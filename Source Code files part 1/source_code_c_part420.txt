yMgrCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CGroupPolicyMgrCF();
    ~CGroupPolicyMgrCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// Strings
//

#define GPM_NAME_PROPERTY      L"name"
#define GPM_OPTIONS_PROPERTY   L"gPOptions"
#define GPM_LINK_PROPERTY      L"gPLink"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\gpobj.cpp ===
//*************************************************************
//  File name: GPOBJ.CPP
//
//  Description:  Group Policy Object class
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************
#include "main.h"

#include "browser.h"
//
// Help ids
//

DWORD aPropertiesHelpIds[] =
{
    IDC_TITLE,                    IDH_PROP_TITLE,
    IDC_DISABLE_COMPUTER,         IDH_PROP_DISABLE_COMPUTER,
    IDC_DISABLE_USER,             IDH_PROP_DISABLE_USER,

    0, 0
};

DWORD aLinkHelpIds[] =
{
    IDC_CBDOMAIN,                 IDH_LINK_DOMAIN,
    IDC_ACTION,                   IDH_LINK_BUTTON,
    IDC_RESULTLIST,               IDH_LINK_RESULT,

    0, 0
};

DWORD aWQLFilterHelpIds[] =
{
    IDC_NONE,                     IDH_WQL_FILTER_NONE,
    IDC_THIS_FILTER,              IDH_WQL_FILTER_THIS_FILTER,
    IDC_FILTER_NAME,              IDH_WQL_FILTER_NAME,
    IDC_FILTER_BROWSE,            IDH_WQL_FILTER_BROWSE,

    0, 0
};

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyObject::CGroupPolicyObject()
{
    InterlockedIncrement(&g_cRefThisDll);

    m_cRef                    = 1;
    m_bInitialized            = FALSE;
    m_pADs                    = NULL;
    m_gpoType                 = GPOTypeLocal;
    m_dwFlags                 = 0;
    m_pName                   = NULL;
    m_pDisplayName            = NULL;
    m_pMachineName            = NULL;
    m_pUser                   = NULL;
    m_pMachine                = NULL;

    m_hinstDSSec              = NULL;
    m_pfnDSCreateSecurityPage = NULL;

    m_pTempFilterString       = NULL;

    m_pDSPath                 = NULL;
    m_pFileSysPath            = NULL;
}

CGroupPolicyObject::~CGroupPolicyObject()
{
    CleanUp();

    if (m_hinstDSSec)
    {
        FreeLibrary (m_hinstDSSec);
    }

    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject object implementation (IUnknown)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CGroupPolicyObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IGroupPolicyObject) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPGROUPPOLICYOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CGroupPolicyObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CGroupPolicyObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CGroupPolicyObject object implementation (IGroupPolicyObject)             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//*************************************************************
//
//  CGroupPolicyObject::New()
//
//  Purpose:    Creates a new GPO in the DS
//
//  Parameters: pszDomainName     -   Domain to create GPO in
//              pszDisplayName    -   GPO friendly name (optional)
//              dwFlags           -   Open / creation flags
//
//  Note:       The domain passed in should be in this format:
//              LDAP://DC=domain,DC=company,DC=COM
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::New (LPOLESTR pszDomainName, LPOLESTR pszDisplayName,
                                      DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrContainer = NULL;
    BSTR bstrGPC = NULL;
    LPTSTR lpResult = NULL, lpDCName = NULL;
    LPTSTR lpEnd = NULL, lpTemp = NULL, lpGPTPath = NULL;
    LPTSTR lpForest = NULL;
    DWORD dwResult;
    GUID guid;
    TCHAR szGPOName[50];
    TCHAR szTemp[100];
    TCHAR szGPOPath[2*MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    IADs *pADs = NULL;
    ULONG ulNoChars;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_INFORMATION si = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                               DACL_SECURITY_INFORMATION);


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Called on an initialized object.")));
        return STG_E_INUSE;
    }


    //
    // Check parameters
    //

    if (!pszDomainName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Null domain name")));
        hr = E_INVALIDARG;
        goto Exit;
    }

    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                       7, pszDomainName, 7) != CSTR_EQUAL)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Domain name does not start with LDAP://")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Entering with:")));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Domain Name:  %s"), pszDomainName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Flags:        0x%x"), dwFlags));

    //
    // Convert the ADSI domain name into a DNS style name
    //

    hr = ConvertToDotStyle (pszDomainName, &lpResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert domain name with 0x%x"), hr));
        goto Exit;
    }

    //
    // If we are working on the enterprise then we need to get the name of the
    // forest.
    //
#if FGPO_SUPPORT
    if (GPO_OPEN_FOREST == (dwFlags & GPO_OPEN_FOREST))
    {
        DWORD dwResult = QueryForForestName(NULL,
                                            lpResult,
                                            DS_PDC_REQUIRED | DS_RETURN_DNS_NAME,
                                            &lpTemp);
        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: QueryForestName failed for domain name %s with %d"),
                      lpResult, dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        int cch = 0;
        int n=0;
        // count the dots in lpTemp;
        while (lpTemp[n])
        {
            if (L'.' == lpTemp[n])
            {
                cch++;
            }
            n++;
        }
        cch *= 3; // multiply the number of dots by 3;
        cch += 11; // add 10 + 1 (for the null)
        cch += n; // add the string size;
        lpForest = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * cch);
        if (!lpForest)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for forest name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        NameToPath(lpForest, lpTemp, cch);

        // substitute the forest's dot path for the domain's dot path
        LocalFree(lpResult);
        lpResult = lpTemp;
        lpTemp = NULL;

        //
        // Check to see if we have a domain path to a specific DC.
        // If we don't then the string will start "LDAP://DC=".
        // The equal sign in particular can only be there if we don't have a specific
        // DC so we'll just check for the equal sign.
        //

        if (*(pszDomainName + 9) != TEXT('='))
        {
            // we have a path to a specific DC
            // need to extract the server path and prepend it to the forest name
            lpDCName = ExtractServerName(pszDomainName);

            if (!lpDCName)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to extract server name for Forest path")));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            lpTemp = MakeFullPath(lpForest, lpDCName);

            if (!lpTemp)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to combine server name with Forest path")));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            // clean up the variables we just borrowed so they can be used later
            LocalFree(lpDCName);
            lpDCName = NULL;
            LocalFree(lpForest);
            lpForest = lpTemp;
            lpTemp = NULL;
        }

        // Substitute the path to the forest for the path to the domain
        pszDomainName = lpForest;
    }
#endif
    //
    // Check to see if we have a domain path to a specific DC.
    // If we don't then the string will start "LDAP://DC=".
    // The equal sign in particular can only be there if we don't have a specific
    // DC so we'll just check for the equal sign.
    //

    if (*(pszDomainName + 9) == TEXT('='))
    {

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomainName, &lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the GPO DC for this domain
        //

        lpDCName = GetDCName (lpTemp, NULL, NULL, FALSE, 0);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to get DC name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Build a fully qualified domain name to a specific DC
        //

        lpTemp = MakeFullPath (pszDomainName, lpDCName);

        if (!lpTemp)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }
    else
    {

        lpDCName = ExtractServerName (pszDomainName);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to extract server name from ADSI path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        ulNoChars = lstrlen(pszDomainName) + 1;
        lpTemp = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));
        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for true domain name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpTemp, ulNoChars, pszDomainName);
        ASSERT(SUCCEEDED(hr));
    }


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create adspathname instance with 0x%x"), hr));
        LocalFree (lpTemp);
        goto Exit;
    }


    //
    // Add the domain name
    //
    BSTR bstrTemp = SysAllocString( lpTemp );
    if ( bstrTemp == NULL )
    {
    	DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for BSTR")));
		LocalFree(lpTemp);
		hr = E_OUTOFMEMORY;
    	goto Exit;
   	}

    hr = pADsPathname->Set (bstrTemp, ADS_SETTYPE_FULL);
    SysFreeString( bstrTemp );
    LocalFree (lpTemp);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }
#if FGPO_SUPPORT
    if (GPO_OPEN_FOREST != (dwFlags & GPO_OPEN_FOREST))
    {
#endif
        //
        // Add the system folder to the path unless we're on the enterprise
        //

        BSTR bstrCNSystem = SysAllocString( TEXT("CN=System") ); 
        if ( bstrCNSystem == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for BSTR")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        hr = pADsPathname->AddLeafElement ( bstrCNSystem );
        SysFreeString( bstrCNSystem );

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
#if FGPO_SUPPORT
    }
    else
    {
        //
        // We're on the enterprise so point at the Configuration folder instead
        //

        BSTR bstrCNConfiguration = SysAllocString(TEXT("CN=Configuration")); 
        if ( bstrCNConfiguration == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for BSTR")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        hr = pADsPathname->AddLeafElement (bstrCNConfiguration);
        SysFreeString( bstrCNConfiguration );

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add system folder with 0x%x"), hr));
            goto Exit;
        }
    }
#endif

    //
    // Retreive the container path - this is the path to the parent of the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create the Policies container
    //

    hr = CreateContainer (bstrContainer, TEXT("Policies"), FALSE);
    if (FAILED(hr))
    {
        if (hr != HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the gpo container with 0x%x"), hr));
            goto Exit;
        }
    }

    SysFreeString (bstrContainer);
    bstrContainer = NULL;


    //
    // Add the policies container to the path
    //

    BSTR bstrCNPolicies = SysAllocString(TEXT("CN=Policies")); 
    if ( bstrCNPolicies == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for BSTR")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrCNPolicies);
    SysFreeString( bstrCNPolicies );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add policies folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path - this is the path to the policies folder
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create a new GPO name (guid)
    //

    if (FAILED(CoCreateGuid(&guid)))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create GUID.")));
        goto Exit;
    }


    if (!StringFromGUID2 (guid, szGPOName, ARRAYSIZE(szGPOName)))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to convert GUID.")));
        goto Exit;
    }


    //
    // Create a container for this GPO
    //

    hr = CreateContainer (bstrContainer, szGPOName, TRUE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the gpo container with 0x%x"), hr));
        goto Exit;
    }

    SysFreeString (bstrContainer);
    bstrContainer = NULL;


    //
    // Add the GPO name to the path
    //

    hr = StringCchCopy (szTemp, ARRAYSIZE(szTemp), TEXT("CN="));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), szGPOName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO name with 0x%x"), hr));
        goto Exit;
    }

    bstrTemp = SysAllocString(szTemp); 
    if ( bstrTemp == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for BSTR")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrTemp);
    SysFreeString( bstrTemp );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to add machine folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the GPC path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrGPC);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: GPO container path is:  %s"), bstrGPC));


    //
    // Now create the machine and user containers
    //

    hr = CreateContainer (bstrGPC, MACHINE_SECTION, FALSE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the machine container with 0x%x"), hr));
        goto Exit;
    }


    hr = CreateContainer (bstrGPC, USER_SECTION, FALSE);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create the user container with 0x%x"), hr));
        goto Exit;
    }


    //
    // Prepare the file system storage on the sysvol
    //
    // Build the name
    //

    hr = StringCchPrintf (szGPOPath, 
                          ARRAYSIZE(szGPOPath), 
                          TEXT("\\\\%s\\SysVol\\%s\\Policies\\%s"), 
                          lpDCName, 
                          lpResult, 
                          szGPOName);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    ulNoChars = lstrlen(szGPOPath) + 1;
    lpGPTPath = (LPTSTR) LocalAlloc(LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpGPTPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to allocate memory for GPT path with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (lpGPTPath, ulNoChars, szGPOPath);
    ASSERT(SUCCEEDED(hr));

    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: File system folder is:  %s"), szGPOPath));


    //
    // Set the security of the sysvol to match the security of the DS
    //
    // First, enable some security privilages so we can set the owner / sacl information
    //

    if (!EnableSecurityPrivs())
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to enable the security privilages with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Bind to the GPO
    //

    hr = OpenDSObject(bstrGPC, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to get gpo IADs interface with 0x%x"), hr));
        (void) SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Get the security descriptor from the DS
    //

    hr = GetSecurityDescriptor (pADs, si, &pSD);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to query the security descriptor with 0x%x"), hr));
        (void) SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Set the security information on the sysvol
    //

    dwResult = SetSysvolSecurity (szGPOPath, si, pSD);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set sysvol security for %s with %d"),
                 szGPOPath, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        (void) SetThreadToken(NULL, NULL);
        goto Exit;
    }


    //
    // Reset the security privilages
    //

    if ( !SetThreadToken(NULL, NULL) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Call to SetThreadToken failed with %d"), GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    lpEnd = CheckSlash(szGPOPath);
    ulNoChars = lstrlen(szGPOPath);

    //
    // Set the initial version number
    //

    hr = StringCchCat (szGPOPath, ARRAYSIZE(szGPOPath), TEXT("GPT.INI"));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }
    
    if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"), TEXT("0"),
                                   szGPOPath))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set initial version number for %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Create the user and machine directories
    //

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szGPOPath) - ulNoChars, MACHINE_SECTION);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create machine file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szGPOPath) - ulNoChars, USER_SECTION);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    if (!CreateNestedDirectory (szGPOPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to create user file system directory %s with %d"),
                 szGPOPath, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Set the GPO specific information
    //
    // Note that we use the nameless form of the sysvol path
    //

    hr = StringCchPrintf (szGPOPath, 
                          ARRAYSIZE(szGPOPath), 
                          TEXT("\\\\%s\\SysVol\\%s\\Policies\\%s"), 
                          lpResult, 
                          lpResult, 
                          szGPOName);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    hr = SetGPOInfo (bstrGPC, pszDisplayName, szGPOPath);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to set GPO information with 0x%x"), hr));
        goto Exit;
    }


    //
    // Call OpenDSGPO to do the loading work
    //

    hr = OpenDSGPO(bstrGPC, dwFlags);


Exit:

    if (lpForest)
    {
        LocalFree (lpForest);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (lpResult)
    {
        LocalFree (lpResult);
    }

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (bstrGPC)
    {
        if (FAILED(hr))
        {
            if (FAILED(DSDelnode(bstrGPC)))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to delete GPC with 0x%x"), hr));
            }
        }

        SysFreeString (bstrGPC);
    }

    if (lpGPTPath)
    {
        if (FAILED(hr))
        {
            if (!Delnode(lpGPTPath))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to delete GPT with %d"),
                         GetLastError()));
            }
        }
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (pADs)
    {
        pADs->Release();
    }

    if (pSD)
    {
        LocalFree (pSD);
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::New: Leaving with a status of  0x%x"), hr));

    return hr;
}


//*************************************************************
//
//  OpenDSGPO()
//
//  Purpose:    Opens a DS Group Policy Object
//
//  Parameters: pszPath - Path to the GPO to open
//              dwFlags - Open / creation flags
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenDSGPO (LPOLESTR pszPath, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    VARIANT var;
    IADsPathname * pADsPathname = NULL;
    IADsObjectOptions *pOptions = NULL;
    BSTR bstrProperty;
    BSTR bstrGPOName = NULL;
    BSTR bstrContainer;
    BSTR bstrDCName;
    TCHAR* szUserKeyName = NULL;
    TCHAR* szMachineKeyName = NULL;
    TCHAR szPath[2*MAX_PATH];
    LPTSTR lpTemp;
    LPTSTR lpEnd;
    LPTSTR pszFullPath = NULL;
    DWORD dwResult;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    DFS_INFO_101 Info101;
    LPTSTR lpDCName = NULL;
    LPOLESTR pszDomain;
    UINT uiSize;
    TCHAR szFormat[10];
    LPTSTR lpNames[2];
    ULONG ulNoChars;
    LPTSTR lpDottedDomainName = NULL;


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }


    //
    // Check parameters
    //

    if (!pszPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: NULL GPO name")));
        return E_INVALIDARG;
    }


    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                       7, pszPath, 7) != CSTR_EQUAL)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: %s does not start with LDAP://"), pszPath));
        hr = E_INVALIDARG;
        goto Exit;
    }


    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Entering with:")));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: GPO Path:  %s"), pszPath));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Flags:  %d"), dwFlags));


    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Retreive the server name if defined
    //

    lpDCName = ExtractServerName (pszPath);

    if (lpDCName)
    {
        pszFullPath = pszPath;
    }
    else
    {
        //
        // Get the domain name
        //

        pszDomain = GetDomainFromLDAPPath(pszPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Get the GPO DC for this domain
        //

        lpDCName = GetDCName (lpTemp, NULL, NULL, FALSE, 0);

        LocalFree (lpTemp);

        if (!lpDCName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get DC name with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        //  Make the fully qualified path
        //

        pszFullPath = MakeFullPath (pszPath, lpDCName);

        if (!pszFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to make full GPO path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Using server %s"), lpDCName));
    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Using fully qualifed pathname of %s"), pszFullPath));


    //
    // Save the DC name
    //

    ulNoChars = lstrlen(lpDCName) + 1;
    m_pMachineName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pMachineName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for machine name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pMachineName, ulNoChars, lpDCName);
    ASSERT(SUCCEEDED(hr));

    //
    // Save the DS path
    //

    ulNoChars = lstrlen(pszFullPath) + 2;
    m_pDSPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pDSPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for ds path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pDSPath, ulNoChars, pszFullPath);
    ASSERT(SUCCEEDED(hr));

    //
    // Bind to the DS object.  Note we hold on to this bind until
    // the object goes away.  This way other ADSI calls will go to
    // the same DC.
    //

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Binding to the object")));

    hr = OpenDSObject(m_pDSPath, IID_IADs, (void **)&m_pADs);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: OpenDSObject failed with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Bound successfully.")));

    //
    // Check if the user has write permission to the GPO
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Checking for write access")));

        hr = CheckDSWriteAccess ((LPUNKNOWN)m_pADs, TEXT("versionNumber"));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: CheckDSWriteAccess failed with 0x%x"), hr));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Write access granted")));
    }

    //
    // Query for the file system path
    //

    bstrProperty = SysAllocString (GPT_PATH_PROPERTY);

    if (!bstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    VariantInit(&var);

    hr = m_pADs->Get(bstrProperty, &var);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to query GPT path with 0x%x"), hr));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        goto Exit;
    }

    ulNoChars = lstrlen(var.bstrVal) + 2;
    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for gpt path")));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pFileSysPath, ulNoChars, var.bstrVal);
    ASSERT(SUCCEEDED(hr));

    SysFreeString (bstrProperty);
    VariantClear (&var);


    //
    // Query for the display name
    //

    bstrProperty = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrProperty)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
        goto Exit;
    }

    VariantInit(&var);

    hr = m_pADs->Get(bstrProperty, &var);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to query for display name with 0x%x"), hr));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        goto Exit;
    }

    ulNoChars = lstrlen(var.bstrVal) + 1;
    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for display name")));
        SysFreeString (bstrProperty);
        VariantClear (&var);
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pDisplayName, ulNoChars, var.bstrVal);
    ASSERT(SUCCEEDED(hr));

    SysFreeString (bstrProperty);
    VariantClear (&var);


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    BSTR bstrDSPath = SysAllocString( m_pDSPath );
    if ( bstrDSPath == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set (bstrDSPath, ADS_SETTYPE_FULL);
    SysFreeString( bstrDSPath );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retrieve the GPO name
    //

    hr = pADsPathname->GetElement (0, &bstrGPOName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to retreive GPO name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Make a copy of the GPO name
    //

    ulNoChars = lstrlen(bstrGPOName) + 1 - 3;
    m_pName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate memory for gpo name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pName, ulNoChars, (bstrGPOName + 3));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Could not copy GPO name")));
        goto Exit;
    }

    //
    // Set the ADSI preferred DC.
    //

    hr = m_pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (SUCCEEDED(hr))
    {
        //
        // Get the domain name
        //

        pszDomain = GetDomainFromLDAPPath(pszPath);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Build a variant containing the domain and dc names
        //

        VariantInit(&var);

        lpNames[0] = lpTemp;
        lpNames[1] = lpDCName;

        hr = ADsBuildVarArrayStr (lpNames, 2, &var);

        LocalFree (lpTemp);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }


        //
        // Set the DC name
        //

        hr = pOptions->SetOption(ADS_PRIVATE_OPTION_SPECIFIC_SERVER, var);

        VariantClear (&var);

        if (FAILED(hr))
        {

            //
            // TODO:  Remove this block after lab03 RI's -- or -- remove post whistler beta2
            //

            if (hr == E_ADS_BAD_PARAMETER)
            {
                //
                // Set the DC name the old way
                //

                VariantInit(&var);
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString (lpDCName);

                if (var.bstrVal)
                {
                    hr = pOptions->SetOption(ADS_PRIVATE_OPTION_SPECIFIC_SERVER, var);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to allocate bstr DCName string")));
                }

                VariantClear (&var);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set private DC name with 0x%x"), hr));
            }
        }

        pOptions->Release();
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get DS object options interface with 0x%x"), hr));
    }


    //
    // Ask the MUP to read/write to this DC's sysvol.
    // We first have to get attributes for the nameless path. This causes the MUP's
    // cache to be initialize if it isn't already.  Then we can tell
    // the MUP which server to use.
    //

    if (!GetFileAttributesEx (m_pFileSysPath, GetFileExInfoStandard, &fad))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: GetFileAttributes for %s FAILED with %d."), m_pFileSysPath, GetLastError()));
    }


    //
    // Now we need to take the full path and trim it down to just
    // domain name \ share
    //

    hr = StringCchCopy (szPath, ARRAYSIZE(szPath), m_pFileSysPath);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Could not copy GPO Path")));
        goto Exit;
    }

    if ((szPath[0] != TEXT('\\')) || (szPath[1] != TEXT('\\')))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Sysvol path doesn't start with \\\\")));
        goto Exit;
    }


    lpTemp = szPath + 2;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to find slash between domain name and share")));
        goto Exit;
    }

    lpTemp++;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
        lpTemp++;

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to find slash between share and directory")));
        goto Exit;
    }

    *lpTemp = TEXT('\0');

    Info101.State = DFS_STORAGE_STATE_ACTIVE;
    dwResult = NetDfsSetClientInfo (szPath, lpDCName,
                                    L"SysVol", 101, (LPBYTE)&Info101);

    if (dwResult != NERR_Success)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to set %s as the active sysvol with %d"),
                 lpDCName, dwResult));
    }


    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Loading registry files")));

        hr = StringCchCopy (szPath, ARRAYSIZE(szPath), m_pFileSysPath);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Could not copy Sysvol path")));
            goto Exit;
        }

        lpEnd = CheckSlash (szPath);
        ulNoChars = lstrlen(szPath);

        //
        // Initialize the user registry (HKCU)
        //

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - ulNoChars, USER_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szPath) - ulNoChars, TEXT("\\Registry.pol"));
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Could not copy Sysvol path")));
            goto Exit;
        }

        //
        // Get the domain name
        //
 
        pszDomain = GetDomainFromLDAPPath(pszPath);
 
        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to get domain name")));
            hr = E_FAIL;
            goto Exit;
        }
 
        //
        // Convert LDAP to dot (DN) style
        //
 
        hr = ConvertToDotStyle (pszDomain, &lpDottedDomainName);
 
        delete [] pszDomain;
 
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to convert domain name with 0x%x"), hr));
            goto Exit;
        }

        GUID    tmpGuid;
        TCHAR   szTmpGuid[50];

        hr = CoCreateGuid(&tmpGuid);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Registry couldn't create guid")));
            goto Exit;
        }

        if (!StringFromGUID2(tmpGuid, szTmpGuid, ARRAYSIZE(szTmpGuid)))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Registry couldn't convert guid to string")));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Mapping Registry to Guid <%s>"), szTmpGuid));


        //
        // The key name  looks like <domain name><a tmp guid><user_section_name>
        //
        
        DWORD  cchUserKeyName = lstrlen( lpDottedDomainName ) + lstrlen( szTmpGuid ) + sizeof(USER_SECTION) / sizeof(WCHAR) + 1;
        szUserKeyName = new TCHAR[ cchUserKeyName ];

        if ( ! szUserKeyName )
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = StringCchCopy (szUserKeyName, cchUserKeyName, lpDottedDomainName );

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szUserKeyName, cchUserKeyName, szTmpGuid);
        }
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szUserKeyName, cchUserKeyName, USER_SECTION);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Could not copy key name")));
            goto Exit;
        }

        hr = m_pUser->Initialize (szPath, szUserKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: User registry failed to initialize")));
            goto Exit;
        }


        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenDSGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - ulNoChars, MACHINE_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szPath) - ulNoChars, TEXT("\\Registry.pol"));
        }

        //
        // The key name  looks like <domain name><a tmp guid><machine_section_name>
        //
        
        DWORD cchMachineKeyName = 0;

        if ( SUCCEEDED(hr) )
        {
            cchMachineKeyName = lstrlen( lpDottedDomainName ) + lstrlen( szTmpGuid ) + sizeof(MACHINE_SECTION) / sizeof(WCHAR) + 1;
            szMachineKeyName = new TCHAR[ cchMachineKeyName ];

            if ( ! szMachineKeyName )
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = StringCchCopy (szMachineKeyName, cchMachineKeyName, lpDottedDomainName);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szMachineKeyName, cchMachineKeyName, szTmpGuid);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szMachineKeyName, cchMachineKeyName, MACHINE_SECTION);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: Could not copy GPO path")));
            goto Exit;
        }


        hr = m_pMachine->Initialize (szPath, szMachineKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }


    //
    // Success
    //

    hr = S_OK;

Exit:

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (bstrGPOName)
    {
        SysFreeString (bstrGPOName);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (lpDottedDomainName)
    {
        LocalFree (lpDottedDomainName );
    }

    if (pszFullPath != pszPath)
    {
        LocalFree (pszFullPath);
    }

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeDS;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    delete [] szUserKeyName;
    
    delete [] szMachineKeyName;

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenDSGPO: Leaving with a status of  0x%x"), hr));

    return hr;
}


//*************************************************************
//
//  OpenLocalMachineGPO()
//
//  Purpose:    Opens this machines GPO
//
//  Parameters: dwFlags - load flags
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenLocalMachineGPO (DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd;
    TCHAR szPath[MAX_PATH];
    TCHAR szFuncVersion[10];
    UINT uRet = 0;
    ULONG ulNoChars;


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }

    
    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Get the path to the local GPO
    //

    ExpandEnvironmentStrings (LOCAL_GPO_DIRECTORY, szBuffer, ARRAYSIZE(szBuffer));


    //
    // Save the file system path
    //

    ulNoChars = lstrlen(szBuffer) + 1;
    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for gpt path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pFileSysPath, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // We disable 32-bit redirection on 64-bit for the local gpo contents -- note 
    // that we do not re-enable it, since these files should always be redirected
    // on this thread
    //

    DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(szBuffer);

    //
    // Create the directory
    //

    uRet = CreateSecureDirectory (szBuffer);
    if (!uRet)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create file system directory %s with %d"),
                 szBuffer, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);


    //
    // Check if the user has write access to the directory
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        hr = CheckFSWriteAccess (szBuffer);

        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: User does not have write access to this GPO (access denied).")));
                goto Exit;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: CheckFSWriteAccess failed with 0x%x"), hr));
            }
        }
    }

    if ( uRet != ERROR_ALREADY_EXISTS )
    {
        hr = StringCchCopy( szPath, ARRAYSIZE(szPath), m_pFileSysPath);
        if (SUCCEEDED(hr)) 
        {
            lpEnd = CheckSlash(szPath);
            hr = StringCchCat( szPath, ARRAYSIZE(szPath), TEXT("gpt.ini") );
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf( szFuncVersion, 
                                  ARRAYSIZE(szFuncVersion), 
                                  TEXT("%d"), 
                                  GPO_FUNCTIONALITY_VERSION );
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
            goto Exit;
        }

        DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(szPath);

        if (!WritePrivateProfileString (TEXT("General"), TEXT("gPCFunctionalityVersion"),
                                        szFuncVersion, szPath))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to write functionality version with 0x%x"), hr));
            goto Exit;
        }
    }

    lpEnd = CheckSlash(szBuffer);
    ulNoChars = lstrlen(szBuffer);


    //
    // Create the user and machine directories
    //

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, MACHINE_SECTION);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(szBuffer);

    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create machine subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, USER_SECTION);
    if (FAILED(hr))
    {    
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
        goto Exit;
    }

    DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(szBuffer);

    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create user subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Load the GPO name
    //

    LoadString (g_hInstance, IDS_LOCAL_NAME, szBuffer, ARRAYSIZE(szBuffer));

    ulNoChars = lstrlen(szBuffer) + 2;
    m_pName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pName, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // Load the display name
    //

    LoadString (g_hInstance, IDS_LOCAL_DISPLAY_NAME, szBuffer, ARRAYSIZE(szBuffer));

    ulNoChars = lstrlen(szBuffer) + 2;
    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pDisplayName, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), m_pFileSysPath);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
            goto Exit;
        }

        lpEnd = CheckSlash (szBuffer);
        ulNoChars = lstrlen(szBuffer);

        //
        // Initialize the user registry (HKCU)
        //
        GUID    tmpGuid;
        TCHAR   szTmpGuid[50];

        hr = CoCreateGuid(&tmpGuid);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Registry couldn't create guid")));
            goto Exit;
        }

        if (!StringFromGUID2(tmpGuid, szTmpGuid, ARRAYSIZE(szTmpGuid)))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Registry couldn't convert guid to string")));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Mapping Registry to Guid <%s>"), szTmpGuid));

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, USER_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, TEXT("\\Registry.pol"));
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCopy (szKeyName, ARRAYSIZE(szKeyName), szTmpGuid);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szKeyName, ARRAYSIZE(szKeyName), USER_SECTION);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
            goto Exit;
        }

        hr = m_pUser->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: User registry failed to initialize")));
            goto Exit;
        }


        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, MACHINE_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, TEXT("\\Registry.pol"));
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCopy (szKeyName, ARRAYSIZE(szKeyName), szTmpGuid);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szKeyName, ARRAYSIZE(szKeyName), MACHINE_SECTION);
        }
        
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenLocalMachineGPO: Could not copy GPO path with 0x%x"), hr));
            goto Exit;
        }

        hr = m_pMachine->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }

    //
    // Success
    //

    hr = S_OK;

Exit:

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeLocal;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    return hr;
}


//*************************************************************
//
//  OpenRemoteMachineGPO()
//
//  Purpose:    Opens a remote machines GPO
//              dwFlags - load flags
//
//  Parameters: pszComputerName - name of computer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::OpenRemoteMachineGPO (LPOLESTR pszComputerName,
                                                       DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    TCHAR szComputerName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szKeyName[100];
    LPTSTR lpEnd;
    TCHAR szPath[MAX_PATH];
    TCHAR szFuncVersion[10];
    UINT uRet = 0;
    ULONG ulNoChars;


    //
    // Check if this object has already been initialized
    //

    if (m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Called on an uninitialized object.")));
        return STG_E_INUSE;
    }

    //
    // Check parameters
    //

    if (!pszComputerName)
        return E_INVALIDARG;


    //
    // Save the flags
    //

    m_dwFlags = dwFlags;


    //
    // Parse the computer name
    //

    if ((pszComputerName[0] == TEXT('\\')) && (pszComputerName[1] == TEXT('\\')))
    {
        hr = StringCchCopy (szComputerName, ARRAYSIZE(szComputerName), pszComputerName+2);
    }
    else
    {
        hr = StringCchCopy (szComputerName, ARRAYSIZE(szComputerName), pszComputerName);
    }

    if (FAILED(hr)) 
    {
        return hr;
    }


    //
    // Save the machine name
    //

    ulNoChars = lstrlen(szComputerName) + 1;
    m_pMachineName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pMachineName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for machine name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pMachineName, ulNoChars, szComputerName);
    ASSERT(SUCCEEDED(hr));

    //
    // Get the path to the local GPO
    //

    hr = StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), REMOTE_GPO_DIRECTORY, szComputerName);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy path to local GPO")));
        goto Exit;
    }


    //
    // Save the file system path
    //

    ulNoChars = lstrlen(szBuffer) + 1;
    m_pFileSysPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pFileSysPath)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for gpt path")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pFileSysPath, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // Create the directory
    //

    uRet = CreateSecureDirectory (szBuffer);
    if (!uRet)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create file system directory %s with %d"),
                 szBuffer, GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    SetFileAttributes (szBuffer, FILE_ATTRIBUTE_HIDDEN);


    //
    // Check if the user has write access to the directory
    //

    if (!(m_dwFlags & GPO_OPEN_READ_ONLY))
    {
        hr = CheckFSWriteAccess (szBuffer);

        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: User does not have write access to this GPO (access denied).")));
                goto Exit;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: CheckFSWriteAccess failed with 0x%x"), hr));
            }
        }
    }

    if ( uRet != ERROR_ALREADY_EXISTS )
    {
        hr = StringCchCopy ( szPath, ARRAYSIZE(szPath), m_pFileSysPath );
        if (SUCCEEDED(hr)) 
        {
            lpEnd = CheckSlash(szPath);
            hr = StringCchCat ( szPath, ARRAYSIZE(szPath), TEXT("gpt.ini") );
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf( szFuncVersion, ARRAYSIZE(szFuncVersion), TEXT("%d"), GPO_FUNCTIONALITY_VERSION );
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
            goto Exit;
        }

        if (!WritePrivateProfileString (TEXT("General"), TEXT("gPCFunctionalityVersion"),
                                        szFuncVersion, szPath))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to write functionality version with 0x%x"), hr));
            goto Exit;
        }
    }

    lpEnd = CheckSlash(szBuffer);
    ulNoChars = lstrlen(szBuffer);

    //
    // Create the user and machine directories
    //

    hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), MACHINE_SECTION);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
        goto Exit;
    }

    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create machine subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, USER_SECTION);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
        goto Exit;
    }

    if (!CreateNestedDirectory (szBuffer, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create user subdirectory with %d"),
                  GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }



    //
    // Load the GPO name
    //

    ulNoChars = lstrlen(szComputerName) + 2;
    m_pName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pName, ulNoChars, szComputerName);
    ASSERT(SUCCEEDED(hr));

    //
    // Load the display name
    //

    ulNoChars = lstrlen(szComputerName) + 2;
    m_pDisplayName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_pDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = StringCchCopy (m_pDisplayName, ulNoChars, szComputerName);
    ASSERT(SUCCEEDED(hr));

    //
    // Now load the registry information
    //

    if (m_dwFlags & GPO_OPEN_LOAD_REGISTRY)
    {
        hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), m_pFileSysPath);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
            goto Exit;
        }
        
        lpEnd = CheckSlash (szBuffer);
        ulNoChars = lstrlen(szBuffer);

        GUID    tmpGuid;
        TCHAR szTmpGuid[50];

        hr = CoCreateGuid(&tmpGuid);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Registry couldn't create guid")));
            goto Exit;
        }

        if (!StringFromGUID2(tmpGuid, szTmpGuid, ARRAYSIZE(szTmpGuid)))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Registry couldn't convert guid to string")));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Mapping Registry to Guid <%s>"), szTmpGuid));

        //
        // Initialize the user registry (HKCU)
        //

        m_pUser = new CRegistryHive();

        if (!m_pUser)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create User registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, USER_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, TEXT("\\Registry.pol"));
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCopy (szKeyName, ARRAYSIZE(szKeyName), szTmpGuid);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szKeyName, ARRAYSIZE(szKeyName), USER_SECTION);
        }
        
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
            goto Exit;
        }

        hr = m_pUser->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: User registry failed to initialize")));
            goto Exit;
        }
        
        //
        // Initialize the machine registry (HKLM)
        //

        m_pMachine = new CRegistryHive();

        if (!m_pMachine)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Failed to create machine registry")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, MACHINE_SECTION);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpEnd, ARRAYSIZE(szBuffer) - ulNoChars, TEXT("\\Registry.pol"));
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCopy (szKeyName, ARRAYSIZE(szKeyName), szTmpGuid);
        }

        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (szKeyName, ARRAYSIZE(szKeyName), MACHINE_SECTION);
        }
        
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
            goto Exit;
        }
        
        hr = m_pMachine->Initialize (szBuffer, szKeyName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::InitializeGPT: machine registry failed to initialize")));
            goto Exit;
        }
    }

    //
    // Success
    //

    hr = S_OK;

Exit:

    if (SUCCEEDED(hr))
    {
        m_gpoType      = GPOTypeRemote;
        m_bInitialized = TRUE;
    } else {
        CleanUp();
    }

    return hr;

}


//*************************************************************
//
//  Save()
//
//  Purpose:    Saves the registry information and bumps the
//              version number
//
//  Parameters: none
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::Save (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin)
{
    HRESULT hr;
    TCHAR szPath[2*MAX_PATH];
    TCHAR szVersion[25];
    ULONG ulVersion, ulOriginal;
    USHORT uMachine, uUser;
    BSTR bstrName;
    VARIANT var;
    GUID RegistryGuid = REGISTRY_EXTENSION_GUID;
    BOOL bEmpty;


    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::Save: Entering with bMachine = %d and bAdd = %d"),
              bMachine, bAdd));

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }

    if ( pGuidExtension == 0 || pGuidSnapin == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: One of the guids is null")));
        return ERROR_INVALID_PARAMETER;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Called on a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }

    //
    // Save registry settings
    //

    if (!CompareGuid (pGuidExtension, &RegistryGuid))
    {
        if (bMachine)
        {
            if (m_pMachine)
            {
                hr = m_pMachine->Save();

                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to save the machine registry with 0x%x"), hr));
                    return hr;
                }

                hr = m_pMachine->IsRegistryEmpty(&bEmpty);

                if (SUCCEEDED(hr) && bEmpty)
                {
                    bAdd = FALSE;
                }
                else
                {
                    bAdd = TRUE;
                }
            }
        }
        else
        {
            if (m_pUser)
            {
                hr = m_pUser->Save();

                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to save the user registry with 0x%x"), hr));
                    return hr;
                }

                hr = m_pUser->IsRegistryEmpty(&bEmpty);

                if (SUCCEEDED(hr) && bEmpty)
                {
                    bAdd = FALSE;
                }
                else
                {
                    bAdd = TRUE;
                }
            }
        }
    }


    XPtrST<TCHAR> xValueIn;
    hr = GetProperty( bMachine ? GPO_MACHEXTENSION_NAMES
                               : GPO_USEREXTENSION_NAMES,
                      xValueIn );
    if ( FAILED(hr) )
    {
       DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to GetProperty with 0x%x"), hr));
       return hr;
    }

    CGuidList guidList;

    hr = guidList.UnMarshallGuids( xValueIn.GetPointer() );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to unmarshall guids with 0x%x"), hr));
        return hr;
    }

    hr = guidList.Update( bAdd, pGuidExtension, pGuidSnapin );
    if ( FAILED(hr) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to update with 0x%x"), hr));
        return hr;
    }

    if ( guidList.GuidsChanged() )
    {
        XPtrST<TCHAR> xValueOut;

        hr = guidList.MarshallGuids( xValueOut );
        if ( FAILED(hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to marshall guids with 0x%x"), hr));
            return hr;
        }

        hr = SetProperty( bMachine ? GPO_MACHEXTENSION_NAMES
                                   : GPO_USEREXTENSION_NAMES,
                          xValueOut.GetPointer() );
        if ( FAILED(hr ) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to set property guids with 0x%x"), hr));
            return hr;
        }
    }

    //
    // Get the current version number
    //

    hr = StringCchCopy (szPath, ARRAYSIZE(szPath), m_pFileSysPath);
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("\\GPT.INI"));
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO Path")));
        return hr;
    }

    if (m_gpoType == GPOTypeDS)
    {

        bstrName = SysAllocString (GPO_VERSION_PROPERTY);

        if (!bstrName)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to allocate memory")));
            return E_OUTOFMEMORY;
        }

        VariantInit(&var);
        hr = m_pADs->Get(bstrName, &var);

        if (SUCCEEDED(hr))
        {
            ulOriginal = var.lVal;
        }

        SysFreeString (bstrName);
        VariantClear (&var);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to get ds version number with 0x%x"), hr));
            return hr;
        }
    }
    else
    {
        //
        // We disable 32-bit redirection on 64-bit for the local gpt.ini -- note 
        // that we do not re-enable it, since this file should always be redirected
        // on this thread
        //

        DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(szPath)

        ulOriginal = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szPath);
    }


    //
    // Separate the user and machine version numbers
    //

    uUser = (USHORT) HIWORD(ulOriginal);
    uMachine = (USHORT) LOWORD(ulOriginal);


    //
    // Increment the version number
    //

    if (bMachine)
    {
        uMachine = uMachine + 1;

        if (uMachine == 0)
            uMachine++;
    }
    else
    {
        uUser = uUser + 1;

        if (uUser == 0)
            uUser++;
    }


    //
    // Put the version number back together
    //

    ulVersion = (ULONG) MAKELONG (uMachine, uUser);


    //
    // Update version number in the GPT
    //

    hr = StringCchPrintf (szVersion, ARRAYSIZE(szVersion), TEXT("%d"), ulVersion);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO version")));
        return hr;
    }

    if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"),
                                   szVersion, szPath))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to write sysvol version number with %d"),
                 GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // Put the original version number in szVersion in case
    // we need to roll backwards below
    //

    hr = StringCchPrintf (szVersion, ARRAYSIZE(szVersion), TEXT("%d"), ulOriginal);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::OpenRemoteMachineGPO: Could not copy GPO original version")));
        return hr;
    }


    //
    // Set the version number in the GPC
    //

    if (m_gpoType == GPOTypeDS)
    {
        bstrName = SysAllocString (GPO_VERSION_PROPERTY);

        if (bstrName)
        {
            VariantInit(&var);
            var.vt = VT_I4;
            var.lVal = ulVersion;

            hr = m_pADs->Put(bstrName, var);

            VariantClear (&var);
            SysFreeString (bstrName);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to allocate memory")));
            hr = E_OUTOFMEMORY;
        }


        if (SUCCEEDED(hr))
        {
            //
            // Commit the changes
            //

            hr = m_pADs->SetInfo();

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to commit version number update with 0x%x"), hr));
                if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"),
                                                szVersion, szPath))
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to reset the sysvol version number with %d"),
                             GetLastError()));
                }
            }

        } else {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to update version number with 0x%x"), hr));
            if (!WritePrivateProfileString (TEXT("General"), TEXT("Version"), szVersion, szPath))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Save: Failed to reset the sysvol version number with %d"),
                         GetLastError()));
            }

        }
    }


    //
    // If we are editing the local group policy object, then call
    // RefreshGroupPolicy() so that the end user can see the results
    // immediately.
    //

    if (m_gpoType == GPOTypeLocal)
    {
        RefreshGroupPolicy (bMachine);
    }

    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::Save: Leaving with 0x%x"), hr));

    return hr;
}

//*************************************************************
//
//  Delete()
//
//  Purpose:    Deletes this Group Policy Object
//
//  Parameters: none
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::Delete (void)
{
    HRESULT hr;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Delete called on a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    //
    // Unmount the registry information
    //

    if (m_pUser)
    {
        m_pUser->Release();
        m_pUser = NULL;
    }

    if (m_pMachine)
    {
        m_pMachine->Release();
        m_pMachine = NULL;
    }


    //
    // Clean out the DS stuff
    //

    if (m_gpoType == GPOTypeDS)
    {
        hr = DSDelnode (m_pDSPath);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Failed to delete DS storage with 0x%x"), hr));
            goto Exit;
        }
    }


    //
    // Delete the file system stuff
    //

    if (Delnode (m_pFileSysPath))
    {
        hr = S_OK;
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::Delete: Failed to delete file system storage with %d"),
                GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    if (SUCCEEDED(hr))
    {
        CleanUp();
    }


Exit:

    return hr;
}


//*************************************************************
//
//  GetName()
//
//  Purpose:    Gets the unique GPO name
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetName (LPOLESTR pszName, int cchMaxLength)
{

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    //
    // Save the name
    //

    if ((lstrlen (m_pName) + 1) <= cchMaxLength)
    {
        HRESULT hr;

        hr = StringCchCopy (pszName, cchMaxLength, m_pName);
        return hr;
    }

    return E_OUTOFMEMORY;
}

//*************************************************************
//
//  GetDisplayName()
//
//  Purpose:    Gets the friendly name for this GPO
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetDisplayName (LPOLESTR pszName, int cchMaxLength)
{

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if ((lstrlen (m_pDisplayName) + 1) <= cchMaxLength)
    {
        HRESULT hr;

        hr = StringCchCopy (pszName, cchMaxLength, m_pDisplayName);
        return hr;
    }

    return E_OUTOFMEMORY;
}

//+--------------------------------------------------------------------------
//
//  Member:     CGroupPolicyObject::SetDisplayName
//
//  Synopsis:   changes the friendly display name for a group policy object
//
//  Arguments:  [pszName] - new name (can be NULL to clear name)
//
//  Returns:    S_OK - success
//
//  Modifies:
//
//  Derivation:
//
//  History:    05-002-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

STDMETHODIMP CGroupPolicyObject::SetDisplayName (LPOLESTR lpDisplayName)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName;
    VARIANT var;
    LPOLESTR lpNewName;
    LPTSTR lpPath, lpEnd;
    DWORD dwSize;


    //
    // Check parameters
    //

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if (m_gpoType != GPOTypeDS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: Called for a non DS GPO")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    if (!lpDisplayName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: NULL display name")));
        hr = E_INVALIDARG;
        goto Exit;
    }


    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayName: Called for a READ ONLY GPO")));
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }


    //
    // Call the internal method to set the display name
    //

    hr = SetDisplayNameI (m_pADs, lpDisplayName, m_pFileSysPath, TRUE);


Exit:

    return hr;
}

//*************************************************************
//
//  GetPath()
//
//  Purpose:    Returns the path to the GPO
//
//              If the GPO is in the DS, this is an DN path
//              If the GPO is machine based, it is a file system path
//
//  Parameters: pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetPath (LPOLESTR pszPath, int cchMaxLength)
{
    LPTSTR lpTemp;

    //
    // Check parameters
    //

    if (!pszPath || (cchMaxLength <= 0))
        return E_INVALIDARG;

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if (m_gpoType == GPOTypeDS)
    {
        lpTemp = MakeNamelessPath (m_pDSPath);

        if (lpTemp)
        {
            if ((lstrlen (lpTemp) + 1) <= cchMaxLength)
            {
                HRESULT hr;

                hr = StringCchCopy (pszPath, cchMaxLength, lpTemp);
                LocalFree (lpTemp);
                return hr;
            }

            LocalFree (lpTemp);
        }
    }
    else
    {
        if ((lstrlen (m_pFileSysPath) + 1) <= cchMaxLength)
        {
            HRESULT hr;

            hr = StringCchCopy (pszPath, cchMaxLength, m_pFileSysPath);
            return hr;
        }
    }

    return E_OUTOFMEMORY;
}


//*************************************************************
//
//  GetDSPath()
//
//  Purpose:    Returns a DS path to the requested section
//
//  Parameters: dwSection identifies root vs user vs machine
//              pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetDSPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    HRESULT hr = E_FAIL;
    BSTR bstrPath = NULL;
    TCHAR szTemp[100];
    IADsPathname * pADsPathname = NULL;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    //
    // Check parameters
    //

    if (!pszPath || (cchMaxPath <= 0))
        return E_INVALIDARG;


    if ((dwSection != GPO_SECTION_ROOT) &&
        (dwSection != GPO_SECTION_USER) &&
        (dwSection != GPO_SECTION_MACHINE))
        return E_INVALIDARG;


    //
    // If this is a local or remote machine GPO, then the
    // caller gets an empty string back.
    //

    if (m_gpoType != GPOTypeDS)
    {
        *pszPath = TEXT('\0');
        hr = S_OK;
        goto Exit;
    }


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the GPO name
    //

    BSTR bstrDSPath = SysAllocString( m_pDSPath );
    if ( bstrDSPath == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set (bstrDSPath, ADS_SETTYPE_FULL);
    SysFreeString( bstrDSPath );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the appropriate subcontainer
    //

    if (dwSection != GPO_SECTION_ROOT)
    {
        hr = StringCchCopy (szTemp, ARRAYSIZE(szTemp), TEXT("CN="));
        if (SUCCEEDED(hr)) 
        {
            if (dwSection == GPO_SECTION_USER)
            {
                hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), USER_SECTION);
            }
            else
            {
                hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), MACHINE_SECTION);
            }
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Could not copy GPO path with 0x%x"), hr));
            goto Exit;
        }

        BSTR bstrTemp = SysAllocString( szTemp );
        if ( bstrTemp == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to allocate BSTR memory")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        hr = pADsPathname->AddLeafElement (bstrTemp);
        SysFreeString( bstrTemp );
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to add subcontainer with 0x%x"), hr));
            goto Exit;
        }
    }


    hr = pADsPathname->Retrieve (ADS_FORMAT_X500_NO_SERVER, &bstrPath);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetDSPath: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    if ((lstrlen(bstrPath) + 1) <= cchMaxPath)
    {
        hr = StringCchCopy (pszPath, cchMaxPath, bstrPath);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    SysFreeString (bstrPath);


Exit:

    if (pADsPathname)
    {
        pADsPathname->Release();
    }


    return hr;
}


//*************************************************************
//
//  GetFileSysPath()
//
//  Purpose:    Returns the file system path to the requested section
//
//  Parameters: dwSection identifies user vs machine
//              pszPath is a pointer to a buffer which receives the path
//              cchMaxLength is the max size of the buffer
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetFileSysPath (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath)
{
    TCHAR szPath[2*MAX_PATH];
    HRESULT hr;


    //
    // Check parameters
    //

    if (!pszPath || (cchMaxPath <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    hr = StringCchCopy (szPath, ARRAYSIZE(szPath), m_pFileSysPath);
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (dwSection != GPO_SECTION_ROOT)
    {
        if (dwSection == GPO_SECTION_USER)
        {
            (void) CheckSlash (szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), USER_SECTION);
        }
        else if (dwSection == GPO_SECTION_MACHINE)
        {
            (void) CheckSlash (szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), MACHINE_SECTION);
        }
        else
        {
            return E_INVALIDARG;
        }

        if (FAILED(hr)) 
        {
            return hr;
        }
    }


    if ((lstrlen(szPath) + 1) <= cchMaxPath)
    {
       hr = StringCchCopy (pszPath, cchMaxPath, szPath);
       return hr;
    }

    return E_OUTOFMEMORY;
}

//*************************************************************
//
//  GetRegistryKey()
//
//  Purpose:    Returns the requested registry key
//
//  Parameters: dwSection identifies user vs machine
//              hKey receives the opened registry key
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetRegistryKey (DWORD dwSection, HKEY *hKey)
{
    HRESULT hr = E_FAIL;

    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    switch (dwSection)
    {
        case GPO_SECTION_USER:
            if (m_pUser)
            {
                hr = m_pUser->GetHKey(hKey);
            }
            break;

        case GPO_SECTION_MACHINE:
            if (m_pMachine)
            {
                hr = m_pMachine->GetHKey(hKey);
            }
            break;
    }

    return (hr);
}

//*************************************************************
//
//  GetOptions()
//
//  Purpose:    Gets the GPO options
//
//  Parameters: dwOptions receives the options
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetOptions (DWORD * dwOptions)
{
    HRESULT hr;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }


    //
    // Check argument
    //

    if (!dwOptions)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Received a NULL ptr.")));
        return E_INVALIDARG;
    }


    //
    // If this is a DS GPO, the options are stored as a property on the
    // GPC.  If this a machine GPO, they are in the gpt.ini file.
    //

    if (m_gpoType == GPOTypeDS)
    {
        VARIANT var;
        BSTR bstrProperty;

        //
        // Query for the options
        //

        bstrProperty = SysAllocString (GPO_OPTIONS_PROPERTY);

        if (bstrProperty)
        {
            VariantInit(&var);

            hr = m_pADs->Get(bstrProperty, &var);

            if (SUCCEEDED(hr))
            {
                *dwOptions = var.lVal;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to query for options with 0x%x"), hr));
            }

            VariantClear (&var);
            SysFreeString (bstrProperty);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to allocate memory")));
            hr = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];
        LPTSTR lpEnd;


        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Failed to get path with 0x%x"), hr));
            return hr;
        }


        //
        // Tack on gpt.ini
        //

        lpEnd = CheckSlash (szPath);
        hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("GPT.INI"));
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Could not copy GPO path with 0x%x"), hr));
            return hr;
        }

        //
        // Get the options
        //

        *dwOptions = GetPrivateProfileInt (TEXT("General"), TEXT("Options"),
                                           0, szPath);

        hr = S_OK;
    }


    return hr;
}

//*************************************************************
//
//  SetOptions()
//
//  Purpose:    Sets the GPO options
//
//  Parameters: dwOptions is the new options
//              dwMask states which options should be set
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::SetOptions (DWORD dwOptions, DWORD dwMask)
{
    HRESULT hr;
    DWORD dwResult = 0, dwOriginal;


    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }

    if (m_dwFlags & GPO_OPEN_READ_ONLY)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Called for a READ ONLY GPO")));
        return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }


    //
    // Query for the current options
    //

    hr = GetOptions (&dwResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to get previous options with 0x%x"), hr));
        return hr;
    }


    //
    // Save the original options so we can compare later
    //

    dwOriginal = dwResult;


    //
    // Check for the machine disabled option
    //

    if (dwMask & GPO_OPTION_DISABLE_MACHINE)
    {
        if (dwOptions & GPO_OPTION_DISABLE_MACHINE)
        {
            dwResult |= GPO_OPTION_DISABLE_MACHINE;
        }
        else
        {
            dwResult &= ~GPO_OPTION_DISABLE_MACHINE;
        }
    }


    //
    // Check for the user disabled option
    //

    if (dwMask & GPO_OPTION_DISABLE_USER)
    {
        if (dwOptions & GPO_OPTION_DISABLE_USER)
        {
            dwResult |= GPO_OPTION_DISABLE_USER;
        }
        else
        {
            dwResult &= ~GPO_OPTION_DISABLE_USER;
        }
    }


    //
    // If something changed, set the options back in the GPO
    //

    if (dwResult != dwOriginal)
    {

        //
        // Set the options in the DS or gpt.ini as appropriate
        //

        if (m_gpoType == GPOTypeDS)
        {
            VARIANT var;
            BSTR bstrName;

            bstrName = SysAllocString (GPO_OPTIONS_PROPERTY);

            if (bstrName)
            {
                VariantInit(&var);
                var.vt = VT_I4;
                var.lVal = dwResult;

                hr = m_pADs->Put(bstrName, var);

                VariantClear (&var);
                SysFreeString (bstrName);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to allocate memory")));
                hr = ERROR_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pADs->SetInfo();
            }

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to set options with 0x%x"), hr));
            }
        }
        else
        {
            TCHAR szPath[2*MAX_PATH];
            TCHAR szOptions[20];
            LPTSTR lpEnd;


            //
            // Get the file system path
            //

            hr = GetPath (szPath, ARRAYSIZE(szPath));

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to get path with 0x%x"), hr));
                return hr;
            }


            //
            // Tack on gpt.ini
            //

            lpEnd = CheckSlash (szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("GPT.INI"));
            if (FAILED(hr)) 
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetOptions: Could not copy GPO path with 0x%x"), hr));
                return hr;
            }

            //
            // Convert the options to string format
            //

            _itot (dwResult, szOptions, 10);


            //
            // Set the options
            //

            if (!WritePrivateProfileString (TEXT("General"), TEXT("Options"),
                                            szOptions, szPath))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetOptions: Failed to set options with 0x%x"), hr));
                return hr;
            }


            //
            // If this is the local GPO, trigger a policy refresh if appropriate
            //

            if (m_gpoType == GPOTypeLocal)
            {
                RefreshGroupPolicy (TRUE);
                RefreshGroupPolicy (FALSE);
            }

            hr = S_OK;

        }
    }
    else
    {
        hr = S_OK;
    }


    return hr;
}

//*************************************************************
//
//  GetType()
//
//  Purpose:    Gets the GPO type
//
//  Parameters: gpoType receives the type
//
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetType (GROUP_POLICY_OBJECT_TYPE *gpoType)
{

    //
    // Check for initialization
    //

    if (!m_bInitialized)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetType: Called on an uninitialized object.")));
        return OLE_E_BLANK;
    }


    //
    // Check argument
    //

    if (!gpoType)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetType: Received a NULL ptr.")));
        return E_INVALIDARG;
    }


    //
    // Store type
    //

    *gpoType = m_gpoType;

    return S_OK;
}

//*************************************************************
//
//  GetMachineName()
//
//  Purpose:    Gets the machine name of the remote GPO
//
//  Parameters: pszName is a pointer to a buffer which receives the name
//              cchMaxLength is the max size of the buffer
//
//  Note:       This method returns the name passed to OpenRemoteMachineGPO
//
//  Return:     S_OK if successful
//
//*************************************************************

STDMETHODIMP CGroupPolicyObject::GetMachineName (LPOLESTR pszName, int cchMaxLength)
{
    HRESULT hr = S_OK;

    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }


    if (m_pMachineName)
    {
        //
        // Save the name
        //

        if ((lstrlen (m_pMachineName) + 1) <= cchMaxLength)
        {
            hr = StringCchCopy (pszName, cchMaxLength, m_pMachineName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        *pszName = TEXT('\0');
    }

    return hr;
}

BOOL
EnableWMIFilters( LPWSTR );

//*************************************************************
//
//  GetPropertySheetPages()
//
//  Purpose:    Returns an array of property sheet pages for
//              the callee to use.  The callee needs to free
//              the buffer with LocalFree when finished.
//
//  Parameters: hPages receives a pointer to an array of page handles
//              uPageCount receives the number of pages in hPages
//
//  Return:     S_OK if successful
//
//*************************************************************


STDMETHODIMP CGroupPolicyObject::GetPropertySheetPages (HPROPSHEETPAGE **hPages,
                                                        UINT *uPageCount)
{
    HPROPSHEETPAGE hTempPages[4];
    HPROPSHEETPAGE *lpPages;
    PROPSHEETPAGE psp;
    UINT i, uTempPageCount = 0;
    HRESULT hr;


    //
    // Create the General property sheet
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPERTIES);
    psp.pfnDlgProc = PropertiesDlgProc;
    psp.lParam = (LPARAM) this;

    hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

    if (!hTempPages[uTempPageCount])
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                 GetLastError()));
        return E_FAIL;
    }

    uTempPageCount++;


    //
    // If this is a DS GPO, then create the links, DS security, and WMI filter pages
    //

    if (m_gpoType == GPOTypeDS)
    {
        // Create the search for links page
        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_GPE_LINKS);
        psp.pfnDlgProc = GPELinksDlgProc;
        psp.lParam = (LPARAM) this;

        hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

        if (!hTempPages[uTempPageCount])
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            // destroy the previous prop page
            DestroyPropertySheetPage(hTempPages[uTempPageCount - 1]);
            return E_FAIL;
        }

        uTempPageCount++;

        //
        // Load DSSec.dll
        //

        if (!m_hinstDSSec)
        {
            m_hinstDSSec = LoadLibrary (TEXT("dssec.dll"));
        }

        if (m_hinstDSSec)
        {

            if (!m_pfnDSCreateSecurityPage)
            {
                m_pfnDSCreateSecurityPage = (PFNDSCREATESECPAGE) GetProcAddress (
                                                    m_hinstDSSec, "DSCreateSecurityPage");
            }

            if (m_pfnDSCreateSecurityPage)
            {

                //
                // Call DSCreateSecurityPage
                //

                hr = m_pfnDSCreateSecurityPage (m_pDSPath, L"groupPolicyContainer",
                                                DSSI_IS_ROOT | ((m_dwFlags & GPO_OPEN_READ_ONLY) ? DSSI_READ_ONLY : 0),
                                                &hTempPages[uTempPageCount],
                                                ReadSecurityDescriptor,
                                                WriteSecurityDescriptor, (LPARAM)this);

                if (SUCCEEDED(hr))
                {
                    uTempPageCount++;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create DS security page with 0x%x."), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to get function entry point with %d."), GetLastError()));
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CComponentData::CreatePropertyPages: Failed to load dssec.dll with %d."), GetLastError()));
        }

        if ( EnableWMIFilters( m_pDSPath ) )
        {
            // Create the WQL filter page
            psp.dwSize = sizeof(PROPSHEETPAGE);
            psp.dwFlags = 0;
            psp.hInstance = g_hInstance;
            psp.pszTemplate = MAKEINTRESOURCE(IDD_WQLFILTER);
            psp.pfnDlgProc = WQLFilterDlgProc;
            psp.lParam = (LPARAM) this;

            hTempPages[uTempPageCount] = CreatePropertySheetPage(&psp);

            if (!hTempPages[uTempPageCount])
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetPropertySheetPages: Failed to create property sheet page with %d."),
                         GetLastError()));

                for (i=0; i < uTempPageCount; i++)
                {
                    DestroyPropertySheetPage(hTempPages[i]);
                }
                return E_FAIL;
            }

            uTempPageCount++;
        }
    }



    //
    // Save the results
    //

    lpPages = (HPROPSHEETPAGE *)LocalAlloc (LPTR, sizeof(HPROPSHEETPAGE) * uTempPageCount);

    if (!lpPages)
    {
        for (i=0; i < uTempPageCount; i++)
        {
            DestroyPropertySheetPage(hTempPages[i]);
        }

        return E_OUTOFMEMORY;
    }


    for (i=0; i < uTempPageCount; i++)
    {
        lpPages[i] = hTempPages[i];
    }

    *hPages = lpPages;
    *uPageCount = uTempPageCount;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal methods                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CGroupPolicyObject::CreateContainer (LPOLESTR lpParent,
                                                  LPOLESTR lpCommonName,
                                                  BOOL bGPC)
{
    HRESULT hr = E_FAIL;
    VARIANT var;
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrProvider = NULL;
    BSTR bstrName = NULL;
    TCHAR szTemp[MAX_PATH];

    // test to see if the container already exists
    {
        szTemp[0] = 0;
        // scan lpParent to find the first instance of "CN="
        LPTSTR lpSub = StrStr(lpParent, TEXT("CN="));
        // insert CN=lpCommonName at that point
        if (lpSub)
        {
            lstrcpyn(szTemp, lpParent, ((int)(lpSub - lpParent)) + 1);
            
            hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), TEXT("CN="));
            if (SUCCEEDED(hr)) 
            {
                hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), lpCommonName);
            }

            if (SUCCEEDED(hr)) 
            {
                hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), TEXT(","));
            }

            if (SUCCEEDED(hr)) 
            {
                hr = StringCchCat(szTemp, ARRAYSIZE(szTemp), lpSub);
            }

            if (FAILED(hr)) 
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Could not copy container name with 0x%x"), hr));
                goto Exit;
            }

        }

        BSTR bstrTemp = SysAllocString( szTemp );
        if ( bstrTemp == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate BSTR memory")));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        hr = OpenDSObject(bstrTemp, IID_IADsContainer, (void **)&pADsContainer);
        SysFreeString( bstrTemp );

        if (SUCCEEDED(hr))
        {
            hr = ERROR_OBJECT_ALREADY_EXISTS;
            goto Exit;
        }
    }

    //
    // Bind to the parent object so we can create the container
    //

    BSTR bstrParent = SysAllocString( lpParent );
    if ( bstrParent == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = OpenDSObject(bstrParent, IID_IADsContainer, (void **)&pADsContainer);
    SysFreeString( bstrParent );

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to get gpo container interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Create the container (either GPC or normal container)
    //

    hr = StringCchCopy (szTemp, ARRAYSIZE(szTemp), TEXT("CN="));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szTemp, ARRAYSIZE(szTemp), lpCommonName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Could not copy container name with 0x%x"), hr));
        goto Exit;
    }

    BSTR bstrTemp = SysAllocString( szTemp );
    if ( bstrTemp == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    BSTR bstrContainer = SysAllocString( (bGPC ? TEXT("groupPolicyContainer") : TEXT("container")) );
    if ( bstrContainer == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        SysFreeString( bstrTemp );
        goto Exit;
    }
    hr = pADsContainer->Create ( bstrContainer, bstrTemp, &pDispatch);
    SysFreeString( bstrTemp );
    SysFreeString( bstrContainer );
    
    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to create container with 0x%x"), hr));
        goto Exit;
    }


    //
    // Query for the IADs interface so we can set the CN name and
    // commit the changes
    //

    hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: QI for IADs failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the common name (aka "cn")
    //

    bstrName = SysAllocString (L"cn");

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString (lpCommonName);

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreateContainer: Failed to put common name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Call SetInfo to commit the changes
    //

    hr = pADs->SetInfo();


Exit:


    if (pDispatch)
    {
        pDispatch->Release();
    }

    if (pADs)
    {
        pADs->Release();
    }

    if (pADsContainer)
    {
        pADsContainer->Release();
    }


    return hr;
}

STDMETHODIMP CGroupPolicyObject::SetDisplayNameI (IADs * pADs, LPOLESTR lpDisplayName,
                                                  LPOLESTR lpGPTPath, BOOL bUpdateDisplayVar)
{
    HRESULT hr = E_FAIL;
    BSTR bstrName;
    VARIANT var;
    LPOLESTR lpNewName;
    LPTSTR lpPath, lpEnd;
    DWORD dwSize;


    //
    // Make a copy of the display name and limit it to MAX_FRIENDLYNAME characters
    //

    dwSize = lstrlen(lpDisplayName);

    if (dwSize > (MAX_FRIENDLYNAME - 1))
    {
        dwSize = (MAX_FRIENDLYNAME - 1);
    }

    lpNewName = (LPOLESTR) LocalAlloc (LPTR, (dwSize + 2) * sizeof(OLECHAR));

    if (!lpNewName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory for display name")));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lstrcpyn (lpNewName, lpDisplayName, (dwSize + 1));


    //
    // Set the display name
    //

    bstrName = SysAllocString (GPO_NAME_PROPERTY);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory")));
        LocalFree (lpNewName);
        return ERROR_OUTOFMEMORY;
    }

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString (lpNewName);

    if (var.bstrVal)
    {
        hr = pADs->Put(bstrName, var);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }

    SysFreeString (bstrName);
    VariantClear (&var);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to put display name with 0x%x"), hr));
        LocalFree (lpNewName);
        goto Exit;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to commit changes with 0x%x"), hr));
        LocalFree (lpNewName);
        goto Exit;
    }


    //
    // Put the display name in the gpt.ini file also
    //

    ULONG ulNoChars;

    ulNoChars = lstrlen(lpGPTPath) + 10;
    lpPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (lpPath)
    {
        hr = StringCchCopy(lpPath, ulNoChars, lpGPTPath);
        if (SUCCEEDED(hr)) 
        {
            lpEnd = CheckSlash(lpPath);
            hr = StringCchCat (lpPath, ulNoChars, TEXT("gpt.ini"));
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Could not copy GPO path with 0x%x"), hr));
            LocalFree(lpPath);
            LocalFree (lpNewName);
            goto Exit;
        }

        if (!WritePrivateProfileString (TEXT("General"), GPO_NAME_PROPERTY,
                                        lpNewName, lpPath))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetDisplayNameI: Failed to write display name to gpt.ini with 0x%x"), hr));
        }

        LocalFree (lpPath);
    }


    //
    // Update the member variable if appropriate
    //

    if (bUpdateDisplayVar)
    {
        //
        // Update the display name variable
        //

        if (m_pDisplayName)
        {
            LocalFree (m_pDisplayName);
            m_pDisplayName = NULL;
        }

        m_pDisplayName = lpNewName;
    }
    else
    {
        LocalFree (lpNewName);
    }


Exit:

    return hr;
}

STDMETHODIMP CGroupPolicyObject::SetGPOInfo (LPOLESTR lpGPO,
                                             LPOLESTR lpDisplayName,
                                             LPOLESTR lpGPTPath)
{
    HRESULT hr = E_FAIL;
    IADs * pADs = NULL;
    BSTR bstrName;
    VARIANT var;
    TCHAR szDefaultName[MAX_FRIENDLYNAME];


    //
    // Bind to the GPO container
    //

    hr = OpenDSObject(lpGPO, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to get gpo interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the display name
    //

    GetNewGPODisplayName (szDefaultName, ARRAYSIZE(szDefaultName));

    hr = SetDisplayNameI (pADs, (lpDisplayName ? lpDisplayName : szDefaultName),
                          lpGPTPath, FALSE);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set display name")));
        goto Exit;
    }


    //
    // Set the GPT location
    //

    bstrName = SysAllocString (GPT_PATH_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString (lpGPTPath);

        if (var.bstrVal)
        {
            hr = pADs->Put(bstrName, var);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
            hr = ERROR_OUTOFMEMORY;
        }

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to save GPT path with 0x%x"), hr));
        goto Exit;
    }



    //
    // Set the version number
    //

    bstrName = SysAllocString (GPO_VERSION_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set version number with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the functionality version number
    //

    bstrName = SysAllocString (GPO_FUNCTION_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = GPO_FUNCTIONALITY_VERSION;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set functionality version number with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the options
    //

    bstrName = SysAllocString (GPO_OPTIONS_PROPERTY);

    if (bstrName)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = 0;

        hr = pADs->Put(bstrName, var);

        VariantClear (&var);
        SysFreeString (bstrName);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to allocate memory")));
        hr = ERROR_OUTOFMEMORY;
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetGPOInfo: Failed to set options with 0x%x"), hr));
        goto Exit;
    }


    //
    // Commit the changes
    //

    hr = pADs->SetInfo();


Exit:

    if (pADs)
    {
        pADs->Release();
    }


    return hr;
}

STDMETHODIMP CGroupPolicyObject::CheckFSWriteAccess (LPOLESTR lpLocalGPO)
{
    TCHAR szBuffer[MAX_PATH];
    LPTSTR lpEnd;
    HRESULT hr;


    hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), lpLocalGPO);
    if (SUCCEEDED(hr)) 
    {
        lpEnd = CheckSlash (szBuffer);
        hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), TEXT("gpt.ini"));
    }

    if (SUCCEEDED(hr)) 
    {
        if (!WritePrivateProfileString (TEXT("General"), TEXT("AccessCheck"),
                                        TEXT("test"), szBuffer))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            WritePrivateProfileString (TEXT("General"), TEXT("AccessCheck"),
                                       NULL, szBuffer);
            hr = S_OK;
        }
    }

    return hr;
}

STDMETHODIMP CGroupPolicyObject::GetSecurityDescriptor (IADs *pADs,
                                                        SECURITY_INFORMATION si,
                                                        PSECURITY_DESCRIPTOR *pSD)
{
    HRESULT hr;
    VARIANT var;
    LPWSTR pszSDProperty = L"nTSecurityDescriptor";
    IDirectoryObject *pDsObject = NULL;
    IADsObjectOptions *pOptions = NULL;
    PADS_ATTR_INFO pSDAttributeInfo = NULL;
    DWORD dwAttributesReturned;


    //
    // Retreive the DS Object interface
    //

    hr = pADs->QueryInterface(IID_IDirectoryObject, (void**)&pDsObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get gpo DS object interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object Options interface
    //

    hr = pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the SECURITY_INFORMATION mask
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = si;

    hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);

    VariantClear (&var);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to set ADSI security options with 0x%x"), hr));
        goto Exit;
    }


    //
    // Read the security descriptor
    //

    hr = pDsObject->GetObjectAttributes(&pszSDProperty, 1, &pSDAttributeInfo,
                                        &dwAttributesReturned);

    if (SUCCEEDED(hr) && !pSDAttributeInfo)
    {
        hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege
    }

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to get DS object attributes with 0x%x"), hr));
        goto Exit;
    }


    //
    // Duplicate the security descriptor
    //

    *pSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);

    if (!*pSD)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetSecurityDescriptor: Failed to allocate memory with 0x%x"), hr));
        goto Exit;
    }

    CopyMemory(*pSD, pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue,
               pSDAttributeInfo->pADsValues->SecurityDescriptor.dwLength);


Exit:

    if (pSDAttributeInfo)
    {
        FreeADsMem(pSDAttributeInfo);
    }

    if (pOptions)
    {
        pOptions->Release();
    }

    if (pDsObject)
    {
        pDsObject->Release();
    }

    return hr;
}

BOOL CGroupPolicyObject::EnableSecurityPrivs(void)
{
    BOOL bResult;
    HANDLE hToken;
    HANDLE hNewToken;
    BYTE buffer[sizeof(PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)];
    PTOKEN_PRIVILEGES pPrivileges = (PTOKEN_PRIVILEGES)buffer;


    //
    // Get a token and enable the Security and Take Ownership
    // privileges, if possible.
    //

    bResult = OpenThreadToken(GetCurrentThread(), TOKEN_DUPLICATE, TRUE, &hToken);

    if (!bResult)
    {
        bResult = OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hToken);
    }

    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to get both thread and process token with %d"),
                GetLastError()));
        return FALSE;
    }


    bResult = DuplicateTokenEx(hToken,
                               TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                               NULL,                   // PSECURITY_ATTRIBUTES
                               SecurityImpersonation,  // SECURITY_IMPERSONATION_LEVEL
                               TokenImpersonation,     // TokenType
                               &hNewToken);            // Duplicate token

    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to duplicate the token with %d"),
                GetLastError()));
        CloseHandle(hToken);
        return FALSE;
    }


    //
    // PRIVILEGE_SET contains 1 LUID_AND_ATTRIBUTES already, so
    // this is enough for 2 LUID_AND_ATTRIBUTES (2 privileges).
    //

    CloseHandle(hToken);
    hToken = hNewToken;

    pPrivileges->PrivilegeCount = 2;
    pPrivileges->Privileges[0].Luid = RtlConvertUlongToLuid(SE_SECURITY_PRIVILEGE);
    pPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    pPrivileges->Privileges[1].Luid = RtlConvertUlongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);
    pPrivileges->Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

    bResult = AdjustTokenPrivileges(hToken,     // TokenHandle
                                    FALSE,      // DisableAllPrivileges
                                    pPrivileges,// NewState
                                    0,          // BufferLength
                                    NULL,       // PreviousState
                                    NULL);      // ReturnLength


    if (!bResult)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to AdjustTokenPrivileges with %d"),
                GetLastError()));
        CloseHandle(hToken);
        return FALSE;
    }


    //
    // Set the new thread token
    //

    if ( !SetThreadToken(NULL, hToken) )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableSecurityPrivs: Failed to SetThreadToken with %d"), GetLastError() ) );
        CloseHandle(hToken);
        return FALSE;
    }

    CloseHandle(hToken);

    return TRUE;
}

DWORD CGroupPolicyObject::EnableInheritance (PACL pAcl)
{
    WORD wIndex;
    DWORD dwResult = ERROR_SUCCESS;
    ACE_HEADER *pAceHeader;


    if (pAcl)
    {
        //
        // Loop through the ACL looking at each ACE entry
        //

        for (wIndex = 0; wIndex < pAcl->AceCount; wIndex++)
        {

            if (!GetAce (pAcl, (DWORD)wIndex, (LPVOID *)&pAceHeader))
            {
                dwResult = GetLastError();
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::EnableInheritance: GetAce failed with %d"),
                         dwResult));
                goto Exit;
            }


            //
            // Turn on the inheritance flags
            //

            pAceHeader->AceFlags |= (CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE);
        }
    }

Exit:

    return dwResult;
}

//
// This method will convert a DS security access list into a
// file system security access list and actually set the security
//

DWORD CGroupPolicyObject::SetSysvolSecurity (LPTSTR lpFileSysPath, SECURITY_INFORMATION si,
                                             PSECURITY_DESCRIPTOR pSD)
{
    return SetSysvolSecurityFromDSSecurity( 
        lpFileSysPath,
        si,
        pSD);
}

HRESULT WINAPI CGroupPolicyObject::ReadSecurityDescriptor (LPCWSTR lpGPOPath,
                                                           SECURITY_INFORMATION si,
                                                           PSECURITY_DESCRIPTOR *pSD,
                                                           LPARAM lpContext)
{
    CGroupPolicyObject * pGPO;
    HRESULT hr;


    //
    // Convert lpContext into a pGPO
    //

    pGPO = (CGroupPolicyObject*)lpContext;

    if (!pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::ReadSecurityDescriptor: GPO interface pointer is NULL")));
        return E_FAIL;
    }


    hr = pGPO->GetSecurityDescriptor (pGPO->m_pADs, si, pSD);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::ReadSecurityDescriptor: GetSecurityDescriptor returned 0x%x"), hr));
    }

    return (hr);
}

HRESULT WINAPI CGroupPolicyObject::WriteSecurityDescriptor (LPCWSTR lpGPOPath,
                                                            SECURITY_INFORMATION si,
                                                            PSECURITY_DESCRIPTOR pSD,
                                                            LPARAM lpContext)
{
    CGroupPolicyObject * pGPO;
    IDirectoryObject *pDsObject = NULL;
    IADsObjectOptions *pOptions = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    HRESULT hr;
    VARIANT var;
    ADSVALUE attributeValue;
    ADS_ATTR_INFO attributeInfo;
    DWORD dwAttributesModified;
    DWORD dwSDLength;
    PSECURITY_DESCRIPTOR psd = NULL, pSDOrg = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdControl = 0;
    DWORD dwRevision;
    PACL pAcl;
    BOOL bPresent, bDefault;


    //
    // Convert lpContext into a pGPO
    //

    pGPO = (CGroupPolicyObject*)lpContext;

    if (!pGPO)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GPO interface pointer is NULL")));
        return E_FAIL;
    }


    //
    // Get the original security descriptor from the DS
    //

    hr = pGPO->GetSecurityDescriptor (pGPO->m_pADs, si, &pSDOrg);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to query the security descriptor with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object interface
    //

    hr = pGPO->m_pADs->QueryInterface(IID_IDirectoryObject, (void**)&pDsObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the DS Object Options interface
    //

    hr = pGPO->m_pADs->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the SECURITY_INFORMATION mask
    //

    VariantInit(&var);
    var.vt = VT_I4;
    var.lVal = si;

    hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);

    VariantClear (&var);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get DS object options interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Need the total size of the security descriptor
    //

    dwSDLength = GetSecurityDescriptorLength(pSD);


    //
    // If necessary, make a self-relative copy of the security descriptor
    //

    if (!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision))
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to get security descriptor control with %d"),
                 dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }


    if (!(sdControl & SE_SELF_RELATIVE))
    {
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

        if (!psd)
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to allocate memory for new SD with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        if (!MakeSelfRelativeSD(pSD, psd, &dwSDLength))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: MakeSelfRelativeSD failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        //
        // Point to the self-relative copy
        //

        pSD = psd;
    }


    //
    // By default, the general page will set things up so the inheritance
    // is for the root container only.  We really want the inheritance to
    // be for the root and all sub-containers, so run through the
    // DACL and SACL and set the new inheritance flags
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorDacl(pSD, &bPresent, &pAcl, &bDefault))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GetSecurityDescriptorDacl failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        dwResult = pGPO->EnableInheritance (pAcl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: EnableInheritance failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }
    }


    if (si & SACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorSacl(pSD, &bPresent, &pAcl, &bDefault))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: GetSecurityDescriptorSacl failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }

        dwResult = pGPO->EnableInheritance (pAcl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: EnableInheritance failed with %d"),
                     dwResult));
            hr = HRESULT_FROM_WIN32(dwResult);
            goto Exit;
        }
    }


    //
    // Set the DS security
    //

    attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeValue.SecurityDescriptor.dwLength = dwSDLength;
    attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSD;

    attributeInfo.pszAttrName = L"nTSecurityDescriptor";
    attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
    attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
    attributeInfo.pADsValues = &attributeValue;
    attributeInfo.dwNumValues = 1;

    hr = pDsObject->SetObjectAttributes(&attributeInfo, 1, &dwAttributesModified);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to set DS security with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the sysvol security
    //

    dwResult = pGPO->SetSysvolSecurity (pGPO->m_pFileSysPath, si, pSD);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to set the security for the file system portion <%s> with %d"),
                 pGPO->m_pFileSysPath, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);


        //
        // Restore the orignal DS security
        //

        attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeValue.SecurityDescriptor.dwLength = GetSecurityDescriptorLength(pSDOrg);
        attributeValue.SecurityDescriptor.lpValue = (LPBYTE)pSDOrg;

        attributeInfo.pszAttrName = L"nTSecurityDescriptor";
        attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
        attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
        attributeInfo.pADsValues = &attributeValue;
        attributeInfo.dwNumValues = 1;

        if (FAILED(pDsObject->SetObjectAttributes(&attributeInfo, 1, &dwAttributesModified)))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WriteSecurityDescriptor: Failed to restore DS security")));
        }

        goto Exit;
    }


Exit:

    if (pDsObject)
    {
        pDsObject->Release();
    }

    if (pOptions)
    {
        pOptions->Release();
    }

    if (psd)
    {
        LocalFree(psd);
    }

    if (pSDOrg)
    {
        LocalFree(pSDOrg);
    }

    return (hr);
}

STDMETHODIMP CGroupPolicyObject::CleanUp (void)
{

    if (m_pUser)
    {
        m_pUser->Release();
        m_pUser = NULL;
    }

    if (m_pMachine)
    {
        m_pMachine->Release();
        m_pMachine = NULL;
    }

    if (m_pName)
    {
        LocalFree (m_pName);
        m_pName = NULL;
    }

    if (m_pDisplayName)
    {
        LocalFree (m_pDisplayName);
        m_pDisplayName = NULL;
    }

    if (m_pDSPath)
    {
        LocalFree (m_pDSPath);
        m_pDSPath = NULL;
    }

    if (m_pFileSysPath)
    {
        LocalFree (m_pFileSysPath);
        m_pFileSysPath = NULL;
    }

    if (m_pMachineName)
    {
        LocalFree (m_pMachineName);
        m_pMachineName = NULL;
    }

    if (m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }

    m_gpoType = GPOTypeLocal;
    m_bInitialized = FALSE;

    return S_OK;
}

STDMETHODIMP CGroupPolicyObject::RefreshGroupPolicy (BOOL bMachine)
{
    HINSTANCE hInstUserEnv;
    PFNREFRESHPOLICY pfnRefreshPolicy;


    //
    // Load the function we need
    //

    hInstUserEnv = LoadLibrary (TEXT("userenv.dll"));

    if (!hInstUserEnv) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::RefreshGroupPolicy:  Failed to load userenv with %d."),
                 GetLastError()));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    pfnRefreshPolicy = (PFNREFRESHPOLICY)GetProcAddress (hInstUserEnv,
                                                         "RefreshPolicy");

    if (!pfnRefreshPolicy) {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::RefreshGroupPolicy:  Failed to find RefreshPolicy with %d."),
                 GetLastError()));
        FreeLibrary (hInstUserEnv);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Refresh policy
    //

    pfnRefreshPolicy (bMachine);


    //
    // Clean up
    //

    FreeLibrary (hInstUserEnv);

    return S_OK;
}

BSTR
ParseDomainName( LPWSTR szDomain )
{
    BSTR bstrDomain = 0;

    if ( szDomain )
    {
        WCHAR szXDomain[MAX_PATH*2];
        DWORD dwSize = MAX_PATH*2;

        if ( TranslateName( szDomain,
                            NameUnknown,
                            NameCanonical,
                            szXDomain,
                            &dwSize ) )
        {
            LPWSTR szTemp = wcschr( szXDomain, L'/' );

            if ( szTemp )
            {
                *szTemp = 0;
            }

            bstrDomain = SysAllocString( szXDomain );
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseDomainName: *** %s ***"), bstrDomain ? bstrDomain : L"" ));

    return bstrDomain;
}

BSTR
ParseDomainName2( LPWSTR szDSObject )
{
    BSTR bstrDomain = 0;

    if ( !szDSObject )
    {
        return bstrDomain;
    }

    if ( CompareString( LOCALE_INVARIANT,
                        NORM_IGNORECASE,
                        szDSObject,
                        7,
                        L"LDAP://",
                        7 ) == CSTR_EQUAL )
    {
        szDSObject += 7;
    }

    if ( *szDSObject )
    {
        WCHAR szXDomain[MAX_PATH*2];
        DWORD dwSize = MAX_PATH*2;

        if ( TranslateName( szDSObject,
                            NameUnknown,
                            NameCanonical,
                            szXDomain,
                            &dwSize ) )
        {
            LPWSTR szTemp = wcschr( szXDomain, L'/' );

            if ( szTemp )
            {
                *szTemp = 0;
            }

            bstrDomain = SysAllocString( szXDomain );
        }
    }

    DebugMsg((DM_VERBOSE, TEXT("ParseDomainName2: *** %s ***"), bstrDomain ? bstrDomain : L"" ));

    return bstrDomain;
}

INT_PTR CALLBACK CGroupPolicyObject::WQLFilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyObject* pGPO;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            HRESULT hr;
            BSTR bstrName;
            VARIANT var;
            LPTSTR lpDisplayName;

            pGPO = (CGroupPolicyObject*) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPO);


            //
            // Set the defaults
            //

            pGPO->m_pTempFilterString = NULL;
            CheckDlgButton (hDlg, IDC_NONE, BST_CHECKED);
            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);

            if (pGPO->m_dwFlags & GPO_OPEN_READ_ONLY)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_NONE), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_THIS_FILTER), FALSE);
            }


            //
            // Query for the filter
            //

            bstrName = SysAllocString (GPO_WQLFILTER_PROPERTY);

            if (!bstrName)
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                break;
            }

            VariantInit(&var);

            hr = pGPO->m_pADs->Get(bstrName, &var);


            //
            // If we find a filter, initialize the UI and save the filter string in the
            // temporary buffer
            //

            if (SUCCEEDED(hr))
            {
                //
                // Check if we found a null filter (defined as one space character)
                //

                if (*var.bstrVal != TEXT(' '))
                {
                    ULONG ulNoChars = lstrlen(var.bstrVal) + 1;

                    pGPO->m_pTempFilterString = new TCHAR [ulNoChars];

                    if (!pGPO->m_pTempFilterString)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory for filter")));
                        SysFreeString (bstrName);
                        VariantClear (&var);
                        break;
                    }

                    hr = StringCchCopy (pGPO->m_pTempFilterString, ulNoChars, var.bstrVal);
                    ASSERT(SUCCEEDED(hr));

                    lpDisplayName = GetWMIFilterDisplayName (hDlg, pGPO->m_pTempFilterString, TRUE, FALSE);

                    if (lpDisplayName)
                    {
                        SetDlgItemText (hDlg, IDC_FILTER_NAME, lpDisplayName);
                        delete [] lpDisplayName;

                        CheckDlgButton (hDlg, IDC_NONE, BST_UNCHECKED);
                        CheckDlgButton (hDlg, IDC_THIS_FILTER, BST_CHECKED);
                        EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), TRUE);

                        if (!(pGPO->m_dwFlags & GPO_OPEN_READ_ONLY))
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), TRUE);
                        }
                    }
                }
            }
            else
            {
                if (hr != E_ADS_PROPERTY_NOT_FOUND)
                {
                    DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to query filter with 0x%x"), hr));
                }
            }


            SysFreeString (bstrName);
            VariantClear (&var);

            break;
        }

        case WM_COMMAND:
        {
            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            if (LOWORD(wParam) == IDC_FILTER_BROWSE)
            {
                LPTSTR lpDisplayName = NULL, lpFilter = NULL;
                WCHAR   szDomain[2*MAX_PATH];
                HRESULT hr = pGPO->GetPath( szDomain, ARRAYSIZE( szDomain ) );
                if ( FAILED( hr ) )
                {
                    break;
                }

                BSTR bstrDomain = ParseDomainName2( szDomain );

                if (!GetWMIFilter(FALSE, hDlg, TRUE, &lpDisplayName, &(pGPO->m_pTempFilterString), bstrDomain ))
                {
                    SysFreeString( bstrDomain );
                    break;
                }

                SysFreeString( bstrDomain );

                if (!(pGPO->m_pTempFilterString)) {
                    SetDlgItemText (hDlg, IDC_FILTER_NAME, TEXT(""));

                    EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
                    EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);
                    CheckDlgButton (hDlg, IDC_NONE, BST_CHECKED);
                    CheckDlgButton (hDlg, IDC_THIS_FILTER, BST_UNCHECKED);
                    SetFocus (GetDlgItem(hDlg, IDC_NONE));

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                }
                else {
                    SetDlgItemText (hDlg, IDC_FILTER_NAME, lpDisplayName);
                    delete [] lpDisplayName;

                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                }
            }

            if (LOWORD(wParam) == IDC_NONE)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), FALSE);

                if (pGPO->m_pTempFilterString)
                {
                    delete [] pGPO->m_pTempFilterString;
                    pGPO->m_pTempFilterString = NULL;
                }
            }
            else if (LOWORD(wParam) == IDC_THIS_FILTER)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_NAME), TRUE);
                EnableWindow (GetDlgItem(hDlg, IDC_FILTER_BROWSE), TRUE);
            }

            break;
        }

        case WM_NOTIFY:
        {
            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    HRESULT hr;
                    BSTR bstrName;
                    VARIANT var;


                    //
                    // Save the current WQL filter
                    //

                    bstrName = SysAllocString (GPO_WQLFILTER_PROPERTY);

                    if (!bstrName)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                        break;
                    }

                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = SysAllocString (pGPO->m_pTempFilterString ? pGPO->m_pTempFilterString : TEXT(" "));

                    if (var.bstrVal)
                    {
                        hr = pGPO->m_pADs->Put(bstrName, var);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to allocate memory")));
                        SysFreeString (bstrName);
                        break;
                    }

                    SysFreeString (bstrName);
                    VariantClear (&var);


                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to put display name with 0x%x"), hr));
                        break;
                    }


                    //
                    // Commit the changes
                    //

                    hr = pGPO->m_pADs->SetInfo();

                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::WQLFilterDlgProc: Failed to commit changes with 0x%x"), hr));
                        break;
                    }


                    //
                    // Free the filter string if appropriate
                    //

                    if (((PSHNOTIFY *)lParam)->lParam)
                    {
                        if (pGPO->m_pTempFilterString)
                        {
                            delete [] pGPO->m_pTempFilterString;
                            pGPO->m_pTempFilterString = NULL;
                        }
                    }

                    break;
                }

                case PSN_RESET:
                {
                    if (pGPO->m_pTempFilterString)
                    {
                        delete [] pGPO->m_pTempFilterString;
                        pGPO->m_pTempFilterString = NULL;
                    }
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aWQLFilterHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aWQLFilterHelpIds);
            return (TRUE);


        default:
            break;
    }

    return FALSE;
}

#define MAX_BUTTON_LEN 64
//////////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK CGroupPolicyObject::GPELinksDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    GLPARAM * pglp = NULL;
    switch (message)
    {
        case WM_INITDIALOG:
        {
            LV_COLUMN lvc = {LVCF_WIDTH};
            RECT rc;
            HWND hList = GetDlgItem(hDlg, IDC_RESULTLIST);

            // Allocate the per dialog structure
            pglp = (GLPARAM*)LocalAlloc (LPTR, sizeof(GLPARAM));
            if (pglp)
            {
                pglp->pGPO = (CGroupPolicyObject*) (((LPPROPSHEETPAGE)lParam)->lParam);
                SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pglp);
                pglp->pGPO->FillDomainList (GetDlgItem(hDlg, IDC_CBDOMAIN));
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Failed to LocalAlloc in WM_INITDIALOG")));
            }

            // Set the Columns, in the list view
            if (IsWindow(hList))
            {
                SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_LABELTIP,
                            LVS_EX_LABELTIP);

                GetClientRect(hList, &rc);
                lvc.cx = (rc.right - rc.left);
                ListView_InsertColumn(hList, 0, &lvc);
            }

            // Show icon in the corner
            Animate_Open(GetDlgItem(hDlg, IDAC_FIND), MAKEINTRESOURCE(IDA_FIND));
            break;
        }

        case WM_COMMAND:
        {
            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            if ((IDC_CBDOMAIN == LOWORD(wParam)) && ((CBN_SELCHANGE == HIWORD(wParam)) || (CBN_SELENDOK == HIWORD(wParam))))
            {
                // Clear the list view
                pglp->fAbort = TRUE;
                SendDlgItemMessage(hDlg, IDC_RESULTLIST, LVM_DELETEALLITEMS, 0, 0L);
                break;
            }

            // If the IDC_ACTION was clicked then do search
            if ((IDC_ACTION == LOWORD(wParam)) && (BN_CLICKED == HIWORD(wParam)))
            {
                // If we are have been asked to start a search, create the thread to do so
                if (!pglp->fFinding)
                {
                    HANDLE hThread = NULL;
                    DWORD dwThreadId = 0;
                    GLTHREADPARAM  * pgltp = NULL;
                    int nCurSel = 0;

                    // Make sure something has been selected in the  combo box
                    nCurSel = (int)SendDlgItemMessage (hDlg, IDC_CBDOMAIN, CB_GETCURSEL, 0, 0L);
                    if (CB_ERR == nCurSel)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: There was no Domain selected in the combo box. Exiting.")));
                        break;
                    }

                    // Allocate the Thread Param structure
                    pgltp = (GLTHREADPARAM*)LocalAlloc (LPTR, sizeof(GLTHREADPARAM));
                    if (!pgltp)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Failed to LocalAlloc Thread Param structure")));
                        break;
                    }

                    pgltp->hDlg = hDlg;
                    pgltp->pGPO = pglp->pGPO;
                    pgltp->pfAbort = &pglp->fAbort;

                    pgltp->pszLDAPName = (LPOLESTR)SendDlgItemMessage (hDlg, IDC_CBDOMAIN, CB_GETITEMDATA, nCurSel, 0L);

                    if (!pgltp->pszLDAPName)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: The LDAP name buffer was NULL.")));
                        LocalFree(pgltp);
                        break;
                    }

                    pgltp->pszLDAPName = MakeFullPath (pgltp->pszLDAPName, pglp->pGPO->m_pMachineName);

                    // Unset the abort flag
                    pglp->fAbort = FALSE;

                    // Clear the list view
                    SendDlgItemMessage(hDlg, IDC_RESULTLIST, LVM_DELETEALLITEMS, 0, 0L);

                    // Fire off the thread to fill the list view
                    hThread = CreateThread (NULL, 0, (LPTHREAD_START_ROUTINE)GLThreadFunc, pgltp, 0, &dwThreadId);
                    if (!hThread)
                    {
                        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GPELinksDlgProc: Could not create the search thread.")));
                        LocalFree(pgltp);
                        break;
                    }
                    CloseHandle (hThread);

                    // Change the text on the button to "Stop"
                    SendMessage (hDlg, PDM_CHANGEBUTTONTEXT, 0, 0L);
                }
                else
                {
                    // The user wants to stop the search
                    pglp->fAbort = TRUE;
                }
            }
            break;
        }

        case PDM_CHANGEBUTTONTEXT:
        {
            TCHAR szButtonText[MAX_BUTTON_LEN] = {0};

            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            if (!pglp->fFinding)
                Animate_Play(GetDlgItem(hDlg, IDAC_FIND), 0, -1, -1);
            else
                Animate_Stop(GetDlgItem(hDlg, IDAC_FIND));


            // Set the button to show appropriate text
            LoadString (g_hInstance, pglp->fFinding ? IDS_FINDNOW: IDS_STOP, szButtonText, ARRAYSIZE(szButtonText));
            SetDlgItemText (hDlg, IDC_ACTION, szButtonText);

            // Flip the toggle
            pglp->fFinding = !pglp->fFinding;
            break;
        }

        case WM_NOTIFY:
        {
            pglp = (GLPARAM *) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pglp)
            {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {

                // In case thr user wants to cancel, bail from the thread
                case PSN_QUERYCANCEL:
                    pglp->fAbort = TRUE;
                    break;

                // In case thr user wants to close the prop sheet, bail from the thread
                case PSN_APPLY:
                case PSN_RESET:
                {
                    int nCount = 0;


                    PSHNOTIFY * pNotify = (PSHNOTIFY *) lParam;

                    // User just hit the Apply button don't destroy everything.
                    if (!pNotify->lParam)
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        return TRUE;
                    }

                    pglp->fAbort = TRUE;

                    // When the dialog is going away, delete all the data that was stored with each CB item in
                    // FillDomainList() are freed
                    if (IsWindow(GetDlgItem(hDlg, IDC_CBDOMAIN)))
                    {
                        nCount = (int) SendDlgItemMessage(hDlg, IDC_CBDOMAIN, CB_GETCOUNT, 0, 0L);
                        for (int nIndex = 0; nIndex < nCount; nIndex++)
                        {
                            LPOLESTR pszStr;
                            pszStr = (LPOLESTR)SendDlgItemMessage(hDlg, IDC_CBDOMAIN, CB_GETITEMDATA, nIndex, 0L);
                            if (pszStr)
                                delete [] pszStr;
                        }
                    }

                    // Free the per dialog structure
                    LocalFree (pglp);
                    SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) NULL);
                    Animate_Close(GetDlgItem(hDlg, IDAC_FIND));
                    break;
                }
            }
            break;
        }

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aLinkHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aLinkHelpIds);
            return (TRUE);


        default:
            break;
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// The thread that will look call the recursive find function. This function will clean up
// the param structure that has been passed in
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CGroupPolicyObject::GLThreadFunc(GLTHREADPARAM  * pgltp)
{
    LPTSTR lpGPO;
    DWORD dwRet;
    HINSTANCE hInstance = LoadLibrary(TEXT("GPEdit.dll"));
    HRESULT hr;


    //
    // Initialize COM
    //

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        return 0L;
    }


    //
    // Make sure we have a thread param structure
    //

    if (pgltp)
    {

        pgltp->pGPO->AddRef();

        lpGPO = MakeNamelessPath (pgltp->pGPO->m_pDSPath);

        if (lpGPO)
        {
            //
            // Check if the user wants to abort. Otherwise make recursive call
            //

            if (!*(pgltp->pfAbort))
            {
                dwRet = pgltp->pGPO->FindLinkInDomain(pgltp, lpGPO);
            }

            if ((!*(pgltp->pfAbort)) && dwRet)
            {
                pgltp->pGPO->FindLinkInSite(pgltp, lpGPO);
            }

            if (IsWindow(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST)))
            {
                ListView_SetItemState(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), 0, LVIS_SELECTED |LVIS_FOCUSED, LVIS_SELECTED |LVIS_FOCUSED);
            }

            //
            // Switch the button text, change the cursor, and free the param that the
            // dialog proc allocated and sent to us
            //

            SendMessage(pgltp->hDlg, PDM_CHANGEBUTTONTEXT, 0, 0L);

            LocalFree (lpGPO);
        }
        pgltp->pGPO->Release();

        LocalFree(pgltp->pszLDAPName);
        LocalFree(pgltp);
    }


    //
    // Uninitialize COM
    //
    CoUninitialize();

    FreeLibraryAndExitThread(hInstance, 0);
    return 0L;
}


DWORD WINAPI CGroupPolicyObject::FindLinkInSite(GLTHREADPARAM  * pgltp, LPTSTR lpGPO)
{
    IADsContainer * pADsContainer = NULL;
    HRESULT hr;
    IEnumVARIANT *pVar = NULL;
    IADs * pADs = NULL;
    VARIANT var;
    ULONG ulResult;
    IDispatch * pDispatch = NULL;
    BSTR bstrClassName;
    BSTR bstrSite = NULL;
    IADsPathname * pADsPathname = NULL;


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the gpo name
    //

    BSTR bstrLDAPName = SysAllocString( pgltp->pszLDAPName );
    if ( bstrLDAPName == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set ( bstrLDAPName, ADS_SETTYPE_FULL);
    SysFreeString( bstrLDAPName );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the configuration folder to the path
    //

    BSTR bstrCNConfiguration = SysAllocString( TEXT("CN=Configuration") );
    if ( bstrCNConfiguration == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement ( bstrCNConfiguration );
    SysFreeString( bstrCNConfiguration );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to add configuration folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the sites container to the path
    //

    BSTR bstrCNSites = SysAllocString( TEXT("CN=Sites") );
    if ( bstrCNSites == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to allocate BSTR memory")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrCNSites);
    SysFreeString( bstrCNSites );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to add sites folder with 0x%x"), hr));
        goto Exit;
    }


    //
    // Retreive the container path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrSite);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to retreive site path with 0x%x"), hr));
        goto Exit;
    }


    // Create Enumerator
    hr = OpenDSObject(bstrSite, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInSite: Failed to get gpo container interface with 0x%x for object %s"),
                 hr, bstrSite));
        goto Exit;
    }

    // Build the enumerator
    hr = ADsBuildEnumerator (pADsContainer, &pVar);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("FindLinkInSite: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }

    //
    // Enumerate
    //
    while (TRUE)
    {
        TCHAR lpSite[] = TEXT("site");
        DWORD dwStrLen = lstrlen (lpSite);

        // Check if the user wants to abort. Before proceeding

        if (*(pgltp->pfAbort))
        {
            break;
        }

        VariantInit(&var);

        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        if ((FAILED(hr)) || (var.vt != VT_DISPATCH))
        {
            DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::FindLinkInSite: Failed to enumerator with 0x%x or we didn't get the IDispatch"), hr));
            VariantClear (&var);
            break;
        }


        if (*(pgltp->pfAbort))
        {
            VariantClear (&var);
            break;
        }

        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            goto Exit;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            goto Exit;
        }

        //
        // Get the relative and class names
        //

        hr = pADs->get_Class (&bstrClassName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            pADs->Release();
            VariantClear (&var);
            goto Exit;
        }


        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           lpSite, dwStrLen, bstrClassName, dwStrLen) == CSTR_EQUAL)
        {

            VARIANT varLink;
            BSTR bstrLinkProp;

            VariantInit(&varLink);
            bstrLinkProp = SysAllocString(GPM_LINK_PROPERTY);

            if (bstrLinkProp)
            {
                // Now get the Name property
                hr = pADs->Get(bstrLinkProp, &varLink);

                // Create the new LDAP:// string and call FindLinkInDomain() recursively
                if (SUCCEEDED(hr) && wcsstr(varLink.bstrVal, lpGPO))
                {
                    VARIANT varName;
                    BSTR bstrNameProp;

                    VariantInit(&varName);
                    bstrNameProp = SysAllocString(GPM_NAME_PROPERTY);

                    if (bstrNameProp)
                    {
                        // Now get the Name property
                        hr = pADs->Get(bstrNameProp, &varName);

                        if (SUCCEEDED(hr))
                        {
                            LV_ITEM lvi = {LVIF_TEXT};
                            LPTSTR pszTemp = MakeNamelessPath(bstrSite);

                            if (pszTemp)
                            {
                                ULONG ulLen = wcslen(pszTemp) + 2 + wcslen(varName.bstrVal);
                                LPOLESTR pszTranslated = new OLECHAR[ulLen];

                                if (pszTranslated)
                                {
                                    // Move pointer over the lDAP:// string and insert the rest into the listview
                                    pszTemp += wcslen(TEXT("LDAP://"));

                                    lvi.iItem = 0x7FFFFFFF;
                                    
                                    ULONG ulNeeded = ulLen;
                                    BOOL  bTranslated;

                                    bTranslated = TranslateName(pszTemp, NameFullyQualifiedDN, NameCanonical, pszTranslated, &ulNeeded);

                                    if ( ! bTranslated && ( ulNeeded > ulLen ) )
                                    {
                                        delete [] pszTranslated;

                                        pszTranslated = new OLECHAR[ulNeeded];

                                        if ( pszTranslated )
                                        {
                                            bTranslated = TranslateName(pszTemp, NameFullyQualifiedDN, NameCanonical, pszTranslated, &ulNeeded);
                                        }
                                    }

                                    ulLen = ulNeeded;

                                    if ( bTranslated )
                                    {
                                        ULONG  ulFullPath;
                                        WCHAR* pszFullPath;

                                        ulFullPath = ulLen + sizeof(L'/') / sizeof(WCHAR) + lstrlen( varName.bstrVal ) + 1;

                                        pszFullPath = new OLECHAR[ ulFullPath ];

                                        if ( pszFullPath )
                                        {
                                            HRESULT hrCopy;

                                            hrCopy = StringCchCopy( pszFullPath, ulFullPath, pszTranslated );
                                            ASSERT(SUCCEEDED(hrCopy));

                                            hrCopy = StringCchCat (pszFullPath, ulFullPath, TEXT("/"));
                                            ASSERT(SUCCEEDED(hrCopy));

                                            hrCopy = StringCchCat (pszFullPath, ulFullPath, varName.bstrVal);
                                            ASSERT(SUCCEEDED(hrCopy));

                                            lvi.pszText = pszFullPath;
                                            ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);

                                            delete [] pszFullPath;
                                        }
                                    }
                                    delete [] pszTranslated;
                                }

                                LocalFree (pszTemp);
                            }
                        }
                        SysFreeString (bstrNameProp);
                    }
                    VariantClear (&varName);
                }

                SysFreeString (bstrLinkProp);
            }
            VariantClear (&varLink);
        }

        pADs->Release();
        SysFreeString (bstrClassName);
    }

Exit:
    if (pADsContainer)
        pADsContainer->Release();

    if (pADsPathname)
        pADsPathname->Release();

    if (bstrSite)
        SysFreeString (bstrSite);

    return 1L;
}


//////////////////////////////////////////////////////////////////////////////
// Recursive call that will look through all domains and OUs for our GUID
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI CGroupPolicyObject::FindLinkInDomain(GLTHREADPARAM  * pgltp, LPTSTR lpGPO)
{
    IADs * pADs = NULL;
    IADsContainer * pADsContainer = NULL;
    HRESULT hr;
    IEnumVARIANT *pVar = NULL;
    VARIANT var;
    ULONG ulResult;
    BSTR bstrClassName;
    IDispatch * pDispatch = NULL;
    DWORD dwResult = 1;


    // Check if the user wants to abort. Before proceeding
    if (*(pgltp->pfAbort))
    {
        return 0;
    }

    // Bind to Object
    hr = OpenDSObject(pgltp->pszLDAPName, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        BSTR bstrLinkProp;
        VariantInit(&var);
        bstrLinkProp = SysAllocString(GPM_LINK_PROPERTY);

        if (bstrLinkProp)
        {
            // Now get the link property
            hr = pADs->Get(bstrLinkProp, &var);

            // Check if out GUID is in there.
            if (SUCCEEDED(hr) && StrStrI(var.bstrVal, lpGPO))
            {
                LV_ITEM lvi = {LVIF_TEXT};

                //
                // Check if this is a forest path
                //

                if (IsForest(pgltp->pszLDAPName))
                {
                    TCHAR szForest[50] = {0};

                    LoadString (g_hInstance, IDS_FOREST, szForest, ARRAYSIZE(szForest));
                    lvi.iItem = 0x7FFFFFFF;
                    lvi.pszText = szForest;
                    ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);
                }
                else
                {
                    LPTSTR pszTemp = MakeNamelessPath(pgltp->pszLDAPName);

                    if (pszTemp)
                    {
                        ULONG ulLen = wcslen(pszTemp) + 2;
                        LPOLESTR pszTranslated = new OLECHAR[ulLen];

                        if (pszTranslated)
                        {
                            // Move pointer over the lDAP:// string and insert the rest into the listview
                            pszTemp += wcslen(TEXT("LDAP://"));

                            lvi.iItem = 0x7FFFFFFF;
                            if (TranslateName(pszTemp, NameFullyQualifiedDN, NameCanonical, pszTranslated, &ulLen))
                            {
                                lvi.pszText = pszTranslated;
                                ListView_InsertItem(GetDlgItem(pgltp->hDlg, IDC_RESULTLIST), &lvi);
                            }
                            delete [] pszTranslated;
                        }

                        LocalFree (pszTemp);
                    }
                }
            }

            // Cleanup
            SysFreeString(bstrLinkProp);
        }
        VariantClear(&var);
        pADs->Release();
    }
    else
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInDomain: Failed to get IID_IADs. hr: 0x%x, for %s"),hr, pgltp->pszLDAPName));
        ReportError(pgltp->hDlg, hr, IDS_DSBINDFAILED);
        dwResult = 0;
        goto Exit;

    }


    // Check if the user wants to abort. Before proceeding
    if (*(pgltp->pfAbort))
    {
        dwResult = 0;
        goto Exit;
    }

    // Create Enumerator
    hr = OpenDSObject(pgltp->pszLDAPName, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_VERBOSE, TEXT("FindLinkInDomain: Failed to get gpo container interface with 0x%x for object %s"),
                 hr, pgltp->pszLDAPName));
        dwResult = 0;
        goto Exit;
    }

    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("FindLinkInDomain: Failed to get enumerator with 0x%x"), hr));
        dwResult = 0;
        goto Exit;
    }

    //
    // Enumerate
    //
    while (TRUE)
    {
        TCHAR lpOU[] = TEXT("organizationalUnit");
        DWORD dwStrLen = lstrlen (lpOU);

        // Check if the user wants to abort. Before proceeding

        if (*(pgltp->pfAbort))
        {
            break;
        }

        VariantInit(&var);

        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }

        if ((FAILED(hr)) || (var.vt != VT_DISPATCH))
        {
            VariantClear (&var);
            break;
        }


        if (*(pgltp->pfAbort))
        {
            VariantClear (&var);
            break;
        }

        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pADs);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }

        //
        // Get the relative and class names
        //

        hr = pADs->get_Class (&bstrClassName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            pADs->Release();
            VariantClear (&var);
            dwResult = 0;
            goto Exit;
        }


        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           lpOU, dwStrLen, bstrClassName, dwStrLen) == CSTR_EQUAL)
        {
            VARIANT varName;
            BSTR bstrNameProp;

            VariantInit(&varName);
            bstrNameProp = SysAllocString(GPM_NAME_PROPERTY);

            if (bstrNameProp)
            {
                // Now get the Name property
                hr = pADs->Get(bstrNameProp, &varName);

                // Create the new LDAP:// string and call FindLinkInDomain() recursively
                if (SUCCEEDED(hr))
                {
                    GLTHREADPARAM  gltp = *pgltp;
                    IADsPathname * pADsPathname;
                    ULONG ulNoChars = wcslen(varName.bstrVal) + 10;
                    LPOLESTR pszNewName = new OLECHAR[ulNoChars];
                    BSTR bstr;

                    //
                    // Build the new element name
                    //

                    if (!pszNewName)
                    {
                        dwResult = 0;
                        goto Exit;
                    }

                    hr = StringCchCopy(pszNewName, ulNoChars, TEXT("OU="));
                    if (SUCCEEDED(hr)) 
                    {
                        hr = StringCchCat(pszNewName, ulNoChars, varName.bstrVal);
                    }

                    if (FAILED(hr)) 
                    {
                        delete [] pszNewName;
                        dwResult = 0;
                        goto Exit;
                    }

                    //
                    // Create a pathname object we can work with
                    //

                    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                                          IID_IADsPathname, (LPVOID*)&pADsPathname);


                    if (FAILED(hr))
                    {
                        delete [] pszNewName;
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Set the current name
                    //

                    BSTR bstrLDAPName = SysAllocString( pgltp->pszLDAPName );
                    if ( bstrLDAPName == NULL )
                    {
                        delete [] pszNewName;
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }
                        
                    hr = pADsPathname->Set ( bstrLDAPName, ADS_SETTYPE_FULL);
                    SysFreeString( bstrLDAPName );

                    if (FAILED(hr))
                    {
                        delete [] pszNewName;
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Check for escape characters
                    //

                    BSTR bstrNewName = SysAllocString( pszNewName );
                    delete [] pszNewName;
                    if ( bstrNewName == NULL )
                    {
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }
                    hr = pADsPathname->GetEscapedElement (0, bstrNewName, &bstr);
                    SysFreeString( bstrNewName );

                    if (FAILED(hr))
                    {
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Add the new element
                    //

                    hr = pADsPathname->AddLeafElement (bstr);

                    SysFreeString (bstr);

                    if (FAILED(hr))
                    {
                        pADsPathname->Release();
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Get the new path
                    //

                    hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                    pADsPathname->Release();

                    if (FAILED(hr))
                    {
                        dwResult = 0;
                        goto Exit;
                    }


                    //
                    // Recurse
                    //

                    gltp.pszLDAPName = bstr;
                    if (FindLinkInDomain(&gltp, lpGPO) == 0)
                    {
                        SysFreeString( bstr );
                        dwResult = 0;
                        goto Exit;
                    }

                    SysFreeString (bstr);

                }
                SysFreeString (bstrNameProp);
            }
            VariantClear (&varName);
        }

        pADs->Release();
        SysFreeString (bstrClassName);
    }

Exit:
    if (pADsContainer)
        pADsContainer->Release();

    return dwResult;
}

//////////////////////////////////////////////////////////////////////////////
// Fill the combobox with available domains
//////////////////////////////////////////////////////////////////////////////

BOOL CGroupPolicyObject::FillDomainList (HWND hWndCombo)
{
    HRESULT hr;
    DWORD dwIndex = 0;
    LPOLESTR pszDomain;
    LPTSTR lpTemp;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get the ordered tree of domains
    LOOKDATA * pDomainList = BuildDomainList(NULL);
    LOOKDATA *pRemember = pDomainList;

    // now walk the tree, adding elements to the dialog box

    int nCBIndex;

    // start at the head
    while (pDomainList)
    {

        // add the LDAP path for the doman in this node
        //SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList->szData);
        nCBIndex = (int)SendMessage(hWndCombo, CB_INSERTSTRING, (WPARAM) -1, (LPARAM)(LPCTSTR) pDomainList->szName);
        SendMessage(hWndCombo, CB_SETITEMDATA, (WPARAM) nCBIndex, (LPARAM)(LPCTSTR) pDomainList->szData);

        if (pDomainList->pChild)
        {
            // go to its child
            pDomainList = pDomainList->pChild;
        }
        else
        {
            if (pDomainList->pSibling)
            {
                // go to its sibling if there are no children
                pDomainList = pDomainList->pSibling;
            }
            else
            {
                // there are no children and no siblings
                // back up until we find a parent with a sibling
                // or there are no more parents (we're done)
                do
                {
                    pDomainList = pDomainList->pParent;
                    if (pDomainList)
                    {
                        if (pDomainList->pSibling)
                        {
                            pDomainList = pDomainList->pSibling;
                            break;
                        }
                    }
                    else
                    {
                        break;
                    }
                } while (TRUE);
            }
        }
    }

    FreeDomainInfo (pRemember);


    //
    // Select the current domain in the combobox
    //

    pszDomain = GetDomainFromLDAPPath(m_pDSPath);

    if (pszDomain)
    {

        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpTemp);

        if (SUCCEEDED(hr))
        {
            dwIndex = (DWORD) SendMessage (hWndCombo, CB_FINDSTRINGEXACT, (WPARAM) -1,
                                          (LONG_PTR)lpTemp);

            if (dwIndex == CB_ERR)
            {
                dwIndex = 0;
            }

            LocalFree (lpTemp);
        }

        delete [] pszDomain;
    }


    SendMessage (hWndCombo, CB_SETCURSEL, (WPARAM)dwIndex, 0);
    SetCursor(hcur);

    return TRUE;
}


INT_PTR CALLBACK CGroupPolicyObject::PropertiesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CGroupPolicyObject * pGPO;
    static BOOL bDirty;
    static BOOL bDisableWarningIssued;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            DWORD dwTemp;
            LPTSTR lpEnd;
            TCHAR szBuffer[2*MAX_PATH];
            TCHAR szDate[100];
            TCHAR szTime[100];
            TCHAR szFormat[80];
            TCHAR szVersion[100];
            WIN32_FILE_ATTRIBUTE_DATA fad;
            FILETIME filetime, CreateTime, ChangeTime;
            SYSTEMTIME systime;
            LPTSTR lpResult;
            LPOLESTR pszDomain;
            ULONG ulVersion = 0;
            USHORT uMachine, uUser;
            VARIANT var;
            BSTR bstrName;
            LPTSTR lpDisplayName;
            WORD wDosDate, wDosTime;
            ULONG ulNoChars;
            HRESULT hr;


            pGPO = (CGroupPolicyObject *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pGPO);


            //
            // Initialize
            //

            if ((pGPO->m_pMachineName) && (pGPO->m_gpoType == GPOTypeDS))
            {
                ulNoChars = lstrlen(pGPO->m_pDisplayName) + lstrlen(pGPO->m_pMachineName) + 5;
                lpDisplayName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                if (lpDisplayName)
                {
                    LoadString (g_hInstance, IDS_NAMEFORMAT, szFormat, ARRAYSIZE(szFormat));
                    (void) StringCchPrintf (lpDisplayName, ulNoChars, szFormat, pGPO->m_pDisplayName, pGPO->m_pMachineName);
                    SetDlgItemText (hDlg, IDC_TITLE, lpDisplayName);
                    LocalFree (lpDisplayName);
                }
            }
            else
            {
                SetDlgItemText (hDlg, IDC_TITLE, pGPO->m_pDisplayName);
            }


            if (pGPO->m_gpoType == GPOTypeDS)
            {
                if (IsForest(pGPO->m_pDSPath))
                {
                    LoadString (g_hInstance, IDS_FORESTHEADING, szBuffer, ARRAYSIZE(szBuffer));
                    SetDlgItemText (hDlg, IDC_DOMAIN_HEADING, szBuffer);
                }

                pszDomain = GetDomainFromLDAPPath(pGPO->m_pDSPath);

                if (pszDomain)
                {
                    if (SUCCEEDED(ConvertToDotStyle (pszDomain, &lpResult)))
                    {
                        SetDlgItemText (hDlg, IDC_DOMAIN, lpResult);
                        LocalFree (lpResult);
                    }

                    delete [] pszDomain;
                }

                SetDlgItemText (hDlg, IDC_UNIQUE_NAME, pGPO->m_pName);
            }
            else
            {
                LoadString (g_hInstance, IDS_NOTAPPLICABLE, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_DOMAIN, szBuffer);
                SetDlgItemText (hDlg, IDC_UNIQUE_NAME, szBuffer);
            }


            if (SUCCEEDED(pGPO->GetOptions(&dwTemp)))
            {
                if (dwTemp & GPO_OPTION_DISABLE_MACHINE)
                {
                    CheckDlgButton (hDlg, IDC_DISABLE_COMPUTER, BST_CHECKED);
                }

                if (dwTemp & GPO_OPTION_DISABLE_USER)
                {
                    CheckDlgButton (hDlg, IDC_DISABLE_USER, BST_CHECKED);
                }
            }

            hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), pGPO->m_pFileSysPath);
            if (SUCCEEDED(hr)) 
            {
                lpEnd = CheckSlash (szBuffer);
                hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), TEXT("gpt.ini"));
            }

            if (SUCCEEDED(hr)) 
            {
                if (pGPO->m_gpoType == GPOTypeDS)
                {
                    VariantInit(&var);
                    bstrName = SysAllocString (GPO_VERSION_PROPERTY);

                    if (bstrName)
                    {
                        if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                        {
                            ulVersion = var.lVal;
                        }

                        SysFreeString (bstrName);
                    }

                    VariantClear (&var);
                }
                else
                {
                    ulVersion = GetPrivateProfileInt(TEXT("General"), TEXT("Version"), 0, szBuffer);
                }
            }

            uMachine = (USHORT) LOWORD(ulVersion);
            uUser = (USHORT) HIWORD(ulVersion);

            LoadString (g_hInstance, IDS_REVISIONFORMAT, szFormat, ARRAYSIZE(szFormat));
            (void) StringCchPrintf (szVersion, ARRAYSIZE(szVersion), szFormat, uMachine, uUser);

            SetDlgItemText (hDlg, IDC_REVISION, szVersion);


            //
            // Get the date / time info
            //

            CreateTime.dwLowDateTime = 0;
            CreateTime.dwHighDateTime = 0;
            ChangeTime.dwLowDateTime = 0;
            ChangeTime.dwHighDateTime = 0;


            if (pGPO->m_gpoType == GPOTypeDS)
            {
                //
                // Get the creation time
                //

                VariantInit(&var);
                bstrName = SysAllocString (TEXT("whenCreated"));

                if (bstrName)
                {
                    if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                    {
                        if (VariantTimeToDosDateTime (var.date, &wDosDate, &wDosTime))
                        {
                            DosDateTimeToFileTime (wDosDate, wDosTime, &CreateTime);
                        }
                    }

                    SysFreeString (bstrName);
                }

                VariantClear (&var);


                //
                // Get the last write time
                //

                VariantInit(&var);
                bstrName = SysAllocString (TEXT("whenChanged"));

                if (bstrName)
                {
                    if (SUCCEEDED(pGPO->m_pADs->Get(bstrName, &var)))
                    {
                        if (VariantTimeToDosDateTime (var.date, &wDosDate, &wDosTime))
                        {
                            DosDateTimeToFileTime (wDosDate, wDosTime, &ChangeTime);
                        }
                    }

                    SysFreeString (bstrName);
                }

                VariantClear (&var);
            }
            else
            {
                //
                // Get the time info from the gpt.ini file
                //

                if (GetFileAttributesEx (szBuffer, GetFileExInfoStandard, &fad))
                {

                    CreateTime.dwLowDateTime = fad.ftCreationTime.dwLowDateTime;
                    CreateTime.dwHighDateTime = fad.ftCreationTime.dwHighDateTime;

                    ChangeTime.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
                    ChangeTime.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
                }
            }



            //
            // Format & display the date / time information
            //

            FileTimeToLocalFileTime (&CreateTime, &filetime);
            FileTimeToSystemTime (&filetime, &systime);
            GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                           NULL, szDate, ARRAYSIZE (szDate));

            GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                           NULL, szTime, ARRAYSIZE (szTime));

            LoadString (g_hInstance, IDS_DATETIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
            (void) StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), szFormat, szDate, szTime);
            SetDlgItemText (hDlg, IDC_CREATE_DATE, szBuffer);


            FileTimeToLocalFileTime (&ChangeTime, &filetime);
            FileTimeToSystemTime (&filetime, &systime);
            GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                           NULL, szDate, ARRAYSIZE (szDate));

            GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                           NULL, szTime, ARRAYSIZE (szTime));

            (void) StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), szFormat, szDate, szTime);
            SetDlgItemText (hDlg, IDC_MODIFIED_DATE, szBuffer);



            if (pGPO->m_dwFlags & GPO_OPEN_READ_ONLY)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_DISABLE_COMPUTER), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_DISABLE_USER), FALSE);
            }

            bDirty = FALSE;
            bDisableWarningIssued = FALSE;
            break;
        }

        case WM_COMMAND:
            if (HIWORD(wParam) == BN_CLICKED)
            {
                if ((LOWORD(wParam) == IDC_DISABLE_COMPUTER) ||
                    (LOWORD(wParam) == IDC_DISABLE_USER))
                {
                    if (!bDisableWarningIssued)
                    {
                        if (IsDlgButtonChecked (hDlg, LOWORD(wParam)) == BST_CHECKED)
                        {
                            TCHAR szMessage[200];
                            TCHAR szTitle[100];

                            bDisableWarningIssued = TRUE;

                            LoadString (g_hInstance, IDS_CONFIRMDISABLE, szMessage, ARRAYSIZE(szMessage));
                            LoadString (g_hInstance, IDS_CONFIRMTITLE2, szTitle, ARRAYSIZE(szTitle));

                            if (MessageBox (hDlg, szMessage, szTitle, MB_YESNO |
                                        MB_ICONWARNING | MB_DEFBUTTON2) == IDNO) {

                                CheckDlgButton (hDlg, LOWORD(wParam), BST_UNCHECKED);
                                break;
                            }
                        }
                    }
                }

                if (!bDirty)
                {
                    SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
                    bDirty = TRUE;
                }
            }
            break;

        case WM_NOTIFY:

            pGPO = (CGroupPolicyObject *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pGPO) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    if (bDirty)
                    {
                        DWORD dwTemp = 0;
                        HRESULT hr;


                        //
                        // Set the disable flags in the GPO
                        //

                        if (IsDlgButtonChecked (hDlg, IDC_DISABLE_COMPUTER) == BST_CHECKED)
                        {
                            dwTemp |= GPO_OPTION_DISABLE_MACHINE;
                        }

                        if (IsDlgButtonChecked (hDlg, IDC_DISABLE_USER) == BST_CHECKED)
                        {
                            dwTemp |= GPO_OPTION_DISABLE_USER;
                        }

                        hr = pGPO->SetOptions (dwTemp, (GPO_OPTION_DISABLE_MACHINE | GPO_OPTION_DISABLE_USER));

                        if (FAILED(hr))
                        {
                            ReportError(hDlg, hr, IDS_FAILEDPROPERTIES);
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                            return TRUE;
                        }

                        bDirty = FALSE;
                    }
                }
                // fall through...

                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aPropertiesHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aPropertiesHelpIds);
            return (TRUE);
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CGroupPolicyObjectCF::CGroupPolicyObjectCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CGroupPolicyObjectCF::~CGroupPolicyObjectCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CGroupPolicyObjectCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CGroupPolicyObjectCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CGroupPolicyObjectCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CGroupPolicyObjectCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CGroupPolicyObject *pGroupPolicyObject = new CGroupPolicyObject(); // ref count == 1

    if (!pGroupPolicyObject)
        return E_OUTOFMEMORY;

    HRESULT hr = pGroupPolicyObject->QueryInterface(riid, ppvObj);
    pGroupPolicyObject->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CGroupPolicyObjectCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


//*************************************************************
//
//  CGroupPolicyObject::GetProperty
//
//  Purpose:    Retrieves a property from DS or from gpt.ini
//
//  Parameters: pszProp   - Property to get
//              xValueIn  - Value returned here
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT  CGroupPolicyObject::GetProperty( TCHAR *pszProp, XPtrST<TCHAR>& xValueIn )
{
    HRESULT hr = E_FAIL;

    if ( m_gpoType == GPOTypeDS )
    {
        VARIANT var;
        BSTR bstrProperty;

        VariantInit( &var );
        bstrProperty = SysAllocString( pszProp );

        if ( bstrProperty == NULL )
            return E_OUTOFMEMORY;

        hr = m_pADs->Get( bstrProperty, &var );

        if ( SUCCEEDED(hr) )
        {
            ULONG ulNoChars = lstrlen(var.bstrVal) + 1;
            TCHAR *pszValue = new TCHAR[ulNoChars];
            if ( pszValue == 0 )
                hr = E_OUTOFMEMORY;
            else
            {
                hr = StringCchCopy ( pszValue, ulNoChars, var.bstrVal );
                ASSERT(SUCCEEDED(hr));
                xValueIn.Set( pszValue );

                hr = S_OK;
            }
        } else if ( hr == E_ADS_PROPERTY_NOT_FOUND )
        {
            //
            // Property has not be written out before
            //

            hr = S_OK;
        }

        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetProperty: Failed with errorcode 0x%x"), hr));
        }

        SysFreeString( bstrProperty );
        VariantClear( &var );

        return hr;
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];

        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::GetProperty: Failed with errorcode 0x%x"), hr));
        }

        (void) CheckSlash (szPath);
        hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("GPT.INI"));
        if (FAILED(hr)) 
        {
            return hr;
        }

        XPtrST<TCHAR> xszValue( new TCHAR[2*MAX_PATH] );
        if ( xszValue.GetPointer() == NULL )
            return E_OUTOFMEMORY;

        DWORD dwSize = (2*MAX_PATH);
        DWORD dwCount = GetPrivateProfileString( TEXT("General"),
                                                 pszProp,
                                                 TEXT(""),
                                                 xszValue.GetPointer(),
                                                 dwSize,
                                                 szPath );
        while ( dwCount == dwSize - 1 )
        {
            //
            // Value has been truncated, so retry with larger buffer
            //

            dwSize *= 2;
            delete xszValue.Acquire();
            xszValue.Set( new TCHAR[dwSize] );

            if ( xszValue.GetPointer() == NULL )
                return E_OUTOFMEMORY;

            dwCount = GetPrivateProfileString( TEXT("General"),
                                               pszProp,
                                               TEXT(""),
                                               xszValue.GetPointer(),
                                               dwSize,
                                               szPath );
        }

        xValueIn.Set( xszValue.Acquire() );

        return S_OK;
    }
}


//*************************************************************
//
//  CGroupPolicyObject::SetProperty
//
//  Purpose:    Writes a property to DS or to gpt.ini
//
//  Parameters: pszProp      - Property to set
//              pszPropValue - Property value
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT  CGroupPolicyObject::SetProperty( TCHAR *pszProp, TCHAR *pszPropValue )
{
    HRESULT hr = E_FAIL;

    if ( m_gpoType == GPOTypeDS )
    {
        VARIANT var;

        VariantInit( &var );

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString( pszPropValue );
        if ( var.bstrVal == 0 )
            return E_OUTOFMEMORY;

        BSTR bstrProperty = SysAllocString( pszProp );
        if ( bstrProperty == 0 )
        {
            VariantClear( &var );
            return E_OUTOFMEMORY;
        }

        hr = m_pADs->Put( bstrProperty, var );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetProperty: Failed with errorcode 0x%x"), hr));
            return hr;
        }

        SysFreeString( bstrProperty );
        VariantClear( &var );

        return S_OK;
    }
    else
    {
        TCHAR szPath[2*MAX_PATH];

        //
        // Get the file system path
        //

        hr = GetPath (szPath, ARRAYSIZE(szPath));
        if ( FAILED(hr) ) {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetProperty: Failed with errorcode 0x%x"), hr));
        }

        (void) CheckSlash (szPath);
        hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("GPT.INI"));
        if (FAILED(hr)) 
        {
            return hr;
        }

        BOOL bOk  = WritePrivateProfileString( TEXT("General"),
                                               pszProp,
                                               pszPropValue,
                                               szPath );
        if ( bOk )
            hr = S_OK;
        else
            hr = GetLastError();

        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\guidlist.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        guidlist.h
//
// Contents:    Classes for marshalling, unmarshalling Guids
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#pragma once

typedef struct _GUIDELEM
{
    GUID                guid;           // Extension guid
    struct _GUIDELEM *  pSnapinGuids;   // List of snapin guids
    struct _GUIDELEM *  pNext;          // Singly linked list ptr
} GUIDELEM, *LPGUIDELEM;

void FreeGuidList( LPGUIDELEM pGuidList );

class CGuidList
{

public:
    CGuidList();
    ~CGuidList();

    HRESULT MarshallGuids( XPtrST<TCHAR> & xValueOut );
    HRESULT UnMarshallGuids( TCHAR *pszGuids );

    HRESULT Update( BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin );
    BOOL GuidsChanged()        { return m_bGuidsChanged; }

private:
    HRESULT UpdateSnapinGuid( BOOL bAdd, GUIDELEM *pCurPtr, GUID *pGuidSnapin );

    GUIDELEM *  m_pExtGuidList;
    BOOL        m_bGuidsChanged;
};



//*************************************************************
//
//  XGuidElem
//
//  Purpose:    Smart pointer for GUIDELEM list
//
//*************************************************************

class XGuidElem
{

public:
    XGuidElem()
       : m_pGuidList(0)
    {
    }

    ~XGuidElem()
    {
        FreeGuidList( m_pGuidList );
    }

    void Set( GUIDELEM *pGuidList )
    {
        m_pGuidList = pGuidList;
    }

    GUIDELEM *Acquire()
    {
        GUIDELEM *pTemp = m_pGuidList;
        m_pGuidList = 0;
        
        return pTemp;
    }


private:
    GUIDELEM *m_pGuidList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\gpedit.cpp ===
#include "main.h"
#include <initguid.h>
#include "about.h"
#include <gpedit.h>

//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;
DWORD g_dwNameSpaceItems;
CRITICAL_SECTION g_DCCS;
TCHAR g_szDisplayProperties[150] = {0};


//
// Group Policy Manager's snapin GUID
// {D70A2BEA-A63E-11d1-A7D4-0000F87571E3}
//

DEFINE_GUID(CLSID_GPMSnapIn, 0xd70a2bea, 0xa63e, 0x11d1, 0xa7, 0xd4, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// RSOP Context Menu GUID for planning mode
// {63E23168-BFF7-4E87-A246-EF024425E4EC}
//

DEFINE_GUID(CLSID_RSOP_CMenu, 0x63E23168, 0xBFF7, 0x4E87, 0xA2, 0x46, 0xEF, 0x02, 0x44, 0x25, 0xE4, 0xEC);

// 
// GPMC Snapin
//

const TCHAR szGPMCSnapIn[] = TEXT("{789D9216-FDF0-476e-9D73-058C6A7375C3}");

//
// DS Admin's snapin ID
//

const TCHAR szDSAdmin[] = TEXT("{E355E538-1C2E-11D0-8C37-00C04FD8FE93}");


//
// Nodes the GPM extends in DS Admin
//

const LPTSTR szDSAdminNodes[] =
   {
   TEXT("{19195a5b-6da0-11d0-afd3-00c04fd930c9}"),   // Domain
   TEXT("{bf967aa5-0de6-11d0-a285-00aa003049e2}"),   // Organizational unit
   };


//
// Site Manager's snapin ID
//

const TCHAR szSiteMgr[] = TEXT("{D967F824-9968-11D0-B936-00C04FD8D5B0}");


//
// Nodes the GPM extends in DS Admin
//

const LPTSTR szSiteMgrNodes[] =
   {
   TEXT("{bf967ab3-0de6-11d0-a285-00aa003049e2}")  // Site
   };


const LPTSTR szDSTreeSnapinNodes[] =
   {
   TEXT("{4c06495e-a241-11d0-b09b-00c04fd8dca6}") // Forest
   };


const LPTSTR szDSAdminRsopTargetNodes[] = 
   {
    
   TEXT("{bf967aba-0de6-11d0-a285-00aa003049e2}"), // user
   TEXT("{bf967a86-0de6-11d0-a285-00aa003049e2}")  // comp
   };



//
// Help topic commands
//

const TCHAR g_szGPERoot[]    = TEXT("gpedit.chm::/gpe_default.htm");
const TCHAR g_szUser[]       = TEXT("gpedit.chm::/user.htm");
const TCHAR g_szMachine[]    = TEXT("gpedit.chm::/machine.htm");
const TCHAR g_szWindows[]    = TEXT("gpedit.chm::/windows.htm");
const TCHAR g_szSoftware[]   = TEXT("gpedit.chm::/software.htm");

const TCHAR g_szRsopRoot[]   = TEXT("rsop.chm::/RSPIntro.htm");

//
// Result pane items for the nodes with no result pane items
//

RESULTITEM g_Undefined[] =
{
    { 1, 1, 0, 0, {0} }
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_NameSpace[] =
{
  { 0, -1, 2, 2, IDS_SNAPIN_NAME, IDS_SNAPIN_DESCRIPT,           2, {0}, 0, g_Undefined, &NODEID_GPERoot,           g_szGPERoot  },  // GPE Root
  { 1,  0, 4, 4, IDS_MACHINE,     IDS_MACHINE_DESC,              2, {0}, 0, g_Undefined, &NODEID_MachineRoot,       g_szMachine  },  // Computer Configuration
  { 2,  0, 5, 5, IDS_USER,        IDS_USER_DESC,                 2, {0}, 0, g_Undefined, &NODEID_UserRoot,          g_szUser     },  // User Configuration

  { 3,  1, 0, 1, IDS_SWSETTINGS,  IDS_C_SWSETTINGS_DESC,         0, {0}, 0, g_Undefined, &NODEID_MachineSWSettings, g_szSoftware },  // Computer Configuration\Software Settings
  { 4,  1, 0, 1, IDS_WINSETTINGS, IDS_C_WINSETTINGS_DESC,        0, {0}, 0, g_Undefined, &NODEID_Machine,           g_szWindows  },  // Computer Configuration\Windows Settings

  { 5,  2, 0, 1, IDS_SWSETTINGS,  IDS_U_SWSETTINGS_DESC,         0, {0}, 0, g_Undefined, &NODEID_UserSWSettings,    g_szSoftware },  // User Configuration\Software Settings
  { 6,  2, 0, 1, IDS_WINSETTINGS, IDS_U_WINSETTINGS_DESC,        0, {0}, 0, g_Undefined, &NODEID_User,              g_szWindows  },  // User Configuration\Windows Settings
};

NAMESPACEITEM g_RsopNameSpace[] =
{
  { 0, -1, 2, 2, IDS_RSOP_SNAPIN_NAME, IDS_RSOP_SNAPIN_DESCRIPT, 2, {0}, 0, g_Undefined, &NODEID_RSOPRoot,      g_szRsopRoot  },  // Root of the rsop snapin
  { 1,  0, 4, 4, IDS_MACHINE,          IDS_MACHINE_DESC,         2, {0}, 0, g_Undefined, &NODEID_RSOPMachineRoot,       g_szMachine  },  // Computer Configuration
  { 2,  0, 5, 5, IDS_USER,             IDS_USER_DESC,            2, {0}, 0, g_Undefined, &NODEID_RSOPUserRoot,          g_szUser     },  // User Configuration

  { 3,  1, 0, 1, IDS_SWSETTINGS,       IDS_C_SWSETTINGS_DESC,    0, {0}, 0, g_Undefined, &NODEID_RSOPMachineSWSettings, g_szSoftware },  // Computer Configuration\Software Settings
  { 4,  1, 0, 1, IDS_WINSETTINGS,      IDS_C_WINSETTINGS_DESC,   0, {0}, 0, g_Undefined, &NODEID_RSOPMachine,           g_szWindows  },  // Computer Configuration\Windows Settings

  { 5,  2, 0, 1, IDS_SWSETTINGS,       IDS_U_SWSETTINGS_DESC,    0, {0}, 0, g_Undefined, &NODEID_RSOPUserSWSettings,    g_szSoftware },  // User Configuration\Software Settings
  { 6,  2, 0, 1, IDS_WINSETTINGS,      IDS_U_WINSETTINGS_DESC,   0, {0}, 0, g_Undefined, &NODEID_RSOPUser,              g_szWindows  },  // User Configuration\Windows Settings
};



BOOL InitNameSpace()
{
    DWORD dwIndex;

    g_dwNameSpaceItems = ARRAYSIZE(g_NameSpace);

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_NameSpace[dwIndex].iStringID)
        {
            LoadString (g_hInstance, g_NameSpace[dwIndex].iStringID,
                        g_NameSpace[dwIndex].szDisplayName,
                        MAX_DISPLAYNAME_SIZE);
        }
    }

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if (g_RsopNameSpace[dwIndex].iStringID)
        {
            LoadString (g_hInstance, g_RsopNameSpace[dwIndex].iStringID,
                        g_RsopNameSpace[dwIndex].szDisplayName,
                        MAX_DISPLAYNAME_SIZE);
        }
    }

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    WORD wVersionRequested;
    WSADATA wsaData;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitNameSpace();
       InitializeCriticalSection(&g_DCCS);
       InitDebugSupport();
       LoadString (hInstance, IDS_DISPLAYPROPERTIES, g_szDisplayProperties, ARRAYSIZE(g_szDisplayProperties));

         
       wVersionRequested = MAKEWORD( 2, 2 );
         
       // we need to call WSAStartup to do gethostbyname
       // Error is handled gracefully. Safe to ignore the error
       WSAStartup( wVersionRequested, &wsaData );
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
       WSACleanup( );
       FreeDCSelections();
       DeleteCriticalSection(&g_DCCS);
    }
    
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;


    if (IsEqualCLSID (rclsid, CLSID_GPESnapIn)) {

        CComponentDataCF *pComponentDataCF = new CComponentDataCF();   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_GroupPolicyObject)) {

        CGroupPolicyObjectCF *pGroupPolicyObjectCF = new CGroupPolicyObjectCF();   // ref == 1

        if (!pGroupPolicyObjectCF)
            return E_OUTOFMEMORY;

        hr = pGroupPolicyObjectCF->QueryInterface(riid, ppv);

        pGroupPolicyObjectCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_GPMSnapIn)) {

        CGroupPolicyMgrCF *pGroupPolicyMgrCF = new CGroupPolicyMgrCF();   // ref == 1

        if (!pGroupPolicyMgrCF)
            return E_OUTOFMEMORY;

        hr = pGroupPolicyMgrCF->QueryInterface(riid, ppv);

        pGroupPolicyMgrCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPSnapIn)) {

        CRSOPComponentDataCF *pRSOPComponentDataCF = new CRSOPComponentDataCF();   // ref == 1

        if (!pRSOPComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pRSOPComponentDataCF->QueryInterface(riid, ppv);

        pRSOPComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_AboutGPE)) {

        CAboutGPECF *pAboutGPECF = new CAboutGPECF();   // ref == 1

        if (!pAboutGPECF)
            return E_OUTOFMEMORY;

        hr = pAboutGPECF->QueryInterface(riid, ppv);

        pAboutGPECF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPAboutGPE)) {

        CAboutGPECF *pAboutGPECF = new CAboutGPECF(TRUE);   // ref == 1

        if (!pAboutGPECF)
            return E_OUTOFMEMORY;

        hr = pAboutGPECF->QueryInterface(riid, ppv);

        pAboutGPECF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOP_CMenu)) {

        CRSOPCMenuCF *pRSOPCMenuCF = new CRSOPCMenuCF();   // ref == 1 

        if (!pRSOPCMenuCF)
            return E_OUTOFMEMORY;

        hr = pRSOPCMenuCF->QueryInterface(riid, ppv);

        pRSOPCMenuCF->Release();     // release initial ref

        return hr;
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

const TCHAR szDLLLocation[] = TEXT("%SystemRoot%\\System32\\GPEdit.dll");
const TCHAR szThreadingModel[] = TEXT("Apartment");
const TCHAR szSnapInNameIndirect[] = TEXT("@gpedit.dll,-1");
const TCHAR szRsopSnapInNameIndirect[] = TEXT("@gpedit.dll,-4");
const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");
const TCHAR szDefRsopMscLocation [] = TEXT("%systemroot%\\system32\\rsop.msc");

STDAPI DllRegisterServer(void)
{
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szSnapInKey[50];
    TCHAR szRsopSnapInKey[50];
    TCHAR szRsopSnapInName[100];
    TCHAR szRsopName[100];
    TCHAR szRsopGUID[50];
    TCHAR szName[100];
    TCHAR szGUID[50];
    DWORD dwDisp, dwIndex;
    LONG lResult;
    HKEY hKey;
    INT i;
    HKEY hGPMCKey;
    DWORD dwError;
    HRESULT hr;

    //
    // Register GPE SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    //
    // Register RSOP SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szRsopSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_SNAPIN_NAME, szRsopSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szRsopSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szRsopSnapInName,
                   (lstrlen(szRsopSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szRsopSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register GPO in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GroupPolicyObject, szGUID, 50);
    LoadString (g_hInstance, IDS_GPO_NAME, szName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register AboutGPE in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_AboutGPE, szGUID, 50);
    LoadString (g_hInstance, IDS_ABOUT_NAME, szName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);

    //
    // Register RSOPAboutGPE in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOPAboutGPE, szGUID, 50);
    LoadString (g_hInstance, IDS_ABOUT_NAME, szName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szName,
                   (lstrlen(szName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szGUID);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register GPE SnapIn with MMC
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_SNAPIN_NAME, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    StringFromGUID2 (CLSID_AboutGPE, szGUID, 50);
    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID,
                   (lstrlen(szGUID) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                              szSnapInKey, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\StandAlone"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register RSOP SnapIn with MMC
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szRsopSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_SNAPIN_NAME, szRsopSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szRsopSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szRsopSnapInName,
                   (lstrlen(szRsopSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szRsopSnapInNameIndirect,
                   (lstrlen(szRsopSnapInNameIndirect) + 1) * sizeof(TCHAR));

    StringFromGUID2 (CLSID_RSOPAboutGPE, szGUID, 50);
    RegSetValueEx (hKey, TEXT("About"), 0, REG_SZ, (LPBYTE) szGUID,
                   (lstrlen(szGUID) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szGUID, 50);

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
                              szRsopSnapInKey, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\StandAlone"), 
                          szRsopSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register in the NodeTypes key and register for the view extension
    //

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szGUID, 50);

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\View"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                       (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

        RegCloseKey (hKey);

        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szGUID, 50);

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\View"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                       (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

        RegCloseKey (hKey);
    }

    //
    // Register GPM SnapIn in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_GPMSnapIn, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_GPM_SNAPIN_NAME, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register GPMSnapIn with MMC
    //

    hr = StringCchPrintf (szSubKey,
                           ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Check if GPMC is running already
    // If so, register CLSID of GPMC Snapin
    //

    dwError = RegOpenKeyEx ( HKEY_LOCAL_MACHINE,
                             L"Software\\Microsoft\\Group Policy Management Console",
                             0,
                             KEY_QUERY_VALUE,
                             &hGPMCKey );

    if (ERROR_SUCCESS == dwError) 
    {
        RegCloseKey(hGPMCKey);
        hr = StringCchCopy (szSnapInKey,ARRAYSIZE(szSnapInKey), szGPMCSnapIn);
        if (FAILED(hr)) 
        {
            return hr;
        }
    }

    //
    // Register as a DS admin property sheet extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szDSAdmin, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a site mgr property sheet extension
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szSiteMgrNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey,
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szSiteMgr, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register RSOP Context Menu in HKEY_CLASSES_ROOT
    //

    StringFromGUID2 (CLSID_RSOP_CMenu, szSnapInKey, 50);
    LoadString (g_hInstance, IDS_RSOP_CMENU_NAME, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s\\InProcServer32"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)szDLLLocation,
                   (lstrlen(szDLLLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register RSOP Context Menu with MMC.
    // !!!!! Check whether this is necessary
    //

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (FAILED(hr)) 
    {
        return hr;
    }
    
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)szSnapInNameIndirect,
                   (lstrlen(szSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register as a DS admin task menu extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szDSAdmin, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a DS admin rsop target task menu extension
    //

    for (i=0; i < ARRAYSIZE(szDSAdminRsopTargetNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminRsopTargetNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szDSAdmin, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


    //
    // Register as a site mgr task menu extension
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szSiteMgrNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szSiteMgr, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }

    //
    // Mark the authormode rsop.msc as read only
    //

    TCHAR  szRsopMscFileName[MAX_PATH+1];

    if (ExpandEnvironmentStrings(szDefRsopMscLocation, szRsopMscFileName, MAX_PATH+1)) {
        SetFileAttributes(szRsopMscFileName, FILE_ATTRIBUTE_READONLY);
    }
    else {
        DebugMsg((DM_WARNING, TEXT("DllRegisterServer: ExpandEnvironmentStrings failed with error %d"), GetLastError()));
    }

#if FGPO_SUPPORT

    // register as a DSTree snapin property sheet extension
    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSTreeSnapinNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"), 
                              szSiteMgr, 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegCloseKey (hKey);


        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                                  szSubKey,
                                  0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                                  &hKey, &dwDisp);

        if (lResult != ERROR_SUCCESS) {
            return SELFREG_E_CLASS;
        }

        RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                       (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


        RegCloseKey (hKey);
    }


#else

    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSTreeSnapinNodes[i]);
        if (FAILED(hr)) 
        {
            return hr;
        }

        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                              szGUID);
        if (FAILED(hr)) 
        {
            return hr;
        }

        lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                szSubKey,
                                0,
                                KEY_WRITE, &hKey);


        if (lResult == ERROR_SUCCESS) {
            RegDeleteValue (hKey, szSnapInKey);
            RegCloseKey (hKey);
        }
    }

#endif

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    TCHAR szSnapInKey[50];
    DWORD dwIndex;
    LONG lResult;
    INT i;
    HKEY hKey;
    HRESULT hr;

    //
    // Unregister GPE
    //

    StringFromGUID2 (CLSID_GPESnapIn, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_NameSpace[dwIndex].pNodeID, szSnapInKey, 50);
        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), 
                              szSnapInKey);
        if (SUCCEEDED(hr)) 
        {
            RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
        }
    }

    //
    // Unregister RSOP
    //

    StringFromGUID2 (CLSID_RSOPSnapIn, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }

    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        StringFromGUID2 (*g_RsopNameSpace[dwIndex].pNodeID, szSnapInKey, 50); // undone
        hr = StringCchPrintf (szSubKey, 
                              ARRAYSIZE(szSubKey), 
                              TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), 
                              szSnapInKey);
        if (SUCCEEDED(hr)) 
        {
            RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
        }
    }


    //
    // Unregister GPO
    //

    StringFromGUID2 (CLSID_GroupPolicyObject, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    //
    // Unregister AboutGPE
    //

    StringFromGUID2 (CLSID_AboutGPE, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    //
    // Unregister RSOPAboutGPE
    //

    StringFromGUID2 (CLSID_RSOPAboutGPE, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    //
    // Unregister GPM
    //

    StringFromGUID2 (CLSID_GPMSnapIn, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }


    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }


    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szSiteMgrNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }

    //
    // Unregister rsop context menu
    //


    StringFromGUID2 (CLSID_RSOP_CMenu, szSnapInKey, 50);
    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("CLSID\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_CLASSES_ROOT, szSubKey);
    }

    hr = StringCchPrintf (szSubKey, 
                          ARRAYSIZE(szSubKey), 
                          TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), 
                          szSnapInKey);
    if (SUCCEEDED(hr)) 
    {
        RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);
    }

    //
    // from ds admin nodes
    //

    for (i=0; i < ARRAYSIZE(szDSAdminNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }

    for (i=0; i < ARRAYSIZE(szDSAdminRsopTargetNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSAdminRsopTargetNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }
    
    //
    // from sites node
    //

    for (i=0; i < ARRAYSIZE(szSiteMgrNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szSiteMgrNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\ContextMenu"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }



    for (i=0; i < ARRAYSIZE(szDSTreeSnapinNodes); i++)
    {
        hr = StringCchCopy (szGUID, ARRAYSIZE(szGUID), szDSTreeSnapinNodes[i]);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchPrintf (szSubKey, 
                                  ARRAYSIZE(szSubKey), 
                                  TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\PropertySheet"), 
                                  szGUID);
        }

        if (SUCCEEDED(hr)) 
        {
            lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                                    szSubKey,
                                    0,
                                    KEY_WRITE, &hKey);


            if (lResult == ERROR_SUCCESS) {
                RegDeleteValue (hKey, szSnapInKey);
                RegCloseKey (hKey);
            }
        }
    }


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\gpobj.h ===
class CGroupPolicyObject;

typedef struct _GLPARAM
{
    BOOL fFinding;
    BOOL fAbort;
    CGroupPolicyObject * pGPO;
} GLPARAM;

typedef struct _GLTHREADPARAM
{
    HWND hDlg;
    BOOL * pfAbort;
    CGroupPolicyObject * pGPO;
    LPOLESTR pszLDAPName;
} GLTHREADPARAM;

#define PDM_CHANGEBUTTONTEXT    (WM_USER + 1000)

//
// CGroupPolicyObject class
//
class CGroupPolicyObject : public IGroupPolicyObject
{
public:
    CGroupPolicyObject();
    ~CGroupPolicyObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IGroupPolicyObject methods
    //

    STDMETHOD(New) (LPOLESTR pszDomainName, LPOLESTR pszDisplayName, DWORD dwFlags);
    STDMETHOD(OpenDSGPO) (LPOLESTR pszPath, DWORD dwFlags);
    STDMETHOD(OpenLocalMachineGPO) (DWORD dwFlags);
    STDMETHOD(OpenRemoteMachineGPO) (LPOLESTR pszCompterName, DWORD dwFlags);
    STDMETHOD(Save) (BOOL bMachine, BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin );
    STDMETHOD(Delete) (void);
    STDMETHOD(GetName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetDisplayName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(SetDisplayName) (LPOLESTR pszName);
    STDMETHOD(GetPath) (LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetDSPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetFileSysPath) (DWORD dwSection, LPOLESTR pszPath, int cchMaxPath);
    STDMETHOD(GetRegistryKey) (DWORD dwSection, HKEY *hKey);
    STDMETHOD(GetOptions) (DWORD *dwOptions);
    STDMETHOD(SetOptions) (DWORD dwOptions, DWORD dwMask);
    STDMETHOD(GetType) (GROUP_POLICY_OBJECT_TYPE *gpoType);
    STDMETHOD(GetMachineName) (LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetPropertySheetPages) (HPROPSHEETPAGE **hPages, UINT *uPageCount);


    //
    // Internal methods
    //

    STDMETHOD(CreateContainer) (LPOLESTR lpParent, LPOLESTR lpCommonName, BOOL bGPC);
    STDMETHOD(SetDisplayNameI) (IADs * pADs, LPOLESTR lpDisplayName,
                                LPOLESTR lpGPTPath, BOOL bUpdateDisplayVar);
    STDMETHOD(SetGPOInfo) (LPOLESTR lpGPO, LPOLESTR lpDisplayName, LPOLESTR lpGPTPath);
    STDMETHOD(CheckFSWriteAccess) (LPOLESTR lpLocalGPO);
    STDMETHOD(GetSecurityDescriptor) (IADs *pADs, SECURITY_INFORMATION si,
                                      PSECURITY_DESCRIPTOR *pSD);
    BOOL EnableSecurityPrivs(void);
    DWORD EnableInheritance (PACL pAcl);
    DWORD SetSysvolSecurity (LPTSTR lpFileSysPath, SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
    STDMETHOD(CleanUp) (void);
    STDMETHOD(RefreshGroupPolicy) (BOOL bMachine);

    static HRESULT WINAPI ReadSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR *pSD, LPARAM lpContext);
    static HRESULT WINAPI WriteSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, LPARAM lpContext);
    static INT_PTR CALLBACK WQLFilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PropertiesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK GPELinksDlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI GLThreadFunc(GLTHREADPARAM  * pgltp);
    DWORD WINAPI FindLinkInDomain(GLTHREADPARAM  * pgltp, LPTSTR lpGPO);
    DWORD WINAPI FindLinkInSite(GLTHREADPARAM  * pgltp, LPTSTR lpGPO);
    BOOL FillDomainList (HWND hWndCombo);

private:

    HRESULT GetProperty( TCHAR *pszProp, XPtrST<TCHAR>& xValueIn );
    HRESULT SetProperty( TCHAR *pszProp, TCHAR *pszPropValue );

    ULONG                       m_cRef;
    BOOL                        m_bInitialized;
    IADs                       *m_pADs;
    GROUP_POLICY_OBJECT_TYPE    m_gpoType;
    DWORD                       m_dwFlags;
    LPOLESTR                    m_pName;
    LPOLESTR                    m_pDisplayName;
    LPOLESTR                    m_pMachineName;
    CRegistryHive              *m_pUser;
    CRegistryHive              *m_pMachine;

    HINSTANCE                   m_hinstDSSec;
    PFNDSCREATESECPAGE          m_pfnDSCreateSecurityPage;

    LPTSTR                      m_pTempFilterString;

public:

    LPOLESTR                    m_pDSPath;
    LPOLESTR                    m_pFileSysPath;
};


//
// GroupPolicyObject class factory
//


class CGroupPolicyObjectCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CGroupPolicyObjectCF();
    ~CGroupPolicyObjectCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// Strings
//

#define GPO_VERSION_PROPERTY     L"versionNumber"
#define GPT_PATH_PROPERTY        L"gPCFileSysPath"
#define GPO_NAME_PROPERTY        L"displayName"
#define GPO_OPTIONS_PROPERTY     L"flags"
#define GPO_FUNCTION_PROPERTY    L"gPCFunctionalityVersion"
#define GPO_WQLFILTER_PROPERTY   L"gPCWQLFilter"

#define GPO_USEREXTENSION_NAMES  L"gPCUserExtensionNames"
#define GPO_MACHEXTENSION_NAMES  L"gPCMachineExtensionNames"


#define LOCAL_GPO_DIRECTORY      TEXT("%SystemRoot%\\System32\\GroupPolicy")
#define REMOTE_GPO_DIRECTORY     TEXT("\\\\%s\\ADMIN$\\System32\\GroupPolicy")

#define SITE_NAME_PROPERTY       L"name"
#define DOMAIN_NAME_PROPERTY     L"name"

//
// Functionality version
//

#define GPO_FUNCTIONALITY_VERSION  2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\guidlist.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        guidlist.cpp
//
// Contents:    Classes for marshalling, unmarshalling Guids
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#include "main.h"



//*************************************************************
//
//  CGuidList::CGuidList, ~CGuidList
//
//  Purpose:    Constructor, destructor
//
//*************************************************************

CGuidList::CGuidList()
    : m_pExtGuidList(0),
      m_bGuidsChanged(FALSE)
{
}


CGuidList::~CGuidList()
{
    FreeGuidList( m_pExtGuidList );
}


void FreeGuidList( GUIDELEM *pGuidList )
{
    while ( pGuidList )
    {
        //
        // Free snapin guids
        //
        GUIDELEM *pTemp;
        GUIDELEM *pGuidSnp = pGuidList->pSnapinGuids;

        while ( pGuidSnp )
        {
            pTemp = pGuidSnp->pNext;
            delete pGuidSnp;
            pGuidSnp = pTemp;
        }

        pTemp = pGuidList->pNext;
        delete pGuidList;
        pGuidList = pTemp;
    }
}


//*************************************************************
//
//  CGuidList::UnMarshallGuids
//
//  Purpose:    Converts string representation of guids to list
//              of guids.
//
//  Parameters: pszGuids  - String to convert
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::UnMarshallGuids( TCHAR *pszGuids )
{
    //
    // Format is [{ext guid1}{snapin guid1}..{snapin guidn}][{ext guid2}...]...\0
    // Both extension and snapin guids are in ascending order.
    //

    TCHAR *pchCur = pszGuids;

    XGuidElem xGuidElem;
    GUIDELEM *pGuidExtTail = 0;

    if ( pszGuids == 0 || lstrcmpi( pszGuids, TEXT(" ") ) == 0 )
    {
        //
        // Empty property case, so nothing to unmarshall
        //

        m_pExtGuidList = 0;
        return S_OK;
    }

    //
    // Outer loop over extensions
    //

    while ( *pchCur )
    {
        if ( *pchCur == TEXT('[') )
            pchCur++;
        else
            return E_FAIL;

        GUID guidExt;
        if ( ValidateGuid( pchCur ) )
            StringToGuid( pchCur, &guidExt );
        else
            return E_FAIL;

        GUIDELEM *pGuidExt = new GUIDELEM;
        if ( pGuidExt == 0 )
            return E_OUTOFMEMORY;

        pGuidExt->guid = guidExt;
        pGuidExt->pSnapinGuids = 0;
        pGuidExt->pNext = 0;

        //
        // Append to end of list
        //

        if ( pGuidExtTail == 0 )
            xGuidElem.Set( pGuidExt );
        else
            pGuidExtTail->pNext = pGuidExt;

        pGuidExtTail = pGuidExt;

        //
        // Move past '{', then skip until next '{
        //

        pchCur++;

        while ( *pchCur && *pchCur != TEXT('{') )
            pchCur++;

        if ( !(*pchCur) )
            return E_FAIL;

        //
        // Inner loop over snapin guids
        //

        GUIDELEM *pGuidSnapinTail = 0;

        while ( *pchCur != TEXT(']') )
        {
            GUID guidSnp;

            if ( ValidateGuid( pchCur ) )
                StringToGuid( pchCur, &guidSnp );
            else
                return E_FAIL;

            GUIDELEM *pGuidSnapin = new GUIDELEM;
            if ( pGuidSnapin == 0 )
                return E_OUTOFMEMORY;

            pGuidSnapin->guid = guidSnp;
            pGuidSnapin->pSnapinGuids = 0;
            pGuidSnapin->pNext = 0;

            //
            // Append to end of list
            //

            if ( pGuidSnapinTail == 0 )
                pGuidExtTail->pSnapinGuids = pGuidSnapin;
            else
                pGuidSnapinTail->pNext = pGuidSnapin;

            pGuidSnapinTail = pGuidSnapin;

            while ( *pchCur && *pchCur != TEXT('}') )
                pchCur++;

            if ( !(*pchCur) )
                return E_FAIL;

            pchCur++;

            if ( *pchCur != TEXT('{') && *pchCur != TEXT(']') )
                return E_FAIL;
        } // inner while

        pchCur++;

    } // outer while

    m_pExtGuidList = xGuidElem.Acquire();

    return S_OK;
}



//*************************************************************
//
//  CGuidList::MarshallGuids
//
//  Purpose:    Converts list of guids to string representation
//
//  Parameters: xValueOut  - String representation returned here
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::MarshallGuids( XPtrST<TCHAR>& xValueOut )
{
    //
    // Get count of guids to allocate sufficient space up front
    //

    DWORD dwCount = 1;

    GUIDELEM *pGuidExt = m_pExtGuidList;
    while ( pGuidExt )
    {
        dwCount++;

        GUIDELEM *pGuidSnapin = pGuidExt->pSnapinGuids;
        while ( pGuidSnapin )
        {
            dwCount++;
            pGuidSnapin = pGuidSnapin->pNext;
        }

        pGuidExt = pGuidExt->pNext;
    }

    LONG lSize = dwCount * (GUID_LENGTH + 6);

    TCHAR *pszValue = new TCHAR[lSize];
    if ( pszValue == 0 )
        return E_OUTOFMEMORY;

    xValueOut.Set( pszValue );

    TCHAR *pchCur = pszValue;

    //
    // Actual marshalling
    //
    if ( m_pExtGuidList == 0 )
    {
        HRESULT hr;

        //
        // Adsi doesn't commit null strings, so use ' ' instead
        //

        hr = StringCchCopy( pchCur, lSize, TEXT(" ") );
        return hr;
    }

    pGuidExt = m_pExtGuidList;
    while ( pGuidExt )
    {
        DmAssert( lSize > GUID_LENGTH * 2 + (pchCur-pszValue) );

        *pchCur = TEXT('[');
        pchCur++;

        GuidToString( &pGuidExt->guid, pchCur );
        pchCur += GUID_LENGTH;

        GUIDELEM *pGuidSnp = pGuidExt->pSnapinGuids;
        while ( pGuidSnp )
        {
            DmAssert( lSize > GUID_LENGTH + (pchCur-pszValue) );

            GuidToString( &pGuidSnp->guid, pchCur );
            pchCur += GUID_LENGTH;

            pGuidSnp = pGuidSnp->pNext;
        }

        *pchCur = TEXT(']');

        pchCur++;

        pGuidExt = pGuidExt->pNext;
    }

    *pchCur = 0;

    return S_OK;
}



//*************************************************************
//
//  CGuidList::Update
//
//  Purpose:    Updates in memory list with guid info
//
//  Parameters: bAdd           - Add or delete
//              pGuidExtension - Extension's guid
//              pGuidSnapin    - Snapin's guid
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::Update( BOOL bAdd, GUID *pGuidExtension, GUID *pGuidSnapin )
{
    HRESULT hr = E_FAIL;
    GUIDELEM *pTrailPtr = NULL;
    GUIDELEM *pCurPtr = m_pExtGuidList;

    while ( pCurPtr != NULL )
    {
        if ( *pGuidExtension == pCurPtr->guid )
        {
            hr = UpdateSnapinGuid( bAdd, pCurPtr, pGuidSnapin );
            if ( FAILED(hr) )
                return hr;

            if ( pCurPtr->pSnapinGuids == NULL )
            {
                //
                // Remove extension from list
                //

                if ( pTrailPtr == NULL )
                    m_pExtGuidList = pCurPtr->pNext;
                else
                    pTrailPtr->pNext = pCurPtr->pNext;

                delete pCurPtr;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else if ( CompareGuid( pGuidExtension, &pCurPtr->guid ) < 0 )
        {
            //
            // Since guids are in ascending order,
            // pGuidExtension is not in list, add if necessary
            //

            if ( bAdd )
            {
                GUIDELEM *pGuidExt = new GUIDELEM;
                if ( pGuidExt == 0 )
                    return E_OUTOFMEMORY;

                pGuidExt->pSnapinGuids = new GUIDELEM;
                if ( pGuidExt->pSnapinGuids == 0 )
                {
                    delete pGuidExt;
                    return E_OUTOFMEMORY;
                }

                pGuidExt->guid = *pGuidExtension;
                pGuidExt->pNext = pCurPtr;

                pGuidExt->pSnapinGuids->guid = *pGuidSnapin;
                pGuidExt->pSnapinGuids->pSnapinGuids = 0;
                pGuidExt->pSnapinGuids->pNext = 0;

                if ( pTrailPtr == 0)
                    m_pExtGuidList = pGuidExt;
                else
                    pTrailPtr->pNext = pGuidExt;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else // compareguid
        {
            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;
        }
    } // while


    //
    // End of list or null list, add guid at end if necessary
    //
    if ( bAdd )
    {
        GUIDELEM *pGuidExt = new GUIDELEM;
        if ( pGuidExt == 0 )
            return E_OUTOFMEMORY;

        pGuidExt->pSnapinGuids = new GUIDELEM;
        if ( pGuidExt->pSnapinGuids == 0 )
        {
            delete pGuidExt;
            return E_OUTOFMEMORY;
        }

        pGuidExt->guid = *pGuidExtension;
        pGuidExt->pNext = 0;

        pGuidExt->pSnapinGuids->guid = *pGuidSnapin;
        pGuidExt->pSnapinGuids->pSnapinGuids = 0;
        pGuidExt->pSnapinGuids->pNext = 0;

        if ( pTrailPtr == 0)
            m_pExtGuidList = pGuidExt;
        else
            pTrailPtr->pNext = pGuidExt;

        m_bGuidsChanged = TRUE;
    }

    return S_OK;
}



//*************************************************************
//
//  CGuidList::UpdateSnapinGuid
//
//  Purpose:    Updates snapin list with guid info
//
//  Parameters: bAdd           - Add or delete
//              pExtGuid       - Extension's guid ptr
//              pGuidSnapin    - Snapin's guid
//
//  Returns:    S_OK if successful
//
//*************************************************************

HRESULT CGuidList::UpdateSnapinGuid( BOOL bAdd, GUIDELEM *pExtGuid,
                                     GUID *pGuidSnapin )
{
    GUIDELEM *pTrailPtr = 0;
    GUIDELEM *pCurPtr = pExtGuid->pSnapinGuids;

    while ( pCurPtr != NULL )
    {
        if ( *pGuidSnapin == pCurPtr->guid )
        {
            if ( !bAdd )
            {
                if ( pTrailPtr == NULL )
                    pExtGuid->pSnapinGuids = pCurPtr->pNext;
                else
                    pTrailPtr->pNext = pCurPtr->pNext;

                delete pCurPtr;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else if ( CompareGuid( pGuidSnapin, &pCurPtr->guid ) < 0 )
        {
            //
            // Since guids are in ascending order,
            // pGuidSnapin is not in list, add if necessary
            //

            if ( bAdd )
            {
                GUIDELEM *pGuidSnp = new GUIDELEM;
                if ( pGuidSnp == 0 )
                    return E_OUTOFMEMORY;

                pGuidSnp->guid = *pGuidSnapin;
                pGuidSnp->pSnapinGuids = 0;
                pGuidSnp->pNext = pCurPtr;

                if ( pTrailPtr == NULL )
                    pExtGuid->pSnapinGuids = pGuidSnp;
                else
                    pTrailPtr->pNext = pGuidSnp;

                m_bGuidsChanged = TRUE;
            }

            return S_OK;
        }
        else
        {
            //
            // Advance down the list
            //

            pTrailPtr = pCurPtr;
            pCurPtr = pCurPtr->pNext;
        }
    } // while

    //
    // End of list or null list, add guid at end if necessary
    //
    if ( bAdd )
    {
        GUIDELEM *pGuidSnp = new GUIDELEM;
        if ( pGuidSnp == 0 )
            return E_OUTOFMEMORY;

        pGuidSnp->guid = *pGuidSnapin;
        pGuidSnp->pSnapinGuids = 0;
        pGuidSnp->pNext = 0;

        if ( pTrailPtr == 0 )
            pExtGuid->pSnapinGuids = pGuidSnp;
        else
            pTrailPtr->pNext = pGuidSnp;

        m_bGuidsChanged = TRUE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\main.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <tchar.h>
#define SECURITY_WIN32
#include <security.h>
#include <lm.h>
#include <lmdfs.h>
#include <ole2.h>
#include <iads.h>
#include <iadsp.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <dsrole.h>
#include <mmc.h>
#include <accctrl.h>
#include <aclapi.h>
#include <winsock2.h>
#include <richedit.h>
#include <gpedit.h>
#ifndef RC_INVOKED
#include <wbemcli.h>
#include <ntdsapi.h>
#endif
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>
#include <dssec.h>
#include <winuserp.h>

class CSnapIn;

#include "structs.h"
#include "registry.h"
#include "compdata.h"
#include "snapin.h"
#include "events.h"
#include "rsoproot.h"
#include "rsopsnap.h"
#include "about.h"
#include "dataobj.h"
#include "rsopdobj.h"
#include "gpmgr.h"
#include "smartptr.h"
#include "guidlist.h"
#include "gpobj.h"
#include "debug.h"
#include "util.h"
#include "sid.h"
#include "pcommon.h"
#include <strsafe.h>

#if !defined(_WIN64)
#include <wow64t.h>

#define DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(x) { if (IsWin64()) {Wow64DisableFilesystemRedirector(x);} }
#define ENABLE_32BIT_FILE_REDIRECTION_ON_64BIT { if (IsWin64()) {Wow64EnableFilesystemRedirector();} }

#else // _WIN64

#define DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(x) 
#define ENABLE_32BIT_FILE_REDIRECTION_ON_64BIT 

#endif // _WIN64


//
// Resource ids
//

#define IDS_SNAPIN_NAME           1
#define IDS_SNAPIN_EXT_NAME       2
#define IDS_GPM_SNAPIN_NAME       3
#define IDS_RSOP_SNAPIN_NAME      4
#define IDS_DCOPTIONS             5
#define IDS_DCOPTIONSDESC         6
#define IDS_UNKNOWNREASON         7
#define IDS_DISPLAYNAME2          8
#define IDS_DISPLAYNAME           9
#define IDS_NOTAPPLICABLE        10
#define IDS_DATETIMEFORMAT       11
#define IDS_REVISIONFORMAT       12
#define IDS_NAMEFORMAT           13
#define IDS_NONE                 14
#define IDS_NOTSPECIFIED         15
#define IDS_ARCHIVEDATA          16
#define IDS_ARCHIVEDATADESC      17
#define IDS_ARCHIVEDATATAG       18
#define IDS_ARCHIVEDATA_CAPTION  19
#define IDS_ARCHIVEDATA_MESSAGE  20
#define IDS_DIAGNOSTIC           21
#define IDS_PLANNING             22
#define IDS_VERSION              23
#define IDS_VERSIONFORMAT        24
#define IDS_WMIFILTERFAILED      25
#define IDS_DISABLEDGPO          26
#define IDS_GPM_FORESTDESC       27
#define IDS_NAME                 28
#define IDS_MACHINE              29
#define IDS_USER                 30
#define IDS_SERVERAPPS           31
#define IDS_DEVICES              32
#define IDS_WINSETTINGS          33
#define IDS_SWSETTINGS           34
#define IDS_COMPUTERTITLE        35
#define IDS_UNTITLED             36
#define IDS_LOCAL_NAME           37
#define IDS_LOCAL_DISPLAY_NAME   38
#define IDS_REMOTE_DISPLAY_NAME  39

#define IDS_GPM_NAME             40
#define IDS_GPM_NOOVERRIDE       41
#define IDS_GPM_DISABLED         42
#define IDS_GPM_DESCRIPTION      43
#define IDS_GPM_NOGPONAME        44
#define IDS_GPM_ADDTITLE         45
#define IDS_GPM_DCNAME           46
#define IDS_GPM_DOMAINNAME       47
#define IDS_APPLIED              48
#define IDS_SECURITYDENIED       49
#define IDS_SNAPIN_DESCRIPT      50
#define IDS_PROVIDER_NAME        51
#define IDS_SNAPIN_VERSION       52
#define IDS_ABOUT_NAME           53
#define IDS_RSOP_SNAPIN_DESCRIPT 54
#define IDS_RSOP_ABOUT_NAME      55
#define IDS_RSOP_DETAILS         56
#define IDS_RSOP_SETTINGS        57
#define IDS_INVALIDMSC           58
#define IDS_ACCESSDENIED         59
#define IDS_FILTERING            60
#define IDS_SOM                  61
#define IDS_DISABLEDLINK         62
#define IDS_RSOP_DISPLAYNAME1    63
#define IDS_RSOP_DISPLAYNAME2    64
#define IDS_RSOP_FINISH_P0       65
#define IDS_RSOP_FINISH_P1       66
#define IDS_RSOP_FINISH_P2       67
#define IDS_RSOP_FINISH_P3       68
#define IDS_RSOP_FINISH_P4       69
#define IDS_RSOP_FINISH_P5       70
#define IDS_RSOP_FINISH_P6       71
#define IDS_RSOP_FINISH_P7       72
#define IDS_RSOP_FINISH_P8       73
#define IDS_RSOP_FINISH_P9       74
#define IDS_RSOP_FINISH_P10      75

#define IDS_BROWSE_USER_OU_TITLE 76
#define IDS_BROWSE_USER_OU_CAPTION 77
#define IDS_BROWSE_COMPUTER_OU_TITLE 78
#define IDS_BROWSE_COMPUTER_OU_CAPTION 79
#define IDS_RSOP_GPOLIST_MACHINE 80
#define IDS_RSOP_GPOLIST_USER    81

#define IDS_TITLE_WELCOME        82
#define IDS_TITLE_CHOOSEMODE     83
#define IDS_SUBTITLE_CHOOSEMODE  84
#define IDS_TITLE_GETCOMP        85
#define IDS_SUBTITLE_GETCOMP     86
//#define IDS_TITLE_GETUSER       305
#define IDS_SUBTITLE_GETUSER     87
#define IDS_TITLE_FINISHED       88
#define IDS_SUBTITLE_FINISHED    89
#define IDS_TITLE_GETTARGET      90
#define IDS_SUBTITLE_GETTARGET   91
#define IDS_TITLE_GETDC          92
#define IDS_SUBTITLE_GETDC       93
#define IDS_TITLE_ALTDIRS        94
#define IDS_SUBTITLE_ALTDIRS     95
#define IDS_TITLE_USERSECGRPS    96
#define IDS_SUBTITLE_USERSECGRPS 97
#define IDS_TITLE_COMPSECGRPS    98
#define IDS_SUBTITLE_COMPSECGRPS 99

#define IDS_GPO_NAME            100
#define IDS_ACCESSDENIED2       101
#define IDS_FAILEDLOCAL         102
#define IDS_FAILEDREMOTE        103
#define IDS_FAILEDDS            104
#define IDS_FAILEDNEW           105
#define IDS_FAILEDDELETE        106
#define IDS_FAILEDLINK          107
#define IDS_FAILEDUNLINK        108
#define IDS_FAILEDSETNAME       109
#define IDS_FAILEDGPLINK        110

#define IDS_FAILEDGPINFO        115
#define IDS_FAILEDGPQUERY       116
#define IDS_FAILEDGPODELETE     117
#define IDS_SPAWNGPEFAILED      118
#define IDS_NODC                119
#define IDS_NODSDC              120
#define IDS_DELETECONFIRM       121
#define IDS_CONFIRMTITLE        122
#define IDS_CONFIRMDISABLE      123
#define IDS_CONFIRMTITLE2       124

#define IDS_NODC_ERROR_TEXT     130
#define IDS_NODC_ERROR_TITLE    131
#define IDS_NODC_OPTIONS_TEXT   132
#define IDS_NODC_OPTIONS_TITLE  133

#define IDS_EXECFAILED_USER     136
#define IDS_EXECFAILED_COMPUTER 137
#define IDS_NOUSER2             138
#define IDS_NOCOMPUTER2         139
#define IDS_NODSOBJECT_MSG      140
#define IDS_BADUSERSOM          141
#define IDS_BADCOMPUTERSOM      142
#define IDS_NOUSER              143
#define IDS_NOCOMPUTER          144
#define IDS_NOUSERCONTAINER     145
#define IDS_NOCOMPUTERCONTAINER 146
#define IDS_EXECFAILED          147
#define IDS_CONNECTSERVERFAILED 148
#define IDS_RSOPLOGGINGDISABLED 149
#define IDS_RSOPLOGGINGTITLE    150

#define IDS_CAPTION             151
#define IDS_OPENBUTTON          152
#define IDS_DOMAINS             153
#define IDS_SITES               154
#define IDS_COMPUTERS           155
#define IDS_ALL                 156
#define IDS_NEWGPO              157

#define IDS_NAMECOLUMN          160
#define IDS_DOMAINCOLUMN        161
#define IDS_ALLDESCRIPTION      162
#define IDS_DOMAINDESCRIPTION   163
#define IDS_SITEDESCRIPTION     164
#define IDS_TOOLTIP_BACK        165
#define IDS_TOOLTIP_NEW         166
#define IDS_TOOLTIP_ROTATE      167
#define IDS_STOP                169
#define IDS_FINDNOW             170
#define IDS_FOREST              171
#define IDS_FORESTHEADING       172

#define IDS_TITLE_WQLUSER       180
#define IDS_SUBTITLE_WQL        181
#define IDS_TITLE_WQLCOMP       182

#define IDS_RSOP_FINISH_P11     190
#define IDS_RSOP_FINISH_P12     191
#define IDS_RSOP_FINISH_P13     192
#define IDS_YES                 193
#define IDS_NO                  194
#define IDS_NORSOPDC            195
#define IDS_DSBINDFAILED        196
#define IDS_DOMAINLIST          197
#define IDS_FAILEDPROPERTIES    198
#define IDS_NODATA              199
#define IDS_DCMISSINGRSOP       200

#define IDS_COMPONENT_NAME      225
#define IDS_STATUS              226
#define IDS_SUCCESS             227
#define IDS_FAILED              228
#define IDS_PENDING             229
#define IDS_SUCCESSMSG          230
#define IDS_FAILEDMSG1          231
#define IDS_PENDINGMSG          232
#define IDS_LOGGINGFAILED       233
#define IDS_OVERRIDE            234
#define IDS_WARNING             235
#define IDS_CSE_NA              236
#define IDS_SUCCESS2            237
#define IDS_FAILED2             238
#define IDS_SYNC_REQUIRED_USER  239

#define IDS_ERRORFILTER         240
#define IDS_FAILEDMSG2          241

#define IDS_DISPLAYPROPERTIES   250
#define IDS_MACHINE_DESC        251
#define IDS_USER_DESC           252
#define IDS_U_SWSETTINGS_DESC   253
#define IDS_U_WINSETTINGS_DESC  254
#define IDS_C_SWSETTINGS_DESC   255
#define IDS_C_WINSETTINGS_DESC  256
#define IDS_CSEFAILURE_DESC     257
#define IDS_CSEFAILURE2_DESC    258

#define IDS_GPE_WELCOME         270
#define IDS_MISSINGFILTER       271
#define IDS_WMIFILTERMISSING    272

#define IDS_ADDITIONALINFO      275
#define IDS_GPCOREFAIL          276
#define IDS_LEGACYCSE           277
#define IDS_LEGACYCSE1          278
#define IDS_ENUMUSERSFAILED     279
#define IDS_DOWNLEVELCOMPUTER   280
#define IDS_PLEASEWAIT          281
#define IDS_RSOP_FINISH_P14     282
#define IDS_RSOP_FINISH_P15     283
#define IDS_RSOP_PLANNING       284
#define IDS_RSOP_CMENU_NAME     285
#define IDS_RSOP_LOGGING        286

#define IDS_BLOCKEDSOM          287
#define IDS_SKIPWQLFILTER       289
#define IDS_NONESELECTED        290
#define IDS_GPCORE_LOGGINGFAIL  291

#define IDS_RSOP_FINISH_P16     292
#define IDS_LOOPBACK_REPLACE    293
#define IDS_LOOPBACK_MERGE      294

#define IDS_EXECFAILED_BOTH     295
#define IDS_EXECFAILED_TIMEDOUT 296
#define IDS_PLEASEWAIT1         297
#define IDS_DEFDC_DOWNLEVEL     298
#define IDS_DEFDC_CONNECTFAILED 299
#define IDS_WMIFILTERFORCEDNONE 300
#define IDS_RSOPWMIQRYFMT       301
#define IDS_RSOPDELNAMESPACE    302
#define IDS_RSOPDELNS_TITLE     303
#define IDS_INVALID_NAMESPACE   304

#define IDS_TITLE_GETUSER       305


#define IDS_LARGEFONTNAME       306
#define IDS_LARGEFONTSIZE       307
#define IDS_SMALLFONTNAME       308
#define IDS_SMALLFONTSIZE       309

#define IDS_POLICY_DELAYED      310
#define IDS_POLICY_DELAYED2     311

#define IDS_RSOP_RUNQUERY       312
#define IDS_RSOP_RUNQUERYDESC   313

#define IDS_RSOP_CHANGEQUERY       314
#define IDS_RSOP_CHANGEQUERYDESC   315

#define IDS_DEFDC_FAILED        316

#define IDS_RSOP_REFRESHQUERY   317
#define IDS_RSOP_REFRESHQUERYDESC 318

#define IDS_RSOP_UNINITIALIZED      319
#define IDS_RSOP_UNINITIALIZEDDESC  320

#define IDS_NOCROSSFORESTALLOWED 321
#define IDS_CROSSFORESTFAILED 322

#define IDS_RSOPDELNAMESPACE2 323

#define IDS_SYNC_REQUIRED_MACH 324

//
// Icons
//

#define IDI_POLICY                1
#define IDI_POLICY2               2
#define IDI_POLICY3               3
#define IDA_FIND                  4




//
// Bitmaps
//

#define IDB_16x16                 101
#define IDB_32x32                 102
#define IDB_WIZARD                103
#define IDB_POLICY16              104
#define IDB_POLICY32              105
#define IDB_HEADER                106


//
// Menu items
//

#define IDM_DCOPTIONS             1
#define IDM_ARCHIVEDATA           2
#define IDM_GENERATE_RSOP         3
#define IDM_REFRESH_RSOP        4

#define IDM_GPM_CONTEXTMENU      10
#define IDM_GPM_NOOVERRIDE       11
#define IDM_GPM_DISABLED         12
#define IDM_GPM_NEW              13
#define IDM_GPM_ADD              14
#define IDM_GPM_EDIT             15
#define IDM_GPM_DELETE           16
#define IDM_GPM_RENAME           17
#define IDM_GPM_REFRESH          18
#define IDM_GPM_PROPERTIES       19

#define IDM_GPOLIST_CONTEXTMENU  30
#define IDM_GPOLIST_EDIT         31
#define IDM_GPOLIST_SECURITY     32


//
// Error dialog defines
//

#define IDD_ERROR               200
#define IDC_ERRORTEXT           201
#define IDC_DETAILSBORDER       202
#define IDC_DETAILSTEXT         203
#define IDC_ERROR_ICON          204


//
// Properties dialog defines
//

#define IDD_PROPERTIES          500
#define IDC_TITLE               501
#define IDC_DISABLE_TEXT        502
#define IDC_DISABLE_COMPUTER    503
#define IDC_DISABLE_USER        504
#define IDC_CREATE_DATE         505
#define IDC_MODIFIED_DATE       506
#define IDC_REVISION            507
#define IDC_DOMAIN              508
#define IDC_UNIQUE_NAME         509
#define IDC_DOMAIN_HEADING      510

#define IDD_GPE_LINKS           550
#define IDC_RESULTLIST          551
#define IDI_FIND                552
#define IDC_CBDOMAIN            553
#define IDC_ACTION              554
#define IDAC_FIND               555

#define IDD_WQLFILTER           560
#define IDC_NONE                561
#define IDC_THIS_FILTER         562
#define IDC_FILTER_NAME         563
#define IDC_FILTER_BROWSE       564

//
// Choose dialog defines
//

#define IDD_CHOOSE_INTRO        900
#define IDC_BITMAP              901
#define IDC_DS_GPO              902
#define IDC_MACHINE_GPO         903
#define IDC_CAPTION             904

#define IDD_CHOOSE_DS           925
#define IDC_OPEN                926
#define IDC_OPEN_TITLE          927
#define IDC_OPEN_NAME           928
#define IDC_OPEN_BROWSE         929
#define IDC_NEW                 930
#define IDC_NEW_TITLE           931
#define IDC_NEW_NAME            932
#define IDC_NEW_TITLE2          933
#define IDC_NEW_DOMAIN          934
#define IDC_COPY_FROM           935
#define IDC_COPY_NAME           936
#define IDC_COPY_BROWSE         937
#define IDC_OVERRIDE            938
#define IDC_SPAWN               939

#define IDD_CHOOSE_MACHINE      950
#define IDC_LOCAL               951
#define IDC_REMOTE              952
#define IDC_NAME                953
#define IDC_BROWSE              954

#define IDD_ADD_GPO             975



//
// Browse dialog defines
//

#define IDC_STATIC                -1
#define IDD_BROWSEGPO             1000
#define IDC_BROWSE_LIST           1001
#define IDC_DOMAIN_LIST           1002
#define IDC_BROWSE_DELETE         1003

#define IDD_BROWSE2_DIALOG        1202
#define IDD_PROPPAGE_GPOBROWSER   1203
#define IDR_MAINFRAME             1228
#define IDR_TOOLBAR1              1229
#define IDR_LISTMENU              1234
#define IDD_PROPPAGE_COMPUTERS    1237

#define IDC_BUTTON1               1300
#define IDC_LIST1                 1301
#define IDC_COMBO1                1302
#define IDC_RADIO1                1304
#define IDC_RADIO2                1305
#define IDC_EDIT1                 1306
#define IDC_STATIC1               1307
#define IDC_DESCRIPTION           1308

#define ID_BACKBUTTON             32771
#define ID_NEWFOLDER              32772
#define ID_ROTATEVIEW             32773
#define ID_DETAILSVIEW            32774
#define ID_SMALLICONS             32776
#define ID_LIST                   32780
#define ID_DETAILS                32781
#define ID_LARGEICONS             32782
#define ID_TOP_placeholder        32783
#define ID_NEW                    32783
#define ID_EDIT                   32784
#define ID_DELETE                 32788
#define ID_RENAME                 32789
#define ID_REFRESH                32790
#define ID_PROPERTIES             32792
#define ID_TOP_LINEUPICONS        32794
#define ID_ARRANGE_BYNAME         32795
#define ID_ARRANGE_BYTYPE         32796
#define ID_ARRANGE_AUTO           32797


//
// Group Policy Manager dialog defines
//

#define IDD_GPMANAGER            1025
#define IDC_GPM_TITLE            1026
#define IDC_GPM_DCNAME           1027
#define IDC_GPM_LIST             1028
#define IDC_GPM_UP               1029
#define IDC_GPM_DOWN             1030
#define IDC_GPM_ADD              1031
#define IDC_GPM_EDIT             1032
#define IDC_GPM_DELETE           1033
#define IDC_GPM_PROPERTIES       1034
#define IDC_GPM_BLOCK            1035
#define IDC_GPM_NEW              1036
#define IDC_GPM_OPTIONS          1037
#define IDC_GPM_ICON             1038
#define IDC_GPM_LINE1            1039
#define IDD_GPM_LINK_OPTIONS     1040
#define IDC_GPM_NOOVERRIDE       1041
#define IDC_GPM_DISABLED         1042
#define IDC_GPM_PRIORITY         1043
#define IDC_GPM_LINE2            1044

//
// Remove GPO dialog defines
//

#define IDD_REMOVE_GPO           1050
#define IDC_REMOVE_TITLE         1051
#define IDC_REMOVE_LIST          1052
#define IDC_REMOVE_DS            1053
#define IDC_QUESTION             1054


//
// No DC dialog
//

#define IDD_NODC                 1060
#define IDC_NODC_TEXT            1061
#define IDC_NODC_ERROR           1062
#define IDC_NODC_PDC             1063
#define IDC_NODC_INHERIT         1064
#define IDC_NODC_ANYDC           1065


//
// Missing DS object dialog
//

#define IDD_NODSOBJECT           1070
#define IDC_NODSOBJECT_ICON      1071
#define IDC_NODSOBJECT_TEXT      1072


//
// RSOP welcome dialog
//

#define IDD_RSOP_WELCOME                1090

//
// RSOP choose mode dialog (diag vs planning)
//

#define IDD_RSOP_CHOOSEMODE             1091



#define IDD_RSOP_WQLUSER                1088
#define IDD_RSOP_WQLCOMP                1089

#define IDD_RSOP_GETCOMP                1092
#define IDD_RSOP_GETUSER                1093
#define IDD_RSOP_GETTARGET              1094
#define IDD_RSOP_GETDC                  1095
#define IDD_RSOP_ALTDIRS                1096
#define IDD_RSOP_ALTUSERSEC             1097
#define IDD_RSOP_ALTCOMPSEC             1098
#define IDD_RSOP_FINISHED               1099
//#define IDD_RSOP_FINISHED2              1105
//#define IDD_RSOP_FINISHED3              1106

#define IDD_RSOP_GPOLIST                1100
#define IDD_CHOOSEDC                    1101
#define IDD_RSOP_QUERY                  1102
#define IDD_RSOP_ERRORS                 1103
#define IDD_RSOP_BROWSEDC               1104
#define IDD_RSOP_FINISHED2              1105
#define IDD_RSOP_FINISHED3              1106

#define IDC_RSOP_BIG_BOLD1              1107

#define IDD_RSOP_FINISHED3_INT          1108
#define IDD_RSOP_FINISHED_INT           1109


#define IDD_BROWSE2_DIALOG              1202
#define IDD_PROPPAGE_GPOBROWSER         1203
#define IDR_MAINFRAME                   1228
#define IDR_TOOLBAR1                    1229
#define IDR_LISTMENU                    1234
#define IDD_PROPPAGE_COMPUTERS          1237
#define IDC_BUTTON1                     1300
#define IDC_BUTTON2                     1310
#define IDC_COMBO1                      1302
#define IDC_BUTTON3                     1302
#define IDC_COMBO2                      1303
#define IDC_RADIO1                      1304
#define IDC_RADIO2                      1305
#define IDC_EDIT1                       1306
#define IDC_STATIC1                     1307
#define IDC_EDIT2                       1307
#define IDC_DESCRIPTION                 1308
#define IDC_EDIT3                       1308
#define IDC_PROGRESS1                   1401
#define IDC_DC                          1402
#define IDC_LIST2                       1403
#define IDC_CHECK1                      1404
#define IDC_RADIO3                      1405
#define IDC_RADIO4                      1406
#define IDC_BROWSE1                     1407
#define IDC_BROWSE2                     1408
#define IDC_BROWSE3                     1409
#define IDC_BROWSE4                     1410
#define IDC_EDIT4                       1411
#define IDC_EDIT5                       1412
#define IDC_EDIT6                       1413
#define IDC_CHECK2                      1414
#define IDC_CHECK3                      1415

#define IDD_RSOP_STATUSMSC              1416

//
// Help file
//

#define HELP_FILE   TEXT("gpedit.hlp")


//
// Help IDs
//

#define IDH_NOCONTEXTHELP          -1L
#define IDH_GPMGR_DCNAME            2
#define IDH_GPMGR_LIST              3
#define IDH_GPMGR_UP                4
#define IDH_GPMGR_DOWN              5
#define IDH_GPMGR_ADD               6
#define IDH_GPMGR_EDIT              7
#define IDH_GPMGR_DELETE            8
#define IDH_GPMGR_PROPERTIES        9
#define IDH_GPMGR_BLOCK            10
#define IDH_GPMGR_NEW              11
#define IDH_GPMGR_OPTIONS          12

#define IDH_GPMGR_NOOVERRIDE       13
#define IDH_GPMGR_DISABLED         14

#define IDH_PROP_TITLE             15
#define IDH_PROP_DISABLE_COMPUTER  17
#define IDH_PROP_DISABLE_USER      23

#define IDH_BROWSE_LIST            25
#define IDH_BROWSE_DOMAINS         26

#define IDH_REMOVE_LIST            36
#define IDH_REMOVE_DS              37

#define IDH_LINK_DOMAIN            40
#define IDH_LINK_BUTTON            41
#define IDH_LINK_RESULT            42

#define IDH_DC_PDC                 43
#define IDH_DC_INHERIT             44
#define IDH_DC_ANYDC               45

#define IDH_NODSOBJECT             47

#define IDH_BROWSER_LOOKIN         75
#define IDH_BROWSER_DOMAINGPO      76
#define IDH_BROWSER_SITELIST       77
#define IDH_BROWSER_GPOLIST        78
#define IDH_BROWSER_DOMAINLIST     79
#define IDH_BROWSER_FULLGPOLIST    80
#define IDH_BROWSER_LOCALCOMPUTER  81
#define IDH_BROWSER_REMOTECOMPUTER 82
#define IDH_BROWSER_BROWSE         83

#define IDH_RSOPLOGGINGDISABLED    90

#define IDH_WQL_FILTER_NONE        100
#define IDH_WQL_FILTER_THIS_FILTER 101
#define IDH_WQL_FILTER_NAME        102
#define IDH_WQL_FILTER_BROWSE      103

#define IDH_RSOP_BANNER            200
#define IDH_RSOP_CONTAINERLIST     201

#define IDH_RSOP_GPOLIST           205
#define IDH_RSOP_APPLIEDGPOS       206
#define IDH_RSOP_GPOSOM            207
#define IDH_RSOP_REVISION          208
#define IDH_RSOP_SECURITY          209
#define IDH_RSOP_EDIT              210

#define IDH_RSOP_QUERYLIST         215

#define IDH_RSOP_COMPONENTLIST     220
#define IDH_RSOP_COMPONENTDETAILS  221
#define IDH_RSOP_SAVEAS            222

#define IDH_RSOP_BROWSEDC          225


//
// Private window message used to refresh the button states
//

#define WM_REFRESHDISPLAY  (WM_USER + 532)
#define WM_BUILDWQLLIST    (WM_USER + 533)
#define WM_INITRSOP        (WM_USER + 534)

//
// Strings
//

#define USER_SECTION                TEXT("User")
#define MACHINE_SECTION             TEXT("Machine")
#define COMPUTER_SECTION            TEXT("Computer")

#define GPE_KEY                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor")
#define GPE_POLICIES_KEY            TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor")
#define DCOPTION_VALUE              TEXT("DCOption")
#define NEW_LINKS_DISABLED_VALUE    TEXT("NewGPOLinksDisabled")
#define GPO_DISPLAY_NAME_VALUE      TEXT("GPODisplayName")

//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;
extern DWORD g_dwNameSpaceItems;
extern NAMESPACEITEM g_NameSpace[];
extern NAMESPACEITEM g_RsopNameSpace[];
extern CRITICAL_SECTION g_DCCS;
extern TCHAR g_szDisplayProperties[];


//
// DC selection dialog
//

typedef struct _DCSELINFO
{
    BOOL    bError;
    BOOL    bAllowInherit;
    INT     iDefault;
    LPTSTR  lpDomainName;
} DCSELINFO, *LPDCSELINFO;

INT_PTR CALLBACK DCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define MAX_FRIENDLYNAME 256


#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL         0x10000000
#endif


//
// Define to manage if FOREST GPO support is enabled or disabled.
//
// If this feature is re-enabled, 2 changes need to be made to gpedit.h
//
// 1)  Add the GPO_OPEN_FOREST flag for the IGPO interface
//       #define GPO_OPEN_FOREST             0x00000004  // Open the GPO on the forest
//
// 2)  Add GPHintForest entry to the GROUP_POLICY_HINT_TYPE enumerated type
//

#define FGPO_SUPPORT 0

#define MAX_ALIGNMENT_SIZE 8

#define ALIGN_SIZE_TO_NEXTPTR( offset )   \
                    ( ((DWORD)offset + (MAX_ALIGNMENT_SIZE-1) ) & (~(MAX_ALIGNMENT_SIZE - 1) ) )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\newbrows.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       newbrows.cpp
//
//  Contents:   implementation of the new GPO browser
//
//  Functions:  BrowseForGPO
//
//  History:    04-30-1998   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "browser.h"
#include "compspp.h"

int CALLBACK PSCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);

//+--------------------------------------------------------------------------
//
//  Function:   BrowseForGPO
//
//  Synopsis:   the GPO browser
//
//  Arguments:  [lpBrowseInfo] - structure that defines the behavior of the
//                                browser and contains the results
//
//  Returns:    S_OK - success
//
//  Modifies:
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT BrowseForGPO(LPGPOBROWSEINFO lpBrowseInfo)
{
    LPOLESTR szCaption;
    if (NULL != lpBrowseInfo->lpTitle)
    {
        szCaption = lpBrowseInfo->lpTitle;
    }
    else
    {
        szCaption = new OLECHAR[256];
        if (szCaption)
        {
            LoadString(g_hInstance, IDS_CAPTION, szCaption, 256);
        }
    }

    // bind to lpBrowseInfo->lpInitialOU and see if it is a site
    BOOL fSite = FALSE;

    IADs * pADs = NULL;
    HRESULT hr = OpenDSObject(lpBrowseInfo->lpInitialOU, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        BSTR bstrProperty = SysAllocString(L"objectClass");

        if (bstrProperty)
        {
            hr = pADs->Get(bstrProperty, &var);
            if (SUCCEEDED(hr))
            {
                int cElements = var.parray->rgsabound[0].cElements;
                VARIANT * rgData = (VARIANT *)var.parray->pvData;
                while (cElements--)
                {
                    if (0 == _wcsicmp(L"site", rgData[cElements].bstrVal))
                    {
                        fSite = TRUE;
                    }
                }
            }
            SysFreeString(bstrProperty);
        }
        VariantClear(&var);
        pADs->Release();
    }

    HPROPSHEETPAGE hpage[4];
    int nPage = 0;
    int nStartPage = 0;

    void * pActive;

    CBrowserPP ppDomains;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
        hpage[nPage++]= ppDomains.Initialize(PAGETYPE_DOMAINS, lpBrowseInfo, &pActive);
    CBrowserPP ppSites;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
    {
        if (fSite)
        {
            nStartPage = nPage;
        }
        hpage[nPage++]= ppSites.Initialize(PAGETYPE_SITES, lpBrowseInfo, &pActive);
    }
    CCompsPP ppComputers;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NOCOMPUTERS))
        hpage[nPage++]= ppComputers.Initialize(PAGETYPE_COMPUTERS, lpBrowseInfo, &pActive);
    CBrowserPP ppAll;
    if (0 == (lpBrowseInfo->dwFlags & GPO_BROWSE_NODSGPOS))
    {
        if (lpBrowseInfo->dwFlags & GPO_BROWSE_INITTOALL)
        {
            nStartPage = nPage;
        }
        hpage[nPage++]= ppAll.Initialize(PAGETYPE_ALL, lpBrowseInfo, &pActive);
    }

    PROPSHEETHEADER psh;
    memset(&psh, 0, sizeof(psh));
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_NOAPPLYNOW | ((lpBrowseInfo->dwFlags & GPO_BROWSE_OPENBUTTON) ? PSH_USECALLBACK : 0);
    psh.hwndParent = lpBrowseInfo->hwndOwner;
    psh.pszCaption = szCaption;
    psh.nPages = nPage;
    psh.phpage = hpage;
    psh.pfnCallback = PSCallback;
    psh.nStartPage = nStartPage;

    int iReturn = (int)PropertySheet(&psh);


    if (szCaption && (szCaption != lpBrowseInfo->lpTitle))
    {
        delete [] szCaption;
    }

    if (IDOK == iReturn)
    {
        return S_OK;
    }
    else
        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
}

//+--------------------------------------------------------------------------
//
//  Function:   PSCallback
//
//  Synopsis:   Callback function called by Windows during property sheet
//              initialization (among others).
//
//  Arguments:  [hwndDlg] - handle to the property sheet
//              [uMsg]    - message ID
//              [lParam]  - additional message specific info
//
//  Returns:    0
//
//  History:    04-30-1998   stevebl   Created
//
//  Notes:      This is used to change the text of the OK button
//
//---------------------------------------------------------------------------

int CALLBACK PSCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    if (uMsg == PSCB_INITIALIZED)
    {
        TCHAR szOpen[64];

        LoadString(g_hInstance, IDS_OPENBUTTON, szOpen, ARRAYSIZE(szOpen));
        SetDlgItemText(hwndDlg, IDOK, szOpen);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\registry.h ===
//
// RegistryHive class
//

class CRegistryHive:
    public IUnknown
{

protected:
    ULONG                m_cRef;
    HKEY                 m_hKey;
    LPTSTR               m_lpFileName;
    LPTSTR               m_lpKeyName;
    LPTSTR               m_lpEventName;
    HANDLE               m_hEvent;

public:
    CRegistryHive();
    ~CRegistryHive();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented Internal methods
    //

    STDMETHODIMP         Initialize(LPTSTR lpFileName, LPTSTR lpKeyName);
    STDMETHODIMP         GetHKey(HKEY *hKey);
    STDMETHODIMP         Save(VOID);
    STDMETHODIMP         ExportKey(HKEY hKey, HANDLE hFile, LPWSTR lpKeyName, ULONG ulKeySize);
    STDMETHODIMP         WriteValue(HANDLE hFile, LPWSTR lpKeyName,
                                    LPWSTR lpValueName, DWORD dwType,
                                    DWORD dwDataLength, LPBYTE lpData);
    STDMETHODIMP         Load(VOID);
    STDMETHODIMP         IsRegistryEmpty(BOOL *bEmpty);
};


//
// Verison number for the registry file format
//

#define REGISTRY_FILE_VERSION       1

//
// File signature
//

#define REGFILE_SIGNATURE  0x67655250


//
// Max keyname size
//

#define MAX_KEYNAME_SIZE         2048
#define MAX_VALUENAME_SIZE        512
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopdobj.h ===
//
// IRSOPDataObject interface id
//

// {4AE19823-BCEE-11d0-9484-080036B11A03}
DEFINE_GUID(IID_IRSOPDataObject, 0x4ae19823, 0xbcee, 0x11d0, 0x94, 0x84, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);



#ifndef _RSOPDOBJ_H_
#define _RSOPDOBJ_H_

//
// This is a private dataobject interface for GPE.
// When the GPE snapin receives a dataobject and needs to determine
// if it came from the GPE snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IRSOPDataObject
DECLARE_INTERFACE_(IRSOPDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IRSOPDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IRSOPDataObject *LPRSOPDATAOBJECT;



//
// CRSOPDataObject class
//

class CRSOPDataObject : public IDataObject,
                    public IRSOPInformation,
                    public IRSOPDataObject
{
    friend class CSnapIn;

protected:

    ULONG                  m_cRef;
    CRSOPComponentData    *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfPreloads;
    static unsigned int    m_cfNodeID;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CRSOPDataObject(CRSOPComponentData *pComponent);
    ~CRSOPDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IRSOPInformation methods
    //

    STDMETHOD(GetNamespace) (DWORD dwSection, LPOLESTR pszName, int cchMaxLength);
    STDMETHOD(GetFlags) (DWORD * pdwFlags);
    STDMETHOD(GetEventLogEntryText) (LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                     LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);


    //
    // Implemented IRSOPDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreatePreloadsData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeIDData(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

#endif // _RSOPDOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\registry.cpp ===
#include "main.h"

const WCHAR g_cOpenBracket = L'[';
const WCHAR g_cCloseBracket = L']';
const WCHAR g_cSemiColon = L';';

#define TEMP_LOCATION    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Objects")
#define REG_EVENT_NAME   TEXT("Group Policy registry event name for ")

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRegistryHive::CRegistryHive()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hKey = NULL;
    m_hEvent = NULL;
    m_lpFileName = m_lpKeyName = m_lpEventName = NULL;
}

CRegistryHive::~CRegistryHive()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRegistryHive::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPUNKNOWN)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRegistryHive::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRegistryHive::Release (void)
{
    if (--m_cRef == 0) {

        if (m_hKey)
        {
            RegCloseKey (m_hKey);

            if (m_lpKeyName)
            {
                BOOL bCleanRegistry = TRUE;


                //
                // We need to decide if the registry keys can be deleted or if
                // they are in use by another copy of GPE.  To do this, close
                // the event we created during initialization and then try to
                // open the event again.  If the event is successfully opened,
                // then another process is using the same registry key and it
                // should not be deleted.
                //

                if (m_hEvent && m_lpEventName)
                {
                    CloseHandle (m_hEvent);

                    m_hEvent = OpenEvent (SYNCHRONIZE, FALSE, m_lpEventName);

                    if (m_hEvent)
                    {
                        bCleanRegistry = FALSE;
                    }
                }


                if (bCleanRegistry)
                {
                    RegDelnode (HKEY_CURRENT_USER, m_lpKeyName);
                    RegDeleteKey (HKEY_CURRENT_USER, TEMP_LOCATION);
                }
            }
        }

        if (m_lpKeyName)
        {
            LocalFree (m_lpKeyName);
        }

        if (m_lpFileName)
        {
            LocalFree (m_lpFileName);
        }

        if (m_lpEventName)
        {
            LocalFree (m_lpEventName);
        }

        if (m_hEvent)
        {
            CloseHandle (m_hEvent);
        }

        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRegistryHive object implementation (Public functions)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRegistryHive::Initialize(LPTSTR lpFileName, LPTSTR lpKeyName)
{
    TCHAR szBuffer[300];
    INT i;
    LONG lResult;
    DWORD dwDisp;
    HRESULT hr;


    //
    // Check for null pointer
    //

    if (!lpFileName || !(*lpFileName))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Null filename")));
        return E_INVALIDARG;
    }


    //
    // Make sure this object hasn't been initialized already
    //

    if (m_hKey || m_lpFileName || m_lpKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Object already initialized")));
        return (E_UNEXPECTED);
    }


    //
    // Find a temporary registry key to work with
    //

    hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), TEMP_LOCATION);
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), TEXT("\\"));
    }
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), lpKeyName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to copyt registry name with 0x%x"), hr));
        return hr;
    }

    lResult = RegCreateKeyEx (HKEY_CURRENT_USER, szBuffer, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                              NULL, &m_hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to open registry key with %d"), lResult));
        return (HRESULT_FROM_WIN32(lResult));
    }


    //
    // Store the keyname
    //

    ULONG ulNoChars;

    ulNoChars = lstrlen(szBuffer) + 1;
    m_lpKeyName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_lpKeyName)
    {
        RegCloseKey (m_hKey);
        m_hKey = NULL;
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for KeyName")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = StringCchCopy (m_lpKeyName, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // Store the filename
    //

    ulNoChars = lstrlen(lpFileName) + 1;
    m_lpFileName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for filename")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = StringCchCopy (m_lpFileName, ulNoChars, lpFileName);
    ASSERT(SUCCEEDED(hr));

    //
    // Store the event name
    //

    hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), REG_EVENT_NAME);
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (szBuffer, ARRAYSIZE(szBuffer), lpKeyName);
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to copy event name")));
        return hr;
    }

    ulNoChars = lstrlen(szBuffer) + 1;
    m_lpEventName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!m_lpEventName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to allocate memory for filename")));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = StringCchCopy (m_lpEventName, ulNoChars, szBuffer);
    ASSERT(SUCCEEDED(hr));

    //
    // Load the file if it exists
    //

    hr =  Load();

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Create the registry event
    //

    m_hEvent = CreateEvent (NULL, FALSE, FALSE, m_lpEventName);

    if (!m_hEvent)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Initialize: Failed to create registry event with %d"),
                 GetLastError()));
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    return (S_OK);
}

STDMETHODIMP CRegistryHive::GetHKey(HKEY *hKey)
{
    HRESULT hr = E_FAIL;

    *hKey = NULL;

    if (m_hKey)
    {
        if (DuplicateHandle (GetCurrentProcess(),
                              (HANDLE)m_hKey,
                              GetCurrentProcess(),
                              (LPHANDLE) hKey, 0,
                              TRUE, DUPLICATE_SAME_ACCESS))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    return hr;
}

STDMETHODIMP CRegistryHive::Save(VOID)
{
    HANDLE hFile;
    HRESULT hr;
    DWORD dwTemp, dwBytesWritten;
    LPWSTR lpKeyName;


    //
    // Check parameters
    //

    if (!m_hKey || !m_lpFileName || !m_lpKeyName)
    {
        return E_INVALIDARG;
    }


    //
    // Allocate a buffer to hold the keyname
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Create the output file
    //
    
    DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(m_lpFileName);

    hFile = CreateFile (m_lpFileName, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    ENABLE_32BIT_FILE_REDIRECTION_ON_64BIT;

    if (hFile == INVALID_HANDLE_VALUE) {
        LocalFree (lpKeyName);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Write the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    dwTemp = REGFILE_SIGNATURE;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Save: Failed to write signature with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    dwTemp = REGISTRY_FILE_VERSION;

    if (!WriteFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Save: Failed to write version number with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Exports the values / keys
    //

    hr = ExportKey (m_hKey, hFile, lpKeyName, MAX_KEYNAME_SIZE);


Exit:

    //
    // Finished
    //

    CloseHandle (hFile);
    LocalFree (lpKeyName);

    return hr;
}


STDMETHODIMP CRegistryHive::ExportKey(HKEY hKey, HANDLE hFile, LPWSTR lpKeyName, ULONG ulKeySize)
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten, dwNameSize, dwDataSize, dwKeySize;
    DWORD dwIndex, dwTemp1, dwTemp2, dwType, dwKeyCount = 0;
    LONG  lResult;
    HKEY  hSubKey;
    LPWSTR lpValueName = NULL;
    LPWSTR lpSubKeyName = NULL;
    LPBYTE lpValueData = NULL;
    LPWSTR lpEnd;



    //
    // Gather information about this key
    //

    lResult = RegQueryInfoKey (hKey, NULL, NULL, NULL, &dwKeyCount, &dwKeySize, NULL,
                               NULL, &dwNameSize, &dwDataSize, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to query registry key information with %d"),
                 lResult));
        return HRESULT_FROM_WIN32(lResult);
    }


    //
    // Allocate buffers to work with
    //

    lpValueName = (LPWSTR) LocalAlloc (LPTR, (dwNameSize + 1) * sizeof(WCHAR));

    if (!lpValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    lpValueData = (LPBYTE) LocalAlloc (LPTR, dwDataSize);

    if (!lpValueData)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    //
    // Enumerate the values and write them to the file
    //

    dwIndex = 0;

    while (TRUE)
    {
        dwTemp1 = dwNameSize + 1;
        dwTemp2 = dwDataSize;
        *lpValueName = L'\0';

        lResult = RegEnumValueW (hKey, dwIndex, lpValueName, &dwTemp1, NULL,
                                 &dwType, lpValueData, &dwTemp2);

        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegEnumValue failed with %d"),
                     lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        hr = WriteValue(hFile, lpKeyName, lpValueName, dwType, dwTemp2, lpValueData);

        if (hr != S_OK)
            goto Exit;

        dwIndex++;
    }


    //
    // If dwIndex is 0, this is an empty key.  We need to special case this
    // so the empty key is entered into the registry file when there are
    // no subkeys under it.
    //

    if ((dwIndex == 0) && (dwKeyCount == 0) && (*lpKeyName))
    {
        hr = WriteValue(hFile, lpKeyName, lpValueName, REG_NONE, 0, lpValueData);

        if (hr != S_OK)
            goto Exit;
    }


    LocalFree (lpValueName);
    lpValueName = NULL;

    LocalFree (lpValueData);
    lpValueData = NULL;


    //
    // Now process the sub keys
    //

    lpSubKeyName = (LPWSTR) LocalAlloc (LPTR, (dwKeySize + 1) * sizeof(WCHAR));

    if (!lpSubKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: Failed to alloc memory with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    dwIndex = 0;

    ULONG ulNoChars;
    if (*lpKeyName)
    {
        lpEnd = CheckSlash (lpKeyName);
        ulNoChars = ulKeySize - lstrlen(lpKeyName);
    }

    else
    {
        lpEnd = lpKeyName;
        ulNoChars = ulKeySize;
    }
    
    while (TRUE)
    {
        dwTemp1 = dwKeySize + 1;
        lResult = RegEnumKeyEx (hKey, dwIndex, lpSubKeyName, &dwTemp1,
                                NULL, NULL, NULL, NULL);

        if (lResult == ERROR_NO_MORE_ITEMS)
            break;

        if (lResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegEnumKeyEx failed with %d"),
                     lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        hr = StringCchCopy (lpEnd, ulNoChars, lpSubKeyName);
        if (FAILED(hr)) 
        {
            break;
        }

        lResult = RegOpenKeyEx (hKey, lpSubKeyName, 0, KEY_READ, &hSubKey);

        if (lResult == ERROR_SUCCESS)
        {
            hr = ExportKey (hSubKey, hFile, lpKeyName, ulKeySize);
            RegCloseKey (hSubKey);

            if (hr != S_OK)
                break;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::ExportKey: RegOpenKeyEx failed with %d"),
                     lResult));
        }

        dwIndex++;
    }


Exit:

    if (lpValueName)
        LocalFree (lpValueName);

    if (lpValueData)
        LocalFree (lpValueData);

    if (lpSubKeyName)
        LocalFree (lpSubKeyName);

    return hr;

}

STDMETHODIMP CRegistryHive::WriteValue(HANDLE hFile, LPWSTR lpKeyName,
                                       LPWSTR lpValueName, DWORD dwType,
                                       DWORD dwDataLength, LPBYTE lpData)
{
    HRESULT hr = S_OK;
    DWORD dwBytesWritten;
    DWORD dwTemp;


    //
    // Write the entry to the text file.
    //
    // Format:
    //
    // [keyname;valuename;type;datalength;data]
    //

    // open bracket
    if (!WriteFile (hFile, &g_cOpenBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write open bracket with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // key name
    dwTemp = (lstrlen (lpKeyName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpKeyName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write key name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // value name
    dwTemp = (lstrlen (lpValueName) + 1) * sizeof (WCHAR);
    if (!WriteFile (hFile, lpValueName, dwTemp, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write value name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // type
    if (!WriteFile (hFile, &dwType, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data type with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // data length
    if (!WriteFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(DWORD))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data type with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // semicolon
    if (!WriteFile (hFile, &g_cSemiColon, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write semicolon with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // data
    if (!WriteFile (hFile, lpData, dwDataLength, &dwBytesWritten, NULL) ||
        dwBytesWritten != dwDataLength)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write data with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // close bracket
    if (!WriteFile (hFile, &g_cCloseBracket, sizeof(WCHAR), &dwBytesWritten, NULL) ||
        dwBytesWritten != sizeof(WCHAR))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::WriteValue: Failed to write close bracket with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::WriteValue:  Successfully wrote: %s\\%s"),
             lpKeyName, lpValueName));


Exit:

    return hr;
}


STDMETHODIMP CRegistryHive::Load(VOID)
{
    HANDLE hFile;
    HRESULT hr = S_OK;
    DWORD dwTemp, dwBytesRead, dwType, dwDataLength, dwDisp;
    LPWSTR lpKeyName, lpValueName, lpTemp;
    LPBYTE lpData;
    WCHAR  chTemp;
    HKEY hSubKey;
    LONG lResult;


    //
    // Check parameters
    //

    if (!m_hKey || !m_lpFileName || !m_lpKeyName)
    {
        return E_INVALIDARG;
    }


    //
    // Open the registry file
    //

    DISABLE_32BIT_FILE_REDIRECTION_ON_64BIT(m_lpFileName);

    hFile = CreateFile (m_lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                        NULL);
    
    ENABLE_32BIT_FILE_REDIRECTION_ON_64BIT;

    if (hFile == INVALID_HANDLE_VALUE) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            return S_OK;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: CreateFile failed for <%s> with %d"),
                     m_lpFileName, GetLastError()));
            return (HRESULT_FROM_WIN32(GetLastError()));
        }
    }


    //
    // Allocate buffers to hold the keyname, valuename, and data
    //

    lpKeyName = (LPWSTR) LocalAlloc (LPTR, MAX_KEYNAME_SIZE * sizeof(WCHAR));

    if (!lpKeyName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory with %d"),
                 GetLastError()));
        CloseHandle (hFile);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    lpValueName = (LPWSTR) LocalAlloc (LPTR, MAX_VALUENAME_SIZE * sizeof(WCHAR));

    if (!lpValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory with %d"),
                 GetLastError()));
        LocalFree (lpKeyName);
        CloseHandle (hFile);
        return (HRESULT_FROM_WIN32(GetLastError()));
    }


    //
    // Read the header block
    //
    // 2 DWORDS, signature (PReg) and version number and 2 newlines
    //

    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read signature with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    if (dwTemp != REGFILE_SIGNATURE)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Invalid file signature")));
        hr = E_FAIL;
        goto Exit;
    }


    if (!ReadFile (hFile, &dwTemp, sizeof(dwTemp), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(dwTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read version number with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (dwTemp != REGISTRY_FILE_VERSION)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Invalid file version")));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read the data
    //

    while (TRUE)
    {

        //
        // Read the first character.  It will either be a [ or the end
        // of the file.
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L'['))
        {
            goto Exit;
        }


        //
        // Read the keyname
        //

        lpTemp = lpKeyName;
        DWORD dwTempLen = 0;

        while (TRUE)
        {
            if ( dwTempLen == MAX_KEYNAME_SIZE )
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Keyname is bigger than MAX_KEYNAME_SIZE (%d)"), MAX_KEYNAME_SIZE));
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Exit;
            }

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read keyname character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;
            dwTempLen++;

            if (chTemp == TEXT('\0'))
                break;

        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            goto Exit;
        }


        //
        // Read the valuename
        //

        lpTemp = lpValueName;
        dwTempLen = 0;

        while (TRUE)
        {
            if ( dwTempLen == MAX_VALUENAME_SIZE )
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Valuename is bigger than MAX_VALUENAME_SIZE (%d)"), MAX_VALUENAME_SIZE));
                hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
                goto Exit;
            }

            if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read valuename character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

            *lpTemp++ = chTemp;
            dwTempLen++;

            if (chTemp == TEXT('\0'))
                break;
        }


        //
        // Read the semi-colon
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            if (GetLastError() != ERROR_HANDLE_EOF)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read first character with %d"),
                         GetLastError()));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            goto Exit;
        }

        if ((dwBytesRead == 0) || (chTemp != L';'))
        {
            goto Exit;
        }


        //
        // Read the type
        //

        if (!ReadFile (hFile, &dwType, sizeof(DWORD), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read type with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip semicolon with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Read the data length
        //

        if (!ReadFile (hFile, &dwDataLength, sizeof(DWORD), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to data length with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip semicolon
        //

        if (!ReadFile (hFile, &dwTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip semicolon with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Allocate memory for data
        //

        lpData = (LPBYTE) LocalAlloc (LPTR, dwDataLength);

        if (!lpData)
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to allocate memory for data with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Read data
        //

        if (!ReadFile (hFile, lpData, dwDataLength, &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to read data with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }


        //
        // Skip closing bracket
        //

        if (!ReadFile (hFile, &chTemp, sizeof(WCHAR), &dwBytesRead, NULL))
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to skip closing bracket with %d"),
                     GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        if (chTemp != L']')
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Expected to find ], but found %c"),
                     chTemp));
            hr = E_FAIL;
            goto Exit;
        }



        //
        // Save registry value
        //

        lResult = RegCreateKeyEx (m_hKey, lpKeyName, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_WRITE, NULL, &hSubKey, &dwDisp);

        if (lResult == ERROR_SUCCESS)
        {

            if ((dwType == REG_NONE) && (dwDataLength == 0) &&
                (*lpValueName == L'\0'))
            {
                lResult = ERROR_SUCCESS;
            }
            else
            {
                lResult = RegSetValueEx (hSubKey, lpValueName, 0, dwType,
                                         lpData, dwDataLength);
            }

            RegCloseKey (hSubKey);

            if (lResult != ERROR_SUCCESS)
            {
                DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to set value <%s> with %d"),
                         lpValueName, lResult));
                hr = HRESULT_FROM_WIN32(lResult);
                LocalFree (lpData);
                goto Exit;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRegistryHive::Load: Failed to open key <%s> with %d"),
                     lpKeyName, lResult));
            hr = HRESULT_FROM_WIN32(lResult);
            LocalFree (lpData);
            goto Exit;
        }

        LocalFree (lpData);

    }

Exit:

    //
    // Finished
    //

    CloseHandle (hFile);
    LocalFree (lpKeyName);
    LocalFree (lpValueName);

    return hr;
}


STDMETHODIMP CRegistryHive::IsRegistryEmpty(BOOL *bEmpty)
{
    HRESULT hr = ERROR_SUCCESS;
    DWORD dwKeys, dwValues;
    LONG lResult;

    if (!m_hKey)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::IsRegistryEmpty: registry key not open yet")));
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }


    lResult = RegQueryInfoKey(m_hKey, NULL, NULL, NULL, &dwKeys, NULL, NULL, &dwValues,
                              NULL, NULL, NULL, NULL);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRegistryHive::IsRegistryEmpty: RegQueryInfoKey failed with %d"),
                  lResult));
        return HRESULT_FROM_WIN32(lResult);
    }

    if ((dwKeys == 0) && (dwValues == 0))
    {
        *bEmpty = TRUE;
        DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::IsRegistryEmpty: registry key is empty")));
    }
    else
    {
        *bEmpty = FALSE;
        DebugMsg((DM_VERBOSE, TEXT("CRegistryHive::IsRegistryEmpty: registry key is not empty.  Keys = %d, Values = %d"),
                 dwKeys, dwValues));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopdobj.cpp ===
#include "main.h"
#include <initguid.h>
#include "dataobj.h"
#include "rsopdobj.h"


unsigned int CRSOPDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CRSOPDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CRSOPDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CRSOPDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CRSOPDataObject::m_cfPreloads       = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
unsigned int CRSOPDataObject::m_cfNodeID         = RegisterClipboardFormat(CCF_NODEID);
unsigned int CRSOPDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CRSOPDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject implementation                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CRSOPDataObject::CRSOPDataObject(CRSOPComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CRSOPDataObject::~CRSOPDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IUnknown)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRSOPDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IRSOPInformation))
    {
        *ppv = (LPRSOPINFORMATION)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IRSOPDataObject))
    {
        *ppv = (LPRSOPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRSOPDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRSOPDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IDataObject)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfPreloads)
    {
        hr = CreatePreloadsData(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;
            TCHAR szDesc[300];

            IStream *lpStream = lpMedium->pstm;

            if(lpStream)
            {
                LoadString (g_hInstance, g_RsopNameSpace[m_cookie].iStringDescID, szDesc, ARRAYSIZE(szDesc));
                hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);

                if (SUCCEEDED(hr))
                {
                    if ((m_cookie == 0) && ( m_pcd->ComputerCSEErrorExists() || m_pcd->UserCSEErrorExists() ))
                    {
                        LoadString (g_hInstance, IDS_CSEFAILURE2_DESC, szDesc, ARRAYSIZE(szDesc));
                        hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
                    }

                    if (((m_cookie == 1) && m_pcd->ComputerCSEErrorExists() ) ||
                        ((m_cookie == 2) && m_pcd->UserCSEErrorExists() ))
                    {
                        LoadString (g_hInstance, IDS_CSEFAILURE_DESC, szDesc, ARRAYSIZE(szDesc));
                        hr = lpStream->Write(szDesc, lstrlen(szDesc) * sizeof(TCHAR), &ulWritten);
                    }
                }
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if ((m_cookie == 0) || (m_cookie == 1) || (m_cookie == 2))
            {
                IStream *lpStream = lpMedium->pstm;

                if(lpStream)
                {
                    hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CRSOPDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeID)
    {
        hr = CreateNodeIDData(lpMedium);
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (IROSPInformation)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CRSOPDataObject::GetNamespace (DWORD dwSection, LPOLESTR pszName, int cchMaxLength)
{
    return m_pcd->GetNamespace(dwSection, pszName, cchMaxLength);
}

STDMETHODIMP CRSOPDataObject::GetFlags (DWORD * pdwFlags)
{
    return m_pcd->GetFlags(pdwFlags);
}

STDMETHODIMP CRSOPDataObject::GetEventLogEntryText (LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                                    LPOLESTR pszEventTime, DWORD dwEventID,
                                                     LPOLESTR *ppszText)
{
    return m_pcd->GetEventLogEntryText(pszEventSource, pszEventLogName, pszEventTime, dwEventID, ppszText);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPDataObject object implementation (Internal functions)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CRSOPDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CRSOPDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    // Create the node type object in GUID format
    return Create((LPVOID)pGUID, sizeof(GUID), lpMedium);

}

HRESULT CRSOPDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CRSOPDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[300];

    //
    // This is the display named used in the scope pane and snap-in manager
    //

    szDisplayName[0] = TEXT('\0');

    if ( m_pcd->HasDisplayName() )
    //if (m_pcd->m_pGPO && m_pcd->m_pDisplayName)
    {
        (void) StringCchCopy (szDisplayName, ARRAYSIZE(szDisplayName), m_pcd->GetDisplayName() );
    }
    else
    {
        LoadStringW (g_hInstance, IDS_RSOP_SNAPIN_NAME, szDisplayName, ARRAYSIZE(szDisplayName));
    }

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CRSOPDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create((LPVOID)&CLSID_GPESnapIn, sizeof(CLSID), lpMedium);
}

HRESULT CRSOPDataObject::CreatePreloadsData(LPSTGMEDIUM lpMedium)
{
    BOOL bPreload = TRUE;

    return Create((LPVOID)&bPreload, sizeof(bPreload), lpMedium);
}

HRESULT CRSOPDataObject::CreateNodeIDData(LPSTGMEDIUM lpMedium)
{
    const GUID * pGUID;
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;
    TCHAR szNodeType[50];
    SNodeID * psNode;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    if (m_type == CCT_RESULT)
        pGUID = g_RsopNameSpace[lpResultItem->dwNameSpaceItem].pNodeID;
    else
        pGUID = g_RsopNameSpace[m_cookie].pNodeID;

    szNodeType[0] = TEXT('\0');
    StringFromGUID2 (*pGUID, szNodeType, 50);

    lpMedium->hGlobal = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, (lstrlen(szNodeType) * sizeof(TCHAR)) + sizeof(SNodeID));

    if (!lpMedium->hGlobal)
    {
        return (STG_E_MEDIUMFULL);
    }

    psNode = (SNodeID *) GlobalLock (lpMedium->hGlobal);

    psNode->cBytes = lstrlen(szNodeType) * sizeof(TCHAR);
    CopyMemory (psNode->id, szNodeType, psNode->cBytes);

    GlobalUnlock (lpMedium->hGlobal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopquery.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       RSOPQuery.h
//
//  Contents:  Definitions for the RSOP query API
//
//  Functions:
//          CreateRSOPQuery
//          RunRSOPQuery
//          FreeRSOPQuery
//          FreeRSOPQueryResults
//
//  History:    07-30-2001  rhynierm        Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "RSOPQuery.h"

#include "RSOPWizard.h"
#include "RSOPWizardDlg.h"

//-------------------------------------------------------

BOOL CopyString( LPTSTR szSource, LPTSTR* pszTarget )
{
    if ( szSource == NULL )
    {
        (*pszTarget) = NULL;
        return TRUE;
    }

    ULONG ulNoChars = _tcslen(szSource)+1;
    *pszTarget = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR) * ulNoChars );
    if ( *pszTarget == NULL )
    {
        return FALSE;
    }

    HRESULT hr;

    hr = StringCchCopy( *pszTarget, ulNoChars, szSource );
    ASSERT(SUCCEEDED(hr));

    return TRUE;
}

//-------------------------------------------------------

BOOL CreateRSOPQuery( LPRSOP_QUERY* ppQuery, RSOP_QUERY_TYPE QueryType )
{
    *ppQuery = (LPRSOP_QUERY)LocalAlloc( LPTR, sizeof(RSOP_QUERY) );
    if ( *ppQuery == NULL )
    {
        DWORD dwLastError = GetLastError();
        DebugMsg( (DM_WARNING, TEXT("CreateRSOPQuery: Failed to allocate memory with 0x%x."), HRESULT_FROM_WIN32(dwLastError)) );
        SetLastError( dwLastError );
        return FALSE;
    }

    (*ppQuery)->QueryType = QueryType;
    (*ppQuery)->UIMode = RSOP_UI_WIZARD;
    (*ppQuery)->dwFlags = 0;
    
    if ( (QueryType == RSOP_UNKNOWN_MODE) || (QueryType == RSOP_LOGGING_MODE) )
    {
        (*ppQuery)->szUserName = NULL;
        (*ppQuery)->szUserSid = NULL;
        (*ppQuery)->szComputerName = NULL;
    }
    else // QueryType == RSOP_PLANNING_MODE
    {
        (*ppQuery)->bSlowNetworkConnection = FALSE;
        (*ppQuery)->LoopbackMode = RSOP_LOOPBACK_NONE;
        (*ppQuery)->szSite = NULL;
        (*ppQuery)->szDomainController = NULL;
        (*ppQuery)->pUser = (LPRSOP_QUERY_TARGET)LocalAlloc( LPTR, sizeof(RSOP_QUERY_TARGET) );
        (*ppQuery)->pComputer = (LPRSOP_QUERY_TARGET)LocalAlloc( LPTR, sizeof(RSOP_QUERY_TARGET) );
        if ( ((*ppQuery)->pUser == NULL) || ((*ppQuery)->pComputer == NULL) )
        {
            DWORD dwLastError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CreateRSOPQuery: Falied to allocate memory with 0x%x"),
                                HRESULT_FROM_WIN32( dwLastError ) ));

            LocalFree( (*ppQuery)->pUser );
            LocalFree( (*ppQuery)->pComputer );
            LocalFree( *ppQuery );
            *ppQuery = NULL;

            SetLastError( dwLastError );
            return FALSE;
        }

        (*ppQuery)->pUser->bAssumeWQLFiltersTrue = TRUE;
        (*ppQuery)->pComputer->bAssumeWQLFiltersTrue = TRUE;
    }

    return TRUE;
}

//-------------------------------------------------------

BOOL FreeStringList( DWORD dwCount, LPTSTR* aszStrings )
{
    if ( aszStrings == NULL )
    {
        return TRUE;
    }
    
    for ( DWORD dw = 0; dw < dwCount; dw++ )
    {
        LocalFree( aszStrings[dw] );
        aszStrings[dw] = NULL;
    }
    LocalFree( aszStrings );

    return TRUE;
}

//-------------------------------------------------------

BOOL CopyStringList( DWORD dwCount, LPTSTR* aszStrings , DWORD* pdwNewCount, LPTSTR** paszNewStrings )
{
    DWORD dw = 0;

    *pdwNewCount = 0;

    if ( (aszStrings == NULL) || (dwCount == 0) )
    {
        *paszNewStrings = NULL;
        return TRUE;
    }

    *paszNewStrings = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * dwCount );
    if ( *paszNewStrings == NULL )
    {
        return FALSE;
    }
    
    for ( dw = 0; dw < dwCount; dw++ )
    {
        if ( !CopyString( aszStrings[dw], &((*paszNewStrings)[dw]) ) )
        {
            goto ErrorExit;
        }
    }

    *pdwNewCount = dwCount;
    return TRUE;

    ErrorExit:
    if ( dw > 0 )
    {
        if ( FreeStringList( dw-1, *paszNewStrings ) )
        {
            *paszNewStrings = NULL;
        }
    }
    else
    {
        LocalFree( *paszNewStrings );
        *paszNewStrings = NULL;
    }
    return FALSE;
}

//-------------------------------------------------------

BOOL FreeTargetData( LPRSOP_QUERY_TARGET pTarget )
{
    if ( pTarget == NULL )
    {
        return TRUE;
    }

    LocalFree( pTarget->szName );
    pTarget->szName = NULL;

    LocalFree( pTarget->szSOM );
    pTarget->szSOM = NULL;

    bool bSuccess = TRUE;
    if ( FreeStringList( pTarget->dwSecurityGroupCount, pTarget->aszSecurityGroups ) )
    {
        pTarget->aszSecurityGroups = NULL;
        pTarget->dwSecurityGroupCount = 0;
    }
    else
    {
        bSuccess = FALSE;
    }

    if ( pTarget->adwSecurityGroupsAttr != NULL )
    {
        LocalFree( pTarget->adwSecurityGroupsAttr );
        pTarget->adwSecurityGroupsAttr = NULL;
    }

    DWORD dwCount = pTarget->dwWQLFilterCount;
    if ( FreeStringList( pTarget->dwWQLFilterCount, pTarget->aszWQLFilters) )
    {
        pTarget->aszWQLFilters = NULL;
        pTarget->dwWQLFilterCount = 0;
    }
    else
    {
        bSuccess = FALSE;
    }

    if ( FreeStringList( dwCount, pTarget->aszWQLFilterNames) )
    {
        pTarget->aszWQLFilterNames = NULL;
    }
    else
    {
        bSuccess = FALSE;
    }

    return bSuccess;
}

//-------------------------------------------------------

BOOL FreeTarget( LPRSOP_QUERY_TARGET pTarget )
{
    if ( pTarget == NULL )
    {
        return TRUE;
    }

    if ( FreeTargetData( pTarget ) )
    {
        LocalFree( pTarget );
        return TRUE;
    }
    return FALSE;
}

//-------------------------------------------------------

BOOL CopyTarget( LPRSOP_QUERY_TARGET pTarget, LPRSOP_QUERY_TARGET* ppNewTarget )
{
    if ( pTarget == NULL )
    {
        *ppNewTarget = NULL;
        return TRUE;
    }

    *ppNewTarget = (LPRSOP_QUERY_TARGET)LocalAlloc( LPTR, sizeof(RSOP_QUERY_TARGET) );
    if ( *ppNewTarget == NULL )
    {
        return FALSE;
    }
    ZeroMemory( *ppNewTarget, sizeof(RSOP_QUERY_TARGET) );

    if ( !CopyString( pTarget->szName, &((*ppNewTarget)->szName) ) )
    {
        goto ErrorExit;
    }
    if ( !CopyString( pTarget->szSOM, &((*ppNewTarget)->szSOM) ) )
    {
        goto ErrorExit;
    }
    if ( !CopyStringList( pTarget->dwSecurityGroupCount, pTarget->aszSecurityGroups,
                                    &((*ppNewTarget)->dwSecurityGroupCount), &((*ppNewTarget)->aszSecurityGroups) ) )
    {
        goto ErrorExit;
    }
    if ( !CopyStringList( pTarget->dwWQLFilterCount, pTarget->aszWQLFilterNames,
                                    &((*ppNewTarget)->dwWQLFilterCount), &((*ppNewTarget)->aszWQLFilterNames) ) )
    {
        goto ErrorExit;
    }
    if ( !CopyStringList( pTarget->dwWQLFilterCount, pTarget->aszWQLFilters,
                                    &((*ppNewTarget)->dwWQLFilterCount), &((*ppNewTarget)->aszWQLFilters) ) )
    {
        goto ErrorExit;
    }

    if ( pTarget->adwSecurityGroupsAttr != NULL )
    {
        (*ppNewTarget)->adwSecurityGroupsAttr = (DWORD*)LocalAlloc( LPTR, sizeof(DWORD)*pTarget->dwSecurityGroupCount );
        if ( (*ppNewTarget)->adwSecurityGroupsAttr == NULL )
        {
            goto ErrorExit;
        }
        memcpy( (*ppNewTarget)->adwSecurityGroupsAttr, pTarget->adwSecurityGroupsAttr, sizeof(DWORD)*pTarget->dwSecurityGroupCount );
    }
    
    (*ppNewTarget)->bAssumeWQLFiltersTrue = pTarget->bAssumeWQLFiltersTrue;

    return TRUE;

    ErrorExit:
    FreeTarget( *ppNewTarget );
    *ppNewTarget = NULL;
    return FALSE;
}

//-------------------------------------------------------

BOOL FreeRSOPQueryData( LPRSOP_QUERY pQuery )
{
    BOOL bSuccess = TRUE;
    
    if ( pQuery == NULL )
    {
        return TRUE;
    }

    if ( pQuery->QueryType == RSOP_PLANNING_MODE )
    {
        if ( FreeTarget( pQuery->pUser ) )
        {
            pQuery->pUser = NULL;
        }
        else
        {
            bSuccess = FALSE;
        }

        if ( FreeTarget( pQuery->pComputer ) )
        {
            pQuery->pUser = NULL;
        }
        else
        {
            bSuccess = FALSE;
        }

        LocalFree( pQuery->szSite );
        pQuery->szSite = NULL;
        
        LocalFree( pQuery->szDomainController );
        pQuery->szDomainController = NULL;
    }
    else
    {
        LocalFree( pQuery->szUserName );
        pQuery->szUserName = NULL;
        LocalFree( pQuery->szUserSid );
        pQuery->szUserSid = NULL;
        LocalFree( pQuery->szComputerName );
        pQuery->szComputerName = NULL;
    }

    return bSuccess;
}

//-------------------------------------------------------

BOOL FreeRSOPQuery( LPRSOP_QUERY pQuery )
{
    if ( pQuery == NULL )
    {
        return TRUE;
    }
    
    if ( !FreeRSOPQueryData( pQuery ) )
    {
        return FALSE;
    }
    
    LocalFree( pQuery );
    return TRUE;
}

//-------------------------------------------------------

BOOL CopyRSOPQuery( LPRSOP_QUERY pQuery, LPRSOP_QUERY* ppNewQuery )
{
    if ( pQuery == NULL )
    {
        *ppNewQuery = NULL;
        return TRUE;
    }

    *ppNewQuery = (LPRSOP_QUERY)LocalAlloc( LPTR, sizeof(RSOP_QUERY) );
    if ( *ppNewQuery == NULL )
    {
        return FALSE;
    }

    (*ppNewQuery)->QueryType = pQuery->QueryType;
    (*ppNewQuery)->UIMode = pQuery->UIMode;
    (*ppNewQuery)->dwFlags = pQuery->dwFlags;
    
    if ( pQuery->QueryType == RSOP_PLANNING_MODE )
    {
        (*ppNewQuery)->bSlowNetworkConnection = pQuery->bSlowNetworkConnection;
        (*ppNewQuery)->LoopbackMode = pQuery->LoopbackMode;
        if ( !CopyTarget( pQuery->pUser, &((*ppNewQuery)->pUser) ) )
        {
            goto ErrorExit;
        }
        if ( !CopyTarget( pQuery->pComputer, &((*ppNewQuery)->pComputer) ) )
        {
            goto ErrorExit;
        }
        if ( !CopyString( pQuery->szSite, &((*ppNewQuery)->szSite) ) )
        {
            goto ErrorExit;
        }
        if ( !CopyString( pQuery->szDomainController, &((*ppNewQuery)->szDomainController) ) )
        {
            goto ErrorExit;
        }
    }
    else
    {
        if ( !CopyString( pQuery->szComputerName, &((*ppNewQuery)->szComputerName) ) )
        {
            goto ErrorExit;
        }
        if ( !CopyString( pQuery->szUserName, &((*ppNewQuery)->szUserName) ) )
        {
            goto ErrorExit;
        }
        if ( !CopyString( pQuery->szUserSid, &((*ppNewQuery)->szUserSid) ) )
        {
            goto ErrorExit;
        }
    }

    return TRUE;

    ErrorExit:
    if ( FreeRSOPQuery( *ppNewQuery ) )
    {
        *ppNewQuery = NULL;
    }
    return FALSE;
}

//-------------------------------------------------------
BOOL ChangeRSOPQueryType( LPRSOP_QUERY pQuery, RSOP_QUERY_TYPE NewQueryType )
{
    if ( pQuery->QueryType != NewQueryType )
    {
        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
        {
            FreeTarget( pQuery->pUser );
            pQuery->pUser = NULL;
            FreeTarget( pQuery->pComputer );
            pQuery->pComputer = NULL;
            LocalFree( pQuery->szSite );
            pQuery->szSite = NULL;
            LocalFree( pQuery->szDomainController );
            pQuery->szDomainController = NULL;
        }
        else
        {
            LocalFree( pQuery->szUserName );
            pQuery->szUserName = NULL;
            LocalFree( pQuery->szUserSid );
            pQuery->szUserSid = NULL;
            LocalFree( pQuery->szComputerName );
            pQuery->szComputerName = NULL;
        }

        pQuery->QueryType = NewQueryType;
        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
        {
            pQuery->bSlowNetworkConnection = FALSE;
            pQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
            pQuery->szSite = NULL;
            pQuery->szDomainController = NULL;
            pQuery->pUser = (LPRSOP_QUERY_TARGET)LocalAlloc( LPTR, sizeof(RSOP_QUERY_TARGET) );
            pQuery->pComputer = (LPRSOP_QUERY_TARGET)LocalAlloc( LPTR, sizeof(RSOP_QUERY_TARGET) );
            if ( (pQuery->pUser == NULL) || (pQuery->pComputer == NULL) )
            {
                DebugMsg((DM_WARNING, TEXT("ChangeRSOPQueryType: Falied to allocate memory with 0x%x"),
                                    HRESULT_FROM_WIN32( GetLastError() ) ));

                pQuery->QueryType = RSOP_LOGGING_MODE;
                LocalFree( pQuery->pUser );
                LocalFree( pQuery->pComputer );
                pQuery->szUserName = NULL;
                pQuery->szUserSid = NULL;
                pQuery->szComputerName = NULL;

                return FALSE;
            }

            pQuery->pUser->bAssumeWQLFiltersTrue = TRUE;
            pQuery->pComputer->bAssumeWQLFiltersTrue = TRUE;
        }
        else
        {
            pQuery->szUserName = NULL;
            pQuery->szUserSid = NULL;
            pQuery->szComputerName = NULL;
        }

        pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_USER_POLICY ^ 0xffffffff);
        pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_COMPUTER_POLICY ^ 0xffffffff);
        pQuery->dwFlags = pQuery->dwFlags & (RSOP_FIX_USER ^ 0xffffffff);
        pQuery->dwFlags = pQuery->dwFlags & (RSOP_FIX_COMPUTER ^ 0xffffffff);
        pQuery->dwFlags = pQuery->dwFlags & (RSOP_FIX_DC ^ 0xffffffff);
        pQuery->dwFlags = pQuery->dwFlags & (RSOP_FIX_SITENAME ^ 0xffffffff);
    }

    return TRUE;
}

//-------------------------------------------------------

BOOL FreeRSOPQueryResults( LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pResults )
{
    if ( pResults == NULL )
    {
        return TRUE;
    }

    BOOL bSuccess = TRUE;

    if ( pResults->szWMINameSpace != NULL )
    {
        HRESULT hr = CRSOPWizard::DeleteRSOPData( pResults->szWMINameSpace, pQuery );
        if ( FAILED(hr) )
        {
            DebugMsg( (DM_WARNING, TEXT("FreeRSOPQueryResults: Failed to delete RSOP data with 0x%x."), hr) );
            bSuccess = FALSE;
        }
        else
        {
            LocalFree( pResults->szWMINameSpace );
            pResults->szWMINameSpace = NULL;
        }
    }

    if ( bSuccess )
    {
        LocalFree( pResults );
    }
    
    return bSuccess;
}

//-------------------------------------------------------

HRESULT RunRSOPQueryInternal( HWND hParent, CRSOPExtendedProcessing* pExtendedProcessing,
                                    LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults )
{
    // Check parameters
    if ( pQuery == NULL )
    {
        return E_INVALIDARG;
    }

    if ( pQuery->QueryType == RSOP_UNKNOWN_MODE )
    {
        if ( (pQuery->UIMode == RSOP_UI_NONE)
            || ((pQuery->dwFlags & RSOP_FIX_QUERYTYPE) == RSOP_FIX_QUERYTYPE) )
        {
            return E_INVALIDARG;
        }
    }

    RSOP_UI_MODE UIMode = pQuery->UIMode;

    // Check if only the query needs to be run
    if ( (UIMode == RSOP_UI_CHOOSE) || (UIMode == RSOP_UI_REFRESH) || (UIMode == RSOP_UI_NONE) )
    {
        BOOL bRefreshOnly = TRUE;
        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
        {
            if ( (pQuery->pUser->szName == NULL) && (pQuery->pUser->szSOM == NULL)
                && (pQuery->pComputer->szName == NULL) && (pQuery->pComputer->szSOM == NULL) )
            {
                bRefreshOnly = FALSE;
            }
            if ( pQuery->szDomainController == NULL )
            {
                bRefreshOnly = FALSE;
            }
        }
        else
        {
            if ( pQuery->szComputerName == NULL )
            {
                bRefreshOnly = FALSE;
            }
            else if ( (pQuery->szUserName == NULL) && (pQuery->szUserSid == NULL)
                && ((pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY) )
            {
                bRefreshOnly = FALSE;
            }
        }

        if ( UIMode == RSOP_UI_CHOOSE )
        {
            if ( bRefreshOnly )
            {
                UIMode = RSOP_UI_REFRESH;
            }
            else
            {
                UIMode = RSOP_UI_WIZARD;
            }
        }
        else // (UIMode == RSOP_REFRESH) || (UIMode == RSOP_NONE)
        {
            if ( !bRefreshOnly )
            {
                // We have to quit as the user requested refresh with insufficient information
                return E_INVALIDARG;
            }
        }
    }

    if ( UIMode == RSOP_UI_NONE )
    {
        *ppResults = (LPRSOP_QUERY_RESULTS)LocalAlloc( LPTR, sizeof(RSOP_QUERY_RESULTS) );
        if ( *ppResults == NULL )
        {
            DebugMsg( (DM_WARNING, TEXT("CreateRSOPQuery: Failed to allocate memory with 0x%x."), HRESULT_FROM_WIN32(GetLastError())) );
            return E_FAIL;
        }
        (*ppResults)->szWMINameSpace = 0;
        (*ppResults)->bUserDeniedAccess = FALSE;
        (*ppResults)->bNoUserPolicyData = FALSE;
        (*ppResults)->bComputerDeniedAccess = FALSE;
        (*ppResults)->bNoComputerPolicyData = FALSE;
        (*ppResults)->ulErrorInfo = 0;

        // Perform basic RSOP query
        return CRSOPWizard::GenerateRSOPData( NULL, pQuery, &((*ppResults)->szWMINameSpace),
                                                FALSE, FALSE, FALSE, FALSE, &((*ppResults)->ulErrorInfo) );
    }
    else
    {
        // Local variables
        CRSOPWizardDlg wizardDlg( pQuery, pExtendedProcessing );
        HRESULT hr = S_OK;
        LPRSOP_QUERY pOldQuery = NULL;

        if ( UIMode == RSOP_UI_REFRESH )
        {
            hr = wizardDlg.RunQuery( hParent );
        }
        else // UIMode == RSOP_UI_WIZARD
        {
            if ( !CopyRSOPQuery( pQuery, &pOldQuery ) )
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = wizardDlg.ShowWizard( hParent );
            }
        }

        // If successfull, replace original query and get results
        if ( hr == S_OK )
        {
            // Get the results
            *ppResults = wizardDlg.GetResults();

            // Wipe the old query
            FreeRSOPQuery( pOldQuery );
        }
        else if ( hr == S_FALSE )
        {
            // Copy back the old query
            if ( FreeRSOPQueryData( pQuery ) )
            {
                memcpy( pQuery, pOldQuery, sizeof(RSOP_QUERY) );
                LocalFree( pOldQuery );
            }
            else
            {
                FreeRSOPQuery( pOldQuery );
            }
            
            *ppResults = NULL;
        }
        else
        {
            *ppResults = NULL;
        }

        return hr;
    }
}

//-------------------------------------------------------

HRESULT RunRSOPQuery( HWND hParent, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults )
{
    return RunRSOPQueryInternal( hParent, NULL, pQuery, ppResults );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsoputil.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.cpp
//
//  Contents:   helper functions for working with the RSOP databases
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "rsoputil.h"
#pragma warning(4:4535)     // set_se_translator used w/o /EHa from sdkinc\provexce.h
#include "wbemtime.h"

//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(szData);
    hr = pInst->Put(szParam, 0, &var, 0);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, SAFEARRAY * psa)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_BSTR | VT_ARRAY;
    var.parray = psa;
    hr = pInst->Put(szParam, 0, &var, 0);
    return hr;
}

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT uiData)
{
    VARIANT var;
    HRESULT hr = S_OK;
    var.vt = VT_I4;
    var.lVal = uiData;
    hr = pInst->Put(szParam, 0, &var, 0);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetParameterToNull
//
//  Synopsis:   sets a paramter's value in a WMI parameter list to null
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//
//  History:    03-01-2000  ericflo   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT SetParameterToNull(IWbemClassObject * pInst, TCHAR * szParam)
{
    VARIANT var;
    var.vt = VT_NULL;
    return (pInst->Put(szParam, 0, &var, 0));
}

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData, BOOL bUseLocalAlloc /*=FALSE*/ )
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BSTR)
        {
            if ( szData != NULL )
            {
                if ( bUseLocalAlloc )
                {
                    LocalFree( szData );
                }
                else
                {
                    delete [] szData;
                }
                szData = NULL;
            }

            ULONG ulNoChars;

            ulNoChars = _tcslen(var.bstrVal)+1;
            if ( bUseLocalAlloc )
            {
                szData = (TCHAR*)LocalAlloc( LPTR, sizeof(TCHAR) * ulNoChars );
            }
            else
            {
                szData = new TCHAR[ulNoChars];
            }

            if ( szData != NULL )
            {
                hr = StringCchCopy(szData, ulNoChars, var.bstrVal);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BSTR)
        {
            if (bstrData)
            {
                SysFreeString(bstrData);
            }
            bstrData = SysAllocStringLen(var.bstrVal, SysStringLen(var.bstrVal));
            if (NULL == bstrData)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_BOOL)
        {
            fData = var.bVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, LPWSTR *&szStringArray, DWORD &dwSize)
{
    VARIANT      var;
    HRESULT      hr                     = S_OK;
    SAFEARRAY   *pArray;
    long         lSafeArrayUBound;
    long         lSafeArrayLBound;
    long         lSafeArrayLen;
    long         lCount                 = 0;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt ==  (VT_ARRAY | VT_BSTR))
        {
            pArray = var.parray;
            hr = SafeArrayGetUBound(pArray, 1, &lSafeArrayUBound);
            if (FAILED(hr)) {
                return hr;
            }

            hr = SafeArrayGetLBound(pArray, 1, &lSafeArrayLBound);
            if (FAILED(hr)) {
                return hr;
            }

            lSafeArrayLen = 1+(lSafeArrayUBound-lSafeArrayLBound);

            szStringArray = (LPWSTR *)LocalAlloc(LPTR, sizeof(LPWSTR)*lSafeArrayLen);
            if (!szStringArray) {
                hr = E_OUTOFMEMORY;
                return hr;
            }

            for (lCount = 0; lCount < lSafeArrayLen; lCount++) {
                long    lIndex = lSafeArrayLBound+lCount;
                BSTR    bstrElement;

                hr = SafeArrayGetElement(pArray, &lIndex, &bstrElement);

                if (FAILED(hr)) {
                    break;
                }

                ULONG ulNoChars = 1+lstrlen(bstrElement);
                szStringArray[lCount] = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);

                if (!szStringArray[lCount]) {
                    hr = E_OUTOFMEMORY;
                    SysFreeString(bstrElement);
                    break;
                }

                
                hr = StringCchCopy(szStringArray[lCount], ulNoChars, bstrElement);
                ASSERT(SUCCEEDED(hr));

                SysFreeString(bstrElement);
            }

            // if there was an error free the remaining elements
            if (FAILED(hr)) {
                for (;lCount > 0; lCount-- ) {
                    LocalFree(szStringArray[lCount]);
                }
                szStringArray = NULL;
            }
            else {
                dwSize = lSafeArrayLen;
                hr = S_OK;
            }
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt == VT_I4)
        {
            hrData = (HRESULT) var.lVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData)
{
    VARIANT var;
    HRESULT hr = S_OK;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if ((var.vt == VT_UI4) || (var.vt == VT_I4))
        {
            ulData = var.ulVal;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}

HRESULT GetParameterBytes(IWbemClassObject * pInst, TCHAR * szParam, LPBYTE * lpData, DWORD *dwDataSize)
{
    VARIANT var;
    HRESULT hr = S_OK;
    SAFEARRAY * pSafeArray;
    DWORD dwSrcDataSize;
    LPBYTE lpSrcData;

    if (!pInst)
        return E_INVALIDARG;

    VariantInit(&var);
    hr = pInst->Get(szParam, 0, &var, 0, 0);
    if (SUCCEEDED(hr))
    {
        if (var.vt != VT_NULL)
        {
            pSafeArray = var.parray;
            dwSrcDataSize = pSafeArray->rgsabound[0].cElements;
            lpSrcData = (LPBYTE) pSafeArray->pvData;

            *lpData = (LPBYTE)LocalAlloc (LPTR, dwSrcDataSize);

            if (!(*lpData))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

            CopyMemory (*lpData, lpSrcData, dwSrcDataSize);
            *dwDataSize = dwSrcDataSize;
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }
    VariantClear(&var);
    return hr;
}


HRESULT WINAPI ImportRSoPData (LPOLESTR lpNameSpace, LPOLESTR lpFileName)
{
    IMofCompiler * pIMofCompiler;
    HRESULT hr;
    WBEM_COMPILE_STATUS_INFO info;


    //
    // Check args
    //

    if (!lpNameSpace)
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: Null namespace arg")));
        return E_INVALIDARG;
    }

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: Null filename arg")));
        return E_INVALIDARG;
    }


    //
    // Create an instance of the mof compiler
    //

    hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER,
                          IID_IMofCompiler, (LPVOID *) &pIMofCompiler);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: CoCreateInstance failed with 0x%x"), hr));
        return hr;
    }

    //
    // Compile the file
    //

    ZeroMemory (&info, sizeof(info));
    hr = pIMofCompiler->CompileFile (lpFileName, lpNameSpace, NULL, NULL, NULL,
                                     0, 0, 0, &info);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("LoadNameSpaceFromFile: CompileFile failed with 0x%x"), hr));
    }


    pIMofCompiler->Release();

    return hr;
}

BOOL WriteMofFile (HANDLE hFile, LPTSTR lpData)
{
    DWORD dwBytesWritten, dwAnsiDataSize, dwByteCount, dwLFCount = 0;
    LPSTR lpAnsiData;
    LPTSTR lpTemp, lpRealData, lpDest;


    //
    // The lpData argument contains linefeed characters only.  We need to convert
    // these to CR LF characters.  Loop through the data to determine how many LFs
    // need to be converted.
    //

    lpTemp = lpData;

    while (*lpTemp)
    {
        if (*lpTemp == 0x0A)
        {
            dwLFCount++;
        }

        lpTemp++;
    }


    //
    // Allocate a new buffer to hold the string plus CR characters
    //

    lpRealData = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpData) + dwLFCount + 1) * sizeof(TCHAR));

    if (!lpRealData)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: LocalAlloc failed with %d"), GetLastError()));
        return FALSE;
    }


    //
    // Copy the string replacing LF with CRLF as we find them
    //

    lpDest = lpRealData;
    lpTemp = lpData;

    while (*lpTemp)
    {
        if (*lpTemp == 0x0A)
        {
            *lpDest = 0x0D;
            lpDest++;
        }

        *lpDest = *lpTemp;

        lpDest++;
        lpTemp++;
    }


    //
    // Allocate a buffer to hold the ANSI data
    //

    dwAnsiDataSize = lstrlen (lpRealData) * 2;

    lpAnsiData = (LPSTR) LocalAlloc (LPTR, dwAnsiDataSize);

    if (!lpAnsiData)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: LocalAlloc failed with %d"), GetLastError()));
        LocalFree (lpRealData);
        return FALSE;
    }


    //
    // Convert the buffer
    //

    dwByteCount = (DWORD) WideCharToMultiByte (CP_ACP, 0, lpRealData, lstrlen(lpRealData), lpAnsiData, dwAnsiDataSize, NULL, NULL);

    LocalFree (lpRealData);

    if (!dwByteCount)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: WriteFile failed with %d"), GetLastError()));
        LocalFree (lpAnsiData);
        return FALSE;
    }


    //
    // Write the mof description to the file
    //

    if (!WriteFile (hFile, lpAnsiData, dwByteCount, &dwBytesWritten, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: WriteFile failed with %d"), GetLastError()));
        LocalFree (lpAnsiData);
        return FALSE;
    }

    LocalFree (lpAnsiData);


    //
    // Make sure it was all written to the file
    //

    if (dwByteCount != dwBytesWritten)
    {
        DebugMsg((DM_WARNING, TEXT("WriteMofFile: Failed to write the correct amount of data.")));
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    return TRUE;
}

HRESULT EnumInstances (IWbemServices * pIWbemServices, BSTR pClassName, HANDLE hFile)
{
    IWbemClassObject *pObjects[2], *pObject;
    IEnumWbemClassObject *pEnum = NULL;
    ULONG ulCount;
    HRESULT hr;
    BSTR bstrClass;
    DWORD dwError;


    //
    // Create the instance enumerator
    //

    hr = pIWbemServices->CreateInstanceEnum (pClassName, WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumInstances: CreateInstanceEnum failed with 0x%x"), hr));
        return hr;
    }


    //
    // Walk through the list
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulCount) == S_OK)
    {
        pObject = pObjects[0];


        //
        // Get the mof description of this class
        //

        hr = pObject->GetObjectText (0, &bstrClass);

        pObject->Release();

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("EnumInstances: GetObjectText failed with 0x%x"), hr));
            pEnum->Release();
            return hr;
        }


        //
        // Write the mof description to the file
        //

        if (!WriteMofFile (hFile, bstrClass))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("EnumInstances: WriteMofFile failed with %d"), dwError));
            SysFreeString (bstrClass);
            pEnum->Release();
            return HRESULT_FROM_WIN32(dwError);
        }

        SysFreeString (bstrClass);
    }

    pEnum->Release();


    return hr;
}

HRESULT EnumNameSpace (IWbemServices * pIWbemServices, HANDLE hFile)
{
    IWbemClassObject *pObjects[2], *pObject;
    IEnumWbemClassObject *pEnum = NULL;
    ULONG ulCount;
    HRESULT hr;
    VARIANT var;
    BSTR bstrClass;
    DWORD dwError;


    //
    // Create the class enumerator
    //

    hr = pIWbemServices->CreateClassEnum (NULL, WBEM_FLAG_DEEP | WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("EnumNameSpace: CreateClassEnum failed with 0x%x"), hr));
        return hr;
    }


    //
    // Walk through the list
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulCount) == S_OK)
    {
        pObject = pObjects[0];


        //
        // Get the class name
        //

        hr = pObject->Get (TEXT("__CLASS"), 0, &var, NULL, NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("EnumNameSpace: Failed to get class name with 0x%x"), hr));
            pEnum->Release();
            return hr;
        }


        //
        // Check if this is a system class.  System classes start with "_"
        //

        if (var.bstrVal[0] != TEXT('_'))
        {

            //
            // Get the mof description of this class
            //

            hr = pObject->GetObjectText (0, &bstrClass);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: GetObjectText failed with 0x%x"), hr));
                VariantClear (&var);
                pEnum->Release();
                return hr;
            }


            //
            // Write the mof description to the file
            //

            if (!WriteMofFile (hFile, bstrClass))
            {
                dwError = GetLastError();
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: WriteMofFile failed with %d"), dwError));
                SysFreeString (bstrClass);
                VariantClear (&var);
                pEnum->Release();
                return HRESULT_FROM_WIN32(dwError);
            }

            SysFreeString (bstrClass);


            //
            // Now enumerate the instances of this class
            //

            hr = EnumInstances (pIWbemServices, var.bstrVal, hFile);

            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("EnumNameSpace: EnumInstances failed with 0x%x"), hr));
                VariantClear (&var);
                pEnum->Release();
                return hr;
            }
        }

        VariantClear (&var);
    }

    pEnum->Release();


    return hr;
}

HRESULT WINAPI ExportRSoPData (LPTSTR lpNameSpace, LPTSTR lpFileName)
{
    IWbemLocator *pIWbemLocator;
    IWbemServices *pIWbemServices;
    HANDLE hFile;
    HRESULT hr;
    DWORD dwError;


    //
    // Open the data file
    //

    hFile = CreateFile (lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: CreateFile for %s failed with %d"), lpFileName, dwError));
        return HRESULT_FROM_WIN32(dwError);
    }


    //
    // Create a locater instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: CoCreateInstance failed with 0x%x"), hr));
        CloseHandle (hFile);
        return hr;
    }


    //
    // Connect to the server
    //

    BSTR bstrNameSpace = SysAllocString( lpNameSpace );
    if ( bstrNameSpace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: Failed to allocate BSTR memory.")));
        pIWbemLocator->Release();
        CloseHandle(hFile);
        return E_OUTOFMEMORY;
    }
    hr = pIWbemLocator->ConnectServer(bstrNameSpace, NULL, NULL, 0, 0, NULL, NULL, &pIWbemServices);
    SysFreeString( bstrNameSpace );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: ConnectServer to %s failed with 0x%x"), lpNameSpace, hr));
        pIWbemLocator->Release();
        CloseHandle (hFile);
        return hr;
    }

	// Set the proper security to encrypt the data
	hr = CoSetProxyBlanket(pIWbemServices,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
						RPC_C_IMP_LEVEL_IMPERSONATE,
						NULL,
						0);
	if (FAILED(hr))
	{
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: CoSetProxyBlanket failed with 0x%x"), hr));
		pIWbemServices->Release();
        pIWbemLocator->Release();
        CloseHandle (hFile);
        return hr;
	}


    //
    // Enumerate the classes and instances
    //

    hr = EnumNameSpace (pIWbemServices, hFile);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: EnumNameSpace failed with 0x%x"), hr));
    }

    CloseHandle (hFile);


    pIWbemServices->Release();
    pIWbemLocator->Release();

    return hr;
}

//******************************************************************************
//
// Function:        WbemTimeToSystemTime
//
// Description:
//
// Parameters:
//
// Return:
//
// History:     08-16-2000   stevebl   rewrote to use WBEMTime class
//
//******************************************************************************

HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime)
{
    HRESULT hr = E_FAIL;
    WBEMTime wt(xbstrWbemTime);
    if (wt.GetSYSTEMTIME(&sysTime))
    {
        hr = S_OK;
    }
    return hr;
}


//-------------------------------------------------------

HRESULT ExtractWQLFilters (LPTSTR lpNameSpace, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR** paszFilters, 
                                           BOOL bReturnIfTrueOnly )
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pObjGPO = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPO"));
    BSTR bstrFilterId = NULL;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    LPTSTR lpDisplayName;
    INT iIndex;
    LONG   lCount=0, lCountAllocated = 0, l=0;
    LPTSTR* aszWQLFilterIds = NULL;


    // Get a locator instance
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    // Connect to the namespace
    BSTR bstrNameSpace = SysAllocString( lpNameSpace );
    if ( bstrNameSpace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("ExportRSoPData: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    hr = pLocator->ConnectServer(bstrNameSpace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    SysFreeString( bstrNameSpace );
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }

	// Set the proper security to encrypt the data
	hr = CoSetProxyBlanket(pNamespace,
						RPC_C_AUTHN_DEFAULT,
						RPC_C_AUTHZ_DEFAULT,
						COLE_DEFAULT_PRINCIPAL,
						RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
						RPC_C_IMP_LEVEL_IMPERSONATE,
						NULL,
						0);
	if (FAILED(hr))
	{
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: CoSetProxyBlanket failed with 0x%x"), hr));
		goto cleanup;
	}


    // Query for the RSOP_GPO instances
    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    // Allocate memory for 10 - should be enough for most cases
    aszWQLFilterIds = (LPTSTR*)LocalAlloc(LPTR, sizeof(LPTSTR)*(lCountAllocated+10));
    if ( aszWQLFilterIds == 0 )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: LocalAlloc failed with 0x%x"), hr));
        goto cleanup;
    }

    lCountAllocated += 10;


    // Loop through the results
    while (TRUE)
    {
        // Get one instance of RSOP_GPO
        hr = pEnum->Next(WBEM_INFINITE, 1, &pObjGPO, &n);

        if (FAILED(hr) || (n == 0))
        {
            hr = S_OK;
            break;
        }


        // Allocate more memory if necessary
        if ( lCount == lCountAllocated )
        {
            LPTSTR* aszNewWQLFilterIds = (LPTSTR*)LocalAlloc(LPTR, sizeof(LPTSTR)*(lCountAllocated+10));
            if ( aszNewWQLFilterIds == NULL )
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: LocalAlloc failed with 0x%x"), hr));
                goto cleanup;
            }

            lCountAllocated += 10;

            for (l=0; l < lCount; l++)
            {
                aszNewWQLFilterIds[l] = aszWQLFilterIds[l];    
            }

            LocalFree(aszWQLFilterIds);
            aszWQLFilterIds = aszNewWQLFilterIds;
        }


        // Get the filter id
        aszWQLFilterIds[lCount] = NULL;
        hr = GetParameter(pObjGPO, TEXT("filterId"), aszWQLFilterIds[lCount], TRUE);

        if (FAILED(hr))
        {
            goto LoopAgain;
        }

        // if only successful filters need to be returned, check gilterallowed attribute as well
        if (bReturnIfTrueOnly) {
            BOOL    bFilterAllowed;
            hr = GetParameter(pObjGPO, TEXT("filterAllowed"), bFilterAllowed);
            // if it is not there assume it to be false
            if (FAILED(hr))
            {
                goto LoopAgain;
            }

            if (!bFilterAllowed) {
                goto LoopAgain;
            }
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: Filter <%s> evaluates to true on gpo"), aszWQLFilterIds[lCount]));
        }

        if (!aszWQLFilterIds[lCount] || !(*aszWQLFilterIds[lCount]) || (*aszWQLFilterIds[lCount] == TEXT(' ')))
        {
            if (aszWQLFilterIds[lCount])
            {
                LocalFree( aszWQLFilterIds[lCount] );
            }
            goto LoopAgain;
        }


#ifdef DBG
        BSTR bstrGPOName;

        bstrGPOName = NULL;
        hr = GetParameterBSTR(pObjGPO, TEXT("name"), bstrGPOName);

        if ( (SUCCEEDED(hr)) && (bstrGPOName) )
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: Found filter on GPO <%s>"), bstrGPOName));
            SysFreeString (bstrGPOName);
            bstrGPOName = NULL;
        }

        hr = S_OK;
#endif


        // Eliminate duplicates
        for ( l=0; l < lCount; l++ )
        {
            if (lstrcmpi(aszWQLFilterIds[lCount], aszWQLFilterIds[l]) == 0)
            {
                break;
            }
        }

        if ((lCount != 0) && (l != lCount))
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: filter = <%s> is a duplicate"), aszWQLFilterIds[lCount]));
            LocalFree(aszWQLFilterIds[lCount]);
            goto LoopAgain;
        }

        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::ExtractWQLFilters: filter = <%s>"), aszWQLFilterIds[lCount]));


        lCount++;

LoopAgain:

        pObjGPO->Release();
        pObjGPO = NULL;

    }


    // Now allocate arrays. 
    if ( lCount == 0 )
    {
        *pdwCount = 0;
        *paszNames = NULL;
        *paszFilters = NULL;
        goto cleanup;
    }

    *paszNames = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * lCount );
    if ( *paszNames == NULL )
    {
        hr = E_FAIL;
        goto cleanup;
    }

    *paszFilters = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * lCount );
    if ( *paszFilters == NULL )
    {
        LocalFree( *paszNames );
        *paszNames = NULL;
        hr = E_FAIL;
        goto cleanup;
    }

    *pdwCount = lCount;
    for ( l = 0; l < lCount; l++ )
    {
        (*paszFilters)[l] = aszWQLFilterIds[l];

        // Get the filter's friendly display name
        lpDisplayName = GetWMIFilterDisplayName (NULL, aszWQLFilterIds[l], FALSE, TRUE);

        if ( lpDisplayName == NULL )
        {
            ULONG ulNoChars = _tcslen(aszWQLFilterIds[l])+1;

            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::ExtractWQLFilters: Failed to get display name for filter id:  %s"), aszWQLFilterIds[l]));
            (*paszNames)[l] = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR) * ulNoChars );
            if ( (*paszNames)[l] != NULL )
            {
                hr = StringCchCopy( (*paszNames)[l], ulNoChars, aszWQLFilterIds[l] );
                ASSERT(SUCCEEDED(hr));
            }
        }
        else {
            ULONG ulNoChars = _tcslen(lpDisplayName)+1;

            (*paszNames)[l] = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR) * ulNoChars );
            if ( (*paszNames)[l] != NULL )
            {
                hr = StringCchCopy( (*paszNames)[l], ulNoChars, lpDisplayName );
                ASSERT(SUCCEEDED(hr));
            }
            delete lpDisplayName;
        }
    }

    LocalFree( aszWQLFilterIds );
    aszWQLFilterIds = NULL;

cleanup:

    if (bstrFilterId)
    {
        SysFreeString (bstrFilterId);
    }

    if (pObjGPO)
    {
        pObjGPO->Release();
    }

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    if (aszWQLFilterIds) {
        for (l=0; l < lCount; l++) {
            if (aszWQLFilterIds[l])
                LocalFree(aszWQLFilterIds[l]);
        }

        LocalFree(aszWQLFilterIds);
    }

    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);

    return hr;
}

//-------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopquery.h ===
#ifndef __RSOP_QUERY_H__
#define __RSOP_QUERY_H__
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       RSOPQuery.h
//
//  Contents:  Definitions for the RSOP query API
//
//  Functions:
//			CreateRSOPQuery
//			RunRSOPQuery
//			FreeRSOPQuery
//			FreeRSOPQueryResults
//
//  History:	07-30-2001	rhynierm		Created
//
//---------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Defines what kind of user interaction we want.
typedef enum tagRSOP_UI_MODE
{
    RSOP_UI_NONE,
    RSOP_UI_REFRESH,
    RSOP_UI_WIZARD,
    RSOP_UI_CHOOSE
} RSOP_UI_MODE;

// Defines what kind of query we want to run.
typedef enum tagRSOP_QUERY_TYPE
{
    RSOP_UNKNOWN_MODE,
    RSOP_PLANNING_MODE,
    RSOP_LOGGING_MODE
} RSOP_QUERY_TYPE;

// Defines the planning mode loopback mode
typedef enum tagRSOP_LOOPBACK_MODE
{
    RSOP_LOOPBACK_NONE,
    RSOP_LOOPBACK_REPLACE,
    RSOP_LOOPBACK_MERGE
} RSOP_LOOPBACK_MODE;

// Flags that can be set in RSOPQuery
#define RSOP_NO_USER_POLICY 0x1          // Don't run query for user policy
#define RSOP_NO_COMPUTER_POLICY 0x2     // Don't run query for computer policy
#define RSOP_FIX_USER 0x4                // User is prespecified and cannot be changed
#define RSOP_FIX_COMPUTER 0x8           // Computer is prespecified and cannot be changed
#define RSOP_FIX_DC 0x10                 // DC is prespecified and cannot be changed
#define RSOP_FIX_SITENAME 0x20          // Site name is prespecified and cannot be changed
#define RSOP_FIX_QUERYTYPE 0x40         // Fix the query type - this hides the choice page
#define RSOP_NO_WELCOME 0x100           // Do not display a welcome message

// Information identifying the target in the RSOP query.
typedef struct tagRSOP_QUERY_TARGET
{
    LPTSTR          szName;
    LPTSTR          szSOM;
    DWORD           dwSecurityGroupCount;
    LPTSTR*         aszSecurityGroups;           // See dwSecurityGroupCount for # of items
    DWORD*          adwSecurityGroupsAttr;      // See dwSecurityGroupCount for # of items
    BOOL            bAssumeWQLFiltersTrue;
    DWORD           dwWQLFilterCount;
    LPTSTR*         aszWQLFilters;               // See dwWQLFilterCount for # of items
    LPTSTR*         aszWQLFilterNames;          // See dwWQLFilterCount for # of items
} RSOP_QUERY_TARGET, *LPRSOP_QUERY_TARGET;

// Results returned from calling RSOPRunQuery
typedef struct tagRSOP_QUERY_RESULTS
{
    LPTSTR          szWMINameSpace;
    BOOL            bUserDeniedAccess;
    BOOL            bNoUserPolicyData;
    BOOL            bComputerDeniedAccess;
    BOOL            bNoComputerPolicyData;
    ULONG           ulErrorInfo;
} RSOP_QUERY_RESULTS, *LPRSOP_QUERY_RESULTS;

// Structure containing all the information used by the RSOP query API.
typedef struct tagRSOP_QUERY
{
    RSOP_QUERY_TYPE     QueryType;          // Type of query to run
    RSOP_UI_MODE        UIMode;             // TRUE if wizard must show
    DWORD               dwFlags;
    union
    {
        struct  // QueryType == RSOP_PLANNING_MODE
        {
            LPRSOP_QUERY_TARGET pUser;                      // Target user (SAM style name)
            LPRSOP_QUERY_TARGET pComputer;                 // Target computer (SAM style name)
            BOOL                bSlowNetworkConnection;
            RSOP_LOOPBACK_MODE  LoopbackMode;              // Loopback processing
            LPTSTR              szSite;
            LPTSTR              szDomainController;
        };
        struct  // QueryType == (any other option)
        {
            LPTSTR              szUserName;                 // SAM style user object name (Ignored in query - just used for display purposes)
            LPTSTR              szUserSid;                  // User's SID (is actually used for logging mode query)
            LPTSTR              szComputerName;             // SAM style computer object name
        };
    };
} RSOP_QUERY, *LPRSOP_QUERY;

// RSOP Query API

BOOL WINAPI CreateRSOPQuery( LPRSOP_QUERY* ppQuery, RSOP_QUERY_TYPE QueryType );
HRESULT WINAPI RunRSOPQuery( HWND hParent, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults );
BOOL WINAPI FreeRSOPQuery( LPRSOP_QUERY pQuery );
BOOL WINAPI FreeRSOPQueryResults( LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pResults );
BOOL WINAPI CopyRSOPQuery( LPRSOP_QUERY pQuery, LPRSOP_QUERY* ppNewQuery );
BOOL WINAPI ChangeRSOPQueryType( LPRSOP_QUERY pQuery, RSOP_QUERY_TYPE NewQueryType );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopsnap.h ===
//
// SnapIn class
//

class CRSOPSnapIn:
    public IComponent,
    public IExtendContextMenu
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    LPCONSOLE2           m_pConsole2;  // New Console interface for MMC 1.2
    CRSOPComponentData  *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode
    BOOL                 m_bExpand;      // Expand root nodes

public:
    CRSOPSnapIn(CRSOPComponentData *pComponent);
    ~CRSOPSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsoproot.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoproot.cpp
//
//  Contents:   implementation of root RSOP snap-in node
//
//  Classes:    CRSOPComponentDataCF
//              CRSOPComponentData
//
//  Functions:
//
//  History:    09-13-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "objsel.h" // for the object picker
#include "rsoputil.h"
#include "rsopwizard.h"

#include <ntdsapi.h> // for the Ds*DomainController* API
#include "sddl.h"    // for sid to string functions

//---------------------------------------------------------------------------
// Help ids
//

DWORD aGPOListHelpIds[] =
{
    IDC_LIST1,   IDH_RSOP_GPOLIST,
    IDC_CHECK1,  IDH_RSOP_GPOSOM,
    IDC_CHECK2,  IDH_RSOP_APPLIEDGPOS,
    IDC_CHECK3,  IDH_RSOP_REVISION,
    IDC_BUTTON1, IDH_RSOP_SECURITY,
    IDC_BUTTON2, IDH_RSOP_EDIT,

    0, 0
};

DWORD aErrorsHelpIds[] =
{
    IDC_LIST1,   IDH_RSOP_COMPONENTLIST,
    IDC_EDIT1,   IDH_RSOP_COMPONENTDETAILS,
    IDC_BUTTON1, IDH_RSOP_SAVEAS,

    0, 0
};


DWORD aQueryHelpIds[] =
{
    IDC_LIST1,  IDH_RSOP_QUERYLIST,

    0, 0
};


//---------------------------------------------------------------------------
// Private functions
//

HRESULT RunRSOPQueryInternal( HWND hParent, CRSOPExtendedProcessing* pExtendedProcessing,
                                    LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults );     // In RSOPQuery.cpp

WCHAR * NameWithoutDomain(WCHAR * szName);      // In RSOPWizard.cpp

//************************************************************************
//  ParseDN
//
//  Purpose:    Parses the given name to get the pieces. 
//
//  Parameters:
//          lpDSObject  - Path to the DS Obkect in the format LDAP://<DC-Name>/DN
//          pwszDomain  - Returns the <DC-Name>. This is allocated in the fn.
//          pszDN       - The DN part of lpDSObject
//          szSOM       - THe actual SOM (the node on which we have the rsop rights on
// 
// No return value. If memory couldn't be allocated for the pwszDomain it is returned as NULL
//
//************************************************************************

void ParseDN(LPWSTR lpDSObject, LPWSTR *pwszDomain, LPWSTR *pszDN, LPWSTR *szSOM)
{
    LPWSTR  szContainer = lpDSObject;
    LPWSTR  lpEnd = NULL;

   *pszDN = szContainer;

   if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, TEXT("LDAP://"),
                      7, szContainer, 7) != CSTR_EQUAL)
   {
       DebugMsg((DM_WARNING, TEXT("GetSOMFromDN: Object does not start with LDAP://")));
       return;
   }

   szContainer += 7;
   
   lpEnd = szContainer;

   //
   // Move till the end of the domain name
   //

   *pwszDomain = NULL;

   while (*lpEnd && (*lpEnd != TEXT('/'))) {
       lpEnd++;
   }

   if (*lpEnd == TEXT('/')) {
       *pwszDomain = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*( (lpEnd - szContainer) + 1));

       if (*pwszDomain) {
           wcsncpy(*pwszDomain, szContainer, (lpEnd - szContainer));
       }

       szContainer = lpEnd + 1;
   }


   *pszDN = szContainer;
   
   while (*szContainer) {

       //
       // See if the DN name starts with OU=
       //

       if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                          szContainer, 3, TEXT("OU="), 3) == CSTR_EQUAL) {
           break;
       }

       //
       // See if the DN name starts with DC=
       //

       else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE,
                               szContainer, 3, TEXT("DC="), 3) == CSTR_EQUAL) {
           break;
       }


       //
       // Move to the next chunk of the DN name
       //

       while (*szContainer && (*szContainer != TEXT(','))) {
           szContainer++;
       }

       if (*szContainer == TEXT(',')) {
           szContainer++;
       }
   }

   *szSOM = szContainer;
   return;
}

//************************************************************************
//  ParseCommandLine
//
//  Purpose:    Parse the command line to return the value associated with options
//
//  Parameters:
//          szCommandLine   - Part remaining in the unparsed command lines
//          szArgPrefix     - Argument prefix
//          szArgVal        - Argument value. expected in unescaped quotes
//          pbFoundArg      - Whether the argument was found or not
// 
// 
//  Return
//          The remaining cmd line
//
//************************************************************************

LPTSTR ParseCommandLine(LPTSTR szCommandLine, LPTSTR szArgPrefix, LPTSTR *szArgVal, BOOL *pbFoundArg)
{
    LPTSTR lpEnd = NULL;
    int    iTemp;

    iTemp = lstrlen (szArgPrefix);
    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                   szArgPrefix, iTemp,
                   szCommandLine, iTemp) == CSTR_EQUAL)
    {
        *pbFoundArg = TRUE;
    
         //
         // Found the switch
         //
        
         szCommandLine += iTemp + 1;
        
         lpEnd = szCommandLine;
         while (*lpEnd && 
                (!( ( (*(lpEnd-1)) != TEXT('\\') ) && ( (*lpEnd) == TEXT('\"') ) ) ) ) /* look for an unesced quote */
             lpEnd++;
        
         // lpEnd is at the end or at the last quote
         *szArgVal = (LPTSTR) LocalAlloc (LPTR, ((lpEnd - szCommandLine) + 1) * sizeof(TCHAR));
        
         if (*szArgVal)
         {
             lstrcpyn (*szArgVal, szCommandLine, (int)((lpEnd - szCommandLine) + 1));
             DebugMsg((DM_VERBOSE, TEXT("ParseCOmmandLine: Argument %s = <%s>"), szArgPrefix, *szArgVal));
         }
        
         if ((*lpEnd) == TEXT('\"'))
             szCommandLine = lpEnd+1;
         
    }
    else
         *pbFoundArg = FALSE;

    return szCommandLine;
}

//-------------------------------------------------------

WCHAR* NormalizedComputerName(WCHAR * szComputerName )
{
    TCHAR* szNormalizedComputerName;
     
    // Computer names may start with '\\', so we will return
    // the computer name without that prefix if it exists

    szNormalizedComputerName = szComputerName;

    if ( szNormalizedComputerName )
    {
        // Make sure that the computer name string is at least 2 characters in length --
        // if the first character is non-zero, we know the second character must exist
        // since this is a zero terminated string -- in this case, it is safe to compare
        // the first 2 characters
        if ( *szNormalizedComputerName )
        {
            if ( ( TEXT('\\') == szNormalizedComputerName[0] ) &&
                 ( TEXT('\\') == szNormalizedComputerName[1] ) )
            {
                szNormalizedComputerName += 2;
            }
        }
    }

    return szNormalizedComputerName;
}

//************************************************************************
// CopyUnescapedSOM
//
// Purpose: to remove all escape sequence literals
// of the form \" from a SOM stored in WMI -- WMI
// cannot store the " character in a key field, so the 
// only way to store the " is to escape it -- this is done
// so by preceding it with the \ char.  To give back
// a friendly display to the user, we undo the escape process
//************************************************************************

void CopyUnescapedSOM( LPTSTR lpUnescapedSOM, LPTSTR lpSOM )
{
    while ( *lpSOM )
    {
        //
        // If we have the escape character
        //
        if ( TEXT('\\') == *lpSOM )
        {
            //
            // Check for the " character
            //
            if ( (TEXT('"') == *(lpSOM + 1)) || (TEXT('\\') == *(lpSOM + 1)) ) 
            {
                //
                // Skip the escape character if this is the " char
                //
                lpSOM++;
            }
        }

        *lpUnescapedSOM++ = *lpSOM++;
    } 

    *lpUnescapedSOM = TEXT('\0');
}

//*************************************************************
//
//  MyTranslateName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
// Allocates and retries with the appropriate buffer size
//
//*************************************************************

LPTSTR MyTranslateName (LPTSTR lpAccName, EXTENDED_NAME_FORMAT  NameFormat, EXTENDED_NAME_FORMAT  desiredNameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (desiredNameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = (LPTSTR) LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!TranslateName (lpAccName, NameFormat, desiredNameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  TranslateName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpTemp = (LPTSTR) LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }


        lpUserName = lpTemp;

        if (!TranslateName (lpAccName, NameFormat, desiredNameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetTranslateName:  TranslateName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpUserName;
}

//---------------------------------------------------------------------------
// _CExtendedProcessing class

class _CExtendedProcessing : public CRSOPExtendedProcessing
{
public:
    _CExtendedProcessing( BOOL bGetExtendedErrorInfo, CRSOPGPOLists& gpoLists, CRSOPCSELists& cseLists )
        : m_GPOLists( gpoLists )
        , m_CSELists( cseLists )
        , m_bGetExtendedErrorInfo( bGetExtendedErrorInfo )
        { ; }

    ~_CExtendedProcessing()
        { ; }

    virtual HRESULT DoProcessing( LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pResults, BOOL bGetExtendedErrorInfo );

    virtual BOOL GetExtendedErrorInfo() const
        {
            return m_bGetExtendedErrorInfo;
        }

private:
    CRSOPGPOLists& m_GPOLists;
    CRSOPCSELists& m_CSELists;

    BOOL m_bGetExtendedErrorInfo;
};

HRESULT _CExtendedProcessing::DoProcessing( LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pResults, BOOL bGetExtendedErrorInfo )
{
    m_bGetExtendedErrorInfo = bGetExtendedErrorInfo;
    m_GPOLists.Build( pResults->szWMINameSpace );
    m_CSELists.Build( pQuery, pResults->szWMINameSpace, GetExtendedErrorInfo() );

    if ( m_CSELists.GetEvents() != NULL )
    {
        m_CSELists.GetEvents()->DumpDebugInfo();
    }

    return S_OK;
}

//---------------------------------------------------------------------------
// CRSOPGPOLists class

void CRSOPGPOLists::Build( LPTSTR szWMINameSpace )
{
    LPTSTR lpNamespace, lpEnd;
    ULONG ulNoChars;
    HRESULT hr;

    ulNoChars = lstrlen(szWMINameSpace) + 20;
    lpNamespace = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (lpNamespace)
    {
        hr = StringCchCopy( lpNamespace, ulNoChars, szWMINameSpace );
        ASSERT(SUCCEEDED(hr));

        ULONG ulNoRemChars;

        lpEnd = CheckSlash(lpNamespace);
        ulNoRemChars = ulNoChars - lstrlen(lpNamespace);
        hr = StringCchCat (lpNamespace, ulNoChars, TEXT("User"));

        if (SUCCEEDED(hr)) 
        {
            if (m_pUserGPOList)
            {
                FreeGPOListData(m_pUserGPOList);
                m_pUserGPOList = NULL;
            }
            BuildGPOList (&m_pUserGPOList, lpNamespace);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOLists: Could not copy the nmae space with %d"),hr));
        }

        hr = StringCchCopy (lpEnd, ulNoRemChars, TEXT("Computer"));
        if (SUCCEEDED(hr)) 
        {
            if (m_pComputerGPOList)
            {
                FreeGPOListData(m_pComputerGPOList);
                m_pComputerGPOList = NULL;
            }

            BuildGPOList (&m_pComputerGPOList, lpNamespace);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOLists: Cou;d not copy the nmae space with %d"),hr));
        }

        LocalFree (lpNamespace);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOLists: Failed to allocate memory for namespace with %d"),
                 GetLastError()));
    }
}

//-------------------------------------------------------

void CRSOPGPOLists::BuildGPOList (LPGPOLISTITEM * lpList, LPTSTR lpNamespace)
{
    HRESULT hr;
    ULONG n, ulIndex = 0, ulOrder, ulAppliedOrder;
    IWbemClassObject * pObjGPLink = NULL;
    IWbemClassObject * pObjGPO = NULL;
    IWbemClassObject * pObjSOM = NULL;
    IEnumWbemClassObject * pAppliedEnum = NULL;
    IEnumWbemClassObject * pNotAppliedEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strAppliedQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPLink where AppliedOrder > 0"));
    BSTR strNotAppliedQuery = SysAllocString(TEXT("SELECT * FROM RSOP_GPLink where AppliedOrder = 0"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR strTemp = NULL;
    WCHAR * szGPOName = NULL;
    WCHAR * szSOM = NULL;
    WCHAR * szGPOPath = NULL;
    WCHAR szFiltering[80] = {0};
    BSTR bstrTemp = NULL;
    ULONG ul = 0, ulVersion = 0;
    BOOL bLinkEnabled, bGPOEnabled, bAccessDenied, bFilterAllowed, bSOMBlocked;
    BOOL bProcessAppliedList = TRUE;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    LV_COLUMN lvcol;
    BOOL      bValidGPOData;
    LPBYTE pSD = NULL;
    DWORD dwDataSize = 0;


    // Get a locator instance

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }

    // Connect to the namespace

    BSTR bstrNamespace = SysAllocString( lpNamespace );
    if ( bstrNamespace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    hr = pLocator->ConnectServer(bstrNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    SysFreeString( bstrNamespace );
    
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: CoSetProxyBlanket failed with 0x%x"), hr));
        goto cleanup;
    }

    // Query for the RSOP_GPLink (applied) instances 

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strAppliedQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY,
                               NULL,
                               &pAppliedEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }

    // Query for the RSOP_GPLink (notapplied) instances 

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strNotAppliedQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY,
                               NULL,
                               &pNotAppliedEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: ExecQuery (notapplied) failed with 0x%x"), hr));
        goto cleanup;
    }


    bProcessAppliedList = FALSE;

    // Loop through the results

    while (TRUE)
    {

        if (!bProcessAppliedList) {
            
            // No need to sort the not applied list

            hr = pNotAppliedEnum->Next(WBEM_INFINITE, 1, &pObjGPLink, &n);
            if (FAILED(hr) || (n == 0))
            {
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::BuildGPOList: Getting applied links")));
                bProcessAppliedList = TRUE;
            }
            else {
                hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulOrder);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get link order with 0x%x"), hr));
                    goto cleanup;
                }
            }
        }

        // Reset the enumerator so we can look through the results to find the correct index

        if (bProcessAppliedList) {
            pAppliedEnum->Reset();

            // Find the correct index in the result set
            
            ulIndex++;
            ulOrder = 0;
            do {
                hr = pAppliedEnum->Next(WBEM_INFINITE, 1, &pObjGPLink, &n);
                if (FAILED(hr) || (n == 0))
                {
                    goto cleanup;
                }


                hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulOrder);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get link order with 0x%x"), hr));
                    goto cleanup;
                }

                if (ulOrder != ulIndex)
                {
                    pObjGPLink->Release();
                    pObjGPLink = NULL;
                }

            } while (ulOrder != ulIndex);


            if (FAILED(hr)) {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Next failed with error 0x%x"), hr));
                goto cleanup;
            }
        }


        // Get the applied order of this link

        hr = GetParameter(pObjGPLink, TEXT("AppliedOrder"), ulAppliedOrder);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get applied order with 0x%x"), hr));
            goto cleanup;
        }

        // Get the enabled state of the link

        hr = GetParameter(pObjGPLink, TEXT("enabled"), bLinkEnabled);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get enabled with 0x%x"), hr));
            goto cleanup;
        }

        // Get the GPO path

        hr = GetParameterBSTR(pObjGPLink, TEXT("GPO"), bstrTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get GPO with 0x%x"), hr));
            goto cleanup;
        }

        // Set the default GPO name to be the gpo path.  Don't worry about
        // freeing this string because the GetParameter call will free the buffer
        // when the real name is successfully queried. Sometimes the rsop_gpo instance
        // won't exist if this gpo is new.

        ULONG ulNoChars;

        ulNoChars = _tcslen(bstrTemp) + 1;
        szGPOName = new TCHAR[ulNoChars];

        if (!szGPOName)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for temp gpo name.")));
            goto cleanup;
        }

        if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           TEXT("RSOP_GPO.id="), 12, bstrTemp, 12) == CSTR_EQUAL)
        {
            // removing the first and last quote
            hr = StringCchCopy (szGPOName, ulNoChars, bstrTemp+13);
            if (SUCCEEDED(hr)) 
            {
                szGPOName[lstrlen(szGPOName)-1] = TEXT('\0');
            }
        }
        else
        {
            hr = StringCchCopy (szGPOName, ulNoChars, bstrTemp);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Could not copy GPO name")));
            goto cleanup;
        }

        // Add ldap to the path if appropriate

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, szGPOName, -1, TEXT("LocalGPO"), -1) != CSTR_EQUAL)
        {
            ulNoChars = lstrlen(szGPOName) + 10;
            szGPOPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(WCHAR));

            if (!szGPOPath)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for full path with %d"),
                         GetLastError()));
                goto cleanup;
            }

            hr = StringCchCopy (szGPOPath, ulNoChars, TEXT("LDAP://"));
            if (SUCCEEDED(hr)) 
            {
                hr = StringCchCat (szGPOPath, ulNoChars, szGPOName);
            }

            if (FAILED(hr)) 
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Could not copy GPO path")));
                goto cleanup;
            }

        }
        else
        {
            szGPOPath = NULL;
        }



        bValidGPOData = FALSE;

        // Bind to the GPO

        hr = pNamespace->GetObject(
                          bstrTemp,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObjGPO,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: GetObject for GPO %s failed with 0x%x"),
                      bstrTemp, hr));
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            goto GetSOMData;
        }
        SysFreeString (bstrTemp);
        bstrTemp = NULL;


        // Get the GPO name

        hr = GetParameter(pObjGPO, TEXT("name"), szGPOName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get name with 0x%x"), hr));
            goto GetSOMData;

        }

        // Get the version number

        hr = GetParameter(pObjGPO, TEXT("version"), ulVersion);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get version with 0x%x"), hr));
            goto GetSOMData;

        }

        // Get the enabled state of the GPO

        hr = GetParameter(pObjGPO, TEXT("enabled"), bGPOEnabled);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get gpo enabled state with 0x%x"), hr));
            goto GetSOMData;
        }

        // Get the WMI filter state of the GPO

        hr = GetParameter(pObjGPO, TEXT("filterAllowed"), bFilterAllowed);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get gpo enabled state with 0x%x"), hr));
            goto GetSOMData;
        }


        // Check for access denied

        hr = GetParameter(pObjGPO, TEXT("accessDenied"), bAccessDenied);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get accessdenied with 0x%x"), hr));
            goto GetSOMData;
        }

        // Get the security descriptor

        if (szGPOPath)
        {
            hr = GetParameterBytes(pObjGPO, TEXT("securityDescriptor"), &pSD, &dwDataSize);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get security descriptor with 0x%x"), hr));
                goto GetSOMData;
            }
        }

        
        bValidGPOData = TRUE;

GetSOMData:

        // Get the SOM for this link (the S,D,OU that this GPO is linked to)

        hr = GetParameterBSTR(pObjGPLink, TEXT("SOM"), bstrTemp);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get SOM with 0x%x"), hr));
            goto AddNode;
        }

        // Bind to the SOM instance

        hr = pNamespace->GetObject(
                          bstrTemp,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pObjSOM,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: GetObject for SOM of %s failed with 0x%x"),
                     bstrTemp, hr));
            SysFreeString (bstrTemp);
            bstrTemp = NULL;
            goto AddNode;
        }

        SysFreeString (bstrTemp);
        bstrTemp = NULL;

        // Get SOM name

        hr = GetParameter(pObjSOM, TEXT("id"), szSOM);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get som id with 0x%x"), hr));
            goto AddNode;
        }

        // Get blocked from above

        hr = GetParameter(pObjSOM, TEXT("blocked"), bSOMBlocked);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to get som id with 0x%x"), hr));
            goto AddNode;
        }



AddNode:

        // Decide on the filtering name

        if (ulAppliedOrder > 0)
        {
            LoadString(g_hInstance, IDS_APPLIED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if (!bLinkEnabled)
        {
            LoadString(g_hInstance, IDS_DISABLEDLINK, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if (bSOMBlocked) {
            LoadString(g_hInstance, IDS_BLOCKEDSOM, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (!bGPOEnabled))
        {
            LoadString(g_hInstance, IDS_DISABLEDGPO, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (bAccessDenied))
        {
            LoadString(g_hInstance, IDS_SECURITYDENIED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (!bFilterAllowed))
        {
            LoadString(g_hInstance, IDS_WMIFILTERFAILED, szFiltering, ARRAYSIZE(szFiltering));
        }
        else if ((bValidGPOData) && (ulVersion == 0))
        {
            LoadString(g_hInstance, IDS_NODATA, szFiltering, ARRAYSIZE(szFiltering));
        }
        else
        {
            LoadString(g_hInstance, IDS_UNKNOWNREASON, szFiltering, ARRAYSIZE(szFiltering));
        }


        if (!szSOM)
        {
            szSOM = new TCHAR[2];

            if (!szSOM)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate memory for temp som name.")));
                goto cleanup;
            }

            szSOM[0] = TEXT(' ');
        }

        // Add this node to the list

        if (!AddGPOListNode(szGPOName, szGPOPath, szSOM, szFiltering, ulVersion,
                            ((ulAppliedOrder > 0) ? TRUE : FALSE), pSD, dwDataSize, lpList))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: AddGPOListNode failed.")));
        }


        // Prepare for next iteration

        if (pObjSOM)
        {
            pObjSOM->Release();
            pObjSOM = NULL;
        }
        if (pObjGPO)
        {
            pObjGPO->Release();
            pObjGPO = NULL;
        }
        if (pObjGPLink)
        {
            pObjGPLink->Release();
            pObjGPLink = NULL;
        }

        if (szGPOName)
        {
            delete [] szGPOName;
            szGPOName = NULL;
        }

        if (szSOM)
        {
            delete [] szSOM;
            szSOM = NULL;
        }

        if (szGPOPath)
        {
            LocalFree (szGPOPath);
            szGPOPath = NULL;
        }

        if (pSD)
        {
            LocalFree (pSD);
            pSD = NULL;
            dwDataSize = 0;
        }

        ulVersion = 0;
    }

cleanup:
    if (szGPOPath)
    {
        LocalFree (szGPOPath);
    }
    if (pSD)
    {
        LocalFree (pSD);
    }
    if (szGPOName)
    {
        delete [] szGPOName;
    }
    if (szSOM)
    {
        delete [] szSOM;
    }
    if (pObjSOM)
    {
        pObjSOM->Release();
    }
    if (pObjGPO)
    {
        pObjGPO->Release();
    }
    if (pObjGPLink)
    {
        pObjGPLink->Release();
    }
    if (pAppliedEnum)
    {
        pAppliedEnum->Release();
    }
    if (pNotAppliedEnum)
    {
        pNotAppliedEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strAppliedQuery);
    SysFreeString(strNotAppliedQuery);
    SysFreeString(strNamespace);
}

//-------------------------------------------------------

VOID CRSOPGPOLists::FreeGPOListData(LPGPOLISTITEM lpList)
{
    LPGPOLISTITEM lpTemp;


    do {
        lpTemp = lpList->pNext;
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

//-------------------------------------------------------

BOOL CRSOPGPOLists::AddGPOListNode(LPTSTR lpGPOName, LPTSTR lpDSPath, LPTSTR lpSOM,
                                        LPTSTR lpFiltering, DWORD dwVersion, BOOL bApplied,
                                        LPBYTE pSD, DWORD dwSDSize, LPGPOLISTITEM *lpList)
{
    DWORD dwSize;
    LPGPOLISTITEM lpItem, lpTemp;
    ULONG ulNoChars;
    HRESULT hr;


    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (GPOLISTITEM);

    dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));

    if (lpDSPath)
    {
        dwSize += ((lstrlen(lpDSPath) + 1) * sizeof(TCHAR));
    }

    dwSize += ((lstrlen(lpSOM) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpSOM) + 1) * sizeof(TCHAR)); // The unescaped SOM length -- it is always smaller than the actual SOM
    dwSize += ((lstrlen(lpFiltering) + 1) * sizeof(TCHAR));
    dwSize += dwSDSize + MAX_ALIGNMENT_SIZE;


    //
    // Allocate space for it
    //

    lpItem = (LPGPOLISTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddGPOListNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    ulNoChars = (dwSize - sizeof(GPOLISTITEM))/sizeof(WCHAR);

    lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(GPOLISTITEM));
    hr = StringCchCopy (lpItem->lpGPOName, ulNoChars, lpGPOName);

    if (SUCCEEDED(hr)) 
    {
        if (lpDSPath)
        {
            lpItem->lpDSPath = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
            ulNoChars = ulNoChars -(lstrlen (lpItem->lpGPOName) + 1); 
            hr = StringCchCopy (lpItem->lpDSPath, ulNoChars, lpDSPath);
            if (SUCCEEDED(hr)) 
            {
                lpItem->lpSOM = lpItem->lpDSPath + lstrlen (lpItem->lpDSPath) + 1;
                ulNoChars = ulNoChars - (lstrlen (lpItem->lpDSPath) + 1);
                hr = StringCchCopy (lpItem->lpSOM, ulNoChars, lpSOM);
            }            
        }
        else
        {
            lpItem->lpSOM = lpItem->lpGPOName + lstrlen (lpItem->lpGPOName) + 1;
            ulNoChars = ulNoChars - (lstrlen (lpItem->lpGPOName) + 1);
            hr = StringCchCopy (lpItem->lpSOM, ulNoChars, lpSOM);
        }
    }

    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddGPOListNode: Could not copy GPO list item with %d"), hr));
        LocalFree(lpItem);
        return FALSE;
    }

    //
    // Note that the DS SOM's may contain characters such as '"' that 
    // must be escaped with a "\" in WMI -- thus the SOM name will contain
    // '\' escape chars that are not actually present in the real SOM name,
    // so we call a function that removes them
    //
    lpItem->lpUnescapedSOM = lpItem->lpSOM + lstrlen (lpItem->lpSOM) + 1;        
    CopyUnescapedSOM( lpItem->lpUnescapedSOM, lpItem->lpSOM );

    lpItem->lpFiltering = lpItem->lpUnescapedSOM + lstrlen (lpItem->lpUnescapedSOM) + 1;
    ulNoChars = ulNoChars - (lstrlen (lpItem->lpUnescapedSOM) + 1);
    hr = StringCchCopy (lpItem->lpFiltering, ulNoChars, lpFiltering);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddGPOListNode: Could not copy GPO list item with %d"), hr));
        LocalFree(lpItem);
        return FALSE;
    }

    if (pSD)
    {
        // sd has to be pointer aligned. This is currently aligning it to
        // 8 byte boundary

        DWORD dwOffset;

        dwOffset = (DWORD) ((LPBYTE)(lpItem->lpFiltering + lstrlen (lpItem->lpFiltering) + 1) - (LPBYTE)lpItem);
        lpItem->pSD = (LPBYTE)lpItem + ALIGN_SIZE_TO_NEXTPTR(dwOffset);

        CopyMemory (lpItem->pSD, pSD, dwSDSize);
    }

    lpItem->dwVersion = dwVersion;
    lpItem->bApplied = bApplied;


    //
    // Add item to the link list
    //

    if (*lpList)
    {
        lpTemp = *lpList;

        while (lpTemp)
        {
            if (!lpTemp->pNext)
            {
                lpTemp->pNext = lpItem;
                break;
            }
            lpTemp = lpTemp->pNext;
        }
    }
    else
    {
        *lpList = lpItem;
    }


    return TRUE;
}

//---------------------------------------------------------------------------
// CRSOPCSELists class

VOID CRSOPCSELists::Build( LPRSOP_QUERY pQuery, LPTSTR szWMINameSpace, BOOL bGetEventLogErrors )
{
    LPTSTR lpNamespace, lpEnd;
    HRESULT hr;
    ULONG ulNoChars;
    ULONG ulNoRemChars;

    ulNoChars = lstrlen(szWMINameSpace) + 20;
    lpNamespace = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (lpNamespace)
    {
        hr = StringCchCopy( lpNamespace, ulNoChars, szWMINameSpace );
        ASSERT(SUCCEEDED(hr));

        lpEnd = CheckSlash(lpNamespace);
        ulNoRemChars = ulNoChars - lstrlen(lpNamespace);

        m_bNoQuery = !bGetEventLogErrors;
        
        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_szTargetMachine = pQuery->szDomainController;
        }
        else
        {
            m_szTargetMachine = pQuery->szComputerName;
        }

        hr = StringCchCat (lpNamespace, ulNoChars, TEXT("User"));
        if (SUCCEEDED(hr)) 
        {
            if (m_pUserCSEList)
            {
                FreeCSEData(m_pUserCSEList);
                m_pUserCSEList = NULL;

                m_bUserCSEError = FALSE;
                m_bUserGPCoreError = FALSE;
                m_bUserGPCoreWarning = FALSE;
            }

            BuildCSEList( pQuery, &m_pUserCSEList, lpNamespace, TRUE, &m_bUserCSEError, &m_bUserGPCoreError );

            if (!m_bViewIsArchivedData)
            {
                QueryRSoPPolicySettingStatusInstances (lpNamespace);
            }


            //  
            // by this time m_pEvents is populated with eventlog entries
            // in archived and non archived cases
            //

            // go through the list and figure out which one belongs to gp core

            if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
            {
                for (LPCSEITEM lpTemp=m_pUserCSEList; lpTemp != NULL; lpTemp = lpTemp->pNext)
                {
                    GUID    guid;
                    StringToGuid( lpTemp->lpGUID, &guid);


                    if (IsNullGUID(&guid))
                    {
                        if (m_pEvents)
                        {
                            LPWSTR  szEvents=NULL;
                            m_pEvents->GetCSEEntries(&(lpTemp->BeginTime), &(lpTemp->EndTime),
                                                     lpTemp->lpEventSources,
                                                     &szEvents,
                                                     TRUE);

                            if (szEvents)
                            {
                                m_bUserGPCoreWarning = TRUE;
                                CoTaskMemFree(szEvents);
                            }
                        }

                        break;
                    }
                }
            }
        }

        hr = StringCchCopy (lpEnd, ulNoRemChars, TEXT("Computer"));
        if (SUCCEEDED(hr)) 
        {
            if (m_pComputerCSEList)
            {
                FreeCSEData(m_pComputerCSEList);
                m_pComputerCSEList = NULL;

                m_bComputerCSEError = FALSE;
                m_bComputerGPCoreError = FALSE;
                m_bComputerGPCoreWarning = FALSE;
            }

            BuildCSEList( pQuery, &m_pComputerCSEList, lpNamespace, FALSE, &m_bComputerCSEError, &m_bComputerGPCoreError );

            if (!m_bViewIsArchivedData)
            {
                QueryRSoPPolicySettingStatusInstances (lpNamespace);
            }


            //  
            // by this time m_pEvents is populated with eventlog entries
            // in archived and non archived cases
            //

            // go through the list and figure out which one belongs to gp core

            if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
            {
                for (LPCSEITEM lpTemp=m_pComputerCSEList; lpTemp != NULL; lpTemp = lpTemp->pNext)
                {
                    GUID    guid;
                    StringToGuid( lpTemp->lpGUID, &guid);


                    if (IsNullGUID(&guid))
                    {
                        if (m_pEvents)
                        {
                            LPWSTR  szEvents=NULL;
                            m_pEvents->GetCSEEntries(&(lpTemp->BeginTime), &(lpTemp->EndTime),
                                                     lpTemp->lpEventSources,
                                                     &szEvents,
                                                     TRUE);

                            if (szEvents)
                            {
                                m_bComputerGPCoreWarning = TRUE;
                                CoTaskMemFree(szEvents);
                            }
                        }

                        break;
                    }
                }
            }
        }

        LocalFree (lpNamespace);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSELists: Failed to allocate memory for namespace with %d"),
                 GetLastError()));
    }

    m_szTargetMachine = NULL;
}

//-------------------------------------------------------

void CRSOPCSELists::BuildCSEList( LPRSOP_QUERY pQuery, LPCSEITEM * lpList, LPTSTR lpNamespace, BOOL bUser, BOOL *bCSEError, BOOL *bGPCoreError )
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pExtension = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSOP_ExtensionStatus"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR bstrName = NULL;
    BSTR bstrGUID = NULL;
    BSTR bstrBeginTime = NULL;
    BSTR bstrEndTime = NULL;
    ULONG ulLoggingStatus;
    ULONG ulStatus;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    SYSTEMTIME BeginTime, EndTime;
    LPTSTR lpSourceNames = NULL;
    XBStr xbstrWbemTime;
    LPSOURCEENTRY lpSources;

    // Get a locator instance

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }

    // Connect to the namespace

    BSTR bstrNamespace = SysAllocString( lpNamespace );
    if ( bstrNamespace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    hr = pLocator->ConnectServer(bstrNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    SysFreeString( bstrNamespace );
    
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: CoSetProxyBlanket failed with 0x%x"), hr));
        goto cleanup;
    }

    // Query for the RSOP_ExtensionStatus instances

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }

    // Loop through the results

    while (TRUE)
    {
        // Get 1 instance

        hr = pEnum->Next(WBEM_INFINITE, 1, &pExtension, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }

        // Get the name

        hr = GetParameterBSTR(pExtension, TEXT("displayName"), bstrName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }

        // Get the GUID

        hr = GetParameterBSTR(pExtension, TEXT("extensionGuid"), bstrGUID);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }

        // Get the status

        hr = GetParameter(pExtension, TEXT("error"), ulStatus);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get status with 0x%x"), hr));
            goto cleanup;

        }

        // Get the rsop logging status

        hr = GetParameter(pExtension, TEXT("loggingStatus"), ulLoggingStatus);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get logging status with 0x%x"), hr));
            goto cleanup;
        }

        // Get the BeginTime in bstr format

        hr = GetParameterBSTR(pExtension, TEXT("beginTime"), bstrBeginTime);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: Failed to get begin time with 0x%x"), hr));
            goto cleanup;
        }

        // Convert it to system time format

        xbstrWbemTime = bstrBeginTime;

        hr = WbemTimeToSystemTime(xbstrWbemTime, BeginTime);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: WbemTimeToSystemTime failed with 0x%x"), hr));
            goto cleanup;
        }

        // Get the EndTime in bstr format

        hr = GetParameterBSTR(pExtension, TEXT("endTime"), bstrEndTime);

        if (SUCCEEDED(hr))
        {
            // Convert it to system time format

            xbstrWbemTime = bstrEndTime;

            hr = WbemTimeToSystemTime(xbstrWbemTime, EndTime);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: WbemTimeToSystemTime failed with 0x%x"), hr));
                goto cleanup;
            }
        }
        else
        {
            FILETIME ft;
            ULARGE_INTEGER ulTime;

            // Add 2 minutes to BeginTime to get a close approx of the EndTime

            if (!SystemTimeToFileTime (&BeginTime, &ft))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: SystemTimeToFileTime failed with %d"), GetLastError()));
                goto cleanup;
            }

            ulTime.LowPart = ft.dwLowDateTime;
            ulTime.HighPart = ft.dwHighDateTime;

            ulTime.QuadPart = ulTime.QuadPart + (10000000 * 120);  // 120 seconds

            ft.dwLowDateTime = ulTime.LowPart;
            ft.dwHighDateTime = ulTime.HighPart;

            if (!FileTimeToSystemTime (&ft, &EndTime))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: FileTimeToSystemTime failed with %d"), GetLastError()));
                goto cleanup;
            }
        }

        // Get the event log source information

        lpSources = NULL;
        GetEventLogSources (pNamespace, bstrGUID, m_szTargetMachine,
                            &BeginTime, &EndTime, &lpSources);


        // Add this node to the list
        if (!AddCSENode(bstrName, bstrGUID, ulStatus, ulLoggingStatus, &BeginTime, &EndTime, bUser,
                        lpList, bCSEError, bGPCoreError, lpSources))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildCSEList: AddGPOListNode failed.")));
            if (m_pEvents)
            {
                m_pEvents->FreeSourceData (lpSources);
            }
            goto cleanup;
        }

        // Prepare for next iteration

        SysFreeString (bstrName);
        bstrName = NULL;

        SysFreeString (bstrGUID);
        bstrGUID = NULL;

        SysFreeString (bstrBeginTime);
        bstrBeginTime = NULL;

        if (bstrEndTime)
        {
            SysFreeString (bstrEndTime);
            bstrEndTime = NULL;
        }

        LocalFree (lpSourceNames);
        lpSourceNames = NULL;

        pExtension->Release();
        pExtension = NULL;
    }

cleanup:

    if (bstrName)
    {
        SysFreeString (bstrName);
    }
    if (bstrGUID)
    {
        SysFreeString (bstrGUID);
    }
    if (bstrBeginTime)
    {
        SysFreeString (bstrBeginTime);
    }
    if (bstrEndTime)
    {
        SysFreeString (bstrEndTime);
    }
    if (lpSourceNames)
    {
        LocalFree (lpSourceNames);
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
}

//-------------------------------------------------------

VOID CRSOPCSELists::FreeCSEData(LPCSEITEM lpList)
{
    LPCSEITEM lpTemp;


    do {
        lpTemp = lpList->pNext;
        if (m_pEvents)
        {
            m_pEvents->FreeData();
            m_pEvents->FreeSourceData (lpList->lpEventSources);
        }
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

//-------------------------------------------------------

BOOL CRSOPCSELists::AddCSENode(LPTSTR lpName, LPTSTR lpGUID, DWORD dwStatus,
                                    ULONG ulLoggingStatus, SYSTEMTIME *pBeginTime, SYSTEMTIME *pEndTime, BOOL bUser,
                                    LPCSEITEM *lpList, BOOL *bCSEError, BOOL *bGPCoreError,
                                    LPSOURCEENTRY lpSources)
{
    DWORD dwSize;
    LPCSEITEM lpItem, lpTemp;
    GUID guid;
    ULONG ulNoChars;
    HRESULT hr;

    //
    // Calculate the size of the new item
    //

    dwSize = sizeof (CSEITEM);

    dwSize += ((lstrlen(lpName) + 1) * sizeof(TCHAR));
    dwSize += ((lstrlen(lpGUID) + 1) * sizeof(TCHAR));


    //
    // Allocate space for it
    //

    lpItem = (LPCSEITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddCSENode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->lpName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(CSEITEM));
    ulNoChars = (dwSize - sizeof(CSEITEM))/sizeof(WCHAR);
    hr = StringCchCopy (lpItem->lpName, ulNoChars, lpName);
    if (SUCCEEDED(hr)) 
    {
        lpItem->lpGUID = lpItem->lpName + lstrlen (lpItem->lpName) + 1;
        ulNoChars = ulNoChars - (lstrlen (lpItem->lpName) + 1);
        hr = StringCchCopy (lpItem->lpGUID, ulNoChars, lpGUID);
    }
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::AddCSENode: Could not copy GPO name with %d"),hr));
        LocalFree(lpItem);
        return FALSE;
    }

    lpItem->dwStatus = dwStatus;
    lpItem->ulLoggingStatus = ulLoggingStatus;
    lpItem->lpEventSources = lpSources;
    lpItem->bUser = bUser;

    CopyMemory ((LPBYTE)&lpItem->BeginTime, pBeginTime, sizeof(SYSTEMTIME));
    CopyMemory ((LPBYTE)&lpItem->EndTime, pEndTime, sizeof(SYSTEMTIME));


    //
    // Add item to the link list
    //

    if (*lpList)
    {
        StringToGuid( lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            lpItem->pNext = *lpList;
            *lpList = lpItem;
        }
        else
        {
            lpTemp = *lpList;

            while (lpTemp)
            {
                if (!lpTemp->pNext)
                {
                    lpTemp->pNext = lpItem;
                    break;
                }
                lpTemp = lpTemp->pNext;
            }
        }
    }
    else
    {
        *lpList = lpItem;
    }


    //
    // Set the error flag if appropriate
    //

    if ((dwStatus != ERROR_SUCCESS) || (ulLoggingStatus == 2))
    {
        StringToGuid( lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            *bGPCoreError = TRUE;
        }
        else
        {
            *bCSEError =  TRUE;
        }
    }

    return TRUE;
}

//-------------------------------------------------------

void CRSOPCSELists::GetEventLogSources (IWbemServices * pNamespace,
                                             LPTSTR lpCSEGUID, LPTSTR lpComputerName,
                                             SYSTEMTIME *BeginTime, SYSTEMTIME *EndTime,
                                             LPSOURCEENTRY *lpSources)
{
    HRESULT hr;
    ULONG n;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = NULL;
    LPTSTR lpQuery;
    const TCHAR szBaseQuery [] = TEXT("SELECT * FROM RSOP_ExtensionEventSourceLink WHERE extensionStatus=\"RSOP_ExtensionStatus.extensionGuid=\\\"%s\\\"\"");
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject * pLink = NULL;
    IWbemClassObject * pEventSource = NULL;
    BSTR bstrEventSource = NULL;
    BSTR bstrEventLogName = NULL;
    BSTR bstrEventSourceName = NULL;
    ULONG ulNoChars;

    //
    // Build the query first
    //

    ulNoChars = lstrlen(szBaseQuery) + 50;
    lpQuery = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed  to allocate memory for query")));
        goto cleanup;
    }

    hr = StringCchPrintf (lpQuery, ulNoChars, szBaseQuery, lpCSEGUID);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed  to copy rsop query")));
        LocalFree (lpQuery);
        goto cleanup;
    }

    strQuery = SysAllocString(lpQuery);

    LocalFree (lpQuery);

    if (!strQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed  to allocate memory for query (2)")));
        goto cleanup;
    }


    //
    // Query for the RSOP_ExtensionEventSourceLink instances that match this CSE
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get 1 instance
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pLink, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }


        //
        // Get the eventSource reference
        //

        hr = GetParameterBSTR(pLink, TEXT("eventSource"), bstrEventSource);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event source reference with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the eventSource instance
        //

        hr = pNamespace->GetObject(
                          bstrEventSource,
                          WBEM_FLAG_RETURN_WBEM_COMPLETE,
                          NULL,
                          &pEventSource,
                          NULL);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: GetObject for event source of %s failed with 0x%x"),
                     bstrEventSource, hr));
            goto loopagain;
        }


        //
        // Get the eventLogSource property
        //

        hr = GetParameterBSTR(pEventSource, TEXT("eventLogSource"), bstrEventSourceName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event source name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the eventLogName property
        //

        hr = GetParameterBSTR(pEventSource, TEXT("eventLogName"), bstrEventLogName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetEventLogSources: Failed to get event log name with 0x%x"), hr));
            goto cleanup;
        }


        if (m_pEvents)
        {
            //
            // Add it to the list of sources
            //

            m_pEvents->AddSourceEntry (bstrEventLogName, bstrEventSourceName, lpSources);


            //
            // Initialize the event log database for this source if we are working
            // with a live query.  If this is archived data, the event log entries
            // will be reloaded from the saved console file.
            //

            if (!m_bViewIsArchivedData && !m_bNoQuery)
            {
                m_pEvents->QueryForEventLogEntries (lpComputerName,
                                                    bstrEventLogName, bstrEventSourceName,
                                                    0, BeginTime, EndTime);
            }
        }


        //
        // Clean up for next item
        //

        SysFreeString (bstrEventLogName);
        bstrEventLogName = NULL;

        SysFreeString (bstrEventSourceName);
        bstrEventSourceName = NULL;

        pEventSource->Release();
        pEventSource = NULL;

loopagain:
        SysFreeString (bstrEventSource);
        bstrEventSource = NULL;

        pLink->Release();
        pLink = NULL;
    }

cleanup:


    if (bstrEventSourceName)
    {
        SysFreeString (bstrEventSourceName);
    }

    if (bstrEventLogName)
    {
        SysFreeString (bstrEventLogName);
    }

    if (bstrEventSource)
    {
        SysFreeString (bstrEventSource);
    }

    if (pEventSource)
    {
        pEventSource->Release();
    }

    if (pLink)
    {
        pLink->Release();
    }

    if (pEnum)
    {
        pEnum->Release();
    }

    if (strQueryLanguage)
    {
        SysFreeString(strQueryLanguage);
    }

    if (strQuery)
    {
        SysFreeString(strQuery);
    }

}

//-------------------------------------------------------

void CRSOPCSELists::QueryRSoPPolicySettingStatusInstances (LPTSTR lpNamespace)
{
    HRESULT hr;
    ULONG n;
    IWbemClassObject * pStatus = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    BSTR strQueryLanguage = SysAllocString(TEXT("WQL"));
    BSTR strQuery = SysAllocString(TEXT("SELECT * FROM RSoP_PolicySettingStatus"));
    BSTR strNamespace = SysAllocString(lpNamespace);
    BSTR bstrEventSource = NULL;
    BSTR bstrEventLogName = NULL;
    DWORD dwEventID;
    BSTR bstrEventTime = NULL;
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    SYSTEMTIME EventTime, BeginTime, EndTime;
    XBStr xbstrWbemTime;
    FILETIME ft;
    ULARGE_INTEGER ulTime;


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *)&pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: CoCreateInstance failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Connect to the namespace
    //

    BSTR bstrNamespace = SysAllocString( lpNamespace );
    if ( bstrNamespace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    hr = pLocator->ConnectServer(bstrNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    SysFreeString( bstrNamespace );
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: ConnectServer failed with 0x%x"), hr));
        goto cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: CoSetProxyBlanket failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Query for the RSoP_PolicySettingStatus instances
    //

    hr = pNamespace->ExecQuery(strQueryLanguage,
                               strQuery,
                               WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                               NULL,
                               &pEnum);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: ExecQuery failed with 0x%x"), hr));
        goto cleanup;
    }


    //
    // Loop through the results
    //

    while (TRUE)
    {

        //
        // Get 1 instance
        //

        hr = pEnum->Next(WBEM_INFINITE, 1, &pStatus, &n);

        if (FAILED(hr) || (n == 0))
        {
            goto cleanup;
        }


        //
        // Get the event source name
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventSource"), bstrEventSource);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the event log name
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventLogName"), bstrEventLogName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the event ID
        //

        hr = GetParameter(pStatus, TEXT("eventID"), (ULONG)dwEventID);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get display name with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Get the EventTime in bstr format
        //

        hr = GetParameterBSTR(pStatus, TEXT("eventTime"), bstrEventTime);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: Failed to get event time with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Convert it to system time format
        //

        xbstrWbemTime = bstrEventTime;

        hr = WbemTimeToSystemTime(xbstrWbemTime, EventTime);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: WbemTimeToSystemTime failed with 0x%x"), hr));
            goto cleanup;
        }


        //
        // Take the event time minus 1 second to get the begin time
        //

        if (!SystemTimeToFileTime (&EventTime, &ft))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: SystemTimeToFileTime failed with %d"), GetLastError()));
            goto cleanup;
        }

        ulTime.LowPart = ft.dwLowDateTime;
        ulTime.HighPart = ft.dwHighDateTime;

        ulTime.QuadPart = ulTime.QuadPart - 10000000;  // 1 second

        ft.dwLowDateTime = ulTime.LowPart;
        ft.dwHighDateTime = ulTime.HighPart;

        if (!FileTimeToSystemTime (&ft, &BeginTime))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: FileTimeToSystemTime failed with %d"), GetLastError()));
            goto cleanup;
        }


        //
        // Take the event time plus 1 second to get the end time
        //

        if (!SystemTimeToFileTime (&EventTime, &ft))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: SystemTimeToFileTime failed with %d"), GetLastError()));
            goto cleanup;
        }

        ulTime.LowPart = ft.dwLowDateTime;
        ulTime.HighPart = ft.dwHighDateTime;

        ulTime.QuadPart = ulTime.QuadPart + 10000000;  // 1 second

        ft.dwLowDateTime = ulTime.LowPart;
        ft.dwHighDateTime = ulTime.HighPart;

        if (!FileTimeToSystemTime (&ft, &EndTime))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::QueryRSoPPolicySettingStatusInstances: FileTimeToSystemTime failed with %d"), GetLastError()));
            goto cleanup;
        }


        //
        // Get the event log source information
        //

        if (m_pEvents && !m_bNoQuery)
        {
            m_pEvents->QueryForEventLogEntries( m_szTargetMachine,
                                                bstrEventLogName, bstrEventSource, dwEventID,
                                                &BeginTime, &EndTime);
        }

        //
        // Prepare for next iteration
        //

        SysFreeString (bstrEventSource);
        bstrEventSource = NULL;

        SysFreeString (bstrEventLogName);
        bstrEventLogName = NULL;

        SysFreeString (bstrEventTime);
        bstrEventTime = NULL;

        pStatus->Release();
        pStatus = NULL;
    }

cleanup:

    if (bstrEventSource)
    {
        SysFreeString (bstrEventSource);
    }
    if (bstrEventLogName)
    {
        SysFreeString (bstrEventLogName);
    }
    if (bstrEventTime)
    {
        SysFreeString (bstrEventTime);
    }
    if (pEnum)
    {
        pEnum->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    SysFreeString(strQueryLanguage);
    SysFreeString(strQuery);
    SysFreeString(strNamespace);
}


//---------------------------------------------------------------------------
//  CRSOPComponentData class
//

//-------------------------------------------------------
//  Static member variable declarations
//

unsigned int CRSOPCMenu::m_cfDSObjectName  = RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);

//-------------------------------------------------------
//  Constructors/destructor
//

CRSOPComponentData::CRSOPComponentData()
    : m_CSELists( m_bViewIsArchivedData )
{
    InterlockedIncrement(&g_cRefThisDll);

    m_bPostXPBuild = FALSE; // Assume this is not post XP until verified as otherwise
    OSVERSIONINFOEX osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx ((OSVERSIONINFO*) &osvi) )
    {
        // Windows XP was version 5.1, while .Net Server is version 5.2. So, we enable the
        //  additional features for any version past XP, i.e. >= 5.2
        m_bPostXPBuild = (osvi.dwMajorVersion >= 5) && (osvi.dwMinorVersion >= 2) && (VER_NT_WORKSTATION != osvi.wProductType);
    }

    m_cRef = 1;
    m_hwndFrame = NULL;
    m_bOverride = FALSE;
    m_bDirty = FALSE;
    m_bRefocusInit = FALSE;
    m_bArchiveData = FALSE;
    m_bViewIsArchivedData = FALSE;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hMachine = NULL;
    m_hUser = NULL;
    m_bRootExpanded = FALSE;

    m_szDisplayName = NULL;
    m_bInitialized = FALSE;

    m_pRSOPQuery = NULL;
    m_pRSOPQueryResults = NULL;

    m_dwLoadFlags = RSOP_NOMSC;

    m_bNamespaceSpecified = FALSE;

    m_dwLoadFlags = RSOP_NOMSC;

    m_bGetExtendedErrorInfo = TRUE;
    
    m_hRichEdit = LoadLibrary (TEXT("riched20.dll"));

    m_BigBoldFont = NULL;
    m_BoldFont = NULL;


}

//-------------------------------------------------------

CRSOPComponentData::~CRSOPComponentData()
{
    if (m_szDisplayName)
    {
        delete [] m_szDisplayName;
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_hRichEdit)
    {
        FreeLibrary (m_hRichEdit);
    }

    if ( m_BoldFont )
    {
        DeleteObject(m_BoldFont); m_BoldFont = NULL;
    }

    if ( m_BoldFont )
    {
        DeleteObject(m_BigBoldFont); m_BigBoldFont = NULL;
    }


    InterlockedDecrement(&g_cRefThisDll);
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (IUnknown)

HRESULT CRSOPComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

//-------------------------------------------------------

ULONG CRSOPComponentData::AddRef (void)
{
    return ++m_cRef;
}

//-------------------------------------------------------

ULONG CRSOPComponentData::Release (void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (IComponentData)

STDMETHODIMP CRSOPComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    HBITMAP hbmp32x32;
    LPIMAGELIST lpScopeImage;


    // QI for IConsoleNameSpace

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for IConsoleNameSpace2.")));
        return hr;
    }

    // QI for IConsole

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);

    // Query for the scope imagelist interface

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));
    hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                                    reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                    0, RGB(255, 0, 255));

    lpScopeImage->Release();


    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CRSOPSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::CreateComponent: Entering.")));

    // Initialize

    *ppComponent = NULL;

    // Create the snapin view

    pSnapIn = new CRSOPSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateComponent: Failed to create CRSOPSnapIn.")));
        return E_OUTOFMEMORY;
    }

    // QI for IComponent

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                                 LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CRSOPDataObject *pDataObject;
    LPRSOPDATAOBJECT pRSOPDataObject;

    // Create a new DataObject

    pDataObject = new CRSOPDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;

    // QI for the private RSOPDataObject interface so we can set the cookie
    // and type information.

    hr = pDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return(hr);
    }

    pRSOPDataObject->SetType(type);
    pRSOPDataObject->SetCookie(cookie);
    pRSOPDataObject->Release();

    // QI for a normal IDataObject to return.

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::Destroy(VOID)
{
    HRESULT hr = S_OK;

    if (m_bInitialized)
    {
        if (m_bViewIsArchivedData)
        {
            hr = DeleteArchivedRSOPNamespace();
        }
        else
        {
            if (!m_bNamespaceSpecified) {
                FreeRSOPQueryResults( m_pRSOPQuery, m_pRSOPQueryResults );
            }
            else {
                // freeing results without deleting the namespace
                if (m_pRSOPQueryResults) {
                    if (m_pRSOPQueryResults->szWMINameSpace) {
                        LocalFree( m_pRSOPQueryResults->szWMINameSpace );
                        m_pRSOPQueryResults->szWMINameSpace = NULL;
                    }

                    LocalFree( m_pRSOPQueryResults );
                    m_pRSOPQueryResults = NULL;
                }
                m_bNamespaceSpecified = FALSE;
            }

            FreeRSOPQuery(m_pRSOPQuery);
            m_pRSOPQuery = NULL;
        }

        if (SUCCEEDED(hr))
        {
            m_bInitialized = FALSE;
        }
    }


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Destroy: Failed to delete namespace with 0x%x"), hr ));
    }

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch (event)
    {
    case MMCN_EXPAND:
        if (arg == TRUE)
        {
            HSCOPEITEM hExpandingItem = (HSCOPEITEM)param;
            hr = EnumerateScopePane( hExpandingItem );
            if ( hExpandingItem == m_hRoot )
            {
                m_bRootExpanded = TRUE;
            }
        }
        break;

    case MMCN_PRELOAD:
        if (!m_bRefocusInit)
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Notify:  Received MMCN_PRELOAD event.")));
            m_bRefocusInit = TRUE;

            m_hRoot = (HSCOPEITEM)arg;

            hr = SetRootNode();
            if ( hr != S_OK )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Notify: Setting the root scope item failed with 0x%x"), hr));
            }
        }
        break;

    default:
        break;
    }

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
    {
        return E_POINTER;
    }

    if ( ((DWORD) pItem->lParam == 0) && (m_szDisplayName != NULL) )
    {
        pItem->displayname = m_szDisplayName;
        return S_OK;
    }

    // Find item
    for (dwIndex = 0; dwIndex < g_dwNameSpaceItems; dwIndex++)
    {
        if ( g_RsopNameSpace[dwIndex].dwID == (DWORD) pItem->lParam )
        {
            break;
        }
    }

    if (dwIndex == g_dwNameSpaceItems)
    {
        pItem->displayname = NULL;
    }
    else
    {
        pItem->displayname = g_RsopNameSpace[dwIndex].szDisplayName;
    }

    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObjectA, pRSOPDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private RSOPDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IRSOPDataObject,
                                             (LPVOID *)&pRSOPDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IRSOPDataObject,
                                             (LPVOID *)&pRSOPDataObjectB)))
    {
        pRSOPDataObjectA->Release();
        return S_FALSE;
    }

    pRSOPDataObjectA->GetCookie(&cookie1);
    pRSOPDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pRSOPDataObjectA->Release();
    pRSOPDataObjectB->Release();

    return hr;
}

//-------------------------------------------------------
// IComponentData helper methods

HRESULT CRSOPComponentData::SetRootNode()
{
    SCOPEDATAITEM item;

    ZeroMemory (&item, sizeof(SCOPEDATAITEM));
    item.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_CHILDREN;
    item.displayname = MMC_CALLBACK;

    if (m_bInitialized)
    {
        item.cChildren = 1;
        
        if (m_CSELists.GetUserGPCoreError() || m_CSELists.GetComputerGPCoreError())
        {
            item.nImage = 3;
            item.nOpenImage = 3;
        }
        else if (m_CSELists.GetUserCSEError() || m_CSELists.GetComputerCSEError()
                    || m_pRSOPQueryResults->bUserDeniedAccess
                    || m_pRSOPQueryResults->bComputerDeniedAccess )
        {
            item.nImage = 11;
            item.nOpenImage = 11;
        }
        else
        {
            item.nImage = 2;
            item.nOpenImage = 2;
        }
    }
    else
    {
        item.cChildren = 0;
        item.nImage = 2;
        item.nOpenImage = 2;
    }

    item.ID = m_hRoot;

    return m_pScope->SetItem (&item);
}

//-------------------------------------------------------
HRESULT CRSOPComponentData::EnumerateScopePane ( HSCOPEITEM hParent )
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if ( m_hRoot == NULL )
    {
        m_hRoot = hParent;

        if (!m_bRefocusInit)
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EnumerateScopePane:  Resetting the root node")));
            m_bRefocusInit = TRUE;

            hr = SetRootNode();
            if ( hr != S_OK )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EnumerateScopePane: Setting the root scope item failed with 0x%x"), hr));
                return E_FAIL;
            }
        }
    }


    if (!m_bInitialized)
    {
        return S_OK;
    }


    if (m_hRoot == hParent)
    {
        dwIndex = 0;
    }
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    // RM: Make sure that parent item is expanded before inserting any new scope items
    m_pScope->Expand( hParent );

    for (i = 0; i < g_dwNameSpaceItems; i++)
    {
        if (g_RsopNameSpace[i].dwParent == dwIndex)
        {
            BOOL bAdd = TRUE;

            if (g_RsopNameSpace[i].dwID == 1)
            {
                if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
                {
                    if ( (m_pRSOPQuery->pComputer->szName == NULL) && (m_pRSOPQuery->pComputer->szSOM == NULL) )
                    {
                        bAdd = FALSE;
                    }
                }
                else
                {
                    if ( m_pRSOPQuery->szComputerName == NULL )
                    {
                        bAdd = FALSE;
                    }
                }
                
                if ( (m_pRSOPQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
                {
                    bAdd = FALSE;
                }

                if ( m_pRSOPQueryResults->bNoComputerPolicyData )
                {
                    bAdd = FALSE;
                }

                if ( m_pRSOPQueryResults->bComputerDeniedAccess )
                {
                    bAdd = FALSE;
                }
            }

            if (g_RsopNameSpace[i].dwID == 2)
            {
                if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
                {
                    if ( m_pRSOPQuery->LoopbackMode == RSOP_LOOPBACK_NONE )
                    {
                        if ( (m_pRSOPQuery->pUser->szName == NULL) && (m_pRSOPQuery->pUser->szSOM == NULL) )
                        {
                            bAdd = FALSE;
                        }
                        else if ( (m_pRSOPQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY )
                        {
                            bAdd = FALSE;
                        }
                    }
                }
                else // RSOP_LOGGING_MODE
                {
                    if ( (m_pRSOPQuery->szUserSid == NULL) && (m_pRSOPQuery->szUserName == NULL) )
                    {
                        bAdd = FALSE;
                    }
                    else if ( (m_pRSOPQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY )
                    {
                        bAdd = FALSE;
                    }
                }

                if ( m_pRSOPQueryResults->bNoUserPolicyData)
                {
                    bAdd = FALSE;
                }

                if ( m_pRSOPQueryResults->bUserDeniedAccess )
                {
                    bAdd = FALSE;
                }
            }

            if (bAdd)
            {
                INT iIcon, iOpenIcon;

                iIcon = g_RsopNameSpace[i].iIcon;
                iOpenIcon = g_RsopNameSpace[i].iOpenIcon;

                if ((i == 1) && m_CSELists.GetComputerGPCoreError())
                {
                    iIcon = 12;
                    iOpenIcon = 12;
                }

                else if ((i == 1) && (ComputerCSEErrorExists() || ComputerGPCoreWarningExists()))
                {
                    iIcon = 14;
                    iOpenIcon = 14;
                }
                else if ((i == 2) && UserGPCoreErrorExists())
                {
                    iIcon = 13;
                    iOpenIcon = 13;
                }
                else if ((i == 2) && (UserCSEErrorExists() || UserGPCoreWarningExists()))
                {
                    iIcon = 15;
                    iOpenIcon = 15;
                }

                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = iIcon;
                item.nOpenImage = iOpenIcon;
                item.nState = 0;
                item.cChildren = g_RsopNameSpace[i].cChildren;
                item.lParam = g_RsopNameSpace[i].dwID;
                item.relativeID =  hParent;

                if (SUCCEEDED(m_pScope->InsertItem (&item)))
                {
                    if (i == 1)
                    {
                        m_hMachine = item.ID;
                    }
                    else if (i == 2)
                    {
                        m_hUser = item.ID;
                    }
                }
            }
        }
    }

    return S_OK;
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (IExtendPropertySheet2)

STDMETHODIMP CRSOPComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                                     LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr = E_FAIL;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;

    // Set up fonts
    hr = SetupFonts();
    if (FAILED(hr))
    {
        return hr;
    }

    // Now check which property page to show
    BOOL fRoot, fMachine, fUser;
    hr = IsNode(lpDataObject, 0); // check for root node
    fRoot = (S_OK == hr);
    hr = IsNode(lpDataObject, 1); // check for machine node
    fMachine = (S_OK == hr);
    hr = IsNode(lpDataObject, 2); // check for user
    fUser = (S_OK == hr);

    hr = S_OK;
    if (fMachine || fUser)
    {
        // Create the GPO property sheet

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GPOLIST);
        psp.pfnDlgProc = fMachine ? RSOPGPOListMachineProc : RSOPGPOListUserProc;
        psp.lParam = (LPARAM) this;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        hr = lpProvider->AddPage(hPage);

        // Create the Error information property sheet

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ERRORS);
        psp.pfnDlgProc = fMachine ? RSOPErrorsMachineProc : RSOPErrorsUserProc;
        psp.lParam = (LPARAM) this;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        hr = lpProvider->AddPage(hPage);

    }

    if (fRoot)
    {
        // Create the GPO property sheet

        psp.dwSize = sizeof(PROPSHEETPAGE);
        psp.dwFlags = 0;
        psp.hInstance = g_hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_QUERY);
        psp.pfnDlgProc = QueryDlgProc;
        psp.lParam = (LPARAM) this;

        hPage = CreatePropertySheetPage(&psp);

        if (!hPage)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreatePropertyPages: Failed to create property sheet page with %d."),
                      GetLastError()));
            return E_FAIL;
        }

        hr = lpProvider->AddPage(hPage);
    }

    return hr;
    
    // RM: Removed! return SetupPropertyPages(RSOP_NOMSC, lpProvider, handle, lpDataObject);
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    HRESULT hr;

    if ( !m_bInitialized )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = IsSnapInManager(lpDataObject);

        if (hr != S_OK)
        {
            hr = IsNode(lpDataObject, 0); // check for root
            if (S_OK == hr)
            {
                return hr;
            }
            hr = IsNode(lpDataObject, 1); // check for machine
            if (S_OK == hr)
            {
                return hr;
            }
            hr = IsNode(lpDataObject, 2); // check for user
            if (S_OK == hr)
            {
                return hr;
            }
            hr = E_FAIL;
        }
    }

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::GetWatermarks(LPDATAOBJECT lpIDataObject,
                                               HBITMAP* lphWatermark,
                                               HBITMAP* lphHeader,
                                               HPALETTE* lphPalette,
                                               BOOL* pbStretch)
{
    *lphPalette = NULL;
    *lphHeader = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_HEADER));
    *lphWatermark = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_WIZARD));;
    *pbStretch = TRUE;

    return S_OK;
}


//-------------------------------------------------------
// IExtendPropertySheet2 helper methods

HRESULT CRSOPComponentData::IsSnapInManager (LPDATAOBJECT lpDataObject)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObject;
    DATA_OBJECT_TYPES type;


    // We can determine if this is a RSOP DataObject by trying to
    // QI for the private IRSOPDataObject interface.  If found,
    // it belongs to us.

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IRSOPDataObject,
                                               (LPVOID *)&pRSOPDataObject)))
    {
        // This is a GPO object.  Now see if is a scope pane
        // data object.  We only want to display the property
        // sheet for the scope pane.

        if (SUCCEEDED(pRSOPDataObject->GetType(&type)))
        {
            if (type == CCT_SNAPIN_MANAGER)
            {
                hr = S_OK;
            }
        }
        pRSOPDataObject->Release();
    }

    return(hr);
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::IsNode (LPDATAOBJECT lpDataObject, MMC_COOKIE cookie)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObject;
    DATA_OBJECT_TYPES type;
    MMC_COOKIE testcookie;


    // This is a check for the special case where the Message OCX result pane
    //  is active and the snapin is not yet initialized. So, if the query is
    //  to check whether this is the root node, we can return TRUE, else return
    //  FALSE.
    if ( IS_SPECIAL_DATAOBJECT(lpDataObject) )
    {
        ASSERT( !m_bInitialized );

        if ( cookie == 0 )
        {
            hr = S_OK;
        }
    }
    // We can determine if this is a GPO DataObject by trying to
    // QI for the private IGPEDataObject interface.  If found,
    // it belongs to us.
    else if (SUCCEEDED(lpDataObject->QueryInterface(IID_IRSOPDataObject,
                 (LPVOID *)&pRSOPDataObject)))
    {

        pRSOPDataObject->GetType(&type);
        pRSOPDataObject->GetCookie(&testcookie);

        if ((type == CCT_SCOPE) && (cookie == testcookie))
        {
            hr = S_OK;
        }

        pRSOPDataObject->Release();
    }

    return (hr);
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (IExtendContextMenu)

STDMETHODIMP CRSOPComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                              LPCONTEXTMENUCALLBACK pCallback,
                                              LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;


    if (IsNode(piDataObject, 0) == S_OK)
    {
        if ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) == CCM_INSERTIONALLOWED_TOP)
        {
            // Add "Rerun query..." menu option
            if ( m_bInitialized )
            {
                // Changing the query is only supported in post XP builds
                if ( !m_bNamespaceSpecified && m_bPostXPBuild )
                {
                    LoadString (g_hInstance, IDS_RSOP_CHANGEQUERY, szMenuItem, 100);
                    LoadString (g_hInstance, IDS_RSOP_CHANGEQUERYDESC, szDescription, 250);

                    item.strName = szMenuItem;
                    item.strStatusBarText = szDescription;
                    item.lCommandID = IDM_GENERATE_RSOP;
                    item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                    item.fFlags = 0;
                    item.fSpecialFlags = 0;

                    hr = pCallback->AddItem(&item);
                }
            }
            else
            {
                LoadString (g_hInstance, IDS_RSOP_RUNQUERY, szMenuItem, 100);
                LoadString (g_hInstance, IDS_RSOP_RUNQUERYDESC, szDescription, 250);
                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_GENERATE_RSOP;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                item.fFlags = 0;
                item.fSpecialFlags = 0;

                hr = pCallback->AddItem(&item);

            }

            // Refreshing the query is only supported in post XP builds
            if ( m_bInitialized && (!m_bNamespaceSpecified) && m_bPostXPBuild )
            {
                LoadString (g_hInstance, IDS_RSOP_REFRESHQUERY, szMenuItem, 100);
                LoadString (g_hInstance, IDS_RSOP_REFRESHQUERYDESC, szDescription, 250);

                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_REFRESH_RSOP;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
                item.fFlags = 0;
                item.fSpecialFlags = 0;

                hr = pCallback->AddItem(&item);
            }
        }

        if ( (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) == CCM_INSERTIONALLOWED_VIEW)
        {
            // Add "Archive data" menu option
            LoadString (g_hInstance, IDS_ARCHIVEDATA, szMenuItem, 100);
            LoadString (g_hInstance, IDS_ARCHIVEDATADESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_ARCHIVEDATA;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            item.fFlags = m_bArchiveData ? MFS_CHECKED : 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }


    return(hr);
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{
    TCHAR szCaption[100];
    TCHAR szMessage[300];
    INT iRet;

    switch (lCommandID)
    {
    case IDM_ARCHIVEDATA:
        {
            m_bArchiveData = !m_bArchiveData;
            SetDirty();
        }
        break;

    case IDM_GENERATE_RSOP:
        {
            HRESULT hr = InitializeRSOP( TRUE );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Command: Failed to run RSOP query with 0x%x"), hr ));
            }
        }
        break;

    case IDM_REFRESH_RSOP:
        {
            if ( m_bInitialized )
            {
                HRESULT hr = InitializeRSOP( FALSE );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Command: Failed to run RSOP query with 0x%x"), hr ));
                }
            }
        }
        break;
        
    }

    return S_OK;
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (IPersistStreamInit)

STDMETHODIMP CRSOPComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    *pClassID = CLSID_RSOPSnapIn;

    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::IsDirty(VOID)
{
    return ThisIsDirty() ? S_OK : S_FALSE;
}

//-------------------------------------------------------
//-------------------------------------------------------
HRESULT 
ExtractSecurityGroups(
                      IN   IWbemClassObject        *pSessionInst, 
                      IN   LPRSOP_QUERY_TARGET      pRsopQueryTarget)
{
    LPWSTR      *szSecGroupSids;
    HRESULT      hr = S_OK;

    // get the secgrps of the Comp, if available
    GetParameter(pSessionInst, 
                 L"SecurityGroups", 
                 szSecGroupSids, 
                 (pRsopQueryTarget->dwSecurityGroupCount));


    pRsopQueryTarget->adwSecurityGroupsAttr = (DWORD *)LocalAlloc(LPTR, 
                                                                 sizeof(DWORD)*((pRsopQueryTarget->dwSecurityGroupCount)));

    if (!pRsopQueryTarget->adwSecurityGroupsAttr)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pRsopQueryTarget->aszSecurityGroups = (LPWSTR *)LocalAlloc(LPTR, 
                                                                 sizeof(LPWSTR)*((pRsopQueryTarget->dwSecurityGroupCount)));
    if (!pRsopQueryTarget->aszSecurityGroups)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }


    for (DWORD i = 0; i < (pRsopQueryTarget->dwSecurityGroupCount); i++)
    {
        (pRsopQueryTarget->adwSecurityGroupsAttr)[i] = 0;
        if (!GetUserNameFromStringSid(szSecGroupSids[i], &((pRsopQueryTarget->aszSecurityGroups)[i]))) 
        {
            ULONG ulNoChars = lstrlen(szSecGroupSids[i])+1;

            (pRsopQueryTarget->aszSecurityGroups)[i] = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
            if (!((pRsopQueryTarget->aszSecurityGroups)[i]))
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = StringCchCopy((pRsopQueryTarget->aszSecurityGroups)[i], ulNoChars, szSecGroupSids[i]);
            ASSERT(SUCCEEDED(hr));
        }
    }


    hr = S_OK;

Cleanup:      
    if (szSecGroupSids)
    {
        for (DWORD i = 0; i < (pRsopQueryTarget->dwSecurityGroupCount); i++)
        {
            if (szSecGroupSids[i])
            {
                LocalFree(szSecGroupSids[i]);
            }
        }

        LocalFree(szSecGroupSids);
    }


    if (FAILED(hr))
    {
        if (pRsopQueryTarget->adwSecurityGroupsAttr)
        {
            LocalFree(pRsopQueryTarget->adwSecurityGroupsAttr);
            pRsopQueryTarget->adwSecurityGroupsAttr = NULL;
        }

        if (pRsopQueryTarget->aszSecurityGroups)
        {
            for (DWORD i = 0; i < (pRsopQueryTarget->dwSecurityGroupCount); i++)
            {
                if ((pRsopQueryTarget->aszSecurityGroups)[i])
                {
                    LocalFree((pRsopQueryTarget->aszSecurityGroups)[i]);
                }
            }

            LocalFree(pRsopQueryTarget->aszSecurityGroups);
            pRsopQueryTarget->aszSecurityGroups = NULL;
            pRsopQueryTarget->dwSecurityGroupCount = 0;
        }
    }

    return hr;
}
//-------------------------------------------------------


//-------------------------------------------------------

#define USER_SUBNAMESPACE   L"User"
#define COMP_SUBNAMESPACE   L"Computer"
#define RSOP_SESSION_PATH   L"RSOP_Session.id=\"Session1\""

 
HRESULT 
CRSOPComponentData::EvaluateParameters(
                                      IN   LPWSTR                  szNamespace, 
                                      IN   LPWSTR                  szTarget)

/*++

Routine Description:

    Given the namespace name and the DC that is passed in as a commandline
    argument, this function will compute the effective parameters that were
    used to get the result. 

Arguments:

    [in]    szNamespace         - Namespace which needs to be read to get the parameters
    
    [in]    szTarget            - This can be DC. (in case of planning mode there is currently no way to 
                                  to determine which dc was used to generate the planning mode 
                                  data from the namespace. So we need a separate parameter)
                                  
                                - or logging mode target computer. (in case of logging mode there is 
                                  currently no way to to determine which machine was used to generate
                                  the logging mode data. So we need a separate parameter)
                                  
    [out]   m_pRsopQuery         - Returns an allocated RsopQuery that corresponds to the parameters
                                  for this rsop namespace
                                  
    [out]   m_pRsopQueryResults  - Returns the query result that corresponds to the result elements
                                                                        
                                    
Return Value:

    S_OK on success.
    
    On failure the corresponding error code will be returned.
    Any API calls that are made in this function might fail and these error
    codes will be returned directly.

    Note: 
    This will just return parameters to the closest approximation.
    ie. this will return the minimal sets of parameters that would get this result.
    
    for example: if wmi filters A, B & C were specified in a planning mode query and
    there were gpos with filters A & B, these will return just A & B (and not C)   
    
    We will always return security groups whether or not the user had specified these in
    the original query.
    
    We will return the parent som for the user/computer in all cases
    
    
--*/
{
    HRESULT                 hr                      = S_OK;     
    IWbemLocator           *pLocator                = NULL;     
    IWbemServices          *pUserNamespace          = NULL;     
    IWbemServices          *pCompNamespace          = NULL;     
    LPWSTR                  szUserNamespace         = NULL;     
    LPWSTR                  szCompNamespace         = NULL;     
    LPWSTR                  lpEnd                   = NULL;     
    BSTR                    bstrNamespace           = NULL;     
    BSTR                    bstrSessionInstPath     = NULL;     
    IWbemClassObject       *pUserSessionInst        = NULL;     
    IWbemClassObject       *pCompSessionInst        = NULL;     
    BOOL                    bPlanning               = TRUE;


    if (!szTarget)
    {
        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Target name was not specified") ) );
        return E_INVALIDARG;
    }

    DebugMsg( (DM_VERBOSE, TEXT("CRSOPComponentData::EvaluateParameters namespace=<%s>, target=<%s>"), szNamespace, szTarget) );

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    bstrSessionInstPath = SysAllocString(RSOP_SESSION_PATH);

    if (!bstrSessionInstPath)
    {
        goto Cleanup;
    }

    // allocate memory for the original namespace followed by "\" and computer or user
    ULONG ulNoChars = lstrlen(szNamespace) + lstrlen(USER_SUBNAMESPACE) + 5;

    szUserNamespace = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
    if (!szUserNamespace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = StringCchCopy (szUserNamespace, ulNoChars, szNamespace);
    ASSERT(SUCCEEDED(hr));

    lpEnd = CheckSlash(szUserNamespace);

    //
    // first the user namespace
    //

    hr = StringCchCat(szUserNamespace, ulNoChars, USER_SUBNAMESPACE);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Could not copy user namespace with 0x%x"), hr));
        goto Cleanup;
    }

    bstrNamespace = SysAllocString(szUserNamespace);

    if (!bstrNamespace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pLocator->ConnectServer(bstrNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pUserNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to connect to user namespace with 0x%x"), hr));
        goto Cleanup;
    }


    hr = pUserNamespace->GetObject(bstrSessionInstPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                                   NULL, 
                                   &pUserSessionInst, 
                                   NULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get session obj for user namespace with 0x%x"), hr));
        goto Cleanup;
    }

    //
    // Now computer
    //

    if (bstrNamespace)
    {
        SysFreeString(bstrNamespace);
        bstrNamespace = NULL;
    }

    // allocate memory for the original namespace followed by "\" and computer or user
    ulNoChars = lstrlen(szNamespace) + lstrlen(COMP_SUBNAMESPACE) + 5;

    szCompNamespace = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
    if (!szCompNamespace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = StringCchCopy (szCompNamespace, ulNoChars, szNamespace);
    ASSERT(SUCCEEDED(hr));

    lpEnd = CheckSlash(szCompNamespace);

    //
    // now the Comp namespace
    //

    hr = StringCchCat(szCompNamespace, ulNoChars, COMP_SUBNAMESPACE);
    ASSERT(SUCCEEDED(hr));

    bstrNamespace = SysAllocString(szCompNamespace);

    if (!bstrNamespace)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pLocator->ConnectServer(bstrNamespace,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pCompNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to connect to computer namespace with 0x%x"), hr));
        goto Cleanup;
    }


    hr = pCompNamespace->GetObject(bstrSessionInstPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE, 
                                   NULL, 
                                   &pCompSessionInst, 
                                   NULL);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get session obj for computer namespace with 0x%x"), hr));
        goto Cleanup;
    }

    //
    // now check whether we have planning mode flag in either user/computer
    // if it is not in either then we can assume it to be in logging mode
    // otherwise we will assume it to be in planning mode
    //


    ULONG   ulUserFlags;
    ULONG   ulCompFlags;

    // Get the flags parameter for user
    hr = GetParameter(pUserSessionInst, TEXT("flags"), ulUserFlags);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get flags param with 0x%x"), hr));
        goto Cleanup;
    }

    // Get the flags parameter for computer
    hr = GetParameter(pCompSessionInst, TEXT("flags"), ulCompFlags);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get flags param with 0x%x"), hr));
        goto Cleanup;
    }

    if ((ulUserFlags & FLAG_PLANNING_MODE) || (ulCompFlags & FLAG_PLANNING_MODE))
    {
        bPlanning = TRUE;
        if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_PLANNING_MODE ) )
        {
            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to change query type") ) );
            hr = E_FAIL;
            goto Cleanup;
        }
    }
    else
    {
        bPlanning = FALSE;
        if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_LOGGING_MODE ) )
        {
            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to change query type") ) );
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // rsop query results
    m_pRSOPQueryResults = (LPRSOP_QUERY_RESULTS)LocalAlloc( LPTR, sizeof(RSOP_QUERY_RESULTS) );
    if ( m_pRSOPQueryResults == NULL )
    {
        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to create RSOP_QUERY_RESULTS.")) );
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ulNoChars = 1+lstrlen(szNamespace);
    m_pRSOPQueryResults->szWMINameSpace = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
    if (!(m_pRSOPQueryResults->szWMINameSpace))
    {
        hr = E_OUTOFMEMORY;
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to allocate memory for namespace with 0x%x"), hr));
        goto Cleanup;
    }

    hr = StringCchCopy(m_pRSOPQueryResults->szWMINameSpace, ulNoChars, szNamespace);
    ASSERT(SUCCEEDED(hr));

    m_pRSOPQuery->dwFlags = RSOP_NO_WELCOME;
    m_pRSOPQuery->UIMode = RSOP_UI_NONE;

    if (bPlanning)
    {
        ULONG               ulFlags         = 0;
        IWbemClassObject   *pSessionInst    = NULL;
        BOOL                bUserSpecified  = FALSE;
        BOOL                bCompSpecified  = FALSE;

        if (ulUserFlags & FLAG_PLANNING_MODE)
        {

            if (ulUserFlags & FLAG_LOOPBACK_MERGE)
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_MERGE;
            }
            else if (ulUserFlags & FLAG_LOOPBACK_REPLACE)
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_REPLACE;
            }
            else
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
            }

            //
            // User has data specified. so we will use user to update information
            //

            ulFlags = ulUserFlags;
            pSessionInst = pUserSessionInst;
            bUserSpecified = TRUE;
        }
        else
        {
            m_pRSOPQuery->dwFlags |= RSOP_NO_USER_POLICY;
            m_pRSOPQueryResults->bNoUserPolicyData = TRUE;
        }

        if (ulCompFlags & FLAG_PLANNING_MODE)
        {

            //
            // Comp has data specified. so we will use comp to update all global information
            //

            ulFlags = ulCompFlags;
            pSessionInst = pCompSessionInst;
            bCompSpecified = TRUE;
        }
        else
        {
            m_pRSOPQuery->dwFlags |= RSOP_NO_COMPUTER_POLICY;
            m_pRSOPQueryResults->bNoComputerPolicyData = TRUE;
        }


        // slowlink value
        hr = GetParameter(pSessionInst, TEXT("slowLink"), m_pRSOPQuery->bSlowNetworkConnection);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get slowlink param with 0x%x"), hr));
            goto Cleanup;
        }

        // site value. we should ignore the error
        GetParameter(pSessionInst, TEXT("Site"), m_pRSOPQuery->szSite, TRUE);

        // set the dc as appropriate
        if (szTarget)
        {
            ulNoChars = 1+lstrlen(szTarget);
            m_pRSOPQuery->szDomainController = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
            if (!(m_pRSOPQuery->szDomainController))
            {
                hr = E_OUTOFMEMORY;
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to allocate memory for dc with 0x%x"), hr));
                goto Cleanup;
            }

            hr = StringCchCopy (m_pRSOPQuery->szDomainController, ulNoChars, szTarget);
            ASSERT(SUCCEEDED(hr));
        }

        if (bUserSpecified)
        {
            // get the name of the user, if available
            hr = GetParameter(pUserSessionInst, L"targetName", (m_pRSOPQuery->pUser->szName), TRUE);
            if ( SUCCEEDED(hr) )
            {
                // check for an empty string, since this will mean that only a SOM was specified and the
                //  name has to be NULL.
                if ( (m_pRSOPQuery->pUser->szName != NULL) && (m_pRSOPQuery->pUser->szName[0] == TEXT('\0')) )
                {
                    LocalFree( m_pRSOPQuery->pUser->szName );
                    m_pRSOPQuery->pUser->szName = NULL;
                }
            }

            // get the som
            hr = GetParameter(pUserSessionInst, L"SOM", (m_pRSOPQuery->pUser->szSOM), TRUE);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get som param with 0x%x"), hr));
                goto Cleanup;
            }
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EvaluateParameters: SOM = %s"), m_pRSOPQuery->pUser->szSOM ? m_pRSOPQuery->pUser->szSOM : TEXT("<NULL>")));

            if (ulUserFlags & FLAG_ASSUME_USER_WQLFILTER_TRUE)
            {
                (m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue) = TRUE;
            }
            else
            {
                (m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue) = FALSE;
            }

            // get the secgrps of the user, if available
            hr = ExtractSecurityGroups(pUserSessionInst, m_pRSOPQuery->pUser);
            if (FAILED(hr))
            {
                goto Cleanup;
            }

            // get applicable wmi filters

            if (!(m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue))
            {
                hr = ExtractWQLFilters(szUserNamespace, 
                                       &(m_pRSOPQuery->pUser->dwWQLFilterCount),
                                       &(m_pRSOPQuery->pUser->aszWQLFilterNames),
                                       &(m_pRSOPQuery->pUser->aszWQLFilters), 
                                       TRUE);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get Extract WMI filter param with 0x%x"), hr));
                    goto Cleanup;
                }
            }
        }

        if (bCompSpecified)
        {
            // get the name of the Comp, if available
            hr = GetParameter(pCompSessionInst, L"targetName", (m_pRSOPQuery->pComputer->szName), TRUE);
            if ( SUCCEEDED(hr) )
            {
                // check for an empty string, since this will mean that only a SOM was specified and the
                //  name has to be NULL.
                if ( (m_pRSOPQuery->pComputer->szName != NULL) && (m_pRSOPQuery->pComputer->szName[0] == TEXT('\0')) )
                {
                    LocalFree( m_pRSOPQuery->pComputer->szName );
                    m_pRSOPQuery->pComputer->szName = NULL;
                }
            }

            // get the som
            hr = GetParameter(pCompSessionInst, L"SOM", (m_pRSOPQuery->pComputer->szSOM), TRUE);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get som param with 0x%x"), hr));
                goto Cleanup;
            }

            if (ulCompFlags & FLAG_ASSUME_COMP_WQLFILTER_TRUE)
            {
                (m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue) = TRUE;
            }
            else
            {
                (m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue) = FALSE;
            }

            hr = ExtractSecurityGroups(pCompSessionInst, m_pRSOPQuery->pComputer);
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to extract security group param for comp with 0x%x"), hr));
            }

            // get applicable wmi filters

            if (!(m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue))
            {
                hr = ExtractWQLFilters(szCompNamespace, 
                                       &(m_pRSOPQuery->pComputer->dwWQLFilterCount),
                                       &(m_pRSOPQuery->pComputer->aszWQLFilterNames),
                                       &(m_pRSOPQuery->pComputer->aszWQLFilters), 
                                       TRUE);
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to get Extract WMI filter param with 0x%x"), hr));
                    goto Cleanup;
                }
            }
        }
    }
    else
    {
        LPTSTR              szComputerName;             // SAM style computer object name


        hr = GetParameter(pUserSessionInst, L"targetName", (m_pRSOPQuery->szUserName), TRUE);
        if (SUCCEEDED(hr) && (m_pRSOPQuery->szUserName) && (*(m_pRSOPQuery->szUserName)))
        {
            GetStringSid((m_pRSOPQuery->szUserName), &(m_pRSOPQuery->szUserSid));
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EvaluateParameters: No user data specified")));
            if (m_pRSOPQuery->szUserName)
            {
                LocalFree(m_pRSOPQuery->szUserName);
                m_pRSOPQuery->szUserName = NULL;
            }
            // assume that the user results are not present
            m_pRSOPQuery->szUserName = NULL;
            m_pRSOPQuery->szUserSid = NULL;
            m_pRSOPQuery->dwFlags |= RSOP_NO_USER_POLICY;
            m_pRSOPQueryResults->bNoUserPolicyData = TRUE;
        }

        hr = GetParameter(pCompSessionInst, L"targetName", szComputerName, TRUE);
        if (FAILED(hr) || (!szComputerName) || (!(*szComputerName)))
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::EvaluateParameters: No Computer data specified")));
            // assume that the computer results are not present
            m_pRSOPQuery->dwFlags |= RSOP_NO_COMPUTER_POLICY;
            m_pRSOPQueryResults->bNoComputerPolicyData = TRUE;
        }

        if (szComputerName)
        {
            LocalFree(szComputerName);
        }

        if (szTarget)
        {
            ulNoChars = 1+lstrlen(szTarget);
            m_pRSOPQuery->szComputerName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);
            if (!(m_pRSOPQuery->szComputerName))
            {
                hr = E_OUTOFMEMORY;
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::EvaluateParameters: Failed to allocate memory for target comp with 0x%x"), hr));
                goto Cleanup;
            }

            hr = StringCchCopy(m_pRSOPQuery->szComputerName, ulNoChars, szTarget);
            ASSERT(SUCCEEDED(hr));
        }
    }

    DebugMsg( (DM_VERBOSE, TEXT("CRSOPComponentData::EvaluateParameters successful for namespace=<%s>, target=<%s>"), szNamespace, szTarget) );


    Cleanup:

    if (pUserSessionInst)
    {
        pUserSessionInst->Release();
    }

    if (pCompSessionInst)
    {
        pCompSessionInst->Release();
    }

    if (pUserNamespace)
    {
        pUserNamespace->Release();
    }

    if (pCompNamespace)
    {
        pCompNamespace->Release();
    }

    if (bstrNamespace)
    {
        SysFreeString(bstrNamespace);
        bstrNamespace = NULL;
    }

    if (szUserNamespace)
    {
        LocalFree(szUserNamespace);
    }

    if (szCompNamespace)
    {
        LocalFree(szCompNamespace);
    }

    if (bstrSessionInstPath)
    {
        SysFreeString(bstrSessionInstPath);
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    return hr;
}
//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::Load(IStream *pStm)
{
    HRESULT hr = E_FAIL;
    DWORD dwVersion, dwFlags;
    ULONG nBytesRead;
    LONG lIndex, lMax;
    LPTSTR lpText = NULL;
    BSTR bstrText;
    LPTSTR lpCommandLine = NULL;
    LPTSTR lpTemp, lpMode;
    BOOL   bFoundArg;
    int    iStrLen;


    // Parameter / initialization check

    if (!pStm)
        return E_FAIL;

    if ( m_pRSOPQuery == NULL )
    {
        if ( !CreateRSOPQuery( &m_pRSOPQuery, RSOP_UNKNOWN_MODE ) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to create RSOP_QUERY_CONTEXT with 0x%x."),
                                HRESULT_FROM_WIN32(GetLastError())));
            hr = E_FAIL;
            goto Exit;
        }
    }

    // Get the command line
    lpCommandLine = GetCommandLine();

    // Read in the saved data version number
    hr = pStm->Read(&dwVersion, sizeof(dwVersion), &nBytesRead);
    if ((hr != S_OK) || (nBytesRead != sizeof(dwVersion)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read version number with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }

    // Confirm that we are working with the correct version
    if (dwVersion != RSOP_PERSIST_DATA_VERSION)
    {
        ReportError(m_hwndFrame, 0, IDS_INVALIDMSC);
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Wrong version number (%d)."), dwVersion));
        hr = E_FAIL;
        goto Exit;
    }

    // Read the flags
    hr = pStm->Read(&dwFlags, sizeof(dwFlags), &nBytesRead);
    if ((hr != S_OK) || (nBytesRead != sizeof(dwFlags)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read flags with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }

    // Parse the command line
    DebugMsg((DM_VERBOSE, TEXT("CComponentData::Load: Command line switch override enabled.  Command line = %s"), lpCommandLine));

    lpTemp = lpCommandLine;
    iStrLen = lstrlen (RSOP_CMD_LINE_START);

    LPTSTR szUserSOMPref = NULL;
    LPTSTR szComputerSOMPref = NULL;
    LPTSTR szUserNamePref = NULL;
    LPTSTR szComputerNamePref = NULL;
    LPTSTR szSitePref = NULL;
    LPTSTR szDCPref = NULL;
    LPTSTR szNamespacePref = NULL;
    LPTSTR szTargetPref = NULL;

    do
    {
        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          RSOP_CMD_LINE_START, iStrLen,
                          lpTemp, iStrLen) == CSTR_EQUAL)
        {

            m_bOverride = TRUE;
            m_dwLoadFlags = RSOPMSC_OVERRIDE;
            lpTemp = ParseCommandLine(lpTemp, RSOP_MODE, &lpMode, &bFoundArg);

            if (bFoundArg) {
                if (lpMode && lpMode[0]) {
                    if ( _ttoi(lpMode) == 0 )
                    {
                        if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_LOGGING_MODE ) )
                        {
                            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to change query type") ) );
                            hr = E_FAIL;
                            goto Exit;
                        }
                    }
                    else
                    {
                        if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_PLANNING_MODE ) )
                        {
                            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to change query type") ) );
                            hr = E_FAIL;
                            goto Exit;
                        }
                    }
                }
                else
                {
                    if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_PLANNING_MODE ) )
                    {
                        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to change query type") ) );
                        hr = E_FAIL;
                        goto Exit;
                    }
                }

                if (lpMode) {
                    LocalFree(lpMode);
                    lpMode = NULL;
                }

                continue;
            }

            if (NULL == szUserSOMPref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_USER_OU_PREF, &szUserSOMPref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }
           
            if (NULL == szComputerSOMPref)
            {           
                lpTemp = ParseCommandLine(lpTemp, RSOP_COMP_OU_PREF, &szComputerSOMPref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }

            if (NULL == szUserNamePref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_USER_NAME, &szUserNamePref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }

            if (NULL==szComputerNamePref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_COMP_NAME, &szComputerNamePref, &bFoundArg);
                if (bFoundArg) 
                {
                    // RM: This code has been copied in from RSOPGetCompDlgProc and RSOPGetTargetDlgProc as I believe it belongs here.
                    ULONG ulNoChars = wcslen(szComputerNamePref)+1;
                    LPTSTR szTemp = (LPTSTR)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                    if ( szTemp == NULL )
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to allocate memory with 0x%x."),
                                  HRESULT_FROM_WIN32(GetLastError())) );
                        hr = E_FAIL;
                        goto Exit;
                    }

                    hr = StringCchCopy( szTemp, ulNoChars, NormalizedComputerName( szComputerNamePref) );
                    if (FAILED(hr))
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to copy computer name with 0x%x."), hr) );
                        LocalFree( szComputerNamePref );
                        LocalFree(szTemp);
                        goto Exit;
                    }

                    if ( wcslen( szTemp ) >= 1 )
                    {
                        // this is being called from dsa. A terminating '$' will be passed in
                        szTemp[ wcslen(szTemp)-1] = L'\0';
                    }

                    LocalFree( szComputerNamePref );
                    szComputerNamePref = szTemp;
                    continue;
                }
            }
           
            if (NULL == szSitePref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_SITENAME, &szSitePref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }

            if (NULL == szDCPref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_DCNAME_PREF, &szDCPref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }

            if (NULL == szNamespacePref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_NAMESPACE, &szNamespacePref, &bFoundArg);
                if (bFoundArg) 
                {
                    m_bNamespaceSpecified = TRUE;
                    continue;
                }
            }

            if (NULL == szTargetPref) 
            {
                lpTemp = ParseCommandLine(lpTemp, RSOP_TARGETCOMP, &szTargetPref, &bFoundArg);
                if (bFoundArg) 
                {
                    continue;
                }
            }

            lpTemp += iStrLen;
            continue;
        }
        lpTemp++;

    } while (*lpTemp);
        
    
    if ( m_bOverride )
    {
        if (m_bNamespaceSpecified)
        {
            hr = EvaluateParameters(szNamespacePref, szTargetPref);

            if (szNamespacePref)
            {
                LocalFree(szNamespacePref);
                szNamespacePref = NULL;
            }

            if (szTargetPref)
            {
                LocalFree(szTargetPref);
                szTargetPref = NULL;
            }

            if (FAILED(hr))
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: EvaluateParameters failed with error 0x%x"), hr) );
                goto Exit;
            }
        }
        else {
            m_pRSOPQuery->UIMode = RSOP_UI_WIZARD;
            m_pRSOPQuery->dwFlags |= RSOP_NO_WELCOME;

            // Store parameters found
            if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
            {
                m_pRSOPQuery->pUser->szName = szUserNamePref;
                m_pRSOPQuery->pUser->szSOM = szUserSOMPref;
                m_pRSOPQuery->pComputer->szName = szComputerNamePref;
                m_pRSOPQuery->pComputer->szSOM = szComputerSOMPref;
                m_pRSOPQuery->szSite = szSitePref;
                m_pRSOPQuery->szDomainController = szDCPref;

                if ( (m_pRSOPQuery->pUser->szName != NULL)
                    || (m_pRSOPQuery->pUser->szSOM != NULL) )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_USER;
                }

                if ( (m_pRSOPQuery->pComputer->szName != NULL)
                    || (m_pRSOPQuery->pComputer->szSOM != NULL) )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_COMPUTER;
                }

                // If both the user and computer are fixed, we are unfixing both
                //  since we don't know what the "user" intended to fix
                if ( (m_pRSOPQuery->dwFlags & RSOP_FIX_COMPUTER)
                      && (m_pRSOPQuery->dwFlags & RSOP_FIX_USER) )
                {
                    m_pRSOPQuery->dwFlags = m_pRSOPQuery->dwFlags & (RSOP_FIX_COMPUTER ^ 0xffffffff);
                    m_pRSOPQuery->dwFlags = m_pRSOPQuery->dwFlags & (RSOP_FIX_USER ^ 0xffffffff);
                }

                if ( m_pRSOPQuery->szSite != NULL )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_SITENAME;
                }

                if ( m_pRSOPQuery->szDomainController != NULL )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_DC;
                }
            }
            else
            {
                m_pRSOPQuery->szUserName = szUserNamePref;
                m_pRSOPQuery->szComputerName = szComputerNamePref;

                if ( m_pRSOPQuery->szUserName != NULL )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_USER;
                }

                if ( m_pRSOPQuery->szComputerName != NULL )
                {
                    m_pRSOPQuery->dwFlags |= RSOP_FIX_COMPUTER;
                }

                if ( szUserSOMPref != NULL )
                {
                    LocalFree( szUserSOMPref );
                }
                if ( szComputerSOMPref != NULL )
                {
                    LocalFree( szComputerSOMPref );
                }
                if ( szSitePref != NULL )
                {
                    LocalFree( szSitePref );
                }
                if ( szDCPref != NULL )
                {
                    LocalFree( szDCPref );
                }
            }
        }
    }
    else
    {
        if ( dwFlags & MSC_RSOP_FLAG_NO_DATA )
        {
            // There is no data in this file, so we simply quit here.
            m_pRSOPQuery->UIMode = RSOP_UI_WIZARD;
            hr = S_OK;
            goto Exit;
        }

        m_bGetExtendedErrorInfo = !((dwFlags & MSC_RSOP_FLAG_NOGETEXTENDEDERRORINFO) != 0);

        // Decode the loaded flags
        m_dwLoadFlags = RSOPMSC_NOOVERRIDE;

        m_bOverride = FALSE;
        m_pRSOPQuery->UIMode = RSOP_UI_REFRESH;

        if (dwFlags & MSC_RSOP_FLAG_DIAGNOSTIC)
        {
            if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_LOGGING_MODE ) )
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to change query type") ) );
                hr = E_FAIL;
                goto Exit;
            }
        }
        else
        {
            if ( !ChangeRSOPQueryType( m_pRSOPQuery, RSOP_PLANNING_MODE ) )
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to change query type") ) );
                hr = E_FAIL;
                goto Exit;
            }
        }
    
        if (dwFlags & MSC_RSOP_FLAG_ARCHIVEDATA)
        {
            m_bArchiveData = TRUE;
            m_bViewIsArchivedData = TRUE;
        }
    
        if ( (dwFlags & MSC_RSOP_FLAG_SLOWLINK) && (m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE) )
        {
            m_pRSOPQuery->bSlowNetworkConnection = TRUE;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            if (dwFlags & MSC_RSOP_FLAG_LOOPBACK_REPLACE)
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_REPLACE;
            }
            else if (dwFlags & MSC_RSOP_FLAG_LOOPBACK_MERGE)
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_MERGE;
            }
            else
            {
                m_pRSOPQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
            }

            m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue =
                        (dwFlags & MSC_RSOP_FLAG_COMPUTERWQLFILTERSTRUE) == MSC_RSOP_FLAG_COMPUTERWQLFILTERSTRUE;
            m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue = 
                        (dwFlags & MSC_RSOP_FLAG_USERWQLFILTERSTRUE) == MSC_RSOP_FLAG_USERWQLFILTERSTRUE;
        }
  
        if (dwFlags & MSC_RSOP_FLAG_NOUSER)
        {
            m_pRSOPQuery->dwFlags |= RSOP_NO_USER_POLICY;
        }
    
    
        if (dwFlags & MSC_RSOP_FLAG_NOCOMPUTER)
        {
            m_pRSOPQuery->dwFlags |= RSOP_NO_COMPUTER_POLICY;
        }

        if ( m_bViewIsArchivedData )
        {
            // We must create a dummy RSOP query results structure for the loaded information
            m_pRSOPQueryResults = (LPRSOP_QUERY_RESULTS)LocalAlloc( LPTR, sizeof(RSOP_QUERY_RESULTS) );
            if ( m_pRSOPQueryResults == NULL )
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to create RSOP_QUERY_CONTEXT.")) );
                hr = E_FAIL;
                goto Exit;
            }
            m_pRSOPQueryResults->bComputerDeniedAccess = FALSE;
            m_pRSOPQueryResults->bNoComputerPolicyData = FALSE;
            m_pRSOPQueryResults->bNoUserPolicyData = FALSE;
            m_pRSOPQueryResults->bUserDeniedAccess = FALSE;
            m_pRSOPQueryResults->szWMINameSpace = NULL;
        }
        

        if (dwFlags & MSC_RSOP_FLAG_USERDENIED)
        {
            // RM: Must still decide what to do here. Removing the persistence of this
            // item might cause a regression, but it is not sure if anybody uses this "feature".
            // m_bUserDeniedAccess = TRUE;
            if ( m_bViewIsArchivedData )
            {
                m_pRSOPQueryResults->bUserDeniedAccess = TRUE;
            }
        }


        if (dwFlags & MSC_RSOP_FLAG_COMPUTERDENIED)
        {
            // RM: Must still decide what to do here. Removing the persistence of this
            // item might cause a regression, but it is not sure if anybody uses this "feature".
            // m_bComputerDeniedAccess = TRUE;
            if ( m_bViewIsArchivedData )
            {
                m_pRSOPQueryResults->bComputerDeniedAccess = TRUE;
            }
        }

        // Read the computer name
        LPTSTR szComputerName = NULL;
        hr = ReadString( pStm, &szComputerName, TRUE );
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the computer name with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
        // Read the computer SOM
        LPTSTR szComputerSOM = NULL;
        hr = ReadString( pStm, &szComputerSOM, TRUE );
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the computer SOM with 0x%x."), hr));
            hr = E_FAIL;
            LocalFree( szComputerName );
            goto Exit;
        }

        // RM: based on the query type, set the right variables
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->pComputer->szName = szComputerName;
            m_pRSOPQuery->pComputer->szSOM = szComputerSOM;
        }
        else
        {
            if ( szComputerName != NULL )
            {
                m_pRSOPQuery->szComputerName = szComputerName;
            }
            LocalFree( szComputerSOM );
            // RM: From investigating the code, I have concluded that in logging mode, only a computer name can be specified, not a SOM.
        }

        DWORD listCount = 0;
        LPTSTR* aszStringList = NULL;
        
        // Read in the computer security groups
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read computer security groups with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
        
        // RM: Once again, there should be no security groups to read in if this is logging mode, but for backwards compatability I must
        //  try to read in whatever there is.
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->pComputer->dwSecurityGroupCount = listCount;
            m_pRSOPQuery->pComputer->aszSecurityGroups = aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded computer security groups in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }

        // Read in the computer WQL filters
        listCount = 0;
        aszStringList = NULL;
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read computer WQL filters with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
        
        // RM: See notes for security groups - same applies here
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->pComputer->dwWQLFilterCount = listCount;
            m_pRSOPQuery->pComputer->aszWQLFilters = aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded computer WQL filters in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }
    
        // Read in the computer WQL filter names
        listCount = 0;
        aszStringList = NULL;
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read computer WQL filter names with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        // RM: See notes for security groups - same applies here
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            //m_pRSOPQuery->pComputer->dwWQLFilterNameCount= listCount;
            // The number of filter names must match the number of filters
            m_pRSOPQuery->pComputer->aszWQLFilterNames= aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded computer WQL filter names in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }
            
        // Read the user name
        LPTSTR szUserNameOrSid = NULL;
        hr = ReadString( pStm, &szUserNameOrSid, TRUE );
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user name with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
    
        // Read the user display name (only used in logging mode)
        LPTSTR szUserDisplayName = NULL;
        hr = ReadString( pStm, &szUserDisplayName, TRUE );
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user display name with 0x%x."), hr));
            hr = E_FAIL;
            LocalFree( szUserNameOrSid );
            goto Exit;
        }
    
        // Read the user SOM
        LPTSTR szUserSOM = NULL;
        hr = ReadString( pStm, &szUserSOM, TRUE );
    
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the user SOM with 0x%x."), hr));
            hr = E_FAIL;
            LocalFree( szUserNameOrSid );
            LocalFree( szUserDisplayName );
            goto Exit;
        }
    
        if (m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE)
        {
            m_pRSOPQuery->pUser->szName = szUserNameOrSid;
            m_pRSOPQuery->pUser->szSOM = szUserSOM;
        }
        else
        {
            // First check if the user sid is a special character and we are going to do logging mode. If this is the case,
            //  the current user is found and used (SPECIAL: used primarily by RSOP.MSC)
            if ( (m_pRSOPQuery->QueryType == RSOP_LOGGING_MODE)
                && !lstrcmpi( szUserNameOrSid, TEXT(".") ) && !m_bViewIsArchivedData )
            {
                LPTSTR szThisUserName = NULL;
        
                szThisUserName = MyGetUserName (NameSamCompatible);
        
                if ( szThisUserName != NULL )
                {
                    if ( szUserDisplayName != NULL )
                    {
                        LocalFree( szUserDisplayName );
                    }
        
                    szUserDisplayName = szThisUserName;
                }
            }

            // RM: From investigating the code, I have concluded that the assignment below is what originally happened
            //  in the wizard. Also, the UserSOM is not used and should actually be NULL.
            m_pRSOPQuery->szUserName = szUserDisplayName;
            m_pRSOPQuery->szUserSid = szUserNameOrSid;
        }
    
        // Read in the user security groups
        listCount = 0;
        aszStringList = NULL;
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read user security groups with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
        
        // RM: Once again, there should be no security groups to read in if this is logging mode, but for backwards compatability I must
        //  try to read in whatever there is.
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->pUser->dwSecurityGroupCount = listCount;
            m_pRSOPQuery->pUser->aszSecurityGroups = aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded user security groups in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }

        // Read in the WQL filters
        listCount = 0;
        aszStringList = NULL;
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read user WQL filters with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }
        
        // RM: See notes for security groups - same applies here
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->pUser->dwWQLFilterCount = listCount;
            m_pRSOPQuery->pUser->aszWQLFilters = aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded user WQL filters in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }
    
        // Read in the WQL filter names
        listCount = 0;
        aszStringList = NULL;
        hr = LoadStringList( pStm, &listCount, &aszStringList );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read user WQL filter names with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        // RM: See notes for security groups - same applies here
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            //m_pRSOPQuery->pUser->dwWQLFilterNameCount= listCount;
            // The number of filter names must match the number of filters
            m_pRSOPQuery->pUser->aszWQLFilterNames= aszStringList;
        }
        else if ( listCount != 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Loaded user WQL filter names in logging mode!")) );
            hr = E_FAIL;
            goto Exit;
        }
    
        // Read the site
        LPTSTR szSite = NULL;
        hr = ReadString( pStm, &szSite, TRUE );
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the site with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->szSite = szSite;
        }
        else
        {
            LocalFree( szSite );
        }
    
        // Read the DC
        LPTSTR szDomainController = NULL;
        hr = ReadString( pStm, &szDomainController, TRUE );
        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read the dc with 0x%x."), hr));
            hr = E_FAIL;
            goto Exit;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            m_pRSOPQuery->szDomainController = szDomainController;
        }
        else
        {
            LocalFree( szDomainController );
        }
    }
    
    // Read in the WMI data if appropriate

    if (m_bNamespaceSpecified)
    {
        // Initialize the snapin
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: Launching RSOP to collect data from the namespace.")));

        hr = InitializeRSOP( FALSE );
        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: InitializeRSOP failed with 0x%x."), hr));
            goto Exit;
        }
    }
    else if (m_bViewIsArchivedData)
    {
        m_pStm = pStm;
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: Launching RSOP status dialog box.")));

        if (DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RSOP_STATUSMSC),
                           NULL, InitArchivedRsopDlgProc, (LPARAM) this ) == -1) {

            m_pStm = NULL;
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Falied to create dialog box. 0x%x"), hr));
            goto Exit;
        }
        m_pStm = NULL;
    }
    else
    {
        // Initialize the snapin
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: Launching RSOP status dialog box.")));

        hr = InitializeRSOP( FALSE );
        if ( (hr == S_FALSE) && (m_dwLoadFlags == RSOPMSC_OVERRIDE) )
        {
            // this is a hack to get mmc to not launch itself when user cancelled the wizard
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::Load: User cancelled the wizard. Exitting the process")));
            TerminateProcess (GetCurrentProcess(), ERROR_CANCELLED);
        }

        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: InitializeRSOP failed with 0x%x."), hr));
            goto Exit;
        }
    }


Exit:
    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = STG_E_CANTSAVE;
    ULONG nBytesWritten;
    DWORD dwTemp;
    DWORD dwFlags;
    GROUP_POLICY_OBJECT_TYPE gpoType;
    LPTSTR lpPath = NULL;
    LPTSTR lpTemp;
    DWORD dwPathSize = 1024;
    LONG lIndex, lMax;
    LPTSTR lpText;
    LPTSTR lpUserData = NULL, lpComputerData = NULL;
    TCHAR szPath[2*MAX_PATH];

    // Save the version number
    dwTemp = RSOP_PERSIST_DATA_VERSION;
    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write version number with 0x%x."), hr));
        goto Exit;
    }

    // Save the flags
    dwTemp = 0;

    if ( !m_bInitialized )
    {
        dwTemp |= MSC_RSOP_FLAG_NO_DATA;
    }
    else
    {
        if ( !m_bGetExtendedErrorInfo )
        {
            dwTemp |= MSC_RSOP_FLAG_NOGETEXTENDEDERRORINFO;
        }
        
        if ( (m_pRSOPQuery == NULL) || (m_pRSOPQueryResults == NULL) )
        {
            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Cannot save snapin with no initialized RSOP query or results.")) );
            return E_FAIL;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_UNKNOWN_MODE )
        {
            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Cannot save snapin with no initialized RSOP query.")) );
            return E_FAIL;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_LOGGING_MODE )
        {
            dwTemp |= MSC_RSOP_FLAG_DIAGNOSTIC;
        }

        if (m_bArchiveData)
        {
            dwTemp |= MSC_RSOP_FLAG_ARCHIVEDATA;
        }

        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            if ( m_pRSOPQuery->bSlowNetworkConnection )
            {
                dwTemp |= MSC_RSOP_FLAG_SLOWLINK;
            }
        
            switch ( m_pRSOPQuery->LoopbackMode )
            {
                case RSOP_LOOPBACK_REPLACE:
                    dwTemp |= MSC_RSOP_FLAG_LOOPBACK_REPLACE;
                    break;
                case RSOP_LOOPBACK_MERGE:
                    dwTemp |= MSC_RSOP_FLAG_LOOPBACK_MERGE;
                    break;
                default:
                    break;
            }

            if ( m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue )
            {
                dwTemp |= MSC_RSOP_FLAG_COMPUTERWQLFILTERSTRUE;
            }

            if ( m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue )
            {
                dwTemp |= MSC_RSOP_FLAG_USERWQLFILTERSTRUE;
            }
        }

        if ( (m_pRSOPQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY )
        {
            dwTemp |= MSC_RSOP_FLAG_NOUSER;
        }

        if ( (m_pRSOPQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
        {
            dwTemp |= MSC_RSOP_FLAG_NOCOMPUTER;
        }

        // RM: must still decide what to do here, but from all accounts it looks like this is completele redundant
        //  unless the RSOP data was also archived.
        /*
        if (m_bUserDeniedAccess)
        {
            dwTemp |= MSC_RSOP_FLAG_USERDENIED;
        }

        if (m_bComputerDeniedAccess)
        {
            dwTemp |= MSC_RSOP_FLAG_COMPUTERDENIED;
        }
        */
    }

    hr = pStm->Write(&dwTemp, sizeof(dwTemp), &nBytesWritten);
    if ((hr != S_OK) || (nBytesWritten != sizeof(dwTemp)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write flags with 0x%x."), hr));
        goto Exit;
    }

    // If there is no data, we quit here
    if ( !m_bInitialized )
    {
        return S_OK;
    }

    // Save the computer name
    LPTSTR szComputerName = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szComputerName = m_pRSOPQuery->pComputer->szName;
    }
    else
    {
        szComputerName = m_pRSOPQuery->szComputerName;
    }
    
    if ( szComputerName == NULL )
    {
        // SaveString knows how to handle NULL strings. We must save this so that a NULL string can be loaded!
        hr = SaveString( pStm, szComputerName );
    }
    else
    {
        if ( (m_bArchiveData) && (!lstrcmpi(szComputerName, TEXT("."))) )
        {
            ULONG ulSize = MAX_PATH;
            LPTSTR szLocalComputerName = new TCHAR[MAX_PATH];
            if ( szLocalComputerName == NULL )
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer name (could not allocate memory)")) );
                hr = E_FAIL;
                goto Exit;
            }
            if (!GetComputerObjectName (NameSamCompatible, szLocalComputerName, &ulSize))
            {
                DWORD dwLastError = GetLastError();
                if ( dwLastError == ERROR_MORE_DATA )
                {
                    delete [] szLocalComputerName;
                    szLocalComputerName = new TCHAR[ulSize];
                    if ( szLocalComputerName == NULL )
                    {
                        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer name (could not allocate memory)")) );
                        hr = E_FAIL;
                        goto Exit;
                    }

                    if (!GetComputerObjectName (NameSamCompatible, szLocalComputerName, &ulSize))
                    {
                        dwLastError = GetLastError();
                    }
                    else
                    {
                        dwLastError = ERROR_SUCCESS;
                    }
                }

                if ( dwLastError != ERROR_SUCCESS )
                {
                    if ( !GetComputerNameEx (ComputerNameNetBIOS, szLocalComputerName, &ulSize) )
                    {
                        dwLastError = GetLastError();
                        if ( dwLastError == ERROR_MORE_DATA )
                        {
                            delete [] szLocalComputerName;
                            szLocalComputerName = new TCHAR[ulSize];
                            if ( szLocalComputerName == NULL )
                            {
                                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer name (could not allocate memory)")) );
                                hr = E_FAIL;
                                goto Exit;
                            }

                            if (!GetComputerNameEx (ComputerNameNetBIOS, szLocalComputerName, &ulSize))
                            {
                                dwLastError = GetLastError();
                            }
                        }
                        
                    }
                }

                if ( dwLastError != ERROR_SUCCESS )
                {
                    DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Could not obtain computer name with 0x%x"),
                                        HRESULT_FROM_WIN32(dwLastError) ) );
                    hr = E_FAIL;
                    delete [] szLocalComputerName;
                    goto Exit;
                }
            }

            if ( (szLocalComputerName != NULL) && (wcslen(szLocalComputerName) >= 1)
                    && (szLocalComputerName[wcslen(szLocalComputerName)-1] == L'$'))
            {
                // Remove the terminating '$' to be consistent with saving a specific computer name in logging mode.
                szLocalComputerName[ wcslen(szLocalComputerName)-1] = L'\0';
            }

            hr = SaveString (pStm, szLocalComputerName);
            delete [] szLocalComputerName;
        }
        else
        {
            hr = SaveString (pStm, szComputerName);
        }
    }

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer name with %d."), hr));
        goto Exit;
    }

    // Save the computer SOM
    LPTSTR szComputerSOM = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szComputerSOM = m_pRSOPQuery->pComputer->szSOM;
    }
    hr = SaveString( pStm, szComputerSOM );

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save computer SOM with %d."), hr));
        goto Exit;
    }

    // Save the computer security groups
    DWORD dwStringCount = 0;
    LPTSTR* aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pComputer->dwSecurityGroupCount;
        aszStringList = m_pRSOPQuery->pComputer->aszSecurityGroups;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write computer security groups.")) );
        goto Exit;
    }

    // Save the computer WQL filters
    dwStringCount = 0;
    aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pComputer->dwWQLFilterCount;
        aszStringList = m_pRSOPQuery->pComputer->aszWQLFilters;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write computer WQL filters.")) );
        goto Exit;
    }

    // Save the computer WQL filter names
    dwStringCount = 0;
    aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pComputer->dwWQLFilterCount;
        aszStringList = m_pRSOPQuery->pComputer->aszWQLFilterNames;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write computer WQL filter names.")) );
        goto Exit;
    }

    // Save the user name/
    // fyi, This is not used in diagnostic mode archive data
    LPTSTR szUserNameOrSid = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szUserNameOrSid = m_pRSOPQuery->pUser->szName;
    }
    else
    {
        // RM: (See Load method)
        szUserNameOrSid = m_pRSOPQuery->szUserSid;
    }
    hr = SaveString( pStm, szUserNameOrSid );

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user name with %d."), hr));
        goto Exit;
    }

    // Save the user display name (only used in logging mode)
    LPTSTR szUserDisplayName = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_LOGGING_MODE )
    {
        if ( 0 == lstrcmpi( m_pRSOPQuery->szUserSid, TEXT(".") ) )
        {
            szUserDisplayName = m_pRSOPQuery->szUserSid;
        }
        else
        {
            szUserDisplayName = m_pRSOPQuery->szUserName;
        }
        
        if ( m_bArchiveData && !lstrcmpi( m_pRSOPQuery->szUserSid, TEXT(".") ) )
        {
            LPTSTR lpSaveTemp;

            lpSaveTemp = MyGetUserName (NameSamCompatible);
            if ( lpSaveTemp == NULL )
            {
                DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to get user name for archived data.")) );
                hr = E_FAIL;
                goto Exit;
            }

            hr = SaveString (pStm, lpSaveTemp);
            LocalFree (lpSaveTemp);
        }
        else
        {
            hr = SaveString (pStm, szUserDisplayName );
        }
    }
    else
    {
        hr = SaveString( pStm, szUserDisplayName );
    }

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user display name with %d."), hr));
        goto Exit;
    }

    // Save the user SOM
    LPTSTR szUserSOM = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szUserSOM = m_pRSOPQuery->pUser->szSOM;
    }
    hr = SaveString (pStm, szUserSOM);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save user SOM with %d."), hr));
        goto Exit;
    }

    // Save the user security groups
    dwStringCount = 0;
    aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pUser->dwSecurityGroupCount;
        aszStringList = m_pRSOPQuery->pUser->aszSecurityGroups;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write user security groups.")) );
        goto Exit;
    }

    // Save the user WQL filters
    dwStringCount = 0;
    aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pUser->dwWQLFilterCount;
        aszStringList = m_pRSOPQuery->pUser->aszWQLFilters;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write user WQL filters.")) );
        goto Exit;
    }

    // Save the user WQL filter names
    dwStringCount = 0;
    aszStringList = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        dwStringCount = m_pRSOPQuery->pUser->dwWQLFilterCount;
        aszStringList = m_pRSOPQuery->pUser->aszWQLFilterNames;
    }
    hr = SaveStringList( pStm, dwStringCount, aszStringList );

    if ( hr != S_OK )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to write user WQL filter names.")) );
        goto Exit;
    }

    // Save the site
    LPTSTR szSite = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szSite = m_pRSOPQuery->szSite;
    }
    hr = SaveString( pStm, szSite );

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save site with %d."), hr));
        goto Exit;
    }

    // Save the DC
    LPTSTR szDomainController = NULL;
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        szDomainController = m_pRSOPQuery->szDomainController;
    }
    hr = SaveString( pStm, szDomainController );

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Failed to save DC with %d."), hr));
        goto Exit;
    }

    // Save the WMI and event log data if appropriate
    if (m_bArchiveData)
    {
        lpComputerData = CreateTempFile();

        if (!lpComputerData)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CreateTempFile failed with %d."), GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        ULONG ulNoRemChars = 0;

        hr = StringCchCopy (szPath,  ARRAYSIZE(szPath),m_pRSOPQueryResults->szWMINameSpace );
        if (SUCCEEDED(hr)) 
        {
            lpTemp = CheckSlash (szPath);
            ulNoRemChars = ARRAYSIZE(szPath) - lstrlen(szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), COMPUTER_SECTION);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Could not copy  WMI name space with %d."), hr));
            goto Exit;
        }

        hr = ExportRSoPData (szPath, lpComputerData);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: ExportRSoPData failed with 0x%x."), hr));
            goto Exit;
        }

        hr = CopyFileToMSC (lpComputerData, pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CopyFileToMSC failed with 0x%x."), hr));
            goto Exit;
        }


        lpUserData = CreateTempFile();

        if (!lpUserData)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CreateTempFile failed with %d."), GetLastError()));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = StringCchCopy (lpTemp, ulNoRemChars, USER_SECTION);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: Could not copy  WMI name space with %d."), hr));
            goto Exit;
        }

        hr = ExportRSoPData (szPath, lpUserData);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: ExportRSoPData failed with 0x%x."), hr));
            goto Exit;
        }

        hr = CopyFileToMSC (lpUserData, pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: CopyFileToMSC failed with 0x%x."), hr));
            goto Exit;
        }

        //  Save the event log entries
        hr = m_CSELists.GetEvents()->SaveEntriesToStream(pStm);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Save: SaveEntriesToStream failed with 0x%x."), hr));
            goto Exit;
        }
    }

    if (fClearDirty)
    {
        ClearDirty();
    }

Exit:

    if (lpUserData)
    {
        DeleteFile (lpUserData);
        delete [] lpUserData;
    }

    if (lpComputerData)
    {
        DeleteFile (lpComputerData);
        delete [] lpComputerData;
    }

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::InitNew(void)
{
    return S_OK;
}

//-------------------------------------------------------
// IPersistStreamInit helper methods

STDMETHODIMP CRSOPComponentData::CopyFileToMSC (LPTSTR lpFileName, IStream *pStm)
{
    ULONG nBytesWritten;
    WIN32_FILE_ATTRIBUTE_DATA info;
    ULARGE_INTEGER FileSize, SubtractAmount;
    HANDLE hFile;
    DWORD dwError, dwReadAmount, dwRead;
    LPBYTE lpData;
    HRESULT hr;


    // Get the file size

    if (!GetFileAttributesEx (lpFileName, GetFileExInfoStandard, &info))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to get file attributes with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    FileSize.LowPart = info.nFileSizeLow;
    FileSize.HighPart = info.nFileSizeHigh;

    // Save the file size

    hr = pStm->Write(&FileSize, sizeof(FileSize), &nBytesWritten);

    if (hr != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write string length with %d."), hr));
        return hr;
    }

    if (nBytesWritten != sizeof(FileSize))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write the correct amount of data.")));
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    // Allocate a buffer to use for the transfer

    lpData = (LPBYTE) LocalAlloc (LPTR, 4096);

    if (!lpData)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to allocate memory with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Open the temp file

    hFile = CreateFile (lpFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: CreateFile for %s failed with %d"), lpFileName, dwError));
        LocalFree (lpData);
        return HRESULT_FROM_WIN32(dwError);
    }


    while (FileSize.QuadPart)
    {
        // Determine how much to read

        dwReadAmount = (FileSize.QuadPart > 4096) ? 4096 : FileSize.LowPart;

        // Read from the temp file

        if (!ReadFile (hFile, lpData, dwReadAmount, &dwRead, NULL))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: ReadFile failed with %d"), dwError));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }

        // Make sure we read enough

        if (dwReadAmount != dwRead)
        {
            dwError = ERROR_INVALID_DATA;
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to read enough data")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }

        // Write to the stream

        hr = pStm->Write(lpData, dwReadAmount, &nBytesWritten);

        if (hr != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write data with %d."), hr));
            LocalFree (lpData);
            CloseHandle (hFile);
            return hr;
        }

        if (nBytesWritten != dwReadAmount)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyFileToMSC: Failed to write the correct amount of data.")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        SubtractAmount.LowPart = dwReadAmount;
        SubtractAmount.HighPart = 0;

        FileSize.QuadPart = FileSize.QuadPart - SubtractAmount.QuadPart;
    }


    CloseHandle (hFile);
    LocalFree (lpData);

    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::CreateNameSpace (LPTSTR lpNameSpace, LPTSTR lpParentNameSpace)
{
    IWbemLocator *pIWbemLocator;
    IWbemServices *pIWbemServices;
    IWbemClassObject *pIWbemClassObject = NULL, *pObject = NULL;
    VARIANT var;
    BSTR bstrName, bstrNameProp;
    HRESULT hr;

    // Create a locater instance

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: CoCreateInstance failed with 0x%x"), hr));
        return hr;
    }

    // Connect to the server
    BSTR bstrParentNamespace = SysAllocString( lpParentNameSpace );
    if ( bstrParentNamespace == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildGPOList: Failed to allocate BSTR memory.")));
        pIWbemLocator->Release();
        return E_OUTOFMEMORY;
    }

    hr = pIWbemLocator->ConnectServer(bstrParentNamespace, NULL, NULL, 0, 0, NULL, NULL, &pIWbemServices);
    SysFreeString( bstrParentNamespace );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: ConnectServer to %s failed with 0x%x"), lpNameSpace, hr));
        pIWbemLocator->Release();
        return hr;
    }

    // Get the namespace class

    bstrName = SysAllocString (TEXT("__Namespace"));

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    hr = pIWbemServices->GetObject( bstrName, 0, NULL, &pIWbemClassObject, NULL);

    SysFreeString (bstrName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: GetObject failed with 0x%x"), hr));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    // Spawn Instance

    hr = pIWbemClassObject->SpawnInstance(0, &pObject);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SpawnInstance failed with 0x%x"), hr));
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    // Convert new namespace to a bstr

    bstrName = SysAllocString (lpNameSpace);

    if (!bstrName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    // Set the display name

    var.vt = VT_BSTR;
    var.bstrVal = bstrName;

    bstrNameProp = SysAllocString (TEXT("Name"));

    if (!bstrNameProp)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: SysAllocString failed with %d"), GetLastError()));
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }


    hr = pObject->Put( bstrNameProp, 0, &var, 0 );

    SysFreeString (bstrNameProp);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: Put failed with 0x%x"), hr));
        SysFreeString (bstrName);
        pObject->Release();
        pIWbemServices->Release();
        pIWbemLocator->Release();
        return hr;
    }

    // Commit the instance

    hr = pIWbemServices->PutInstance( pObject, WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateNameSpace: PutInstance failed with 0x%x"), hr));
    }

    SysFreeString (bstrName);
    pObject->Release();
    pIWbemServices->Release();
    pIWbemLocator->Release();

    return hr;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::CopyMSCToFile (IStream *pStm, LPTSTR *lpMofFileName)
{
    HRESULT hr;
    LPTSTR lpFileName;
    ULARGE_INTEGER FileSize, SubtractAmount;
    ULONG nBytesRead;
    LPBYTE lpData;
    DWORD dwError, dwReadAmount, dwRead, dwBytesWritten;
    HANDLE hFile;

    // Get the filename to work with

    lpFileName = CreateTempFile();

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to create temp filename with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Read in the data length

    hr = pStm->Read(&FileSize, sizeof(FileSize), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(FileSize)))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to read data size with 0x%x."), hr));
        return E_FAIL;
    }

    // Allocate a buffer to use for the transfer

    lpData = (LPBYTE) LocalAlloc (LPTR, 4096);

    if (!lpData)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to allocate memory with %d."), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Open the temp file

    hFile = CreateFile (lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: CreateFile for %s failed with %d"), lpFileName, dwError));
        LocalFree (lpData);
        return HRESULT_FROM_WIN32(dwError);
    }


    while (FileSize.QuadPart)
    {
        // Determine how much to read

        dwReadAmount = (FileSize.QuadPart > 4096) ? 4096 : FileSize.LowPart;

        // Read from the msc file

        hr = pStm->Read(lpData, dwReadAmount, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwReadAmount))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Read failed with 0x%x"), hr));
            LocalFree (lpData);
            CloseHandle (hFile);
            return hr;
        }

        // Write to the temp file

        if (!WriteFile(hFile, lpData, dwReadAmount, &dwBytesWritten, NULL))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to write data with %d."), dwError));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(dwError);
        }

        if (dwBytesWritten != dwReadAmount)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CopyMSCToFile: Failed to write the correct amount of data.")));
            LocalFree (lpData);
            CloseHandle (hFile);
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        SubtractAmount.LowPart = dwReadAmount;
        SubtractAmount.HighPart = 0;

        FileSize.QuadPart = FileSize.QuadPart - SubtractAmount.QuadPart;
    }


    CloseHandle (hFile);
    LocalFree (lpData);

    *lpMofFileName = lpFileName;

    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::BuildDisplayName (void)
{
    TCHAR szArchiveData[100];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szComputerNameBuffer[100];
    LPTSTR szUserName, szComputerName, lpEnd;
    LPTSTR szUserOU, szComputerOU;
    DWORD dwSize;
    int n;

    // Make the display name (needs to handle empty names)

    if (m_bViewIsArchivedData)
    {
        LoadString(g_hInstance, IDS_ARCHIVEDATATAG, szArchiveData, ARRAYSIZE(szArchiveData));
    }
    else
    {
        szArchiveData[0] = TEXT('\0');
    }


    szUserName = NULL;
    szUserOU = NULL;
    if ( !m_pRSOPQueryResults->bNoUserPolicyData )
    {
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            if ( m_pRSOPQuery->pUser->szName != NULL )
            {
                szUserName = NameWithoutDomain( m_pRSOPQuery->pUser->szName );
            }
            else if ( m_pRSOPQuery->pUser->szSOM )
            {
                szUserOU = GetContainerFromLDAPPath( m_pRSOPQuery->pUser->szSOM );
                szUserName = szUserOU;
            }
        }
        else if ( m_pRSOPQuery->szUserName != NULL )
        {
            szUserName = NameWithoutDomain( m_pRSOPQuery->szUserName );
        }
    }

    szComputerName = NULL;
    szComputerOU = NULL;
    if ( !m_pRSOPQueryResults->bNoComputerPolicyData )
    {
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            if ( m_pRSOPQuery->pComputer->szName != NULL )
            {
                szComputerName = m_pRSOPQuery->pComputer->szName;
            }
            else if ( m_pRSOPQuery->pComputer->szSOM != NULL )
            {
                szComputerOU = GetContainerFromLDAPPath( m_pRSOPQuery->pComputer->szSOM );
            }
        }
        else if ( m_pRSOPQuery->szComputerName != NULL )
        {
            szComputerName = m_pRSOPQuery->szComputerName;
        }

        // Format computer name if necessary
        if ( szComputerName != NULL )
        {
            if ( !lstrcmpi(szComputerName, TEXT(".")) )
            {
                szComputerNameBuffer[0] = TEXT('\0');
                dwSize = ARRAYSIZE(szComputerNameBuffer);
                GetComputerNameEx (ComputerNameNetBIOS, szComputerNameBuffer, &dwSize);
                szComputerName = szComputerNameBuffer;
            }
            else
            {
                lstrcpyn (szComputerNameBuffer, NameWithoutDomain(szComputerName),
                          ARRAYSIZE(szComputerNameBuffer));

                szComputerName = szComputerNameBuffer;

                lpEnd = szComputerName + lstrlen(szComputerName) - 1;

                if (*lpEnd == TEXT('$'))
                {
                    *lpEnd =  TEXT('\0');
                }
            }
        }
        else if ( szComputerOU != NULL )
        {
            szComputerName = szComputerOU;
        }
    }


    if ( (szUserName != NULL) && (szComputerName != NULL) )
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME1, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            wcslen(szUserName) + wcslen(szComputerName) + 1;

        m_szDisplayName = new WCHAR[n];

        if (m_szDisplayName)
        {
            (void) StringCchPrintf(m_szDisplayName, n, szBuffer, szUserName, szComputerName);
        }
    }
    else if ( (szUserName != NULL) && (szComputerName == NULL) )
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME2, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            wcslen(szUserName) + 1;

        m_szDisplayName = new WCHAR[n];

        if (m_szDisplayName)
        {
            (void) StringCchPrintf (m_szDisplayName, n, szBuffer, szUserName);
        }
    }
    else
    {
        LoadString(g_hInstance, IDS_RSOP_DISPLAYNAME2, szBuffer, ARRAYSIZE(szBuffer));

        n = wcslen(szBuffer) + wcslen (szArchiveData) +
            (szComputerName ? wcslen(szComputerName) : 0) + 1;

        m_szDisplayName = new WCHAR[n];

        if (m_szDisplayName)
        {
            (void) StringCchPrintf (m_szDisplayName, n, szBuffer, (szComputerName ? szComputerName : L""));
        }
    }


    if ( (m_szDisplayName != NULL) && m_bViewIsArchivedData)
    {
        (void) StringCchCat (m_szDisplayName, n, szArchiveData);
    }

    if ( szUserOU != NULL )
    {
        delete [] szUserOU;
    }

    if ( szComputerOU != NULL )
    {
        delete [] szComputerOU;
    }

    return S_OK;
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::LoadStringList( IStream* pStm, DWORD* pCount, LPTSTR** paszStringList )
{
    HRESULT hr = S_OK;
    DWORD dwStringCount = 0;
    DWORD dwIndex = 0;
    ULONG nBytesRead;
    
    // Read in the list count
    hr = pStm->Read( &dwStringCount, sizeof(dwStringCount), &nBytesRead );

    if ( (hr != S_OK) || (nBytesRead != sizeof(dwStringCount)) )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::LoadStringList: Failed to read string list count with 0x%x."), hr));
        hr = E_FAIL;
    }
    // Read in the security groups
    else if ( dwStringCount != 0 )
    {
        (*paszStringList) = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR)*dwStringCount );

        if ( (*paszStringList) == NULL )
        {
            DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::LoadBSTRList: Failed to allocate memory for string list with 0x%x."),
                                HRESULT_FROM_WIN32(GetLastError()) ) );
            hr = E_FAIL;
        }
        else
        {
            LPTSTR szString = NULL;
            for ( dwIndex = 0; dwIndex < dwStringCount; dwIndex++ )
            {
                hr = ReadString( pStm, &szString, TRUE );
                if (hr != S_OK)
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Failed to read string with 0x%x."), hr));
                    hr = E_FAIL;
                    goto ErrorExit;
                }

                (*paszStringList)[dwIndex] = szString;
            }

            *pCount = dwStringCount;
        }
    }

    return hr;
    
ErrorExit:
    // Free allocated memory
    for ( DWORD dwClearIndex = 0; dwClearIndex < dwIndex; dwClearIndex++ )
    {
        LocalFree( (*paszStringList)[dwClearIndex] );
        paszStringList[dwClearIndex] = 0;
    }

    LocalFree( *paszStringList );
    *paszStringList = NULL;
    
    return hr;
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::SaveStringList( IStream* pStm, DWORD dwCount, LPTSTR* aszStringList )
{
    HRESULT hr = S_OK;
    ULONG nBytesWritten;

    // Write the count
    hr = pStm->Write( &dwCount, sizeof(dwCount), &nBytesWritten );
    if ( (hr != S_OK) || (nBytesWritten != sizeof(dwCount)) )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::SaveStringList: Failed to write string list count with %d."), hr));
        return E_FAIL;
    }

    // If there are strings to write, do so
    if ( dwCount != 0 )
    {
        DWORD dwIndex;
        for ( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {
            hr = SaveString( pStm, aszStringList[dwIndex] );
            if (hr != S_OK)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::SaveStringList: Failed to save string list with %d."), hr));
                return E_FAIL;
            }
        }
    }

    return S_OK;
}

//-------------------------------------------------------
// Helpers for IRSOPInformation

STDMETHODIMP CRSOPComponentData::GetNamespace (DWORD dwSection, LPOLESTR pszName, int cchMaxLength)
{
    TCHAR szPath[2*MAX_PATH];
    LPTSTR lpEnd;


    //
    // Check parameters
    //

    if (!pszName || (cchMaxLength <= 0))
        return E_INVALIDARG;


    if (!m_bInitialized)
    {
        return OLE_E_BLANK;
    }

    if ((dwSection != GPO_SECTION_ROOT) &&
        (dwSection != GPO_SECTION_USER) &&
        (dwSection != GPO_SECTION_MACHINE))
        return E_INVALIDARG;


    //
    // Build the path
    //

    HRESULT hr = StringCchCopy ( szPath,  ARRAYSIZE(szPath), m_pRSOPQueryResults->szWMINameSpace );
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (dwSection != GPO_SECTION_ROOT)
    {
        if (dwSection == GPO_SECTION_USER)
        {
            lpEnd = CheckSlash (szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), USER_SECTION);
        }
        else if (dwSection == GPO_SECTION_MACHINE)
        {
            lpEnd = CheckSlash (szPath);
            hr = StringCchCat (szPath, ARRAYSIZE(szPath), COMPUTER_SECTION);
        }
        else
        {
            return E_INVALIDARG;
        }

        if (FAILED(hr)) 
        {
            return hr;
        }
    }


    //
    // Save the name
    //

    if ((lstrlen (szPath) + 1) <= cchMaxLength)
    {
        hr = StringCchCopy (pszName, cchMaxLength, szPath);
        return hr;
    }

    return E_OUTOFMEMORY;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::GetFlags (DWORD * pdwFlags)
{
    if (!pdwFlags)
    {
        return E_INVALIDARG;
    }

    *pdwFlags = 0;
    if ( (m_pRSOPQuery != NULL) && (m_pRSOPQuery->QueryType == RSOP_LOGGING_MODE) )
    {
        *pdwFlags = RSOP_INFO_FLAG_DIAGNOSTIC_MODE;
    }

    return S_OK;
}

//-------------------------------------------------------

STDMETHODIMP CRSOPComponentData::GetEventLogEntryText (LPOLESTR pszEventSource,
                                                       LPOLESTR pszEventLogName,
                                                       LPOLESTR pszEventTime,
                                                       DWORD dwEventID,
                                                       LPOLESTR *ppszText)
{
    return ( m_CSELists.GetEvents() ? m_CSELists.GetEvents()->GetEventLogEntryText(pszEventSource, pszEventLogName, pszEventTime,
                                            dwEventID, ppszText) : E_NOINTERFACE);
}

//-------------------------------------------------------
// CRSOPComponentData object implementation (ISnapinHelp)

STDMETHODIMP CRSOPComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\rsopsnp.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::SetupFonts()
{
    HRESULT hr;
    LOGFONT BigBoldLogFont;
    LOGFONT BoldLogFont;
    HDC pdc = NULL;
    WCHAR largeFontSizeString[128];
    INT     largeFontSize;
    WCHAR smallFontSizeString[128];
    INT     smallFontSize;

    // Create the fonts we need based on the dialog font

    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof (ncm);
    if (SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0) == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


    BigBoldLogFont  = ncm.lfMessageFont;
    BoldLogFont     = ncm.lfMessageFont;

    // Create Big Bold Font and Bold Font

    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;


    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.

    if ( !LoadString (g_hInstance, IDS_LARGEFONTNAME, BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
        ASSERT (0);
        hr = StringCchCopy (BigBoldLogFont.lfFaceName, LF_FACESIZE, L"Verdana");
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    if ( LoadString (g_hInstance, IDS_LARGEFONTSIZE, largeFontSizeString, ARRAYSIZE(largeFontSizeString)) ) 
    {
        largeFontSize = wcstoul ((LPCWSTR) largeFontSizeString, NULL, 10);
    } 
    else 
    {
        ASSERT (0);
        largeFontSize = 12;
    }

    if ( !LoadString (g_hInstance, IDS_SMALLFONTNAME, BoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
        ASSERT (0);
        hr = StringCchCopy (BoldLogFont.lfFaceName, LF_FACESIZE, L"Verdana");
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    if ( LoadString (g_hInstance, IDS_SMALLFONTSIZE, smallFontSizeString, ARRAYSIZE(smallFontSizeString)) ) 
    {
        smallFontSize = wcstoul ((LPCWSTR) smallFontSizeString, NULL, 10);
    } 
    else 
    {
        ASSERT (0);
        smallFontSize = 8;
    }

    pdc = GetDC (NULL);

    if (pdc == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * largeFontSize / 72);
    BoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * smallFontSize / 72);

    m_BigBoldFont = CreateFontIndirect (&BigBoldLogFont);
    if (m_BigBoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    m_BoldFont = CreateFontIndirect (&BoldLogFont);
    if (m_BoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    hr = S_OK;

end:
    if (pdc != NULL) {
        ReleaseDC (NULL, pdc);
        pdc = NULL;
    }

    return hr;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPComponentData::RSOPGPOListMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData* pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData*) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        LoadString(g_hInstance, IDS_RSOP_GPOLIST_MACHINE, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg, IDC_STATIC1, szBuffer);

        if (pCD)
        {
            pCD->FillGPOList(hDlg, IDC_LIST1, pCD->m_GPOLists.GetComputerList(), FALSE, FALSE, FALSE, TRUE);
        }
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                switch (LOWORD(wParam))
                {
                case IDC_CHECK1:
                case IDC_CHECK2:
                case IDC_CHECK3:
                    {
                        pCD->FillGPOList(hDlg,
                                         IDC_LIST1,
                                         pCD->m_GPOLists.GetComputerList(),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK3), BM_GETCHECK, 0, 0),
                                         FALSE);
                    }
                    break;

                case IDC_BUTTON2:
                case IDM_GPOLIST_EDIT:
                    pCD->OnEdit(hDlg);
                    break;

                case IDC_BUTTON1:
                case IDM_GPOLIST_SECURITY:
                    pCD->OnSecurity(hDlg);
                    break;
                }
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_NOTIFY:
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

        if (pCD)
        {
            pCD->OnRefreshDisplay(hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        break;


    case WM_CONTEXTMENU:
        if (GetDlgItem(hDlg, IDC_LIST1) == (HWND)wParam)
        {
            pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                pCD->OnContextMenu(hDlg, lParam);
            }
        }
        else
        {
            // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        }
        return TRUE;

    }
    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPComponentData::RSOPGPOListUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData* pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData*) (((LPPROPSHEETPAGE)lParam)->lParam);

        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);
        LoadString(g_hInstance, IDS_RSOP_GPOLIST_USER, szBuffer, ARRAYSIZE(szBuffer));
        SetDlgItemText(hDlg, IDC_STATIC1, szBuffer);

        if (pCD)
        {
            pCD->FillGPOList(hDlg, IDC_LIST1, pCD->m_GPOLists.GetUserList(), FALSE, FALSE, FALSE, TRUE);
        }
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_COMMAND:
        {
            pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                switch (LOWORD(wParam))
                {
                case IDC_CHECK1:
                case IDC_CHECK2:
                case IDC_CHECK3:
                    {
                        pCD->FillGPOList(hDlg,
                                         IDC_LIST1,
                                         pCD->m_GPOLists.GetUserList(),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0),
                                         (BOOL) SendMessage(GetDlgItem(hDlg, IDC_CHECK3), BM_GETCHECK, 0, 0),
                                         FALSE);
                    }
                    break;

                case IDC_BUTTON2:
                case IDM_GPOLIST_EDIT:
                    pCD->OnEdit(hDlg);
                    break;

                case IDC_BUTTON1:
                case IDM_GPOLIST_SECURITY:
                    pCD->OnSecurity(hDlg);
                    break;
                }
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_NOTIFY:
        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

        if (pCD)
        {
            pCD->OnRefreshDisplay(hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        break;

    case WM_CONTEXTMENU:
        if (GetDlgItem(hDlg, IDC_LIST1) == (HWND)wParam)
        {
            pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (pCD)
            {
                pCD->OnContextMenu(hDlg, lParam);
            }
        }
        else
        {
            // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aGPOListHelpIds);
        }
        return TRUE;

    }
    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPComponentData::RSOPErrorsMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData* pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData*) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            pCD->InitializeErrorsDialog(hDlg, pCD->m_CSELists.GetComputerList());
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            if (LOWORD(wParam) == IDC_BUTTON1)
            {
                pCD->OnSaveAs(hDlg);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpHdr = (LPNMHDR)lParam;

            if (lpHdr->code == LVN_ITEMCHANGED)
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            pCD->RefreshErrorInfo (hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        break;


    case WM_CONTEXTMENU:
        // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        return TRUE;

    }
    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPComponentData::RSOPErrorsUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData* pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData*) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            pCD->InitializeErrorsDialog(hDlg, pCD->m_CSELists.GetUserList());
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_COMMAND:

        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            if (LOWORD(wParam) == IDC_BUTTON1)
            {
                pCD->OnSaveAs(hDlg);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpHdr = (LPNMHDR)lParam;

            if (lpHdr->code == LVN_ITEMCHANGED)
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
        }
        break;
        break;

    case WM_REFRESHDISPLAY:
        pCD = (CRSOPComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);
        if (pCD)
        {
            pCD->RefreshErrorInfo (hDlg);
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        break;


    case WM_CONTEXTMENU:
        // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aErrorsHelpIds);
        return TRUE;

    }
    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPComponentData::QueryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR szBuffer[MAX_PATH];
    CRSOPComponentData * pCD;

    switch (message)
    {
    case WM_INITDIALOG:
        pCD = (CRSOPComponentData *) (((LPPROPSHEETPAGE)lParam)->lParam);
        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

        if (pCD)
        {
            CRSOPWizard::InitializeResultsList (GetDlgItem(hDlg, IDC_LIST1));
            CRSOPWizard::FillResultsList (GetDlgItem(hDlg, IDC_LIST1), pCD->m_pRSOPQuery, pCD->m_pRSOPQueryResults);
        }

        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (ULONG_PTR) (LPSTR) aQueryHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (ULONG_PTR) (LPSTR) aQueryHelpIds);
        return (TRUE);

    }
    return FALSE;
}

//-------------------------------------------------------
// Dialog event handlers

void CRSOPComponentData::OnEdit(HWND hDlg)
{
    HWND hLV;
    LVITEM item;
    LPGPOLISTITEM lpItem;
    INT i;
    SHELLEXECUTEINFO ExecInfo;
    TCHAR szArgs[MAX_PATH + 30];

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }


    ZeroMemory (&item, sizeof(item));
    item.mask = LVIF_PARAM;
    item.iItem = i;

    if (!ListView_GetItem (hLV, &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    if (lpItem->lpDSPath)
    {
        if (!SpawnGPE(lpItem->lpDSPath, GPHintUnknown, NULL, hDlg))
        {
            ReportError (hDlg, GetLastError(), IDS_SPAWNGPEFAILED);
        }
    }
    else
    {
        ZeroMemory (&ExecInfo, sizeof(ExecInfo));
        ExecInfo.cbSize = sizeof(ExecInfo);
        ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
        ExecInfo.lpVerb = TEXT("open");
        ExecInfo.lpFile = TEXT("gpedit.msc");
        ExecInfo.nShow = SW_SHOWNORMAL;

        LPTSTR szComputerName = NULL;
        if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
        {
            szComputerName = m_pRSOPQuery->pComputer->szName;
        }
        else
        {
            szComputerName = m_pRSOPQuery->szComputerName;
        }
        
        if ( lstrcmpi(szComputerName, TEXT(".")))
        {
            HRESULT hr = StringCchPrintf (szArgs, 
                                          ARRAYSIZE(szArgs), 
                                          TEXT("/gpcomputer:\"%s\" /gphint:1"), 
                                          szComputerName);
            if (FAILED(hr)) 
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnEdit: Could not copy computer name with %d"), hr));
                ReportError(NULL, GetLastError(), IDS_SPAWNGPEFAILED);
                return;
            }
            ExecInfo.lpParameters = szArgs;
        }

        if (ShellExecuteEx (&ExecInfo))
        {
            SetWaitCursor();
            WaitForInputIdle (ExecInfo.hProcess, 10000);
            ClearWaitCursor();
            CloseHandle (ExecInfo.hProcess);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnEdit: ShellExecuteEx failed with %d"),
                     GetLastError()));
            ReportError(NULL, GetLastError(), IDS_SPAWNGPEFAILED);
        }
    }
}

//-------------------------------------------------------

void CRSOPComponentData::OnSecurity(HWND hDlg)
{
    HWND hLV;
    INT i;
    HRESULT hr;
    LVITEM item;
    LPGPOLISTITEM lpItem;
    TCHAR szGPOName[MAX_FRIENDLYNAME];
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE hPages[2];

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }


    ZeroMemory (&item, sizeof(item));
    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = i;
    item.pszText = szGPOName;
    item.cchTextMax = ARRAYSIZE(szGPOName);

    if (!ListView_GetItem (hLV, &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    //
    // Create the security page
    //

    hr = DSCreateSecurityPage (lpItem->lpDSPath, L"groupPolicyContainer",
                                    DSSI_IS_ROOT | DSSI_READ_ONLY,
                                    &hPages[0], ReadSecurityDescriptor,
                                    WriteSecurityDescriptor, (LPARAM)lpItem);

    if (FAILED(hr))
    {
        return;
    }


    //
    // Display the property sheet
    //

    ZeroMemory (&psh, sizeof(psh));
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_PROPTITLE;
    psh.hwndParent = hDlg;
    psh.hInstance = g_hInstance;
    psh.pszCaption = szGPOName;
    psh.nPages = 1;
    psh.phpage = hPages;

    PropertySheet (&psh);
}

//-------------------------------------------------------

void CRSOPComponentData::OnRefreshDisplay(HWND hDlg)
{
    INT iIndex;
    LVITEM item;
    LPGPOLISTITEM lpItem;


    iIndex = ListView_GetNextItem (GetDlgItem(hDlg, IDC_LIST1), -1,
                                   LVNI_ALL | LVNI_SELECTED);

    if (iIndex != -1)
    {

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (GetDlgItem(hDlg, IDC_LIST1), &item))
        {
            return;
        }

        lpItem = (LPGPOLISTITEM) item.lParam;

        if (lpItem->pSD)
        {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
        }
        else
        {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
        }

        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
    }
}

//-------------------------------------------------------

void CRSOPComponentData::OnContextMenu(HWND hDlg, LPARAM lParam)
{
    LPGPOLISTITEM lpItem;
    LVITEM item;
    HMENU hPopup;
    HWND hLV;
    int i;
    RECT rc;
    POINT pt;

    //
    // Get the selected item (if any)
    //

    hLV = GetDlgItem (hDlg, IDC_LIST1);
    i = ListView_GetNextItem(hLV, -1, LVNI_SELECTED);

    if (i < 0)
    {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = i;
    item.iSubItem = 0;

    if (!ListView_GetItem (GetDlgItem(hDlg, IDC_LIST1), &item))
    {
        return;
    }

    lpItem = (LPGPOLISTITEM) item.lParam;


    //
    // Figure out where to place the context menu
    //

    pt.x = ((int)(short)LOWORD(lParam));
    pt.y = ((int)(short)HIWORD(lParam));

    GetWindowRect (hLV, &rc);

    if (!PtInRect (&rc, pt))
    {
        if ((lParam == (LPARAM) -1) && (i >= 0))
        {
            rc.left = LVIR_SELECTBOUNDS;
            SendMessage (hLV, LVM_GETITEMRECT, i, (LPARAM) &rc);

            pt.x = rc.left + 8;
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);

            ClientToScreen (hLV, &pt);
        }
        else
        {
            pt.x = rc.left + ((rc.right - rc.left) / 2);
            pt.y = rc.top + ((rc.bottom - rc.top) / 2);
        }
    }


    //
    // Load the context menu
    //


    hPopup = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDM_GPOLIST_CONTEXTMENU));

    if (!hPopup) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnContextMenu: LoadMenu failed with %d"),
                 GetLastError()));
        return;
    }

    if (!(lpItem->pSD)) {
        DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::OnContextMenu: Disabling Security menu item")));
        EnableMenuItem(GetSubMenu(hPopup, 0), IDM_GPOLIST_SECURITY, MF_GRAYED);
        DrawMenuBar(hDlg);
    }

    //
    // Display the menu
    //

    TrackPopupMenu(GetSubMenu(hPopup, 0), TPM_LEFTALIGN, pt.x, pt.y, 0, hDlg, NULL);

    DestroyMenu(hPopup);
}

//-------------------------------------------------------

void CRSOPComponentData::OnSaveAs (HWND hDlg)
{
    OPENFILENAME ofn;
    TCHAR szFilter[100];
    LPTSTR lpTemp;
    TCHAR szFile[2*MAX_PATH];
    HANDLE hFile;
    DWORD dwSize, dwBytesWritten;


    //
    // Load the filter string and replace the # signs with nulls
    //

    LoadString (g_hInstance, IDS_ERRORFILTER, szFilter, ARRAYSIZE(szFilter));


    lpTemp = szFilter;

    while (*lpTemp)
    {
        if (*lpTemp == TEXT('#'))
            *lpTemp = TEXT('\0');

        lpTemp++;
    }


    //
    // Call the Save common dialog
    //

    szFile[0] = TEXT('\0');
    ZeroMemory (&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrDefExt = TEXT("txt");
    ofn.Flags = OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST;

    if (!GetSaveFileName (&ofn))
    {
        return;
    }


    SetWaitCursor ();

    //
    // Create the text file
    //

    hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: CreateFile failed with %d"), GetLastError()));
        ClearWaitCursor ();
        return;
    }


    //
    // Get the text out of the edit control
    //

    dwSize = (DWORD) SendDlgItemMessage (hDlg, IDC_EDIT1, WM_GETTEXTLENGTH, 0, 0);

    lpTemp = (LPTSTR) LocalAlloc (LPTR, (dwSize+2) * sizeof(TCHAR));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: LocalAlloc failed with %d"), GetLastError()));
        CloseHandle (hFile);
        ClearWaitCursor ();
        return;
    }

    SendDlgItemMessage (hDlg, IDC_EDIT1, WM_GETTEXT, (dwSize+1), (LPARAM) lpTemp);



    //
    // Save it to the new file
    //

    WriteFile(hFile, L"\xfeff\r\n", 3 * sizeof(WCHAR), &dwBytesWritten, NULL);

    if (!WriteFile (hFile, lpTemp, (dwSize * sizeof(TCHAR)), &dwBytesWritten, NULL) ||
        (dwBytesWritten != (dwSize * sizeof(TCHAR))))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::OnSaveAs: Failed to text with %d"),
                 GetLastError()));
    }


    LocalFree (lpTemp);
    CloseHandle (hFile);
    ClearWaitCursor ();

}

//-------------------------------------------------------
// Dialog helper methods

void CRSOPComponentData::InitializeErrorsDialog(HWND hDlg, LPCSEITEM lpList)
{
    RECT rect;
    WCHAR szBuffer[256];
    LV_COLUMN lvcol;
    LONG lWidth;
    INT cxName = 0, cxStatus = 0, iIndex = 0, iDefault = 0;
    DWORD dwCount = 0;
    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
    LPCSEITEM lpTemp;
    LVITEM item;
    GUID guid;
    BOOL bGPCoreFailed = FALSE;


    //
    // Count the number of components
    //

    lpTemp = lpList;

    while (lpTemp)
    {
        lpTemp = lpTemp->pNext;
        dwCount++;
    }


    //
    // Decide on the column widths
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    cxStatus = (lWidth * 35) / 100;
    cxName = lWidth - cxStatus;


    //
    // Insert the component name column and then the status column
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.pszText = szBuffer;
    lvcol.cx = cxName;
    LoadString(g_hInstance, IDS_COMPONENT_NAME, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hList, 0, &lvcol);


    lvcol.cx = cxStatus;
    LoadString(g_hInstance, IDS_STATUS, szBuffer, ARRAYSIZE(szBuffer));
    ListView_InsertColumn(hList, 1, &lvcol);


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Insert the CSE's
    //

    lpTemp = lpList;

    while (lpTemp)
    {
        ZeroMemory (&item, sizeof(item));

        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = iIndex;
        item.pszText = lpTemp->lpName;
        item.lParam = (LPARAM) lpTemp;
        iIndex = ListView_InsertItem (hList, &item);


        if (bGPCoreFailed)
        {
            LoadString(g_hInstance, IDS_CSE_NA, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if ((lpTemp->dwStatus == ERROR_SUCCESS) && (lpTemp->ulLoggingStatus != 2))
        {
            if (lpTemp->ulLoggingStatus == 3)
            {
                LoadString(g_hInstance, IDS_SUCCESS2, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_SUCCESS, szBuffer, ARRAYSIZE(szBuffer));
            }
        }
        else if (lpTemp->dwStatus == E_PENDING)
        {
            LoadString(g_hInstance, IDS_PENDING, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpTemp->dwStatus == ERROR_OVERRIDE_NOCHANGES)
        {
            LoadString(g_hInstance, IDS_WARNING, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpTemp->dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED)
        {
            //
            // If policy application was delayed, we don't want to say that it has
            // failed, so we display a special indicator in that case
            //
            if (lpTemp->ulLoggingStatus == 3)
            {
                LoadString(g_hInstance, IDS_POLICY_DELAYED2, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_POLICY_DELAYED, szBuffer, ARRAYSIZE(szBuffer));
            }
        }
        else
        {
            if (lpTemp->ulLoggingStatus == 3)
            {
                LoadString(g_hInstance, IDS_FAILED2, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_FAILED, szBuffer, ARRAYSIZE(szBuffer));
            }
        }


        item.mask = LVIF_TEXT;
        item.pszText = szBuffer;
        item.iItem = iIndex;
        item.iSubItem = 1;
        ListView_SetItem(hList, &item);


        //
        // Check if GPCore failed
        //

        StringToGuid( lpTemp->lpGUID, &guid);

        if (IsNullGUID (&guid))
        {
            if (lpTemp->dwStatus != ERROR_SUCCESS)
            {
                bGPCoreFailed = TRUE;
            }
        }

        lpTemp = lpTemp->pNext;
        iIndex++;
    }


    //
    // Select the first non-successful item
    //


    iIndex = 0;

    while (iIndex < ListView_GetItemCount(hList))
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = LVIF_PARAM;
        item.iItem = iIndex;

        if (!ListView_GetItem (hList, &item))
        {
            break;
        }

        if (item.lParam)
        {
            lpTemp = (LPCSEITEM) item.lParam;

            if ((lpTemp->dwStatus != ERROR_SUCCESS) || (lpTemp->ulLoggingStatus == 2))
            {
                iDefault = iIndex;
                break;
            }
        }

        iIndex++;
    }

    item.mask = LVIF_STATE;
    item.iItem = iDefault;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, iDefault, (LPARAM) &item);
    SendMessage (hList, LVM_ENSUREVISIBLE, iDefault, FALSE);
}

//-------------------------------------------------------

void CRSOPComponentData::RefreshErrorInfo (HWND hDlg)
{
    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
    HWND hEdit = GetDlgItem(hDlg, IDC_EDIT1);
    LPCSEITEM lpItem;
    LVITEM item;
    INT iIndex;
    TCHAR szBuffer[300];
    LPTSTR lpMsg;
    TCHAR szDate[100];
    TCHAR szTime[100];
    TCHAR szFormat[80];
    FILETIME ft, ftLocal;
    SYSTEMTIME systime;
    LPOLESTR lpEventLogText = NULL;
    CHARFORMAT2 chFormat;
    BOOL bBold = FALSE;
    GUID guid;
    HRESULT hr;

    iIndex = ListView_GetNextItem (hList, -1, LVNI_ALL | LVNI_SELECTED);

    if (iIndex != -1)
    {
        //
        // Get the CSEITEM pointer
        //

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hList, &item))
        {
            return;
        }

        lpItem = (LPCSEITEM) item.lParam;

        if (!lpItem)
        {
            return;
        }


        SendMessage (hEdit, WM_SETREDRAW, FALSE, 0);

        //
        // Set the time information
        //

        SendMessage (hEdit, EM_SETSEL, 0, (LPARAM) -1);

        SystemTimeToFileTime (&lpItem->EndTime, &ft);
        FileTimeToLocalFileTime (&ft, &ftLocal);
        FileTimeToSystemTime (&ftLocal, &systime);


        GetDateFormat (LOCALE_USER_DEFAULT, DATE_LONGDATE, &systime,
                       NULL, szDate, ARRAYSIZE (szDate));

        GetTimeFormat (LOCALE_USER_DEFAULT, 0, &systime,
                       NULL, szTime, ARRAYSIZE (szTime));

        LoadString (g_hInstance, IDS_DATETIMEFORMAT, szFormat, ARRAYSIZE(szFormat));
        (void) StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), szFormat, szDate, szTime);

        //
        // Turn italic on
        //

        ZeroMemory (&chFormat, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_ITALIC;
        chFormat.dwEffects = CFE_ITALIC;

        SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                     (LPARAM) &chFormat);


        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);


        if (lpItem->ulLoggingStatus == 3)
        {
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n\r\n"));

            LoadString(g_hInstance, IDS_LEGACYCSE, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);

            LoadString(g_hInstance, IDS_LEGACYCSE1, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
        }


        //
        // Turn italic off
        //

        ZeroMemory (&chFormat, sizeof(chFormat));
        chFormat.cbSize = sizeof(chFormat);
        chFormat.dwMask = CFM_ITALIC;

        SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                     (LPARAM) &chFormat);


        //
        // Put a blank line in between the time and the main message
        //

        SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n\r\n"));


        //
        // Set the main message
        //

        if (lpItem->ulLoggingStatus == 2)
        {
            if ( lpItem->dwStatus == ERROR_SUCCESS )
                LoadString(g_hInstance, IDS_LOGGINGFAILED, szBuffer, ARRAYSIZE(szBuffer));
            else
                LoadString(g_hInstance, IDS_FAILEDMSG2, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }
        else if (lpItem->dwStatus == ERROR_SUCCESS)
        {
            LoadString(g_hInstance, IDS_SUCCESSMSG, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpItem->dwStatus == E_PENDING)
        {
            LoadString(g_hInstance, IDS_PENDINGMSG, szBuffer, ARRAYSIZE(szBuffer));
        }
        else if (lpItem->dwStatus == ERROR_OVERRIDE_NOCHANGES)
        {
            LoadString(g_hInstance, IDS_OVERRIDE, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }
        else if (lpItem->dwStatus == ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED)
        {
            if (lpItem->bUser)
            {
                LoadString(g_hInstance, IDS_SYNC_REQUIRED_USER, szBuffer, ARRAYSIZE(szBuffer));
            }
            else
            {
                LoadString(g_hInstance, IDS_SYNC_REQUIRED_MACH, szBuffer, ARRAYSIZE(szBuffer));
            }

            bBold = TRUE;
        }
        else
        {
            LoadString(g_hInstance, IDS_FAILEDMSG1, szBuffer, ARRAYSIZE(szBuffer));
            bBold = TRUE;
        }


        if (bBold)
        {
            //
            // Turn bold on
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;
            chFormat.dwEffects = CFE_BOLD;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);
        }

        ULONG ulNoChars = lstrlen(lpItem->lpName) + lstrlen(szBuffer) + 1;
        lpMsg = (LPTSTR) LocalAlloc(LPTR, ulNoChars * sizeof(TCHAR));

        if (lpMsg) 
        {
            hr = StringCchPrintf (lpMsg, ulNoChars, szBuffer, lpItem->lpName);
            if (FAILED(hr)) 
            {
                LocalFree(lpMsg);
                lpMsg = NULL;
            }
        }

        if (!lpMsg)
        {
            SendMessage (hEdit, WM_SETREDRAW, TRUE, 0);
            InvalidateRect (hEdit, NULL, TRUE);
            UpdateWindow (hEdit);
            return;
        }

        SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
        SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpMsg);
        LocalFree (lpMsg);


        //
        // Even if the CSE was successful or if it returned E_PENDING, continue on to get the
        // eventlog msgs
        //

        StringToGuid( lpItem->lpGUID, &guid);

        if (!((lpItem->dwStatus == ERROR_SUCCESS) || (lpItem->dwStatus == E_PENDING)))
        {
            //
            // Print the error code if appropriate
            //

            if (lpItem->dwStatus != ERROR_OVERRIDE_NOCHANGES && lpItem->dwStatus != ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED )
            {
                lpMsg = (LPTSTR) LocalAlloc(LPTR, 300 * sizeof(TCHAR));

                if (lpMsg)
                {
                    LoadMessage (lpItem->dwStatus, lpMsg, 300);

                    SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                    SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpMsg);

                    LocalFree (lpMsg);
                }
            }


            //
            // Special case GPCore to have an additional message
            //

            if (IsNullGUID (&guid))
            {
                LoadString(g_hInstance, IDS_GPCOREFAIL, szBuffer, ARRAYSIZE(szBuffer));
                SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
            }

        }
        else {

            if (lpItem->ulLoggingStatus == 2) {

                //
                // Special case GPCore to have an additional message if logging failed
                //

                if (IsNullGUID (&guid))
                {
                    LoadString(g_hInstance, IDS_GPCORE_LOGGINGFAIL, szBuffer, ARRAYSIZE(szBuffer));
                    SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
                    SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);
                }
            }
        }


        if (bBold)
        {
            //
            // Turn bold off
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_BOLD;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);
        }


        //
        // Get any event log text for this CSE
        //

        if (m_CSELists.GetEvents() && SUCCEEDED(m_CSELists.GetEvents()->GetCSEEntries(&lpItem->BeginTime, &lpItem->EndTime,
                                                            lpItem->lpEventSources, &lpEventLogText,
                                                            (IsNullGUID (&guid)))))
        {
            //
            // Put a blank line between the main message and the Additional information header
            //

            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n"));


            //
            // Turn underline on
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINETYPE | CFM_UNDERLINE;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.bUnderlineType = CFU_UNDERLINE;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);

            LoadString(g_hInstance, IDS_ADDITIONALINFO, szBuffer, ARRAYSIZE(szBuffer));
            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) szBuffer);


            //
            // Turn underline off
            //

            ZeroMemory (&chFormat, sizeof(chFormat));
            chFormat.cbSize = sizeof(chFormat);
            chFormat.dwMask = CFM_UNDERLINETYPE | CFM_UNDERLINE;
            chFormat.dwEffects = CFE_UNDERLINE;
            chFormat.bUnderlineType = CFU_UNDERLINENONE;

            SendMessage (hEdit, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD,
                         (LPARAM) &chFormat);


            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) TEXT("\r\n"));


            //
            //  Add the event log info to the edit control
            //

            SendMessage (hEdit, EM_SETSEL, (WPARAM)-1, (LPARAM) -1);
            SendMessage (hEdit, EM_REPLACESEL, 0, (LPARAM) lpEventLogText);

            CoTaskMemFree (lpEventLogText);
        }

        SendMessage (hEdit, EM_SETSEL, 0, 0);
        SendMessage (hEdit, EM_SCROLLCARET, 0, 0);

        SendMessage (hEdit, WM_SETREDRAW, TRUE, 0);
        InvalidateRect (hEdit, NULL, TRUE);
        UpdateWindow (hEdit);
    }

}

//-------------------------------------------------------

HRESULT WINAPI CRSOPComponentData::ReadSecurityDescriptor (LPCWSTR lpGPOPath,
                                                           SECURITY_INFORMATION si,
                                                           PSECURITY_DESCRIPTOR *pSD,
                                                           LPARAM lpContext)
{
    LPGPOLISTITEM lpItem;
    HRESULT hr;


    lpItem = (LPGPOLISTITEM) lpContext;

    if (!lpItem)
    {
        return E_FAIL;
    }

    if (si & DACL_SECURITY_INFORMATION)
    {
        *pSD = lpItem->pSD;
    }
    else
    {
        *pSD = NULL;
    }

    return S_OK;
}

//-------------------------------------------------------

HRESULT WINAPI CRSOPComponentData::WriteSecurityDescriptor (LPCWSTR lpGPOPath,
                                                            SECURITY_INFORMATION si,
                                                            PSECURITY_DESCRIPTOR pSD,
                                                            LPARAM lpContext)
{
    return S_OK;
}

//-------------------------------------------------------

void CRSOPComponentData::FillGPOList(HWND hDlg, DWORD dwListID, LPGPOLISTITEM lpList,
                                     BOOL bSOM, BOOL bFiltering, BOOL bVersion, BOOL bInitial)
{
    LV_COLUMN lvcol;
    HWND hList;
    LV_ITEM item;
    int iItem;
    TCHAR szVersion[80];
    TCHAR szVersionFormat[50];
    INT iColIndex, iDefault = 0;
    LPGPOLISTITEM lpItem, lpDefault = NULL;
    DWORD dwCount = 0;
    LVFINDINFO FindInfo;
    HRESULT hr;
    ULONG ulNoChars;


    LoadString(g_hInstance, IDS_VERSIONFORMAT, szVersionFormat, ARRAYSIZE(szVersionFormat));

    hList = GetDlgItem(hDlg, dwListID);
    ListView_DeleteAllItems(hList);

    lpItem = lpList;

    while (lpItem)
    {
        if (bInitial)
        {
            if (LOWORD(lpItem->dwVersion) != HIWORD(lpItem->dwVersion))
            {
                bVersion = TRUE;
                CheckDlgButton (hDlg, IDC_CHECK3, BST_CHECKED);
            }
        }
        lpItem = lpItem->pNext;
        dwCount++;
    }


    PrepGPOList(hList, bSOM, bFiltering, bVersion, dwCount);

    lpItem = lpList;

    while (lpItem)
    {
        if (lpItem->bApplied || bFiltering)
        {
            hr = StringCchPrintf (szVersion, 
                                  ARRAYSIZE(szVersion), 
                                  szVersionFormat, 
                                  LOWORD(lpItem->dwVersion), 
                                  HIWORD(lpItem->dwVersion));
            if (FAILED(hr)) 
            {
                lpItem = lpItem->pNext;
                continue;
            }

            iColIndex = 0;
            memset(&item, 0, sizeof(item));
            item.mask = LVIF_TEXT | LVIF_PARAM;
            item.pszText = lpItem->lpGPOName;
            item.iItem = 0;
            item.lParam = (LPARAM) lpItem;
            iItem = ListView_InsertItem(hList, &item);
            iColIndex++;

            if (bInitial)
            {
                if (LOWORD(lpItem->dwVersion) != HIWORD(lpItem->dwVersion))
                {
                    lpDefault = lpItem;
                }
            }

            if (bFiltering)
            {
                item.mask = LVIF_TEXT;
                item.pszText = lpItem->lpFiltering;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
                iColIndex++;
            }

            if (bSOM)
            {
                item.mask = LVIF_TEXT;
                item.pszText = lpItem->lpUnescapedSOM;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
                iColIndex++;
            }

            if (bVersion)
            {
                item.mask = LVIF_TEXT;
                item.pszText = szVersion;
                item.iItem = iItem;
                item.iSubItem = iColIndex;
                ListView_SetItem(hList, &item);
            }
        }

        lpItem = lpItem->pNext;
    }


    if (lpDefault)
    {
        ZeroMemory (&FindInfo, sizeof(FindInfo));
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM) lpDefault;

        iDefault = ListView_FindItem(hList, -1, &FindInfo);

        if (iDefault == -1)
        {
            iDefault = 0;
        }
    }

    // Select a item

    item.mask = LVIF_STATE;
    item.iItem = iDefault;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, (WPARAM)iDefault, (LPARAM) &item);
    SendMessage (hList, LVM_ENSUREVISIBLE, iDefault, FALSE);

}

//-------------------------------------------------------

void CRSOPComponentData::PrepGPOList(HWND hList, BOOL bSOM, BOOL bFiltering,
                                     BOOL bVersion, DWORD dwCount)
{
    RECT rect;
    WCHAR szHeading[256];
    LV_COLUMN lvcol;
    LONG lWidth;
    INT cxName = 0, cxSOM = 0, cxFiltering = 0, cxVersion = 0, iTotal = 0;
    INT iColIndex = 0;


    //
    // Delete any previous columns
    //

    SendMessage (hList, LVM_DELETECOLUMN, 3, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 2, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 1, 0);
    SendMessage (hList, LVM_DELETECOLUMN, 0, 0);


    //
    // Decide on the column widths
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    if (bFiltering)
    {
        cxFiltering = (lWidth * 30) / 100;
        iTotal += cxFiltering;
    }

    if (bVersion)
    {
        cxVersion = (lWidth * 30) / 100;
        iTotal += cxVersion;
    }

    if (bSOM)
    {
        cxSOM = (lWidth - iTotal) / 2;
        iTotal += cxSOM;
        cxName = lWidth - iTotal;
    }
    else
    {
        cxName = lWidth - iTotal;
    }


    //
    // Insert the GPO Name column and then any appropriate columns
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.pszText = szHeading;
    lvcol.cx = cxName;
    LoadString(g_hInstance, IDS_GPO_NAME, szHeading, ARRAYSIZE(szHeading));
    ListView_InsertColumn(hList, iColIndex, &lvcol);
    iColIndex++;


    if (bFiltering)
    {
        lvcol.cx = cxFiltering;
        LoadString(g_hInstance, IDS_FILTERING, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
        iColIndex++;
    }

    if (bSOM)
    {
        lvcol.cx = cxSOM;
        LoadString(g_hInstance, IDS_SOM, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
        iColIndex++;
    }

    if (bVersion)
    {
        lvcol.cx = cxVersion;
        LoadString(g_hInstance, IDS_VERSION, szHeading, ARRAYSIZE(szHeading));
        ListView_InsertColumn(hList, iColIndex, &lvcol);
    }


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

}

//-------------------------------------------------------
// Dialog methods for loading RSOP data from archive

INT_PTR CALLBACK CRSOPComponentData::InitArchivedRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CRSOPComponentData * pCD;
    HRESULT hr = S_OK;
    TCHAR szMessage[200];


    switch (message)
    {
        case WM_INITDIALOG:
        {
            pCD = (CRSOPComponentData *) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            if (pCD)
            {
                CRSOPWizard::InitializeResultsList (GetDlgItem (hDlg, IDC_LIST1));
                CRSOPWizard::FillResultsList (GetDlgItem (hDlg, IDC_LIST1), pCD->m_pRSOPQuery, pCD->m_pRSOPQueryResults);

                LoadString(g_hInstance, IDS_PLEASEWAIT1, szMessage, ARRAYSIZE(szMessage));
                SetWindowText(GetDlgItem(hDlg, IDC_STATIC1), szMessage);
                ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS1), SW_HIDE);
            }

            PostMessage(hDlg, WM_INITRSOP, 0, 0);
            return TRUE;
        }

        case WM_INITRSOP:

            pCD = (CRSOPComponentData *) GetWindowLongPtr (hDlg, DWLP_USER);
                        
            hr = pCD->InitializeRSOPFromArchivedData(pCD->m_pStm);

            if (hr != S_OK)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitArchivedRsopDlgProc: InitializeRSOPFromArchivedData failed with 0x%x."), hr));
                EndDialog(hDlg, 0);
                return TRUE;
            }

            EndDialog(hDlg, 1);
            return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::DeleteArchivedRSOPNamespace()
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    BSTR bstrParam = NULL;
    LPTSTR lpTemp = NULL;
    BSTR bstrTemp = NULL;
    HRESULT hr = S_OK;

    if ( m_pRSOPQueryResults->szWMINameSpace != NULL )
    {
        LocalFree( m_pRSOPQueryResults->szWMINameSpace );
        m_pRSOPQueryResults->szWMINameSpace = NULL;
    }
    LocalFree( m_pRSOPQueryResults );
    m_pRSOPQueryResults = NULL;
    
    // Delete the namespace
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Delete the namespace we created when loading the data
    bstrParam = SysAllocString(TEXT("\\\\.\\root\\rsop"));

    if (!bstrParam)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pLocator->ConnectServer(bstrParam,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pNamespace,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Allocate a temp buffer to store the fully qualified path in
    ULONG ulNoChars = lstrlen(m_szArchivedDataGuid) + 30;
    lpTemp = new TCHAR [ulNoChars];

    if (!lpTemp)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    hr = StringCchPrintf (lpTemp, ulNoChars, TEXT("__Namespace.name=\"%ws\""), m_szArchivedDataGuid);
    if ( FAILED(hr)) 
    {
        goto Cleanup;
    }

    // Delete the namespace
    bstrTemp = SysAllocString (lpTemp);

    if (!bstrTemp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pNamespace->DeleteInstance( bstrTemp, 0, NULL, NULL);


Cleanup:
    if (lpTemp)
    {
        delete [] lpTemp;
    }

    if (bstrTemp)
    {
        SysFreeString(bstrTemp);
    }

    if (bstrParam)
    {
        SysFreeString(bstrParam);
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    return hr;
}

STDMETHODIMP CRSOPComponentData::InitializeRSOPFromArchivedData(IStream *pStm)
{
    HRESULT hr;
    TCHAR szNameSpace[100];
    GUID guid;
    LPTSTR lpEnd, lpFileName, lpTemp;

    // Create a guid to work with

    hr = CoCreateGuid( &guid );

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CoCreateGuid failed with 0x%x"), hr));
        return hr;
    }

    hr = StringCchPrintf ( m_szArchivedDataGuid,
                           ARRAYSIZE(m_szArchivedDataGuid),
                           L"NS%08lX_%04X_%04X_%02X%02X_%02X%02X%02X%02X%02X%02X",
                           guid.Data1,
                           guid.Data2,
                           guid.Data3,
                           guid.Data4[0], guid.Data4[1],
                           guid.Data4[2], guid.Data4[3],
                           guid.Data4[4], guid.Data4[5],
                           guid.Data4[6], guid.Data4[7] );
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, 
                  TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Coudl not copy Archived data guid with 0x%x"),
                  hr));
        return hr;
    }

    hr = StringCchCopy (szNameSpace, ARRAYSIZE(szNameSpace), TEXT("\\\\.\\root\\rsop"));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, 
                  TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Coudl not copy data with 0x%x"),
                  hr));
        return hr;
    }

    // Build the parent namespace

    hr = CreateNameSpace (m_szArchivedDataGuid, szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }

    lpEnd = CheckSlash (szNameSpace);
    hr = StringCchCat (szNameSpace, ARRAYSIZE(szNameSpace),m_szArchivedDataGuid );
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }

    // Build the user subnamespace

    hr = CreateNameSpace (TEXT("User"), szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }

    // Build the computer subnamespace

    hr = CreateNameSpace (TEXT("Computer"), szNameSpace);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CreateNameSpace failed with 0x%x"), hr));
        return hr;
    }

    // Save the namespace for future use

    ULONG ulNoChars = lstrlen(szNameSpace) + 1;
    m_pRSOPQueryResults->szWMINameSpace = (LPTSTR)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );

    if ( m_pRSOPQueryResults->szWMINameSpace == NULL ) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Failed to allocate memory with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = StringCchCopy ( m_pRSOPQueryResults->szWMINameSpace, ulNoChars, szNameSpace );
    ASSERT(SUCCEEDED(hr));

    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Namespace name is: %s"), szNameSpace));

    // Make a copy of the namespace that we can manipulate (to load the data with)

    ulNoChars = lstrlen(szNameSpace) + 10;
    lpTemp = new TCHAR[ulNoChars];

    if (!lpTemp) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Failed to allocate memory with %d"), GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    hr = StringCchCopy( lpTemp, ulNoChars, m_pRSOPQueryResults->szWMINameSpace );
    ASSERT(SUCCEEDED(hr));

    ULONG ulNoRemChars;

    lpEnd = CheckSlash (lpTemp);
    ulNoRemChars = ulNoChars - lstrlen(lpTemp);
    hr = StringCchCat (lpTemp, ulNoChars, TEXT("Computer"));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, 
                  TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Could not copy WMI name space with 0x%x"), 
                  hr));
        delete [] lpTemp;
        return hr;
    }

    // Extract the computer data to a temp file

    hr = CopyMSCToFile (pStm, &lpFileName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CopyMSCToFile failed with 0x%x"), hr));
        delete [] lpTemp;
        return hr;
    }

    // Use the mof compiler to pull the data from the file and put it in the new namespace

    hr = ImportRSoPData (lpTemp, lpFileName);

    DeleteFile (lpFileName);
    delete [] lpFileName;

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: ImportRSoPData failed with 0x%x"), hr));
        delete [] lpTemp;
        return hr;
    }

    // Now extract the user data to a temp file

    hr = StringCchCopy (lpEnd, ulNoRemChars, TEXT("User"));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, 
                  TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: Could not copy WMI name space with 0x%x"), 
                  hr));
        delete [] lpTemp;
        return hr;
    }


    hr = CopyMSCToFile (pStm, &lpFileName);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: CopyMSCToFile failed with 0x%x"), hr));
        delete [] lpTemp;
        return hr;
    }

    // Use the mof compiler to pull the data from the file and put it in the new namespace

    hr = ImportRSoPData (lpTemp, lpFileName);

    DeleteFile (lpFileName);
    delete [] lpFileName;

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: ImportRSoPData failed with 0x%x"), hr));
        delete [] lpTemp;
        return hr;
    }

    delete [] lpTemp;


    // Pull the event log information and initialize the database
    hr = m_CSELists.GetEvents()->LoadEntriesFromStream(pStm);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOPFromArchivedData: LoadEntriesFromStream failed with 0x%x."), hr));
        return hr;
    }

    // Build the common data structures used by various property sheets
    m_GPOLists.Build( m_pRSOPQueryResults->szWMINameSpace );
    m_CSELists.Build( m_pRSOPQuery, m_pRSOPQueryResults->szWMINameSpace, m_bGetExtendedErrorInfo );

    if ( m_CSELists.GetEvents() )
    {
        m_CSELists.GetEvents()->DumpDebugInfo();
    }

    // Build the display name

    BuildDisplayName();

    m_bInitialized = TRUE;

    return S_OK;
}

//-------------------------------------------------------

HRESULT CRSOPComponentData::InitializeRSOP( BOOL bShowWizard )
{
    HRESULT hr;
    _CExtendedProcessing extendedProcessing( m_bGetExtendedErrorInfo, m_GPOLists, m_CSELists );

    // if the UI is launched with namespace specification, there is nothing more to be done here
    // no query needs to be run etc.
    if (!m_bNamespaceSpecified)
    {
        if ( !m_bInitialized )
        {
            if ( m_pRSOPQuery == NULL )
            {
                if ( !CreateRSOPQuery( &m_pRSOPQuery, RSOP_UNKNOWN_MODE ) )
                {
                    return HRESULT_FROM_WIN32( GetLastError() );
                }
            }

            m_pRSOPQuery->dwFlags |= RSOP_NEW_QUERY;
            hr = RunRSOPQueryInternal( m_hwndFrame, &extendedProcessing, m_pRSOPQuery, &m_pRSOPQueryResults );
        }
        else
        {
            LPRSOP_QUERY_RESULTS pNewResults = NULL;

            // We want the following to be set
            m_pRSOPQuery->dwFlags = m_pRSOPQuery->dwFlags & (RSOP_NEW_QUERY ^ 0xffffffff);
            m_pRSOPQuery->dwFlags |= RSOP_NO_WELCOME;
            if ( bShowWizard )
            {
                m_pRSOPQuery->UIMode = RSOP_UI_WIZARD;
            }
            else
            {
                m_pRSOPQuery->UIMode = RSOP_UI_REFRESH;
            }

            // Run the query
            hr = RunRSOPQueryInternal( m_hwndFrame, &extendedProcessing, m_pRSOPQuery, &pNewResults );
            if ( hr == S_OK )
            {
                if ( m_bViewIsArchivedData )
                {
                    DeleteArchivedRSOPNamespace();
                    m_bViewIsArchivedData = FALSE;
                }
                else
                {
                    // If the old and new namespaces are the same, it translates to the case where a non-admin user
                    //  reran the query and chose to discard the previous query results in favour of the new one's.
                    //  In this case we do not delete the namespace as it is the one that should be used.
                    if ( CompareString( LOCALE_INVARIANT, 0, m_pRSOPQueryResults->szWMINameSpace, -1, pNewResults->szWMINameSpace, -1 ) == CSTR_EQUAL )
                    {
                        LocalFree( m_pRSOPQueryResults->szWMINameSpace );
                        LocalFree( m_pRSOPQueryResults );
                    }
                    else
                    {
                        FreeRSOPQueryResults( m_pRSOPQuery, m_pRSOPQueryResults );
                    }
                }
                m_pRSOPQueryResults = pNewResults;
            }
            else
            {
                FreeRSOPQueryResults( m_pRSOPQuery, pNewResults );
            }
        }

        if ( FAILED(hr) )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: SetupPropertyPages failed with 0x%x"), hr));
        }

        if (hr == S_FALSE)
        {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::InitializeRSOP: User cancelled in the init wizard")));
        }
    }
    else
    {
        hr = extendedProcessing.DoProcessing(m_pRSOPQuery, m_pRSOPQueryResults, TRUE);
    }

    if ( hr == S_OK )
    {
        m_bGetExtendedErrorInfo = extendedProcessing.GetExtendedErrorInfo();
        
        if ( m_bInitialized && (m_hRoot != NULL) )
        {
            if ( m_hMachine != NULL) hr = m_pScope->DeleteItem( m_hMachine, FALSE );
            if ( m_hUser != NULL) hr = m_pScope->DeleteItem( m_hUser, FALSE );
            hr = m_pScope->DeleteItem( m_hRoot, FALSE );
            if ( hr != S_OK )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: Deleting scope items failed with 0x%x"), hr));
                return E_FAIL;
            }

            m_hMachine = NULL;
            m_hUser = NULL;
        }
        else
        {
            m_bInitialized = TRUE;
        }

        if ( !m_bNamespaceSpecified )
        {
            SetDirty();
        }

        BuildDisplayName();

        if ( m_hRoot != NULL )
        {
            hr = SetRootNode();
            if ( hr != S_OK )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: Setting the root scope item failed with 0x%x"), hr));
                return E_FAIL;
            }

            if ( m_bRootExpanded )
            {
                // Must recreate root subitems since MMC does not seem to notice that it must re-expand the node if all its subitems
                //  where deleted.
                hr = EnumerateScopePane( m_hRoot );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: Enumerating the scope items failed with 0x%x"), hr));
                    return E_FAIL;
                }
            }
            else
            {
                hr = m_pScope->Expand( m_hRoot );
                if ( FAILED(hr) )
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: Expanding the scope items failed with 0x%x"), hr));
                    return E_FAIL;
                }
                if ( hr == S_FALSE )
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeRSOP: Expanding the scope items seemingly already done.")));
                    hr = S_OK;
                }
            }

            // For refresh and consistency purposes, reselect the root node
            m_pConsole->SelectScopeItem( m_hRoot );
        }
    }

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPComponentDataCF::CRSOPComponentDataCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPComponentDataCF::~CRSOPComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CRSOPComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CRSOPComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRSOPComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                                     REFIID      riid,
                                     LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRSOPComponentData *pComponentData = new CRSOPComponentData(); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CRSOPComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory implementation for rsop context menu                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPCMenuCF::CRSOPCMenuCF()
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPCMenuCF::~CRSOPCMenuCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CRSOPCMenuCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CRSOPCMenuCF::Release()
{
    m_cRef = InterlockedDecrement(&m_cRef);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPCMenuCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRSOPCMenuCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CRSOPCMenu *pRsopCMenu = new CRSOPCMenu(); // ref count == 1

    if (!pRsopCMenu)
        return E_OUTOFMEMORY;

    HRESULT hr = pRsopCMenu->QueryInterface(riid, ppvObj);
    pRsopCMenu->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CRSOPCMenuCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation for rsop context menu                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPCMenu::CRSOPCMenu()
{
    m_cRef = 1;
    m_lpDSObject = NULL;
    m_szDN = NULL;
    m_szDomain = NULL;
    InterlockedIncrement(&g_cRefThisDll);
}

CRSOPCMenu::~CRSOPCMenu()
{
    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu:: Context menu destroyed")));
    InterlockedDecrement(&g_cRefThisDll);

    if (m_lpDSObject)
        LocalFree(m_lpDSObject);

    if (m_szDN)
    {
        LocalFree(m_szDN);
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation (IUnknown)                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP_(ULONG)
CRSOPCMenu::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG)
CRSOPCMenu::Release()
{
    m_cRef = InterlockedDecrement(&m_cRef);

    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CRSOPCMenu::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPCLASSFACTORY)this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPCMenu implementation (IExtendContextMenu)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP        
CRSOPCMenu::AddMenuItems(LPDATAOBJECT piDataObject,
                         LPCONTEXTMENUCALLBACK piCallback,
                         long * pInsertionAllowed)
{
    FORMATETC       fm;
    STGMEDIUM       medium;
    LPDSOBJECTNAMES lpNames;
    CONTEXTMENUITEM ctxMenu;
    HRESULT         hr=S_OK;
    LPTSTR          lpTemp;
    HANDLE          hTokenUser = 0;
    BOOL            bPlAccessGranted = FALSE, bLoAccessGranted = FALSE;
    BOOL            bLoNeeded = TRUE;


    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: Entering")));

    
    // if we are not allowed in the tasks menu quit
    if (!((*pInsertionAllowed) & CCM_INSERTIONALLOWED_TASK )) {
        return S_OK;
    }

    
    //
    // Ask DS admin for the ldap path to the selected object
    //

    ZeroMemory (&fm, sizeof(fm));
    fm.cfFormat = (WORD)m_cfDSObjectName;
    fm.tymed = TYMED_HGLOBAL;

    ZeroMemory (&medium, sizeof(medium));
    medium.tymed = TYMED_HGLOBAL;

    medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_NODISCARD, 512);

    if (medium.hGlobal)
    {
        hr = piDataObject->GetData(&fm, &medium);

        if (SUCCEEDED(hr))
        {
            lpNames = (LPDSOBJECTNAMES) GlobalLock (medium.hGlobal);

            if (lpNames) {
                lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetName);

                if (m_lpDSObject)
                {
                    LocalFree (m_lpDSObject);
                }

                ULONG ulNoChars;

                ulNoChars = lstrlen (lpTemp) + 1;
                m_lpDSObject = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                if (m_lpDSObject)
                {
                    hr = StringCchCopy (m_lpDSObject, ulNoChars, lpTemp);
                    ASSERT(SUCCEEDED(hr));
                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: LDAP path from DS Admin %s"), m_lpDSObject));
                }
                else {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                
                m_rsopHint = RSOPHintUnknown;

                if (lpNames->aObjects[0].offsetClass) {
                    lpTemp = (LPWSTR) (((LPBYTE)lpNames) + lpNames->aObjects[0].offsetClass);

                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("domainDNS"), -1) == CSTR_EQUAL)
                    {
                        m_rsopHint = RSOPHintDomain;
                    }
                    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("organizationalUnit"), -1) == CSTR_EQUAL)
                    {
                        m_rsopHint = RSOPHintOrganizationalUnit;
                    }
                    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("site"), -1) == CSTR_EQUAL)
                    {
                        m_rsopHint = RSOPHintSite;
                    }
                    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("user"), -1) == CSTR_EQUAL)
                    {
                        m_rsopHint = RSOPHintUser;
                    }
                    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT("computer"), -1) == CSTR_EQUAL)
                    {
                        m_rsopHint = RSOPHintMachine;
                    }

                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: m_rsopHint = %d"), m_rsopHint));
                } else {
                    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: No objectclass defined.")));
                }

                GlobalUnlock (medium.hGlobal);

            }
            else {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }

        GlobalFree(medium.hGlobal);
    }
    else {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }


    //
    // if we got our data as expected add the menu
    //

    if (SUCCEEDED(hr)) {
        LPWSTR  szContainer = NULL;
        LPWSTR  szTempDN = NULL;

        //
        // Now check whether the user has right to do rsop generation
        // if the container is anything other than the Site
        //

        if (m_szDomain) {
            LocalFree(m_szDomain);
            m_szDomain = NULL;
        }

        ParseDN(m_lpDSObject, &m_szDomain, &szTempDN, &szContainer);

        if (m_szDN)
        {
            LocalFree(m_szDN);
            m_szDN = NULL;
        }

        if (szTempDN)
        {
           hr = UnEscapeLdapPath(szTempDN, &m_szDN);
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: UnEscapeLdapPath failed. Error 0x%x"), hr));
            bLoAccessGranted = bPlAccessGranted = FALSE;
        }
        else {
            if ((m_rsopHint == RSOPHintMachine) || (m_rsopHint == RSOPHintUser)) 
                bLoNeeded = TRUE;
            else
                bLoNeeded = FALSE;


            if (m_rsopHint != RSOPHintSite) {
                if (!OpenThreadToken (GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, TRUE, &hTokenUser)) {
                    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_IMPERSONATE | TOKEN_DUPLICATE | TOKEN_QUERY, &hTokenUser)) {
                        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: Couldn't get process token. Error %d"), GetLastError()));
                        bLoAccessGranted = bPlAccessGranted = FALSE;
                    }
                }


                if (hTokenUser) {
                    DWORD   dwErr;

                    dwErr = CheckAccessForPolicyGeneration( hTokenUser, szContainer, m_szDomain, FALSE, &bPlAccessGranted);

                    if (dwErr != ERROR_SUCCESS) {
                        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: CheckAccessForPolicyGeneration. Error %d"), dwErr));
                        bPlAccessGranted = FALSE;
                    }


                    if (bLoNeeded) {                  
                        dwErr = CheckAccessForPolicyGeneration( hTokenUser, szContainer, m_szDomain, TRUE, &bLoAccessGranted);

                        if (dwErr != ERROR_SUCCESS) {
                            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::AddMenuItems: CheckAccessForPolicyGeneration. Error %d"), dwErr));
                            bLoAccessGranted = FALSE;
                        }
                    }

                    CloseHandle(hTokenUser);
                }

            }
            else {
                bPlAccessGranted = TRUE;
            }
        }

        if (bPlAccessGranted) {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: User has right to do Planning RSOP")));
        }

        if (bLoAccessGranted) {
            DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: User has right to do Logging RSOP")));
        }



        //
        // Add the Context menu appropriately
        //
        
        WCHAR szMenuName[150];

        memset(&ctxMenu, 0, sizeof(ctxMenu));

        LoadString (g_hInstance, IDS_RSOP_PLANNING, szMenuName, ARRAYSIZE(szMenuName));
        ctxMenu.strName = szMenuName;
        ctxMenu.strStatusBarText = NULL;
        ctxMenu.lCommandID = RSOP_LAUNCH_PLANNING;  // no sp. flags
        ctxMenu.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
        
        if (bPlAccessGranted)
            ctxMenu.fFlags = MF_ENABLED;
        else
            ctxMenu.fFlags = MF_GRAYED | MF_DISABLED;

        hr = piCallback->AddItem(&ctxMenu);

        if (bLoNeeded) {
            LoadString (g_hInstance, IDS_RSOP_LOGGING, szMenuName, ARRAYSIZE(szMenuName));
            ctxMenu.strName = szMenuName;
            ctxMenu.strStatusBarText = NULL;
            ctxMenu.lCommandID = RSOP_LAUNCH_LOGGING;  // no sp. flags
            ctxMenu.lInsertionPointID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
                 
            if (bLoAccessGranted)
                ctxMenu.fFlags = MF_ENABLED;
            else
                ctxMenu.fFlags = MF_GRAYED | MF_DISABLED;

            hr = piCallback->AddItem(&ctxMenu);
        }
    }
                

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::AddMenuItems: Leaving hr = 0x%x"), hr));
    return hr;

}


STDMETHODIMP        
CRSOPCMenu::Command(long lCommandID, LPDATAOBJECT piDataObject)
{
    DWORD   dwSize = 0;
    LPTSTR szArguments=NULL, lpEnd=NULL;
    SHELLEXECUTEINFO ExecInfo;
    LPTSTR  szUserName=NULL, szMachName=NULL;
    LPTSTR szFile = NULL;
    HRESULT hr;    

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: lCommandID = %d"), lCommandID));

    //
    // Launch rsop.msc with the appropriate cmd line arguments
    //

    dwSize += lstrlen(RSOP_MODE) + 10;


    if (m_rsopHint == RSOPHintSite) {
        dwSize += lstrlen(RSOP_SITENAME) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintDomain) {
        dwSize += lstrlen(RSOP_COMP_OU_PREF) + lstrlen(m_szDN)+10;
        dwSize += lstrlen(RSOP_USER_OU_PREF) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintOrganizationalUnit) {
        dwSize += lstrlen(RSOP_COMP_OU_PREF) + lstrlen(m_szDN)+10;
        dwSize += lstrlen(RSOP_USER_OU_PREF) + lstrlen(m_szDN)+10;
    }

    if (m_rsopHint == RSOPHintMachine) {
        szMachName = MyTranslateName(m_szDN, NameFullyQualifiedDN, NameSamCompatible);

        if (!szMachName) {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: MyTranslateName failed with error %d"), GetLastError()));
            goto Exit;
        }
        dwSize += lstrlen(RSOP_COMP_NAME) + lstrlen(szMachName)+10;
    }

    if (m_rsopHint == RSOPHintUser) {
        szUserName = MyTranslateName(m_szDN, NameFullyQualifiedDN, NameSamCompatible);

        if (!szUserName) {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: MyTranslateName failed with error %d"), GetLastError()));
            goto Exit;
        }
        
        dwSize += lstrlen(RSOP_USER_NAME) + lstrlen(szUserName)+10;
    }

    if (m_szDomain) {
        dwSize += lstrlen(RSOP_DCNAME_PREF) + lstrlen(m_szDomain)+10;
    }

    szArguments = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

    if (!szArguments)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to allocate memory with %d"),
                 GetLastError()));
        goto Exit;
    }

    ULONG ulNoChars;

    hr = StringCchPrintf (szArguments, dwSize, TEXT("/s "));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
        goto Exit;
    }
    lpEnd = szArguments + lstrlen(szArguments);
    ulNoChars = dwSize - lstrlen(szArguments);

    //
    // Build the command line arguments
    //

    hr = StringCchPrintf(lpEnd, ulNoChars, L"%s\"%d\" ", RSOP_MODE, (lCommandID == RSOP_LAUNCH_PLANNING) ? 1 : 0);
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
        goto Exit;
    }

    lpEnd = szArguments + lstrlen(szArguments);
    ulNoChars = dwSize - lstrlen(szArguments);

    if (m_rsopHint == RSOPHintSite) 
    {
        hr = StringCchPrintf(lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_SITENAME, m_szDN);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    }

    if (m_rsopHint == RSOPHintDomain) {
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_COMP_OU_PREF, m_szDN);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);

        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_USER_OU_PREF, m_szDN);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);

    }

    if (m_rsopHint == RSOPHintOrganizationalUnit) {
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_COMP_OU_PREF, m_szDN);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_USER_OU_PREF, m_szDN);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    }

    if (m_rsopHint == RSOPHintMachine) {
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_COMP_NAME, szMachName);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    }

    if (m_rsopHint == RSOPHintUser) {
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_USER_NAME, szUserName);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    }

    if (m_szDomain) {
        hr = StringCchPrintf (lpEnd, ulNoChars, L"%s\"%s\" ", RSOP_DCNAME_PREF, m_szDomain);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
            goto Exit;
        }
        lpEnd = szArguments + lstrlen(szArguments);
        ulNoChars = dwSize - lstrlen(szArguments);
    }

    DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: Starting GPE with %s"), szArguments));

    // Get the file to execute with the right path
    TCHAR szRSOPMSC[] = TEXT("rsop.msc");
    ulNoChars = MAX_PATH + _tcslen(szRSOPMSC) + 2;
    szFile = new TCHAR[ulNoChars];
    if ( szFile == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to allocate memory.")));
        goto Exit;
    }
    UINT uPathSize = GetSystemDirectory( szFile, MAX_PATH);
    if ( uPathSize == 0 )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to get the system directory with %d"),
                 GetLastError()));
        goto Exit;
    }
    else if ( uPathSize > MAX_PATH )
    {
        delete [] szFile;
        ulNoChars = uPathSize + _tcslen(szRSOPMSC) + 2;
        szFile = new TCHAR[ulNoChars];
        if ( szFile == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to allocate memory.")));
            goto Exit;
        }
        UINT uPathSize2 = GetSystemDirectory( szFile, uPathSize );
        if ( uPathSize2 == 0 )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Failed to get the system directory with %d"),
                     GetLastError()));
            goto Exit;
        }
    }
    if ( szFile[_tcslen(szFile)-1] != _T('\\') )
    {
        szFile[_tcslen(szFile)+1] = _T('\0');
        szFile[_tcslen(szFile)] = _T('\\');
    }
    hr = StringCchCat ( szFile, ulNoChars, szRSOPMSC );
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: Could not copy arguments with 0x%x"), hr));
        goto Exit;
    }

    // Set up the execution info
    ZeroMemory (&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpVerb = TEXT("open");
    ExecInfo.lpFile = szFile;
    ExecInfo.lpParameters = szArguments;
    ExecInfo.nShow = SW_SHOWNORMAL;


    if (ShellExecuteEx (&ExecInfo))
    {
        DebugMsg((DM_VERBOSE, TEXT("CRSOPCMenu::Command: Launched rsop tool")));

        SetWaitCursor();
        WaitForInputIdle (ExecInfo.hProcess, 10000);
        ClearWaitCursor();
        CloseHandle (ExecInfo.hProcess);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPCMenu::Command: ShellExecuteEx failed with %d"),
                 GetLastError()));
//        ReportError(NULL, GetLastError(), IDS_SPAWNRSOPFAILED);
        goto Exit;
    }

Exit:
    if (szUserName) {
        LocalFree(szUserName);
    }
    
    if (szMachName) {
        LocalFree(szMachName);
    }

    if (szArguments) {
        LocalFree (szArguments);
    }

    if (szFile != NULL)
    {
        delete [] szFile;
    }
    
    return S_OK;
}

BOOL
EnableWMIFilters( LPWSTR szGPOPath )
{
    BOOL bReturn = FALSE;
    LPWSTR szDomain = szGPOPath;
    IWbemLocator* pLocator = 0;
    IWbemServices*  pServices = 0;
    HRESULT hr;

    while ( szDomain )
    {
        if ( CompareString( LOCALE_INVARIANT,
                            NORM_IGNORECASE,
                            szDomain,
                            3,
                            L"DC=",
                            3 ) == CSTR_EQUAL )
        {
            break;
        }
        szDomain++;
    }

    if ( !szDomain )
    {
        goto Exit;
    }


    hr = CoCreateInstance(  CLSID_WbemLocator,
                            0,
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (void**) &pLocator );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    BSTR xbstrNamespace = SysAllocString( L"\\\\.\\root\\Policy" );
    if ( !xbstrNamespace )
    {
        goto Exit;
    }


    hr = pLocator->ConnectServer(   xbstrNamespace, // namespace
                                    0,              // user
                                    0,              // password
                                    0,              // locale
                                    0,              // security flags
                                    0,              // authority
                                    0,              // Wbem context
                                    &pServices );   // IWbemServices
    SysFreeString( xbstrNamespace );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    WCHAR szDomainCanonical[512];
    DWORD dwSize = 512;
    
    if ( !TranslateName(szDomain,
                         NameUnknown,
                         NameCanonical,
                         szDomainCanonical,
                         &dwSize ) )
    {
        goto Exit;
    }

    LPWSTR szTemp = wcsrchr( szDomainCanonical, L'/' );

    if ( szTemp )
    {
        *szTemp = 0;
    }

    WCHAR szBuffer[512];

    hr = StringCchPrintf ( szBuffer, ARRAYSIZE(szBuffer), L"MSFT_SomFilterStatus.domain=\"%s\"", szDomainCanonical );
    if (FAILED(hr)) 
    {
        goto Exit;
    }

    BSTR bstrObjectPath = SysAllocString( szBuffer );
    if ( !bstrObjectPath )
    {
        goto Exit;
    }

    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pServices, 
                           RPC_C_AUTHN_WINNT, 
                           RPC_C_AUTHZ_DEFAULT, 
                           0, 
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                           RPC_C_IMP_LEVEL_IMPERSONATE, 
                           0,
                           0);
    if ( FAILED( hr ) )
    {
        SysFreeString( bstrObjectPath );
        goto Exit;
    }

    IWbemClassObject* xObject = 0;
    hr = pServices->GetObject(  bstrObjectPath,
                                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                0,
                                &xObject,
                                0 );
    SysFreeString( bstrObjectPath );
    if ( FAILED( hr ) )
    {
        goto Exit;
    }

    VARIANT var;
    VariantInit(&var);

    hr = xObject->Get(L"SchemaAvailable", 0, &var, NULL, NULL);

    if((FAILED(hr)) || ( var.vt == VT_NULL ))
    {
        DebugMsg((DM_WARNING, TEXT("EnableWMIFilters: Get failed for SchemaAvailable with error 0x%x"), hr));
        goto Exit;
    }

    if (var.boolVal == VARIANT_FALSE )
    {
        VariantClear(&var);
        goto Exit;
    }

    VariantClear(&var);
    DebugMsg((DM_VERBOSE, TEXT("Schema is available for wmi filters")));
    bReturn = TRUE;

Exit:
    if ( pLocator )
    {
        pLocator->Release();
    }
    if ( pServices )
    {
        pServices->Release();
    }

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsoproot.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoproot.h
//
//  Contents:   Definitions for the RSOP Snap-In classes
//
//  Classes:    CRSOPComponentData - Root RSOP snap-in node
//              CRSOPComponentDataCF - class factory for RSOPComponentData
//
//  Functions:
//
//  History:    09-13-1999   stevebl   Created
//
//---------------------------------------------------------------------------

#include "RSOPQuery.h"

//
// RSOP gpo list data structure
//

typedef struct tagGPOLISTITEM {
    LPTSTR  lpGPOName;
    LPTSTR  lpDSPath;
    LPTSTR  lpSOM;
    LPTSTR  lpUnescapedSOM;
    LPTSTR  lpFiltering;
    LPBYTE  pSD;
    DWORD   dwVersion;
    BOOL    bApplied;
    struct tagGPOLISTITEM * pNext;
} GPOLISTITEM, *LPGPOLISTITEM;


//
// RSOP CSE data structure
//

typedef struct tagCSEITEM {
    LPTSTR lpName;
    LPTSTR lpGUID;
    DWORD  dwStatus;
    ULONG  ulLoggingStatus;
    SYSTEMTIME BeginTime;
    SYSTEMTIME EndTime;
    BOOL bUser;
    LPSOURCEENTRY lpEventSources;
    struct tagCSEITEM *pNext;
} CSEITEM, *LPCSEITEM;


//
// CRSOPGPOLists class
//
class CRSOPGPOLists
{
public:
    CRSOPGPOLists()
        {
            m_pUserGPOList = NULL;
            m_pComputerGPOList = NULL;
        }

    ~CRSOPGPOLists()
        {
            if ( m_pUserGPOList != NULL )
            {
                FreeGPOListData( m_pUserGPOList );
                m_pUserGPOList = NULL;
            }

            if ( m_pComputerGPOList != NULL )
            {
                FreeGPOListData( m_pComputerGPOList );
                m_pComputerGPOList = NULL;
            }
        }

    
    void Build( LPTSTR szWMINameSpace );


    LPGPOLISTITEM GetUserList()
        { return m_pUserGPOList; }

    LPGPOLISTITEM GetComputerList()
        { return m_pComputerGPOList; }


private:
    static void FreeGPOListData(LPGPOLISTITEM lpList);
    static void BuildGPOList (LPGPOLISTITEM * lpList, LPTSTR lpNamespace);
    static BOOL AddGPOListNode(LPTSTR lpGPOName, LPTSTR lpDSPath, LPTSTR lpSOM, LPTSTR lpFiltering,
                        DWORD dwVersion, BOOL bFiltering, LPBYTE pSD, DWORD dwSDSize,
                        LPGPOLISTITEM *lpList);


private:
    LPGPOLISTITEM       m_pUserGPOList;
    LPGPOLISTITEM       m_pComputerGPOList;
};


//
// CRSOPCSELists class
//
class CRSOPCSELists
{
public:
    CRSOPCSELists( const BOOL& bViewIsArchivedData )
        : m_bViewIsArchivedData( bViewIsArchivedData )
        {
            m_bNoQuery = FALSE;
            m_szTargetMachine = NULL;
            m_pUserCSEList = NULL;
            m_pComputerCSEList = NULL;

            m_bUserCSEError = FALSE;
            m_bComputerCSEError = FALSE;
            m_bUserGPCoreError = FALSE;
            m_bComputerGPCoreError = FALSE;
            m_bUserGPCoreWarning = FALSE;
            m_bComputerGPCoreWarning = FALSE;

            m_pEvents = new CEvents;
        }

    ~CRSOPCSELists()
        {
            if ( m_pEvents != NULL )
            {
                delete m_pEvents;
                m_pEvents = NULL;
            }

            if ( m_pUserCSEList != NULL )
            {
                FreeCSEData( m_pUserCSEList );
                m_pUserCSEList = NULL;
            }

            if ( m_pComputerCSEList != NULL )
            {
                FreeCSEData( m_pComputerCSEList );
                m_pComputerCSEList = NULL;
            }
        }

    
    void Build( LPRSOP_QUERY pQuery, LPTSTR szWMINameSpace, BOOL bGetEventLogErrors );


public:
    LPCSEITEM GetUserList()
        { return m_pUserCSEList; }

    LPCSEITEM GetComputerList()
        { return m_pComputerCSEList; }

    BOOL GetUserCSEError()
        { return m_bUserCSEError; }

    BOOL GetComputerCSEError()
        { return m_bComputerCSEError; }

    BOOL GetUserGPCoreError()
        { return m_bUserGPCoreError; }

    BOOL GetComputerGPCoreError()
        { return m_bComputerGPCoreError; }

    BOOL GetUserGPCoreWarning()
        { return m_bUserGPCoreWarning; }

    BOOL GetComputerGPCoreWarning()
        { return m_bComputerGPCoreWarning; }

    CEvents* GetEvents()
        { return m_pEvents; }


private:
    void BuildCSEList( LPRSOP_QUERY pQuery, LPCSEITEM * lpList, LPTSTR lpNamespace, BOOL bUser, BOOL *bCSEError, BOOL *bGPCoreError );
    void FreeCSEData( LPCSEITEM lpList );
    static BOOL AddCSENode( LPTSTR lpName, LPTSTR lpGUID, DWORD dwStatus,
                    ULONG ulLoggingStatus, SYSTEMTIME *pBeginTime, SYSTEMTIME *pEndTime, BOOL bUser,
                    LPCSEITEM *lpList, BOOL *bCSEError, BOOL *bGPCoreError, LPSOURCEENTRY lpSources );
    void GetEventLogSources( IWbemServices * pNamespace,
                             LPTSTR lpCSEGUID, LPTSTR lpComputerName,
                             SYSTEMTIME *BeginTime, SYSTEMTIME *EndTime,
                             LPSOURCEENTRY *lpSources );
    void QueryRSoPPolicySettingStatusInstances( LPTSTR lpNamespace );


private:
    const BOOL&                     m_bViewIsArchivedData;
    BOOL                            m_bNoQuery;
    LPTSTR                          m_szTargetMachine;
    
    // CSE data
    LPCSEITEM                       m_pUserCSEList;
    LPCSEITEM                       m_pComputerCSEList;
    BOOL                            m_bUserCSEError;
    BOOL                            m_bComputerCSEError;
    BOOL                            m_bUserGPCoreError;
    BOOL                            m_bComputerGPCoreError;
    BOOL                            m_bUserGPCoreWarning;
    BOOL                            m_bComputerGPCoreWarning;

    // Event log data
    CEvents*                        m_pEvents;

};


//
// CRSOPComponentData class
//
class CRSOPComponentData:
    public IComponentData,
    public IExtendPropertySheet2,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
protected:
    BOOL                            m_bPostXPBuild;
    
    ULONG                           m_cRef;
    HWND                            m_hwndFrame;
    BOOL                            m_bOverride;            // RM: Overrides the loading of a .MSC file and uses commandline parameters instead (integration with DSA)
    BOOL                            m_bRefocusInit;
    BOOL                            m_bArchiveData;
    BOOL                            m_bViewIsArchivedData;
    TCHAR                           m_szArchivedDataGuid[50];
    LPCONSOLENAMESPACE2             m_pScope;
    LPCONSOLE                       m_pConsole;
    HSCOPEITEM                      m_hRoot;
    HSCOPEITEM                      m_hMachine;
    HSCOPEITEM                      m_hUser;
    BOOL                            m_bRootExpanded;

    HMODULE                         m_hRichEdit;
    DWORD                           m_dwLoadFlags;

    // RSOP query and results
    BOOL                            m_bInitialized;
    LPTSTR                          m_szDisplayName;
    LPRSOP_QUERY                    m_pRSOPQuery;
    LPRSOP_QUERY_RESULTS            m_pRSOPQueryResults;

    // Extended error lists
    CRSOPGPOLists                   m_GPOLists;
    CRSOPCSELists                   m_CSELists;
    BOOL                            m_bGetExtendedErrorInfo;

    IStream *                       m_pStm;

    BOOL                            m_bNamespaceSpecified; // boolean flag to indicate tha the namespace was
                                                           // specified. special actions need to be taken to
                                                           // prevent the namespace from getting deleted.

public:
    //
    // Constructors/destructor
    //

    CRSOPComponentData();
    
    ~CRSOPComponentData();


public:
    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


public:
    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

private:
    //
    // IComponentData helper methods
    //

    HRESULT SetRootNode();
    HRESULT EnumerateScopePane ( HSCOPEITEM hParent );


public:
    //
    // Implemented IExtendPropertySheet2 methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);
    STDMETHODIMP         GetWatermarks(LPDATAOBJECT lpIDataObject,  HBITMAP* lphWatermark,
                                       HBITMAP* lphHeader, HPALETTE* lphPalette, BOOL* pbStretch);


private:
    //
    // IExtendPropertySheet2 helper methods
    //
    HRESULT IsSnapInManager (LPDATAOBJECT lpDataObject);
    HRESULT IsNode (LPDATAOBJECT lpDataObject, MMC_COOKIE cookie);

    
public:
    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


public:
    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

private:
    //
    // IPersistStreamInit helper methods
    //
    
    STDMETHODIMP         CopyFileToMSC (LPTSTR lpFileName, IStream *pStm);
    STDMETHODIMP         CreateNameSpace (LPTSTR lpNameSpace, LPTSTR lpParentNameSpace);
    STDMETHODIMP         CopyMSCToFile (IStream *pStm, LPTSTR *lpMofFileName);
    STDMETHODIMP         BuildDisplayName (void);
    HRESULT              LoadStringList( IStream* pStm, DWORD* pCount, LPTSTR** paszStringList );
    HRESULT              SaveStringList( IStream* pStm, DWORD count, LPTSTR* aszStringList );


private:
    //
    // RSOP initialization helper methods
    //
    HRESULT InitializeRSOPFromMSC(DWORD dwFlags);
    HRESULT DeleteArchivedRSOPNamespace();


public:
    //
    // Helpers for IRSOPInformation (Used by CRSOPDataObject)
    //
    
    STDMETHODIMP         GetNamespace(DWORD dwSection, LPOLESTR pszNamespace, INT ccMaxLength);
    STDMETHODIMP         GetFlags(DWORD * pdwFlags);
    STDMETHODIMP         GetEventLogEntryText(LPOLESTR pszEventSource, LPOLESTR pszEventLogName,
                                              LPOLESTR pszEventTime, DWORD dwEventID, LPOLESTR *ppszText);


public:
    //
    // Implemented ISnapinHelp interface members
    //
    
    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);


public:
    //
    // Member attribute access functions
    //

    BOOL IsPostXPBuild() { return m_bPostXPBuild; }

    HSCOPEITEM GetMachineScope() { return m_hMachine; }
    HSCOPEITEM GetUserScope() { return m_hUser; }

    bool IsNamespaceInitialized() const { return m_bInitialized != 0; };
    bool HasDisplayName() const { return (m_szDisplayName != NULL); };
    LPCTSTR GetDisplayName() const { return m_szDisplayName; };

    BOOL ComputerGPCoreErrorExists() { return m_CSELists.GetComputerGPCoreError(); }
    BOOL ComputerGPCoreWarningExists() { return m_CSELists.GetComputerGPCoreWarning(); }
    BOOL ComputerCSEErrorExists() { return m_CSELists.GetComputerCSEError(); }
    BOOL UserGPCoreErrorExists() { return m_CSELists.GetUserGPCoreError(); }
    BOOL UserGPCoreWarningExists() { return m_CSELists.GetUserGPCoreWarning(); }
    BOOL UserCSEErrorExists() { return m_CSELists.GetUserCSEError(); }


private:
    //
    // Property page methods
    //
    HRESULT SetupFonts();

    HFONT m_BigBoldFont;
    HFONT m_BoldFont;


private:
    //
    // Dialog handlers
    //
    static INT_PTR CALLBACK RSOPGPOListMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGPOListUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPErrorsMachineProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPErrorsUserProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK QueryDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


private:
    //
    // Dialog event handlers
    //
    void OnEdit(HWND hDlg);
    void OnSecurity(HWND hDlg);
    void OnRefreshDisplay(HWND hDlg);
    void OnContextMenu(HWND hDlg, LPARAM lParam);
    void OnSaveAs (HWND hDlg);


private:
    //
    // Dialog helper methods
    //
    void InitializeErrorsDialog(HWND hDlg, LPCSEITEM lpList);
    void RefreshErrorInfo (HWND hDlg);
    static HRESULT WINAPI ReadSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR *pSD, LPARAM lpContext);
    static HRESULT WINAPI WriteSecurityDescriptor (LPCWSTR lpGPOPath, SECURITY_INFORMATION si, PSECURITY_DESCRIPTOR pSD, LPARAM lpContext);
    
    
private:
    //
    // Graphical GPO list usage methods
    //
    void FillGPOList(HWND hDlg, DWORD dwListID, LPGPOLISTITEM lpList,
                     BOOL bSOM, BOOL bFiltering, BOOL bVersion, BOOL bInitial);
    void PrepGPOList(HWND hList, BOOL bSOM, BOOL bFiltering,
                     BOOL bVersion, DWORD dwCount);


private:
    //
    // Dialog methods for loading RSOP data from archive
    //
    static INT_PTR CALLBACK InitArchivedRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    STDMETHODIMP InitializeRSOPFromArchivedData(IStream *pStm);


private:
    //
    // Context menu event handler
    //
    HRESULT InitializeRSOP( BOOL bShowWizard );
    HRESULT EvaluateParameters(LPWSTR                  szNamespacePref, 
                               LPWSTR                  szTarget);

private:
    //
    // Persistence help methods
    //
    void SetDirty(VOID)  { m_bDirty = TRUE; }
    void ClearDirty(VOID)  { m_bDirty = FALSE; }
    BOOL ThisIsDirty(VOID) { return m_bDirty; }
    
    BOOL                           m_bDirty;
    
};

//
// class factory
//

class CRSOPComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;

public:
    CRSOPComponentDataCF();
    ~CRSOPComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


//
// AboutGPE class factory
//


class CRSOPCMenuCF : public IClassFactory
{
protected:
    LONG  m_cRef;

public:
    CRSOPCMenuCF();
    ~CRSOPCMenuCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};


#define RSOP_LAUNCH_PLANNING    1
#define RSOP_LAUNCH_LOGGING     2


//
// Group Policy Hint types
//

typedef enum _RSOP_POLICY_HINT_TYPE {
    RSOPHintUnknown = 0,                      // No link information available
    RSOPHintMachine,                          // a machine
    RSOPHintUser,                             // a user
    RSOPHintSite,                             // a site
    RSOPHintDomain,                           // a domain
    RSOPHintOrganizationalUnit,               // a organizational unit
} RSOP_POLICY_HINT_TYPE, *PRSOP_POLICY_HINT_TYPE;


class CRSOPCMenu : public IExtendContextMenu
{
protected:
    LONG                    m_cRef;
    LPWSTR                  m_lpDSObject;
    LPWSTR                  m_szDomain;
    LPWSTR                  m_szDN;
    RSOP_POLICY_HINT_TYPE   m_rsopHint;
    static unsigned int     m_cfDSObjectName;

    
public:
    
    CRSOPCMenu();
    ~CRSOPCMenu();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IExtencContextMenu methods
    STDMETHODIMP        AddMenuItems(LPDATAOBJECT piDataObject,
                                     LPCONTEXTMENUCALLBACK piCallback,
                                     long * pInsertionAllowed);

    STDMETHODIMP        Command(long lCommandID, LPDATAOBJECT piDataObject);
};


//
// Save console defines
//

#define RSOP_PERSIST_DATA_VERSION    5              // version number in msc file

#define MSC_RSOP_FLAG_DIAGNOSTIC        0x00000001     // Diagnostic mode vs planning mode
#define MSC_RSOP_FLAG_ARCHIVEDATA       0x00000002     // RSoP data is archived also
#define MSC_RSOP_FLAG_SLOWLINK          0x00000004     // Slow link simulation in planning mode
#define MSC_RSOP_FLAG_NOUSER            0x00000008     // Do not display user data
#define MSC_RSOP_FLAG_NOCOMPUTER        0x00000010     // Do not display computer data
#define MSC_RSOP_FLAG_LOOPBACK_REPLACE  0x00000020     // Simulate loopback replace mode.
#define MSC_RSOP_FLAG_LOOPBACK_MERGE    0x00000040     // Simulate loopback merge mode.
#define MSC_RSOP_FLAG_USERDENIED        0x00000080     // User denied access
#define MSC_RSOP_FLAG_COMPUTERDENIED    0x00000100     // Computer denied access
#define MSC_RSOP_FLAG_COMPUTERWQLFILTERSTRUE    0x00000200
#define MSC_RSOP_FLAG_USERWQLFILTERSTRUE        0x00000400
#define MSC_RSOP_FLAG_NOGETEXTENDEDERRORINFO      0x00000800

#define MSC_RSOP_FLAG_NO_DATA           0xf0000000      // No RSoP data was saved - only empty snapin

//
// RSOP Command line switches
//

#define RSOP_CMD_LINE_START          TEXT("/Rsop")        // base to all group policy command line switches
#define RSOP_MODE                    TEXT("/RsopMode:")   // Rsop Mode Planning/Logging 0 is logging, 1 is planning
#define RSOP_USER_OU_PREF            TEXT("/RsopUserOu:") // Rsop User OU preference
#define RSOP_COMP_OU_PREF            TEXT("/RsopCompOu:") // Rsop Comp OU Preference
#define RSOP_USER_NAME               TEXT("/RsopUser:")   // Rsop User Name
#define RSOP_COMP_NAME               TEXT("/RsopComp:")   // Rsop Comp Name
#define RSOP_SITENAME                TEXT("/RsopSite:")   // Rsop Site Name
#define RSOP_DCNAME_PREF             TEXT("/RsopDc:")     // DC Name that the tool should connect to
#define RSOP_NAMESPACE               TEXT("/RsopNamespace:")     // namespace that the tool should use
#define RSOP_TARGETCOMP              TEXT("/RsopTargetComp:")    // machine on which the rsop was originally run
                                                                 // for displaying in the UI and to get eventlog data


//
// Various flags to decide which prop sheets to show
//

#define RSOP_NOMSC          1
#define RSOPMSC_OVERRIDE    2
#define RSOPMSC_NOOVERRIDE  4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopsnap.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CRSOPSnapIn::CRSOPSnapIn(CRSOPComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pConsole2 = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_REPORT;
    m_bExpand = TRUE;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
}

CRSOPSnapIn::~CRSOPSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IUnknown)                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CRSOPSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CRSOPSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CRSOPSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IComponent)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    // QI for IConsole2
    hr = lpConsole->QueryInterface(IID_IConsole2, (LPVOID *)&m_pConsole2);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPSnapIn::Initialize: Failed to QI for IConsole2.")));
        m_pConsole->Release();
        m_pConsole = NULL;
        return hr;
    }

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::Destroy(MMC_COOKIE cookie)
{
    if (m_pConsole2 != NULL)
    {
        m_pConsole2->Release();
        m_pConsole2 = NULL;
    }

    if (m_pConsole != NULL)
    {
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if ( m_pcd->IsNamespaceInitialized() )
        {
            if (arg == TRUE)
            {
                RESULTDATAITEM resultItem;
                LPRSOPDATAOBJECT pRSOPDataObject;
                MMC_COOKIE cookie;
                INT i;
                LPCONSOLE2 lpConsole2;

                //
                // Get the cookie of the scope pane item
                //

                hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

                if (FAILED(hr))
                    return S_OK;

                hr = pRSOPDataObject->GetCookie(&cookie);

                pRSOPDataObject->Release();     // release initial ref
                if (FAILED(hr))
                    return S_OK;


                //
                // Prepare the view
                //

                m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
                m_pResult->SetViewMode(m_lViewMode);


                //
                // Add result pane items for this node
                //

                for (i = 0; i < g_RsopNameSpace[cookie].cResultItems; i++)
                {
                    resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                    resultItem.str = MMC_CALLBACK;
                    resultItem.nImage = g_RsopNameSpace[cookie].pResultItems[i].iImage;
                    resultItem.lParam = (LPARAM) &g_RsopNameSpace[cookie].pResultItems[i];
                    m_pResult->InsertItem(&resultItem);
                }

                m_pResult->Sort(0, 0, -1);

                if (m_bExpand)
                {
                    hr = m_pConsole->QueryInterface(IID_IConsole2,
                                    reinterpret_cast<void**>(&lpConsole2));

                    if (SUCCEEDED(hr))
                    {
                        if ( m_pcd->GetMachineScope() )
                        {
                            lpConsole2->Expand( m_pcd->GetMachineScope() , TRUE);
                        }

                        if ( m_pcd->GetUserScope() )
                        {
                            lpConsole2->Expand( m_pcd->GetUserScope() , TRUE);
                        }

                        lpConsole2->Release();
                    }

                    m_bExpand = FALSE;
                }
            }
            else
            {
                m_pHeader->GetColumnWidth(0, &m_nColumnSize);
                m_pResult->GetViewMode(&m_lViewMode);
            }
        }
        else
        {
            if ( arg == TRUE )
            {
                IUnknown* pUnk = NULL;
                hr = m_pConsole2->QueryResultView( &pUnk );

                // QI for IMessageView
                IMessageView* pMessageView = NULL;
                hr = pUnk->QueryInterface(IID_IMessageView, (LPVOID *)&pMessageView );
                if (FAILED(hr))
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPSnapIn::Notify: Failed to QI for IMessageView.")));
                    pUnk->Release();
                }
                else
                {
                    TCHAR szString[256];
                    
                    pUnk->Release();
                    pMessageView->SetIcon( Icon_Warning );
                    
                    LoadString( g_hInstance, IDS_RSOP_UNINITIALIZED, szString, ARRAYSIZE(szString) );
                    pMessageView->SetTitleText( szString );

                    LoadString( g_hInstance, IDS_RSOP_UNINITIALIZEDDESC, szString, ARRAYSIZE(szString) );
                    pMessageView->SetBodyText( szString );
                    
                    pMessageView->Release();
                }
            }
        }
        break;

    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPRSOPDATAOBJECT pRSOPDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);

            // First check if the snapin has been initialized
            if ( m_pcd->IsNamespaceInitialized() )
            {
                //
                // See if this is one of our items.
                //

                hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

                if (FAILED(hr))
                    break;

                pRSOPDataObject->GetType(&type);
                pRSOPDataObject->GetCookie(&cookie);

                pRSOPDataObject->Release();


                //
                // If this is a result pane item or the root of the namespace
                // nodes, enable the Properties menu item
                //

                if ((type == CCT_RESULT) ||
                    ((type == CCT_SCOPE) && ((cookie == 0) || (cookie == 1) || (cookie == 2))))
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                    //
                    // If this is a result pane item, then change the default
                    // verb to Properties.
                    //

                    if (type == CCT_RESULT)
                        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                }
            }
            else
            {
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
            }
        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPOLESTR pszHelpTopic;
            LPRSOPDATAOBJECT pRSOPDataObject;
            MMC_COOKIE cookie;


            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IRSOPDataObject, (LPVOID *)&pRSOPDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pRSOPDataObject->GetCookie(&cookie);

            pRSOPDataObject->Release();     // release initial ref

            if (FAILED(hr))
                return S_OK;

            ULONG ulNoChars = 50;
            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (ulNoChars * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                hr = StringCchCopy (pszHelpTopic, ulNoChars, g_RsopNameSpace[cookie].lpHelpTopic);
                if (SUCCEEDED(hr)) 
                {
                    m_pDisplayHelp->ShowTopic (pszHelpTopic);
                }
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CRSOPSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    pResult->str = g_RsopNameSpace[pResult->lParam].szDisplayName;
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if ( m_pcd->IsNamespaceInitialized() )
                {
                    INT iIcon;

                    iIcon = g_RsopNameSpace[pResult->lParam].iIcon;

                    if ((pResult->lParam == 1) && m_pcd->ComputerGPCoreErrorExists() )
                    {
                        iIcon = 12;
                    }
                    else if ((pResult->lParam == 1) && (m_pcd->ComputerCSEErrorExists() || m_pcd->ComputerGPCoreWarningExists()))
                    {
                        iIcon = 14;
                    }
                    else if ((pResult->lParam == 2) && m_pcd->UserGPCoreErrorExists() )
                    {
                        iIcon = 13;
                    }
                    else if ((pResult->lParam == 2) && (m_pcd->UserCSEErrorExists() || m_pcd->UserGPCoreWarningExists()))
                    {
                        iIcon = 15;
                    }

                    pResult->nImage = iIcon;
                }
                else
                    pResult->nImage = 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CRSOPSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CRSOPSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    if ( m_pcd->IsNamespaceInitialized() )
    {
        return S_FALSE;
    }
    else
    {
        StringFromCLSID( CLSID_MessageView, ppViewType );
        return S_OK;
    }
}

STDMETHODIMP CRSOPSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPRSOPDATAOBJECT pRSOPDataObjectA, pRSOPDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IRSOPDataObject,
                                            (LPVOID *)&pRSOPDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IRSOPDataObject,
                                            (LPVOID *)&pRSOPDataObjectB)))
    {
        pRSOPDataObjectA->Release();
        return S_FALSE;
    }

    pRSOPDataObjectA->GetCookie(&cookie1);
    pRSOPDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pRSOPDataObjectA->Release();
    pRSOPDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CRSOPSnapIn object implementation (IExtendContextMenu)                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CRSOPSnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                   LPCONTEXTMENUCALLBACK pCallback,
                                   LONG *pInsertionAllowed)
{
    return m_pcd->AddMenuItems (piDataObject, pCallback, pInsertionAllowed);
}

STDMETHODIMP CRSOPSnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    return m_pcd->Command (lCommandID, piDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopwizard.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       RSOPWizard.cpp
//
//  Contents:   implementation of RSOP wizard
//
//  Classes:    CRSOPWizard
//
//  Functions:
//
//  History:    08-02-2001   rhynierm   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "RSOPWizard.h"

#include "sddl.h"    // for sid to string functions
#include "RSOPUtil.h"

//---------------------------------------------------------------------------
//  Utility methods
//

WCHAR * NameWithoutDomain(WCHAR * szName)
{
    // The name passed in could be of the form
    // "domain/name"
    // or it could be just
    // "name"

    int cch = 0;
    if (NULL != szName)
    {
        while (szName[cch])
        {
            if (szName[cch] == L'/' || szName[cch] == L'\\')
            {
                return &szName[cch + 1];
            }
            cch++;
        }
    }
    return szName;
}

//---------------------------------------------------------------------------
//  CRSOPWizard class implementation
//

//-------------------------------------------------------
// RSOP data generation/manipulation

HRESULT CRSOPWizard::DeleteRSOPData( LPTSTR szNameSpace, LPRSOP_QUERY pQuery )
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pInInst = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    LPTSTR szLocalNameSpace = NULL;

    HRESULT hr;
    HRESULT hrSuccess;
    ULONG ulNoChars;

    ulNoChars = 2+lstrlen(szNameSpace);
    szLocalNameSpace = (LPTSTR)LocalAlloc(LPTR, ulNoChars*sizeof(TCHAR));

    if (!szLocalNameSpace) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::DeleteRSOPData: LocalAlloc failed with 0x%x"), hr));
        goto Cleanup;
    }

    if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, 
                       TEXT("\\\\"), 2, szNameSpace, 2) == CSTR_EQUAL) {

        if (CompareString (LOCALE_USER_DEFAULT, NORM_STOP_ON_NULL, 
                           TEXT("\\\\."), 3, szNameSpace, 3) != CSTR_EQUAL) {
            LPTSTR lpEnd;
            lpEnd = wcschr(szNameSpace+2, L'\\');

            if (!lpEnd) {
                hr = E_FAIL;
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::DeleteRSOPData: Invalid format for name space")));
                goto Cleanup;
            }
            else {
                hr = StringCchCopy(szLocalNameSpace, ulNoChars, TEXT("\\\\."));
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat(szLocalNameSpace, ulNoChars, lpEnd);
                }

                if (FAILED(hr)) 
                {
                    goto Cleanup;
                }
            }
        }
        else {
            hr = StringCchCopy(szLocalNameSpace, ulNoChars, szNameSpace);
            if (FAILED(hr)) 
            {
                goto Cleanup;
            }
        }
    }
    else {
        hr = StringCchCopy(szLocalNameSpace, ulNoChars, szNameSpace);
        if (FAILED(hr)) 
        {
            goto Cleanup;
        }

    }

    DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::DeleteRSOPData: Namespace passed to the provider = %s"), szLocalNameSpace));

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if ( pQuery->QueryType == RSOP_LOGGING_MODE )
    {
        // set up diagnostic mode
        // build a path to the target: "\\\\computer\\root\\rsop"
        hr = StringCchPrintf(szBuffer,
                             ARRAYSIZE(szBuffer),
                             TEXT("\\\\%s\\root\\rsop"), 
                             NameWithoutDomain( pQuery->szComputerName ));
        if (FAILED(hr)) 
        {
            goto Cleanup;
        }

        bstrParam = SysAllocString(szBuffer);

        if (!bstrParam)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }
    else
    {
        // set up planning mode
        // build a path to the DC: "\\\\dc\\root\\rsop"
        hr = StringCchPrintf( szBuffer, 
                              ARRAYSIZE(szBuffer), 
                              TEXT("\\\\%s\\root\\rsop"), 
                              pQuery->szDomainController );
        if (FAILED(hr)) 
        {
            goto Cleanup;
        }

        bstrParam = SysAllocString(szBuffer);

        if (!bstrParam)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopPlanningModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    bstrMethodName = SysAllocString(TEXT("RsopDeleteSession"));

    if (!bstrMethodName)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = pClass->GetMethod(bstrMethodName,
                           0,
                           &pInClass,
                           NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = pInClass->SpawnInstance(0, &pInInst);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = SetParameter(pInInst, TEXT("nameSpace"), szLocalNameSpace);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Set the proper security to prevent the ExecMethod call from failing and to enable encryption
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    hr = pNamespace->ExecMethod(bstrClassPath,
                                bstrMethodName,
                                0,
                                NULL,
                                pInInst,
                                &pOutInst,
                                NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = GetParameter(pOutInst, TEXT("hResult"), hrSuccess);
    if (SUCCEEDED(hr))
    {
        if (FAILED(hrSuccess))
        {
            hr = hrSuccess;
        }
    }

Cleanup:

    if (szLocalNameSpace) {
        LocalFree(szLocalNameSpace);
        szLocalNameSpace = NULL;
    }

    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);
    if (pInInst)
    {
        pInInst->Release();
    }
    if (pOutInst)
    {
        pOutInst->Release();
    }
    if (pInClass)
    {
        pInClass->Release();
    }
    if (pClass)
    {
        pClass->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }
    return hr;
}

//-------------------------------------------------------
//  Synopsis:   Wrapper around GenerateRSOPData.  This version adds retry
//              support.  If the user doesn't have access to half of the data
//              this method will re-issue the query for only the part of the data
//              the user has access to.

HRESULT CRSOPWizard::GenerateRSOPDataEx( HWND hDlg, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults )
{
    // Check preconditions
    if ( pQuery == NULL )
    {
        return E_FAIL;
    }

    *ppResults = (LPRSOP_QUERY_RESULTS)LocalAlloc( LPTR, sizeof(RSOP_QUERY_RESULTS) );
    if ( *ppResults == NULL )
    {
        DebugMsg( (DM_WARNING, TEXT("CreateRSOPQuery: Failed to allocate memory with 0x%x."), HRESULT_FROM_WIN32(GetLastError())) );
        return E_FAIL;
    }
    (*ppResults)->szWMINameSpace = 0;
    (*ppResults)->bUserDeniedAccess = FALSE;
    (*ppResults)->bNoUserPolicyData = FALSE;
    (*ppResults)->bComputerDeniedAccess = FALSE;
    (*ppResults)->bNoComputerPolicyData = FALSE;
    (*ppResults)->ulErrorInfo = 0;
    
    HRESULT hr;
    BOOL bSkipCSEs, bLimitData, bUser, bForceCreate;

    bSkipCSEs = bLimitData = bUser =  bForceCreate = FALSE;

    // Perform basic RSOP query
    hr = GenerateRSOPData( hDlg, pQuery, &((*ppResults)->szWMINameSpace),
                            bSkipCSEs, bLimitData, bUser, bForceCreate,
                            &((*ppResults)->ulErrorInfo) );

    if (FAILED(hr))
    {
        BOOL bNoUserData = FALSE;
        BOOL bNoComputerData = FALSE;
        
        if ( ((*ppResults)->ulErrorInfo) == RSOP_USER_ACCESS_DENIED )
        {
            if ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
            {
                // Do not try to do the query without the user's RSOP data since
                //  we are not supposed to get the computer's RSOP data in any case.
                // NOTE: Since we already have UI lockdown another string cannot be added
                //  at this stage to describe this specific failure. The message for access
                //  denied for both user and computer must therefor suffice and will not
                //  create any real confusion.
                (*ppResults)->ulErrorInfo = RSOP_USER_ACCESS_DENIED | RSOP_COMPUTER_ACCESS_DENIED;
            }
            else
            {
                ReportError (hDlg, hr, IDS_EXECFAILED_USER);
                (*ppResults)->bUserDeniedAccess = TRUE;
                FillResultsList( GetDlgItem (hDlg, IDC_LIST1), pQuery, *ppResults );

                bSkipCSEs = bUser =  bForceCreate = FALSE;
                bLimitData = TRUE;
                bNoUserData = TRUE;
                hr = GenerateRSOPData( hDlg, pQuery, &((*ppResults)->szWMINameSpace),
                                                        bSkipCSEs, bLimitData, bUser, bForceCreate,
                                                        &((*ppResults)->ulErrorInfo),
                                                        bNoUserData, bNoComputerData );
            }
        }
        else if ( ((*ppResults)->ulErrorInfo) == RSOP_COMPUTER_ACCESS_DENIED )
        {
            if ( (pQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY )
            {
                // Do not try to do the query without the computer's RSOP data since
                //  we are not supposed to get the user's RSOP data in any case.
                // NOTE: Since we already have UI lockdown another string cannot be added
                //  at this stage to describe this specific failure. The message for access
                //  denied for both user and computer must therefor suffice and will not
                //  create any real confusion.
                (*ppResults)->ulErrorInfo = RSOP_USER_ACCESS_DENIED | RSOP_COMPUTER_ACCESS_DENIED;
            }
            else
            {
                ReportError (hDlg, hr, IDS_EXECFAILED_COMPUTER);
                (*ppResults)->bComputerDeniedAccess = TRUE;
                FillResultsList( GetDlgItem (hDlg, IDC_LIST1), pQuery, *ppResults );

                bSkipCSEs =  bForceCreate = FALSE;
                bLimitData = bUser = TRUE;
                bNoComputerData = TRUE;
                hr = GenerateRSOPData (hDlg, pQuery, &((*ppResults)->szWMINameSpace),
                                                        bSkipCSEs, bLimitData, bUser, bForceCreate,
                                                        &((*ppResults)->ulErrorInfo),
                                                        bNoUserData, bNoComputerData );
            }
        }
        
        if (FAILED(hr))
        {
            if ( (((*ppResults)->ulErrorInfo) & RSOP_COMPUTER_ACCESS_DENIED) && 
                     (((*ppResults)->ulErrorInfo) & RSOP_USER_ACCESS_DENIED) )
            {
                // both are denied access
                ReportError (hDlg, hr, IDS_EXECFAILED_BOTH);
            }
            else if (hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT))
            {
                ReportError (hDlg, hr, IDS_EXECFAILED_TIMEDOUT);
            }
            else if ( ((*ppResults)->ulErrorInfo) & RSOP_TEMPNAMESPACE_EXISTS )
            {
                TCHAR szConfirm[MAX_PATH], szTitle[MAX_PATH];

                szConfirm[0] = szTitle[0] = TEXT('\0');
                // If this is a new query being performed and this error condition occurs, we can savely say
                //  that someone else is hogging the namespace, otherwise, it is probably us doing the hogging :)
                if ( (pQuery->dwFlags & RSOP_NEW_QUERY) == RSOP_NEW_QUERY )
                {
                    LoadString(g_hInstance, IDS_RSOPDELNAMESPACE, szConfirm, ARRAYSIZE(szConfirm));
                }
                else
                {
                    LoadString(g_hInstance, IDS_RSOPDELNAMESPACE2, szConfirm, ARRAYSIZE(szConfirm));
                }
                LoadString(g_hInstance, IDS_RSOPDELNS_TITLE, szTitle, ARRAYSIZE(szTitle));

                if (MessageBox(hDlg, szConfirm, szTitle, MB_OKCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2) == IDOK) {
                    // use the same options as before
                    bForceCreate = TRUE;
                    hr = GenerateRSOPData( hDlg, pQuery, &((*ppResults)->szWMINameSpace),
                                                        bSkipCSEs, bLimitData, bUser, bForceCreate,
                                                        &((*ppResults)->ulErrorInfo),
                                                        bNoUserData, bNoComputerData );

                    if ( FAILED(hr) )
                    {
                        if ( hr == HRESULT_FROM_WIN32(WAIT_TIMEOUT) )
                        {
                            ReportError( hDlg, hr, IDS_EXECFAILED_TIMEDOUT );
                        }
                        else
                        {
                            ReportError( hDlg, hr, IDS_EXECFAILED );
                        }
                    }
                }
            }
            else
            {
                ReportError (hDlg, hr, IDS_EXECFAILED);
            }
        }
    }
    return hr;
}

//-------------------------------------------------------
//  Synopsis:   Calls the rsop provider based on the settings made in the
//              initialization wizard
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    10-04-1999   stevebl   Created
//
//  Notes:
//

HRESULT CRSOPWizard::GenerateRSOPData(  HWND hDlg,
                                                                            LPRSOP_QUERY pQuery,
                                                                            LPTSTR* pszNameSpace,
                                                                            BOOL bSkipCSEs,
                                                                            BOOL bLimitData,
                                                                            BOOL bUser,
                                                                            BOOL bForceCreate, 
                                                                            ULONG *pulErrorInfo,
                                                                            BOOL bNoUserData /* = FALSE */,
                                                                            BOOL bNoComputerData /* = FALSE */)
{
    // Check preconditions
    if ( pQuery == NULL )
    {
        return E_FAIL;
    }
    
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutInst = NULL;
    IWbemClassObject * pInClass = NULL;
    IWbemClassObject * pInInst = NULL;
    IUnsecuredApartment *pSpawner = NULL;
    IUnknown *pSubstitute = NULL;
    IWbemObjectSink *pSubstituteSink = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    HRESULT hrSuccess;
    CCreateSessionSink *pCSS = NULL;
    MSG msg;
    UINT uiFlags = 0;
    BOOL bSetData;
    HANDLE hEvent = NULL;


    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }

    if ( pQuery->QueryType == RSOP_LOGGING_MODE )
    {
        // set up diagnostic mode
        // build a path to the target: "\\\\computer\\root\\rsop"
        hr = StringCchPrintf(szBuffer, 
                             ARRAYSIZE(szBuffer), 
                             TEXT("\\\\%s\\root\\rsop"), 
                             NameWithoutDomain(pQuery->szComputerName));
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: failed to copy computer name with 0x%x"), hr));
            goto Cleanup;
        }

        bstrParam = SysAllocString(szBuffer);
        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ConnectServer failed with 0x%x"), hr));
            if ( hDlg != NULL )
            {
                WCHAR szTitle[MAX_PATH];
                ULONG ulSize;

                ulSize = ARRAYSIZE(szTitle);

                if ( !lstrcmpi(pQuery->szComputerName, L".") )
                {                
                    if (!GetComputerObjectName (NameDisplay, szTitle, &ulSize))
                    {
                        ulSize = ARRAYSIZE(szTitle);
                        if ( !GetComputerNameEx (ComputerNamePhysicalNetBIOS, szTitle, &ulSize))
                        {
                            hr = StringCchCopy(szTitle, ulSize, L".");
                            if (FAILED(hr)) 
                            {
                                goto Cleanup;
                            }
                        }
                    }
                    ReportError (hDlg, hr, IDS_CONNECTSERVERFAILED, szTitle);
                }
                else
                {
                    ReportError (hDlg, hr, IDS_CONNECTSERVERFAILED, pQuery->szComputerName);
                }
            }
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetObject failed with 0x%x"), hr));
            goto Cleanup;
        }

        bstrMethodName = SysAllocString(TEXT("RsopCreateSession"));
        hr = pClass->GetMethod(bstrMethodName,
                               0,
                               &pInClass,
                               NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetMethod failed with 0x%x"), hr));
            goto Cleanup;
        }

        hr = pInClass->SpawnInstance(0, &pInInst);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SpawnInstance failed with 0x%x"), hr));
            goto Cleanup;
        }

        // RM: It is quite difficult to figure out what is going on here. Since this method is called multiple times from GenerateRSOPDataEx,
        //  where one of there variables gets set, it might be that it was intended that way. Otherwise it serves no purpose to check 
        //  the "results" of a query (bUserDeniedAccess) before generating the results ...
        if ( ((pQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY) || bNoUserData)
        {
            uiFlags |= FLAG_NO_USER;
        }

        if ( ((pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY) || bNoComputerData )
        {
            uiFlags |= FLAG_NO_COMPUTER;
        }

        if ( bForceCreate )
        {
            uiFlags |= FLAG_FORCE_CREATENAMESPACE;
        }

        hr = SetParameter(pInInst, TEXT("flags"), uiFlags);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        // RM: Double check that the the username is set to a "." in the wizard for this case
        if ( !lstrcmpi( pQuery->szUserSid, TEXT(".")) )
        {
            hr = SetParameterToNull( pInInst, TEXT("userSid") );
        }
        else
        {
            hr = SetParameter( pInInst, TEXT("userSid"),  pQuery->szUserSid );
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }
    }
    else if ( pQuery->QueryType == RSOP_PLANNING_MODE )
    {
        // set up planning mode
        // build a path to the DC: "\\\\dc\\root\\rsop"
        hr = StringCchPrintf(szBuffer, 
                             ARRAYSIZE(szBuffer),
                             TEXT("\\\\%s\\root\\rsop"),  
                             pQuery->szDomainController );
        if (FAILED(hr)) 
        {
            goto Cleanup;
        }

        bstrParam = SysAllocString(szBuffer);
        hr = pLocator->ConnectServer(bstrParam,
                                     NULL,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     NULL,
                                     &pNamespace);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ConnectServer failed with 0x%x"), hr));
            if ( hDlg != NULL )
            {
                ReportError (hDlg, hr, IDS_CONNECTSERVERFAILED, pQuery->szDomainController );
            }
            goto Cleanup;
        }

        bstrClassPath = SysAllocString(TEXT("RsopPlanningModeProvider"));
        hr = pNamespace->GetObject(bstrClassPath,
                                   WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                   NULL,
                                   &pClass,
                                   NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetObject failed with 0x%x"), hr));
            goto Cleanup;
        }

        bstrMethodName = SysAllocString(TEXT("RsopCreateSession"));
        hr = pClass->GetMethod(bstrMethodName,
                               0,
                               &pInClass,
                               NULL);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: GetMethod failed with 0x%x"), hr));
            goto Cleanup;
        }

        hr = pInClass->SpawnInstance(0, &pInInst);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SpawnInstance failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( pQuery->bSlowNetworkConnection )
        {
            uiFlags |= FLAG_ASSUME_SLOW_LINK;
        }

        if ( !bSkipCSEs || bUser )
        {
            switch ( pQuery->LoopbackMode)
            {
                case RSOP_LOOPBACK_REPLACE:
                    uiFlags |= FLAG_LOOPBACK_REPLACE;
                    break;
                case RSOP_LOOPBACK_MERGE:
                    uiFlags |= FLAG_LOOPBACK_MERGE;
                    break;
                default:
                    break;
            }
        }

        if ( bSkipCSEs )
        {
            uiFlags |= (FLAG_NO_GPO_FILTER | FLAG_NO_CSE_INVOKE);
        }
        else
        {
            if ( pQuery->pComputer->bAssumeWQLFiltersTrue )
            {
                uiFlags |= FLAG_ASSUME_COMP_WQLFILTER_TRUE;
            }

            if ( pQuery->pUser->bAssumeWQLFiltersTrue )
            {
                uiFlags |= FLAG_ASSUME_USER_WQLFILTER_TRUE;
            }
        }

        hr = SetParameter(pInInst, TEXT("flags"), uiFlags);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        //
        // If this method is being called to generate temporary rsop data for the
        // wmi filter UI, we only want to initialize half of the args (either user
        // or computer).  Decide if we want to set the computer information here.
        //

        bSetData = TRUE;

        if ( bLimitData )
        {
            if ( bUser && (RSOP_LOOPBACK_NONE == pQuery->LoopbackMode) )
            {
                bSetData = FALSE;
            }
        }

        if ( (pQuery->pComputer->szName != NULL) && bSetData )
        {
            hr = SetParameter(pInInst, TEXT("computerName"), pQuery->pComputer->szName );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerName"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( (pQuery->pComputer->szSOM != NULL) && bSetData )
        {
            hr = SetParameter(pInInst, TEXT("computerSOM"), pQuery->pComputer->szSOM );
        }
        else
        {
            hr = SetParameterToNull (pInInst, TEXT("computerSOM"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( bSetData && (pQuery->pComputer->dwSecurityGroupCount != 0) )
        {
            SAFEARRAY* saComputerSecurityGroups = NULL;
            hr = CreateSafeArray( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups, &saComputerSecurityGroups );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateSafeArray failed with 0x%x"), hr));
                goto Cleanup;
            }
            hr = SetParameter(pInInst, TEXT("computerSecurityGroups"), saComputerSecurityGroups );
            SafeArrayDestroy( saComputerSecurityGroups );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerSecurityGroups"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( bSetData && (pQuery->pComputer->dwWQLFilterCount != 0) )
        {
            SAFEARRAY* saComputerWQLFilters = NULL;
            hr = CreateSafeArray( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilters, &saComputerWQLFilters );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateSafeArray failed with 0x%x"), hr));
                goto Cleanup;
            }
            hr = SetParameter(pInInst, TEXT("computerGPOFilters"), saComputerWQLFilters);
            SafeArrayDestroy( saComputerWQLFilters );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("computerGPOFilters"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        //
        // If this method is being called to generate temporary RSOP data for the
        // wmi filter UI, we only want to initialize half of the args (either user
        // or computer).  Decide if we want to set the user information here.
        //

        bSetData = TRUE;

        if ( bLimitData )
        {
            if ( !bUser )
            {
                bSetData = FALSE;
            }
        }

        if ( (pQuery->pUser->szName != NULL) && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userName"), pQuery->pUser->szName );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userName"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( (pQuery->pUser->szSOM != NULL) && bSetData)
        {
            hr = SetParameter(pInInst, TEXT("userSOM"), pQuery->pUser->szSOM );
        }
        else
        {
            hr = SetParameterToNull (pInInst, TEXT("userSOM"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( bSetData && (pQuery->pUser->dwSecurityGroupCount != 0) )
        {
            SAFEARRAY* saUserSecurityGroups = NULL;
            hr = CreateSafeArray( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups, &saUserSecurityGroups );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateSafeArray failed with 0x%x"), hr));
                goto Cleanup;
            }
            hr = SetParameter(pInInst, TEXT("userSecurityGroups"), saUserSecurityGroups );
            SafeArrayDestroy( saUserSecurityGroups );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userSecurityGroups"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( bSetData && (pQuery->pUser->dwWQLFilterCount != 0) )
        {
            SAFEARRAY* saUserWQLFilters = NULL;
            hr = CreateSafeArray( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilters, &saUserWQLFilters );
            if ( FAILED(hr) )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateSafeArray failed with 0x%x"), hr));
                goto Cleanup;
            }
            hr = SetParameter(pInInst, TEXT("userGPOFilters"), saUserWQLFilters);
            SafeArrayDestroy( saUserWQLFilters );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("userGPOFilters"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }

        if ( pQuery->szSite != NULL )
        {
            hr = SetParameter(pInInst, TEXT("site"), pQuery->szSite );
        }
        else
        {
            hr = SetParameterToNull(pInInst, TEXT("site"));
        }

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: SetParameter failed with 0x%x"), hr));
            goto Cleanup;
        }
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: The query type was not specified properly")));
        goto Cleanup;
    }
    
    hr = CoCreateInstance(CLSID_UnsecuredApartment, NULL, CLSCTX_ALL,
                          IID_IUnsecuredApartment, (void **)&pSpawner);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoCreateInstance for unsecure apartment failed with 0x%x"), hr));
        goto Cleanup;
    }

    hEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        NULL);
    if (NULL == hEvent) 
    {
        DebugMsg((DM_WARNING, L"CRSOPComponentData::GenerateRSOPData: Failed to create event"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Cleanup;
    }

    pCSS = new CCreateSessionSink(hDlg != NULL? GetDlgItem(hDlg, IDC_PROGRESS1) : NULL, hEvent, (pQuery->dwFlags & RSOP_90P_ONLY) != 0);

    if (!pCSS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: Failed to create createsessionsink")));
        goto Cleanup;
    }



    hr = pSpawner->CreateObjectStub(pCSS, &pSubstitute);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CreateObjectStub failed with 0x%x"), hr));
        goto Cleanup;
    }

    hr = pSubstitute->QueryInterface(IID_IWbemObjectSink, (LPVOID *)&pSubstituteSink);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: QI failed with 0x%x"), hr));
        goto Cleanup;
    }


    // Set the proper security to prevent the ExecMethod call from failing and to enable encryption
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }

    pCSS->SendQuitEvent (TRUE);

    hr = pNamespace->ExecMethodAsync(bstrClassPath,
                                     bstrMethodName,
                                     WBEM_FLAG_SEND_STATUS,
                                     NULL,
                                     pInInst,
                                     pSubstituteSink);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GenerateRSOPData: ExecMethodAsync failed with 0x%x"), hr));
        pCSS->SendQuitEvent (FALSE);
        goto Cleanup;
    }


    DWORD dwEventRetVal;

    while (TRUE) 
    {
        dwEventRetVal = MsgWaitForMultipleObjectsEx(
            1,
            &hEvent,
            INFINITE,
            QS_VALID, // QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE, is what COM seem to be using 
                      // CoWaitForMultipleHandles
            MWMO_INPUTAVAILABLE);
        if ( WAIT_OBJECT_0 == dwEventRetVal)
        {
            break;
        }

        if (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE)) 
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            continue;
        }
    }

    pCSS->SendQuitEvent (FALSE);
    pCSS->GetResult (&hrSuccess);
    pCSS->GetErrorInfo (pulErrorInfo);

    if (SUCCEEDED(hrSuccess))
    {
        LPTSTR lpComputerName;
        BSTR bstrNamespace = NULL;

        pCSS->GetNamespace (&bstrNamespace);

        if (bstrNamespace)
        {
            if ( pQuery->QueryType == RSOP_PLANNING_MODE )
            {
                lpComputerName = pQuery->szDomainController;
            }
            else
            {
                lpComputerName = NameWithoutDomain(pQuery->szComputerName );
            }

            ULONG ulNoChars = _tcslen(bstrNamespace) + _tcslen(lpComputerName) + 1;
            *pszNameSpace = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );

            if (*pszNameSpace)
            {
                hr = StringCchCopy (*pszNameSpace, ulNoChars, TEXT("\\\\"));
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat (*pszNameSpace, ulNoChars, lpComputerName);
                }
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat (*pszNameSpace, ulNoChars, (bstrNamespace+3));
                }
                
                DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::GenerateRSOPData: Complete namespace is: %s"), *pszNameSpace));
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    }
    else
    {
        hr = hrSuccess;
        if (hDlg)
        {
            SendMessage (GetDlgItem(hDlg, IDC_PROGRESS1), PBM_SETPOS, 0, 0);
        }
        goto Cleanup;
    }

Cleanup:
    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);

    if(hEvent != NULL)
    {
        CloseHandle(hEvent);
    }

    if (pInInst)
    {
        pInInst->Release();
    }

    if (pOutInst)
    {
        pOutInst->Release();
    }

    if (pInClass)
    {
        pInClass->Release();
    }

    if (pClass)
    {
        pClass->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }
    
    if (pSubstitute)
    {
        pSubstitute->Release();
    }

    if (pSubstituteSink)
    {
        pSubstituteSink->Release();
    }

    if (pSpawner)
    {
        pSpawner->Release();
    }

    if (pCSS)
    {
        pCSS->Release();
    }

    return hr;
}

//-------------------------------------------------------

HRESULT CRSOPWizard::CreateSafeArray( DWORD dwCount, LPTSTR* aszStringList, SAFEARRAY** psaList )
{
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = dwCount;


    *psaList = SafeArrayCreate (VT_BSTR, 1, rgsabound);
    if ( *psaList == NULL )
    {
        return E_OUTOFMEMORY;
    }

    long lCount = (long)dwCount;
    for ( long l = 0; l < lCount; l++ )
    {
        BSTR bstr = SysAllocString( aszStringList[l] );
        if ( bstr != NULL )
        {
            HRESULT hr = SafeArrayPutElement( *psaList, &l, bstr );
            if (FAILED(hr))
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPWizard::CreateSafeArray: SafeArrayPutElement failed with 0x%x."), hr));
            }
        }
    }

    return S_OK;
}

//-------------------------------------------------------

VOID CRSOPWizard::InitializeResultsList (HWND hLV)
{
    LV_COLUMN lvcol;
    RECT rect;
    TCHAR szTitle[50];


    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

    //
    // Add the columns to the listview
    //

    GetClientRect(hLV, &rect);

    ZeroMemory(&lvcol, sizeof(lvcol));

    LoadString(g_hInstance, IDS_RSOP_DETAILS, szTitle, ARRAYSIZE(szTitle));
    lvcol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvcol.pszText = szTitle;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = (int)(rect.right * .40);
    ListView_InsertColumn(hLV, 0, &lvcol);

    LoadString(g_hInstance, IDS_RSOP_SETTINGS, szTitle, ARRAYSIZE(szTitle));
    lvcol.cx = ((rect.right - lvcol.cx) - GetSystemMetrics(SM_CYHSCROLL));
    lvcol.pszText = szTitle;
    ListView_InsertColumn(hLV, 1, &lvcol);

}

//-------------------------------------------------------

void CRSOPWizard::FillResultsList (HWND hLV, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pQueryResults)
{
    TCHAR szTitle[200];
    TCHAR szAccessDenied[75];
    LPTSTR lpEnd;
    LVITEM item;
    INT iIndex = 0;
    ULONG ulSize;
    HRESULT hr;

    if ( pQuery == NULL )
    {
        return;
    }

    ListView_DeleteAllItems (hLV);

    // Mode
    ZeroMemory (&item, sizeof(item));

    LoadString(g_hInstance, IDS_RSOP_FINISH_P0, szTitle, ARRAYSIZE(szTitle));

    item.mask = LVIF_TEXT;
    item.iItem = iIndex;
    item.pszText = szTitle;
    iIndex = ListView_InsertItem (hLV, &item);

    if (iIndex != -1)
    {
        if ( pQuery->QueryType == RSOP_LOGGING_MODE )
        {
            LoadString(g_hInstance, IDS_DIAGNOSTIC, szTitle, ARRAYSIZE(szTitle));
        }
        else
        {
            LoadString(g_hInstance, IDS_PLANNING, szTitle, ARRAYSIZE(szTitle));
        }

        item.mask = LVIF_TEXT;
        item.pszText = szTitle;
        item.iItem = iIndex;
        item.iSubItem = 1;
        ListView_SetItem(hLV, &item);
    }

    if ( pQuery->QueryType == RSOP_LOGGING_MODE )
    {
        // User Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P1, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;

            if ( pQuery->szUserName != NULL )
            {
                lstrcpyn (szTitle, pQuery->szUserName, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
            }

            if ( (pQueryResults != NULL) && pQueryResults->bUserDeniedAccess )
            {
                LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT) lstrlen(szAccessDenied))
                {
                    hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                    ASSERT(SUCCEEDED(hr));
                }
            }

            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        // Do not display user data
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P15, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if (  ((pQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY)
                || ((pQueryResults != NULL) && pQueryResults->bNoUserPolicyData) )
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        // Computer Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P2, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            szTitle[0] = TEXT('\0');

            if (!lstrcmpi( pQuery->szComputerName, TEXT(".")))
            {
                ulSize = ARRAYSIZE(szTitle);
                if (!GetComputerObjectName (NameSamCompatible, szTitle, &ulSize))
                {
                    ulSize = ARRAYSIZE(szTitle);
                    GetComputerNameEx (ComputerNameNetBIOS, szTitle, &ulSize);
                }
            }
            else
            {
                lstrcpyn (szTitle, pQuery->szComputerName, ARRAYSIZE(szTitle));
            }

            // Remove the trailing $
            lpEnd = szTitle + lstrlen(szTitle) - 1;

            if (*lpEnd == TEXT('$'))
            {
                *lpEnd =  TEXT('\0');
            }

            if ( (pQueryResults != NULL) && pQueryResults->bComputerDeniedAccess )
            {
                LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                {
                    hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                    ASSERT(SUCCEEDED(hr));
                }
            }


            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        // Do not display computer data
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P14, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if ( ((pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY)
                || ((pQueryResults != NULL) && pQueryResults->bNoComputerPolicyData) )
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }

    }
    else if ( pQuery->QueryType == RSOP_PLANNING_MODE )
    {
        // User Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        if ( (pQuery->pUser->szName == NULL) && (pQuery->pUser->szSOM != NULL) )
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P9, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                lstrcpyn (szTitle, pQuery->pUser->szSOM, ARRAYSIZE(szTitle));

                if ( (pQueryResults != NULL) && pQueryResults->bUserDeniedAccess )
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                        ASSERT(SUCCEEDED(hr));
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }
        else
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P1, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if ( pQuery->pUser->szName != NULL )
                {
                    lstrcpyn (szTitle, pQuery->pUser->szName, ARRAYSIZE(szTitle));
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                }

                if ( (pQueryResults != NULL) && pQueryResults->bUserDeniedAccess)
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                        ASSERT(SUCCEEDED(hr));
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        // Computer Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        if ( (pQuery->pComputer->szName == NULL) && (pQuery->pComputer->szSOM != NULL) )
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P10, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                lstrcpyn (szTitle, pQuery->pComputer->szSOM, ARRAYSIZE(szTitle));

                if ( (pQueryResults != NULL) && pQueryResults->bComputerDeniedAccess )
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                        ASSERT(SUCCEEDED(hr));
                    }
                }

                item.pszText = szTitle;
                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }
        else
        {
            LoadString(g_hInstance, IDS_RSOP_FINISH_P2, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if ( pQuery->pComputer->szName != NULL )
                {
                    lstrcpyn (szTitle, pQuery->pComputer->szName, ARRAYSIZE(szTitle));

                    lpEnd = szTitle + lstrlen(szTitle) - 1;

                    if (*lpEnd == TEXT('$'))
                    {
                        *lpEnd = TEXT('\0');
                    }
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                }

                if ( (pQueryResults != NULL) && pQueryResults->bComputerDeniedAccess )
                {
                    LoadString(g_hInstance, IDS_ACCESSDENIED2, szAccessDenied, ARRAYSIZE(szAccessDenied));

                    if ((UINT)(ARRAYSIZE(szTitle) - lstrlen(szTitle)) > (UINT)lstrlen(szAccessDenied))
                    {
                        hr = StringCchCat (szTitle, ARRAYSIZE(szTitle), szAccessDenied);
                        ASSERT(SUCCEEDED(hr));
                    }
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                item.pszText = szTitle;
                ListView_SetItem(hLV, &item);
            }
        }


        // Show all GPOs
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P13, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            if ( pQuery->bSlowNetworkConnection )
            {
                LoadString(g_hInstance, IDS_YES, szTitle, ARRAYSIZE(szTitle));
            }
            else
            {
                LoadString(g_hInstance, IDS_NO, szTitle, ARRAYSIZE(szTitle));
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        // Indicate the loopback mode
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P16, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            switch ( pQuery->LoopbackMode)
            {
            case RSOP_LOOPBACK_NONE:
                LoadString(g_hInstance, IDS_NONE, szTitle, ARRAYSIZE(szTitle));
                break;
            case RSOP_LOOPBACK_REPLACE:
                LoadString(g_hInstance, IDS_LOOPBACK_REPLACE, szTitle, ARRAYSIZE(szTitle));
                break;
            case RSOP_LOOPBACK_MERGE:
                LoadString(g_hInstance, IDS_LOOPBACK_MERGE, szTitle, ARRAYSIZE(szTitle));
                break;
            }

            item.mask = LVIF_TEXT;
            item.pszText = szTitle;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


        // Site Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P3, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;

            if ( pQuery->szSite != NULL )
            {
                item.pszText = pQuery->szSite;
            }
            else
            {
                LoadString(g_hInstance, IDS_NONE, szTitle, ARRAYSIZE(szTitle));
                item.pszText = szTitle;
            }

            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }


/*
        // DC Name
        ZeroMemory (&item, sizeof(item));
        iIndex++;

        LoadString(g_hInstance, IDS_RSOP_FINISH_P4, szTitle, ARRAYSIZE(szTitle));

        item.mask = LVIF_TEXT;
        item.iItem = iIndex;
        item.pszText = szTitle;
        iIndex = ListView_InsertItem (hLV, &item);

        if (iIndex != -1)
        {
            item.mask = LVIF_TEXT;
            item.pszText = m_szDC;
            item.iItem = iIndex;
            item.iSubItem = 1;
            ListView_SetItem(hLV, &item);
        }
*/


        // Alternate User Location
        if ( pQuery->pUser->szName != NULL )
        {
            ZeroMemory (&item, sizeof(item));
            iIndex++;

            LoadString(g_hInstance, IDS_RSOP_FINISH_P5, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if ( pQuery->pUser->szSOM != NULL )
                {
                    item.pszText = pQuery->pUser->szSOM;
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                    item.pszText = szTitle;
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        // Alternate Computer Location
        if ( pQuery->pComputer->szName != NULL )
        {

            ZeroMemory (&item, sizeof(item));
            iIndex++;

            LoadString(g_hInstance, IDS_RSOP_FINISH_P6, szTitle, ARRAYSIZE(szTitle));

            item.mask = LVIF_TEXT;
            item.iItem = iIndex;
            item.pszText = szTitle;
            iIndex = ListView_InsertItem (hLV, &item);

            if (iIndex != -1)
            {
                item.mask = LVIF_TEXT;

                if ( pQuery->pComputer->szSOM != NULL )
                {
                    item.pszText = pQuery->pComputer->szSOM;
                }
                else
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));
                    item.pszText = szTitle;
                }

                item.iItem = iIndex;
                item.iSubItem = 1;
                ListView_SetItem(hLV, &item);
            }
        }


        // Alternate User security groups
        if ( (pQuery->pUser->szName != NULL)
            || (pQuery->pUser->szSOM != NULL)
            || (RSOP_LOOPBACK_NONE != pQuery->LoopbackMode) )
        {
            if ( pQuery->pUser->dwSecurityGroupCount != 0 )
            {
                DWORD dwIndex;
                for ( dwIndex = 0; dwIndex < pQuery->pUser->dwSecurityGroupCount; dwIndex++ )
                {
                    ZeroMemory (&item, sizeof(item));
                    iIndex++;

                    item.mask = LVIF_TEXT;
                    item.iItem = iIndex;

                    if ( dwIndex == 0 )
                    {
                        LoadString(g_hInstance, IDS_RSOP_FINISH_P7, szTitle, ARRAYSIZE(szTitle));
                        item.pszText = szTitle;
                    }
                    else
                    {
                        item.pszText = TEXT("");
                    }

                    iIndex = ListView_InsertItem (hLV, &item);

                    if (iIndex != -1)
                    {
                        LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                        item.mask = LVIF_TEXT;
                        item.pszText = pQuery->pUser->aszSecurityGroups[dwIndex];
                        item.iItem = iIndex;
                        item.iSubItem = 1;
                        ListView_SetItem(hLV, &item);
                    }
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P7, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        // Alternate Computer security groups
        if ( (pQuery->pComputer->szName != NULL)  || (pQuery->pComputer->szSOM != NULL) )
        {

            if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
            {
                DWORD dwIndex;
                for ( dwIndex = 0; dwIndex < pQuery->pComputer->dwSecurityGroupCount; dwIndex++ )
                {
                    ZeroMemory (&item, sizeof(item));
                    iIndex++;

                    item.mask = LVIF_TEXT;
                    item.iItem = iIndex;

                    if ( dwIndex == 0 )
                    {
                        LoadString(g_hInstance, IDS_RSOP_FINISH_P8, szTitle, ARRAYSIZE(szTitle));
                        item.pszText = szTitle;
                    }
                    else
                    {
                        item.pszText = TEXT("");
                    }

                    iIndex = ListView_InsertItem (hLV, &item);

                    if (iIndex != -1)
                    {
                        LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                        item.mask = LVIF_TEXT;
                        LPTSTR szText = pQuery->pComputer->aszSecurityGroups[dwIndex];

                        BOOL bDollarRemoved = FALSE;

                        if ( szText[wcslen(szText)-1] == L'$' )
                        {
                            bDollarRemoved = TRUE;
                            szText[wcslen(szText)-1] = 0;
                        }

                        item.pszText = szText;
                        item.iItem = iIndex;
                        item.iSubItem = 1;
                        ListView_SetItem(hLV, &item);

                        if (bDollarRemoved) {
                            szText[wcslen(szText)] = L'$';
                        }
                    }
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P8, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        // User WQL filters
        if ( (pQuery->pUser->szName != NULL)
            || (pQuery->pUser->szSOM != NULL)
            || (RSOP_LOOPBACK_NONE != pQuery->LoopbackMode) )
        {
            if ( pQuery->pUser->dwWQLFilterCount != 0 )
            {
                DWORD dwIndex = 0;
                for ( dwIndex = 0; dwIndex < pQuery->pUser->dwWQLFilterCount; dwIndex++ )
                {
                    ZeroMemory (&item, sizeof(item));
                    iIndex++;

                    item.mask = LVIF_TEXT;
                    item.iItem = iIndex;

                    if ( dwIndex == 0 )
                    {
                        LoadString(g_hInstance, IDS_RSOP_FINISH_P11, szTitle, ARRAYSIZE(szTitle));
                        item.pszText = szTitle;
                    }
                    else
                    {
                        item.pszText = TEXT("");
                    }

                    iIndex = ListView_InsertItem (hLV, &item);

                    if (iIndex != -1)
                    {
                        LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                        item.mask = LVIF_TEXT;
                        item.pszText = pQuery->pUser->aszWQLFilterNames[dwIndex];
                        item.iItem = iIndex;
                        item.iSubItem = 1;
                        ListView_SetItem(hLV, &item);
                    }
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P11, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    if ( pQuery->pUser->bAssumeWQLFiltersTrue )
                    {
                        LoadString(g_hInstance, IDS_SKIPWQLFILTER, szTitle, ARRAYSIZE(szTitle));
                    }
                    else
                    {
                        LoadString(g_hInstance, IDS_NONESELECTED, szTitle, ARRAYSIZE(szTitle));
                    }

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }


        // Computer WQL filters
        if ( (pQuery->pComputer->szName != NULL)
            || (pQuery->pComputer->szSOM != NULL) )
        {
            if ( pQuery->pComputer->dwWQLFilterCount != 0 )
            {
                DWORD dwIndex = 0;
                for ( dwIndex = 0; dwIndex < pQuery->pComputer->dwWQLFilterCount; dwIndex++ )
                {
                    ZeroMemory (&item, sizeof(item));
                    iIndex++;

                    item.mask = LVIF_TEXT;
                    item.iItem = iIndex;

                    if ( dwIndex == 0 )
                    {
                        LoadString(g_hInstance, IDS_RSOP_FINISH_P12, szTitle, ARRAYSIZE(szTitle));
                        item.pszText = szTitle;
                    }
                    else
                    {
                        item.pszText = TEXT("");
                    }

                    iIndex = ListView_InsertItem (hLV, &item);

                    if (iIndex != -1)
                    {
                        LoadString(g_hInstance, IDS_NOTSPECIFIED, szTitle, ARRAYSIZE(szTitle));

                        item.mask = LVIF_TEXT;
                        item.pszText = pQuery->pComputer->aszWQLFilterNames[dwIndex];
                        item.iItem = iIndex;
                        item.iSubItem = 1;
                        ListView_SetItem(hLV, &item);
                    }
                }
            }
            else
            {
                ZeroMemory (&item, sizeof(item));
                iIndex++;

                LoadString(g_hInstance, IDS_RSOP_FINISH_P12, szTitle, ARRAYSIZE(szTitle));

                item.mask = LVIF_TEXT;
                item.iItem = iIndex;
                item.pszText = szTitle;
                iIndex = ListView_InsertItem (hLV, &item);

                if (iIndex != -1)
                {
                    if ( pQuery->pComputer->bAssumeWQLFiltersTrue )
                    {
                        LoadString(g_hInstance, IDS_SKIPWQLFILTER, szTitle, ARRAYSIZE(szTitle));
                    }
                    else
                    {
                        LoadString(g_hInstance, IDS_NONESELECTED, szTitle, ARRAYSIZE(szTitle));
                    }

                    item.mask = LVIF_TEXT;
                    item.pszText = szTitle;
                    item.iItem = iIndex;
                    item.iSubItem = 1;
                    ListView_SetItem(hLV, &item);
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// IWbemObjectSink implementation                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CCreateSessionSink::CCreateSessionSink(HWND hProgress, HANDLE hEvent, BOOL bLimitProgress)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_hProgress = hProgress;
    m_hEvent  = hEvent;

    m_bSendEvent = FALSE;
    m_hrSuccess  = S_OK;
    m_pNameSpace = NULL;
    m_ulErrorInfo = 0;

    m_bLimitProgress = bLimitProgress;

    SendMessage (hProgress, PBM_SETPOS, 0, 0);
}

CCreateSessionSink::~CCreateSessionSink()
{
    if (m_pNameSpace)
    {
        SysFreeString (m_pNameSpace);
    }

    InterlockedDecrement(&g_cRefThisDll);
}

STDMETHODIMP_(ULONG)
CCreateSessionSink::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CCreateSessionSink::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CCreateSessionSink::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IWbemObjectSink))
    {
        *ppv = (IWbemObjectSink *)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP CCreateSessionSink::SendQuitEvent (BOOL bSendEvent)
{
    m_bSendEvent = bSendEvent;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetResult (HRESULT *hSuccess)
{
    *hSuccess = m_hrSuccess;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetNamespace (BSTR *pNamespace)
{
    *pNamespace = m_pNameSpace;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::GetErrorInfo (ULONG *pulErrorInfo)
{
    *pulErrorInfo = m_ulErrorInfo;
    return S_OK;
}

STDMETHODIMP CCreateSessionSink::Indicate(long lObjCount, IWbemClassObject **pArray)
{
    LONG lIndex;
    HRESULT hr;
    IWbemClassObject *pObject;

    for (lIndex = 0; lIndex < lObjCount; lIndex++)
    {
        pObject = pArray[lIndex];

        hr = GetParameter(pObject, TEXT("hResult"), m_hrSuccess);

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(m_hrSuccess))
            {
                GetParameterBSTR(pObject, TEXT("nameSpace"), m_pNameSpace);
            }
            else
            {
                GetParameter(pObject, TEXT("ExtendedInfo"), m_ulErrorInfo);
            }
        }

        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  Status:        0x%x"), m_hrSuccess));
        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  Namespace:     %s"), m_pNameSpace ? m_pNameSpace : TEXT("Null")));
        DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::Indicate:  ExtendedInfo:  %d"), m_ulErrorInfo));
    }

    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CCreateSessionSink::SetStatus(LONG lFlags, HRESULT hResult,
                                      BSTR strParam, IWbemClassObject *pObjParam)
{
    HRESULT hr;

    if (lFlags == WBEM_STATUS_PROGRESS)
    {
        if (m_hProgress)
        {
            //
            //  The hResult arg contains both the denominator
            //  and the numerator packed together.
            //
            //  Denominator is in the high word
            //  Numerator is in the low word
            //

            ULONG uDenominator = MAKELONG(HIWORD(hResult), 0);
            ULONG uNumerator = MAKELONG(LOWORD(hResult), 0);

            if ( m_bLimitProgress )
            {
                // Now to transform progress indicator values to 90% of whole bar
                uDenominator *= 10;
                uNumerator *= 9;
            }

            SendMessage (m_hProgress, PBM_SETRANGE32, 0, (LPARAM) uDenominator);
            SendMessage (m_hProgress, PBM_SETPOS, (WPARAM) uNumerator, 0);

            DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::SetStatus:  Precentage complete:  %d"), uNumerator));
        }
    }

    if (lFlags == WBEM_STATUS_COMPLETE)
    {
        if (m_bSendEvent)
        {
            if (hResult != WBEM_S_NO_ERROR)
            {
                m_hrSuccess = hResult;
                DebugMsg((DM_VERBOSE, TEXT("CCreateSessionSink::SetStatus:  Setting error status to:  0x%x"), m_hrSuccess));
            }

            if (SetEvent(m_hEvent) == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                DebugMsg((DM_WARNING, L"CCreateSessionSink::SetStatus:SetEvent failed with 0x%x", hr));
            }
        }
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopwizarddlg.h ===
#ifndef __RSOP_WIZARD_DLG_H__
#define __RSOP_WIZARD_DLG_H__
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       RSOPWizardDlg.h
//
//  Contents:   Definitions for the RSOP Wizard dialog class
//
//  Classes:    CRSOPWizardDlg
//
//  Functions:
//
//  History:    08-08-2001   rhynierm  Created
//
//---------------------------------------------------------------------------

#include "RSOPQuery.h"

// Forward declaration
class CRSOPExtendedProcessing;


//
// CRSOPWizardDlg class
//
class CRSOPWizardDlg
{
public:
    //
    // Constructors/destructor
    //
    CRSOPWizardDlg( LPRSOP_QUERY pQuery, CRSOPExtendedProcessing* pExtendedProcessing );

    ~CRSOPWizardDlg();

    VOID FreeUserData();
    VOID FreeComputerData();

    
public:
    //
    // Wizard interface
    //
    HRESULT ShowWizard( HWND hParent );
    HRESULT RunQuery( HWND hParent );
    LPRSOP_QUERY_RESULTS GetResults() const
        { return m_pRSOPQueryResults; }
    

private:
    //
    // Static RSOP data generation/manipulation
    //
    static INT_PTR CALLBACK InitRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


private:
    //
    // Property sheet/dialog box handlers
    //
    static INT_PTR CALLBACK RSOPWelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPChooseModeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPGetDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltDirsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltUserSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPAltCompSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPWQLUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPWQLCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPFinishedDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPFinished2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK RSOPChooseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    static INT CALLBACK DsBrowseCallback (HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);
    static INT_PTR CALLBACK BrowseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


private:
    //
    // Dialog helper methods
    //
    HRESULT SetupFonts();
    HRESULT FillUserList (HWND hList, BOOL* pbCurrentUserFound, BOOL* pbFixedUserFound);
    VOID EscapeString (LPTSTR *lpString);

    VOID InitializeSitesInfo (HWND hDlg);
    BOOL IsComputerRSoPEnabled(LPTSTR lpDCName);
    BOOL TestAndValidateComputer(HWND hDlg);
    VOID InitializeDCInfo (HWND hDlg);
    DWORD GetDefaultGroupCount();
    VOID AddDefaultGroups (HWND hLB);
    HRESULT BuildMembershipList (HWND hLB, IDirectoryObject * pDSObj, DWORD* pdwCount, LPTSTR** paszSecGrps, DWORD** padwSecGrpAttr);
    VOID GetPrimaryGroup (HWND hLB, IDirectoryObject * pDSObj);

    HRESULT SaveSecurityGroups (HWND hLB, DWORD* pdwCount, LPTSTR** paszSecGrps, DWORD** padwSecGrpAttr);
    VOID FillListFromSecurityGroups(HWND hLB, DWORD dwCount, LPTSTR* aszSecurityGroups, DWORD* adwSecGrpAttr);
    VOID FillListFromWQLFilters( HWND hLB, DWORD dwCount, LPTSTR* aszNames, LPTSTR* aszFilters );

    VOID AddSiteToDlg (HWND hDlg, LPWSTR szSitePath);

    VOID BuildWQLFilterList (HWND hDlg, BOOL bUser, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR** paszFilters );
    HRESULT SaveWQLFilters (HWND hLB, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR**paszFilters );

    BOOL CompareStringLists( DWORD dwCountA, LPTSTR* aszListA, DWORD dwCountB, LPTSTR* aszListB );

    LPTSTR GetDefaultSOM (LPTSTR lpDNName);
    HRESULT TestSOM (LPTSTR lpSOM, HWND hDlg);


private:
    BOOL m_bPostXPBuild;
    DWORD m_dwSkippedFrom;
    
    // Dialog fonts
    HFONT m_BigBoldFont;
    HFONT m_BoldFont;

    // Used to prevent the user from cancelling the query
    BOOL m_bFinalNextClicked;

    // Final RSOP information
    LPRSOP_QUERY            m_pRSOPQuery;
    LPRSOP_QUERY_RESULTS    m_pRSOPQueryResults;

    HRESULT                 m_hrQuery;
    BOOL                    m_bNoChooseQuery;

    // RM: variables that belong only in the dialogs
    LPTSTR                  m_szDefaultUserSOM;
    LPTSTR				    m_szDefaultComputerSOM;
    IDirectoryObject*		m_pComputerObject;
    IDirectoryObject *      m_pUserObject;

    BOOL                    m_bDollarRemoved;
    BOOL                    m_bNoCurrentUser;

    DWORD                   m_dwDefaultUserSecurityGroupCount;
    LPTSTR*                 m_aszDefaultUserSecurityGroups;
    DWORD*                  m_adwDefaultUserSecurityGroupsAttr;

    DWORD                   m_dwDefaultUserWQLFilterCount;
    LPTSTR*                 m_aszDefaultUserWQLFilterNames;
    LPTSTR*                 m_aszDefaultUserWQLFilters;

    DWORD                   m_dwDefaultComputerSecurityGroupCount;
    LPTSTR*                 m_aszDefaultComputerSecurityGroups;
    DWORD*                  m_adwDefaultComputerSecurityGroupsAttr;

    DWORD                   m_dwDefaultComputerWQLFilterCount;
    LPTSTR*                 m_aszDefaultComputerWQLFilterNames;
    LPTSTR*                 m_aszDefaultComputerWQLFilters;

    CRSOPExtendedProcessing* m_pExtendedProcessing;

    LONG                    m_lPlanningFinishedPage;
    LONG                    m_lLoggingFinishedPage;

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\sid.h ===
//*************************************************************
//
//  Header file for Sid.c
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#ifdef __cplusplus
extern "C" {
#endif

LPTSTR GetSidString(HANDLE UserToken);
VOID DeleteSidString(LPTSTR SidString);
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid);

#ifdef __cplusplus
}
#endif

PSID GetUserSid (HANDLE UserToken);
VOID DeleteUserSid(PSID Sid);
NTSTATUS LoadSidAuthFromString (const WCHAR* pString, PSID_IDENTIFIER_AUTHORITY pSidAuth);
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue);
NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopwizard.h ===
#ifndef __RSOP_WIZARD_H__
#define __RSOP_WIZARD_H__
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       RSOPWizard.h
//
//  Contents:   Definitions for the RSOP Wizard classes
//
//  Classes:    CRSOPWizard
//
//  Functions:
//
//  History:    08-02-2001   rhynierm  Created
//
//---------------------------------------------------------------------------

#include "RSOPQuery.h"

#define RSOP_NEW_QUERY 0x80000000
#define RSOP_90P_ONLY 0x40000000

//
// CRSOPExtendedProcessing
//
class CRSOPExtendedProcessing
{
public:
    virtual HRESULT DoProcessing( LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pResults, BOOL bGetExtendedErrorInfo ) = 0;
    virtual BOOL GetExtendedErrorInfo() const = 0;
};

//
// CRSOPWizard class
//

class CRSOPWizard
{
    friend class CRSOPComponentData;
    friend class CRSOPWizardDlg;

    
private:
    //
    // Constructors/destructor
    //

    CRSOPWizard();
    ~CRSOPWizard();


public:
    //
    // Static RSOP data generation/manipulation
    //

    static HRESULT DeleteRSOPData( LPTSTR szNameSpace, LPRSOP_QUERY pQuery );
    static HRESULT GenerateRSOPDataEx( HWND hDlg, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS* ppResults );
    static HRESULT GenerateRSOPData(   HWND hDlg,
                                                                    LPRSOP_QUERY pQuery,
                                                                    LPTSTR* pszNameSpace,
                                                                    BOOL bSkipCSEs,
                                                                    BOOL bLimitData,
                                                                    BOOL bUser,
                                                                    BOOL bForceCreate,
                                                                    ULONG *pulErrorInfo,
                                                                    BOOL bNoUserData = FALSE,
                                                                    BOOL bNoComputerData = FALSE);

    static HRESULT CreateSafeArray( DWORD dwCount, LPTSTR* aszStringList, SAFEARRAY** psaList );

private:
    //
    // RSOP generation dialog methods
    //
    static VOID InitializeResultsList (HWND hLV);
    static void FillResultsList (HWND hLV, LPRSOP_QUERY pQuery, LPRSOP_QUERY_RESULTS pQueryResults);
    
};


//
// IWbemObjectSink implementation
//

class CCreateSessionSink : public IWbemObjectSink
{
protected:
    ULONG m_cRef;
    HWND  m_hProgress;
    HANDLE  m_hEvent;
    HRESULT m_hrSuccess;
    BSTR    m_pNameSpace;
    ULONG   m_ulErrorInfo;
    BOOL    m_bSendEvent;
    BOOL    m_bLimitProgress;

public:
    CCreateSessionSink(HWND hProgress, HANDLE hEvent, BOOL bLimitProgress);
    ~CCreateSessionSink();

    STDMETHODIMP SendQuitEvent (BOOL bSendQuitMessage);
    STDMETHODIMP GetResult (HRESULT *hSuccess);
    STDMETHODIMP GetNamespace (BSTR *pNamespace);
    STDMETHODIMP GetErrorInfo (ULONG *pulErrorInfo);

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IWbemObjectSink methods
    STDMETHODIMP Indicate(LONG lObjectCount, IWbemClassObject **apObjArray);
    STDMETHODIMP SetStatus(LONG lFlags, HRESULT hResult, BSTR strParam, IWbemClassObject *pObjParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\smartptr.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        smartptr.h
//
// Contents:    Classes for smart pointers
//
// History:     24-Oct-98       SitaramR    Created
//
//---------------------------------------------------------------------------

#pragma once

template<class CItem> class XPtrST
{
public:
    XPtrST(CItem* p = 0) : _p( p )
    {
    }

    ~XPtrST() { delete _p; }

    BOOL IsNull() const { return ( 0 == _p ); }

    void Set ( CItem* p )
    {
        _p = p;
    }

    CItem * Acquire()
    {
        CItem * pTemp = _p;
        _p = 0;
        return pTemp;
    }

    CItem & GetReference() const
    {
        return *_p;
    }

    CItem * GetPointer() const { return _p ; }

    void Free() { delete Acquire(); }

private:
    XPtrST (const XPtrST<CItem> & x);
    XPtrST<CItem> & operator=( const XPtrST<CItem> & x);

    CItem * _p;
};


//*************************************************************
//
//  Class:      XBStr
//
//  Purpose:    Smart pointer class for BSTRs
//
//*************************************************************

class XBStr
{

private:

    XBStr(const XBStr& x);
    XBStr& operator=(const XBStr& x);

    BSTR _p;

public:

    XBStr(WCHAR* p = 0) : _p(0)
    {
        if(p)
        {
            _p = SysAllocString(p);
        }
    }

    ~XBStr()
    {
        SysFreeString(_p);
    }

    operator BSTR(){ return _p; }

    void operator=(WCHAR* p)
    {
        SysFreeString(_p);
        _p = p ? SysAllocString(p) : NULL;
    }

    BSTR Acquire()
    {
        BSTR p = _p;
        _p = 0;
        return p;
    }

};

//*************************************************************
//
//  Class:      MyXPtrST
//
//  Purpose:    Smart pointer template to wrap pointers to a single type.
//
//*************************************************************

template<class T> class MyXPtrST
{

private:

    MyXPtrST (const MyXPtrST<T>& x);
    MyXPtrST<T>& operator=(const MyXPtrST<T>& x);

    T* _p;

public:

    MyXPtrST(T* p = NULL) : _p(p){}

    ~MyXPtrST(){ delete _p; }

    T* operator->(){ return _p; }
    T** operator&(){ return &_p; }
    operator T*(){ return _p; }

    void operator=(T* p)
    {
        if(_p)
        {
            delete _p;
        }
        _p = p;
    }

    T* Acquire()
    {
        T* p = _p;
        _p = 0;
        return p;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsopwizarddlg.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 2001.
//
//  File:       RSOPWizardDlg.cpp
//
//  Contents:   implementation of RSOP wizard dialog
//
//  Classes:    CRSOPWizardDlg
//
//  Functions:
//
//  History:    08-08-2001   rhynierm   Created
//
//---------------------------------------------------------------------------

#include "main.h"
#include "RSOPWizardDlg.h"

#include "RSOPWizard.h"
#include "RSOPUtil.h"
#include "objsel.h" // for the object picker
#include "sddl.h"    // for sid to string functions

//---------------------------------------------------------------------------
// Private global variables


DWORD g_aBrowseForOUHelpIds[] =
{
    DSBID_BANNER,        IDH_RSOP_BANNER,
    DSBID_CONTAINERLIST, IDH_RSOP_CONTAINERLIST,

    0, 0
};

DWORD g_aBrowseDCHelpIds[] =
{
    IDC_LIST1,  IDH_RSOP_BROWSEDC,

    0, 0
};


//---------------------------------------------------------------------------
// Private helper methods

WCHAR * NameWithoutDomain(WCHAR * szName);                          // In RSOPWizard.cpp
TCHAR* NormalizedComputerName(TCHAR * szComputerName ); // In RSOPRoot.cpp
BOOL CopyString( LPTSTR szSource, LPTSTR* pszTarget );              // In RSOPQuery.cpp
BOOL FreeStringList( DWORD dwCount, LPTSTR* aszStrings );           // In RSOPQuery.cpp
BOOL FreeTargetData( LPRSOP_QUERY_TARGET pTarget );                 // In RSOPQuery.cpp
BOOL FreeTarget( LPRSOP_QUERY_TARGET pTarget );                         // In RSOPQuery.cpp



//---------------------------------------------------------------------------
// TranslateNameXForest
//
// Purpose: a method to do name translations (similar to TranslateName),
//  but that also works with names in other forests.

DWORD DsNameErrorMap[] = {  ERROR_SUCCESS,
                            ERROR_NO_SUCH_USER,
                            ERROR_NO_SUCH_USER,
                            ERROR_NONE_MAPPED,
                            ERROR_NONE_MAPPED,
                            ERROR_SOME_NOT_MAPPED,
                            ERROR_SOME_NOT_MAPPED
                            };

#define MapDsNameError( x )    ((x < sizeof( DsNameErrorMap ) / sizeof( DWORD ) ) ? \
                                     DsNameErrorMap[ x ] : ERROR_GEN_FAILURE )

BOOLEAN 
TranslateNameXForest (
                  LPTSTR                szDomain,                       // Domain where the name should be resolved
                  LPCTSTR               lpAccountName,                  // object name
                  DS_NAME_FORMAT        AccountNameFormat,              // name format
                  DS_NAME_FORMAT        DesiredNameFormat,              // new name format
                  LPTSTR               *lpTranslatedName                // returned name buffer
                )
{
    BOOL                        bRetry          = FALSE;
    DWORD                       dwErr;
    PDOMAIN_CONTROLLER_INFO     pDCInfo         = NULL;
    HANDLE                      hDS             = NULL;
    PDS_NAME_RESULT             pResult         = NULL;
    BOOLEAN                     bRet            = FALSE;
    LPWSTR                      szTransName     = NULL;


    DebugMsg(( DM_VERBOSE, L"TranslateNameXForest: Resolving name <%s> at Domain <%s>", lpAccountName, szDomain ? szDomain : L""));


    //
    // get a DC and bind to it. Make sure to force rediscover a DC if the bind fails
    //


    for (;;) {
        
        dwErr = DsGetDcName( NULL,
                             szDomain ? szDomain : L"",
                             NULL,
                             NULL,
                             DS_DIRECTORY_SERVICE_REQUIRED           |
                                 DS_RETURN_DNS_NAME                  | 
                                 (bRetry ? DS_FORCE_REDISCOVERY : 0) |
                             0,
                             &pDCInfo );

        if (dwErr == NO_ERROR) {
            dwErr = DsBind( pDCInfo->DomainControllerName,
                            NULL,
                            &hDS );

            if (dwErr == NO_ERROR) {
                break;
            }
            else {
                DebugMsg(( DM_WARNING, L"TranslateNameXForest: Failed to bind to DC <%s> with error %d", 
                         pDCInfo->DomainControllerName, dwErr ));
                NetApiBufferFree(pDCInfo);
                pDCInfo = NULL;
            }

        }
        else {
            DebugMsg(( DM_WARNING, L"TranslateNameXForest: Failed to get DC for domain <%s> with error %d", 
                     szDomain ? szDomain : L"", dwErr ));
        }                                                 



        //
        // Failed to bind to a DC. bail
        //

        if (bRetry) {
            goto Exit;
        }

        bRetry = TRUE;                          
    }

    DebugMsg(( DM_VERBOSE, L"TranslateNameXForest: DC selected is <%s>", pDCInfo->DomainControllerName ));


    //
    // Now crack names with the DC that is bound
    //

    dwErr = DsCrackNames( hDS,
                          DS_NAME_NO_FLAGS,
                          AccountNameFormat,
                          DesiredNameFormat,
                          1,
                          &lpAccountName,
                          &pResult);

    if (dwErr != DS_NAME_NO_ERROR) {
        DebugMsg(( DM_WARNING, L"TranslateNameXForest: Failed to crack names with error %d", dwErr ));
        goto Exit;
    }

    if ( pResult->cItems == 0 ) {
        DebugMsg(( DM_WARNING, L"TranslateNameXForest: Failed to return enough result items" ));
        dwErr = ERROR_INVALID_DATA;
        goto Exit;
    }


    if ( pResult->rItems[0].status == DS_NAME_NO_ERROR ) {
        
        //
        // In case of no error, return the resolved name
        //
        DWORD dwTransNameLength = 1 + lstrlen(pResult->rItems[0].pName);
        szTransName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR) * ( dwTransNameLength ));

        if (!szTransName) {
            DebugMsg(( DM_WARNING, L"TranslateNameXForest: Failed to allocate memory for domain" ));
            dwErr = GetLastError();
            goto Exit;
        }

        HRESULT hr = StringCchCopy(szTransName, dwTransNameLength, pResult->rItems[0].pName);

        if(FAILED(hr)) {
            dwErr = HRESULT_CODE(hr);
            goto Exit;
        }

        *lpTranslatedName = szTransName;
        szTransName = NULL;
    }
    else {
        
        //
        // remap the error code to win32 error
        //

        DebugMsg(( DM_WARNING, L"TranslateNameXForest: DsCrackNames failed with error %d", pResult->rItems[0].status ));
        dwErr = MapDsNameError(pResult->rItems[0].status);
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if ( szTransName ) {
        LocalFree( szTransName );
    }
    
    if ( pDCInfo ) {
        NetApiBufferFree(pDCInfo);
    }
    
    if (hDS) {
        DsUnBind( &hDS );
    }

    if (pResult) {
        DsFreeNameResult(pResult);
    }

    if ( !bRet )
    {
        SetLastError( dwErr );
    }
    return bRet;
}

//-------------------------------------------------------

LPTSTR GetDomainFromSOM (LPTSTR lpSOM)
{
    LPTSTR lpFullName, lpResult;
    LPOLESTR lpLdapDomain, lpDomainName;
    HRESULT hr;
    ULONG ulNoChars;

    ulNoChars = lstrlen(lpSOM) + 10;
    lpFullName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpFullName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to allocate memory with %d."), GetLastError()));
        return NULL;
    }

    hr = StringCchCopy (lpFullName, ulNoChars, TEXT("LDAP://"));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (lpFullName, ulNoChars, lpSOM);
    }

    if (FAILED(hr))
    {
        LocalFree(lpFullName);
        return NULL;
    }

    lpLdapDomain = GetDomainFromLDAPPath(lpFullName);

    LocalFree (lpFullName);

    if (!lpLdapDomain)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to get ldap domain name from path.")));
        return NULL;
    }

    hr = ConvertToDotStyle (lpLdapDomain, &lpDomainName);

    delete [] lpLdapDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetDomainFromSOM: Failed to convert to dot style.")));
        return NULL;
    }

    ulNoChars = lstrlen(lpDomainName) + 1;
    lpResult = new TCHAR[ulNoChars];

    if (lpResult)
    {
        hr = StringCchCopy (lpResult, ulNoChars, lpDomainName);
        ASSERT(SUCCEEDED(hr));
    }

    LocalFree (lpDomainName);

    return lpResult;
}
//-------------------------------------------------------

WCHAR * ExtractDomain(WCHAR * sz)
{
    // parse through the string looking for a forward slash
    DWORD cch = 0;
    if (!sz)
    {
        return NULL;
    }
    while (sz[cch])
    {
        if (L'\\' == sz[cch] || L'/' == sz[cch])
        {
            WCHAR * szNew = new WCHAR[cch+1];
            if (szNew)
            {
                wcsncpy(szNew, sz, cch);
                szNew[cch] = TEXT('\0');
            }
            return szNew;
        }
        cch++;
    }

    // didn't find a forward slash
    return NULL;
}


//*************************************************************
//
//  MyLookupAccountName()
//
//  Purpose:    Gets the SID of the user
//
//  Parameters:
//      szSystemName:   Machine where the account should be resolved
//      szAccName:      The actual account name
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
// Allocates and retries with the appropriate buffer size

LPTSTR MyLookupAccountName(LPTSTR szSystemName, LPTSTR szAccName)
{
    PSID            pSid = NULL;
    DWORD           cSid = 0, cbDomain = 0;
    SID_NAME_USE    peUse;
    LPTSTR          lpSidString = NULL, szDomain = NULL;
    DWORD           dwErr = 0;
    BOOL            bRet = FALSE;


    LookupAccountName(szSystemName, szAccName, NULL, &cSid, NULL, &cbDomain, &peUse);

    pSid = (PSID)LocalAlloc(LPTR, cSid);

    szDomain = (LPTSTR) LocalAlloc(LPTR, cbDomain*(sizeof(TCHAR)));

    if (!pSid || !szDomain) {
        return NULL;
    }


    if (!LookupAccountName(szSystemName, szAccName, pSid, &cSid, szDomain, &cbDomain, &peUse)) {
        DebugMsg((DM_WARNING, TEXT("MyLookupAccountName:  LookupAccountName failed with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    if (!ConvertSidToStringSid(pSid, &lpSidString)) {
        DebugMsg((DM_WARNING, TEXT("MyLookupAccountName:  ConvertSidToStringSid failed with %d"),
                 GetLastError()));
        dwErr = GetLastError();
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if (pSid) {
        LocalFree(pSid);
    }

    if (szDomain) {
        LocalFree(szDomain);
    }

    if (!bRet) {
        SetLastError(dwErr);
        return NULL;
    }
    else {
        return lpSidString;
    }
}
//-------------------------------------------------------

void GetControlText(HWND hDlg, DWORD ctrlid, TCHAR * &szControlText, BOOL bUseLocalAlloc)
{
    UINT nSize;

    if ( szControlText != NULL )
    {
        if ( bUseLocalAlloc )
        {
            LocalFree( szControlText );
        }
        else
        {
            delete [] szControlText;
        }
        szControlText = NULL;
    }
    
    nSize = (UINT) SendMessage(GetDlgItem(hDlg, ctrlid),
                    WM_GETTEXTLENGTH, 0, 0);

    if (nSize > 0)
    {
        if ( bUseLocalAlloc )
        {
            szControlText = (TCHAR*)LocalAlloc( LPTR, (nSize+1)*sizeof(TCHAR) );
        }
        else
        {
            szControlText =  new TCHAR[nSize + 1];
        }
        if (szControlText)
        {
            LPTSTR lpDest, lpSrc;

            GetDlgItemText(hDlg, ctrlid, szControlText, nSize + 1);

            if (szControlText[0] == TEXT(' '))
            {
                //
                // Remove leading blanks by shuffling the characters forward
                //

                lpDest = lpSrc = szControlText;

                while ((*lpSrc == TEXT(' ')) && *lpSrc)
                    lpSrc++;

                if (*lpSrc)
                {
                    while (*lpSrc)
                    {
                        *lpDest = *lpSrc;
                        lpDest++;
                        lpSrc++;
                    }
                    *lpDest = TEXT('\0');
                }
            }

            //
            // Remove trailing blanks
            //

            lpDest = szControlText + lstrlen(szControlText) - 1;

            while ((*lpDest == TEXT(' ')) && (lpDest >= szControlText))
                lpDest--;

            *(lpDest+1) = TEXT('\0');
        }
    }
}

//-------------------------------------------------------

HRESULT ImplementBrowseButton(HWND hDlg, DWORD dwFlagsUp, DWORD dwFlagsDown,
                              DWORD dwflScope, HWND hLB, TCHAR * &szFoundObject)
{
        // shell the object picker to get the computer list
        HRESULT                 hr = E_FAIL;
        IDsObjectPicker *       pDsObjectPicker = NULL;
        const ULONG             cbNumScopes = 4;    //make sure this number matches the number of scopes initialized
        DSOP_SCOPE_INIT_INFO    ascopes [cbNumScopes];
        DSOP_INIT_INFO          InitInfo;
        IDataObject *           pdo = NULL;
        STGMEDIUM               stgmedium = {
                                                TYMED_HGLOBAL,
                                                NULL
                                            };
        UINT                    cf = 0;
        FORMATETC               formatetc = {
                                                (CLIPFORMAT)cf,
                                                NULL,
                                                DVASPECT_CONTENT,
                                                -1,
                                                TYMED_HGLOBAL
                                            };
        BOOL                    bAllocatedStgMedium = FALSE;
        PDS_SELECTION_LIST      pDsSelList = NULL;
        PDS_SELECTION           pDsSelection = NULL;
        ULONG                   ulSize, ulIndex, ulMax;
        LPWSTR                  lpTemp;
        LPTSTR                  szDomain = NULL;
        LPWSTR                  szUnEscapedPath = NULL;

        hr = CoInitialize (NULL);

        if (FAILED(hr))
            goto Browse_Cleanup;

        hr = CoCreateInstance (CLSID_DsObjectPicker,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IDsObjectPicker,
                               (void **) & pDsObjectPicker
                               );

        if (FAILED(hr))
            goto Browse_Cleanup;

        //Initialize the scopes.
        ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));

        ascopes[0].cbSize = ascopes[1].cbSize = ascopes[2].cbSize = ascopes[3].cbSize
            = sizeof (DSOP_SCOPE_INIT_INFO);

        ascopes[0].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        ascopes[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP
                             | DSOP_SCOPE_FLAG_STARTING_SCOPE | dwflScope;
        ascopes[0].FilterFlags.Uplevel.flBothModes = dwFlagsUp;

        ascopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        ascopes[1].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        ascopes[2].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN |
                            DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        ascopes[2].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[2].FilterFlags.flDownlevel = dwFlagsDown;
        ascopes[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        ascopes[3].flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE |
                            DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE |
                            DSOP_SCOPE_TYPE_WORKGROUP;
        ascopes[3].FilterFlags.Uplevel.flBothModes = dwFlagsUp;
        ascopes[3].FilterFlags.flDownlevel = dwFlagsDown;
        ascopes[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP | dwflScope;

        //populate the InitInfo structure that will be used to initialize the
        //object picker
        ZeroMemory (&InitInfo, sizeof (DSOP_INIT_INFO));

        InitInfo.cbSize = sizeof (DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = cbNumScopes;
        InitInfo.aDsScopeInfos = ascopes;
        InitInfo.flOptions = (hLB ? DSOP_FLAG_MULTISELECT : 0);

        hr = pDsObjectPicker->Initialize (&InitInfo);

        if (FAILED(hr))
            goto Browse_Cleanup;

        hr = pDsObjectPicker->InvokeDialog (hDlg, &pdo);

        //if the computer selection dialog cannot be invoked or if the user
        //hits cancel, bail out.
        if (FAILED(hr) || S_FALSE == hr)
            goto Browse_Cleanup;

       //if we are here, the user chose, OK, so find out what group was chosen
       cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);

       if (0 == cf)
           goto Browse_Cleanup;

       //set the clipboard format for the FORMATETC structure
       formatetc.cfFormat = (CLIPFORMAT)cf;

       hr = pdo->GetData (&formatetc, &stgmedium);

       if (FAILED (hr))
           goto Browse_Cleanup;

       bAllocatedStgMedium = TRUE;

       pDsSelList = (PDS_SELECTION_LIST) GlobalLock (stgmedium.hGlobal);



       //
       // Decide what the max number of items to process is
       //

       ulMax = pDsSelList->cItems;

       if (!hLB && (ulMax > 1))
       {
          ulMax = 1;
       }


       //
       // Loop through the items
       //

       for (ulIndex = 0; ulIndex < ulMax; ulIndex++)
       {

           pDsSelection = &(pDsSelList->aDsSelection[ulIndex]);


           //
           // Find the beginning of the object name after the domain name
           //

           lpTemp = pDsSelection->pwzADsPath + 7;

           while (*lpTemp && *lpTemp != TEXT('/'))
           {
               lpTemp++;
           }

           if (!(*lpTemp))
           {
               hr = E_FAIL;
               goto Browse_Cleanup;
           }

           lpTemp++;

           ulSize = wcslen(lpTemp);

           //
           // Convert the name from full DN to sam compatible
           //

            szDomain = GetDomainFromSOM( lpTemp );

            // 
            // ADSI escapes '/' which is not liked by native ldap. 
            // APIs like DsCrackNames/TranslateName etc.
            // Previous function (GetDomainFromSOM) needs it though 
            // because it is using adsi interfaces internally
            //

            hr = UnEscapeLdapPath(lpTemp, &szUnEscapedPath);

            if (FAILED(hr))
            {
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                DebugMsg((DM_WARNING, TEXT("ImplementBrowseButton: UnEscapeLdapPath for %s failed with 0x%x."),
                         lpTemp, hr));
                goto Browse_Cleanup;
            }

            if (TranslateNameXForest ( szDomain, szUnEscapedPath, (DS_NAME_FORMAT)NameFullyQualifiedDN,
                                       (DS_NAME_FORMAT)NameSamCompatible, &szFoundObject ))
            {
                BOOL bDollarRemoved = FALSE;

                if (szFoundObject[wcslen(szFoundObject)-1] == L'$')
                {
                    bDollarRemoved = TRUE;
                    szFoundObject[wcslen(szFoundObject)-1] = 0;
                }

                if (hLB)
                {
                    INT iIndex;

                    iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szFoundObject);
                    SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) ((bDollarRemoved) ? 2: 0));

                    SendMessage (hLB, LB_SETCURSEL, (WPARAM) iIndex, 0);
                    LocalFree( szFoundObject );
                    szFoundObject = NULL;
                }
            }
            else
            {                
                hr = HRESULT_FROM_WIN32(GetLastError());
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                DebugMsg((DM_WARNING, TEXT("ImplementBrowseButton: TranslateName for %s to SAM style failed with %d."),
                         lpTemp, GetLastError()));
                goto Browse_Cleanup;
            }
       }


    Browse_Cleanup:
        if (szUnEscapedPath)
            LocalFree(szUnEscapedPath);

        if (pDsSelList)
            GlobalUnlock (pDsSelList);
        if (bAllocatedStgMedium)
            ReleaseStgMedium (&stgmedium);
        if (pdo)
            pdo->Release();
        if (pDsObjectPicker)
            pDsObjectPicker->Release();
        if (szDomain)
            delete [] szDomain;
    return hr;
}

//-------------------------------------------------------

HRESULT GetForestFromDC( LPTSTR szDC, LPTSTR* pszForest )
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* psDomainInfo( NULL );
    DWORD dwResult( ERROR_SUCCESS );

    if ( (szDC == NULL) || (*pszForest != NULL) )
    {
        return E_INVALIDARG;
    }

    dwResult = ::DsRoleGetPrimaryDomainInformation( szDC, DsRolePrimaryDomainInfoBasic, (PBYTE*) &psDomainInfo );
    if ( dwResult != ERROR_SUCCESS )
    {
        return HRESULT_FROM_WIN32( dwResult );
    }

    CopyString( psDomainInfo->DomainForestName, pszForest );

    ::DsRoleFreeMemory( psDomainInfo );
    
    return S_OK;
}

//-------------------------------------------------------

HRESULT GetForestFromObject( LPTSTR szDomainObject, LPTSTR* pszForest )
{
    HRESULT hr = E_FAIL;
    LPTSTR szDomain = ExtractDomain( szDomainObject );

    if ( szDomain != NULL )
    {
        LPTSTR szDC = GetDCName( szDomain, NULL, NULL, FALSE, 0, DS_RETURN_DNS_NAME);
        if ( szDC != NULL )
        {
            hr = GetForestFromDC( szDC, pszForest );

            LocalFree( szDC );
        }

        delete [] szDomain;
    }

    return hr;
}

//-------------------------------------------------------

HRESULT GetForestFromContainer( LPTSTR szDSContainer, LPTSTR* pszForest )
{
    HRESULT hr = E_FAIL;
    LPTSTR szDomain = GetDomainFromSOM( szDSContainer );

    if ( szDomain != NULL )
    {
        LPTSTR szDC = GetDCName( szDomain, NULL, NULL, FALSE, 0, DS_RETURN_DNS_NAME);
        if ( szDC != NULL )
        {
            hr = GetForestFromDC( szDC, pszForest );

            LocalFree( szDC );
        }

        delete [] szDomain;
    }

    return hr;
}


//---------------------------------------------------------------------------
// CRSOPWizardDlg class
//

CRSOPWizardDlg::CRSOPWizardDlg( LPRSOP_QUERY pQuery, CRSOPExtendedProcessing* pExtendedProcessing )
{
    m_bPostXPBuild = FALSE; // Assume this is not post XP until verified as otherwise
    OSVERSIONINFOEX osvi;

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx ((OSVERSIONINFO*) &osvi) )
    {
        // Windows XP was version 5.1, while .Net Server is version 5.2. So, we enable the
        //  additional features for any version past XP, i.e. >= 5.2
        m_bPostXPBuild = (osvi.dwMajorVersion >= 5) && (osvi.dwMinorVersion >= 2) && (VER_NT_WORKSTATION != osvi.wProductType);
    }

    m_dwSkippedFrom = 0;
    
    m_pRSOPQuery = pQuery;
    m_pRSOPQueryResults = NULL;

    m_hrQuery = E_FAIL;
    m_bNoChooseQuery = FALSE;

    // Initialize local variables
    m_szDefaultUserSOM = NULL;
    m_szDefaultComputerSOM = NULL;
    m_pComputerObject = NULL;
    m_pUserObject = NULL;

    m_bDollarRemoved = FALSE;
    m_bNoCurrentUser = FALSE;

    m_dwDefaultUserSecurityGroupCount = 0;
    m_aszDefaultUserSecurityGroups = NULL;
    m_adwDefaultUserSecurityGroupsAttr = NULL;

    m_dwDefaultUserWQLFilterCount = 0;
    m_aszDefaultUserWQLFilters = NULL;
    m_aszDefaultUserWQLFilterNames = NULL;
    
    m_dwDefaultComputerSecurityGroupCount = 0;
    m_aszDefaultComputerSecurityGroups = NULL;
    m_adwDefaultComputerSecurityGroupsAttr = NULL;

    m_dwDefaultComputerWQLFilterCount = 0;
    m_aszDefaultComputerWQLFilters = NULL;
    m_aszDefaultComputerWQLFilterNames = NULL;
    m_bFinalNextClicked = FALSE;

    m_pExtendedProcessing = pExtendedProcessing;
    m_lPlanningFinishedPage = 0;
    m_lLoggingFinishedPage = 0;
}

//-------------------------------------------------------

CRSOPWizardDlg::~CRSOPWizardDlg()
{
    delete [] m_szDefaultUserSOM;
    delete [] m_szDefaultComputerSOM;

    if ( m_pComputerObject != NULL )
    {
        m_pComputerObject->Release();
        m_pComputerObject = NULL;
    }

    if ( m_pUserObject != NULL )
    {
        m_pUserObject->Release();
        m_pUserObject = NULL;
    }

    if ( m_dwDefaultUserSecurityGroupCount != 0 )
    {
        LocalFree( m_aszDefaultUserSecurityGroups );
        LocalFree( m_adwDefaultUserSecurityGroupsAttr );
    }
    
    if ( m_dwDefaultUserWQLFilterCount != 0 )
    {
        LocalFree( m_aszDefaultUserWQLFilters );
        LocalFree( m_aszDefaultUserWQLFilterNames );
    }
    
    if ( m_dwDefaultComputerSecurityGroupCount != 0 )
    {
        LocalFree( m_aszDefaultComputerSecurityGroups );
        LocalFree( m_adwDefaultComputerSecurityGroupsAttr );
    }

    if ( m_dwDefaultComputerWQLFilterCount != 0 )
    {
        LocalFree( m_aszDefaultComputerWQLFilters );
        LocalFree( m_aszDefaultComputerWQLFilterNames );
    }
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::FreeUserData ()
// RSOP_PLANNING_MODE : Only called from RSOPTargetDlgProc
{
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        FreeTargetData( m_pRSOPQuery->pUser );
        m_pRSOPQuery->pUser->bAssumeWQLFiltersTrue = TRUE;
    }
    else
    {
        LocalFree( m_pRSOPQuery->szUserName );
        m_pRSOPQuery->szUserName = NULL;
        LocalFree( m_pRSOPQuery->szUserSid );
        m_pRSOPQuery->szUserSid = NULL;
    }
        
    if ( m_szDefaultUserSOM != NULL )
    {
        delete [] m_szDefaultUserSOM;
        m_szDefaultUserSOM = NULL;
    }

    if ( m_dwDefaultUserSecurityGroupCount != 0 )
    {
        FreeStringList( m_dwDefaultUserSecurityGroupCount, m_aszDefaultUserSecurityGroups );
        m_aszDefaultUserSecurityGroups = NULL;
        LocalFree( m_adwDefaultUserSecurityGroupsAttr );
        m_adwDefaultUserSecurityGroupsAttr = NULL;
        m_dwDefaultUserSecurityGroupCount = 0;
    }

    if ( m_dwDefaultUserWQLFilterCount != 0 )
    {
        FreeStringList( m_dwDefaultUserWQLFilterCount, m_aszDefaultUserWQLFilterNames );
        m_aszDefaultUserWQLFilterNames = NULL;
        FreeStringList( m_dwDefaultUserWQLFilterCount, m_aszDefaultUserWQLFilters );
        m_aszDefaultUserWQLFilters = NULL;
        m_dwDefaultUserWQLFilterCount = 0;
    }

    if ( m_pUserObject != NULL )
    {
        m_pUserObject->Release();
        m_pUserObject = NULL;
    }
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::FreeComputerData ()
// RSOP_PLANNING_MODE : Only called from RSOPTargetDlgProc
{
    if ( m_pRSOPQuery->QueryType == RSOP_PLANNING_MODE )
    {
        FreeTargetData( m_pRSOPQuery->pComputer );
        m_pRSOPQuery->pComputer->bAssumeWQLFiltersTrue = TRUE;
    }
    else
    {
        LocalFree( m_pRSOPQuery->szComputerName );
        m_pRSOPQuery->szComputerName = NULL;
    }
        
    if ( m_szDefaultComputerSOM != NULL )
    {
        delete [] m_szDefaultComputerSOM;
        m_szDefaultComputerSOM = NULL;
    }

    if ( m_dwDefaultComputerSecurityGroupCount != 0 )
    {
        FreeStringList( m_dwDefaultComputerSecurityGroupCount, m_aszDefaultComputerSecurityGroups );
        m_aszDefaultComputerSecurityGroups = NULL;
        LocalFree( m_adwDefaultComputerSecurityGroupsAttr );
        m_adwDefaultComputerSecurityGroupsAttr = NULL;
        m_dwDefaultComputerSecurityGroupCount = 0;
    }

    if ( m_dwDefaultComputerWQLFilterCount != 0 )
    {
        FreeStringList( m_dwDefaultComputerWQLFilterCount, m_aszDefaultComputerWQLFilterNames );
        m_aszDefaultComputerWQLFilterNames = NULL;
        FreeStringList( m_dwDefaultComputerWQLFilterCount, m_aszDefaultComputerWQLFilters );
        m_aszDefaultComputerWQLFilters = NULL;
        m_dwDefaultComputerWQLFilterCount = 0;
    }

    if ( m_pComputerObject != NULL )
    {
        m_pComputerObject->Release();
        m_pComputerObject = NULL;
    }
}

//-------------------------------------------------------
// Wizard interface

HRESULT CRSOPWizardDlg::ShowWizard( HWND hParent )
{
    HRESULT hr = E_FAIL;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage;
    TCHAR szTitle[150];
    TCHAR szSubTitle[300];
    
    HPROPSHEETPAGE hShowNowPages[20];
    DWORD          dwCount=0, dwDiagStartPage = 0, dwPlanStartPage = 0, dwDiagFinishPage = 0, dwPlanFinishPage = 0;



    hr = SetupFonts();
    if ( FAILED(hr) )
    {
        return hr;
    }

    // ------------------------------
    // Create all the wizard property pages

    // (1) --- Welcome ---
    // LoadString (g_hInstance, IDS_TITLE_WELCOME, szTitle, ARRAYSIZE(szTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    // psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.dwFlags = PSP_HIDEHEADER;
     
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WELCOME);
    psp.pfnDlgProc = RSOPWelcomeDlgProc;
    psp.lParam = (LPARAM) this;
    //psp.pszHeaderTitle = szTitle;
    psp.pszHeaderTitle = NULL;
    psp.pszHeaderSubTitle = NULL;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (2) --- Choose Mode ---
    LoadString (g_hInstance, IDS_TITLE_CHOOSEMODE, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_CHOOSEMODE, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_CHOOSEMODE);
    psp.pfnDlgProc = RSOPChooseModeDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (3) --- GetComp ---
    LoadString (g_hInstance, IDS_TITLE_GETCOMP, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_GETCOMP, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETCOMP);
    psp.pfnDlgProc = RSOPGetCompDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwDiagStartPage = dwCount;
    dwCount++;

    // (4) --- GetUser ---
    LoadString (g_hInstance, IDS_TITLE_GETUSER, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_GETUSER, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETUSER);
    psp.pfnDlgProc = RSOPGetUserDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (5) --- GetTarget ---
    LoadString (g_hInstance, IDS_TITLE_GETTARGET, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_GETTARGET, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETTARGET);
    psp.pfnDlgProc = RSOPGetTargetDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwPlanStartPage = dwCount;
    dwCount++;

    // (6) --- GetDC ---
    LoadString (g_hInstance, IDS_TITLE_GETDC, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_GETDC, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_GETDC);
    psp.pfnDlgProc = RSOPGetDCDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (7) --- AltDirs ---
    LoadString (g_hInstance, IDS_TITLE_ALTDIRS, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_ALTDIRS, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTDIRS);
    psp.pfnDlgProc = RSOPAltDirsDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (8) --- AltUserSec ---
    LoadString (g_hInstance, IDS_TITLE_USERSECGRPS, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_USERSECGRPS, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTUSERSEC);
    psp.pfnDlgProc = RSOPAltUserSecDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (9) --- AltCompSec ---
    LoadString (g_hInstance, IDS_TITLE_COMPSECGRPS, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_COMPSECGRPS, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_ALTCOMPSEC);
    psp.pfnDlgProc = RSOPAltCompSecDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (10) --- WQLUser ---
    LoadString (g_hInstance, IDS_TITLE_WQLUSER, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_WQL, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WQLUSER);
    psp.pfnDlgProc = RSOPWQLUserDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (11) --- WQLComp ---
    LoadString (g_hInstance, IDS_TITLE_WQLCOMP, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_WQL, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_WQLCOMP);
    psp.pfnDlgProc = RSOPWQLCompDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    // (12) --- Finished ---
    LoadString (g_hInstance, IDS_TITLE_FINISHED, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_FINISHED, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    if ( m_pExtendedProcessing != NULL )
    {
        m_lLoggingFinishedPage = IDD_RSOP_FINISHED_INT;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED_INT);
    }
    else
    {
        m_lLoggingFinishedPage = IDD_RSOP_FINISHED;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED);
    }
    psp.pfnDlgProc = RSOPFinishedDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwDiagFinishPage = dwCount;
    dwCount++;

    // (13) --- Finished3 ---
    LoadString (g_hInstance, IDS_TITLE_FINISHED, szTitle, ARRAYSIZE(szTitle));
    LoadString (g_hInstance, IDS_SUBTITLE_FINISHED, szSubTitle, ARRAYSIZE(szSubTitle));
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.hInstance = g_hInstance;
    if ( m_pExtendedProcessing != NULL )
    {
        m_lPlanningFinishedPage = IDD_RSOP_FINISHED3_INT;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED3_INT);
    }
    else
    {
        m_lPlanningFinishedPage = IDD_RSOP_FINISHED3;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED3);
    }
    psp.pfnDlgProc = RSOPFinishedDlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = szTitle;
    psp.pszHeaderSubTitle = szSubTitle;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwPlanFinishPage = dwCount;
    dwCount++;

    // (14) --- Finished2 ---
    ::memset( &psp, 0, sizeof(PROPSHEETPAGE) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_HIDEHEADER;
    psp.hInstance = g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_RSOP_FINISHED2);
    psp.pfnDlgProc = RSOPFinished2DlgProc;
    psp.lParam = (LPARAM) this;
    psp.pszHeaderTitle = NULL;
    psp.pszHeaderSubTitle = NULL;

    hPage = CreatePropertySheetPage(&psp);
    if (!hPage)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: Failed to create property sheet page with %d."),
                  GetLastError()));
        return E_FAIL;
    }

    hShowNowPages[dwCount] = hPage;
    dwCount++;

    if ( (m_pRSOPQuery->dwFlags & RSOP_FIX_QUERYTYPE) == RSOP_FIX_QUERYTYPE )
    {
        m_bNoChooseQuery = FALSE;
    }
    else
    {
        m_bNoChooseQuery = ((m_pRSOPQuery->dwFlags & RSOP_FIX_COMPUTER) == RSOP_FIX_COMPUTER)
                        || ((m_pRSOPQuery->dwFlags & RSOP_FIX_DC) == RSOP_FIX_DC)
                        || ((m_pRSOPQuery->dwFlags & RSOP_FIX_SITENAME) == RSOP_FIX_SITENAME)
                        || ((m_pRSOPQuery->dwFlags & RSOP_FIX_USER) == RSOP_FIX_USER);
    }

    // ------------------------------
    // Now create the Property Sheet

    INT_PTR         iRet;
    PROPSHEETHEADER psph;

    ::memset( &psph, 0, sizeof(PROPSHEETHEADER) );
    psph.dwSize = sizeof(PROPSHEETHEADER);
    psph.dwFlags = PSH_WIZARD97 | PSH_HEADER | PSH_WATERMARK;
    psph.hwndParent = hParent;
    psph.hInstance = g_hInstance;
    psph.nPages = dwCount;
    psph.pszbmHeader = MAKEINTRESOURCE(IDB_HEADER);
    psph.pszbmWatermark = MAKEINTRESOURCE(IDB_WIZARD);


    // if (dwFlags & RSOPMSC_OVERRIDE)
    if ( (m_pRSOPQuery->dwFlags & RSOP_NO_WELCOME) == RSOP_NO_WELCOME )
    {
        // RM: This condition translates to a case where an MSC was loaded but where parameters where passed, overriding
        //  the values in the MSC file.
        psph.nStartPage = ( m_pRSOPQuery->QueryType == RSOP_LOGGING_MODE) ? dwDiagStartPage : dwPlanStartPage;
        DebugMsg((DM_VERBOSE, TEXT("CRSOPWizardDlg::CreatePropertyPages: Showing prop sheet in override mode.")));
    }

    psph.phpage  = hShowNowPages;

    DebugMsg((DM_VERBOSE, TEXT("CRSOPWizardDlg::CreatePropertyPages: Showing prop sheet.")));
    iRet = PropertySheet(&psph);

    if (iRet == -1) {
        DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::CreatePropertyPages: PropertySheet failed with error %d."),
                  GetLastError()));
    }

    // user cancelled in the wizard
    if (iRet != IDOK)
    {
        return S_FALSE;
    }

    return m_hrQuery;
}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::RunQuery( HWND hParent )
{
    if ( DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_RSOP_STATUSMSC),
                       hParent, InitRsopDlgProc, (LPARAM) this ) == -1)
    {

        HRESULT hr = HRESULT_FROM_WIN32( GetLastError() );
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::Load: Falied to create dialog box. 0x%x"), hr));
        return hr;
    }

    return m_hrQuery;
}

//-------------------------------------------------------
// RSOP generation dialog method

INT_PTR CALLBACK CRSOPWizardDlg::InitRsopDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    TCHAR szMessage[200];

    switch (message)
    {
        case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            if (pWizard)
            {
                CRSOPWizard::InitializeResultsList (GetDlgItem (hDlg, IDC_LIST1));
                CRSOPWizard::FillResultsList (GetDlgItem (hDlg, IDC_LIST1), pWizard->m_pRSOPQuery, NULL);
            }

            PostMessage(hDlg, WM_INITRSOP, 0, 0);
            return TRUE;
        }

        case WM_INITRSOP:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);
                        
            // RM: InitializeRSOP used to be called here, but now we go directly to GenerateRSOPEx
            pWizard->m_hrQuery = CRSOPWizard::GenerateRSOPDataEx(hDlg, pWizard->m_pRSOPQuery, &(pWizard->m_pRSOPQueryResults) );
            if ( pWizard->m_hrQuery != S_OK )
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitRsopDlgProc: GenerateRSOPEx failed with 0x%x."), hr));
                EndDialog(hDlg, 0);
                return TRUE;
            }
            
            if ( pWizard->m_pExtendedProcessing != NULL )
            {
                pWizard->m_pExtendedProcessing->DoProcessing( pWizard->m_pRSOPQuery,
                                                              pWizard->m_pRSOPQueryResults,
                                                              pWizard->m_pExtendedProcessing->GetExtendedErrorInfo() );
            }

            EndDialog(hDlg, 1);
            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPWelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
    case WM_INITDIALOG:
        {
            TCHAR szDefaultGPO[128];


            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            SendMessage(GetDlgItem(hDlg, IDC_RSOP_BIG_BOLD1),
                        WM_SETFONT, (WPARAM)pWizard->m_BigBoldFont, (LPARAM)TRUE);

/*
            if (!pWizard->m_hChooseBitmap)
            {
                pWizard->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                            MAKEINTRESOURCE(IDB_WIZARD),
                                                            IMAGE_BITMAP, 0, 0,
                                                            LR_DEFAULTCOLOR);
            }

            if (pWizard->m_hChooseBitmap)
            {
                SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                    IMAGE_BITMAP, (LPARAM) pWizard->m_hChooseBitmap);
            }
*/
        }

        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }
        }

        break;
    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_NEXT);
                break;

            case PSN_WIZNEXT:
                if ( (pQuery->dwFlags & RSOP_FIX_QUERYTYPE) == RSOP_FIX_QUERYTYPE )
                {
                    if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETTARGET);
                    }
                    else
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETCOMP);
                    }
                    return TRUE;
                }
                // otherwise we fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPChooseModeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg*pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            if ( IsStandaloneComputer() || !pWizard->m_bPostXPBuild )
            {
                EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                CheckRadioButton( hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2 );
            }
            else if ( pQuery->QueryType == RSOP_PLANNING_MODE )
            {
                CheckRadioButton( hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1 );
            }
            else
            {
                CheckRadioButton( hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2 );
            }
            break;
        }

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_WIZNEXT:
                {
                    // First make sure that we do not come back to this page
                    pQuery->dwFlags |= RSOP_NO_WELCOME;

                    // Now get the right mode
                    RSOP_QUERY_TYPE QueryType = RSOP_LOGGING_MODE;
                    if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                    {
                        QueryType = RSOP_PLANNING_MODE;
                    }

                    if ( pQuery->QueryType != QueryType )
                    {
                        // First free any mode related information in the object
                        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                        {
                            pWizard->FreeUserData();
                            pWizard->FreeComputerData();
                        }
                        
                        ChangeRSOPQueryType( pQuery, QueryType );
                    }

                    if ( QueryType == RSOP_PLANNING_MODE )
                    {
                        // Skip to the planning mode pages
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETTARGET);
                        return TRUE;
                    }
                }
                break;
                
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPGetCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_LOGGING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (LOWORD(wParam))
            {
            case IDC_EDIT1:
                if (HIWORD(wParam) == EN_CHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }

                break;
            case IDC_BUTTON1:
                {
                    TCHAR * sz;

                    if (ImplementBrowseButton(hDlg, DSOP_FILTER_COMPUTERS,
                                              DSOP_DOWNLEVEL_FILTER_COMPUTERS,
                                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS,
                                              NULL, sz) == S_OK)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, sz);
                        LocalFree( sz );
                     }
                }
                break;

            case IDC_RADIO1:
                SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO2:
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                SetFocus (GetDlgItem(hDlg, IDC_EDIT1));
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        {
            UINT n;

            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }
            
            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            DWORD dwWizBack = PSWIZB_BACK;
            if ( pWizard->m_bNoChooseQuery )
            {
                dwWizBack = 0;
            }

            if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
            {
                n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);

                if (n > 0 )
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), dwWizBack | PSWIZB_NEXT);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), dwWizBack);
                }
            }
            else
            {
                PropSheet_SetWizButtons(GetParent(hDlg), dwWizBack | PSWIZB_NEXT);
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_WIZBACK:
                if ( (pQuery->dwFlags & RSOP_FIX_QUERYTYPE) == RSOP_FIX_QUERYTYPE )
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WELCOME);
                }
                else
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_CHOOSEMODE);
                }
                return TRUE;
                
            case PSN_WIZNEXT:
                {
                    LPTSTR szNewComputerName = NULL;
                    if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        GetControlText(hDlg, IDC_EDIT1, szNewComputerName, TRUE );

                        if ( szNewComputerName != NULL )
                        {
                            TCHAR* szNormalizedComputerName;
                            
                            // We need to handle the case where the user enters a name 
                            // prefixed by '\\'

                            szNormalizedComputerName = NormalizedComputerName( szNewComputerName );
                            
                            // If we detect the '\\' prefix, we must remove it since this syntax
                            // is not recognized by the RSoP provider
                            if ( szNormalizedComputerName != szNewComputerName )
                            {
                                LPTSTR szReplaceComputerName;
                                HRESULT hr;
                                ULONG ulNoChars;

                                ulNoChars = lstrlen(szNormalizedComputerName)+1;
                                szReplaceComputerName = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );

                                if ( szReplaceComputerName != NULL )
                                {
                                    hr = StringCchCopy( szReplaceComputerName, ulNoChars, szNormalizedComputerName );
                                    ASSERT(SUCCEEDED(hr));
                                }

                                LocalFree( szNewComputerName );

                                szNewComputerName = szReplaceComputerName;
                            }
                        }
                    }
                    else
                    {
                        ULONG ulNoChars = 2;
                        HRESULT hr;

                        szNewComputerName =  (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                        if ( szNewComputerName != NULL )
                        {
                            hr = StringCchCopy( szNewComputerName, ulNoChars, L"." );
                            ASSERT(SUCCEEDED(hr));
                        }
                    }

                    BOOL bComputerNameChanged = FALSE;
                    if ( pQuery->szComputerName != NULL )
                    {
                        if ( szNewComputerName && ( lstrcmpi( pQuery->szComputerName, szNewComputerName ) != 0 ) )
                        {
                            LocalFree( pQuery->szComputerName );
                            pQuery->szComputerName = szNewComputerName;
                            bComputerNameChanged = TRUE;
                        }
                        else
                        {
                            LocalFree( szNewComputerName );
                        }
                    }
                    else
                    {
                        pQuery->szComputerName = szNewComputerName;
                        bComputerNameChanged = TRUE;
                    }
                    
                    if ( pWizard->TestAndValidateComputer (hDlg) )
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                        if ( ((pQuery->dwFlags & RSOP_FIX_USER) != RSOP_FIX_USER)
                            && bComputerNameChanged )
                        {
                            if ( pQuery->szUserName != NULL )
                            {
                                LocalFree( pQuery->szUserName );
                                pQuery->szUserName = NULL;
                            }

                            if ( pQuery->szUserSid != NULL )
                            {
                                LocalFree( pQuery->szUserSid );
                                pQuery->szUserSid = NULL;
                            }
                        }
                    }
                    else
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_CHECK1) == BST_CHECKED)
                    {
                        pQuery->dwFlags |= RSOP_NO_COMPUTER_POLICY;
                    }
                    else
                    {
                        pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_COMPUTER_POLICY ^ 0xffffffff);
                    }
                }
                return TRUE;

            case PSN_SETACTIVE:
                {
                    if ( (pQuery->dwFlags & RSOP_FIX_COMPUTER) == RSOP_FIX_COMPUTER )
                    {
                        CheckRadioButton( hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2 );
                        EnableWindow( GetDlgItem( hDlg, IDC_RADIO1 ), FALSE );
                        SetDlgItemText( hDlg, IDC_EDIT1, pQuery->szComputerName );
                        CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                        EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                    }
                    else
                    {
                        if ( (pQuery->szComputerName != NULL) && (lstrcmpi( pQuery->szComputerName, L"." ) != 0) )
                        {
                            CheckRadioButton( hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2 );
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                            EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                            SetDlgItemText( hDlg, IDC_EDIT1, pQuery->szComputerName );
                            SetFocus (GetDlgItem(hDlg, IDC_EDIT1));
                        }
                        else
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                            EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                            SetDlgItemText( hDlg, IDC_EDIT1, _T("") );
                            SetFocus (GetDlgItem(hDlg, IDC_RADIO1));
                        }
                    
                        if ( (pQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY )
                        {
                            pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_COMPUTER_POLICY ^ 0xffffffff);
                            CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), FALSE);
                        }
                        else if ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
                        {
                            CheckDlgButton (hDlg, IDC_CHECK1, BST_CHECKED);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), TRUE);
                        }
                        else
                        {
                            CheckDlgButton (hDlg, IDC_CHECK1, BST_UNCHECKED);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), TRUE);
                        }
                    }
                    
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;


            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
            break;
        }
    }


    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPGetUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_LOGGING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            LVCOLUMN lvcol;
            RECT rect;
            HWND hLV = GetDlgItem(hDlg, IDC_LIST1);

            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            GetClientRect(hLV, &rect);

            ZeroMemory(&lvcol, sizeof(lvcol));

            lvcol.mask = LVCF_FMT | LVCF_WIDTH;
            lvcol.fmt = LVCFMT_LEFT;
            lvcol.cx = rect.right - GetSystemMetrics(SM_CYHSCROLL);
            ListView_InsertColumn(hLV, 0, &lvcol);

            SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_WIZNEXT:
            case PSN_WIZBACK:
                {
                    LPTSTR lpData;
                    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
                    INT iSel;


                    if ( (pQuery->dwFlags & RSOP_FIX_USER) != RSOP_FIX_USER )
                    {
                        if ( pQuery->szUserName != NULL )
                        {
                            LocalFree( pQuery->szUserName );
                            pQuery->szUserName = NULL;
                        }

                        if ( pQuery->szUserSid != NULL )
                        {
                            LocalFree( pQuery->szUserSid );
                            pQuery->szUserSid = NULL;
                        }

                        if (IsDlgButtonChecked (hDlg, IDC_RADIO4) == BST_CHECKED)
                        {
                            pQuery->dwFlags |= RSOP_NO_USER_POLICY;
                        }
                        else
                        {
                            pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_USER_POLICY ^ 0xffffffff);

                            if (IsDlgButtonChecked (hDlg, IDC_RADIO1))
                            {
                                LPTSTR lpTemp;

                                if ( IsStandaloneComputer() )
                                {
                                    pQuery->szUserName = MyGetUserName (NameUnknown);
                                }
                                else
                                {
                                    pQuery->szUserName = MyGetUserName (NameSamCompatible);
                                }

                                HRESULT hr;
                                ULONG ulNoChars = 2;

                                pQuery->szUserSid = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );

                                if ( pQuery->szUserSid != NULL )
                                {
                                    hr = StringCchCopy( pQuery->szUserSid, ulNoChars, TEXT(".") );
                                    ASSERT(SUCCEEDED(hr));
                                }
                            }
                            else
                            {
                                iSel = (INT) SendMessage(hList, LVM_GETNEXTITEM, (WPARAM) -1, MAKELPARAM(LVNI_SELECTED, 0));

                                if (iSel != -1)
                                {
                                    pQuery->szUserName = (TCHAR*)LocalAlloc( LPTR, 200 * sizeof(TCHAR) );
                                    if ( pQuery->szUserName != NULL )
                                    {
                                        LVITEM item;

                                        ZeroMemory (&item, sizeof(item));

                                        item.mask = LVIF_TEXT | LVIF_PARAM;
                                        item.iItem =  iSel;
                                        item.pszText = pQuery->szUserName;
                                        item.cchTextMax = 200;

                                        if (SendMessage(hList, LVM_GETITEM, 0, (LPARAM) &item))
                                        {

                                            lpData = (LPTSTR) item.lParam;

                                            if (lpData)
                                            {
                                                ULONG ulNoChars;
                                                HRESULT hr;

                                                ulNoChars = lstrlen(lpData) + 1;
                                                pQuery->szUserSid = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                                                if ( pQuery->szUserSid != NULL )
                                                {
                                                    hr = StringCchCopy( pQuery->szUserSid, ulNoChars, lpData );
                                                    ASSERT(SUCCEEDED(hr));
                                                }
                                            }
                                        }
                                    }
                                }

                            }   // if (IsDlgButtonChecked (hDlg, IDC_RADIO1))
                        }

                    }
                    if ( ((NMHDR FAR*)lParam)->code == PSN_WIZNEXT )
                    {
                        // Skip to the last page in the wizard
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lLoggingFinishedPage);
                        return TRUE;
                    }
                }
                break;

            case PSN_SETACTIVE:
                {
                    HRESULT hr;
                    BOOL bFixedUserFound;
                    BOOL bCurrentUserFound;
                    HWND hList = GetDlgItem(hDlg, IDC_LIST1);
                    SendMessage(hList, LVM_DELETEALLITEMS, 0 ,0);
                    PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                    
                    hr = pWizard->FillUserList (hList, &bCurrentUserFound, &bFixedUserFound);
                    if ( FAILED(hr) )
                    {
                        ReportError (hDlg, hr, IDS_ENUMUSERSFAILED);
                        // RsopEnumerateUsers failed. It should be safe to disable user policy setting in all cases
                        pQuery->dwFlags |= RSOP_NO_USER_POLICY; 

                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                    }
                    else if ( (pQuery->dwFlags & RSOP_FIX_USER) == RSOP_FIX_USER )
                    {
                        if ( bFixedUserFound )
                        {
                            // Disable current user radio button
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);
                        }
                        else
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                        }
                    }
                    else
                    {
                        // If there is no computer policy, then we should at least have user policy, so disable
                        if ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
                        {
                            pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_USER_POLICY ^ 0xffffffff);
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);
                        }
                        else if ( ((pQuery->dwFlags & RSOP_NO_USER_POLICY) == RSOP_NO_USER_POLICY)
                                    || (ListView_GetItemCount (hList) == 0) )
                        {
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                        }
                        else
                        {
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                        }

                        if ( (!lstrcmpi( pQuery->szComputerName, TEXT("."))) && bCurrentUserFound )
                        {
                            pWizard->m_bNoCurrentUser = FALSE;
                        }
                        else
                        {
                            pWizard->m_bNoCurrentUser = TRUE;
                        }

                        if ( (pQuery->szUserSid != NULL)
                                && !lstrcmpi( pQuery->szUserSid, TEXT("."))
                                && !pWizard->m_bNoCurrentUser )
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
                        }
                        else if ( (pQuery->szUserSid == NULL) && !pWizard->m_bNoCurrentUser )
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
                        }
                        else if ( ListView_GetItemCount (hList) != 0 )
                        {
                            CheckRadioButton (hDlg, IDC_RADIO1, IDC_RADIO2, IDC_RADIO2);

                            if ( pQuery->szUserName != NULL )
                            {
                                LVFINDINFO FindInfo;
                                LVITEM item;
                                INT iRet;
                                
                                ZeroMemory (&FindInfo, sizeof(FindInfo));
                                FindInfo.flags = LVFI_STRING;
                                FindInfo.psz = pQuery->szUserName;

                                iRet =  (INT) SendMessage (hList, LVM_FINDITEM,
                                                           (WPARAM) -1, (LPARAM) &FindInfo);

                                if (iRet != -1)
                                {
                                    ZeroMemory (&item, sizeof(item));
                                    item.mask = LVIF_STATE;
                                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                                    SendMessage (hList, LVM_SETITEMSTATE, (WPARAM) -1, (LPARAM) &item);

                                    ZeroMemory (&item, sizeof(item));
                                    item.mask = LVIF_STATE;
                                    item.iItem = iRet;
                                    item.state = LVIS_SELECTED | LVIS_FOCUSED;
                                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                                    SendMessage (hList, LVM_SETITEMSTATE, (WPARAM) iRet, (LPARAM) &item);
                                }
                            }
                        }
                        else
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                            CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                            EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                        }
                     }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;


            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;

            case LVN_DELETEITEM:
                {
                    NMLISTVIEW * pNMListView = (NMLISTVIEW *) lParam;

                    if (pNMListView && pNMListView->lParam)
                    {
                        delete [] ((LPTSTR)pNMListView->lParam);
                    }
                }
                break;
            }
        }
        break;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_RADIO1:
                CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO2:
                CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO3:
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            case IDC_RADIO4:
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;
            }
        }
        break;

    case WM_REFRESHDISPLAY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            if ( (pQuery->dwFlags & RSOP_FIX_USER) == RSOP_FIX_USER )
            {
                break;
            }

            int iListCount = ListView_GetItemCount(GetDlgItem(hDlg, IDC_LIST1));
            
            if (IsDlgButtonChecked (hDlg, IDC_RADIO4) == BST_CHECKED)
            {
                // Disable list of users while "Do not display user policy" radio is selected
                EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO1), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO2), FALSE);

                if ( pWizard->m_bNoCurrentUser && (iListCount == 0)
                    && ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY ) )
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }
                else
                {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
            }
            else
            {
                // Enable/disable inner radio buttons
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO1), !pWizard->m_bNoCurrentUser);
                EnableWindow(GetDlgItem(hDlg, IDC_RADIO2), iListCount != 0);
                    
                if ( !pWizard->m_bNoCurrentUser || (iListCount != 0) )
                {
                    if ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
                    {
                        pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_USER_POLICY ^ 0xffffffff);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);

                    }
                    else
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), TRUE);
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_RADIO2) == BST_CHECKED)
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), TRUE);

                        if ( iListCount != 0 )
                        {
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                            SetFocus (GetDlgItem(hDlg, IDC_LIST1));
                        }
                        else
                        {
                            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                        }
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    }
                }
                else
                {
                    if ( (pQuery->dwFlags & RSOP_NO_COMPUTER_POLICY) == RSOP_NO_COMPUTER_POLICY )
                    {
                        // If the user said no computer data but he has access to no users,
                        //  enable on back button and disable the checkbox
                        pQuery->dwFlags = pQuery->dwFlags & (RSOP_NO_USER_POLICY ^ 0xffffffff);

                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO3);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO4), FALSE);

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                    }
                    else
                    {
                        // This is an error condition where ::FillUserList failed
                        EnableWindow(GetDlgItem(hDlg, IDC_LIST1), FALSE);
                        CheckRadioButton(hDlg, IDC_RADIO3, IDC_RADIO4, IDC_RADIO4);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                    }
                }
            }
        }
         break;

    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPGetTargetDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            LPTSTR lpText, lpPath;
    
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
    
            if ( pWizard != NULL )
            {
                lpText = MyGetUserName(NameSamCompatible);
    
                if (lpText)
                {
                    SetDlgItemText (hDlg, IDC_EDIT6, lpText);
                    LocalFree (lpText);
                }
    
                lpText = MyGetUserName(NameFullyQualifiedDN);
    
                if (lpText)
                {
                    lpPath = pWizard->GetDefaultSOM(lpText);
    
                    if (lpPath)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT5, lpPath);
                        delete [] lpPath;
                    }
    
                    LocalFree (lpText);
                }
            }
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (LOWORD(wParam))
            {
            case IDC_RADIO1:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), TRUE);
                if ( pQuery->pUser->szSOM != NULL )
                {
                    SetDlgItemText( hDlg, IDC_EDIT1, pQuery->pUser->szSOM );
                }

                SetDlgItemText (hDlg, IDC_EDIT2, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO2:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), TRUE);
                if ( pQuery->pUser->szName != NULL )
                {
                    SetDlgItemText( hDlg, IDC_EDIT2, pQuery->pUser->szName );
                }

                SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO3:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), TRUE);
                if ( pQuery->pComputer->szSOM != NULL )
                {
                    SetDlgItemText( hDlg, IDC_EDIT3, pQuery->pComputer->szSOM );
                }

                SetDlgItemText (hDlg, IDC_EDIT4, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_RADIO4:
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), TRUE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), TRUE);
                if ( pQuery->pComputer->szName != NULL )
                {
                    // RM: The computer name account in the DS actually has a '$' at the end. We strip it here for display
                    //  purposes, but will add it again ...
                    if ( (wcslen(pQuery->pComputer->szName) >= 1)
                        && (pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)-1] == L'$') )
                    {
                        pWizard->m_bDollarRemoved = TRUE;
                        pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)-1] = L'\0';
                    }
                    SetDlgItemText(hDlg, IDC_EDIT4, pQuery->pComputer->szName );
                    if ( pWizard->m_bDollarRemoved )
                    {
                        pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)] = L'$';
                        pWizard->m_bDollarRemoved = FALSE;
                    }
                }

                SetDlgItemText (hDlg, IDC_EDIT3, TEXT(""));
                EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), FALSE);

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case IDC_EDIT1:
            case IDC_EDIT2:
            case IDC_EDIT3:
            case IDC_EDIT4:
                if (HIWORD(wParam) == EN_CHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BROWSE1:
                {
                DSBROWSEINFO dsbi = {0};
                TCHAR *szResult;
                TCHAR szTitle[256];
                TCHAR szCaption[256];
                dsbi.hwndOwner = hDlg;
                dsbi.pszCaption = szTitle;
                dsbi.pszTitle = szCaption;
                dsbi.cbStruct = sizeof(dsbi);
                dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
                dsbi.pfnCallback = DsBrowseCallback;

                szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);

                if (szResult) {
                    dsbi.pszPath = szResult;
                    dsbi.cchPath = 4000;

                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));

                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        LPWSTR  szDN;
                        HRESULT hr;
                        
                        // skipping 7 chars for LDAP:// in the szResult
                        hr = UnEscapeLdapPath(szResult+7, &szDN);

                        if (FAILED(hr))
                        {
                            ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                        }
                        else {
                            SetDlgItemText(hDlg, IDC_EDIT1, szDN);
                            LocalFree(szDN);
                        }
                    }
                    
                    LocalFree(szResult);

                }
                }
                break;

            case IDC_BROWSE2:
                {
                TCHAR * sz;

                if (ImplementBrowseButton(hDlg, DSOP_FILTER_USERS,
                                          DSOP_DOWNLEVEL_FILTER_USERS,
                                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS,
                                          NULL, sz) == S_OK)
                {
                    SetDlgItemText (hDlg, IDC_EDIT2, sz);
                    LocalFree( sz );
                }
                }
                break;

            case IDC_BROWSE3:
                {
                    DSBROWSEINFO dsbi = {0};
                    TCHAR *szResult;
                    TCHAR szTitle[256];
                    TCHAR szCaption[256];
                    dsbi.hwndOwner = hDlg;
                    dsbi.pszCaption = szTitle;
                    dsbi.pszTitle = szCaption;
                    dsbi.cbStruct = sizeof(dsbi);
                    dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
                    dsbi.pfnCallback = DsBrowseCallback;

                    szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);

                    if (szResult) {
                        dsbi.pszPath = szResult;
                        dsbi.cchPath = 4000;
                        LoadString(g_hInstance,
                                   IDS_BROWSE_COMPUTER_OU_TITLE,
                                   szTitle,
                                   ARRAYSIZE(szTitle));
                        LoadString(g_hInstance,
                                   IDS_BROWSE_COMPUTER_OU_CAPTION,
                                   szCaption,
                                   ARRAYSIZE(szCaption));
                        if (IDOK == DsBrowseForContainer(&dsbi))
                        {
                            LPWSTR  szDN;
                            HRESULT hr;

                            // skipping 7 chars for LDAP:// in the szResult
                            hr = UnEscapeLdapPath(szResult+7, &szDN);

                            if (FAILED(hr))
                            {
                                ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                            }
                            else {
                                SetDlgItemText(hDlg, IDC_EDIT3, szDN);
                                LocalFree(szDN);
                            }
                        }

                        LocalFree(szResult);
                    }

                }
                break;

            case IDC_BROWSE4:
                {
                    TCHAR * sz;

                    if (ImplementBrowseButton(hDlg, DSOP_FILTER_COMPUTERS,
                                              DSOP_DOWNLEVEL_FILTER_COMPUTERS,
                                              DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS,
                                              NULL, sz) == S_OK)
                    {
                        SetDlgItemText (hDlg, IDC_EDIT4, sz);
                        LocalFree( sz );
                    }
                }
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        {
            UINT n;

            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }
            
            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT2), WM_GETTEXTLENGTH, 0, 0);
            }

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT3), WM_GETTEXTLENGTH, 0, 0);
            }

            if (n == 0)
            {
               n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT4), WM_GETTEXTLENGTH, 0, 0);
            }

            DWORD dwWizBack = PSWIZB_BACK;
            if ( pWizard->m_bNoChooseQuery )
            {
                dwWizBack = 0;
            }

            if (n > 0 )
            {
                PropSheet_SetWizButtons(GetParent(hDlg), dwWizBack | PSWIZB_NEXT);
            }
            else
            {
                PropSheet_SetWizButtons(GetParent(hDlg), dwWizBack);
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    // RM: Fill dialog with current user values
                    if ( pQuery->pUser->szName != NULL )
                    {
                        CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT2, pQuery->pUser->szName);
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), TRUE);

                        CheckDlgButton (hDlg, IDC_RADIO1, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT1, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), FALSE);
                    }
                    else if ( pQuery->pUser->szSOM != NULL )
                    {
                        CheckDlgButton (hDlg, IDC_RADIO1, BST_CHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT1, pQuery->pUser->szSOM);
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), TRUE);

                        CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT2, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
                    }
                    else
                    {
                        CheckDlgButton (hDlg, IDC_RADIO1, BST_CHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT1, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), TRUE);

                        CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT2, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
                    }

                    // Disable certain items if the user must remain fixed
                    if ( (pQuery->dwFlags & RSOP_FIX_USER) == RSOP_FIX_USER )
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_RADIO1), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_RADIO2), FALSE);
                        if ( pQuery->pUser->szName != NULL )
                        {
                            EnableWindow (GetDlgItem (hDlg, IDC_EDIT2), FALSE);
                            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE2), FALSE);
                        }
                        else if ( pQuery->pUser->szSOM != NULL )
                        {
                            EnableWindow (GetDlgItem (hDlg, IDC_EDIT1), FALSE);
                            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE1), FALSE);
                        }
                    }

                    // RM: Fill dialog with current computer values
                    if ( pQuery->pComputer->szName != NULL )
                    {
                        CheckDlgButton (hDlg, IDC_RADIO4, BST_CHECKED);
                        // RM: The computer name account in the DS actually has a '$' at the end. We strip it here for display
                        //  purposes, but will add it again ...
                        if ( (wcslen(pQuery->pComputer->szName) >= 1)
                            && (pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)-1] == L'$') )
                        {
                            pWizard->m_bDollarRemoved = TRUE;
                            pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)-1] = L'\0';
                        }
                        SetDlgItemText(hDlg, IDC_EDIT4, pQuery->pComputer->szName );
                        if ( pWizard->m_bDollarRemoved )
                        {
                            pQuery->pComputer->szName[wcslen(pQuery->pComputer->szName)] = L'$';
                            pWizard->m_bDollarRemoved = FALSE;
                        }
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), TRUE);
                        
                        CheckDlgButton (hDlg, IDC_RADIO3, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT3, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), FALSE);
                    }
                    else if ( pQuery->pComputer->szSOM != NULL )
                    {
                        CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT3, pQuery->pComputer->szSOM);
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), TRUE);

                        CheckDlgButton (hDlg, IDC_RADIO4, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT4, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
                    }
                    else
                    {
                        CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT3, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), TRUE);

                        CheckDlgButton (hDlg, IDC_RADIO4, BST_UNCHECKED);
                        SetDlgItemText(hDlg, IDC_EDIT4, _T(""));
                        EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
                    }

                    // Disable certain items if the computer must remain fixed
                    if ( (pQuery->dwFlags & RSOP_FIX_COMPUTER) == RSOP_FIX_COMPUTER )
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_RADIO3), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_RADIO4), FALSE);
                        if ( pQuery->pComputer->szName != NULL )
                        {
                            EnableWindow (GetDlgItem (hDlg, IDC_EDIT4), FALSE);
                            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE4), FALSE);
                        }
                        else if ( pQuery->pComputer->szSOM != NULL )
                        {
                            EnableWindow (GetDlgItem (hDlg, IDC_EDIT3), FALSE);
                            EnableWindow (GetDlgItem (hDlg, IDC_BROWSE3), FALSE);
                        }
                    }
                    
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case PSN_WIZBACK:
                if ( (pQuery->dwFlags & RSOP_FIX_QUERYTYPE) == RSOP_FIX_QUERYTYPE )
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WELCOME);
                }
                else
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_CHOOSEMODE);
                }
                return TRUE;
                
            case PSN_WIZNEXT:
                {
                    HRESULT hr;
                    IDirectoryObject * pUserObject = NULL;
                    IDirectoryObject * pComputerObject = NULL;
                    LPTSTR lpUserName = NULL, lpUserSOM = NULL;
                    LPTSTR lpComputerName = NULL, lpComputerSOM = NULL;
                    LPTSTR lpFullName;

                    BOOL bUserChanged = TRUE;
                    BOOL bComputerChanged = TRUE;

                    SetWaitCursor();

                    // Get the user and dn name
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO1) == BST_CHECKED)
                    {
                        GetControlText(hDlg, IDC_EDIT1, lpUserSOM, FALSE);

                        if (lpUserSOM)
                        {
                            pWizard->EscapeString (&lpUserSOM);

                            hr = pWizard->TestSOM (lpUserSOM, hDlg);

                            if (FAILED(hr))
                            {
                                if (hr != E_INVALIDARG)
                                {
                                    ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                                }

                                delete [] lpUserSOM;

                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                return TRUE;
                            }
                        }
                    }
                    else
                    {
                        GetControlText(hDlg, IDC_EDIT2, lpUserName, FALSE);

                        if ( lpUserName )
                        {
                            lpUserSOM = ConvertName(lpUserName);
                            if (lpUserName && !lpUserSOM)
                            {
                                DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::RSOPGetTargetDlgProc: Failed to convert username %s to DN name with %d."), lpUserName, GetLastError()));

                                if (GetLastError() == ERROR_FILE_NOT_FOUND)
                                {
                                    ReportError (hDlg, 0, IDS_NOUSER2);
                                }
                                else
                                {
                                    ReportError (hDlg, GetLastError(), IDS_NOUSER);
                                }

                                delete [] lpUserName;

                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                return TRUE;
                            }

                            pWizard->EscapeString (&lpUserSOM);
                        }
                    }

                    if (lpUserSOM)
                    {
                        ULONG ulNoChars;

                        ulNoChars = lstrlen(lpUserSOM) + 10;
                        lpFullName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                        if (lpFullName)
                        {
                            hr = StringCchCopy (lpFullName, ulNoChars, TEXT("LDAP://"));
                            if (SUCCEEDED(hr)) 
                            {
                                hr = StringCchCat (lpFullName, ulNoChars, lpUserSOM);
                            }

                            if (SUCCEEDED(hr)) 
                            {

                                hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pUserObject);

                                if (FAILED(hr))
                                {
                                    DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::RSOPGetTargetDlgProc: Failed to bind to user object %s with %d."), lpFullName, hr));
                                    ReportError (hDlg, hr, IDS_NOUSERCONTAINER);

                                    if (lpUserName)
                                    {
                                        delete [] lpUserName;
                                    }

                                    LocalFree (lpFullName);
                                    delete [] lpUserSOM;

                                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                    return TRUE;
                                }
                            }

                            LocalFree (lpFullName);
                        }
                    }


                    // Get the computer and dn name
                    if (IsDlgButtonChecked(hDlg, IDC_RADIO3) == BST_CHECKED)
                    {
                        GetControlText(hDlg, IDC_EDIT3, lpComputerSOM, FALSE);

                        if (lpComputerSOM)
                        {
                            pWizard->EscapeString (&lpComputerSOM);

                            hr = pWizard->TestSOM (lpComputerSOM, hDlg);

                            if (FAILED(hr))
                            {
                                if (hr != E_INVALIDARG)
                                {
                                    ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                                }

                                delete [] lpComputerSOM;

                                if (lpUserName)
                                {
                                    delete [] lpUserName;
                                }

                                if (lpUserSOM)
                                {
                                    delete [] lpUserSOM;
                                }

                                if (pUserObject)
                                {
                                    pUserObject->Release();
                                    pUserObject = NULL;
                                }

                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                return TRUE;
                            }
                        }
                    }
                    else
                    {
                        GetControlText(hDlg, IDC_EDIT4, lpComputerName, FALSE );

                        if (lpComputerName)
                        {
                            ULONG ulNoChars;

                            ulNoChars = lstrlen(lpComputerName) + 2;
                            LPTSTR lpTempName = new TCHAR [ulNoChars];

                            if (lpTempName)
                            {
                                hr = StringCchCopy (lpTempName, ulNoChars, lpComputerName);
                                if (SUCCEEDED(hr)) 
                                {
                                    hr = StringCchCat (lpTempName, ulNoChars, TEXT("$"));
                                }
                                if (SUCCEEDED(hr)) 
                                {
                                    lpComputerSOM = ConvertName(lpTempName);
                                    delete [] lpComputerName;
                                    lpComputerName = lpTempName;
                                }
                            }
                        }

                        if (lpComputerName && !lpComputerSOM)
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::RSOPGetTargetDlgProc: Failed to convert computername %s to DN name with %d."), lpComputerName, GetLastError()));

                            if (GetLastError() == ERROR_FILE_NOT_FOUND)
                            {
                                ReportError (hDlg, 0, IDS_NOCOMPUTER2);
                            }
                            else
                            {
                                ReportError (hDlg, GetLastError(), IDS_NOCOMPUTER);
                            }

                            delete [] lpComputerName;

                            if (lpUserName)
                            {
                                delete [] lpUserName;
                            }

                            if (lpUserSOM)
                            {
                                delete [] lpUserSOM;
                            }

                            if (pUserObject)
                            {
                                pUserObject->Release();
                                pUserObject = NULL;
                            }

                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }

                        pWizard->EscapeString (&lpComputerSOM);
                    }

                    if (lpComputerSOM)
                    {
                        ULONG ulNoChars;

                        ulNoChars = lstrlen(lpComputerSOM) + 10;
                        lpFullName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                        if (lpFullName)
                        {
                            hr = StringCchCopy (lpFullName, ulNoChars, TEXT("LDAP://"));
                            if (SUCCEEDED(hr)) 
                            {
                                hr = StringCchCat (lpFullName, ulNoChars, lpComputerSOM);
                            }
                            if (SUCCEEDED(hr)) 
                            {
                                hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pComputerObject);

                                if (FAILED(hr))
                                {
                                    DebugMsg((DM_WARNING, TEXT("CRSOPWizardDlg::RSOPGetTargetDlgProc: Failed to bind to computer object %s with %d."), lpFullName, hr));
                                    ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);

                                    if (lpComputerName)
                                    {
                                        delete [] lpComputerName;
                                    }

                                    LocalFree (lpFullName);
                                    delete [] lpComputerSOM;

                                    if (lpUserName)
                                    {
                                        delete [] lpUserName;
                                    }

                                    if (lpUserSOM)
                                    {
                                        delete [] lpUserSOM;
                                    }

                                    if (pUserObject)
                                    {
                                        pUserObject->Release();
                                        pUserObject = NULL;
                                    }

                                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                    return TRUE;
                                }

                                LocalFree (lpFullName);
                            }
                        }
                    }

                    // Now check that both user and computer are in the same forest
                    if ( (lpUserSOM != NULL) && (lpComputerSOM != NULL) )
                    {
                        LPTSTR szComputerForest( NULL );
                        LPTSTR szUserForest( NULL );
                        BOOL bDifferentForests( FALSE );

                        hr = GetForestFromContainer( lpUserSOM, &szUserForest );
                        if ( SUCCEEDED(hr) )
                        {
                            hr = GetForestFromContainer( lpComputerSOM, &szComputerForest );
                            if ( SUCCEEDED(hr) )
                            {
                                if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE, szComputerForest, -1,
                                                        szUserForest, -1 ) != CSTR_EQUAL )
                                {
                                    bDifferentForests = TRUE;
                                    hr = E_INVALIDARG;
                                }
                                LocalFree( szComputerForest );
                            }
                            LocalFree( szUserForest );
                        }

                        if ( FAILED(hr) )
                        {
                            if ( bDifferentForests )
                            {
                                ReportError (hDlg, hr, IDS_NOCROSSFORESTALLOWED);
                            }
                            else
                            {
                                ReportError (hDlg, hr, IDS_CROSSFORESTFAILED);
                            }

                            if (lpComputerName)
                            {
                                delete [] lpComputerName;
                            }
                            delete [] lpComputerSOM;

                            if (lpUserName)
                            {
                                delete [] lpUserName;
                            }
                            delete [] lpUserSOM;

                            if (pUserObject)
                            {
                                pUserObject->Release();
                                pUserObject = NULL;
                            }

                            if (pComputerObject)
                            {
                                pComputerObject->Release();
                                pComputerObject = NULL;
                            }
                            
                            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                    }

                    // Store the user information
                    if ( (pQuery->pUser->szName != NULL) && (lpUserName != NULL) && (!lstrcmpi(pQuery->pUser->szName, lpUserName)))
                    {
                        bUserChanged = FALSE;

                        // Just reinitialize and reuse what we might need
                        if ( pWizard->m_szDefaultUserSOM == NULL )
                        {
                            pWizard->m_szDefaultUserSOM = pWizard->GetDefaultSOM (lpUserSOM);
                        }
                        if ( pWizard->m_pUserObject == NULL )
                        {
                            pWizard->m_pUserObject = pUserObject;
                            pUserObject = NULL;
                        }

                        // Now delete the unneeded stuff
                        delete [] lpUserName;

                        if (lpUserSOM)
                        {
                            delete [] lpUserSOM;
                        }

                        if (pUserObject)
                        {
                            pUserObject->Release();
                            pUserObject = NULL;
                        }
                    }
                    else if ( (pQuery->pUser->szName == NULL) && (lpUserName == NULL)
                                && (pQuery->pUser->szSOM != NULL) && (lpUserSOM != NULL)
                                && (!lstrcmpi( pQuery->pUser->szSOM, lpUserSOM)))
                    {
                        bUserChanged = FALSE;
                        
                        // Just reinitialize and reuse what we might need
                        if ( pWizard->m_szDefaultUserSOM == NULL )
                        {
                            pWizard->m_szDefaultUserSOM = pWizard->GetDefaultSOM (lpUserSOM);
                        }
                        if ( pWizard->m_pUserObject == NULL )
                        {
                            pWizard->m_pUserObject = pUserObject;
                            pUserObject = NULL;
                        }

                        // Now delete the unneeded stuff
                        delete [] lpUserSOM;
                        if (pUserObject)
                        {
                            pUserObject->Release();
                        }
                    }
                    else if ( (pQuery->pUser->szName == NULL) && (lpUserName == NULL)
                                && (pQuery->pUser->szSOM == NULL) && (lpUserSOM == NULL) )
                    {
                        bUserChanged = FALSE;
                        // No stuff to delete!
                    }
                    else
                    {
                        pWizard->FreeUserData();

                        if ( lpUserName != NULL )
                        {
                            ULONG  ulNoChars;

                            ulNoChars = lstrlen(lpUserName)+1;
                            pQuery->pUser->szName = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                            if ( pQuery->pUser->szName != NULL )
                            {
                                hr = StringCchCopy( pQuery->pUser->szName, ulNoChars, lpUserName );
                                ASSERT(SUCCEEDED(hr));
                            }
                            delete [] lpUserName;
                            
                            pWizard->m_szDefaultUserSOM = pWizard->GetDefaultSOM (lpUserSOM);
                            delete [] lpUserSOM;
                        }
                        else if ( lpUserSOM != NULL )
                        {
                            pQuery->pUser->szSOM = NULL;
                            (void)UnEscapeLdapPath(lpUserSOM, &(pQuery->pUser->szSOM));

                            delete [] lpUserSOM;
                        }

                        pWizard->m_pUserObject = pUserObject;
                    }


                    // Store the computer information
                    if ( (pQuery->pComputer->szName != NULL) && (lpComputerName != NULL) && !lstrcmpi(pQuery->pComputer->szName, lpComputerName) )
                    {
                        bComputerChanged = FALSE;
                        
                        // Just reinitialize and reuse what we might need
                        if ( pWizard->m_szDefaultComputerSOM == NULL )
                        {
                            pWizard->m_szDefaultComputerSOM = pWizard->GetDefaultSOM (lpComputerSOM);
                        }
                        if ( pWizard->m_pComputerObject== NULL )
                        {
                            pWizard->m_pComputerObject = pComputerObject;
                            pComputerObject = NULL;
                        }

                        // Now delete the unneeded stuff
                        delete [] lpComputerName;
                        if (lpComputerSOM)
                        {
                            delete [] lpComputerSOM;
                        }

                        if (pComputerObject)
                        {
                            pComputerObject->Release();
                            pComputerObject = NULL;
                        }
                    }
                    else if ( (pQuery->pComputer->szName == NULL) && (lpComputerName == NULL)
                                && (pQuery->pComputer->szSOM != NULL) && (lpComputerSOM != NULL)
                                && !lstrcmpi(pQuery->pComputer->szSOM, lpComputerSOM) )
                    {
                        bComputerChanged = FALSE;
                        
                        // Just reinitialize and reuse what we might need
                        if ( pWizard->m_szDefaultComputerSOM == NULL )
                        {
                            pWizard->m_szDefaultComputerSOM = pWizard->GetDefaultSOM (lpComputerSOM);
                        }
                        if ( pWizard->m_pComputerObject== NULL )
                        {
                            pWizard->m_pComputerObject = pComputerObject;
                            pComputerObject = NULL;
                        }

                        // Now delete the unneeded stuff
                        delete [] lpComputerSOM;

                        if (pComputerObject)
                        {
                            pComputerObject->Release();
                            pComputerObject = NULL;
                        }
                    }
                    else if ( (pQuery->pComputer->szName == NULL) && (lpComputerName == NULL)
                                && (pQuery->pComputer->szSOM == NULL) && (lpComputerSOM == NULL) )
                    {
                        bComputerChanged = FALSE;
                        // No stuff to delete!
                    }
                    else
                    {
                        pWizard->FreeComputerData ();

                        if ( lpComputerName != NULL )
                        {
                            ULONG ulNoChars;

                            ulNoChars = lstrlen(lpComputerName)+1;
                            pQuery->pComputer->szName = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                            if ( pQuery->pComputer->szName != NULL )
                            {
                                hr = StringCchCopy( pQuery->pComputer->szName, ulNoChars, lpComputerName );
                                ASSERT(SUCCEEDED(hr));
                            }
                            delete [] lpComputerName;

                            pWizard->m_szDefaultComputerSOM = pWizard->GetDefaultSOM (lpComputerSOM);
                            delete [] lpComputerSOM;
                        }
                        else if ( lpComputerSOM != NULL )
                        {
                            pQuery->pComputer->szSOM = NULL;
                            (void)UnEscapeLdapPath(lpComputerSOM, &(pQuery->pComputer->szSOM));

                            delete [] lpComputerSOM;
                        }

                        pWizard->m_pComputerObject = pComputerObject;
                    }

                    if ( (pQuery->dwFlags & RSOP_FIX_SITENAME) == RSOP_FIX_SITENAME )
                    {
                        LPTSTR szSiteFriendly = NULL;
                        if ( GetSiteFriendlyName( pQuery->szSite, &szSiteFriendly ) )
                        {
                            ULONG ulNoChars;

                            ulNoChars = lstrlen(szSiteFriendly)+1;
                            LocalFree( pQuery->szSite );
                            pQuery->szSite = (TCHAR*)LocalAlloc( LPTR, ulNoChars * sizeof(TCHAR) );
                            if ( pQuery->szSite != NULL )
                            {
                                hr = StringCchCopy( pQuery->szSite, ulNoChars, szSiteFriendly );
                                ASSERT(SUCCEEDED(hr));
                            }
                            delete [] szSiteFriendly;
                        }
                    }
                    // RM-TODO: Do not delete site name if it is already set and ? didn't change. First find out what ? is!
                    else if ( (bComputerChanged || bUserChanged) && (pQuery->szSite != NULL) )
                    {
                        LocalFree( pQuery->szSite );
                        pQuery->szSite = NULL;
                    }

                    if ( bUserChanged || bComputerChanged || (pQuery->szDomainController == NULL) )
                    {
                        // Set pQuery->szDomainController to the primary DC
                        LPTSTR szDomain = NULL;

                        // Determine the focused domain so we can focus on the correct DC.
                        if ( pQuery->pComputer->szName != NULL )
                        {
                            // Try and get the computer's domain
                            szDomain = ExtractDomain( pQuery->pComputer->szName );
                        }

                        if ( (szDomain == NULL) && (pQuery->pComputer->szSOM != NULL) )
                        {
                            // Try and get the computer's domain from the SOM
                            szDomain = GetDomainFromSOM( pQuery->pComputer->szSOM );
                        }

                        if ( (szDomain == NULL) && (pQuery->pUser->szName != NULL) )
                        {
                            // Try and get the user's domain
                            szDomain = ExtractDomain( pQuery->pUser->szName );
                        }

                        if ( (szDomain == NULL) && (pQuery->pUser->szSOM != NULL) )
                        {
                            // Try and get the user's domain from the SOM
                            szDomain = GetDomainFromSOM( pQuery->pUser->szSOM );
                        }

                        if ( szDomain == NULL )
                        {
                            // Use the local domain
                            LPTSTR szName;
                            szName = MyGetUserName(NameSamCompatible);
                            if ( szName != NULL )
                            {
                                szDomain = ExtractDomain(szName);
                                LocalFree( szName );
                            }
                        }

                        // RM: This is a hack! The command line parameter passed as the preferred DC is being used lower down
                        //  in this method as a parameter to GetDCName - this is the only known place where it is used.
                        LPTSTR szInheritServer = NULL;
                        if ( (pQuery->dwFlags & RSOP_FIX_DC) == RSOP_FIX_DC )
                        {
                            szInheritServer = pQuery->szDomainController;
                            pQuery->szDomainController = NULL;
                        }
                        
                        if ( pQuery->szDomainController != NULL )
                        {
                            LocalFree( pQuery->szDomainController );
                            pQuery->szDomainController = NULL;
                        }

                        LPTSTR lpDCName;
                        lpDCName = GetDCName (szDomain, szInheritServer, NULL, FALSE, 0, DS_RETURN_DNS_NAME);

                        if ( lpDCName != NULL )
                        {
                            pQuery->szDomainController = lpDCName;
                            lpDCName = NULL;
                        }

                        if ( szDomain != NULL )
                        {
                            delete [] szDomain;
                        }
                    }

                    // Reset the loopback mode if the computer or user is now empty
                    if ( (pQuery->LoopbackMode != RSOP_LOOPBACK_NONE) && (bComputerChanged || bUserChanged) )
                    {
                        if ( ((pQuery->pComputer->szName == NULL) && (pQuery->pComputer->szSOM == NULL))
                            || ((pQuery->pUser->szName == NULL) && (pQuery->pUser->szSOM == NULL)) )
                        pQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
                    }

                    ClearWaitCursor();
                }

                if (SendMessage(GetDlgItem(hDlg, IDC_BUTTON1), BM_GETCHECK, 0, 0))
                {
                    pWizard->m_dwSkippedFrom = IDD_RSOP_GETTARGET;

                    // skip to the final pages
                    SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                    return TRUE;
                }

                pWizard->m_dwSkippedFrom = 0;
                break;

            case PSN_WIZFINISH:
            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPGetDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    BOOL                    bEnable;

    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (LOWORD(wParam))
            {
                case IDC_CHECK2:
                    if (SendMessage (GetDlgItem(hDlg, IDC_CHECK2), BM_GETCHECK, 0, 0))
                    {
                        pQuery->LoopbackMode = RSOP_LOOPBACK_REPLACE;
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_CHECKED, 0);            
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                        
                        bEnable = TRUE;
                        if ( (NULL == pQuery->pUser->szName) && (NULL == pQuery->pUser->szSOM) )
                        {
                            bEnable = FALSE;
                        }
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), bEnable);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), bEnable);
                    }
                    else
                    {
                        pQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);            
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                    }
                    break;
                case IDC_RADIO2:
                    pQuery->LoopbackMode = RSOP_LOOPBACK_REPLACE;
                    break;
                case IDC_RADIO3:
                    pQuery->LoopbackMode = RSOP_LOOPBACK_MERGE;
                    break;
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                {
                    PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                    SetWaitCursor();

                    if ( pQuery->bSlowNetworkConnection )
                    {
                        CheckDlgButton(hDlg, IDC_CHECK1, BST_CHECKED);
                    }
                    else
                    {
                        CheckDlgButton(hDlg, IDC_CHECK1, BST_UNCHECKED);
                    }
                    
                    pWizard->InitializeSitesInfo (hDlg);

                    if ( (RSOP_LOOPBACK_NONE == pQuery->LoopbackMode)
                        || ( (RSOP_LOOPBACK_MERGE == pQuery->LoopbackMode)
                            && ( ((NULL == pQuery->pUser->szName) && (NULL == pQuery->pUser->szSOM))
                                || ((NULL == pQuery->pComputer->szName) && (NULL == pQuery->pComputer->szSOM)) ) )
                        || ( (RSOP_LOOPBACK_REPLACE == pQuery->LoopbackMode)
                            && (NULL == pQuery->pComputer->szName) && (NULL == pQuery->pComputer->szSOM) ) )
                    {
                        pQuery->LoopbackMode = RSOP_LOOPBACK_NONE;
                        SendMessage (GetDlgItem(hDlg, IDC_CHECK2), BM_SETCHECK, BST_UNCHECKED, 0);
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);
                        SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                        
                        if ( (NULL == pQuery->pComputer->szName) && (NULL == pQuery->pComputer->szSOM) )
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_CHECK2), FALSE);
                        }
                        else
                        {
                            EnableWindow (GetDlgItem(hDlg, IDC_CHECK2), TRUE);
                        }
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), FALSE);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), FALSE);
                    }
                    else
                    {
                        CheckDlgButton( hDlg, IDC_CHECK2, BST_CHECKED );

                        if ( RSOP_LOOPBACK_REPLACE == pQuery->LoopbackMode )
                        {
                            SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_CHECKED, 0);            
                            SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_UNCHECKED, 0);
                        }
                        else
                        {
                            SendMessage (GetDlgItem(hDlg, IDC_RADIO2), BM_SETCHECK, BST_UNCHECKED, 0);            
                            SendMessage (GetDlgItem(hDlg, IDC_RADIO3), BM_SETCHECK, BST_CHECKED, 0);
                        }
                        
                        bEnable = TRUE;
                        if ( (NULL == pQuery->pUser->szName) && (NULL == pQuery->pUser->szSOM) )
                        {
                            bEnable = FALSE;
                        }
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO2), bEnable);
                        EnableWindow (GetDlgItem(hDlg, IDC_RADIO3), bEnable);
                    }
                    
                    ClearWaitCursor();
                }
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                {
                    SetWaitCursor();

                    GetControlText(hDlg, IDC_COMBO1, pQuery->szSite, TRUE);

                    if ( pQuery->szSite != NULL )
                    {
                        TCHAR szName[30];

                        LoadString (g_hInstance, IDS_NONE, szName, ARRAYSIZE(szName));

                        if ( !lstrcmpi( pQuery->szSite, szName ) )
                        {
                            LocalFree( pQuery->szSite );
                            pQuery->szSite = NULL;
                        }
                    }

                    if (SendMessage(GetDlgItem(hDlg, IDC_CHECK1), BM_GETCHECK, 0, 0))
                    {
                        pQuery->bSlowNetworkConnection= TRUE;
                    }
                    else
                    {
                        pQuery->bSlowNetworkConnection = FALSE;
                    }

                    ClearWaitCursor();

                    if ( ((NMHDR FAR*)lParam)->code == PSN_WIZNEXT )
                    {
                        if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                        {
                            pWizard->m_dwSkippedFrom = IDD_RSOP_GETDC;
                            SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                            return TRUE;
                        }


                        if ( (NULL == pQuery->pUser->szName) && (NULL == pQuery->pComputer->szName) )
                        {
                            pWizard->m_dwSkippedFrom = IDD_RSOP_GETDC;

                            if ( (pQuery->pUser->szSOM != NULL) || (RSOP_LOOPBACK_NONE!= pQuery->LoopbackMode) )
                            {
                                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                            }
                            else if ( pQuery->pComputer->szSOM != NULL )
                            {
                                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                            }
                            else
                            {
                                SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                            }
                            return TRUE;
                        }

                        pWizard->m_dwSkippedFrom = 0;
                    }
                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
            break;
        }
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPAltDirsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
        }
        break;

    case WM_COMMAND:
        {
            DSBROWSEINFO dsbi = {0};
            TCHAR szTitle[256];
            TCHAR szCaption[256];
            TCHAR* szResult;
            dsbi.hwndOwner = hDlg;
            dsbi.pszCaption = szTitle;
            dsbi.pszTitle = szCaption;
            dsbi.cbStruct = sizeof(dsbi);
            dsbi.pszPath = NULL;
            dsbi.cchPath = 0;
            dsbi.dwFlags = DSBI_ENTIREDIRECTORY;
            dsbi.pfnCallback = DsBrowseCallback;

            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                // browse for user's OU

                szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);
                
                if ( szResult )
                {
                    dsbi.pszPath = szResult;
                    dsbi.cchPath = 4000;
                    
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_USER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        LPWSTR szDN;
                        HRESULT hr;

                        // skipping 7 chars for LDAP:// in the szResult
                        hr = UnEscapeLdapPath(szResult+7, &szDN);

                        if (FAILED(hr))
                        {
                            ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                        }
                        else {
                            SetDlgItemText(hDlg, IDC_EDIT1, szDN);
                            LocalFree(szDN);
                        }
                    }

                    LocalFree(szResult);
                }
                break;
                
            case IDC_BUTTON2:
                // browse for computer's OU

                szResult = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR)*4000);

                if ( szResult )
                {
                    dsbi.pszPath = szResult;
                    dsbi.cchPath = 4000;

                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_TITLE,
                               szTitle,
                               ARRAYSIZE(szTitle));
                    LoadString(g_hInstance,
                               IDS_BROWSE_COMPUTER_OU_CAPTION,
                               szCaption,
                               ARRAYSIZE(szCaption));
                    if (IDOK == DsBrowseForContainer(&dsbi))
                    {
                        LPWSTR szDN;
                        HRESULT hr;
                        
                        // skipping 7 chars for LDAP:// in the szResult
                        hr = UnEscapeLdapPath(szResult+7, &szDN);

                        if (FAILED(hr))
                        {
                            ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                        }
                        else {
                            SetDlgItemText(hDlg, IDC_EDIT2, szDN);
                            LocalFree(szDN);
                        }
                    }

                    LocalFree(szResult);
                }
                break;

            case IDC_BUTTON3:
                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT1)))
                {
                    if ( pWizard->m_szDefaultUserSOM != NULL )
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, pWizard->m_szDefaultUserSOM);
                    }
                }

                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT2)))
                {
                    if ( pWizard->m_szDefaultComputerSOM != NULL )
                    {
                        SetDlgItemText (hDlg, IDC_EDIT2, pWizard->m_szDefaultComputerSOM);
                    }
                }
                break;
            }
        }

        break;
    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);


                EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));

                if ( pQuery->pUser->szSOM != NULL )
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, pQuery->pUser->szSOM );
                    if ( pQuery->pUser->szName == NULL )
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                    }
                }
                else if ( pWizard->m_szDefaultUserSOM != NULL )
                {
                    SetDlgItemText (hDlg, IDC_EDIT1, pWizard->m_szDefaultUserSOM);
                }
                else if ( pQuery->pUser->szName == NULL )
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT1), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                }

                EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                SetDlgItemText (hDlg, IDC_EDIT2, TEXT(""));

                if ( pQuery->pComputer->szSOM != NULL )
                {
                    SetDlgItemText (hDlg, IDC_EDIT2, pQuery->pComputer->szSOM);
                    if ( pQuery->pComputer->szName == NULL )
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                    }
                }
                else if ( pWizard->m_szDefaultComputerSOM != NULL )
                {
                    SetDlgItemText (hDlg, IDC_EDIT2, pWizard->m_szDefaultComputerSOM);
                }
                else if ( pQuery->pComputer->szName == NULL )
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT2), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }

                if (IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT1))
                    || IsWindowEnabled (GetDlgItem(hDlg, IDC_EDIT2)))
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
                }
                else
                {
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                }
                break;

            case PSN_WIZBACK:
            case PSN_WIZNEXT:
                {
                    LPTSTR lpUserSOM = NULL, lpComputerSOM = NULL;
                    HRESULT hr;


                    GetControlText(hDlg, IDC_EDIT1, lpUserSOM, FALSE);
                    GetControlText(hDlg, IDC_EDIT2, lpComputerSOM, FALSE);

                    if (lpUserSOM)
                    {
                        pWizard->EscapeString(&lpUserSOM);

                        if (lpUserSOM)
                        {
                            hr = pWizard->TestSOM (lpUserSOM, hDlg);
                        }
                        else {
                            hr = E_FAIL;
                        }


                        if (FAILED(hr))
                        {
                            if (hr != E_INVALIDARG)
                            {
                                ReportError (hDlg, hr, IDS_NOUSERCONTAINER);
                            }

                            if (lpUserSOM)
                            {
                                delete [] lpUserSOM;
                            }

                            if (lpComputerSOM)
                            {
                                delete [] lpComputerSOM;
                            }

                            if ( ((NMHDR FAR*)lParam)->code == PSN_WIZNEXT )
                            {
                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                return TRUE;
                            }
                            else
                            {
                                return FALSE;
                            }
                        }
                    }

                    if (lpComputerSOM)
                    {
                        pWizard->EscapeString(&lpComputerSOM);

                        if (lpComputerSOM)
                        {
                            hr = pWizard->TestSOM (lpComputerSOM, hDlg);
                        }
                        else {

                            hr = E_FAIL;
                        }

                        if (FAILED(hr))
                        {
                            if (hr != E_INVALIDARG)
                            {
                                ReportError (hDlg, hr, IDS_NOCOMPUTERCONTAINER);
                            }

                            if (lpUserSOM)
                            {
                                delete [] lpUserSOM;
                            }

                            if (lpComputerSOM)
                            {
                                delete [] lpComputerSOM;
                            }

                            if ( ((NMHDR FAR*)lParam)->code == PSN_WIZNEXT )
                            {
                                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                return TRUE;
                            }
                            else
                            {
                                return FALSE;
                            }
                        }
                    }

                    if (lpUserSOM)
                    {
                        hr = UnEscapeLdapPath(lpUserSOM, &pQuery->pUser->szSOM);
                        delete [] lpUserSOM;
                        lpUserSOM = NULL;
                    }
                    else {
                        pQuery->pUser->szSOM = NULL;
                    }

                    if (lpComputerSOM)
                    {
                        hr = UnEscapeLdapPath(lpComputerSOM, &pQuery->pComputer->szSOM);
                        delete [] lpComputerSOM;
                        lpComputerSOM = NULL;
                    }
                    else {
                        pQuery->pComputer->szSOM = NULL;
                    }

                    if ( (pWizard->m_szDefaultUserSOM != NULL) && (pQuery->pUser->szSOM != NULL) )
                    {
                        if (!lstrcmpi(pWizard->m_szDefaultUserSOM, pQuery->pUser->szSOM))
                        {
                            LocalFree( pQuery->pUser->szSOM );
                            pQuery->pUser->szSOM = NULL;
                        }
                    }

                    if ( (pWizard->m_szDefaultComputerSOM != NULL) && (pQuery->pComputer->szSOM != NULL) )
                    {
                        if (!lstrcmpi(pWizard->m_szDefaultComputerSOM, pQuery->pComputer->szSOM))
                        {
                            LocalFree( pQuery->pComputer->szSOM );
                            pQuery->pComputer->szSOM = NULL;
                        }
                    }

                    if ( ((NMHDR FAR*)lParam)->code == PSN_WIZNEXT )
                    {
                        if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                        {
                            pWizard->m_dwSkippedFrom = IDD_RSOP_ALTDIRS;
                            SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                            return TRUE;
                        }

                        if ( (NULL == pQuery->pUser->szName) && (NULL == pQuery->pUser->szSOM) )
                        {
                            pWizard->m_dwSkippedFrom = IDD_RSOP_ALTDIRS;

                            if ( (pQuery->pComputer->szName != NULL) || (pQuery->pComputer->szSOM != NULL) )
                            {
                                if ( RSOP_LOOPBACK_NONE == pQuery->LoopbackMode)
                                {
                                    // skip to the alternate computer security page
                                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                                }
                                else
                                {
                                    // Skip to the alternate user security page if simulating loopback mode
                                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                                }
                            }
                            else
                            {
                                // skip to the finish page
                                SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                            }
                            return TRUE;
                        }

                        pWizard->m_dwSkippedFrom = 0;
                    }

                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

    INT_PTR CALLBACK CRSOPWizardDlg::RSOPAltUserSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                {
                    TCHAR * sz;

                    if ( ImplementBrowseButton(hDlg,
                                            (DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE),
                                            (DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),
                                            (DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS),
                                            GetDlgItem(hDlg, IDC_LIST1), sz) == S_OK )
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                        {
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                        }
                    }

                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON3:
                {
                    if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups );
                        pQuery->pUser->dwSecurityGroupCount = 0;
                        pQuery->pUser->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pUser->adwSecurityGroupsAttr );
                        pQuery->pUser->adwSecurityGroupsAttr = NULL;
                    }

                    if ( pWizard->m_dwDefaultUserSecurityGroupCount != 0 )
                    {
                        pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                                pWizard->m_dwDefaultUserSecurityGroupCount,
                                                                                pWizard->m_aszDefaultUserSecurityGroups,
                                                                                pWizard->m_adwDefaultUserSecurityGroupsAttr );
                    }
                    else
                    {
                        pWizard->BuildMembershipList( GetDlgItem(hDlg, IDC_LIST1),
                                                                       pWizard->m_pUserObject,
                                                                       &(pWizard->m_dwDefaultUserSecurityGroupCount),
                                                                       &(pWizard->m_aszDefaultUserSecurityGroups),
                                                                       &(pWizard->m_adwDefaultUserSecurityGroupsAttr) );
                    }
                                                                            
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_LIST1:
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_REFRESHDISPLAY:
        if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
        {
            INT iIndex;

            iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (iIndex != LB_ERR)
            {
                if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        } else {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

                if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                {
                    pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                            pQuery->pUser->dwSecurityGroupCount,
                                                                            pQuery->pUser->aszSecurityGroups,
                                                                            pQuery->pUser->adwSecurityGroupsAttr );

                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
                }
                else if ( pWizard->m_dwDefaultUserSecurityGroupCount != 0 )
                {
                    pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                            pWizard->m_dwDefaultUserSecurityGroupCount,
                                                                            pWizard->m_aszDefaultUserSecurityGroups,
                                                                            pWizard->m_adwDefaultUserSecurityGroupsAttr );
                                                                            
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                }
                else
                {
                    pWizard->BuildMembershipList( GetDlgItem(hDlg, IDC_LIST1),
                                                                   pWizard->m_pUserObject,
                                                                   &(pWizard->m_dwDefaultUserSecurityGroupCount),
                                                                   &(pWizard->m_aszDefaultUserSecurityGroups),
                                                                   &(pWizard->m_adwDefaultUserSecurityGroupsAttr) );
                                                                   
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                }


                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case PSN_WIZNEXT:
                {
                    // Free the previous list of security groups
                    if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups );
                        pQuery->pUser->dwSecurityGroupCount = 0;
                        pQuery->pUser->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pUser->adwSecurityGroupsAttr );
                        pQuery->pUser->adwSecurityGroupsAttr = NULL;
                    }

                    // Save the current list
                    pWizard->SaveSecurityGroups(  GetDlgItem(hDlg, IDC_LIST1),
                                                                    &(pQuery->pUser->dwSecurityGroupCount),
                                                                    &(pQuery->pUser->aszSecurityGroups),
                                                                    &(pQuery->pUser->adwSecurityGroupsAttr) );

                    // Compare the current list with the default list.  If the default list
                    // matches the current list, then delete the current list and just use
                    // the defaults
                    if ( pWizard->CompareStringLists( pWizard->m_dwDefaultUserSecurityGroupCount,
                                                                        pWizard->m_aszDefaultUserSecurityGroups,
                                                                        pQuery->pUser->dwSecurityGroupCount,
                                                                        pQuery->pUser->aszSecurityGroups ) )
                    {
                        if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                        {
                            FreeStringList( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups );
                            pQuery->pUser->dwSecurityGroupCount = 0;
                            pQuery->pUser->aszSecurityGroups = NULL;
                            LocalFree( pQuery->pUser->adwSecurityGroupsAttr );
                            pQuery->pUser->adwSecurityGroupsAttr = NULL;
                        }
                    }

                    // Now check where we should go
                    if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                    {
                        pWizard->m_dwSkippedFrom = IDD_RSOP_ALTUSERSEC;
                        // skip to the diagnostic pages
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                        return TRUE;
                    }

                    if ( (NULL == pQuery->pComputer->szName) && (NULL == pQuery->pComputer->szSOM) )
                    {
                        // skip to the finish page
                        pWizard->m_dwSkippedFrom = IDD_RSOP_ALTUSERSEC;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLUSER);
                        return TRUE;
                    }

                    pWizard->m_dwSkippedFrom = 0;
                }
                break;

            case PSN_WIZBACK:
                {
                    // Free the previous list of security groups
                    if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups );
                        pQuery->pUser->dwSecurityGroupCount = 0;
                        pQuery->pUser->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pUser->adwSecurityGroupsAttr );
                        pQuery->pUser->adwSecurityGroupsAttr = NULL;
                    }

                    // Save the current list
                    pWizard->SaveSecurityGroups(  GetDlgItem(hDlg, IDC_LIST1),
                                                                    &(pQuery->pUser->dwSecurityGroupCount),
                                                                    &(pQuery->pUser->aszSecurityGroups),
                                                                    &(pQuery->pUser->adwSecurityGroupsAttr) );

                    // Compare the current list with the default list.  If the default list
                    // matches the current list, then delete the current list and just use
                    // the defaults
                    if ( pWizard->CompareStringLists( pWizard->m_dwDefaultUserSecurityGroupCount,
                                                                        pWizard->m_aszDefaultUserSecurityGroups,
                                                                        pQuery->pUser->dwSecurityGroupCount,
                                                                        pQuery->pUser->aszSecurityGroups ) )
                    {
                        if ( pQuery->pUser->dwSecurityGroupCount != 0 )
                        {
                            FreeStringList( pQuery->pUser->dwSecurityGroupCount, pQuery->pUser->aszSecurityGroups );
                            pQuery->pUser->dwSecurityGroupCount = 0;
                            pQuery->pUser->aszSecurityGroups = NULL;
                            LocalFree( pQuery->pUser->adwSecurityGroupsAttr );
                            pQuery->pUser->adwSecurityGroupsAttr = NULL;
                        }
                    }

                    // Now check where we should go
                    if ( (pQuery->pUser->szName == NULL) && (pQuery->pComputer->szName == NULL) )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETDC);
                        return TRUE;
                    }
                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPAltCompSecDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON1:
                {
                    TCHAR * sz;

                    if ( ImplementBrowseButton(hDlg,
                                            (DSOP_FILTER_UNIVERSAL_GROUPS_SE | DSOP_FILTER_GLOBAL_GROUPS_SE | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE),
                                            (DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS),
                                            (DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS),
                                            GetDlgItem(hDlg, IDC_LIST1), sz) == S_OK )
                    {
                        EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                        {
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                            SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                        }
                    }

                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON3:
                {

                    if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups );
                        pQuery->pComputer->dwSecurityGroupCount = 0;
                        pQuery->pComputer->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pComputer->adwSecurityGroupsAttr );
                        pQuery->pComputer->adwSecurityGroupsAttr = NULL;
                    }

                    if ( pWizard->m_dwDefaultComputerSecurityGroupCount != 0 )
                    {
                        pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                                pWizard->m_dwDefaultComputerSecurityGroupCount,
                                                                                pWizard->m_aszDefaultComputerSecurityGroups,
                                                                                pWizard->m_adwDefaultComputerSecurityGroupsAttr );
                    }
                    else
                    {
                        pWizard->BuildMembershipList( GetDlgItem(hDlg, IDC_LIST1),
                                                                       pWizard->m_pComputerObject,
                                                                       &(pWizard->m_dwDefaultComputerSecurityGroupCount),
                                                                       &(pWizard->m_aszDefaultComputerSecurityGroups),
                                                                       &(pWizard->m_adwDefaultComputerSecurityGroupsAttr) );
                    }
                                                                            
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_LIST1:
                if (HIWORD(wParam) == LBN_SELCHANGE)
                {
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }
        break;

    case WM_REFRESHDISPLAY:
        if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
        {
            INT iIndex;

            iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

            if (iIndex != LB_ERR)
            {
                if ((SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETITEMDATA, (WPARAM) iIndex, 0) & 1) == 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        } else {
            EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

                if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                {
                    pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                            pQuery->pComputer->dwSecurityGroupCount,
                                                                            pQuery->pComputer->aszSecurityGroups,
                                                                            pQuery->pComputer->adwSecurityGroupsAttr );
                                                                            
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
                }
                else if ( pWizard->m_dwDefaultComputerSecurityGroupCount != 0 )
                {
                    pWizard->FillListFromSecurityGroups( GetDlgItem(hDlg, IDC_LIST1),
                                                                            pWizard->m_dwDefaultComputerSecurityGroupCount,
                                                                            pWizard->m_aszDefaultComputerSecurityGroups,
                                                                            pWizard->m_adwDefaultComputerSecurityGroupsAttr );
                                                                            
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                }
                else
                {
                    pWizard->BuildMembershipList( GetDlgItem(hDlg, IDC_LIST1),
                                                                   pWizard->m_pComputerObject,
                                                                   &(pWizard->m_dwDefaultComputerSecurityGroupCount),
                                                                   &(pWizard->m_aszDefaultComputerSecurityGroups),
                                                                   &(pWizard->m_adwDefaultComputerSecurityGroupsAttr) );
                                                                   
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
                }

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case PSN_WIZNEXT:
                {
                    // Free the previous list of security groups
                    if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups );
                        pQuery->pComputer->dwSecurityGroupCount = 0;
                        pQuery->pComputer->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pComputer->adwSecurityGroupsAttr );
                        pQuery->pComputer->adwSecurityGroupsAttr = NULL;
                    }

                    // Save the current list
                    pWizard->SaveSecurityGroups(  GetDlgItem(hDlg, IDC_LIST1),
                                                                    &(pQuery->pComputer->dwSecurityGroupCount),
                                                                    &(pQuery->pComputer->aszSecurityGroups),
                                                                    &(pQuery->pComputer->adwSecurityGroupsAttr) );


                    // Compare the current list with the default list.  If the default list
                    // matches the current list, then delete the current list and just use
                    // the defaults
                    if ( pWizard->CompareStringLists( pWizard->m_dwDefaultComputerSecurityGroupCount,
                                                                        pWizard->m_aszDefaultComputerSecurityGroups,
                                                                        pQuery->pComputer->dwSecurityGroupCount,
                                                                        pQuery->pComputer->aszSecurityGroups ) )
                    {
                        if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                        {
                            FreeStringList( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups );
                            pQuery->pComputer->dwSecurityGroupCount = 0;
                            pQuery->pComputer->aszSecurityGroups = NULL;
                            LocalFree( pQuery->pComputer->adwSecurityGroupsAttr );
                            pQuery->pComputer->adwSecurityGroupsAttr = NULL;
                        }
                    }

                    // Now check where to go
                    if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                    {
                        pWizard->m_dwSkippedFrom = IDD_RSOP_ALTCOMPSEC;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                        return TRUE;
                    }

                    if ( (NULL == pQuery->pUser->szName) && (NULL == pQuery->pUser->szSOM) && (RSOP_LOOPBACK_NONE == pQuery->LoopbackMode) )
                    {
                        pWizard->m_dwSkippedFrom = IDD_RSOP_ALTCOMPSEC;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLCOMP);
                        return TRUE;
                    }

                    pWizard->m_dwSkippedFrom = 0;
                }
                break;

            case PSN_WIZBACK:
                {
                    // Free the previous list of security groups
                    if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups );
                        pQuery->pComputer->dwSecurityGroupCount = 0;
                        pQuery->pComputer->aszSecurityGroups = NULL;
                        LocalFree( pQuery->pComputer->adwSecurityGroupsAttr );
                        pQuery->pComputer->adwSecurityGroupsAttr = NULL;
                    }

                    // Save the current list
                    pWizard->SaveSecurityGroups(  GetDlgItem(hDlg, IDC_LIST1),
                                                                    &(pQuery->pComputer->dwSecurityGroupCount),
                                                                    &(pQuery->pComputer->aszSecurityGroups),
                                                                    &(pQuery->pComputer->adwSecurityGroupsAttr) );


                    // Compare the current list with the default list.  If the default list
                    // matches the current list, then delete the current list and just use
                    // the defaults
                    if ( pWizard->CompareStringLists( pWizard->m_dwDefaultComputerSecurityGroupCount,
                                                                        pWizard->m_aszDefaultComputerSecurityGroups,
                                                                        pQuery->pComputer->dwSecurityGroupCount,
                                                                        pQuery->pComputer->aszSecurityGroups ) )
                    {
                        if ( pQuery->pComputer->dwSecurityGroupCount != 0 )
                        {
                            FreeStringList( pQuery->pComputer->dwSecurityGroupCount, pQuery->pComputer->aszSecurityGroups );
                            pQuery->pComputer->dwSecurityGroupCount = 0;
                            pQuery->pComputer->aszSecurityGroups = NULL;
                            LocalFree( pQuery->pComputer->adwSecurityGroupsAttr );
                            pQuery->pComputer->adwSecurityGroupsAttr = NULL;
                        }
                    }


                    if ( (pQuery->pUser->szName == NULL) && (pQuery->pUser->szSOM == NULL) )
                    {
                        if ( pQuery->pComputer->szName != NULL )
                        {
                            SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTDIRS);
                        }
                        else
                        {
                            SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETDC);
                        }
                        return TRUE;
                    }
                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPWQLUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
            SetFocus(GetDlgItem(hDlg, IDC_RADIO2));
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON1:
                {
                    if ( pQuery->pUser->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilters );
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilterNames );
                        pQuery->pUser->dwWQLFilterCount = 0;
                        pQuery->pUser->aszWQLFilters = NULL;
                        pQuery->pUser->aszWQLFilterNames = NULL;
                    }

                    pQuery->pUser->bAssumeWQLFiltersTrue = FALSE;

                    if ( pWizard->m_dwDefaultUserWQLFilterCount != 0 )
                    {
                        pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1),
                                                                        pWizard->m_dwDefaultUserWQLFilterCount,
                                                                        pWizard->m_aszDefaultUserWQLFilterNames,
                                                                        pWizard->m_aszDefaultUserWQLFilters );

                        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    }
                    else {
                        PostMessage (hDlg, WM_BUILDWQLLIST, 0, 0);
                    }
                }
                break;
            
            case IDC_RADIO2:
                {
                    if ( IsDlgButtonChecked( hDlg, IDC_RADIO2 ) )
                    {
                        if ( pQuery->pUser->dwWQLFilterCount != 0 )
                        {
                            FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilters );
                            FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilterNames );
                            pQuery->pUser->dwWQLFilterCount = 0;
                            pQuery->pUser->aszWQLFilters = NULL;
                            pQuery->pUser->aszWQLFilterNames = NULL;
                        }

                        pQuery->pUser->bAssumeWQLFiltersTrue = TRUE;
                    }
                        
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            
            case IDC_RADIO3:
                {
                    if ( IsDlgButtonChecked( hDlg, IDC_RADIO3 ) )
                    {
                        pQuery->pUser->bAssumeWQLFiltersTrue = FALSE;
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_BUILDWQLLIST:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            pWizard->BuildWQLFilterList (hDlg, TRUE, &(pWizard->m_dwDefaultUserWQLFilterCount),
                                                                          &(pWizard->m_aszDefaultUserWQLFilterNames),
                                                                          &(pWizard->m_aszDefaultUserWQLFilters) );
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_REFRESHDISPLAY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);
            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            if ( pQuery->pUser->bAssumeWQLFiltersTrue )
            {
                // set the listbox to null
                pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1), 0, NULL, NULL);
                CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
                CheckDlgButton (hDlg, IDC_RADIO3, BST_UNCHECKED);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_LIST1), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_HIDE);
            }
            else
            {
                CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
                CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                EnableWindow (GetDlgItem(hDlg, IDC_LIST1), TRUE);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_HIDE);
                if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);

                if ( !pQuery->pUser->bAssumeWQLFiltersTrue )
                {
                    pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1),
                                                                    pQuery->pUser->dwWQLFilterCount,
                                                                    pQuery->pUser->aszWQLFilterNames,
                                                                    pQuery->pUser->aszWQLFilters );
                }

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);

                break;

            case PSN_WIZNEXT:
                {
                    // Free the previous list of WQL Filters
                    if ( pQuery->pUser->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilters );
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilterNames );
                        pQuery->pUser->dwWQLFilterCount = 0;
                        pQuery->pUser->aszWQLFilters = NULL;
                        pQuery->pUser->aszWQLFilterNames = NULL;
                    }

                    // Save the current list
                    if ( !pQuery->pUser->bAssumeWQLFiltersTrue )
                    {
                        pWizard->SaveWQLFilters(GetDlgItem(hDlg, IDC_LIST1),   &(pQuery->pUser->dwWQLFilterCount),
                                                                                                               &(pQuery->pUser->aszWQLFilterNames),
                                                                                                               &(pQuery->pUser->aszWQLFilters) );
                    }


                    // Move to the next page
                    if (SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0))
                    {
                        pWizard->m_dwSkippedFrom = IDD_RSOP_WQLUSER;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                        return TRUE;
                    }

                    if ( (NULL == pQuery->pComputer->szName) && (NULL == pQuery->pComputer->szSOM) )
                    {
                        // skip to the finish page
                        pWizard->m_dwSkippedFrom = IDD_RSOP_WQLUSER;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                        return TRUE;
                    }

                    pWizard->m_dwSkippedFrom = 0;
                }
                break;

            case PSN_WIZBACK:
                {
                    // Free the previous list of WQL Filters
                    if ( pQuery->pUser->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilters );
                        FreeStringList( pQuery->pUser->dwWQLFilterCount, pQuery->pUser->aszWQLFilterNames );
                        pQuery->pUser->dwWQLFilterCount = 0;
                        pQuery->pUser->aszWQLFilters = NULL;
                        pQuery->pUser->aszWQLFilterNames = NULL;
                    }

                    // Save the current list
                    if ( !pQuery->pUser->bAssumeWQLFiltersTrue )
                    {
                        pWizard->SaveWQLFilters(GetDlgItem(hDlg, IDC_LIST1),   &(pQuery->pUser->dwWQLFilterCount),
                                                                                                               &(pQuery->pUser->aszWQLFilterNames),
                                                                                                               &(pQuery->pUser->aszWQLFilters) );
                    }

                    // Check which page to go back to
                    if ( (pQuery->pComputer->szName == NULL) && (pQuery->pComputer->szSOM == NULL) )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTUSERSEC);
                        return TRUE;
                    }
                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;

    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPWQLCompDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_PLANNING_MODE
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
            SetFocus(GetDlgItem(hDlg, IDC_RADIO2));
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            switch (LOWORD(wParam))
            {
            case IDC_BUTTON2:
                {
                    INT iIndex;

                    iIndex = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iIndex != LB_ERR)
                    {
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_DELETESTRING, (WPARAM) iIndex, 0);
                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_SETCURSEL, (WPARAM) iIndex, 0);
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;

            case IDC_BUTTON1:
                {

                    if ( pQuery->pComputer->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilters );
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilterNames );
                        pQuery->pComputer->dwWQLFilterCount = 0;
                        pQuery->pComputer->aszWQLFilters = NULL;
                        pQuery->pComputer->aszWQLFilterNames = NULL;
                    }

                    pQuery->pComputer->bAssumeWQLFiltersTrue = FALSE;

                    if ( pWizard->m_dwDefaultComputerWQLFilterCount != 0 )
                    {
                        pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1),
                                                                        pWizard->m_dwDefaultComputerWQLFilterCount,
                                                                        pWizard->m_aszDefaultComputerWQLFilterNames,
                                                                        pWizard->m_aszDefaultComputerWQLFilters );
                        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    }
                    else
                    {
                        PostMessage (hDlg, WM_BUILDWQLLIST, 0, 0);
                    }
                
                }
                break;

            case IDC_RADIO2:
                {
                    if ( IsDlgButtonChecked( hDlg, IDC_RADIO2 ) )
                    {
                        if ( pQuery->pComputer->dwWQLFilterCount != 0 )
                        {
                            FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilters );
                            FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilterNames );
                            pQuery->pComputer->dwWQLFilterCount = 0;
                            pQuery->pComputer->aszWQLFilters = NULL;
                            pQuery->pComputer->aszWQLFilterNames = NULL;
                        }

                        pQuery->pComputer->bAssumeWQLFiltersTrue = TRUE;
                    }
                        
                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            
            case IDC_RADIO3:
                {
                    if ( IsDlgButtonChecked( hDlg, IDC_RADIO3 ) )
                    {
                        pQuery->pComputer->bAssumeWQLFiltersTrue = FALSE;
                    }

                    PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                }
                break;
            }
        }

        break;

    case WM_BUILDWQLLIST:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            pWizard->BuildWQLFilterList (hDlg, FALSE, &(pWizard->m_dwDefaultComputerWQLFilterCount),
                                                                          &(pWizard->m_aszDefaultComputerWQLFilterNames),
                                                                          &(pWizard->m_aszDefaultComputerWQLFilters) );
            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
        }
        break;

    case WM_REFRESHDISPLAY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);
            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            
            if ( pQuery->pComputer->bAssumeWQLFiltersTrue )
            {
                // set the listbox to null
                CheckDlgButton (hDlg, IDC_RADIO2, BST_CHECKED);
                CheckDlgButton (hDlg, IDC_RADIO3, BST_UNCHECKED);
                pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1), 0, NULL, NULL);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
                EnableWindow (GetDlgItem(hDlg, IDC_LIST1), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_HIDE);
            }
            else
            {
                CheckDlgButton (hDlg, IDC_RADIO2, BST_UNCHECKED);
                CheckDlgButton (hDlg, IDC_RADIO3, BST_CHECKED);
                EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
                EnableWindow (GetDlgItem(hDlg, IDC_LIST1), TRUE);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST1), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_LIST2), SW_HIDE);
                if (SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCOUNT, 0, 0) > 0)
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
                }
                else
                {
                    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
                }
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK | PSWIZB_NEXT);
                if ( !pQuery->pComputer->bAssumeWQLFiltersTrue )
                {
                    pWizard->FillListFromWQLFilters(GetDlgItem(hDlg, IDC_LIST1),
                                                                    pQuery->pComputer->dwWQLFilterCount,
                                                                    pQuery->pComputer->aszWQLFilterNames,
                                                                    pQuery->pComputer->aszWQLFilters );
                }

                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                break;

            case PSN_WIZNEXT:
                {
                    // Free the previous list of WQL Filters
                    if ( pQuery->pComputer->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilters );
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilterNames );
                        pQuery->pComputer->dwWQLFilterCount = 0;
                        pQuery->pComputer->aszWQLFilters = NULL;
                        pQuery->pComputer->aszWQLFilterNames = NULL;
                    }

                    // Save the current list
                    if ( !pQuery->pComputer->bAssumeWQLFiltersTrue )
                    {
                        pWizard->SaveWQLFilters (GetDlgItem(hDlg, IDC_LIST1), &(pQuery->pComputer->dwWQLFilterCount),
                                                                                                              &(pQuery->pComputer->aszWQLFilterNames),
                                                                                                              &(pQuery->pComputer->aszWQLFilters) );
                    }

                    pWizard->m_dwSkippedFrom = 0;

                    // Skip to the last page in the wizard
                    SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_lPlanningFinishedPage);
                    return TRUE;
                }

            case PSN_WIZBACK:
                {
                    // Free the previous list of WQL Filters
                    if ( pQuery->pComputer->dwWQLFilterCount != 0 )
                    {
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilters );
                        FreeStringList( pQuery->pComputer->dwWQLFilterCount, pQuery->pComputer->aszWQLFilterNames );
                        pQuery->pComputer->dwWQLFilterCount = 0;
                        pQuery->pComputer->aszWQLFilters = NULL;
                        pQuery->pComputer->aszWQLFilterNames = NULL;
                    }

                    // Save the current list
                    if ( !pQuery->pComputer->bAssumeWQLFiltersTrue )
                    {
                        pWizard->SaveWQLFilters (GetDlgItem(hDlg, IDC_LIST1), &(pQuery->pComputer->dwWQLFilterCount),
                                                                                                              &(pQuery->pComputer->aszWQLFilterNames),
                                                                                                              &(pQuery->pComputer->aszWQLFilters) );
                    }

                    // Check which page to go back to
                    if ( (pQuery->pUser->szName == NULL) && (pQuery->pUser->szSOM == NULL) )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_ALTCOMPSEC);
                        return TRUE;
                    }
                }
                break;

            case PSN_WIZFINISH:
                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPFinishedDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// RSOP_LOGGING_MODE (IDD_RSOP_FINISHED)
// RSOP_PLANNING_MODE (IDD_RSOP_FINISHED3)
{

    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
            if (pWizard)
            {
                CRSOPWizard::InitializeResultsList (GetDlgItem (hDlg, IDC_LIST1));
            }
        }
        break;

    case WM_REFRESHDISPLAY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);
            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;
            if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
            {
                UINT n;

                n = (UINT) SendMessage(GetDlgItem(hDlg, IDC_EDIT1), WM_GETTEXTLENGTH, 0, 0);

                if (n > 0 )
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                else
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
        }
        break;

    case WM_COMMAND:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg*) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
            {
                switch (LOWORD(wParam))
                {

                case IDC_BUTTON1:
                    if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_RSOP_BROWSEDC), hDlg,
                                        BrowseDCDlgProc, (LPARAM) pWizard))
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, pQuery->szDomainController);
                    }
                    break;

                case IDC_EDIT1:
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
                    }

                    break;
                }
            }
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

            switch (((NMHDR FAR*)lParam)->code)
            {
            case PSN_WIZBACK:
                if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                {
                    if ( pWizard->m_dwSkippedFrom != 0 )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, pWizard->m_dwSkippedFrom);
                        return TRUE;
                    }
                    else if ( (pQuery->pComputer->szName == NULL) && (pQuery->pComputer->szSOM == NULL) )
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLUSER);
                        return TRUE;
                    }
                    else
                    {
                        SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_WQLCOMP);
                        return TRUE;
                    }
                }
                else // RSOP_LOGGING_MODE
                {
                    SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_GETUSER);
                    return TRUE;
                }
                break;

            case PSN_SETACTIVE:

                PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
                {
                    if ( pQuery->szDomainController != NULL )
                    {
                        if ( !pWizard->IsComputerRSoPEnabled(pQuery->szDomainController))
                        {
                            LocalFree( pQuery->szDomainController );
                            pQuery->szDomainController = NULL;
                        }
                    }

                    if ( pQuery->szDomainController != NULL )
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, pQuery->szDomainController);
                    }
                    else
                    {
                        SetDlgItemText (hDlg, IDC_EDIT1, TEXT(""));
                    }
                }

                CRSOPWizard::FillResultsList (GetDlgItem (hDlg, IDC_LIST1), pQuery, NULL );

                if ( pWizard->m_pExtendedProcessing != NULL )
                {
                    CheckDlgButton(hDlg, IDC_RADIO1, pWizard->m_pExtendedProcessing->GetExtendedErrorInfo() ? BST_CHECKED : BST_UNCHECKED );
                }

                break;

            case PSN_WIZNEXT:
            {
                pWizard->m_bFinalNextClicked = TRUE;
                if ( pQuery->QueryType == RSOP_PLANNING_MODE ) 
                {
                    SetWaitCursor();
                    GetControlText(hDlg, IDC_EDIT1, pQuery->szDomainController, TRUE );

                    if ( ! pQuery->szDomainController || !pWizard->IsComputerRSoPEnabled( pQuery->szDomainController ) )
                    {
                        ClearWaitCursor();
                        ReportError(hDlg, GetLastError(), IDS_DCMISSINGRSOP);
                        pWizard->m_bFinalNextClicked = FALSE;
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    ClearWaitCursor();
                }

                //PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_DISABLEDFINISH);
                PropSheet_SetWizButtons (GetParent(hDlg), 0);
                EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
                if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                {
                    EnableWindow( GetDlgItem(hDlg, IDC_BUTTON1), FALSE );
                    SendMessage( GetDlgItem(hDlg, IDC_EDIT1), EM_SETREADONLY, TRUE, 0 );
                }

                BOOL bGetExtendedInfo = FALSE;
                if ( pWizard->m_pExtendedProcessing != NULL )
                {
                    bGetExtendedInfo = (BOOL)SendMessage(GetDlgItem(hDlg, IDC_RADIO1), BM_GETCHECK, 0, 0);
                    EnableWindow( GetDlgItem(hDlg, IDC_RADIO1), FALSE );
                }
                if ( bGetExtendedInfo )
                {
                    pWizard->m_pRSOPQuery->dwFlags |= RSOP_90P_ONLY;
                }
                else
                {
                    pWizard->m_pRSOPQuery->dwFlags = pWizard->m_pRSOPQuery->dwFlags & (RSOP_90P_ONLY ^ 0xffffffff);
                }
                
                // RM: InitializeRSOP used to be called here, but now we go directly to GenerateRSOPEx
                {
                    pWizard->m_hrQuery = CRSOPWizard::GenerateRSOPDataEx(hDlg, pWizard->m_pRSOPQuery, &(pWizard->m_pRSOPQueryResults) );
                    if ( pWizard->m_hrQuery != S_OK )
                    {
                        PropSheet_SetWizButtons (GetParent(hDlg),PSWIZB_BACK);
                        pWizard->m_bFinalNextClicked = FALSE;
                        EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
                        if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                        {
                            EnableWindow( GetDlgItem(hDlg, IDC_BUTTON1), TRUE );
                            SendMessage( GetDlgItem(hDlg, IDC_EDIT1), EM_SETREADONLY, FALSE, 0 );
                        }
                        if ( pWizard->m_pExtendedProcessing != NULL )
                        {
                            EnableWindow( GetDlgItem(hDlg, IDC_RADIO1), TRUE );
                        }
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID);
                        return TRUE;
                    }
                }

                if ( pWizard->m_pExtendedProcessing != NULL )
                {
                    pWizard->m_pExtendedProcessing->DoProcessing( pWizard->m_pRSOPQuery,
                                                                  pWizard->m_pRSOPQueryResults,
                                                                  bGetExtendedInfo );
                    SendMessage( GetDlgItem(hDlg, IDC_PROGRESS1), PBM_SETRANGE32, 0, (LPARAM) 100);
                    SendMessage( GetDlgItem(hDlg, IDC_PROGRESS1), PBM_SETPOS, (WPARAM) 100, 0);
                    EnableWindow( GetDlgItem(hDlg, IDC_RADIO1), TRUE );
                }
                    
                // skip to the VERY last page in the wizard
                if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                {
                    EnableWindow( GetDlgItem(hDlg, IDC_BUTTON1), TRUE );
                    SendMessage( GetDlgItem(hDlg, IDC_EDIT1), EM_SETREADONLY, FALSE, 0 );
                }

                SetWindowLong(hDlg, DWLP_MSGRESULT, IDD_RSOP_FINISHED2);
                pWizard->m_bFinalNextClicked = FALSE;
                return TRUE;
            }

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;

            case PSN_QUERYCANCEL:
            {
                if (pWizard->m_bFinalNextClicked)
                {
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;                                        
                }

                return FALSE;
            }

            }
        }
        break;
    }

    return FALSE;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::RSOPFinished2DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// Both modes
{
    static BOOL iCancelQuery = FALSE;
    switch (message)
    {
    case WM_INITDIALOG:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) (((LPPROPSHEETPAGE)lParam)->lParam);
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);

            SendMessage(GetDlgItem(hDlg, IDC_RSOP_BIG_BOLD1),
                        WM_SETFONT, (WPARAM)pWizard->m_BigBoldFont, (LPARAM)TRUE);

    /*
            if (!pWizard->m_hChooseBitmap)
            {
                pWizard->m_hChooseBitmap = (HBITMAP) LoadImage (g_hInstance,
                                                            MAKEINTRESOURCE(IDB_WIZARD),
                                                            IMAGE_BITMAP, 0, 0,
                                                            LR_DEFAULTCOLOR);
            }

            if (pWizard->m_hChooseBitmap)
            {
                SendDlgItemMessage (hDlg, IDC_BITMAP, STM_SETIMAGE,
                                    IMAGE_BITMAP, (LPARAM) pWizard->m_hChooseBitmap);
            }
    */
        }
        break;

    case WM_NOTIFY:
        {
            CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pWizard)
            {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {

            case PSN_SETACTIVE:
                PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_FINISH);
                break;

            case PSN_WIZFINISH:

                // fall through

            case PSN_RESET:
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                return TRUE;

                // Ignore the 'X' button on the upper right corner
            case PSN_QUERYCANCEL:
            {
                SetWindowLongPtr (hDlg, DWLP_MSGRESULT, TRUE);
                return TRUE;
            }
            }
        }
        break;
    }
    
    return FALSE;
}


//-------------------------------------------------------

HRESULT CRSOPWizardDlg::SetupFonts()
{
    HRESULT hr;
    LOGFONT BigBoldLogFont;
    LOGFONT BoldLogFont;
    HDC pdc = NULL;
    WCHAR largeFontSizeString[128];
    INT     largeFontSize;
    WCHAR smallFontSizeString[128];
    INT     smallFontSize;

    //
    // Create the fonts we need based on the dialog font
    //
    NONCLIENTMETRICS ncm = {0};
    ncm.cbSize = sizeof (ncm);
    if (SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0) == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }


    BigBoldLogFont  = ncm.lfMessageFont;
    BoldLogFont     = ncm.lfMessageFont;

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;


    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if ( !LoadString (g_hInstance, IDS_LARGEFONTNAME, BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
        ASSERT (0);
        hr = StringCchCopy (BigBoldLogFont.lfFaceName, LF_FACESIZE, L"Verdana");
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    if ( LoadString (g_hInstance, IDS_LARGEFONTSIZE, largeFontSizeString, ARRAYSIZE(largeFontSizeString)) ) 
    {
        largeFontSize = wcstoul ((LPCWSTR) largeFontSizeString, NULL, 10);
    } 
    else 
    {
        ASSERT (0);
        largeFontSize = 12;
    }

    if ( !LoadString (g_hInstance, IDS_SMALLFONTNAME, BoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
        ASSERT (0);
        hr = StringCchCopy (BoldLogFont.lfFaceName, LF_FACESIZE, L"Verdana");
        if (FAILED(hr)) 
        {
            goto end;
        }
    }

    if ( LoadString (g_hInstance, IDS_SMALLFONTSIZE, smallFontSizeString, ARRAYSIZE(smallFontSizeString)) ) 
    {
        smallFontSize = wcstoul ((LPCWSTR) smallFontSizeString, NULL, 10);
    } 
    else 
    {
        ASSERT (0);
        smallFontSize = 8;
    }

    pdc = GetDC (NULL);

    if (pdc == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * largeFontSize / 72);
    BoldLogFont.lfHeight = 0 - (GetDeviceCaps (pdc, LOGPIXELSY) * smallFontSize / 72);

    m_BigBoldFont = CreateFontIndirect (&BigBoldLogFont);
    if (m_BigBoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }
    m_BoldFont = CreateFontIndirect (&BoldLogFont);
    if (m_BoldFont == NULL) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto end;
    }

    hr = S_OK;

end:
    if (pdc != NULL) {
        ReleaseDC (NULL, pdc);
        pdc = NULL;
    }

    return hr;
}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::FillUserList (HWND hList, BOOL* pbFoundCurrentUser, BOOL* pbFoundFixedUser)
{
    HRESULT hr, hrSuccess;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject * pOutInst = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrClassPath = NULL;
    BSTR bstrMethodName = NULL;
    VARIANT var;
    TCHAR szBuffer[MAX_PATH];
    IWbemLocator * pLocator = NULL;
    SAFEARRAY * psa;
    LONG lMax, lIndex;
    BSTR bstrSid;
    PSID pSid;
    TCHAR szName[125];
    TCHAR szDomain[125];
    TCHAR szFullName[MAX_PATH];
    DWORD dwNameSize, dwDomainSize;
    SID_NAME_USE NameUse;
    LPTSTR lpData, szUserSidPref = NULL;
    INT iRet;
    LVITEM item;
    LPTSTR lpCurrentUserSid = NULL;
    HANDLE hToken;
    LPTSTR lpSystemName = NULL;

    BOOL bFixUser = FALSE;
    *pbFoundFixedUser = FALSE;

    // This method only gets called from RSOPGetUserDlgProc, which means that it must be logging mode!
    if ( m_pRSOPQuery->QueryType != RSOP_LOGGING_MODE )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: Not called in planning mode.") ));
        return E_FAIL;
    }
    if ( m_pRSOPQuery->szComputerName == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: Called without computer name set.") ));
        return E_FAIL;
    }

    bFixUser = (m_pRSOPQuery->dwFlags & RSOP_FIX_USER) == RSOP_FIX_USER;
        
    // Get the "selected" user's Sid
    if ( (m_pRSOPQuery->szUserName != NULL) && bFixUser )
    {
        szUserSidPref = MyLookupAccountName(
                               (lstrcmpi( m_pRSOPQuery->szComputerName, TEXT(".")) == 0) ? NULL : NameWithoutDomain(m_pRSOPQuery->szComputerName),
                               m_pRSOPQuery->szUserName );

        if ( szUserSidPref == NULL )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: MyLookupAccountName failed with %d"), hr));
        }
    }

    if ( lstrcmpi(m_pRSOPQuery->szComputerName, TEXT(".")) )
    {
        lpSystemName = m_pRSOPQuery->szComputerName;
    }


    *pbFoundCurrentUser = FALSE;

    if (OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &hToken))
    {
        lpCurrentUserSid = GetSidString(hToken);

        CloseHandle (hToken);
    }


    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }

    // Set up diagnostic mode
    // Build a path to the target: "\\\\computer\\root\\rsop"
    hr = StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("\\\\%s\\root\\rsop"), NameWithoutDomain(m_pRSOPQuery->szComputerName));
    if (FAILED(hr)) 
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: Could not copy Name without domain with 0x%x"), hr));
        goto Cleanup;
    }

    bstrParam = SysAllocString(szBuffer);
    hr = pLocator->ConnectServer(bstrParam,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: ConnectServer to %s failed with 0x%x"), szBuffer, hr));
        goto Cleanup;
    }

    // Set the proper security to prevent the ExecMethod call from failing and to enable encryption
    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }

    bstrClassPath = SysAllocString(TEXT("RsopLoggingModeProvider"));
    bstrMethodName = SysAllocString(TEXT("RsopEnumerateUsers"));
    hr = pNamespace->ExecMethod(bstrClassPath,
                                bstrMethodName,
                                0,
                                NULL,
                                NULL,
                                &pOutInst,
                                NULL);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: ExecMethod failed with 0x%x"), hr));
        goto Cleanup;
    }

    hr = GetParameter(pOutInst, TEXT("hResult"), hrSuccess);
    if (SUCCEEDED(hr) && SUCCEEDED(hrSuccess))
    {

        VariantInit(&var);
        hr = pOutInst->Get(TEXT("userSids"), 0, &var, 0, 0);

        if (SUCCEEDED(hr))
        {
            if (var.vt & VT_ARRAY)
            {
                psa = var.parray;

                if (SUCCEEDED( SafeArrayGetUBound(psa, 1, &lMax)))
                {
                    for (lIndex = 0; lIndex <= lMax; lIndex++)
                    {
                        if (SUCCEEDED(SafeArrayGetElement (psa, &lIndex, &bstrSid)))
                        {
                            ULONG ulNoChars = lstrlen(bstrSid) + 1;
                            lpData = new WCHAR[ulNoChars];

                            if (lpData)
                            {
                                hr = StringCchCopy (lpData, ulNoChars, bstrSid);
                                ASSERT(SUCCEEDED(hr));


                                if (lpCurrentUserSid)
                                {
                                    if (!lstrcmpi(lpCurrentUserSid, lpData))
                                    {
                                        *pbFoundCurrentUser = TRUE;
                                    }
                                }

                                if (NT_SUCCESS(AllocateAndInitSidFromString (bstrSid, &pSid)))
                                {
                                    dwNameSize = ARRAYSIZE(szName);
                                    dwDomainSize = ARRAYSIZE(szDomain);
                                    if (LookupAccountSid (NameWithoutDomain(lpSystemName), pSid, szName, &dwNameSize,
                                                          szDomain, &dwDomainSize, &NameUse))
                                    {
                                        BOOL bAddUser;

                                        bAddUser = (!bFixUser || (lstrcmpi(szUserSidPref, lpData) == 0));
                                        
                                        if ( bFixUser && (lstrcmpi(szUserSidPref, lpData) == 0))
                                        {
                                            *pbFoundFixedUser = TRUE;
                                            m_pRSOPQuery->szUserSid = szUserSidPref;
                                        }

                                        if  (bAddUser)
                                        {
                                            hr = StringCchPrintf (szFullName, ARRAYSIZE(szFullName), TEXT("%s\\%s"), szDomain, szName);
                                            if (SUCCEEDED(hr)) 
                                            {
                                                ZeroMemory (&item, sizeof(item));
                                                item.mask = LVIF_TEXT | LVIF_PARAM;
                                                item.pszText = szFullName;
                                                item.lParam = (LPARAM) lpData;

                                                iRet = ListView_InsertItem(hList, &item);

                                                if (iRet == -1)
                                                {
                                                    delete [] lpData;
                                                }
                                                else if ( (szUserSidPref != NULL) && !lstrcmpi(szUserSidPref, lpData) )
                                                {
                                                    ListView_SetItemState( hList, iRet, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        delete [] lpData;
                                    }

                                    RtlFreeSid(pSid);
                                }
                                else
                                {
                                    delete [] lpData;
                                }
                            }
                        }
                    }
                }
            }
        }
        VariantClear(&var);

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendMessage (hList, LVM_SETITEMSTATE, 0, (LPARAM) &item);

    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: Either GetParameter or the return value failed.  hr = 0x%x, hrSuccess = 0x%x"), hr, hrSuccess));
    }

    if ( bFixUser && !(*pbFoundFixedUser) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::FillUserList: User not found on the machine")));
    }

Cleanup:
    SysFreeString(bstrParam);
    SysFreeString(bstrClassPath);
    SysFreeString(bstrMethodName);
    if (pOutInst)
    {
        pOutInst->Release();
    }
    if (pNamespace)
    {
        pNamespace->Release();
    }
    if (pLocator)
    {
        pLocator->Release();
    }

    if (lpCurrentUserSid)
    {
        DeleteSidString(lpCurrentUserSid);
    }

    if ( !(*pbFoundFixedUser))
    {
        LocalFree(szUserSidPref);
    }

    return hr;
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::EscapeString (LPTSTR *lpString)
{
    IADsPathname * pADsPathnameDest = NULL;
    IADsPathname * pADsPathnameSrc = NULL;
    HRESULT hr;
    BSTR bstr = NULL, bstrResult;
    LPTSTR lpTemp;
    LONG lIndex, lCount;



    //
    // Create a pathname object to put the source string into so we
    // can take it apart one element at a time.
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathnameSrc);


    if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pADsPathnameSrc->put_EscapedMode (ADS_ESCAPEDMODE_OFF_EX);

    if (FAILED(hr))
    {
        goto Exit;
    }

    //
    // Set the provider to LDAP and set the source string
    //

    BSTR bstrLDAP = SysAllocString(TEXT("LDAP"));
    if ( bstrLDAP == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathnameSrc->Set (bstrLDAP, ADS_SETTYPE_PROVIDER);
    SysFreeString( bstrLDAP );

    if (FAILED(hr))
    {
        goto Exit;
    }

    BSTR bstrTmpString = SysAllocString( *lpString );
    if ( bstrTmpString == NULL )
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathnameSrc->Set (bstrTmpString, ADS_SETTYPE_DN);
    SysFreeString( bstrTmpString );

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Query for the number of elements
    //

    hr = pADsPathnameSrc->GetNumElements (&lCount);
    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Create a pathname object to put the freshly escaped string into
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathnameDest);


    if (FAILED(hr))
    {
        goto Exit;
    }


    hr = pADsPathnameDest->put_EscapedMode(ADS_ESCAPEDMODE_ON );

    if (FAILED(hr))
    {
        goto Exit;
    }



    //
    // Loop through the string one element at at time escaping the RDN
    //

    for (lIndex = lCount; lIndex > 0; lIndex--)
    {

        //
        // Get this element
        //

        hr = pADsPathnameSrc->GetElement ((lIndex - 1), &bstr);

        if (FAILED(hr))
        {
            goto Exit;
        }


        //
        // Check for escape characters
        //

        hr = pADsPathnameDest->GetEscapedElement (0, bstr, &bstrResult);

        if (FAILED(hr))
        {
            goto Exit;
        }


        //
        // Add the new element to the destination pathname object
        //

        hr = pADsPathnameDest->AddLeafElement (bstrResult);

        SysFreeString (bstrResult);

        if (FAILED(hr))
        {
            goto Exit;
        }


        SysFreeString (bstr);
        bstr = NULL;
    }


    //
    // Get the final path
    //

    hr = pADsPathnameDest->Retrieve (ADS_FORMAT_X500_DN, &bstr);

    if (FAILED(hr))
    {
        goto Exit;
    }


    //
    // Allocate a new buffer to hold the string
    //

    ULONG ulNoChars = lstrlen(bstr) + 1;
    lpTemp = new TCHAR [ulNoChars];

    if (lpTemp)
    {
        hr = StringCchCopy (lpTemp, ulNoChars, bstr);
        ASSERT(SUCCEEDED(hr));

        delete [] *lpString;
        *lpString = lpTemp;
    }



Exit:

    if (bstr)
    {
        SysFreeString (bstr);
    }

    if (pADsPathnameDest)
    {
        pADsPathnameDest->Release();
    }

    if (pADsPathnameSrc)
    {
        pADsPathnameSrc->Release();
    }
}

//-------------------------------------------------------

INT CALLBACK CRSOPWizardDlg::DsBrowseCallback (HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{

    if (uMsg == DSBM_HELP)
    {
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (ULONG_PTR) (LPSTR) g_aBrowseForOUHelpIds);
    }
    else if (uMsg == DSBM_CONTEXTMENU)
    {
        WinHelp((HWND) lParam, HELP_FILE, HELP_CONTEXTMENU,
                (ULONG_PTR) (LPSTR) g_aBrowseForOUHelpIds);
    }

    return 0;
}

//-------------------------------------------------------

INT_PTR CALLBACK CRSOPWizardDlg::BrowseDCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
// Only called in RSOPFinishedDlgProc where QueryType == RSOP_PLANNING_MODE
{
    switch (message)
    {
        case WM_INITDIALOG:
            {
                CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) lParam;
                SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pWizard);
                pWizard->InitializeDCInfo(hDlg);
                return TRUE;
            }

        case WM_COMMAND:
            {
                CRSOPWizardDlg* pWizard = (CRSOPWizardDlg *) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!pWizard)
                {
                    break;
                }

                LPRSOP_QUERY pQuery = pWizard->m_pRSOPQuery;

                if (LOWORD(wParam) == IDOK)
                {
                    INT iSel, iStrLen;

                    iSel = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETCURSEL, 0, 0);

                    if (iSel == LB_ERR)
                    {
                        break;
                    }

                    iStrLen = (INT) SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETTEXTLEN, (WPARAM) iSel, 0);

                    if (iStrLen == LB_ERR)
                    {
                        break;
                    }

                    if ( pQuery->QueryType == RSOP_PLANNING_MODE )
                    {
                        LocalFree( pQuery->szDomainController );

                        pQuery->szDomainController = (TCHAR*)LocalAlloc( LPTR, (iStrLen+1) * sizeof(TCHAR) );

                        if ( pQuery->szDomainController == NULL )
                        {
                            break;
                        }

                        SendDlgItemMessage (hDlg, IDC_LIST1, LB_GETTEXT, (WPARAM) iSel, (LPARAM) pQuery->szDomainController );
                    }

                    EndDialog(hDlg, 1);
                    return TRUE;
                }

                if (LOWORD(wParam) == IDCANCEL)
                {
                    EndDialog(hDlg, 0);
                    return TRUE;
                }
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) g_aBrowseDCHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) g_aBrowseDCHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::InitializeSitesInfo (HWND hDlg)
// RSOP_PLANNING_MODE - only called from RSOPGetDCDlgProc
{
    LPTSTR szDomain = NULL;
    PDS_NAME_RESULTW pSites;
    int iInitialSite = 0;
    int iIndex, iDefault = CB_ERR;
    HANDLE hDs;
    DWORD dw, n;


    SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_RESETCONTENT, 0, 0);

    // Determine the focused domain.
    if ( m_pRSOPQuery->pComputer->szName != NULL )
    {
        // Try and get the computer's domain
        szDomain = ExtractDomain( m_pRSOPQuery->pComputer->szName );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pComputer->szSOM != NULL) )
    {
        // Try and get the computer's domain from the SOM
        szDomain = GetDomainFromSOM( m_pRSOPQuery->pComputer->szSOM );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pUser->szName != NULL) )
    {
        // Try and get the user's domain
        szDomain = ExtractDomain( m_pRSOPQuery->pUser->szName );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pUser->szSOM != NULL) )
    {
        // Try and get the user's domain from the SOM
        szDomain = GetDomainFromSOM( m_pRSOPQuery->pUser->szSOM );
    }

    if ( szDomain == NULL )
    {
        // Use the local domain
        LPTSTR szName;
        szName = MyGetUserName(NameSamCompatible);
        if ( szName != NULL )
        {
            szDomain = ExtractDomain(szName);
            LocalFree( szName );
        }
    }


    // Bind to the domain
    dw = DsBindW(NULL, szDomain, &hDs);

    if (dw == ERROR_SUCCESS)
    {
        // If we have a site pref, show only that..
        if ( (m_pRSOPQuery->dwFlags & RSOP_FIX_SITENAME) == RSOP_FIX_SITENAME )
        {
            LPWSTR szSiteFriendlyName=NULL;

            // Get the friendly name
            if ( GetSiteFriendlyName(m_pRSOPQuery->szSite, &szSiteFriendlyName) )
            {
                SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                            (WPARAM) 0, (LPARAM) (LPCTSTR) szSiteFriendlyName);
                delete [] szSiteFriendlyName;
            }
        }
        else
        {
            // Query for the list of sites
            dw = DsListSitesW(hDs, &pSites);

            if (dw == ERROR_SUCCESS)
            {
                for (n = 0; n < pSites->cItems; n++)
                {
                    // Add the site name (if it has a name)
                    if (pSites->rItems[n].pName)
                    {
                        LPWSTR szSiteFriendlyName=NULL;

                        if (GetSiteFriendlyName(pSites->rItems[n].pName, &szSiteFriendlyName))
                        {
                            SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                                        (WPARAM) 0, (LPARAM) (LPCTSTR) szSiteFriendlyName);

                            delete [] szSiteFriendlyName;
                        }
                    }
                }

                DsFreeNameResultW(pSites);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeSitesInfo: DsListSites failed with 0x%x"), dw));
            }

        }

        DsUnBindW(&hDs);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeSitesInfo: DsBindW failed with 0x%x"), dw));
    }


    if ( (m_pRSOPQuery->dwFlags & RSOP_FIX_SITENAME) == 0 )
    {
        TCHAR szString[1024];
        LoadString (g_hInstance, IDS_NONE, szString, ARRAYSIZE(szString));
    
        iIndex = (int) SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_ADDSTRING,
                                   (WPARAM) 0, (LPARAM) (LPCTSTR) szString);
    }

    // Set the initial selection
    if ( (m_pRSOPQuery->dwFlags & RSOP_FIX_SITENAME) == RSOP_FIX_SITENAME )
    {
        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_COMBO1), CB_FINDSTRINGEXACT,
                                (WPARAM) -1, (LPARAM) m_pRSOPQuery->szSite );
    }
    else if ( m_pRSOPQuery->szSite != NULL )
    {
        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_COMBO1), CB_FINDSTRINGEXACT,
                                (WPARAM) -1, (LPARAM) m_pRSOPQuery->szSite);
    }


    SendMessage(GetDlgItem(hDlg, IDC_COMBO1), CB_SETCURSEL,
                (WPARAM) (iDefault == CB_ERR) ? iIndex : iDefault, NULL);


    if ( szDomain != NULL )
    {
        delete [] szDomain;
    }
}

//-------------------------------------------------------

BOOL CRSOPWizardDlg::IsComputerRSoPEnabled(LPTSTR lpComputerName)
{
    LPSTR lpComputerNameA;
    LPTSTR lpName, lpWMIPath;
    HRESULT hr;
    BOOL bRetVal = FALSE;
    struct hostent *hostp;
    DWORD dwResult, dwSize = (lstrlen(lpComputerName) + 1) * 2;
    ULONG inaddr, ulSpeed;
    IWbemLocator * pLocator = 0;
    IWbemServices * pNamespace = 0;
    BSTR bstrPath;


    SetLastError(ERROR_SUCCESS);

    //
    // Allocate memory for a ANSI computer name
    //

    lpComputerNameA = new CHAR[dwSize];

    if (lpComputerNameA)
    {

        //
        // Skip the leading \\ if present
        //

        if ((*lpComputerName == TEXT('\\')) && (*(lpComputerName+1) == TEXT('\\')))
        {
            lpName = lpComputerName + 2;
        }
        else
        {
            lpName = lpComputerName;
        }


        //
        // Convert the computer name to ANSI
        //

        if (WideCharToMultiByte (CP_ACP, 0, lpName, -1, lpComputerNameA, dwSize, NULL, NULL))
        {

            //
            // Get the host information for the computer
            //

            hostp = gethostbyname(lpComputerNameA);

            if (hostp)
            {

                //
                // Get the ip address of the computer
                //

                inaddr = *(long *)hostp->h_addr;

                //
                // Create an instance of the WMI locator
                //

                hr = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
                                      IID_IWbemLocator, (LPVOID *) &pLocator);

                if (SUCCEEDED(hr))
                {

                    //
                    // Try to connect to the rsop namespace
                    //  

                    dwSize = lstrlen(lpName) + 20;

                    lpWMIPath = new TCHAR[dwSize];

                    if (lpWMIPath)
                    {
                        hr = StringCchPrintf (lpWMIPath, dwSize, TEXT("\\\\%s\\root\\rsop"), lpName);
                        if (SUCCEEDED(hr)) 
                        {
                            bstrPath = SysAllocString(lpWMIPath);

                            if (bstrPath)
                            {
                                hr = pLocator->ConnectServer(bstrPath,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             0,
                                                             NULL,
                                                             NULL,
                                                             &pNamespace);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Success.  This computer has RSOP support
                                    //

                                    pNamespace->Release();
                                    bRetVal = TRUE;
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: ConnectServer for %s failed with 0x%x"), bstrPath, hr));
                                }

                                SysFreeString (bstrPath);

                                //  
                                // Set hr into  the last error code.  Note, this has to happen after
                                // the call to SysFreeString since it changes the last error code
                                // to success
                                //

                                if (hr != S_OK)
                                {
                                    SetLastError(hr);
                                }
                            }
                            else
                            {
                                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: SysAllocString failed")));
                                SetLastError(ERROR_OUTOFMEMORY);
                            }
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: Could not copy WMI path")));
                            SetLastError(HRESULT_CODE(hr));
                        }

                        delete [] lpWMIPath;
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: Failed to alloc memory for wmi path.")));
                        SetLastError(ERROR_OUTOFMEMORY);
                    }

                    pLocator->Release();
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: CoCreateInstance failed with 0x%x."), hr));
                    SetLastError((DWORD)hr);
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: gethostbyname failed with %d."), WSAGetLastError()));
                SetLastError(WSAGetLastError());
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: WideCharToMultiByte failed with %d"), GetLastError()));
        }

        delete [] lpComputerNameA;
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::IsComputerRSoPEnabled: Failed to allocate memory for ansi dc name")));
        SetLastError(ERROR_OUTOFMEMORY);
    }

    return bRetVal;
}

//-------------------------------------------------------

BOOL CRSOPWizardDlg::TestAndValidateComputer(HWND hDlg)
// RSOP_LOGGING_MODE - only called in RSOPGetCompDlgProc
{
    LPTSTR lpMachineName = NULL;
    BOOL bOk = TRUE;
    HKEY hKeyRoot = 0, hKey = 0;
    DWORD dwType, dwSize, dwValue = 1;
    INT iRet;
    TCHAR szMessage[200];
    TCHAR szCaption[100];
    LONG lResult;
    HRESULT hr;
    ULONG ulNoChars;

    if ( (m_pRSOPQuery->szComputerName != NULL) && lstrcmpi(m_pRSOPQuery->szComputerName, TEXT(".")) )
    {
        ulNoChars = lstrlen(m_pRSOPQuery->szComputerName) + 3;
        lpMachineName = new TCHAR[ulNoChars];

        if ( lpMachineName == NULL )
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to allocate memory with %d"), GetLastError()));
            goto Exit;
        }

        hr = StringCchCopy (lpMachineName, ulNoChars, TEXT("\\\\"));
        if (SUCCEEDED(hr)) 
        {
            if ((lstrlen (m_pRSOPQuery->szComputerName) > 2) && (m_pRSOPQuery->szComputerName[0] == TEXT('\\')) &&
                (m_pRSOPQuery->szComputerName[1] == TEXT('\\')))
            {
                hr = StringCchCat (lpMachineName, ulNoChars, m_pRSOPQuery->szComputerName + 2);
            }
            else
            {
                hr = StringCchCat (lpMachineName, ulNoChars, NameWithoutDomain(m_pRSOPQuery->szComputerName) );
            }
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Could not copy machine name with 0x%x"), hr));
            goto Exit;            
        }

    }

    SetWaitCursor();

    //
    // If we are testing a remote machine, test if the machine is alive and has
    // the rsop namespace
    //

    if ( lpMachineName != NULL  )
    {
        if (!IsComputerRSoPEnabled (lpMachineName))
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: IsComputerRSoPEnabled failed on machine <%s>"), lpMachineName));

            if (GetLastError() == WBEM_E_INVALID_NAMESPACE)
            {
                ReportError (hDlg, 0, IDS_DOWNLEVELCOMPUTER, m_pRSOPQuery->szComputerName);
            }
            else
            {
                ReportError (hDlg, GetLastError(), IDS_CONNECTSERVERFAILED, m_pRSOPQuery->szComputerName);
            }
            bOk = FALSE;
            goto Exit;
        }
    }


    //
    // Check if the machine has rsop logging enabled or disabled
    //

    lResult = RegConnectRegistry (lpMachineName, HKEY_LOCAL_MACHINE, &hKeyRoot);

    ClearWaitCursor();

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to connect to %s with %d"),
                 lpMachineName, lResult));
        bOk = TRUE;
        dwValue = 1; // Ignore errors at this point and assume that rsop is enabled on the machine 
        goto Exit;
    }


    lResult = RegOpenKeyEx (hKeyRoot, TEXT("Software\\Policies\\Microsoft\\Windows\\System"),
                            0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof (dwValue);
        lResult = RegQueryValueEx (hKey, TEXT("RsopLogging"), NULL, &dwType, (LPBYTE) &dwValue,
                                   &dwSize);

        RegCloseKey (hKey);

        if (lResult == ERROR_SUCCESS)
        {
            RegCloseKey (hKeyRoot);
            goto Exit;
        }
    }


    lResult = RegOpenKeyEx (hKeyRoot, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                            0, KEY_READ, &hKey);

    if (lResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: Failed to open winlogon key with %d"),
                 lResult));
        RegCloseKey (hKeyRoot);
        goto Exit;
    }

    dwSize = sizeof (dwValue);
    RegQueryValueEx (hKey, TEXT("RsopLogging"), NULL, &dwType, (LPBYTE) &dwValue, &dwSize);

    RegCloseKey (hKey);
    RegCloseKey (hKeyRoot);


Exit:

    if (bOk && (dwValue == 0))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestAndValidateComputer: RSOP Logging is not enabled on %s"),
                 lpMachineName));


        LoadString(g_hInstance, IDS_RSOPLOGGINGDISABLED, szMessage, ARRAYSIZE(szMessage));
        LoadString(g_hInstance, IDS_RSOPLOGGINGTITLE, szCaption, ARRAYSIZE(szCaption));

        iRet = MessageBox (hDlg, szMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2);

        if (iRet == IDNO)
        {
            bOk = FALSE;
        }
    }


    if (lpMachineName)
    {
        delete [] lpMachineName;
    }

    return bOk;
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::InitializeDCInfo (HWND hDlg)
// RSOP_PLANNING_MODE - ...
{
    LPTSTR szDomain = NULL;
    DWORD dwError = ERROR_SUCCESS;
    INT iDefault = LB_ERR, nPDC = LB_ERR, nCount = 0;

    if ( m_pRSOPQuery->QueryType != RSOP_PLANNING_MODE )
    {
        return;
    }
    

    // Determine the focused domain so we can focus on the correct DC.
    // Determine the focused domain.
    if ( m_pRSOPQuery->pComputer->szName != NULL )
    {
        // Try and get the computer's domain
        szDomain = ExtractDomain( m_pRSOPQuery->pComputer->szName );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pComputer->szSOM != NULL) )
    {
        // Try and get the computer's domain from the SOM
        szDomain = GetDomainFromSOM( m_pRSOPQuery->pComputer->szSOM );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pUser->szName != NULL) )
    {
        // Try and get the user's domain
        szDomain = ExtractDomain( m_pRSOPQuery->pUser->szName );
    }

    if ( (szDomain == NULL) && (m_pRSOPQuery->pUser->szSOM != NULL) )
    {
        // Try and get the user's domain from the SOM
        szDomain = GetDomainFromSOM( m_pRSOPQuery->pUser->szSOM );
    }

    if ( szDomain == NULL )
    {
        // Use the local domain
        LPTSTR szName;
        szName = MyGetUserName(NameSamCompatible);
        if ( szName != NULL )
        {
            szDomain = ExtractDomain(szName);
            LocalFree( szName );
        }
    }

    if ( szDomain != NULL )
    {
        DWORD cInfo;
        INT n;
        PDS_DOMAIN_CONTROLLER_INFO_1 pInfo = NULL;
        HANDLE hDs;
        DWORD result;
        ULONG uDCCount = 0;

        result = DsBind(NULL, szDomain, &hDs);

        if (ERROR_SUCCESS == result)
        {
            result = DsGetDomainControllerInfo(hDs,
                                               szDomain,
                                               1,
                                               &cInfo,
                                               (void **)&pInfo);
            if (ERROR_SUCCESS == result)
            {
                // Enumerate the list
                for (n = 0; (DWORD)n < cInfo; n++)
                {
                    if (pInfo[n].DnsHostName != NULL) 
                    {
                        uDCCount ++;
                    }
                    else
                    {
                        continue;
                    }

                    if (IsComputerRSoPEnabled(pInfo[n].DnsHostName))
                    {
                        SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_ADDSTRING, 0, (LPARAM)pInfo[n].DnsHostName);

                        if (pInfo[n].fIsPdc)
                        {
                            nPDC = n;
                        }

                        nCount++;
                    }
                    else
                    {
                        dwError = GetLastError();
                    }
                }


                if (nCount)
                {
                    // Set the initial selection
                    if ( m_pRSOPQuery->szDomainController != NULL )
                    {
                        iDefault = (INT) SendMessage (GetDlgItem(hDlg, IDC_LIST1), LB_FINDSTRING,
                                                (WPARAM) -1, (LPARAM) m_pRSOPQuery->szDomainController);
                    }
                    else if (nPDC != LB_ERR)
                    {
                        iDefault = (INT) SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_FINDSTRINGEXACT,
                                        (WPARAM) -1, (LPARAM) pInfo[nPDC].DnsHostName);
                    }

                    SendMessage(GetDlgItem(hDlg, IDC_LIST1), LB_SETCURSEL,
                                (WPARAM) (iDefault == LB_ERR) ? 0 : iDefault, NULL);
                }
                else
                {
                    ReportError (hDlg, dwError, IDS_NORSOPDC, szDomain);
                }


                DsFreeDomainControllerInfo(1, cInfo, pInfo);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeDCInfo: DsGetDomainControllerInfo to %s failed with %d."), szDomain, result));
            }

            if (0 == uDCCount)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeDCInfo: DsGetDomainControllerInfo to %s returned DCs with no DNS host name"), szDomain));
            }

            DsUnBind(&hDs);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::InitializeDCInfo: DsBind to %s failed with %d."), szDomain, result));
            ReportError(hDlg, result, IDS_DSBINDFAILED);
        }

        delete [] szDomain;
    }

}

//-------------------------------------------------------

DWORD CRSOPWizardDlg::GetDefaultGroupCount()
{
    return 2;
}

VOID CRSOPWizardDlg::AddDefaultGroups (HWND hLB)
{
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY authWORLD = SECURITY_WORLD_SID_AUTHORITY;
    PSID  psidUser, psidEveryone;
    DWORD dwNameSize, dwDomainSize;
    TCHAR szName[200];
    TCHAR szDomain[65];
    SID_NAME_USE SidName;
    INT iIndex;


    //
    // Get the authenticated users sid
    //

    if (AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidUser))
    {
        //
        // Get the friendly display name and add it to the list
        //

        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid (NULL, psidUser, szName, &dwNameSize,
                              szDomain, &dwDomainSize, &SidName))
        {
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szName);
            SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
        }

        FreeSid(psidUser);
    }


    //
    // Get the everyone sid
    //

    if (AllocateAndInitializeSid(&authWORLD, 1, SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidEveryone))
    {
        //
        // Get the friendly display name and add it to the list
        //

        dwNameSize = ARRAYSIZE(szName);
        dwDomainSize = ARRAYSIZE(szDomain);

        if (LookupAccountSid (NULL, psidEveryone, szName, &dwNameSize,
                              szDomain, &dwDomainSize, &SidName))
        {
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szName);
            SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
        }

        FreeSid(psidEveryone);
    }

}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::BuildMembershipList (HWND hLB, IDirectoryObject * pDSObj, DWORD* pdwCount, LPTSTR** paszSecGrps, DWORD** padwSecGrpAttr)
{
    HRESULT hr;
    PADS_ATTR_INFO spAttrs;
    DWORD i, j, cAttrs = 0;
    WCHAR wzMembershipAttr[MAX_PATH] = L"memberOf;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"memberOf;range=%ld-*";
    BOOL fMoreRemain = FALSE;
    PWSTR rgpwzAttrNames[] = {wzMembershipAttr};
    TCHAR szDisplayName[MAX_PATH];
    ULONG ulSize;
    LPTSTR lpFullName, lpTemp;
    IADs * pGroup;
    VARIANT varType;
    BSTR bstrGroupType = NULL;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);


    AddDefaultGroups (hLB);
    if (!pDSObj)
        goto BuildMembershipListEnd;

    GetPrimaryGroup (hLB, pDSObj);

    bstrGroupType = SysAllocString( TEXT("groupType") );
    if ( bstrGroupType == NULL )
    {
        goto BuildMembershipListEnd;
    }
    
    //
    // Read the membership list from the object. First read the attribute off
    // of the actual object which will give all memberships in the object's
    // domain (including local groups which are not replicated to the GC).
    //
    do
    {
        hr = pDSObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

        if (SUCCEEDED(hr))
        {
            if (cAttrs > 0 && spAttrs != NULL)
            {
                for (i = 0; i < spAttrs->dwNumValues; i++)
                {
                    ulSize = (lstrlen(spAttrs->pADsValues[i].CaseIgnoreString) + 10);
                    lpFullName = (LPTSTR) LocalAlloc (LPTR,  ulSize * sizeof(TCHAR));

                    if (lpFullName)
                    {
                        hr = StringCchCopy (lpFullName, ulSize, TEXT("LDAP://"));
                        if (SUCCEEDED(hr)) 
                        {
                            hr = StringCchCat (lpFullName, ulSize, spAttrs->pADsValues[i].CaseIgnoreString);
                        }

                        if (SUCCEEDED(hr)) 
                        {
                            hr = OpenDSObject(lpFullName, IID_IADs, (void**)&pGroup);

                            if (SUCCEEDED(hr))
                            {
                                if (SUCCEEDED(pGroup->Get(bstrGroupType, &varType)))
                                {
                                    if ( varType.lVal & 0x80000000)
                                    {
                                        if ( varType.lVal & 0x5)
                                        {
                                            lpTemp = lpFullName;

                                            while (*lpTemp && (*lpTemp != TEXT(',')))
                                            {
                                                lpTemp++;
                                            }

                                            if (*lpTemp)
                                            {
                                                *lpTemp = TEXT('\0');
                                                SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) (lpFullName+10));
                                            }
                                        }
                                        else
                                        {
                                            if (TranslateName (spAttrs->pADsValues[i].CaseIgnoreString, NameFullyQualifiedDN,
                                                               NameSamCompatible, lpFullName, &ulSize))
                                            {
                                                SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) lpFullName);
                                            }
                                        }
                                    }

                                    VariantClear (&varType);
                                }

                                pGroup->Release();
                            }
                        }

                        LocalFree (lpFullName);
                    }
                }

                //
                // Check to see if there is more data. If the last char of the
                // attribute name string is an asterisk, then we have everything.
                //
                int cchEnd = wcslen(spAttrs->pszAttrName);

                fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

                if (fMoreRemain)
                {
                    PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
                    if (!pwz)
                    {
                        fMoreRemain = FALSE;
                    }
                    else
                    {
                        pwz++; // move past the hyphen to the range end value.
                        long lEnd = _wtol(pwz);
                        lEnd++; // start with the next value.
                        hr = StringCchPrintf (wzMembershipAttr, ARRAYSIZE(wzMembershipAttr), wzFormat, lEnd);
                        if (SUCCEEDED(hr)) 
                        {
                            DebugMsg((DM_VERBOSE, TEXT("Range returned is %s, now asking for %s"),
                                      spAttrs->pszAttrName, wzMembershipAttr));
                        }

                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("Could not copy membership attributes with 0x%x"),hr));
                            break;
                        }
                    }
                }
            }

            FreeADsMem (spAttrs);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildMembershipList: GetObjectAttributes failed with 0x%s"), hr));
        }

    } while (fMoreRemain);

BuildMembershipListEnd:
    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);

    SaveSecurityGroups (hLB, pdwCount, paszSecGrps, padwSecGrpAttr);

    if ( bstrGroupType != NULL )
    {
        SysFreeString( bstrGroupType );
    }

    ClearWaitCursor();

    return S_OK;
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::GetPrimaryGroup (HWND hLB, IDirectoryObject * pDSObj)
{
    HRESULT hr;
    PADS_ATTR_INFO spAttrs;
    WCHAR wzObjectSID[] = L"objectSid";
    WCHAR wzPrimaryGroup[] = L"primaryGroupID";
    PWSTR rgpwzAttrNames[] = {wzObjectSID, wzPrimaryGroup};
    DWORD cAttrs = 2, i;
    DWORD dwOriginalPriGroup = 0;
    LPBYTE pObjSID = NULL;
    UCHAR * psaCount, iIndex;
    PSID pSID = NULL;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD rgRid[8];
    TCHAR szName[200];
    TCHAR szDomain[300];
    TCHAR *szFullName;
    DWORD dwNameSize, dwDomainSize;
    SID_NAME_USE SidName;


    //
    // Get the SID and perhaps the Primary Group attribute values.
    //

    hr = pDSObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetObjectAttributes failed with 0x%x"), hr));
        return;
    }

    for (i = 0; i < cAttrs; i++)
    {
        if (_wcsicmp(spAttrs[i].pszAttrName, wzPrimaryGroup) == 0)
        {
            dwOriginalPriGroup = spAttrs[i].pADsValues->Integer;
            continue;
        }

        if (_wcsicmp(spAttrs[i].pszAttrName, wzObjectSID) == 0)
        {
            pObjSID = new BYTE[spAttrs[i].pADsValues->OctetString.dwLength];

            if (!pObjSID)
            {
                DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: Failed to allocate memory for sid with %d"), GetLastError()));
                goto Exit;
            }

            memcpy(pObjSID, spAttrs[i].pADsValues->OctetString.lpValue,
                   spAttrs[i].pADsValues->OctetString.dwLength);
        }
    }

    if (!IsValidSid (pObjSID))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: SID is not valid.")));
        goto Exit;
    }


    psaCount = GetSidSubAuthorityCount(pObjSID);

    if (psaCount == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidSubAuthorityCount failed with %d"), GetLastError()));
        goto Exit;
    }

    if (*psaCount > 8)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: psaCount is greater than 8")));
        goto Exit;
    }

    for (iIndex = 0; iIndex < (*psaCount - 1); iIndex++)
    {
        PDWORD pRid = GetSidSubAuthority(pObjSID, (DWORD)iIndex);
        if (pRid == NULL)
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidSubAuthority failed with %d"), GetLastError()));
            goto Exit;
        }
        rgRid[iIndex] = *pRid;
    }

    rgRid[*psaCount - 1] = dwOriginalPriGroup;

    for (iIndex = *psaCount; iIndex < 8; iIndex++)
    {
        rgRid[iIndex] = 0;
    }

    psia = GetSidIdentifierAuthority(pObjSID);

    if (psia == NULL)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: GetSidIdentifierAuthorityCount failed with %d"), GetLastError()));
        goto Exit;
    }

    if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                  rgRid[2], rgRid[3], rgRid[4],
                                  rgRid[5], rgRid[6], rgRid[7], &pSID))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: AllocateAndInitializeSid failed with %d"), GetLastError()));
        goto Exit;
    }


    dwNameSize = ARRAYSIZE(szName);
    dwDomainSize = ARRAYSIZE(szDomain);
    if (LookupAccountSid (NULL, pSID, szName, &dwNameSize, szDomain, &dwDomainSize,
                          &SidName))
    {
        ULONG ulNoChars = lstrlen(szDomain) + lstrlen(szName) + 1 + 1;
        szFullName = (WCHAR *) LocalAlloc(LPTR, ulNoChars * sizeof(WCHAR));
        if (szFullName != NULL) 
        {
            hr = StringCchPrintf (szFullName, ulNoChars, TEXT("%s\\%s"), szDomain, szName);
            ASSERT(SUCCEEDED(hr));
            SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szFullName);
            LocalFree(szFullName);
        }

    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::GetPrimaryGroup: LookupAccountSid failed with %d"), GetLastError()));
    }

    FreeSid (pSID);

Exit:
    FreeADsMem (spAttrs);

    if (pObjSID)
    {
        delete [] pObjSID;
    }

}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::SaveSecurityGroups (HWND hLB, DWORD* pdwCount, LPTSTR** paszSecGrps, DWORD** padwSecGrpAttr)
{
    LONG i, lCount = 0;
    DWORD dwLen;
    LPTSTR lpText;
    BSTR bstrText;
    HRESULT hr;

    
    if ( (*paszSecGrps != NULL) || (*padwSecGrpAttr != NULL) )
    {
        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::SaveSecurityGroups: Arrays passed in are not NULL!")) );
        return E_FAIL;
    }


    // Get number of items from list box
    lCount = (LONG) SendMessage (hLB, LB_GETCOUNT, 0, 0);
    if ( lCount == 0 )
    {
        *pdwCount = 0;
        return S_OK;
    }

    *paszSecGrps = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * lCount );
    if ( *paszSecGrps == NULL )
    {
        return E_OUTOFMEMORY;
    }
    
    *padwSecGrpAttr = (DWORD*)LocalAlloc( LPTR, sizeof(DWORD) * lCount );
    if ( *padwSecGrpAttr == NULL )
    {
        LocalFree( *paszSecGrps );
        *paszSecGrps = NULL;
        return E_OUTOFMEMORY;
    }

    *pdwCount = lCount;
    for ( i = 0; i < lCount; i++ )
    {
        dwLen = (DWORD) SendMessage (hLB, LB_GETTEXTLEN, (WPARAM) i, 0);

        if (dwLen != LB_ERR)
        {
            lpText = (LPTSTR)LocalAlloc( LPTR, (dwLen+2) * sizeof(TCHAR) );

            // RM: Should actually do something here if memory allocation fails!
            if ( lpText != NULL )
            {
                if (SendMessage (hLB, LB_GETTEXT, (WPARAM) i, (LPARAM) lpText) != LB_ERR)
                {
                    LONG lFlags;
                    BOOL bDollarRemoved;
                    lFlags = (LONG) SendMessage (hLB, LB_GETITEMDATA, (WPARAM) i, 0);

                    bDollarRemoved = (lFlags & 2);

                    if (bDollarRemoved)
                    {
                        lpText[wcslen(lpText)] = L'$';
                    }

                    if (lFlags & 1)
                    { // default grps
                        (*padwSecGrpAttr)[i] = 1;
                    }

                    (*paszSecGrps)[i] = lpText;
                }
            }
        }
    }

    return S_OK;
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::FillListFromSecurityGroups(HWND hLB, DWORD dwCount, LPTSTR* aszSecurityGroups, DWORD* adwSecGrpAttr)
{
    DWORD dwIndex;
    LPTSTR lpText;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if ( (dwCount != 0) && (aszSecurityGroups != NULL) )
    {
        for ( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {
            BOOL bDollarRemoved = FALSE;
            lpText = aszSecurityGroups[dwIndex];

            if (lpText[wcslen(lpText)-1] == L'$')
            {
                bDollarRemoved = TRUE;
                lpText[wcslen(lpText)-1] = 0;
            }

            INT iIndex;
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) lpText);
            if ( (adwSecGrpAttr != NULL) && (adwSecGrpAttr[dwIndex] & 1) )
            {
                SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) 1);
            }
            else
            {
                SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) (bDollarRemoved) ? 2 : 0);
            }

            // we just modified it, set it back
            if (bDollarRemoved)
            {
                lpText[wcslen(lpText)] = L'$';
            }
        }
    }

    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);
    ClearWaitCursor();
}

//-------------------------------------------------------

VOID CRSOPWizardDlg::FillListFromWQLFilters( HWND hLB, DWORD dwCount, LPTSTR* aszNames, LPTSTR* aszFilters )
{
    INT iIndex;
    DWORD dwIndex;

    SetWaitCursor();
    SendMessage (hLB, WM_SETREDRAW, FALSE, 0);
    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if ( dwCount != 0 )
    {
        for ( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {
            iIndex = (INT) SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) aszNames[dwIndex] );
            DebugMsg((DM_VERBOSE, TEXT("CRSOPComponentData::FillListFromSafeArrays: Added WQL filter %s"), aszNames[dwIndex]));

            if (iIndex != LB_ERR)
            {
                SendMessage (hLB, LB_SETITEMDATA, (WPARAM) iIndex, (LPARAM) aszFilters[dwIndex] );
            }
        }
    }

    SendMessage (hLB, LB_SETCURSEL, 0, 0);
    SendMessage (hLB, WM_SETREDRAW, TRUE, 0);
    UpdateWindow (hLB);
    ClearWaitCursor();
}


VOID CRSOPWizardDlg::BuildWQLFilterList (HWND hDlg, BOOL bUser, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR** paszFilters )
{
    HRESULT hr;
    LPTSTR szNameSpace = NULL;
    LPTSTR lpFullNameSpace, lpEnd;
    TCHAR szBuffer[150];
    HWND hLB = GetDlgItem (hDlg, IDC_LIST1);
    ULONG ulErrorInfo;

    //
    // Prepare to generate the rsop data.  Give the user a message in the listbox
    // and disable the controls on the page
    //

    SetWaitCursor();

    SendMessage (hLB, LB_RESETCONTENT, 0, 0);
    LoadString(g_hInstance, IDS_PLEASEWAIT, szBuffer, ARRAYSIZE(szBuffer));
    SendMessage (hLB, LB_ADDSTRING, 0, (LPARAM) szBuffer);

    PropSheet_SetWizButtons (GetParent(hDlg), 0);
    EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), FALSE);
    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), FALSE);


    //
    // Generate the rsop data using the info we have already
    //

    hr = CRSOPWizard::GenerateRSOPData(NULL, m_pRSOPQuery, &szNameSpace, TRUE, TRUE, bUser, FALSE, &ulErrorInfo);

    SendMessage (hLB, LB_RESETCONTENT, 0, 0);

    if (FAILED (hr))
    {
        ReportError (hDlg, hr, IDS_EXECFAILED);
        goto Exit;
    }


    ULONG ulNoChars;

    ulNoChars = lstrlen(szNameSpace) + 20;
    lpFullNameSpace = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (lpFullNameSpace)
    {
        hr = StringCchCopy (lpFullNameSpace, ulNoChars, szNameSpace);
        if (SUCCEEDED(hr)) 
        {
            lpEnd = CheckSlash(lpFullNameSpace);

            if (bUser)
            {
                hr = StringCchCopy (lpEnd, ulNoChars - lstrlen(lpFullNameSpace), TEXT("User"));
            }
            else
            {
                hr = StringCchCopy (lpEnd, ulNoChars - lstrlen(lpFullNameSpace), TEXT("Computer"));
            }
        }

        if (SUCCEEDED(hr)) 
        {
            if (SUCCEEDED(ExtractWQLFilters (lpFullNameSpace, pdwCount, paszNames, paszFilters) ))
            {
                FillListFromWQLFilters( hLB, *pdwCount, *paszNames, *paszFilters );
            }
        }

        LocalFree (lpFullNameSpace);
    }

    CRSOPWizard:: DeleteRSOPData( szNameSpace, m_pRSOPQuery );
    LocalFree( szNameSpace );

Exit:

    PropSheet_SetWizButtons (GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
    EnableWindow (GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON1), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON2), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_BUTTON3), TRUE);
    EnableWindow (GetDlgItem(hDlg, IDC_RADIO1), TRUE);


    ClearWaitCursor();
}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::SaveWQLFilters (HWND hLB, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR**paszFilters )
{
    LONG i, lLength, lCount = 0;
    LPTSTR lpText, lpName;
    BSTR bstrText;
    HRESULT hr;

    if ( (*paszNames != NULL) || (*paszFilters != NULL) )
    {
        DebugMsg( (DM_WARNING, TEXT("CRSOPComponentData::SaveWQLFilters: Arrays passed in are not NULL!")) );
        return E_FAIL;
    }

    // Getting the number of items
    lCount = (LONG) SendMessage (hLB, LB_GETCOUNT, 0, 0);
    if ( lCount == 0 )
    {
        *pdwCount = 0;
        return S_OK;
    }

    *paszNames = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * lCount );
    if ( *paszNames == NULL )
    {
        return E_OUTOFMEMORY;
    }
    
    *paszFilters = (LPTSTR*)LocalAlloc( LPTR, sizeof(LPTSTR) * lCount );
    if ( *paszFilters == NULL )
    {
        LocalFree( *paszNames );
        *paszNames = NULL;
        return E_OUTOFMEMORY;
    }

    *pdwCount = lCount;
    for ( i = 0; i < lCount; i++ )
    {
        lLength = (LONG) SendMessage (hLB, LB_GETTEXTLEN, (WPARAM) i, 0);

        lpName = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR) * (lLength + 1) );

        if ( lpName != NULL )
        {
            if (SendMessage (hLB, LB_GETTEXT, (WPARAM) i, (LPARAM) lpName) != LB_ERR)
            {
                (*paszNames)[i] = lpName;

                lpText = (LPTSTR) SendMessage (hLB, LB_GETITEMDATA, (WPARAM) i, 0);

                if (lpText)
                {
                    ULONG ulNoChars = wcslen(lpText) + 1;

                    (*paszFilters)[i] = (LPTSTR)LocalAlloc( LPTR, sizeof(TCHAR) * ulNoChars );
                    if ( (*paszFilters)[i] != NULL )
                    {
                        hr = StringCchCopy( (*paszFilters)[i], ulNoChars, lpText );
                        ASSERT(SUCCEEDED(hr));
                    }
                }
            }
            else
            {
                LocalFree( lpName );
            }
        }
    }

    return S_OK;
}

//-------------------------------------------------------

BOOL CRSOPWizardDlg::CompareStringLists( DWORD dwCountA, LPTSTR* aszListA, DWORD dwCountB, LPTSTR* aszListB )
{
    BOOL bFound;
    DWORD dwA, dwB;

    //
    // Parameter checks
    //
    if ( dwCountA != dwCountB )
    {
        return FALSE;
    }
    if ( (dwCountA == 0) && (dwCountB == 0) )
    {
        return TRUE;
    }

    if ( dwCountA == 0 )
    {
        return FALSE;
    }
    if ( dwCountB == 0 )
    {
        return FALSE;
    }

    if ( (aszListA == NULL) || (aszListB == NULL) )
    {
        return FALSE;
    }

    //
    // Loop through comparing item by item
    //
    for ( dwA = 0; dwA < dwCountA; dwA++ )
    {
        bFound = FALSE;

        for ( dwB = 0; dwB < dwCountB; dwB++ )
        {
            if ( !lstrcmpi( aszListA[dwA], aszListB[dwB] ) )
            {
                bFound = TRUE;
            }
        }

        if (!bFound)
        {
            return FALSE;
        }
    }

    return TRUE;
}

//-------------------------------------------------------

LPTSTR CRSOPWizardDlg::GetDefaultSOM (LPTSTR lpDNName)
{
    HRESULT hr;
    LPTSTR lpPath = NULL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrContainer = NULL;


    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the DN name
    //

    BSTR bstrDNName = SysAllocString( lpDNName );
    if ( bstrDNName == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set (bstrDNName, ADS_SETTYPE_DN);
    SysFreeString( bstrDNName );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }


    //
    // Remove the user / computer name
    //

    hr = pADsPathname->RemoveLeafElement ();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to retreive GPO name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get the new path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500_DN, &bstrContainer);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::New: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a new buffer for the path
    //

    ULONG ulNoChars = lstrlen(bstrContainer)+ 1;
    lpPath = new TCHAR [ulNoChars];

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::BuildAltDirPath: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }


    //
    // Build the path
    //

    hr = StringCchCopy (lpPath, ulNoChars, bstrContainer);
    ASSERT(SUCCEEDED(hr));

Exit:

    if (bstrContainer)
    {
        SysFreeString (bstrContainer);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    return lpPath;
}

//-------------------------------------------------------

HRESULT CRSOPWizardDlg::TestSOM (LPTSTR lpSOM, HWND hDlg)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPTSTR lpFullName;
    IDirectoryObject * pObject;
    ADS_OBJECT_INFO *pInfo;


    if (!lpSOM)
    {
        return E_INVALIDARG;
    }

    ULONG ulNoChars = lstrlen(lpSOM) + 10;

    lpFullName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (lpFullName)
    {
        hr = StringCchCopy (lpFullName, ulNoChars, TEXT("LDAP://"));
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat (lpFullName, ulNoChars, lpSOM);
        }

        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestSOM: Could not copy SOM name with 0x%x"), hr));
            LocalFree(lpFullName);
            return hr;
        }

        hr = OpenDSObject(lpFullName, IID_IDirectoryObject, (void**)&pObject);

        if (SUCCEEDED(hr))
        {
            hr = pObject->GetObjectInformation (&pInfo);

            if (SUCCEEDED(hr))
            {
                if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE, pInfo->pszClassName, -1, TEXT("user"), -1) == CSTR_EQUAL)
                {
                    hr = E_INVALIDARG;
                    ReportError (hDlg, hr, IDS_BADUSERSOM);
                }
                else if (CompareString (LOCALE_INVARIANT, NORM_IGNORECASE, pInfo->pszClassName, -1, TEXT("computer"), -1) == CSTR_EQUAL)
                {
                    hr = E_INVALIDARG;
                    ReportError (hDlg, hr, IDS_BADCOMPUTERSOM);
                }

                FreeADsMem (pInfo);
            }

            pObject->Release();
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::TestSOM: OpenDSObject to %s failed with 0x%x"), lpFullName, hr));
        }

        LocalFree (lpFullName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\rsoputil.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsoputil.h
//
//  Contents:   helper functions for working with the RSOP database
//
//  History:    10-18-1999   stevebl   Created
//
//---------------------------------------------------------------------------


//+--------------------------------------------------------------------------
//
//  Function:   SetParameter
//
//  Synopsis:   sets a paramter's value in a WMI parameter list
//
//  Arguments:  [pInst]   - instance on which to set the value
//              [szParam] - the name of the parameter
//              [xData]   - the data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There may be several flavors of this procedure, one for
//              each data type.
//
//---------------------------------------------------------------------------

HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * szData);
HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, SAFEARRAY * psa);
HRESULT SetParameter(IWbemClassObject * pInst, TCHAR * szParam, UINT uiData);
HRESULT SetParameterToNull(IWbemClassObject * pInst, TCHAR * szParam);

//+--------------------------------------------------------------------------
//
//  Function:   GetParameter
//
//  Synopsis:   retrieves a parameter value from a WMI paramter list
//
//  Arguments:  [pInst]   - instance to get the paramter value from
//              [szParam] - the name of the paramter
//              [xData]   - [out] data
//
//  History:    10-08-1999   stevebl   Created
//
//  Notes:      There are several flavors of this procedure, one for each
//              data type.
//              (Note that BSTR is a special case since the compiler can't
//              distinguish it from a TCHAR * but it's semantics are
//              different.)
//
//---------------------------------------------------------------------------

HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, TCHAR * &szData, BOOL bUseLocalAlloc = FALSE );
HRESULT GetParameterBSTR(IWbemClassObject * pInst, TCHAR * szParam, BSTR &bstrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, BOOL &fData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, HRESULT &hrData);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, ULONG &ulData);
HRESULT GetParameterBytes(IWbemClassObject * pInst, TCHAR * szParam, LPBYTE * lpData, DWORD *dwDataSize);
HRESULT GetParameter(IWbemClassObject * pInst, TCHAR * szParam, LPWSTR *&szStringArray, DWORD &dwSize);


HRESULT WbemTimeToSystemTime(XBStr& xbstrWbemTime, SYSTEMTIME& sysTime);

HRESULT ExtractWQLFilters (LPTSTR lpNameSpace, DWORD* pdwCount, LPTSTR** paszNames, LPTSTR** paszFilters, BOOL bReturnIfTrueOnly=FALSE );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\snapin.cpp ===
#include "main.h"


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation                                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CSnapIn::CSnapIn(CComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumnSize = 180;
    m_lViewMode = LVS_REPORT;
    m_bExpand = TRUE;

    LoadString(g_hInstance, IDS_NAME, m_column1, ARRAYSIZE(m_column1));
}

CSnapIn::~CSnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IUnknown)                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CSnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CSnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CSnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IComponent)                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT hr;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));

    return S_OK;
}

STDMETHODIMP CSnapIn::Destroy(MMC_COOKIE cookie)
{

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;


    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;

        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPGPEDATAOBJECT pGPEDataObject;
            MMC_COOKIE cookie;
            INT i;
            LPCONSOLE2 lpConsole2;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;


            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_column1, LVCFMT_LEFT, m_nColumnSize);
            m_pResult->SetViewMode(m_lViewMode);


            //
            // Add result pane items for this node
            //

            for (i = 0; i < g_NameSpace[cookie].cResultItems; i++)
            {
                resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                resultItem.str = MMC_CALLBACK;
                resultItem.nImage = g_NameSpace[cookie].pResultItems[i].iImage;
                resultItem.lParam = (LPARAM) &g_NameSpace[cookie].pResultItems[i];
                m_pResult->InsertItem(&resultItem);
            }

            m_pResult->Sort(0, 0, -1);

            if (m_bExpand)
            {
                hr = m_pConsole->QueryInterface(IID_IConsole2,
                                reinterpret_cast<void**>(&lpConsole2));

                if (SUCCEEDED(hr))
                {
                    if (m_pcd->m_hRoot)
                    {
                        lpConsole2->Expand(m_pcd->m_hRoot, TRUE);
                    }

                    if (m_pcd->m_hMachine)
                    {
                        lpConsole2->Expand(m_pcd->m_hMachine, TRUE);
                    }

                    if (m_pcd->m_hUser)
                    {
                        lpConsole2->Expand(m_pcd->m_hUser, TRUE);
                    }

                    lpConsole2->Release();
                }

                m_bExpand = FALSE;
            }
        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumnSize);
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;

    case MMCN_SELECT:

        if (m_pConsoleVerb)
        {
            LPRESULTITEM pItem;
            LPGPEDATAOBJECT pGPEDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                break;

            pGPEDataObject->GetType(&type);
            pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (m_pcd->m_pGPO)
            {
                if ((type == CCT_RESULT) || ((type == CCT_SCOPE) && (cookie == 0)))
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);


                    //
                    // If this is a result pane item, then change the default
                    // verb to Properties.
                    //

                    if (type == CCT_RESULT)
                        m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                }
            }
        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPOLESTR pszHelpTopic;
            LPGPEDATAOBJECT pGPEDataObject;
            MMC_COOKIE cookie;


            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IGPEDataObject, (LPVOID *)&pGPEDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pGPEDataObject->GetCookie(&cookie);

            pGPEDataObject->Release();     // release initial ref

            if (FAILED(hr))
                return S_OK;

            ULONG ulNoChars = 50;
            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (ulNoChars * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                hr = StringCchCopy (pszHelpTopic, ulNoChars, g_NameSpace[cookie].lpHelpTopic);
                if (SUCCEEDED(hr)) 
                {
                    m_pDisplayHelp->ShowTopic (pszHelpTopic);
                }
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CSnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    pResult->str = g_NameSpace[pResult->lParam].szDisplayName;
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (m_pcd->m_pGPO)
                    pResult->nImage = g_NameSpace[pResult->lParam].iIcon;
                else
                    pResult->nImage = 3;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    LPRESULTITEM lpResultItem = (LPRESULTITEM)pResult->lParam;

                    if (lpResultItem->szDisplayName[0] == TEXT('\0'))
                    {
                        LoadString (g_hInstance, lpResultItem->iStringID,
                                    lpResultItem->szDisplayName,
                                    MAX_DISPLAYNAME_SIZE);
                    }

                    pResult->str = lpResultItem->szDisplayName;
                }

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CSnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CSnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CSnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPGPEDATAOBJECT pGPEDataObjectA, pGPEDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPODataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IGPEDataObject,
                                            (LPVOID *)&pGPEDataObjectB)))
    {
        pGPEDataObjectA->Release();
        return S_FALSE;
    }

    pGPEDataObjectA->GetCookie(&cookie1);
    pGPEDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pGPEDataObjectA->Release();
    pGPEDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CSnapIn object implementation (IExtendContextMenu)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                   LPCONTEXTMENUCALLBACK pCallback,
                                   LONG *pInsertionAllowed)
{
    return m_pcd->AddMenuItems (piDataObject, pCallback, pInsertionAllowed);
}

STDMETHODIMP CSnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    return m_pcd->Command (lCommandID, piDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\sid.cpp ===
//*************************************************************
//
//  SID management functions.
//
//  THESE FUNCTIONS ARE WINDOWS NT SPECIFIC!!!!!
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

#include "main.h"

/***************************************************************************\
* GetSidString
*
* Allocates and returns a string representing the sid of the current user
* The returned pointer should be freed using DeleteSidString().
*
* Returns a pointer to the string or NULL on failure.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
LPTSTR GetSidString(HANDLE UserToken)
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;
#ifndef UNICODE
    STRING String;
#endif

    //
    // Get the user sid
    //

    UserSid = GetUserSid(UserToken);
    if (UserSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: GetUserSid returned NULL")));
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlConvertSidToUnicodeString failed, status = 0x%x"),
                 NtStatus));
        return NULL;
    }

#ifdef UNICODE


    return(UnicodeString.Buffer);

#else

    //
    // Convert the string to ansi
    //

    NtStatus = RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);
    RtlFreeUnicodeString(&UnicodeString);
    if (!NT_SUCCESS(NtStatus)) {
        DebugMsg((DM_WARNING, TEXT("GetSidString: RtlUnicodeStringToAnsiString failed, status = 0x%x"),
                 status));
        return NULL;
    }


    return(String.Buffer);

#endif

}


/***************************************************************************\
* DeleteSidString
*
* Frees up a sid string previously returned by GetSidString()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteSidString(LPTSTR SidString)
{

#ifdef UNICODE
    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
#else
    ANSI_STRING String;

    RtlInitAnsiString(&String, SidString);

    RtlFreeAnsiString(&String);
#endif

}



/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer. Caller
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
\***************************************************************************/
PSID GetUserSid (HANDLE UserToken)
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = (PTOKEN_USER)LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                      BytesRequired));
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to query user info from user token, status = 0x%x"),
                  status));
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: Failed to allocate %d bytes"),
                  BytesRequired));
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        DebugMsg((DM_WARNING, TEXT("GetUserSid: RtlCopySid Failed. status = %d"),
                  status));
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}


/***************************************************************************\
* DeleteUserSid
*
* Deletes a user sid previously returned by GetUserSid()
*
* Returns nothing.
*
* History:
* 26-Aug-92 Davidc     Created
*
\***************************************************************************/
VOID DeleteUserSid(PSID Sid)
{
    LocalFree(Sid);
}


//+--------------------------------------------------------------------------
//
//  Function:   AllocateAndInitSidFromString
//
//  Synopsis:   given the string representation of a SID, this function
//              allocate and initializes a SID which the string represents
//              For more information on the string representation of SIDs
//              refer to ntseapi.h & ntrtl.h
//
//  Arguments:  [in] lpszSidStr : the string representation of the SID
//              [out] pSID : the actual SID structure created from the string
//
//  Returns:    STATUS_SUCCESS : if the sid structure was successfully created
//              or an error code based on errors that might occur
//
//  History:    10/6/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS AllocateAndInitSidFromString (const WCHAR* lpszSidStr, PSID* ppSid)
{
    WCHAR *     pSidStr = 0;
    WCHAR*      pString = 0;
    NTSTATUS    Status;
    WCHAR*      pEnd = 0;
    int         count;
    BYTE        SubAuthCount;
    DWORD       SubAuths[8] = {0, 0, 0, 0, 0, 0, 0, 0};
    ULONG       n;
    ULONG       ulNoChars;
    SID_IDENTIFIER_AUTHORITY Auth;

    ulNoChars = lstrlen (lpszSidStr) + 1;
    pSidStr = (WCHAR *)LocalAlloc(LPTR, ulNoChars*sizeof(WCHAR));;
    if (!pSidStr)
    {
        Status = STATUS_NO_MEMORY;
        goto AllocAndInitSidFromStr_End;
    }

    HRESULT hr;

    hr = StringCchCopy (pSidStr, ulNoChars, lpszSidStr);
    ASSERT(SUCCEEDED(hr));

    pString = pSidStr;
    *ppSid = NULL;

    count = 0;
    do
    {
        pString = wcschr (pString, '-');
        if (NULL == pString)
            break;
        count++;
        pString++;
    } while (1);

    SubAuthCount = (BYTE)(count - 2);
    if (0 > SubAuthCount || 8 < SubAuthCount)
    {
        Status = ERROR_INVALID_SID;
        goto AllocAndInitSidFromStr_End;
    }

    pString = wcschr (pSidStr, L'-');
    pString++;
    pString = wcschr (pString, L'-'); //ignore the revision #
    pString++;
    pEnd = wcschr (pString, L'-');   //go to the beginning of subauths.
    if (NULL != pEnd) *pEnd = L'\0';

    Status = LoadSidAuthFromString (pString, &Auth);

    if (STATUS_SUCCESS != Status)
        goto AllocAndInitSidFromStr_End;

    for (count = 0; count < SubAuthCount; count++)
    {
        pString = pEnd + 1;
        pEnd = wcschr (pString, L'-');
        if (pEnd)
            *pEnd = L'\0';
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (STATUS_SUCCESS != Status)
            goto AllocAndInitSidFromStr_End;
        SubAuths[count] = n;
    }

    Status = RtlAllocateAndInitializeSid (&Auth, SubAuthCount,
                                          SubAuths[0], SubAuths[1], SubAuths[2],
                                          SubAuths[3], SubAuths[4], SubAuths[5],
                                          SubAuths[6], SubAuths[7], ppSid);

AllocAndInitSidFromStr_End:
    if (pSidStr)
        LocalFree( pSidStr );
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   LoadSidAuthFromString
//
//  Synopsis:   given a string representing the SID authority (as it is
//              normally represented in string format, fill the SID_AUTH..
//              structure. For more details on the format of the string
//              representation of the sid authority, refer to ntseapi.h and
//              ntrtl.h
//
//  Arguments:  [in] pString : pointer to the unicode string
//              [out] pSidAuth : pointer to the SID_IDENTIFIER_AUTH.. that is
//                              desired
//
//  Returns:    STATUS_SUCCESS if it succeeds
//              or an error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS LoadSidAuthFromString (const WCHAR* pString,
                                PSID_IDENTIFIER_AUTHORITY pSidAuth)
{
    size_t len;
    int i;
    NTSTATUS Status;
    const ULONG LowByteMask = 0xFF;
    ULONG n;

    len = lstrlenW (pString);

    if (len > 2 && 'x' == pString[1])
    {
        //this is in hex.
        //so we must have exactly 14 characters
        //(2 each for each of the 6 bytes) + 2 for the leading 0x
        if (14 != len)
        {
            Status = ERROR_INVALID_SID;
            goto LoadAuthEnd;
        }

        for (i=0; i < 6; i++)
        {
            pString += 2;   //we need to skip the leading 0x
            pSidAuth->Value[i] = (UCHAR)(((pString[0] - L'0') << 4) +
                                         (pString[1] - L'0'));
        }
    }
    else
    {
        //this is in decimal
        Status = GetIntFromUnicodeString (pString, 10, &n);
        if (Status != STATUS_SUCCESS)
            goto LoadAuthEnd;

        pSidAuth->Value[0] = pSidAuth->Value[1] = 0;
        for (i = 5; i >=2; i--, n>>=8)
            pSidAuth->Value[i] = (UCHAR)(n & LowByteMask);
    }

    Status = STATUS_SUCCESS;

LoadAuthEnd:
    return Status;
}

//+--------------------------------------------------------------------------
//
//  Function:   GetIntfromUnicodeString
//
//  Synopsis:   converts a unicode string into an integer
//
//  Arguments:  [in] szNum : the number represented as a unicode string
//              [in] Base : the base in which the resultant int is desired
//              [out] pValue : pointer to the integer representation of the
//                             number
//
//  Returns:    STATUS_SUCCESS if successful.
//              or some other error code
//
//  History:    9/29/1998  RahulTh  created
//
//---------------------------------------------------------------------------
NTSTATUS GetIntFromUnicodeString (const WCHAR* szNum, ULONG Base, PULONG pValue)
{
    WCHAR * pwszNumStr = 0;
    UNICODE_STRING StringW;
    size_t len;
    NTSTATUS Status;

    len = lstrlen (szNum);
    pwszNumStr = (WCHAR *)LocalAlloc( LPTR, (len + 1) * sizeof(WCHAR));

    if (!pwszNumStr)
    {
        Status = STATUS_NO_MEMORY;
        goto GetNumEnd;
    }

    HRESULT hr;

    hr = StringCchCopy (pwszNumStr, len+1, szNum);
    ASSERT(SUCCEEDED(hr));
    
    StringW.Length = len * sizeof(WCHAR);
    StringW.MaximumLength = StringW.Length + sizeof (WCHAR);
    StringW.Buffer = pwszNumStr;

    Status = RtlUnicodeStringToInteger (&StringW, Base, pValue);

GetNumEnd:
    if (pwszNumStr)
        LocalFree( pwszNumStr );
    return Status;
}


//*************************************************************
//
//  GetDomainSidFromRid()
//
//  Purpose:    Given one domain sid, constructs another domain sid
//              by replacing the tail by the passed in Rid
//
//  Parameters: pSid            -   Given Domain Sid
//              dwRid           -   Domain Rid
//              ppNewSid        -   Pointer to the New Sid
//
//  Return:     ERROR_SUCCESS on Success
//              FALSE if an error occurs
//
//  Comments:
//      Sid returned must be freed using FreeSid.
//
//  History:    Date        Author     Comment
//              6/6/95      ericflo    Created
//
//*************************************************************

NTSTATUS GetDomainSidFromDomainRid(PSID pSid, DWORD dwRid, PSID *ppNewSid)
{
    
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    // pointer to identifier authority
    BYTE      nSubAuthorityCount, i;                   // count of subauthorities
    DWORD     dwSubAuthority[8]={0,0,0,0,0,0,0,0};     // subauthority 
    PUCHAR    pSubAuthCount;
    DWORD    *pdwSubAuth;
    NTSTATUS  Status=ERROR_SUCCESS;
    
    DmAssert(IsValidSid(pSid));
    
    //
    // Will fail only if passed in sid is invalid and in the case 
    // the returned value is undefined. 
    //
    
    pIdentifierAuthority = RtlIdentifierAuthoritySid(pSid);
    
    //
    // get the count of subauthorities
    //

    pSubAuthCount = RtlSubAuthorityCountSid (pSid);
    
    if (!pSubAuthCount) {
        Status = ERROR_INVALID_SID;
        goto Exit;
    }
    
    nSubAuthorityCount = *pSubAuthCount;
    
    //
    // get each of the subauthorities
    //

    for (i = 0; i < (nSubAuthorityCount-1); i++) {
        pdwSubAuth = RtlSubAuthoritySid(pSid, i);
        
        if (!pdwSubAuth) {
            Status = ERROR_INVALID_SID;
            goto Exit;
        }
        
        dwSubAuthority[i] = *pdwSubAuth;
    }
    
    dwSubAuthority[i] = dwRid;

    //
    // Allocate a sid with these..
    //

    Status = RtlAllocateAndInitializeSid(
                pIdentifierAuthority,
                nSubAuthorityCount,
                dwSubAuthority[0],
                dwSubAuthority[1],
                dwSubAuthority[2],
                dwSubAuthority[3],
                dwSubAuthority[4],
                dwSubAuthority[5],
                dwSubAuthority[6],
                dwSubAuthority[7],
                ppNewSid
                );
    
Exit:

    // Sid, All Done
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\util.h ===
//*************************************************************
//  File name: UTIL.H
//
//  Description: Header file for util.cpp
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

#define GUID_LEN 38

LPTSTR CheckSlash (LPTSTR lpDir);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize);
BOOL ReportError (HWND hParent, DWORD dwError, UINT idMsg, ...);
void SetWaitCursor (void);
void ClearWaitCursor (void);
BOOL Delnode (LPTSTR lpDir);
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal);
HRESULT DSDelnode (LPTSTR lpDSPath);
UINT CreateSecureDirectory (LPTSTR lpDirectory);
HRESULT ConvertToDotStyle (LPOLESTR lpName, LPOLESTR *lpResult);
LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn);
LPOLESTR GetContainerFromLDAPPath(LPOLESTR szIn);

#define VALIDATE_INHERIT_DC     1
LPTSTR GetDCName (LPTSTR lpDomainName, LPTSTR lpInheritServer, HWND hParent, BOOL bAllowUI, DWORD dwFlags, ULONG ulRetFlags = 0);

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( GUID *pGuid, TCHAR * szValue );
BOOL ValidateGuid( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
BOOL IsNullGUID (GUID *pguid);
BOOL SpawnGPE (LPTSTR lpGPO, GROUP_POLICY_HINT_TYPE gpHint, LPTSTR lpDC, HWND hParent);
LPTSTR MakeFullPath (LPTSTR lpDN, LPTSTR lpServer);
LPTSTR MakeNamelessPath (LPTSTR lpDN);
LPTSTR ExtractServerName (LPTSTR lpPath);
BOOL DoesPathContainAServerName (LPTSTR lpPath);
HRESULT OpenDSObject (LPTSTR lpPath, REFIID riid, void FAR * FAR * ppObject);
HRESULT CheckDSWriteAccess (LPUNKNOWN punk, LPTSTR lpProperty);
VOID FreeDCSelections (void);
LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent);
DWORD GetDCHelper (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName);
LPTSTR ConvertName (LPTSTR lpName);
LPTSTR CreateTempFile (void);
DWORD QueryForForestName (LPTSTR lpServerName, LPTSTR lpDomainName, ULONG ulFlags,  LPTSTR *lpForestFound);
void NameToPath(WCHAR * szPath, WCHAR *szName, UINT cch);
LPTSTR GetPathToForest(LPOLESTR szServer);
BOOL IsForest(LPOLESTR szLDAPPath);
BOOL IsStandaloneComputer (VOID);
BOOL GetNewGPODisplayName (LPTSTR lpDisplayName, DWORD dwDisplayNameSize);
BOOL GetWMIFilter (BOOL bBrowser, HWND hwndParent, BOOL bDSFormat,
                   LPTSTR *lpDisplayName, LPTSTR * lpFilter, BSTR bstrDomain );
LPTSTR GetWMIFilterDisplayName (HWND hParent, LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat);
HRESULT SaveString(IStream *pStm, LPTSTR lpString);
HRESULT ReadString(IStream *pStm, LPTSTR *lpString, BOOL bUseLocalAlloc = FALSE);
BOOL GetSiteFriendlyName (LPWSTR szSitePath, LPWSTR *pszSiteName );
DWORD MapSecurityRights (PACL pAcl);

extern "C" {
DWORD SetSysvolSecurityFromDSSecurity (LPTSTR lpFileSysPath, SECURITY_INFORMATION si,
                             PSECURITY_DESCRIPTOR pSD);
}
BOOL GetStringSid(LPTSTR szSamName, LPTSTR *szStringSid);
BOOL GetUserNameFromStringSid(LPTSTR szStringSid, LPTSTR *szSamName);
HRESULT UnEscapeLdapPath(LPWSTR szDN, LPWSTR *pszUnEscapedPath);

#if !defined(_WIN64)
bool IsWin64();
#endif // _WIN64

//
// Length in chars of string form of guid {44cffeec-79d0-11d2-a89d-00c04fbbcfa2}
//
#define GUID_LENGTH 38
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\debug.h ===
//*************************************************************
//
//  Debugging functions header file
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1995
//  All rights reserved
//
//*************************************************************

//
// Debug Levels
//

#define DL_NONE     0x00000000
#define DL_NORMAL   0x00000001
#define DL_VERBOSE  0x00000002
#define DL_LOGFILE  0x00010000
#define DL_DEBUGGER 0x00020000

extern DWORD dwDebugLevel;


//
// Debug message types
//

#define DM_WARNING  0
#define DM_ASSERT   1
#define DM_VERBOSE  2


//
// Debug macros
//

#define DebugMsg(x) if (dwDebugLevel != DL_NONE) \
                        _DebugMsg x


//
// Debug function proto-types
//

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...);
void InitDebugSupport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\structs.h ===
//*************************************************************
//  File name: STRUCTS.H
//
//  Description:  Structures and function prototypes used in this project
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1998
//  All rights reserved
//
//*************************************************************

//
// Max displayname for a namespace item
//

#define MAX_DISPLAYNAME_SIZE    100

typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iIcon;
    INT          iOpenIcon;
    INT          iStringID;
    INT          iStringDescID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
    LPCTSTR      lpHelpTopic;
} NAMESPACEITEM, *LPNAMESPACEITEM;



//
// External function proto-types that we dynamicly link with
//

typedef BOOL (*PFNREFRESHPOLICY)(BOOL bMachine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\snapin.h ===
//
// SnapIn class
//

class CSnapIn:
    public IComponent,
    public IExtendContextMenu
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CComponentData      *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumnSize;  // Size of column 1
    LONG                 m_lViewMode;    // View mode
    BOOL                 m_bExpand;      // Expand root nodes

public:
    CSnapIn(CComponentData *pComponent);
    ~CSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\gposcripts.cpp ===
#include "gptext.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "SmartPtr.h"
#include <strsafe.h>

LPWSTR
StripLinkPrefix( LPWSTR pwszPath )
{
    WCHAR wszPrefix[] = L"LDAP://";
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}

HRESULT
SystemTimeToWbemTime( SYSTEMTIME& sysTime, XBStr& xbstrWbemTime )
{
    const DWORD dwTempLen = 25 + 1;
    XPtrST<WCHAR> xTemp = new WCHAR[dwTempLen];

    if ( !xTemp )
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = StringCchPrintf(xTemp, 
                                 dwTempLen,
                                 L"%04d%02d%02d%02d%02d%02d.000000+000",
                                 sysTime.wYear,
                                 sysTime.wMonth,
                                 sysTime.wDay,
                                 sysTime.wHour,
                                 sysTime.wMinute,
                                 sysTime.wSecond);
    if ( FAILED(hr) )
    {
        return E_FAIL;
    }

    xbstrWbemTime = xTemp;
    if ( !xbstrWbemTime )
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

PSID
GetUserSid( HANDLE UserToken )
{
    PTOKEN_USER pUser, pTemp;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;


    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if ( pUser == NULL )
    {
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if ( status == STATUS_BUFFER_TOO_SMALL )
    {

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = (PTOKEN_USER)LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if ( pTemp == NULL )
        {
            LocalFree (pUser);
            return NULL;
        }

        pUser = pTemp;

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pUser);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = (PSID)LocalAlloc(LMEM_FIXED, BytesRequired);
    if ( pSid == NULL )
    {
        LocalFree(pUser);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if ( !NT_SUCCESS(status) )
    {
        LocalFree(pSid);
        pSid = NULL;
    }


    return pSid;
}

LPWSTR
GetSidString( HANDLE UserToken )
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;

    //
    // Get the user sid
    //
    UserSid = GetUserSid( UserToken );
    if ( !UserSid )
    {
        return 0;
    }

    //
    // Convert user SID to a string.
    //
    NtStatus = RtlConvertSidToUnicodeString(&UnicodeString,
                                            UserSid,
                                            (BOOLEAN)TRUE ); // Allocate
    LocalFree( UserSid );

    if ( !NT_SUCCESS(NtStatus) )
    {
        return 0;
    }

    return UnicodeString.Buffer ;
}

void
DeleteSidString( LPWSTR SidString )
{
    UNICODE_STRING String;

    RtlInitUnicodeString( &String, SidString );
    RtlFreeUnicodeString( &String );
}

DWORD
SecureRegKey(   HANDLE  hToken,
                HKEY    hKey )
{
    DWORD dwError;
    SECURITY_DESCRIPTOR         sd;
    SID_IDENTIFIER_AUTHORITY    authNT = SECURITY_NT_AUTHORITY;
    PACL                        pAcl = 0;
    PSID                        psidUser = 0,
                                psidSystem = 0,
                                psidAdmin = 0,
                                psidNetworkService = 0;
    DWORD cbAcl, AceIndex;
    ACE_HEADER* lpAceHeader;

    //
    // Create the security descriptor that will be applied to the key
    //
    if ( hToken )
    {
        //
        // Get the user's sid
        //
        psidUser = GetUserSid( hToken );
        if ( !psidUser )
        {
            return GetLastError();
        }
    }
    else
    {
        //
        // Get the authenticated users sid
        //
        if ( !AllocateAndInitializeSid( &authNT,
                                        1,
                                        SECURITY_AUTHENTICATED_USER_RID,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        0,
                                        &psidUser ) )
        {
            return GetLastError();
        }
    }

    //
    // Get the system sid
    //
    if ( !AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem))
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Get the network sid
    //
    if ( !AllocateAndInitializeSid(&authNT, 1, SECURITY_NETWORK_SERVICE_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidNetworkService))
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Get the admin sid
    //
    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin))
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Allocate space for the ACL
    //
    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidNetworkService)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (8 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));

    pAcl = (PACL) GlobalAlloc( GMEM_FIXED, cbAcl );
    if ( !pAcl )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !InitializeAcl( pAcl, cbAcl, ACL_REVISION ) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //
    AceIndex = 0;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidNetworkService) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // Now the inheritable ACEs
    //
    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce(pAcl, AceIndex, (void**) &lpAceHeader) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem))
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce( pAcl, AceIndex, (void**) &lpAceHeader ) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidNetworkService))
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce( pAcl, AceIndex, (void**) &lpAceHeader ) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    AceIndex++;
    if ( !AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !GetAce(pAcl, AceIndex, (void**) &lpAceHeader) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);

    //
    // Put together the security descriptor
    //
    if ( !InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    if ( !SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE) )
    {
        dwError = GetLastError();
        goto Exit;
    }

    //
    // secure the registry key
    //
    dwError = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION, &sd );

Exit:
    //
    // LocalFree the sids and acl
    //
    if ( psidUser )
    {
        if ( hToken )
        {
            LocalFree( psidUser );
        }
        else
        {
            FreeSid( psidUser );
        }
    }

    if (psidSystem)
    {
        FreeSid( psidSystem );
    }

    if (psidAdmin)
    {
        FreeSid( psidAdmin );
    }

    if (pAcl)
    {
        GlobalFree( pAcl );
    }

    return dwError;
}

#define GPO_SCRIPTS_KEY L"Software\\Policies\\Microsoft\\Windows\\System\\Scripts"
#define GP_STATE_KEY    L"Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\State"

#define SCRIPT          L"Script"
#define PARAMETERS      L"Parameters"
#define EXECTIME        L"ExecTime"
#define GPOID           L"GPO-ID"
#define SOMID           L"SOM-ID"
#define FILESYSPATH     L"FileSysPath"
#define DISPLAYNAME     L"DisplayName"
#define GPONAME         L"GPOName"

#define SCR_STARTUP     L"Startup"
#define SCR_SHUTDOWN    L"Shutdown"
#define SCR_LOGON       L"Logon"
#define SCR_LOGOFF      L"Logoff"

DWORD
ScrGPOToReg(    LPWSTR  szIni,
                LPWSTR  szScrType,
                LPWSTR  szGPOName,
                LPWSTR  szGPOID,
                LPWSTR  szSOMID,
                LPWSTR  szFileSysPath,
                LPWSTR  szDisplayName,
                HKEY    hKeyPolicy,
                HKEY    hKeyState,
                HANDLE  hToken )
{
    DWORD       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HANDLE  hOldToken;
    HRESULT hr = S_OK;

    if ( ImpersonateUser( hToken, &hOldToken ) ) {
        if ( !GetFileAttributesEx( szIni, GetFileExInfoStandard, &fad ) )
        {
            return GetLastError();
        }

        RevertToUser( &hOldToken );
    }
    else
    {
        return GetLastError();
    }


    SYSTEMTIME  execTime;
    ZeroMemory( &execTime, sizeof( execTime ) );

    BOOL bFirst = TRUE;

    for( DWORD dwIndex = 0; ; dwIndex++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szScripts[3*MAX_PATH];
        WCHAR   szParams[3*MAX_PATH];
        XKey    hKeyScr;
        XKey    hKeyScrState;
        DWORD   dwBytes;

        if ( ImpersonateUser( hToken, &hOldToken ) )
        {
            //
            // Get the command line
            //
            szScripts[0] = 0;
            hr = StringCchPrintf( szTemp, ARRAYSIZE(szTemp), L"%dCmdLine", dwIndex );
            ASSERT(SUCCEEDED(hr));

            GetPrivateProfileString(szScrType,
                                    szTemp,
                                    L"",
                                    szScripts,
                                    ARRAYSIZE(szScripts),
                                    szIni );

            //
            // Get the parameters
            //
            szParams[0] = 0;
            hr = StringCchPrintf( szTemp, ARRAYSIZE(szTemp), L"%dParameters", dwIndex);
            ASSERT(SUCCEEDED(hr));

            GetPrivateProfileString(szScrType,
                                    szTemp,
                                    L"",
                                    szParams,
                                    ARRAYSIZE(szParams),
                                    szIni );

            RevertToUser( &hOldToken );
        }
        else
        {
            return GetLastError();
        }

        //
        // If the command line is empty, we're finished
        //
        if ( szScripts[0] == 0 )
        {
            if ( bFirst )
            {
                //
                // hack error code to detect no scripts
                //
                return ERROR_INVALID_FUNCTION;
            }
            break;
        }

        bFirst = FALSE;

        //
        // create a subkey for each script in the ini file
        //
        dwError = RegCreateKeyEx(   hKeyPolicy,
                                    _itow( dwIndex, szTemp, 16 ),
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyScr,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // create a subkey for each script in the ini file
        //
        dwError = RegCreateKeyEx(   hKeyState,
                                    szTemp,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyScrState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // script command line
        //
        dwBytes = sizeof( WCHAR ) * ( wcslen( szScripts ) + 1 );
        dwError = RegSetValueEx(hKeyScr,
                                SCRIPT,
                                0,
                                REG_SZ,
                                (BYTE*) szScripts,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                SCRIPT,
                                0,
                                REG_SZ,
                                (BYTE*) szScripts,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // parameters
        //
        dwBytes = sizeof( WCHAR ) * ( wcslen( szParams ) + 1 );
        dwError = RegSetValueEx(hKeyScr,
                                PARAMETERS,
                                0,
                                REG_SZ,
                                (BYTE*) szParams,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                PARAMETERS,
                                0,
                                REG_SZ,
                                (BYTE*) szParams,
                                dwBytes );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // execution time
        //
        dwError = RegSetValueEx(hKeyScr,
                                EXECTIME,
                                0,
                                REG_QWORD,
                                (BYTE*) &execTime,
                                sizeof( execTime ) );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        dwError = RegSetValueEx(hKeyScrState,
                                EXECTIME,
                                0,
                                REG_QWORD,
                                (BYTE*) &execTime,
                                sizeof( execTime ) );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    DWORD   dwBytes;

    //
    // GPOID
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szGPOID ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            GPOID,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            GPOID,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }


    //
    // SOMID
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szSOMID ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            SOMID,
                            0,
                            REG_SZ,
                            (BYTE*) szSOMID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            SOMID,
                            0,
                            REG_SZ,
                            (BYTE*) szSOMID,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // FILESYSPATH
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szFileSysPath ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            FILESYSPATH,
                            0,
                            REG_SZ,
                            (BYTE*) szFileSysPath,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            FILESYSPATH,
                            0,
                            REG_SZ,
                            (BYTE*) szFileSysPath,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // DISPLAYNAME
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szDisplayName ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            DISPLAYNAME,
                            0,
                            REG_SZ,
                            (BYTE*) szDisplayName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            DISPLAYNAME,
                            0,
                            REG_SZ,
                            (BYTE*) szDisplayName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPONAME
    //
    dwBytes = sizeof( WCHAR ) * ( wcslen( szGPOName ) + 1 );
    dwError = RegSetValueEx(hKeyPolicy,
                            GPONAME,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    dwError = RegSetValueEx(hKeyState,
                            GPONAME,
                            0,
                            REG_SZ,
                            (BYTE*) szGPOName,
                            dwBytes );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    return dwError;
}

DWORD
ScrGPOListToReg(PGROUP_POLICY_OBJECT    pGPO,
                BOOL                    bMachine,
                HKEY                    hKeyRoot,
                HKEY                    hKeyState,
                HANDLE                  hToken )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szScriptKey[MAX_PATH];
    WCHAR   szStateKey[MAX_PATH];
    WCHAR   szFileSysPath[MAX_PATH];
    WCHAR   szTemp[32];
    DWORD   dwLogon, dwLogoff, dwStartup, dwShutdown;
    HRESULT hr = S_OK;

    dwLogon = dwLogoff = dwStartup = dwShutdown = 0;

    //
    // for each GPO
    //
    for ( ; pGPO ; pGPO = pGPO->pNext )
    {
        XKey    hKeyTypePolicy;
        XKey    hKeyTypeState;
        LPWSTR  szType;

        LPWSTR  szGPOID = wcschr( pGPO->lpDSPath, L',' );
        if ( szGPOID )
        {
            szGPOID++;
        }
        else
        {
            szGPOID = pGPO->lpDSPath;
        }

        LPWSTR szSOMID = StripLinkPrefix( pGPO->lpLink );

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\Machine\Scripts\Scripts.ini
        //
        hr = StringCchCopy( szFileSysPath, ARRAYSIZE(szFileSysPath), pGPO->lpFileSysPath );
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        hr = StringCchCat( szFileSysPath, ARRAYSIZE(szFileSysPath), L"\\Scripts\\Scripts.ini");
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        //
        // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>\\<Index>"
        // hKeyState == "Software\\Microsoft\\Windows\\Group Policy\\State\\Scripts\\<Target>"
        // construct hKeyState:"<Type>\\<Index>"
        //
        hr = StringCchCopy( szScriptKey, ARRAYSIZE(szScriptKey), GPO_SCRIPTS_KEY );
        ASSERT(SUCCEEDED(hr));

        if ( bMachine )
        {
            szType = SCR_STARTUP;
            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), L"\\" SCR_STARTUP L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), _itow( dwStartup, szTemp, 16 ) );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCopy( szStateKey, ARRAYSIZE(szStateKey), SCR_STARTUP L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szStateKey, ARRAYSIZE(szStateKey), szTemp );
            if (FAILED(hr))
            {
                SetLastError(dwError = HRESULT_CODE(hr));
                break;
            }
        }
        else
        {
            szType = SCR_LOGON;
            hr  = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), L"\\" SCR_LOGON L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), _itow( dwLogon, szTemp, 16 ) );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCopy( szStateKey, ARRAYSIZE(szStateKey), SCR_LOGON L"\\" );
            ASSERT(SUCCEEDED(hr));
            
            hr = StringCchCat( szStateKey, ARRAYSIZE(szStateKey), szTemp );
            if (FAILED(hr))
            {
                SetLastError(dwError = HRESULT_CODE(hr));
                break;
            }
        }

        //
        // open/create the state key
        // 
        dwError = RegCreateKeyEx(   hKeyState,
                                    szStateKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypeState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open/create the script key
        // 
        dwError = RegCreateKeyEx(   hKeyRoot,
                                    szScriptKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypePolicy,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToReg(  szFileSysPath,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                hKeyTypePolicy,
                                hKeyTypeState,
                                hToken );
        if ( dwError == ERROR_INVALID_FUNCTION )
        {
            dwError = ERROR_SUCCESS;
            RegDelnode( hKeyRoot, szScriptKey );
            RegDelnode( hKeyState, szStateKey );
            // continue processing
        }
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        else {
            if ( bMachine )
            {
                dwStartup++;
            }
            else 
            {
                dwLogon++;
            }
        }

        //
        // construct "Software\\Policies\\Microsoft\\Windows\\System\\Scripts\\<Type>\\<Index>"
        // hKeyState == "Software\\Microsoft\\Windows\\Group Policy\\State\\Scripts\\<Target>"
        // construct hKeyState:"<Type>\\<Index>"
        //
        hr = StringCchCopy( szScriptKey, ARRAYSIZE(szScriptKey), GPO_SCRIPTS_KEY );
        ASSERT(SUCCEEDED(hr));

        if ( bMachine )
        {
            szType = SCR_SHUTDOWN;
            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), L"\\" SCR_SHUTDOWN L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), _itow( dwShutdown, szTemp, 16 ) );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCopy( szStateKey, ARRAYSIZE(szStateKey), SCR_SHUTDOWN L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szStateKey, ARRAYSIZE(szStateKey), szTemp );
            if (FAILED(hr))
            {
                SetLastError(dwError = HRESULT_CODE(hr));
                break;
            }
        }
        else
        {
            szType = SCR_LOGOFF;
            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), L"\\" SCR_LOGOFF L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szScriptKey, ARRAYSIZE(szScriptKey), _itow( dwLogoff, szTemp, 16 ) );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCopy( szStateKey, ARRAYSIZE(szStateKey), SCR_LOGOFF L"\\" );
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat( szStateKey, ARRAYSIZE(szStateKey), szTemp );
            if (FAILED(hr))
            {
                SetLastError(dwError = HRESULT_CODE(hr));
                break;
            }
        }

        //
        // open/create the state key
        // 
        dwError = RegCreateKeyEx(   hKeyState,
                                    szStateKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypeState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // open/create the script key
        // 
        hKeyTypePolicy = 0;
        dwError = RegCreateKeyEx(   hKeyRoot,
                                    szScriptKey,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyTypePolicy,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToReg(  szFileSysPath,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                hKeyTypePolicy,
                                hKeyTypeState,
                                hToken );
        if ( dwError == ERROR_INVALID_FUNCTION )
        {
            dwError = ERROR_SUCCESS;
            RegDelnode( hKeyRoot, szScriptKey );
            RegDelnode( hKeyState, szStateKey );
            // continue processing
        }
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
        else {
            if ( bMachine )
            {
                dwShutdown++;
            }
            else 
            {
                dwLogoff++;
            }
        }
    }

    return dwError;
}

class CGPOScriptsLogger
{
public:
    CGPOScriptsLogger( IWbemServices* pServices ) :
        m_bInitialized(FALSE),
        m_cScripts( 0 ),
        m_pServices( pServices )
    {
        XBStr                          xsz;
        XInterface<IWbemClassObject>   xClass;

        //
        // WBEM version of CF for RSOP_ScriptPolicySetting
        // Script Policy Object, RSOP_ScriptPolicySetting in MOF
        //

        xsz = L"RSOP_ScriptPolicySetting";
        if ( !xsz )
            return;

        HRESULT hr = pServices->GetObject(  xsz,
                                            0L,
                                            0,
                                            &xClass,
                                            0 );
        if ( FAILED(hr) )
        {
            return;
        }

        //
        // spawn an instance of RSOP_ScriptPolicySetting
        //

        hr = xClass->SpawnInstance( 0, &m_pInstSetting );
        if ( FAILED (hr) )
        {
            return;
        }

        //
        // WBEM version of CF for RSOP_ScriptCmd
        // individual script commands, RSOP_ScriptCmd in MOF
        //

        xsz = L"RSOP_ScriptCmd";
        if ( !xsz )
        {
            return;
        }
        xClass = 0;
        hr = pServices->GetObject(  xsz,
                                    0L,
                                    0,
                                    &xClass,
                                    0 );
        if ( FAILED(hr) )
        {
            return;
        }

        //
        // spawn an instance of RSOP_ScriptCmd
        //

        hr = xClass->SpawnInstance( 0, &m_pInstCmd );
        if ( FAILED (hr) )
        {
            return;
        }

        m_bInitialized = TRUE;
    }

    BOOL Initialized()
    {
        return m_bInitialized;
    }

    DWORD SetGPOID( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"GPOID", 0, &var, 0 );
    }

    DWORD SetID( LPWSTR sz )
    {
        DWORD dwIDLength = wcslen( sz ) + 1;
        m_szID = (LPWSTR) LocalAlloc( LPTR, sizeof( WCHAR ) * ( dwIDLength ) );

        if ( !m_szID )
        {
            return GetLastError();
        }

        HRESULT hr = StringCchCopy( m_szID, dwIDLength, sz );

        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            return HRESULT_CODE(hr);
        }

        return ERROR_SUCCESS;
    }

    DWORD SetSOMID( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"SOMID", 0, &var, 0 );
    }

    DWORD SetName( LPWSTR sz )
    {
        VARIANT var;
        XBStr x = sz;
        var.vt = VT_BSTR;
        var.bstrVal = x;
        return m_pInstSetting->Put( L"name", 0, &var, 0 );
    }

    DWORD SetScriptType( LPWSTR sz )
    {
        DWORD dwScptLen = wcslen( sz ) + 1;
        m_szScriptType = (LPWSTR) LocalAlloc( LPTR, ( dwScptLen ) * sizeof( WCHAR ) );
        if ( m_szScriptType )
        {
            HRESULT hr = StringCchCopy( m_szScriptType, dwScptLen, sz );

            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                return HRESULT_CODE(hr);
            }

            return 0;
        }
        else
        {
            return GetLastError();
        }
    }

    DWORD SetScriptOrder( DWORD cOrder )
    {
        VARIANT var;
        
        var.vt = VT_I4;
        var.lVal = cOrder;
        return m_pInstSetting->Put( L"ScriptOrder", 0, &var, 0 );
    }

    DWORD SetScriptCount( DWORD cScripts )
    {
        m_cScripts = 0;
        SAFEARRAYBOUND arrayBound[1];
        arrayBound[0].lLbound = 0;
        arrayBound[0].cElements = cScripts;

        //
        // create a SafeArray of RSOP_ScriptCmd
        //

        m_aScripts = SafeArrayCreate( VT_UNKNOWN, 1, arrayBound );

        if ( !m_aScripts )
        {
            return E_OUTOFMEMORY;
        }

        return 0;
    }

    DWORD AddScript( LPWSTR szScript, LPWSTR szParameters, SYSTEMTIME* pExecTime )
    {
        HRESULT     hr = S_OK;
        IUnknown*   pUnk = 0;
        VARIANT     var;
        XBStr       xsz;
        XInterface<IWbemClassObject> pClone;

        hr = m_pInstCmd->Clone( &pClone );
        if ( FAILED (hr) )
        {
            return hr;
        }

        var.vt = VT_BSTR;
        xsz = szScript;
        var.bstrVal = xsz;
        hr = pClone->Put( L"Script", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        //
        // set the Arguments field for RSOP_ScriptCmd
        //
        xsz = szParameters;
        var.bstrVal = xsz;
        hr = pClone->Put( L"Arguments", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        //
        // set the executionTime field for RSOP_ScriptCmd
        //
        xsz = 0;
        hr = SystemTimeToWbemTime( *pExecTime, xsz );
        if ( FAILED (hr) )
        {
            return hr;
        }
        
        var.bstrVal = xsz;
        hr = pClone->Put( L"executionTime", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        hr = pClone->QueryInterface( IID_IUnknown, (void **)&pUnk );
        if ( FAILED (hr) )
        {
            return hr;
        }

        hr = SafeArrayPutElement( m_aScripts, (LONG*) &m_cScripts, pUnk );
        if ( FAILED (hr) )
        {
            pUnk->Release();
            return hr;
        }

        m_cScripts++;

        return hr;
    }

    DWORD Log()
    {
        HRESULT hr;
        VARIANT var;
        XBStr   x;
        WCHAR   szName[128];

        var.vt = VT_I4;
        var.lVal = 1;
        hr = m_pInstSetting->Put( L"precedence", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        hr = StringCchCopy( szName, ARRAYSIZE(szName), m_szID );

        if (FAILED(hr)) 
            return hr;

        hr = StringCchCat( szName, ARRAYSIZE(szName), L"-" );

        if (FAILED(hr))
            return hr;

        hr = StringCchCat( szName, ARRAYSIZE(szName), m_szScriptType );

        if (FAILED(hr))
            return hr;

        var.vt = VT_BSTR;
        var.bstrVal = szName;
        hr = m_pInstSetting->Put( L"id", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        DWORD dwType;

        if ( !wcscmp( m_szScriptType, SCR_LOGON ) )
        {
            dwType = 1;
        }
        else if ( !wcscmp( m_szScriptType, SCR_LOGOFF ) )
        {
            dwType = 2;
        }
        else if ( !wcscmp( m_szScriptType, SCR_STARTUP ) )
        {
            dwType = 3;
        }
        else
        {
            dwType = 4;
        }
        
        var.vt = VT_I4;
        var.lVal = dwType;
        hr = m_pInstSetting->Put( L"ScriptType", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        var.vt = VT_ARRAY | VT_UNKNOWN;
        var.parray = m_aScripts;
        hr = m_pInstSetting->Put( L"ScriptList", 0, &var, 0 );
        if ( FAILED (hr) )
        {
            return hr;
        }

        return m_pServices->PutInstance(m_pInstSetting,
                                        WBEM_FLAG_CREATE_OR_UPDATE,
                                        0,
                                        0 );
    }

private:
    BOOL                           m_bInitialized;
    XPtrLF<WCHAR>                  m_szID;
    DWORD                          m_cScripts;
    IWbemServices*                 m_pServices;
    XSafeArray                     m_aScripts;
    XInterface<IWbemClassObject>   m_pInstSetting;
    XInterface<IWbemClassObject>   m_pInstCmd;
    XPtrLF<WCHAR>                  m_szScriptType;
};

DWORD
ScrRegGPOToWbem(HKEY            hKeyGPO,
                LPWSTR          szScrType,
                DWORD           dwScriptOrder,
                CGPOScriptsLogger* pLogger )
{
    DWORD   dwError = ERROR_SUCCESS;
    DWORD   cSubKeys = 0;
    WCHAR   szBuffer[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize;

    //
    // ID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                GPONAME,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetID( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPOID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                GPOID,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetGPOID( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // SOMID
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                SOMID,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );

    //
    // The above API call may fail because SOMS can be arbitrarily long and 
    // we are using a fixed size buffer, so we will retry if the API returns 
    // ERROR_MORE_DATA 
    //

    if ( (dwError != ERROR_SUCCESS) && ( dwError != ERROR_MORE_DATA) )
    {
        return dwError;
    }
    else if (ERROR_MORE_DATA == dwError) 
    {
        //
        // This case is only handled for SOMID since only SOMID does not have limitation 
        // on the length
        //

        WCHAR   *szHeapBuffer = NULL; 

        szHeapBuffer = (WCHAR *) LocalAlloc( LPTR,dwSize);

        if (NULL == szHeapBuffer)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        szHeapBuffer[0] = 0;

        dwError = RegQueryValueEx(  hKeyGPO,
                                    SOMID,
                                    0,
                                    &dwType,
                                    (LPBYTE) szHeapBuffer,
                                    &dwSize );

        if (ERROR_SUCCESS == dwError) 
        {
            dwError = pLogger->SetSOMID( szHeapBuffer );
        }

        LocalFree(szHeapBuffer);
    }
    else
    {
      dwError = pLogger->SetSOMID( szBuffer );  
    }

    if (dwError != ERROR_SUCCESS )  // Check for the success of SetSOMID
    {
        return dwError;
    }


    //
    // DISPLAYNAME
    //
    dwType = REG_SZ;
    dwSize = sizeof( szBuffer );
    szBuffer[0] = 0;
    dwError = RegQueryValueEx(  hKeyGPO,
                                DISPLAYNAME,
                                0,
                                &dwType,
                                (LPBYTE) szBuffer,
                                &dwSize );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    dwError = pLogger->SetName( szBuffer );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script type
    //
    dwError = pLogger->SetScriptType( szScrType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script order
    //
    dwError = pLogger->SetScriptOrder( dwScriptOrder );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // get the numer of Scripts
    //
    dwError = RegQueryInfoKey(  hKeyGPO,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    pLogger->SetScriptCount( cSubKeys );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // for every Script
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey    hKeyScript;
        WCHAR   szTemp[32];
        SYSTEMTIME  execTime;
        WCHAR   szScript[MAX_PATH];
        WCHAR   szParameters[MAX_PATH];

        //
        // open the Script key
        //
        dwError = RegOpenKeyEx( hKeyGPO,
                                _itow( dwIndex, szTemp, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyScript );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // script
        // 
        dwType = REG_SZ;
        dwSize = sizeof( szScript );
        szScript[0] = 0;
        dwError = RegQueryValueEx(  hKeyScript,
                                    SCRIPT,
                                    0,
                                    &dwType,
                                    (LPBYTE) szScript,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // parameters
        // 
        dwType = REG_SZ;
        dwSize = sizeof( szParameters );
        szParameters[0] = 0;
        dwError = RegQueryValueEx(  hKeyScript,
                                    PARAMETERS,
                                    0,
                                    &dwType,
                                    (LPBYTE) szParameters,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // exec time
        // 
        dwType = REG_QWORD;
        dwSize = sizeof( execTime );
        dwError = RegQueryValueEx(  hKeyScript,
                                    EXECTIME,
                                    0,
                                    &dwType,
                                    (LPBYTE) &execTime,
                                    &dwSize );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        dwError = pLogger->AddScript( szScript, szParameters, &execTime );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    if ( !FAILED( dwError ) )
    {
        dwError = pLogger->Log();
    }

    return dwError;
}

DWORD
pScrRegGPOListToWbem(   LPWSTR          szSID,
                        LPWSTR          szType,
                        CGPOScriptsLogger* pLogger )
{
    DWORD   dwError = ERROR_SUCCESS;
    WCHAR   szBuffer[MAX_PATH] = L"";
    XKey    hKeyType;
    BOOL    bMachine = !szSID;
    HRESULT hr = S_OK;

    //
    // open the following key
    // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts\Type
    //
    hr = StringCchCopy( szBuffer, ARRAYSIZE(szBuffer), GP_STATE_KEY L"\\" );
    ASSERT(SUCCEEDED(hr));

    if ( bMachine )
    {
        hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"Machine\\Scripts\\" );
    }
    else
    {
        hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), szSID );
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            return dwError;
        }

        hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"\\Scripts\\" );
    }
    if (FAILED(hr))
    {
        SetLastError(dwError = HRESULT_CODE(hr));
        return dwError;
    }
    
    hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), szType );
    if (FAILED(hr))
    {
        SetLastError(dwError = HRESULT_CODE(hr));
        return dwError;
    }

    //
    // open the key
    //

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_ALL_ACCESS,
                            &hKeyType );
    if ( dwError != ERROR_SUCCESS )
    {
        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            dwError = ERROR_SUCCESS;
        }
        return dwError;
    }

    DWORD   cSubKeys = 0;

    //
    // get the numer of GPOs
    //

    dwError = RegQueryInfoKey(  hKeyType,
                                0,
                                0,
                                0,
                                &cSubKeys,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0 );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }
    //
    // for every GPO
    //
    for ( DWORD dwIndex = 0 ; dwIndex < cSubKeys ; dwIndex++ )
    {
        XKey hKeyGPO;

        //
        // open the GPO key
        //
        dwError = RegOpenKeyEx( hKeyType,
                                _itow( dwIndex, szBuffer, 16 ),
                                0,
                                KEY_ALL_ACCESS,
                                &hKeyGPO );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        //
        // dump all scripts in the GPO into Wbem
        //
        dwError = ScrRegGPOToWbem( hKeyGPO, szType, dwIndex + 1, pLogger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    return dwError;
}

extern "C" DWORD
ScrRegGPOListToWbem(LPWSTR          szSID,
                    IWbemServices*  pServices );

DWORD
ScrRegGPOListToWbem(LPWSTR          szSID,
                    IWbemServices*  pServices )
{
    DWORD   dwError = ERROR_SUCCESS;

    CGPOScriptsLogger logger( pServices );
    if ( !logger.Initialized() )
    {
        return GetLastError();
    }

    dwError = pScrRegGPOListToWbem( szSID,
                                    !szSID ? SCR_STARTUP : SCR_LOGON,
                                    &logger );
    if ( dwError == ERROR_SUCCESS )
    {
        dwError = pScrRegGPOListToWbem( szSID,
                                        !szSID ? SCR_SHUTDOWN : SCR_LOGOFF,
                                        &logger );
    }
    return dwError;
}

DWORD
ScrGPOToWbem(   LPWSTR  szIni,
                LPWSTR  szScrType,
                LPWSTR  szGPOName,
                LPWSTR  szGPOID,
                LPWSTR  szSOMID,
                LPWSTR  szFileSysPath,
                LPWSTR  szDisplayName,
                DWORD&  dwScriptOrder,
                HANDLE  hToken,
                CGPOScriptsLogger* pLogger )
{
    DWORD       dwError = ERROR_SUCCESS;
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HRESULT     hr  =   S_OK;

    if ( !GetFileAttributesEx( szIni, GetFileExInfoStandard, &fad ) )
    {
        return GetLastError();
    }

    //
    // GPONAME
    //
    dwError = pLogger->SetID( szGPOName );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // GPOID
    //
    dwError = pLogger->SetGPOID( szGPOID );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // SOMID
    //
    dwError = pLogger->SetSOMID( szSOMID );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // NAME
    //
    dwError = pLogger->SetName( szDisplayName );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script type
    //
    dwError = pLogger->SetScriptType( szScrType );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // script order
    //
    dwError = pLogger->SetScriptOrder( dwScriptOrder );
    if ( dwError != ERROR_SUCCESS )
    {
        return dwError;
    }

    //
    // count the number of scripts
    //
    for( DWORD cScripts = 0; ; cScripts++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szBuffer[3*MAX_PATH];

        //
        // Get the command line
        //
        szBuffer[0] = 0;
        hr = StringCchPrintf( szTemp, ARRAYSIZE(szTemp), L"%dCmdLine", cScripts );
        ASSERT(SUCCEEDED(hr));

        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szBuffer,
                                ARRAYSIZE(szBuffer),
                                szIni );
        //
        // If the command line is empty, we're finished
        //
        if ( szBuffer[0] == 0 )
        {
            break;
        }
    }

    if ( !cScripts )
    {
        return S_OK;
    }
    else
    {
        dwScriptOrder++;
    }

    //
    // set script count
    //
    pLogger->SetScriptCount( cScripts );

    SYSTEMTIME  execTime;
    ZeroMemory( &execTime, sizeof( execTime ) );

    for( DWORD dwIndex = 0; dwIndex < cScripts ; dwIndex++ )
    {
        WCHAR   szTemp[32];
        WCHAR   szScript[MAX_PATH];
        WCHAR   szParams[MAX_PATH];

        //
        // Get the command line
        //
        szScript[0] = 0;
        hr = StringCchPrintf( szTemp, ARRAYSIZE(szTemp), L"%dCmdLine", dwIndex );
        ASSERT(SUCCEEDED(hr));

        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szScript,
                                ARRAYSIZE(szScript),
                                szIni );

        //
        // If the command line is empty, we're finished
        //
        if ( szScript[0] == 0 )
        {
            break;
        }

        //
        // Get the parameters
        //
        szParams[0] = 0;
        hr = StringCchPrintf( szTemp, ARRAYSIZE(szTemp), L"%dParameters", dwIndex);
        ASSERT(SUCCEEDED(hr));

        GetPrivateProfileString(szScrType,
                                szTemp,
                                L"",
                                szParams,
                                ARRAYSIZE(szParams),
                                szIni );

        dwError = pLogger->AddScript( szScript, szParams, &execTime );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    if ( !FAILED( dwError ) )
    {
        dwError = pLogger->Log();
    }

    return dwError;
}

DWORD
ScrGPOListToWbem(   PGROUP_POLICY_OBJECT    pGPO,
                    BOOL                    bMachine,
                    HANDLE                  hToken,
                    IWbemServices*          pServices )
{
    DWORD   dwError = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    CGPOScriptsLogger logger( pServices );
    if ( !logger.Initialized() )
    {
        return GetLastError();
    }

    //
    // for each GPO
    //
    for ( DWORD dwIndex1 = 1, dwIndex2 = 1 ; pGPO ; pGPO = pGPO->pNext )
    {
        WCHAR   szBuffer[MAX_PATH];
        WCHAR   szTemp[32];
        LPWSTR  szType;

        if ( bMachine )
        {
            szType = SCR_STARTUP;
        }
        else
        {
            szType = SCR_LOGON;
        }

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\Machine\Scripts\Scripts.ini
        //
        
        hr = StringCchCopy( szBuffer, ARRAYSIZE(szBuffer), pGPO->lpFileSysPath );
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"\\Scripts\\Scripts.ini");
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        LPWSTR  szGPOID = wcschr( pGPO->lpDSPath, L',' );
        if ( szGPOID )
        {
            szGPOID++;
        }

        LPWSTR  szSOMID = StripLinkPrefix( pGPO->lpLink );

        //
        // dump the scripts to the registry
        //
        dwError = ScrGPOToWbem( szBuffer,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                dwIndex1,
                                hToken,
                                &logger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }

        if ( bMachine )
        {
            szType = SCR_SHUTDOWN;
        }
        else
        {
            szType = SCR_LOGOFF;
        }

        //
        // construct \\<domain-DNS>\SysVol\<domain-DNS>\Policies\{<GPOID>}\User\Scripts\Scripts.ini
        //
        hr = StringCchCopy( szBuffer, ARRAYSIZE(szBuffer), pGPO->lpFileSysPath );
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"\\Scripts\\Scripts.ini");
        if (FAILED(hr))
        {
            SetLastError(dwError = HRESULT_CODE(hr));
            break;
        }

        //
        // dump the scripts to the registry
        //

        dwError = ScrGPOToWbem( szBuffer,
                                szType,
                                pGPO->szGPOName,
                                szGPOID,
                                szSOMID,
                                pGPO->lpFileSysPath,
                                pGPO->lpDisplayName,
                                dwIndex2,
                                hToken,
                                &logger );
        if ( dwError != ERROR_SUCCESS )
        {
            break;
        }
    }

    return dwError;
}

DWORD
ProcessScripts( DWORD                   dwFlags,
                HANDLE                  hToken,
                HKEY                    hKeyRoot,
                PGROUP_POLICY_OBJECT    pDeletedGPOList,
                PGROUP_POLICY_OBJECT    pChangedGPOList,
                BOOL*                   pbAbort,
                BOOL                    bRSoPPlanningMode,
                IWbemServices*          pWbemServices,
                HRESULT*                phrRsopStatus )
{
    HANDLE  hOldToken;
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    bMachine = ( dwFlags & GPO_INFO_FLAG_MACHINE ) != 0;
    BOOL    bLinkTransition = (dwFlags & GPO_INFO_FLAG_LINKTRANSITION) && (dwFlags & GPO_INFO_FLAG_SLOWLINK);
    HRESULT hr = S_OK;

    if ( bRSoPPlanningMode )
    {
        if ( !bLinkTransition )
        {
            dwError = ScrGPOListToWbem( pChangedGPOList, bMachine, hToken, pWbemServices );
        }
    }
    else
    {
        XKey    hKeyState;
        WCHAR   szBuffer[MAX_PATH];

        //
        // create and secure the following key
        // HKLM\Software\Microsoft\Windows\CurrentVersion\Group Policy\State\<Target>\Scripts
        //
        hr = StringCchCopy( szBuffer, ARRAYSIZE(szBuffer), GP_STATE_KEY L"\\" );
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            return HRESULT_CODE(hr);
        }

        if ( bMachine )
        {
            hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"Machine\\Scripts" );
            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                return HRESULT_CODE(hr);
            }
        }
        else
        {
            LPWSTR szSid = GetSidString( hToken );

            if ( !szSid )
            {
                return GetLastError();
            }
            hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), szSid );
            DeleteSidString( szSid ); // delete SID here
            
            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                return HRESULT_CODE(hr);
            }

            hr = StringCchCat( szBuffer, ARRAYSIZE(szBuffer), L"\\Scripts" );
            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                return HRESULT_CODE(hr);
            }
        }

        dwError = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                                    szBuffer,
                                    0,
                                    0,
                                    0,
                                    KEY_ALL_ACCESS,
                                    0,
                                    &hKeyState,
                                    0 );
        if ( dwError != ERROR_SUCCESS )
        {
            return dwError;
        }

        dwError = SecureRegKey( hToken, hKeyState );
        if ( dwError != ERROR_SUCCESS )
        {
            return dwError;
        }

        if ( bMachine )
        {
            //
            // delete the Startup and Shutdown keys
            //
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_STARTUP );
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_SHUTDOWN );
            RegDelnode( hKeyState, SCR_STARTUP );
            RegDelnode( hKeyState, SCR_SHUTDOWN );
        }
        else
        {
            //
            // delete the Logon and Logoff keys
            //
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_LOGON );
            RegDelnode( hKeyRoot, GPO_SCRIPTS_KEY L"\\" SCR_LOGOFF );
            RegDelnode( hKeyState, SCR_LOGON );
            RegDelnode( hKeyState, SCR_LOGOFF );
        }

        dwError = ScrGPOListToReg(  pChangedGPOList,
                                    bMachine,
                                    hKeyRoot,
                                    hKeyState,
                                    hToken );
    }
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\debug.cpp ===
//*************************************************************
//
//  Debugging functions
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1997
//  All rights reserved
//
//*************************************************************

#include "gptext.h"
#include <strsafe.h>

//
// Global Variable containing the debugging level.
//

DWORD   dwDebugLevel;

//
// Debug strings
//

const TCHAR c_szGPTExt[] = TEXT("GPTEXT(%x.%x) %02d:%02d:%02d:%03d ");
const TCHAR c_szCRLF[]    = TEXT("\r\n");


//
// Registry debug information
//

#define DEBUG_REG_LOCATION  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define DEBUG_KEY_NAME      TEXT("GPTExtDebugLevel")

//
// Log files
//

TCHAR szLogFileName[] = TEXT("%SystemRoot%\\Debug\\UserMode\\gptext.log");

//*************************************************************
//
//  InitDebugSupport()
//
//  Purpose:    Sets the debugging level.
//              Also checks the registry for a debugging level.
//
//  Parameters: None
//
//  Return:     void
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void InitDebugSupport(void)
{
    LONG lResult;
    HKEY hKey;
    DWORD dwType, dwSize;

    //
    // Initialize the debug level to normal
    //

#if DBG
    dwDebugLevel = DL_NORMAL | DL_LOGFILE | DL_DEBUGGER;
#else
    dwDebugLevel = DL_NORMAL | DL_LOGFILE;
#endif


    //
    // Check the registry
    //

    lResult = RegOpenKey (HKEY_LOCAL_MACHINE, DEBUG_REG_LOCATION,
                          &hKey);

    if (lResult == ERROR_SUCCESS) {

        dwSize = sizeof(dwDebugLevel);
        RegQueryValueEx(hKey, DEBUG_KEY_NAME, NULL, &dwType,
                        (LPBYTE)&dwDebugLevel, &dwSize);

        RegCloseKey(hKey);
    }
}

//*************************************************************
//
//  DebugMsg()
//
//  Purpose:    Displays debug messages based on the debug level
//              and type of debug message.
//
//  Parameters: mask    -   debug message type
//              pszMsg  -   debug message
//              ...     -   variable number of parameters
//      
//  Return:     void
//
//
//  Comments:
//
//
//  History:    Date        Author     Comment
//              5/25/95     ericflo    Created
//
//*************************************************************

void _DebugMsg(UINT mask, LPCTSTR pszMsg, ...)
{
    BOOL bOutput;
    TCHAR szDebugTitle[40];
    TCHAR szDebugBuffer[2048];
    va_list marker;
    DWORD dwErrCode;
    SYSTEMTIME systime;

    //
    // Save the last error code (so the debug output doesn't change it).
    //

    dwErrCode = GetLastError();


    //
    // Detemerine the correct amount of debug output
    //

    switch (LOWORD(dwDebugLevel)) {

        case DL_VERBOSE:
            bOutput = TRUE;
            break;

        case DL_NORMAL:

            //
            // Normal debug output.  Don't
            // display verbose stuff, but
            // do display warnings/asserts.
            //

            if (mask != DM_VERBOSE) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;

        case DL_NONE:
        default:

            //
            // Only display asserts
            //

            if (mask == DM_ASSERT) {
                bOutput = TRUE;
            } else {
                bOutput = FALSE;
            }
            break;
    }


    //
    // Display the error message if appropriate
    //

    if (bOutput) {

        //
        // Build the error text prefix and message
        //

        GetLocalTime (&systime);
        (void) StringCchPrintf (szDebugTitle, ARRAYSIZE(szDebugTitle), c_szGPTExt,
                  GetCurrentProcessId(), GetCurrentThreadId(),
                  systime.wHour, systime.wMinute, systime.wSecond,
                  systime.wMilliseconds);

        va_start(marker, pszMsg);
        (void) StringCchVPrintf(szDebugBuffer, ARRAYSIZE(szDebugBuffer), pszMsg, marker);
        va_end(marker);


        //
        // Print to the debugger if appropriate
        //

        if (dwDebugLevel & DL_DEBUGGER) {
            OutputDebugString(szDebugTitle);
            OutputDebugString(szDebugBuffer);
            OutputDebugString(c_szCRLF);
        }


        //
        // Add to the log file if appropriate
        //

        if (dwDebugLevel & DL_LOGFILE) {
            HANDLE hFile;
            DWORD dwBytesWritten;
            TCHAR szExpLogFileName[MAX_PATH+1];

            ExpandEnvironmentStrings (szLogFileName, szExpLogFileName, ARRAYSIZE(szExpLogFileName));

            hFile = CreateFile(szExpLogFileName,
                               FILE_WRITE_DATA | FILE_APPEND_DATA,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hFile != INVALID_HANDLE_VALUE) {

                if (SetFilePointer (hFile, 0, NULL, FILE_END) != 0xFFFFFFFF) {

                    WriteFile (hFile, (LPCVOID) szDebugTitle,
                               lstrlen (szDebugTitle) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) szDebugBuffer,
                               lstrlen (szDebugBuffer) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);

                    WriteFile (hFile, (LPCVOID) c_szCRLF,
                               lstrlen (c_szCRLF) * sizeof(TCHAR),
                               &dwBytesWritten,
                               NULL);
                }

                CloseHandle (hFile);
            }
        }
    }


    //
    // Restore the last error code
    //

    SetLastError(dwErrCode);


    //
    // Break to the debugger if appropriate
    //

    if (mask == DM_ASSERT) {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gpedit\util.cpp ===
#include "main.h"
#include <schemamanager.h>
#include "rsoputil.h"
#include <initguid.h>
#include "sddl.h"
#define  PCOMMON_IMPL
#include "pcommon.h"
#include <adsopenflags.h>

typedef struct _GPOERRORINFO
{
    DWORD   dwError;
    LPTSTR  lpMsg;
} GPOERRORINFO, *LPGPOERRORINFO;

typedef struct _DCOPTION
{
    LPTSTR  lpDomainName;
    INT     iOption;
    struct _DCOPTION *pNext;
} DCOPTION, *LPDCOPTION;

LPDCOPTION g_DCInfo = NULL;

//
// Help ids
//

DWORD aErrorHelpIds[] =
{

    0, 0
};

DWORD aNoDCHelpIds[] =
{
    IDC_NODC_PDC,                 IDH_DC_PDC,
    IDC_NODC_INHERIT,             IDH_DC_INHERIT,
    IDC_NODC_ANYDC,               IDH_DC_ANYDC,

    0, 0
};

DEFINE_GUID(CLSID_WMIFilterManager,0xD86A8E9B,0xF53F,0x45AD,0x8C,0x49,0x0A,0x0A,0x52,0x30,0xDE,0x28);
DEFINE_GUID(IID_IWMIFilterManager,0x64DCCA00,0x14A6,0x473C,0x90,0x06,0x5A,0xB7,0x9D,0xC6,0x84,0x91);



//*************************************************************
//
//  SetWaitCursor()
//
//  Purpose:    Sets the wait cursor
//
//  Parameters: none
//
//
//  Return:     void
//
//*************************************************************
void SetWaitCursor (void)
{
    SetCursor (LoadCursor(NULL, IDC_WAIT));
}

//*************************************************************
//
//  ClearWaitCursor()
//
//  Purpose:    Resets the wait cursor
//
//  Parameters: none
//
//
//  Return:     void
//
//*************************************************************
void ClearWaitCursor (void)
{
    SetCursor (LoadCursor(NULL, IDC_ARROW));
}

//*************************************************************
//
//  CheckSlash()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//
//  Return:     Pointer to the end of the string
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericflo    Created
//
//*************************************************************
LPTSTR CheckSlash (LPTSTR lpDir)
{
    LPTSTR lpEnd;

    lpEnd = lpDir + lstrlen(lpDir);

    if (*(lpEnd - 1) != TEXT('\\')) {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return lpEnd;
}

//*************************************************************
//
//  CreateNestedDirectory()
//
//  Purpose:    Creates a subdirectory and all it's parents
//              if necessary.
//
//  Parameters: lpDirectory -   Directory name
//              lpSecurityAttributes    -   Security Attributes
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/08/95     ericflo    Created
//
//*************************************************************

UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    TCHAR* szDirectory;
    LPTSTR lpEnd;
    UINT   uStatus;

    szDirectory = NULL;
        
    //
    // Note that this function seems to return 0, 1, and ERROR_ALREADY_EXISTS
    // 0 is for failure, 1 is for success, and ERROR_ALREADY_EXISTS is for the
    // case that the directory already exists.  We should probably just return 
    // the success code in that case and have an extra parameter for disposition
    // or use last error, but current code seems to expect this strange behavior
    //
    // We initialize to the failure value below
    //

    uStatus = 0;

    //
    // Check for NULL pointer
    //

    if (!lpDirectory || !(*lpDirectory)) {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Received a NULL pointer.")));
        goto CreateNestedDirectory_Exit;
    }


    //
    // First, see if we can create the directory without having
    // to build parent directories.
    //

    if (CreateDirectory (lpDirectory, lpSecurityAttributes)) {
        uStatus = 1;
        goto CreateNestedDirectory_Exit;
    }

    //
    // If this directory exists already, this is OK too.
    //

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        uStatus = ERROR_ALREADY_EXISTS;
        goto CreateNestedDirectory_Exit;
    }


    //
    // No luck, copy the string to a buffer we can munge
    //

    HRESULT hr;
    ULONG   ulNoChars;

    ulNoChars = lstrlen(lpDirectory) + 1;
    szDirectory = (TCHAR*) LocalAlloc( LPTR, ulNoChars * sizeof(*szDirectory) );

    if ( ! szDirectory )
    {
        DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  Failed to allocate memory.")));
        goto CreateNestedDirectory_Exit;
    }    

    hr = StringCchCopy (szDirectory, ulNoChars, lpDirectory);
    ASSERT(SUCCEEDED(hr));

    //
    // Find the first subdirectory name
    //

    lpEnd = szDirectory;

    if (szDirectory[1] == TEXT(':')) {
        lpEnd += 3;
    } else if (szDirectory[1] == TEXT('\\')) {

        //
        // Skip the first two slashes
        //

        lpEnd += 2;

        //
        // Find the slash between the server name and
        // the share name.
        //

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            goto CreateNestedDirectory_Exit;
        }

        //
        // Skip the slash, and find the slash between
        // the share name and the directory name.
        //

        lpEnd++;

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (!(*lpEnd)) {
            goto CreateNestedDirectory_Exit;
        }

        //
        // Leave pointer at the beginning of the directory.
        //

        lpEnd++;


    } else if (szDirectory[0] == TEXT('\\')) {
        lpEnd++;
    }

    while (*lpEnd) {

        while (*lpEnd && *lpEnd != TEXT('\\')) {
            lpEnd++;
        }

        if (*lpEnd == TEXT('\\')) {
            *lpEnd = TEXT('\0');

            if (!CreateDirectory (szDirectory, NULL)) {

                if (GetLastError() != ERROR_ALREADY_EXISTS) {
                    DebugMsg((DM_WARNING, TEXT("CreateNestedDirectory:  CreateDirectory failed for %s with %d."),
                            szDirectory, GetLastError()));
                    goto CreateNestedDirectory_Exit;
                }
            }

            *lpEnd = TEXT('\\');
            lpEnd++;
        }
    }


    //
    // Create the final directory
    //

    if (CreateDirectory (szDirectory, lpSecurityAttributes)) {
        uStatus = 1;
        goto CreateNestedDirectory_Exit;
    }

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        uStatus = ERROR_ALREADY_EXISTS;
    }


    //
    // Failed
    //

    DebugMsg((DM_VERBOSE, TEXT("CreateNestedDirectory:  Failed to create the directory with error %d."), GetLastError()));

 CreateNestedDirectory_Exit:

    if ( szDirectory )
    {
        LocalFree( szDirectory );
    }

    return uStatus;
}

VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize)
{
    HINSTANCE hInstActiveDS;
    HINSTANCE hInstWMI;


    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, dwID,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  lpBuffer, dwSize, NULL))
    {
        hInstActiveDS = LoadLibrary (TEXT("activeds.dll"));

        if (hInstActiveDS)
        {
            if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                          hInstActiveDS, dwID,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                          lpBuffer, dwSize, NULL))
            {
                hInstWMI = LoadLibrary (TEXT("wmiutils.dll"));

                if (hInstWMI)
                {

                    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                                  hInstWMI, dwID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                  lpBuffer, dwSize, NULL))
                    {
                        DebugMsg((DM_WARNING, TEXT("LoadMessage: Failed to query error message text for %d due to error %d"),
                                 dwID, GetLastError()));
                        (void) StringCchPrintf (lpBuffer, dwSize, TEXT("%d (0x%x)"), dwID, dwID);
                    }

                    FreeLibrary (hInstWMI);
                }
            }

            FreeLibrary (hInstActiveDS);
        }
    }
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for errors
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK ErrorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szError[MAX_PATH];
            LPGPOERRORINFO lpEI = (LPGPOERRORINFO) lParam;
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_WARNING);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_ERROR_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            SetDlgItemText (hDlg, IDC_ERRORTEXT, lpEI->lpMsg);

            szError[0] = TEXT('\0');
            if (lpEI->dwError)
            {
                LoadMessage (lpEI->dwError, szError, ARRAYSIZE(szError));
            }

            if (szError[0] == TEXT('\0'))
            {
                LoadString (g_hInstance, IDS_NONE, szError, ARRAYSIZE(szError));
            }

            SetDlgItemText (hDlg, IDC_DETAILSTEXT, szError);

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCLOSE || LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user
//
//  Parameters: hParent     -   Parent window handle
//              dwError     -   Error number
//              idMsg       -   Error message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ReportError (HWND hParent, DWORD dwError, UINT idMsg, ...)
{
    GPOERRORINFO ei;
    TCHAR szMsg[2*MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    va_list marker;


    //
    // Load the error message
    //

    if (!LoadString (g_hInstance, idMsg, szMsg, 2*MAX_PATH))
    {
        return FALSE;
    }


    //
    // Special case access denied errors with a custom message
    //

    if ((dwError == ERROR_ACCESS_DENIED) || (dwError == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)))
    {
        if ((idMsg != IDS_EXECFAILED_USER) && (idMsg != IDS_EXECFAILED_COMPUTER) &&
            (idMsg != IDS_EXECFAILED) && (idMsg != IDS_EXECFAILED_BOTH))
        {
            if (!LoadString (g_hInstance, IDS_ACCESSDENIED, szMsg, 2*MAX_PATH))
            {
                return FALSE;
            }
        }
    }
    else if ( dwError == WBEM_E_INVALID_NAMESPACE )
    {
        if (!LoadString (g_hInstance, IDS_INVALID_NAMESPACE, szMsg, 2*MAX_PATH))
        {
            return FALSE;
        }
    }

    //
    // Plug in the arguments
    //

    va_start(marker, idMsg);
    wvnsprintf(szErrorMsg, sizeof(szErrorMsg) / sizeof(TCHAR) - 1, szMsg, marker);
    va_end(marker);


    //
    // Display the message
    //

    ei.dwError = dwError;
    ei.lpMsg   = szErrorMsg;

    DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_ERROR), hParent,
                    ErrorDlgProc, (LPARAM) &ei);

    return TRUE;
}

//*************************************************************
//
//  Delnode_Recurse()
//
//  Purpose:    Recursive delete function for Delnode
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              8/10/95     ericflo    Created
//
//*************************************************************

BOOL Delnode_Recurse (LPTSTR lpDir)
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Entering, lpDir = <%s>"), lpDir));


    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        DebugMsg((DM_WARNING, TEXT("Delnode_Recurse:  Failed to set current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(TEXT("*.*"), &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: FindFirstFile failed.  Error = %d"),
                     GetLastError()));
            return FALSE;
        }
    }


    do {
        //
        //  Verbose output
        //

        DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: FindFile found:  <%s>"),
                 fd.cFileName));

        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, TEXT("."))) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            if (!RemoveDirectory (fd.cFileName)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete directory <%s>.  Error = %d"),
                        fd.cFileName, GetLastError()));
            }

        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            if (!DeleteFile (fd.cFileName)) {
                DebugMsg((DM_WARNING, TEXT("Delnode_Recurse: Failed to delete <%s>.  Error = %d"),
                        fd.cFileName, GetLastError()));
            }

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (TEXT(".."))) {
        DebugMsg((DM_WARNING, TEXT("Delnode_Recurse:  Failed to reset current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }


    //
    // Success.
    //

    DebugMsg((DM_VERBOSE, TEXT("Delnode_Recurse: Leaving <%s>"), lpDir));

    return TRUE;
}


//*************************************************************
//
//  Delnode()
//
//  Purpose:    Recursive function that deletes files and
//              directories.
//
//  Parameters: lpDir   -   Directory
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/23/95     ericflo    Created
//
//*************************************************************

BOOL Delnode (LPTSTR lpDir)
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(MAX_PATH, szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            DebugMsg((DM_VERBOSE, TEXT("Delnode: Failed to delete directory <%s>.  Error = %d"),
                    lpDir, GetLastError()));
            return FALSE;
        }


    } else {

        DebugMsg((DM_WARNING, TEXT("Delnode:  Failed to get current working directory.  Error = %d"), GetLastError()));
        return FALSE;
    }

    return TRUE;

}

/*******************************************************************

        NAME:           StringToNum

        SYNOPSIS:       Converts string value to numeric value

        NOTES:          Calls atoi() to do conversion, but first checks
                                for non-numeric characters

        EXIT:           Returns TRUE if successful, FALSE if invalid
                                (non-numeric) characters

********************************************************************/
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal)
{
        TCHAR *pTst = pszStr;

        if (!pszStr) return FALSE;

        // verify that all characters are numbers
        while (*pTst)
        {
            if (!(*pTst >= TEXT('0') && *pTst <= TEXT('9')))
            {
               if (*pTst != TEXT('-'))
                   return FALSE;
            }
            pTst = CharNext(pTst);
        }

        *pnVal = _ttoi(pszStr);

        return TRUE;
}

//*************************************************************
//
//  DSDelnodeRecurse()
//
//  Purpose:    Delnodes a tree in the DS
//
//  Parameters: pADsContainer - IADSContainer interface
//
//  Return:     S_OK if successful
//
//*************************************************************

HRESULT DSDelnodeRecurse (IADsContainer * pADsContainer)
{
    HRESULT hr;
    BSTR bstrRelativeName;
    BSTR bstrClassName;
    IEnumVARIANT *pVar = NULL;
    IADsContainer * pADsChild = NULL;
    IADs * pDSObject = NULL;
    IDispatch * pDispatch;
    VARIANT var;
    ULONG ulResult;



    //
    // Enumerate the children and delete them first
    //

    hr = ADsBuildEnumerator (pADsContainer, &pVar);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse: Failed to get enumerator with 0x%x"), hr));
        goto Exit;
    }


    while (TRUE)
    {

        VariantInit(&var);
        hr = ADsEnumerateNext(pVar, 1, &var, &ulResult);

        if (FAILED(hr))
        {
            DebugMsg((DM_VERBOSE, TEXT("DSDelnodeRecurse: Failed to enumerator with 0x%x"), hr));
            VariantClear (&var);
            break;
        }


        if (S_FALSE == hr)
        {
            VariantClear (&var);
            break;
        }


        //
        // If var.vt isn't VT_DISPATCH, we're finished.
        //

        if (var.vt != VT_DISPATCH)
        {
            VariantClear (&var);
            break;
        }


        //
        // We found something, get the IDispatch interface
        //

        pDispatch = var.pdispVal;

        if (!pDispatch)
        {
            VariantClear (&var);
            goto Exit;
        }


        //
        // Now query for the IADsContainer interface so we can recurse
        // if necessary.  Note it is ok if this fails because not
        // everything is a container.
        //

        hr = pDispatch->QueryInterface(IID_IADsContainer, (LPVOID *)&pADsChild);

        if (SUCCEEDED(hr)) {

            hr = DSDelnodeRecurse (pADsChild);

            if (FAILED(hr)) {
                goto Exit;
            }

            pADsChild->Release();
        }


        //
        // Now query for the IADs interface so we can get some
        // properties from this object
        //

        hr = pDispatch->QueryInterface(IID_IADs, (LPVOID *)&pDSObject);

        if (FAILED(hr)) {
            DebugMsg((DM_WARNING, TEXT("AddGPOsForDomain: QI for IADs failed with 0x%x"), hr));
            VariantClear (&var);
            goto Exit;
        }


        //
        // Get the relative and class names
        //

        hr = pDSObject->get_Name (&bstrRelativeName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get relative name with 0x%x"), hr));
            pDSObject->Release();
            VariantClear (&var);
            goto Exit;
        }

        hr = pDSObject->get_Class (&bstrClassName);
        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed get class name with 0x%x"), hr));
            SysFreeString (bstrRelativeName);
            pDSObject->Release();
            VariantClear (&var);
            goto Exit;
        }


        pDSObject->Release();


        //
        // Delete the object
        //

        hr = pADsContainer->Delete (bstrClassName,
                                    bstrRelativeName);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("DSDelnodeRecurse:  Failed to delete object with 0x%x"), hr));
            SysFreeString (bstrRelativeName);
            SysFreeString (bstrClassName);
            VariantClear (&var);
            goto Exit;
        }


        SysFreeString (bstrRelativeName);
        SysFreeString (bstrClassName);

        VariantClear (&var);
    }

Exit:

    if (pVar)
    {
        ADsFreeEnumerator (pVar);
    }

    return hr;
}

//*************************************************************
//
//  DSDelnodeRecurse()
//
//  Purpose:    Delnodes a tree in the DS
//
//  Parameters: lpDSPath  - Path of DS object to delete
//
//  Return:     S_OK if successful
//
//*************************************************************

HRESULT DSDelnode (LPTSTR lpDSPath)
{
    HRESULT hr;
    BSTR bstrParent = NULL;
    BSTR bstrRelativeName = NULL;
    BSTR bstrClassName = NULL;
    IADsContainer * pADsContainer = NULL;
    IADs * pDSObject = NULL;
    VARIANT var;
    ULONG ulResult;



    //
    // Enumerate the children and delete them first
    //

    hr = OpenDSObject(lpDSPath, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to get gpo container interface with 0x%x"), hr));
        goto Exit;
    }


    hr = DSDelnodeRecurse (pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to delete children with 0x%x"), hr));
        goto Exit;
    }


    pADsContainer->Release();
    pADsContainer = NULL;


    //
    // Bind to the object
    //

    hr = OpenDSObject (lpDSPath, IID_IADs, (void **)&pDSObject);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed bind to the object %s with 0x%x"),
                 lpDSPath, hr));
        goto Exit;
    }


    //
    // Get the parent's name
    //

    hr = pDSObject->get_Parent (&bstrParent);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get parent's name with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get this object's relative and class names
    //

    hr = pDSObject->get_Name (&bstrRelativeName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get relative name with 0x%x"), hr));
        goto Exit;
    }


    hr = pDSObject->get_Class (&bstrClassName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed get class name with 0x%x"), hr));
        goto Exit;
    }


    pDSObject->Release();
    pDSObject = NULL;


    //
    // Bind to the parent object
    //

    hr = OpenDSObject(bstrParent, IID_IADsContainer, (void **)&pADsContainer);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("DSDelnode: Failed to get parent container interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Delete the object
    //

    hr = pADsContainer->Delete (bstrClassName,
                                bstrRelativeName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("DSDelnode:  Failed to delete object with 0x%x"), hr));
        goto Exit;
    }



Exit:

    if (pADsContainer)
    {
        pADsContainer->Release();
    }

    if (pDSObject)
    {
        pDSObject->Release();
    }

    if (bstrParent)
    {
        SysFreeString (bstrParent);
    }

    if (bstrRelativeName)
    {
        SysFreeString (bstrRelativeName);
    }

    if (bstrClassName)
    {
        SysFreeString (bstrClassName);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   CreateGPOLink
//
//  Synopsis:   Creates a GPO link for a domain, site or OU
//
//  Arguments:  [lpGPO]         - LDAP path to the GPO
//              [lpContainer]   - LDAP path to the container object
//              [fHighPriority] - FALSE (default) - adds GPO to the bottom
//                                                  of the prioritized list
//                                TRUE - adds GPO to the top of the list
//
//  Returns:    S_OK on success
//
//  History:    5-08-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT CreateGPOLink(LPOLESTR lpGPO, LPOLESTR lpContainer, BOOL fHighPriority)
{
    IADs * pADs = NULL;
    LPTSTR lpNamelessGPO;
    HRESULT hr;

    lpNamelessGPO = MakeNamelessPath (lpGPO);

    if (lpNamelessGPO)
    {
        hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

        if (SUCCEEDED(hr))
        {
            VARIANT var;
            BSTR bstr = NULL;
            ULONG ulNoChars = 1 + wcslen(lpNamelessGPO) + 3 + 1;
            LPOLESTR szLink = new OLECHAR[ulNoChars];
            if (szLink)
            {
                hr = StringCchCopy(szLink, ulNoChars, L"[");
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat(szLink, ulNoChars, lpNamelessGPO);
                }
                if (SUCCEEDED(hr)) 
                {
                    hr = StringCchCat(szLink, ulNoChars, L";0]");
                }
                if (SUCCEEDED(hr)) 
                {
                    VariantInit(&var);
                    bstr = SysAllocString(GPM_LINK_PROPERTY);

                    if (bstr)
                    {
                        hr = pADs->Get(bstr, &var);

                        if (SUCCEEDED(hr))
                        {
                            ulNoChars = wcslen(var.bstrVal) + wcslen(szLink) + 1;
                            LPOLESTR szTemp = new OLECHAR[ulNoChars];
                            if (szTemp)
                            {
                                if (fHighPriority)
                                {
                                    // Highest priority is at the END of the list

                                    hr = StringCchCopy(szTemp, ulNoChars, var.bstrVal);
                                    ASSERT(SUCCEEDED(hr));

                                    hr = StringCchCat(szTemp, ulNoChars, szLink);
                                    ASSERT(SUCCEEDED(hr));
                                }
                                else
                                {
                                    hr = StringCchCopy(szTemp, ulNoChars, szLink);
                                    ASSERT(SUCCEEDED(hr));

                                    hr = StringCchCat(szTemp, ulNoChars, var.bstrVal);
                                    ASSERT(SUCCEEDED(hr));
                                }
                                delete [] szLink;
                                szLink = szTemp;
                            }
                            else
                            {
                                hr = ERROR_OUTOFMEMORY;
                                goto Cleanup;
                            }
                        }
                        else
                        {
                            if (hr != E_ADS_PROPERTY_NOT_FOUND)
                            {
                                goto Cleanup;
                            }
                        }
                    }
                    else
                    {
                        hr = ERROR_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    VariantClear(&var);

                    VariantInit(&var);
                    var.vt = VT_BSTR;
                    var.bstrVal = SysAllocString(szLink);

                    if (var.bstrVal)
                    {
                        hr = pADs->Put(bstr, var);

                        if (SUCCEEDED(hr))
                        {
                            hr = pADs->SetInfo();
                        }
                    }
                    else
                    {
                        hr = ERROR_OUTOFMEMORY;
                    }

                    Cleanup:
                        VariantClear(&var);
                    if (bstr)
                    {
                        SysFreeString(bstr);
                    }
                }

                delete [] szLink;
            }
            else
                hr = ERROR_OUTOFMEMORY;
            pADs->Release();
        }
   
        LocalFree (lpNamelessGPO);
    }
    else
    {
        hr = ERROR_OUTOFMEMORY;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteAllGPOLinks
//
//  Synopsis:   Deletes all GPO links for a domain, OU or site
//
//  Arguments:  [lpContainer] - LDAP to the container object
//
//  Returns:    S_OK on success
//
//  History:    5-08-1998   stevebl   Created
//
//---------------------------------------------------------------------------

HRESULT DeleteAllGPOLinks(LPOLESTR lpContainer)
{
    IADs * pADs = NULL;

    HRESULT hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        BSTR bstr;

        bstr = SysAllocString(GPM_LINK_PROPERTY);

        if (bstr)
        {
            VariantInit(&var);
            var.vt = VT_BSTR;
            var.bstrVal = SysAllocString(L" ");

            if (var.bstrVal)
            {
                hr = pADs->Put(bstr, var);

                if (SUCCEEDED(hr))
                {
                    pADs->SetInfo();
                }
            }
            else
            {
                hr = ERROR_OUTOFMEMORY;
            }

            VariantClear(&var);
            SysFreeString(bstr);
        }
        else
        {
            hr = ERROR_OUTOFMEMORY;
        }

        pADs->Release();
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   DeleteGPOLink
//
//  Synopsis:   Deletes a GPO link from a domain, OU or site
//              (if there is one).
//
//  Arguments:  [lpGPO]       - LDAP to the GPO
//              [lpContainer] - LDAP to the container object
//
//  Returns:    S_OK - success
//
//  History:    5-08-1998   stevebl   Created
//
//  Notes:      If a GPO is linked more than once, this will remove
//              only the first link.
//
//              If a GPO is NOT linked with this object, then this
//              routine will still return S_OK.
//
//---------------------------------------------------------------------------

HRESULT DeleteGPOLink(LPOLESTR lpGPO, LPOLESTR lpContainer)
{
    IADs * pADs = NULL;

    HRESULT hr = OpenDSObject(lpContainer, IID_IADs, (void **)&pADs);

    if (SUCCEEDED(hr))
    {
        VARIANT var;
        BSTR bstr;
        ULONG ulNoChars;

        // Build the substring to look for.
        // This is the first part of the link, the link ends with ]
        ulNoChars = 1 + wcslen(lpGPO) + 1;
        LPOLESTR szLink = new OLECHAR[ulNoChars];
        if (szLink)
        {
            hr = StringCchCopy(szLink, ulNoChars, L"[");
            ASSERT(SUCCEEDED(hr));

            hr = StringCchCat(szLink, ulNoChars, lpGPO);
            ASSERT(SUCCEEDED(hr));

            bstr = SysAllocString(GPM_LINK_PROPERTY);

            if (bstr)
            {
                VariantInit(&var);

                hr = pADs->Get(bstr, &var);

                if (SUCCEEDED(hr))
                {
                    // find the link and remove it
                    ulNoChars = wcslen(var.bstrVal)+1;
                    LPOLESTR sz = new OLECHAR[ulNoChars];

                    if (sz)
                    {
                        hr = StringCchCopy(sz, ulNoChars, var.bstrVal);
                        ASSERT(SUCCEEDED(hr));

                        OLECHAR * pch = wcsstr(sz, szLink);
                        if (pch)
                        {
                            OLECHAR * pchEnd = pch;

                            // look for the ']'
                            while (*pchEnd && (*pchEnd != L']'))
                                pchEnd++;

                            // skip it
                            if (*pchEnd)
                                pchEnd++;

                            // copy over the rest of the string
                            while (*pchEnd)
                                *pch++ = *pchEnd++;

                            *pch = L'\0';

                            VariantClear(&var);

                            VariantInit(&var);
                            var.vt = VT_BSTR;
                            if (wcslen(sz))
                            {
                                var.bstrVal = SysAllocString(sz);
                            }
                            else
                            {
                                // Put will gag if this is an empty string
                                // so we need to put a space here if we've
                                // deleted all the entries.
                                var.bstrVal = SysAllocString(L" ");
                            }

                            if (var.bstrVal)
                            {
                                // set the link property again

                                hr = pADs->Put(bstr, var);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pADs->SetInfo();
                                }
                            }
                            else
                            {
                                hr = ERROR_OUTOFMEMORY;
                            }
                        }

                        delete [] sz;

                    }
                    else
                    {
                        hr = ERROR_OUTOFMEMORY;
                    }
                }

                VariantClear(&var);
                SysFreeString(bstr);
            }
            else
            {
                hr = ERROR_OUTOFMEMORY;
            }
            delete [] szLink;
        }
        else
            hr = ERROR_OUTOFMEMORY;
        pADs->Release();
    }
    return hr;
}

//*************************************************************
//
//  CreateSecureDirectory()
//
//  Purpose:    Creates a secure directory that only domain admins
//              and the OS have read / write access.  Everyone else has
//              read access only.
//
//  Parameters: lpDirectory  -   Directory name
//
//  Return:     > 0 if successful
//              0 if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/28/98     ericflo    Created
//
//*************************************************************

UINT CreateSecureDirectory (LPTSTR lpDirectory)
{
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidSystem = NULL, psidAdmin = NULL, psidAuthUsers = NULL;
    DWORD cbAcl, aceIndex;
    ACE_HEADER * lpAceHeader;
    UINT uRet = 0;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize system sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the Admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize admin sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Get the authenticated users sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidAuthUsers)) {

         DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize world sid.  Error = %d"), GetLastError()));
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidAuthUsers)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));



    pAcl = (PACL) GlobalAlloc(GMEM_FIXED, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize acl.  Error = %d"), GetLastError()));
        goto Exit;
    }



    //
    // Add Aces.  Non-inheritable ACEs first
    //

    aceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidAuthUsers)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }



    //
    // Now the inheritable ACEs
    //

    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    aceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_READ | GENERIC_EXECUTE, psidAuthUsers)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to add ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    if (!GetAce(pAcl, aceIndex, (LPVOID *)&lpAceHeader)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to get ace (%d).  Error = %d"), aceIndex, GetLastError()));
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to initialize security descriptor.  Error = %d"), GetLastError()));
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        DebugMsg((DM_WARNING, TEXT("CreateSecureDirectory: Failed to set security descriptor dacl.  Error = %d"), GetLastError()));
        goto Exit;
    }

    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Attempt to create the directory
    //

    uRet = CreateNestedDirectory(lpDirectory, &sa);
    if ( uRet ) {
        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Created the directory <%s>"), lpDirectory));

    } else {

        DebugMsg((DM_VERBOSE, TEXT("CreateSecureDirectory: Failed to created the directory <%s>"), lpDirectory));
    }



Exit:

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }


    if (psidAuthUsers) {
        FreeSid(psidAuthUsers);
    }


    if (pAcl) {
        GlobalFree (pAcl);
    }

    return uRet;
}

//*************************************************************
//
//  ConvertToDotStyle()
//
//  Purpose:    Converts an LDAP path to a DN path
//
//  Parameters: lpName   - LDAP name
//              lpResult - pointer to a buffer with the DN name
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT ConvertToDotStyle (LPOLESTR lpName, LPOLESTR *lpResult)
{
    LPTSTR lpNewName;
    LPTSTR lpSrc, lpDest;
    TCHAR lpProvider[] = TEXT("LDAP://");
    DWORD dwStrLen = lstrlen (lpProvider);


    lpNewName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpName) + 1) * sizeof(TCHAR));

    if (!lpNewName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertToDotStyle: Failed to allocate memory with 0x%x"),
                 GetLastError()));
        return E_FAIL;
    }


    lpSrc = lpName;
    lpDest = lpNewName;
    LPTSTR lpStopChecking = (lstrlen(lpSrc) - 2) + lpSrc;

    //
    // Skip the LDAP:// if found
    //

    if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                       lpProvider, dwStrLen, lpSrc, dwStrLen) == CSTR_EQUAL)
    {
        lpSrc += dwStrLen;
    }

    //
    // Parse through the name replacing all the XX= with .
    // Skip server name (if any)
    //

    BOOL fMightFindServer = TRUE;

    while (*lpSrc)
    {
        if (lpSrc < lpStopChecking)
        {
            if (*(lpSrc+2) == TEXT('='))
            {
                lpSrc += 3;
                // no need to look for a server name any more because we've found an XX= string
                fMightFindServer = FALSE;
            }
        }

        while (*lpSrc && (*lpSrc != TEXT(',')))
        {
            *lpDest++ = *lpSrc++;
            if (fMightFindServer && TEXT('/') == *(lpSrc-1))
            {
                // Found a server name
                // reset lpDest so the rest gets put in the front of the buffer (leaving off the server name)
                lpDest = lpNewName;
                break;
            }
        }
        fMightFindServer = FALSE; // don't check any more

        if (*lpSrc == TEXT(','))
        {
            *lpDest++ = TEXT('.');
            lpSrc++;
        }
    }

    *lpDest = 0;

    *lpResult = lpNewName;

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetDomainFromLDAPPath
//
//  Synopsis:   returns a freshly allocated string containing the LDAP path
//              to the domain name contained with an arbitrary LDAP path.
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     5-06-1998   stevebl   Created
//              10-20-1998   stevebl   modified to preserve server names
//
//  Notes:      This routine works by repeatedly removing leaf elements from
//              the LDAP path until an element with the "DC=" prefix is
//              found, indicating that a domain name has been located.  If a
//              path is given that is not rooted in a domain (is that even
//              possible?) then NULL would be returned.
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//---------------------------------------------------------------------------

LPOLESTR GetDomainFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        BSTR bstrIn = SysAllocString( szIn );
        if ( bstrIn != NULL )
        {
            hr = pADsPathname->Set(bstrIn, ADS_SETTYPE_FULL);
            if (SUCCEEDED(hr))
            {
                BSTR bstr;
                BOOL fStop = FALSE;

                while (!fStop)
                {
                    hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
                    if (SUCCEEDED(hr))
                    {
                        // keep peeling them off until we find something
                        // that is a domain name
                        fStop = (0 == _wcsnicmp(L"DC=", bstr, 3));
                        SysFreeString(bstr);
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
                    }

                    if (!fStop)
                    {
                        hr = pADsPathname->RemoveLeafElement();
                        if (FAILED(hr))
                        {
                            DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to remove leaf with 0x%x."), hr));
                            fStop = TRUE;
                        }
                    }
                }

                hr = pADsPathname->Retrieve(ADS_FORMAT_X500, &bstr);
                if (SUCCEEDED(hr))
                {
                    ULONG ulNoChars = wcslen(bstr)+1; 
                    sz = new OLECHAR[ulNoChars];
                    if (sz)
                    {
                        hr = StringCchCopy(sz, ulNoChars, bstr);
                        ASSERT(SUCCEEDED(hr));
                    }
                    SysFreeString(bstr);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to retrieve full path with 0x%x."), hr));
                }
            }            
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to set pathname with 0x%x."), hr));
            }

            SysFreeString( bstrIn );
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to allocate BSTR memory.")));
        }

        pADsPathname->Release();
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}


//+--------------------------------------------------------------------------
//
//  Function:   GetContainerFromLDAPPath
//
//  Synopsis:   returns a the container name from an LDAP path
//
//  Arguments:  [szIn] - LDAP path to the initial object
//
//  Returns:    NULL - if no domain could be found or if OOM
//
//  History:     3-17-2000   ericflo   Created
//
//              The caller must free this path using the standard c++ delete
//              operation. (I/E this isn't an exportable function.)
//
//---------------------------------------------------------------------------

LPOLESTR GetContainerFromLDAPPath(LPOLESTR szIn)
{
    LPOLESTR sz = NULL;
    IADsPathname * pADsPathname = NULL;
    HRESULT hr = CoCreateInstance(CLSID_Pathname,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IADsPathname,
                          (LPVOID*)&pADsPathname);

    if (SUCCEEDED(hr))
    {
        BSTR bstrIn = SysAllocString( szIn );
        if ( bstrIn != NULL )
        {
            hr = pADsPathname->put_EscapedMode(ADS_ESCAPEDMODE_OFF);
            if (SUCCEEDED(hr)) 
            {
                hr = pADsPathname->Set(bstrIn, ADS_SETTYPE_DN);

                if (SUCCEEDED(hr))
                {
                    hr = pADsPathname->put_EscapedMode(ADS_ESCAPEDMODE_OFF_EX);
                    if (SUCCEEDED(hr)) 
                    {
                        BSTR bstr;
                        BOOL fStop = FALSE;

                        hr = pADsPathname->Retrieve(ADS_FORMAT_LEAF, &bstr);
                        if (SUCCEEDED(hr))
                        {
                            ULONG ulNoChars = wcslen(bstr)+1; 

                            sz = new OLECHAR[ulNoChars];
                            if (sz)
                            {
                                hr = StringCchCopy(sz, ulNoChars, (bstr+3));
                                if (FAILED(hr)) 
                                {
                                    DebugMsg((DM_WARNING, TEXT("GetDomainFromLDAPPath: Failed to copy leaf name with 0x%x."), hr));
                                    delete [] sz;
                                    sz = NULL;
                                }
                            }
                            SysFreeString(bstr);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to retrieve leaf with 0x%x."), hr));
                        }
                    }
                    else
                    {
                        DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to put escape mode with 0x%x."), hr));
                    }                
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to set pathname with 0x%x."), hr));
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to put escape mode with 0x%x."), hr));
            }

            SysFreeString( bstrIn );
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to allocate BSTR memory.")));
        }

        pADsPathname->Release();
    }
    else
    {
         DebugMsg((DM_WARNING, TEXT("GetContainerFromLDAPPath: Failed to CoCreateInstance for IID_IADsPathname with 0x%x."), hr));
    }


    return sz;
}

//*************************************************************
//
//  DCDlgProc()
//
//  Purpose:    Dialog box procedure for DC selection
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK DCDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szTitle[100];
            TCHAR szBuffer[350];
            LPDCSELINFO lpSelInfo = (LPDCSELINFO) lParam;
            HICON hIcon;


            if (lpSelInfo->bError)
            {
                hIcon = LoadIcon (NULL, IDI_ERROR);

                if (hIcon)
                {
                    SendDlgItemMessage (hDlg, IDC_NODC_ERROR, STM_SETICON, (WPARAM)hIcon, 0);
                }

                LoadString (g_hInstance, IDS_NODC_ERROR_TEXT, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_NODC_TEXT, szBuffer);

                LoadString (g_hInstance, IDS_NODC_ERROR_TITLE, szTitle, ARRAYSIZE(szTitle));

                (void) StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), szTitle, lpSelInfo->lpDomainName);
                SetWindowText (hDlg, szBuffer);

            }
            else
            {
                LoadString (g_hInstance, IDS_NODC_OPTIONS_TEXT, szBuffer, ARRAYSIZE(szBuffer));
                SetDlgItemText (hDlg, IDC_NODC_TEXT, szBuffer);

                LoadString (g_hInstance, IDS_NODC_OPTIONS_TITLE, szBuffer, ARRAYSIZE(szBuffer));
                SetWindowText (hDlg, szBuffer);
            }

            if (!lpSelInfo->bAllowInherit)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_NODC_INHERIT), FALSE);
            }

            if (lpSelInfo->iDefault == 2)
            {
                if (lpSelInfo->bAllowInherit)
                {
                    CheckDlgButton (hDlg, IDC_NODC_INHERIT, BST_CHECKED);
                }
                else
                {
                    CheckDlgButton (hDlg, IDC_NODC_PDC, BST_CHECKED);
                }
            }
            else if (lpSelInfo->iDefault == 3)
            {
                CheckDlgButton (hDlg, IDC_NODC_ANYDC, BST_CHECKED);
            }
            else
            {
                CheckDlgButton (hDlg, IDC_NODC_PDC, BST_CHECKED);
            }

            return TRUE;
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                if (IsDlgButtonChecked (hDlg, IDC_NODC_PDC) == BST_CHECKED)
                {
                    EndDialog(hDlg, 1);
                }
                else if (IsDlgButtonChecked (hDlg, IDC_NODC_INHERIT) == BST_CHECKED)
                {
                    EndDialog(hDlg, 2);
                }
                else
                {
                    EndDialog(hDlg, 3);
                }

                return TRUE;
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, 0);
                return TRUE;
            }

            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aNoDCHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aNoDCHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  AddDCSelection()
//
//  Purpose:    Adds a DC selection to the array
//
//  Parameters: lpDomainName - Domain name
//              iOption     - Option
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL AddDCSelection (LPTSTR lpDomainName, INT iOption)
{
    LPDCOPTION lpTemp;
    UINT uiSize;


    //
    // Check to see if we already have an entry first
    //

    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        if (!lstrcmpi(lpDomainName, lpTemp->lpDomainName))
        {
            lpTemp->iOption = iOption;
            LeaveCriticalSection(&g_DCCS);
            return TRUE;
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Add a new entry
    //

    uiSize = sizeof(DCOPTION);
    uiSize += ((lstrlen(lpDomainName) + 1) * sizeof(TCHAR));

    lpTemp = (LPDCOPTION) LocalAlloc (LPTR, uiSize);

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("AddDCSelection: Failed to allocate memory with %d"),
                 GetLastError()));
        LeaveCriticalSection(&g_DCCS);
        return FALSE;
    }

    lpTemp->lpDomainName = (LPTSTR)((LPBYTE) lpTemp + sizeof(DCOPTION));

    HRESULT hr;
    ULONG ulNoChars = (uiSize - sizeof(DCOPTION))/sizeof(WCHAR);

    hr = StringCchCopy(lpTemp->lpDomainName, ulNoChars, lpDomainName);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("AddDCSelection: Failed to copy domain name with %d"), hr));
        LocalFree(lpTemp);
        LeaveCriticalSection(&g_DCCS);
        return FALSE;
    }

    lpTemp->iOption = iOption;


    if (g_DCInfo)
    {
        lpTemp->pNext = g_DCInfo;
        g_DCInfo = lpTemp;
    }
    else
    {
        g_DCInfo = lpTemp;
    }

    LeaveCriticalSection(&g_DCCS);

    return TRUE;
}

//*************************************************************
//
//  FreeDCSelections()
//
//  Purpose:    Frees the cached DC selections
//
//  Parameters: none
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

VOID FreeDCSelections (void)
{
    LPDCOPTION lpTemp, lpNext;

    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        lpNext = lpTemp->pNext;

        LocalFree (lpTemp);

        lpTemp = lpNext;
    }

    g_DCInfo = NULL;

    LeaveCriticalSection(&g_DCCS);
}

//*************************************************************
//
//  CheckForCachedDCSelection()
//
//  Purpose:    Checks if the DC selection for this domain is in
//              the cache
//
//  Parameters: lpDomainName - Domain name
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT CheckForCachedDCSelection (LPTSTR lpDomainName)
{
    INT iResult = 0;
    LPDCOPTION lpTemp;


    EnterCriticalSection(&g_DCCS);

    lpTemp = g_DCInfo;

    while (lpTemp)
    {
        if (!lstrcmpi(lpDomainName, lpTemp->lpDomainName))
        {
            iResult = lpTemp->iOption;
            break;
        }

        lpTemp = lpTemp->pNext;
    }

    LeaveCriticalSection(&g_DCCS);

    return iResult;
}

//*************************************************************
//
//  ValidateInheritServer()
//
//  Purpose:    Tests if the given DC name is in the given domain
//
//  Parameters: lpDomainName  -- Domain name
//              lpDCName      -- Domain controller name
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD ValidateInheritServer (LPTSTR lpDomainName, LPTSTR lpDCName)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;


    dwResult = DsRoleGetPrimaryDomainInformation (lpDCName, DsRolePrimaryDomainInfoBasic,
                                                 (LPBYTE *) &pBasic);

    if (dwResult == ERROR_SUCCESS) {

        if (lstrcmpi(lpDomainName, pBasic->DomainNameDns))
        {
            dwResult = ERROR_NO_SUCH_DOMAIN;

            DebugMsg((DM_VERBOSE, TEXT("ValidateInheritServer: DC %s is not part of domain %s, it is part of %s.  This server will not be used for inheritance."),
                     lpDCName, lpDomainName, pBasic->DomainNameDns));
        }

        DsRoleFreeMemory (pBasic);
    }

    return dwResult;
}

//*************************************************************
//
//  TestDC()
//
//  Purpose:    Tests if a DC is available
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD TestDC (LPTSTR lpDCName)
{
    LPTSTR lpTest;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    BOOL bResult = FALSE;
    HRESULT hr;
    ULONG ulNoChars;

    ulNoChars = lstrlen(lpDCName) + 25;
    lpTest = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpTest)
    {
        DebugMsg((DM_WARNING, TEXT("TestDC: Failed to allocate memory with %d"),
                  GetLastError()));
        return GetLastError();
    }

    hr = StringCchCopy (lpTest, ulNoChars, TEXT("\\\\"));
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat(lpTest, ulNoChars, lpDCName);
    }
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat(lpTest, ulNoChars, TEXT("\\sysvol\\*.*"));
    }

    if (FAILED(hr)) 
    {
        LocalFree(lpTest);
        return HRESULT_CODE(hr);
    }

    hFile = FindFirstFile (lpTest, &fd);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("TestDC: Failed to access <%s> with %d"),
                 lpTest, GetLastError()));
        LocalFree (lpTest);
        return GetLastError();
    }

    FindClose (hFile);

    LocalFree (lpTest);

    return ERROR_SUCCESS;
}

//*************************************************************
//
//  QueryForForestName()
//
//  Purpose:    Queries for a domain controller name
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD QueryForForestName (LPTSTR lpServerName, LPTSTR lpDomainName, ULONG ulFlags,  LPTSTR *lpForestFound)
    {
        PDOMAIN_CONTROLLER_INFO pDCI;
        DWORD  dwResult;
        LPTSTR lpTemp, lpEnd;


        //
        // Call for a DC name
        //

        dwResult = DsGetDcName (lpServerName, lpDomainName, NULL, NULL,
                                ulFlags,
                                &pDCI);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: Failed to query <%s> for a DC name with %d"),
                     lpDomainName, dwResult));
            return dwResult;
        }


        if (!(pDCI->Flags & DS_DS_FLAG))
        {
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: %s doesn't have Active Directory support (downlevel domain)"),
                     lpDomainName));
            NetApiBufferFree(pDCI);
            return ERROR_DS_UNAVAILABLE;
        }

        ULONG ulNoChars;
        HRESULT hr;

        ulNoChars = lstrlen(pDCI->DnsForestName) + 1;
        lpTemp = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

        if (!lpTemp)
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("QueryForForestName: Failed to allocate memory for forest name with %d"),
                     dwResult));
            NetApiBufferFree(pDCI);
            return dwResult;
        }

        hr = StringCchCopy(lpTemp, ulNoChars, pDCI->DnsForestName);
        ASSERT(SUCCEEDED(hr)); 

        NetApiBufferFree(pDCI);

        LocalFree(*lpForestFound);
        *lpForestFound = lpTemp;

        
        return ERROR_SUCCESS;
    }

//*************************************************************
//
//  QueryForDCName()
//
//  Purpose:    Queries for a domain controller name
//
//  Parameters:
//
//
//  Return:     ERROR_SUCCESS if successful
//              Error code otherwise
//
//*************************************************************

DWORD QueryForDCName (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName)
{
    PDOMAIN_CONTROLLER_INFO pDCI;
    DWORD  dwResult;
    LPTSTR lpTemp, lpEnd;


    //
    // Call for a DC name
    //

    dwResult = DsGetDcName (NULL, lpDomainName, NULL, NULL,
                            ulFlags, &pDCI);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: Failed to query <%s> for a DC name with %d"),
                 lpDomainName, dwResult));
        return dwResult;
    }


    if (!(pDCI->Flags & DS_DS_FLAG))
    {
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: %s doesn't not have Active Directory support (downlevel domain)"),
                 lpDomainName));
        return ERROR_DS_UNAVAILABLE;
    }


    //
    // Save the DC name
    //

    ULONG ulNoChars;
    HRESULT hr;

    ulNoChars  = lstrlen (pDCI->DomainControllerName) + 1;
    lpTemp = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));
    
    if (!lpTemp)
    {
        dwResult = GetLastError();
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: Failed to allocate memory for DC name with %d"),
                 dwResult));
        NetApiBufferFree(pDCI);
        return dwResult;
    }

    hr = StringCchCopy (lpTemp, ulNoChars, (pDCI->DomainControllerName + 2));
    if (SUCCEEDED(hr)) 
    {
        //
        // Remove the trailing .
        //

        lpEnd = lpTemp + lstrlen(lpTemp) - 1;

        if (*lpEnd == TEXT('.'))
        {
            *lpEnd =  TEXT('\0');
        }

        *lpDCName = lpTemp;
        dwResult = ERROR_SUCCESS;
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("QueryForDCName: Failed to allocate memory for DC name with 0x%x"),hr));
        LocalFree(lpTemp);
        dwResult = HRESULT_CODE(hr);
    }

    NetApiBufferFree(pDCI);

    return dwResult;
}

//*************************************************************
//
//  GetDCHelper()
//
//  Purpose:    Queries for a domain controller based upon
//              the flags and then rediscovers if necessary
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

DWORD GetDCHelper (LPTSTR lpDomainName, ULONG ulFlags, LPTSTR *lpDCName)
{
    DWORD dwError;

    //
    // Query for a DC name
    //

    SetWaitCursor();

    ulFlags |= DS_DIRECTORY_SERVICE_PREFERRED;

    dwError = QueryForDCName (lpDomainName, ulFlags, lpDCName);

    if (dwError == ERROR_SUCCESS)
    {

        //
        // Test if the DC is available
        //

        dwError = TestDC (*lpDCName);

        if (dwError != ERROR_SUCCESS)
        {

            //
            // The DC isn't available.  Query for another one
            //

            LocalFree (*lpDCName);
            ulFlags |= DS_FORCE_REDISCOVERY;

            dwError = QueryForDCName (lpDomainName, ulFlags, lpDCName);

            if (dwError == ERROR_SUCCESS)
            {

                //
                // Test if this DC is available
                //

                dwError = TestDC (*lpDCName);

                if (dwError != ERROR_SUCCESS)
                {
                    LocalFree (*lpDCName);
                    *lpDCName = NULL;
                }
            }
        }
    }

    ClearWaitCursor();

    return dwError;
}

//*************************************************************
//
//  GetDCName()
//
//  Purpose:    Gets a domain controller name
//
//  Parameters: lpDomainName    - Domain name
//              lpInheritServer - Inheritable server name
//              hParent         - Parent window handle for prompt dialog
//              bAllowUI        - Displaying UI is ok
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      DC Option values in the registry
//
//              Not specified  0
//              PDC            1
//              Inherit        2
//              Any Writable   3
//
//              Rules for finding a DC:
//                                         Inherit
//              Preference     Policy      DC Avail        Result
//              ==========     ======      ========        ======
//              Undefined      Undefined                   1) PDC 2) Prompt
//              PDC            Undefined                   1) PDC 2) Prompt
//              Inherit        Undefined     Yes           Inhert
//              Inherit        Undefined     No            Any DC
//              Any            Undefined                   Any DC
//
//              n/a            PDC                         PDC only
//              n/a            Inherit       Yes           Inhert
//              n/a            Inherit       No            Any DC
//              n/a            Any                         Any DC
//
//
//*************************************************************

LPTSTR GetDCName (LPTSTR lpDomainName, LPTSTR lpInheritServer,
                  HWND hParent, BOOL bAllowUI, DWORD dwFlags, ULONG ulRetFlags)
{
    LPTSTR lpDCName;
    ULONG  ulFlags;
    DWORD  dwDCPref = 1;
    DWORD  dwDCPolicy = 0;
    HKEY   hKey;
    DWORD  dwSize, dwType, dwError;
    dwError = ERROR_SUCCESS;
    DCSELINFO SelInfo;
    INT iResult;

    ulFlags = ulRetFlags;

    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Entering for:  %s"), lpDomainName));
    DebugMsg((DM_VERBOSE, TEXT("GetDCName: lpInheritServer is:  %s"), lpInheritServer));


    if (-1 == CheckForCachedDCSelection (lpDomainName))
    {
        DebugMsg((DM_VERBOSE, TEXT("GetDCName: Known dead domain.  Exiting.")));
        return NULL;
    }

    //
    // Check for a user DC preference
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwDCPref);
        RegQueryValueEx (hKey, DCOPTION_VALUE, NULL, &dwType,
                         (LPBYTE) &dwDCPref, &dwSize);

        if (dwDCPref > 3)
        {
            dwDCPref = 1;
        }

        RegCloseKey (hKey);
    }


    //
    // Check for a user DC policy
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwDCPolicy);
        RegQueryValueEx (hKey, DCOPTION_VALUE, NULL, &dwType,
                         (LPBYTE) &dwDCPolicy, &dwSize);

        if (dwDCPolicy > 3)
        {
            dwDCPolicy = 1;
        }

        RegCloseKey (hKey);
    }

    DebugMsg((DM_VERBOSE, TEXT("GetDCName: User preference is:  %d"), dwDCPref));
    DebugMsg((DM_VERBOSE, TEXT("GetDCName: User policy is:      %d"), dwDCPolicy));


    //
    // Validate that the inherit DC name is part of the domain name
    //

    if (lpInheritServer && (dwFlags & VALIDATE_INHERIT_DC))
    {
        if (ValidateInheritServer (lpDomainName, lpInheritServer) != ERROR_SUCCESS)
        {
            lpInheritServer = NULL;
        }
    }



    //
    // Based upon the rules, try to get a DC name
    //

    if (dwDCPolicy == 0)
    {

        //
        // The user doesn't have a preference or they have
        // a preference of using the PDC
        //

        if ((dwDCPref == 0) || (dwDCPref == 1))
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }

        //
        // The user has a preference of inheriting
        //

        else if (dwDCPref == 2)
        {
            if (lpInheritServer)
            {
                ULONG ulNoChars = lstrlen (lpInheritServer) + 1;

                lpDCName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                if (!lpDCName)
                {
                    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                             GetLastError()));
                    return NULL;
                }

                HRESULT hr;

                hr = StringCchCopy (lpDCName, ulNoChars, lpInheritServer);
                ASSERT(SUCCEEDED(hr));

                dwError = TestDC (lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }

                LocalFree (lpDCName);
            }
            else
            {
                ulFlags = ulRetFlags;
                dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }
            }
        }

        //
        // The user has a preference of using any DC
        //

        else if (dwDCPref == 3)
        {
            ulFlags = ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }
    }
    else
    {
        //
        // Policy says to use PDC
        //

        if (dwDCPolicy == 1)
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }

        //
        // Policy says to inherit
        //

        else if (dwDCPolicy == 2)
        {
            if (lpInheritServer)
            {
                ULONG ulNoChars;
                HRESULT hr;

                ulNoChars = lstrlen (lpInheritServer) + 1;
                lpDCName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

                if (!lpDCName)
                {
                    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                             GetLastError()));
                    return NULL;
                }

                hr = StringCchCopy (lpDCName, ulNoChars, lpInheritServer);
                ASSERT(SUCCEEDED(hr));

                dwError = TestDC (lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }

                LocalFree (lpDCName);
            }
            else
            {
                ulFlags = ulRetFlags;
                dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

                if (dwError == ERROR_SUCCESS)
                {
                    DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                    return lpDCName;
                }
            }

        }

        //
        // Policy says to use any DC
        //

        else if (dwDCPolicy == 3)
        {
            ulFlags = ulRetFlags;
            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                return lpDCName;
            }
        }
    }


    DebugMsg((DM_VERBOSE, TEXT("GetDCName: First attempt at DC name failed with %d"), dwError));


    //
    // The first attempt at getting a DC name failed
    //
    // In 2 cases, we will prompt the user for what to do and try again.
    //

    if (bAllowUI && (dwError != ERROR_DS_UNAVAILABLE) && (dwDCPolicy == 0) && ((dwDCPref == 0) || (dwDCPref == 1)))
    {

        iResult = CheckForCachedDCSelection (lpDomainName);

        if (iResult == 0)
        {
            //
            // Display the message
            //

            SelInfo.bError = TRUE;
            SelInfo.bAllowInherit = (lpInheritServer != NULL) ? TRUE : FALSE;
            SelInfo.iDefault = 1;
            SelInfo.lpDomainName = lpDomainName;

            iResult = (INT)DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_NODC), hParent,
                                      DCDlgProc, (LPARAM) &SelInfo);
        }


        //
        // Based upon the return value, try for another DC
        //

        if (iResult == 1)
        {
            ulFlags = DS_PDC_REQUIRED | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }
        }
        else if (iResult == 2)
        {
            HRESULT hr;
            ULONG ulNoChars;

            ulNoChars = lstrlen (lpInheritServer) + 1;
            lpDCName = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

            if (!lpDCName)
            {
                DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to allocate memory for DC name with %d"),
                         GetLastError()));
                return NULL;
            }

            hr = StringCchCopy (lpDCName, ulNoChars, lpInheritServer);
            ASSERT(SUCCEEDED(hr));

            dwError = TestDC (lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }

            LocalFree (lpDCName);
        }
        else if (iResult == 3)
        {
            ulFlags = 0 | ulRetFlags;

            dwError = GetDCHelper (lpDomainName, ulFlags, &lpDCName);

            if (dwError == ERROR_SUCCESS)
            {
                DebugMsg((DM_VERBOSE, TEXT("GetDCName: Domain controller is:  %s"), lpDCName));
                AddDCSelection (lpDomainName, iResult);
                return lpDCName;
            }
            else
            {
                AddDCSelection (lpDomainName, -1);
            }
        }
        else
        {
            DebugMsg((DM_VERBOSE, TEXT("GetDCName: User cancelled the dialog box")));
            return NULL;
        }
    }


    DebugMsg((DM_WARNING, TEXT("GetDCName: Failed to find a domain controller")));

    if (bAllowUI)
    {
        if (dwError == ERROR_DS_UNAVAILABLE)
        {
            ReportError(NULL, dwError, IDS_NODSDC, lpDomainName);
        }
        else
        {
            ReportError(NULL, dwError, IDS_NODC);
        }
    }

    SetLastError(dwError);

    return NULL;
}

//*************************************************************
//
//  MyGetUserName()
//
//  Purpose:    Gets the user name in the requested format
//
//  Parameters: NameFormat  - GetUserNameEx naming format
//
//  Return:     lpUserName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MyGetUserName (EXTENDED_NAME_FORMAT  NameFormat)
{
    DWORD dwError = ERROR_SUCCESS;
    LPTSTR lpUserName = NULL, lpTemp;
    ULONG ulUserNameSize;


    //
    // Allocate a buffer for the user name
    //

    ulUserNameSize = 75;

    if (NameFormat == NameFullyQualifiedDN) {
        ulUserNameSize = 200;
    }


    lpUserName = (LPTSTR) LocalAlloc (LPTR, ulUserNameSize * sizeof(TCHAR));

    if (!lpUserName) {
        dwError = GetLastError();
        DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to allocate memory with %d"),
                 dwError));
        goto Exit;
    }


    //
    // Special case NameUnknown to just get the simple user logon name
    //

    if (NameFormat == NameUnknown)
    {
        if (!GetUserName (lpUserName, &ulUserNameSize))
        {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserName failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
        }
        goto Exit;
    }


    //
    // Get the username in the requested format
    //

    if (!GetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {

        //
        // If the call failed due to insufficient memory, realloc
        // the buffer and try again.  Otherwise, exit now.
        //

        dwError = GetLastError();

        if (dwError != ERROR_INSUFFICIENT_BUFFER) {
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        lpTemp = (LPTSTR) LocalReAlloc (lpUserName, (ulUserNameSize * sizeof(TCHAR)),
                                       LMEM_MOVEABLE);

        if (!lpTemp) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  Failed to realloc memory with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }


        lpUserName = lpTemp;

        if (!GetUserNameEx (NameFormat, lpUserName, &ulUserNameSize)) {
            dwError = GetLastError();
            DebugMsg((DM_WARNING, TEXT("MyGetUserName:  GetUserNameEx failed with %d"),
                     dwError));
            LocalFree (lpUserName);
            lpUserName = NULL;
            goto Exit;
        }

        dwError = ERROR_SUCCESS;
    }


Exit:

    SetLastError(dwError);

    return lpUserName;
}

//*************************************************************
//
//  GuidToString, StringToGuid, ValidateGuid
//
//  Purpose:    Guid utility routines
//
//*************************************************************

void GuidToString( GUID *pGuid, TCHAR * szValue )
{
    (void) StringCchPrintf( szValue,
                            GUID_LEN+1,
                            TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
                            pGuid->Data1,
                            pGuid->Data2,
                            pGuid->Data3,
                            pGuid->Data4[0], pGuid->Data4[1],
                            pGuid->Data4[2], pGuid->Data4[3],
                            pGuid->Data4[4], pGuid->Data4[5],
                            pGuid->Data4[6], pGuid->Data4[7] );
}


void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    WCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == L'{' )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = wcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)wcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)wcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)wcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)wcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)wcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

BOOL ValidateGuid( TCHAR *szValue )
{
    //
    // Check if szValue is of form {19e02dd6-79d2-11d2-a89d-00c04fbbcfa2}
    //

    if ( lstrlen(szValue) < GUID_LENGTH )
        return FALSE;

    if ( szValue[0] != TEXT('{')
         || szValue[9] != TEXT('-')
         || szValue[14] != TEXT('-')
         || szValue[19] != TEXT('-')
         || szValue[24] != TEXT('-')
         || szValue[37] != TEXT('}') )
    {
        return FALSE;
    }

    return TRUE;
}


INT CompareGuid( GUID * pGuid1, GUID * pGuid2 )
{
    INT i;

    if ( pGuid1->Data1 != pGuid2->Data1 )
        return ( pGuid1->Data1 < pGuid2->Data1 ? -1 : 1 );

    if ( pGuid1->Data2 != pGuid2->Data2 )
        return ( pGuid1->Data2 < pGuid2->Data2 ? -1 : 1 );

    if ( pGuid1->Data3 != pGuid2->Data3 )
        return ( pGuid1->Data3 < pGuid2->Data3 ? -1 : 1 );

    for ( i = 0; i < 8; i++ )
    {
        if ( pGuid1->Data4[i] != pGuid2->Data4[i] )
            return ( pGuid1->Data4[i] < pGuid2->Data4[i] ? -1 : 1 );
    }

    return 0;
}

BOOL IsNullGUID (GUID *pguid)
{

    return ( (pguid->Data1 == 0)    &&
             (pguid->Data2 == 0)    &&
             (pguid->Data3 == 0)    &&
             (pguid->Data4[0] == 0) &&
             (pguid->Data4[1] == 0) &&
             (pguid->Data4[2] == 0) &&
             (pguid->Data4[3] == 0) &&
             (pguid->Data4[4] == 0) &&
             (pguid->Data4[5] == 0) &&
             (pguid->Data4[6] == 0) &&
             (pguid->Data4[7] == 0) );
}

//*************************************************************
//
//  SpawnGPE()
//
//  Purpose:    Spawns GPE for a GPO
//
//  Parameters: lpGPO    - ADSI path to the GPO
//              gpHint   - GPO hint type
//              lpDC     - GPO DC name to use (or NULL)
//              hParent  - Parent window handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL SpawnGPE (LPTSTR lpGPO, GROUP_POLICY_HINT_TYPE gpHint, LPTSTR lpDC, HWND hParent)
{
    LPTSTR lpArgs, lpFullPath, lpDomainName, lpGPODCName;
    UINT uiSize;
    SHELLEXECUTEINFO ExecInfo;
    LPOLESTR pszDomain;
    HRESULT hr;


    //
    // If a DC was given, we need to build a full path to the GPO on that DC.
    // If a DC was not given, then we need to query for a DC and then build a
    // full path.
    //

    if (lpDC)
    {
        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpDC);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to build new DS object path")));
            return FALSE;
        }
    }
    else
    {
        //
        // Get the friendly domain name
        //

        pszDomain = GetDomainFromLDAPPath(lpGPO);

        if (!pszDomain)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE: Failed to get domain name")));
            return FALSE;
        }


        //
        // Convert LDAP to dot (DN) style
        //

        hr = ConvertToDotStyle (pszDomain, &lpDomainName);

        delete [] pszDomain;

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
            return FALSE;
        }


        //
        // Get the GPO DC for this domain
        //

        lpGPODCName = GetDCName (lpDomainName, lpDC, hParent, TRUE, VALIDATE_INHERIT_DC);

        if (!lpGPODCName)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to get DC name for %s"),
                     lpDomainName));
            LocalFree (lpDomainName);
            return FALSE;
        }

        LocalFree (lpDomainName);


        //
        // Make the full path
        //

        lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

        LocalFree (lpGPODCName);

        if (!lpFullPath)
        {
            DebugMsg((DM_WARNING, TEXT("SpawnGPE:  Failed to build new DS object path")));
            return FALSE;
        }
    }


    uiSize = lstrlen (lpFullPath) + 30;

    lpArgs = (LPTSTR) LocalAlloc (LPTR, uiSize * sizeof(TCHAR));

    if (!lpArgs)
    {
        DebugMsg((DM_WARNING, TEXT("SpawnGPE: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Build the command line arguments
    //

    hr = StringCchPrintf (lpArgs, uiSize, TEXT("/s /gphint:%d /gpobject:\"%s\""), gpHint, lpFullPath);
    if (FAILED(hr)) 
    {
        LocalFree(lpArgs);
        DebugMsg((DM_WARNING, TEXT("SpawnGPE: Failed to build command line arguements with 0x%x"), hr));
        return FALSE;
    }

    DebugMsg((DM_VERBOSE, TEXT("SpawnGPE: Starting GPE with %s"), lpArgs));


    ZeroMemory (&ExecInfo, sizeof(ExecInfo));
    ExecInfo.cbSize = sizeof(ExecInfo);
    ExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;
    ExecInfo.lpVerb = TEXT("open");
    ExecInfo.lpFile = TEXT("gpedit.msc");
    ExecInfo.lpParameters = lpArgs;
    ExecInfo.nShow = SW_SHOWNORMAL;


    if (ShellExecuteEx (&ExecInfo))
    {
        SetWaitCursor();
        WaitForInputIdle (ExecInfo.hProcess, 10000);
        ClearWaitCursor();
        CloseHandle (ExecInfo.hProcess);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("SpawnGPE: ShellExecuteEx failed with %d"),
                 GetLastError()));
        ReportError(NULL, ( (GetLastError() == -1) ? 0 : GetLastError()), IDS_SPAWNGPEFAILED);
        LocalFree (lpArgs);
        return FALSE;
    }


    LocalFree (lpArgs);
    LocalFree (lpFullPath);

    return TRUE;
}


//*************************************************************
//
//  MakeFullPath()
//
//  Purpose:    Builds a fully qualified ADSI path consisting
//              of server and DN name
//
//  Parameters: lpDN     - DN path,  must start with LDAP://
//              lpServer - Server name
//
//  Return:     lpFullPath if success
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MakeFullPath (LPTSTR lpDN, LPTSTR lpServer)
{
    IADsPathname * pADsPathname;
    LPTSTR lpFullPath;
    BSTR bstr;
    HRESULT hr;
    ULONG ulNoChars;


    //
    // Make sure the incoming path is nameless first
    //

    hr = CoCreateInstance(CLSID_Pathname,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  IID_IADsPathname,
                  (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to create IAdsPathName object with = 0x%x"), hr));
        SetLastError(HRESULT_CODE(hr));
        return NULL;
    }


    BSTR bstrDN = SysAllocString( lpDN );
    if ( bstrDN == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to allocate BSTR memory.")));
        pADsPathname->Release();
        SetLastError(HRESULT_CODE(E_OUTOFMEMORY));
        return NULL;
    }
    hr = pADsPathname->Set(bstrDN, ADS_SETTYPE_FULL);
    SysFreeString( bstrDN );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to set <%s> in IAdsPathName object with = 0x%x"),
                 lpDN, hr));
        pADsPathname->Release();
        SetLastError(HRESULT_CODE(hr));
        return NULL;
    }


    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);
    pADsPathname->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to retrieve pathname with = 0x%x"), hr));
        SetLastError(HRESULT_CODE(hr));
        return NULL;
    }


    //
    // Allocate a new buffer for the named path including LDAP://
    //

    ulNoChars = 7 + lstrlen(bstr) + (lpServer ? lstrlen(lpServer) : 0) + 3;
    lpFullPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpFullPath)
    {
        DebugMsg((DM_WARNING, TEXT("MakeFullPath: Failed to allocate memory with = %d"), GetLastError()));
        SysFreeString (bstr);
        return NULL;
    }


    hr = StringCchCopy (lpFullPath, ulNoChars, TEXT("LDAP://"));
    if (SUCCEEDED(hr)) 
    {
        if (lpServer)
        {
            hr = StringCchCat (lpFullPath, ulNoChars, lpServer);
            if (SUCCEEDED(hr))
            {
                hr = StringCchCat(lpFullPath, ulNoChars, TEXT("/"));
            }
        }
    }
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat (lpFullPath, ulNoChars, (LPTSTR)(bstr + 7));
    }

    if (FAILED(hr)) 
    {
        LocalFree(lpFullPath);
        lpFullPath = NULL;
    }

    SysFreeString (bstr);

    return lpFullPath;
}

//*************************************************************
//
//  MakeNamelessPath()
//
//  Purpose:    Builds a server nameless ADSI path
//
//  Parameters: lpDN     - DN path,  must start with LDAP://
//
//  Return:     lpPath if success
//              NULL if an error occurs
//
//*************************************************************

LPTSTR MakeNamelessPath (LPTSTR lpDN)
{
    IADsPathname * pADsPathname;
    LPTSTR lpPath;
    BSTR bstr;
    HRESULT hr;


    //
    // Create a pathname object to work with
    //

    hr = CoCreateInstance(CLSID_Pathname,
                  NULL,
                  CLSCTX_INPROC_SERVER,
                  IID_IADsPathname,
                  (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to create IAdsPathName object with = 0x%x"), hr));
        return NULL;
    }


    BSTR bstrDN = SysAllocString( lpDN );
    if ( bstrDN == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to allocate BSTR memory.")));
        pADsPathname->Release();
        return NULL;
    }
    hr = pADsPathname->Set(bstrDN, ADS_SETTYPE_FULL);
    SysFreeString( bstrDN );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to set <%s> in IAdsPathName object with = 0x%x"),
                 lpDN, hr));
        pADsPathname->Release();
        return NULL;
    }


    hr = pADsPathname->Retrieve(ADS_FORMAT_X500_NO_SERVER, &bstr);
    pADsPathname->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to retrieve pathname with = 0x%x"), hr));
        return NULL;
    }


    //
    // Allocate a new buffer for the path
    //

    ULONG ulNoChars = lstrlen(bstr) + 1;

    lpPath = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(TCHAR));

    if (!lpPath)
    {
        DebugMsg((DM_WARNING, TEXT("MakeNamelessPath: Failed to allocate memory with = %d"), GetLastError()));
        SysFreeString (bstr);
        return NULL;
    }


    hr = StringCchCopy (lpPath, ulNoChars, bstr);
    ASSERT(SUCCEEDED(hr));

    SysFreeString (bstr);

    return lpPath;
}

//*************************************************************
//
//  ExtractServerName()
//
//  Purpose:    Extracts the server name from a ADSI path
//
//  Parameters: lpPath - ADSI path, must start with LDAP://
//
//  Return:     lpServerName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ExtractServerName (LPTSTR lpPath)
{
    LPTSTR lpServerName = NULL;
    LPTSTR lpEnd, lpTemp;


    //
    // Check the path to see if it has a server name
    //

    if (*(lpPath + 9) != TEXT('='))
    {
        //
        // Allocate memory for the server name
        //

        lpServerName = (LPTSTR) LocalAlloc (LPTR, (lstrlen(lpPath) + 1) * sizeof(TCHAR));

        if (!lpServerName)
        {
            DebugMsg((DM_WARNING, TEXT("ExtractServerName: Failed to allocate memory for name with 0xd"),
                     GetLastError()));
            return NULL;
        }

        lpTemp = (lpPath + 7);
        lpEnd = lpServerName;

        while (*lpTemp && (*lpTemp != TEXT('/')) && (*lpTemp != TEXT(',')))
        {
            *lpEnd = *lpTemp;
            lpEnd++;
            lpTemp++;
        }

        if (*lpTemp != TEXT('/'))
        {
            DebugMsg((DM_WARNING, TEXT("ExtractServerName: Failed to parse server name from ADSI path")));
            LocalFree (lpServerName);
            lpServerName = NULL;
        }
    }

    return lpServerName;
}

//*************************************************************
//
//  DoesPathContainAServerName()
//
//  Purpose:    Checks the given ADSI path to see if it
//              contains a server name
//
//  Parameters: lpPath - ADSI path
//
//  Return:     True if the path contains a server name
//              FALSE if not
//
//*************************************************************

BOOL DoesPathContainAServerName (LPTSTR lpPath)
{
    BOOL bResult = FALSE;


    //
    // Skip over LDAP:// if found
    //

    if ( CompareString( LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                        lpPath, 7, L"LDAP://", 7 ) == CSTR_EQUAL )
    {
        lpPath += 7;
    }


    //
    // Check if the 3rd character in the path is an equal sign.
    // If so, this path does not contain a server name
    //

    if ((lstrlen(lpPath) > 2) && (*(lpPath + 2) != TEXT('=')))
    {
        bResult = TRUE;
    }

    return bResult;
}

//*************************************************************
//
//  OpenDSObject()
//
//  Purpose:    Checks the given ADSI path to see if it
//              contains a server name
//
//  Parameters: lpPath - ADSI path
//
//  Return:     True if the path contains a server name
//              FALSE if not
//
//*************************************************************

HRESULT OpenDSObject (LPTSTR lpPath, REFIID riid, void FAR * FAR * ppObject)
{
    DWORD dwFlags = ADS_SECURE_AUTHENTICATION;


    if (DoesPathContainAServerName (lpPath))
    {
        dwFlags |= ADS_SERVER_BIND;
    }

    return AdminToolsOpenObject(lpPath, NULL, NULL, dwFlags,riid, ppObject);
}

HRESULT CheckDSWriteAccess (LPUNKNOWN punk, LPTSTR lpProperty)
{
    HRESULT hr;
    IDirectoryObject *pDO = NULL;
    PADS_ATTR_INFO pAE = NULL;
    LPWSTR lpAttributeNames[2];
    DWORD dwResult, dwIndex;


    //
    // Get the IDirectoryObject interface
    //

    hr = punk->QueryInterface(IID_IDirectoryObject, (void**)&pDO);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("CheckDSWriteAccess: Failed to get the IDirectoryObject interface with 0x%x"), hr));
        goto Exit;
    }


    //
    // Get the property value
    //

    lpAttributeNames[0] = L"allowedAttributesEffective";

    hr = pDO->GetObjectAttributes(lpAttributeNames, 1, &pAE, &dwResult);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CheckDSWriteAccess: Failed to get object attributes with 0x%x"), hr));
        goto Exit;
    }


    //
    // Set the default return value
    //

    hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);


    //
    // Go through the list of effective attributes
    //

    if (dwResult != 0) {
        for (dwIndex = 0; dwIndex < pAE[0].dwNumValues; dwIndex++)
        {
            if (lstrcmpi(pAE[0].pADsValues[dwIndex].CaseIgnoreString,
                         lpProperty) == 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_SUCCESS);
            }
        }
    }
    else {
        DebugMsg((DM_VERBOSE, TEXT("CheckDSWriteAccess: Couldn't get allowedAttributesEffective")));
    }

Exit:

    if (pAE)
    {
        FreeADsMem (pAE);
    }

    if (pDO)
    {
        pDO->Release();
    }

    return hr;
}

LPTSTR GetFullGPOPath (LPTSTR lpGPO, HWND hParent)
{
    LPTSTR lpFullPath = NULL, lpDomainName = NULL;
    LPTSTR lpGPODCName;
    LPOLESTR pszDomain;
    HRESULT hr;



    //
    // Get the friendly domain name
    //

    pszDomain = GetDomainFromLDAPPath(lpGPO);

    if (!pszDomain)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath: Failed to get domain name")));
        return NULL;
    }


    //
    // Convert LDAP to dot (DN) style
    //

    hr = ConvertToDotStyle (pszDomain, &lpDomainName);

    delete [] pszDomain;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::CreatePropertyPages: Failed to convert domain name with 0x%x"), hr));
        return NULL;
    }

    //
    // Get the GPO DC for this domain
    //

    lpGPODCName = GetDCName (lpDomainName, NULL, hParent, TRUE, 0);

    if (!lpGPODCName)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath:  Failed to get DC name for %s"),
                 lpDomainName));
        goto Exit;
    }


    //
    // Make the full path
    //

    lpFullPath = MakeFullPath (lpGPO, lpGPODCName);

    LocalFree (lpGPODCName);

    if (!lpFullPath)
    {
        DebugMsg((DM_WARNING, TEXT("GetFullGPOPath:  Failed to build new DS object path")));
        goto Exit;
    }


Exit:

    if (lpDomainName)
    {
        LocalFree (lpDomainName);
    }

    return lpFullPath;
}

//*************************************************************
//
//  ConvertName()
//
//  Purpose:    Converts the user / computer name from SAM style
//              to fully qualified DN
//
//  Parameters: lpName  -   name in sam style
//
//
//  Return:     lpDNName if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertName (LPTSTR lpName)
{
    LPTSTR lpDNName = NULL, lpSAMName = NULL;
    LPTSTR lpTemp, lpDCName = NULL;
    DWORD dwResult;
    HANDLE hDS = NULL;
    PDS_NAME_RESULT pNameResult = NULL;
    PDS_NAME_RESULT_ITEM pNameResultItem;
    HRESULT hr;
    ULONG ulNoChars;


    //
    // Check the argument
    //

    if (!lpName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: lpName is null")));
        SetLastError(ERROR_INVALID_DATA);
        goto Exit;
    }


    //
    // Make a copy of the name so we can edit it
    //

    ulNoChars = lstrlen(lpName) + 1;
    lpSAMName = new TCHAR[ulNoChars];

    if (!lpSAMName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }

    hr = StringCchCopy (lpSAMName, ulNoChars, lpName);
    ASSERT(SUCCEEDED(hr));

    //
    // Find the slash between the domain name and the account name and replace
    // it with a null
    //

    lpTemp = lpSAMName;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
    {
        lpTemp++;
    }

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to find backslash in %s"), lpSAMName));
        SetLastError(ERROR_INVALID_DATA);
        goto Exit;
    }

    *lpTemp = TEXT('\0');


    //
    // Call DsGetDcName to convert the netbios name to a FQDN name
    //

    dwResult = GetDCHelper (lpSAMName, DS_IS_FLAT_NAME | DS_RETURN_DNS_NAME, &lpDCName);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: GetDCHelper failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Bind to the domain controller
    //

    dwResult = DsBind (lpDCName, NULL, &hDS);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsBind failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Use DsCrackNames to convert the name FQDN
    //

    dwResult = DsCrackNames (hDS, DS_NAME_NO_FLAGS, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME,
                             1, &lpName, &pNameResult);

    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsCrackNames failed with %d"), dwResult));
        SetLastError(dwResult);
        goto Exit;
    }


    //
    // Setup a pointer to the first item
    //

    pNameResultItem = &pNameResult->rItems[0];

    if (pNameResultItem->status != DS_NAME_NO_ERROR)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: DsCrackNames failed to convert name with %d"), pNameResultItem->status));
        SetLastError(pNameResultItem->status);
        goto Exit;
    }


    //
    // Save the name in a new buffer so it can returned
    //

    ulNoChars = lstrlen(pNameResultItem->pName) + 1;
    lpDNName = new TCHAR[ulNoChars];

    if (!lpDNName)
    {
        DebugMsg((DM_WARNING, TEXT("ConvertName: Failed to allocate memory with %d"), GetLastError()));
        goto Exit;
    }

    hr = StringCchCopy (lpDNName, ulNoChars, pNameResultItem->pName);
    ASSERT(SUCCEEDED(hr));

Exit:

    if (pNameResult)
    {
        DsFreeNameResult (pNameResult);
    }

    if (hDS)
    {
        DsUnBind (&hDS);
    }

    if (lpDCName)
    {
        LocalFree (lpDCName);
    }

    if (lpSAMName)
    {
       delete [] lpSAMName;
    }

    return lpDNName;
}

//*************************************************************
//
//  CreateTempFile()
//
//  Purpose:    Creates a temp file
//
//  Parameters: void
//
//  Return:     filename if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR CreateTempFile (void)
{
    TCHAR szTempDir[MAX_PATH];
    TCHAR szTempFile[MAX_PATH];
    LPTSTR lpFileName;


    //
    // Query for the temp directory
    //

    if (!GetTempPath (MAX_PATH, szTempDir))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: GetTempPath failed with %d"), GetLastError()));
        return NULL;
    }


    //
    // Query for a temp filename
    //

    if (!GetTempFileName (szTempDir, TEXT("RSP"), 0, szTempFile))
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: GetTempFile failed with %d"), GetLastError()));
        return NULL;
    }


    //
    // Allocate a new buffer for the filename
    //

    ULONG ulNoChars;
    HRESULT hr;

    ulNoChars = lstrlen(szTempFile) + 1;
    lpFileName = new TCHAR[ulNoChars];

    if (!lpFileName)
    {
        DebugMsg((DM_WARNING, TEXT("CRSOPComponentData::CreateTempFile: Failed to allocate memory for temp filename with %d"), GetLastError()));
        return NULL;
    }

    hr = StringCchCopy (lpFileName, ulNoChars, szTempFile);
    ASSERT(SUCCEEDED(hr));

    return lpFileName;
}

//+--------------------------------------------------------------------------
//
//  Function:   NameToPath
//
//  Synopsis:   converts a dot-format domain name to an LDAP:// style path
//
//  Arguments:  [szPath]    - (out) buffer to hold the path
//              [szName]    - (in) dot-format domain name
//              [cch]       - (in) size of the out buffer
//
//  History:    10-15-1998   stevebl   Created
//
//  Note:       Currently, this routine will truncate if it doesn't get a
//              large enough buffer so you'd better be sure your
//              buffer's large enough.  (The formula is string size + 10 + 3
//              for each dot in the string.)
//
//              That's good enough to avoid an AV but could have some really
//              wierd side effects so beware.
//
//---------------------------------------------------------------------------

void NameToPath(WCHAR * szPath, WCHAR *szName, UINT cch)
{
    WCHAR * szOut = szPath;
    WCHAR * szIn = szName;
    HRESULT hr;

    hr = StringCchCopy(szOut, cch, TEXT("LDAP://DC="));
    if (FAILED(hr)) 
    {
        return;
    }

    szOut += 10;
    while ((*szIn) && (szOut + 1 < szPath + cch))
    {
        if (*szIn == TEXT('.') && (szOut + 4 < szPath + cch))
        {
            ++szIn;
            if (*szIn && *szIn != TEXT('.'))
            {
                *szOut = TEXT(',');
                ++szOut;
                *szOut = TEXT('D');
                ++szOut;
                *szOut = TEXT('C');
                ++szOut;
                *szOut = TEXT('=');
                ++szOut;
            }
        }
        else
        {
            *szOut = *szIn;
            ++szOut;
            ++szIn;
        }
    }
    *szOut = TEXT('\0');
}

//+--------------------------------------------------------------------------
//
//  Function:   GetPathToForest
//
//  Synopsis:   given a domain, return a pointer to its forest
//
//  Arguments:  [szServer] - DOT style path to a server (may be NULL)
//
//  Returns:    LDAP style path to the forest's Configuration container
//
//  History:    03-31-2000   stevebl   Created
//
//  Notes:      return value is allocated with new
//
//---------------------------------------------------------------------------

LPTSTR GetPathToForest(LPOLESTR szServer)
{
    LPOLESTR szReturn = NULL;
    LPOLESTR lpForest = NULL;
    LPOLESTR lpTemp = NULL;
    LPOLESTR lpDCName = NULL;
    IADsPathname * pADsPathname = NULL;
    BSTR bstrForest = NULL;
    HRESULT hr = 0;
    int cch, n;

    DWORD dwResult = QueryForForestName(szServer,
                                        NULL,
                                        DS_PDC_REQUIRED | DS_RETURN_DNS_NAME,
                                        &lpTemp);
    if (dwResult != ERROR_SUCCESS)
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: QueryForestName failed for domain name %s with %d"),
                  szServer, dwResult));
        hr = HRESULT_FROM_WIN32(dwResult);
        goto Exit;
    }

    cch = 0;
    n = 0;
    // count the dots in lpTemp;
    while (lpTemp[n])
    {
        if (L'.' == lpTemp[n])
        {
            cch++;
        }
        n++;
    }
    cch *= 3; // multiply the number of dots by 3;
    cch += 11; // add 10 + 1 (for the null)
    cch += n; // add the string size;
    lpForest = (LPTSTR) LocalAlloc(LPTR, sizeof(WCHAR) * cch);
    if (!lpForest)
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to allocate memory for forest name with %d"),
                 GetLastError()));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    NameToPath(lpForest, lpTemp, cch);
    LocalFree(lpTemp);
    lpTemp = NULL;

    // See if we need to put a specific server on this.
    //
    if (szServer)
    {
        // we have a path to a specific DC
        // need to prepend it to the forest name
        lpTemp = MakeFullPath(lpForest, szServer);

        if (!lpTemp)
        {
            DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to combine server name with Forest path")));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        // clean up the variables we just borrowed so they can be used later
        LocalFree(lpForest);
        lpForest = lpTemp;
        lpTemp = NULL;
    }


    // at this point we have the path to the forest's DC in lpForest
    // we still need to add "CN=Configuration" to this

    //
    // Create a pathname object we can work with
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (LPVOID*)&pADsPathname);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to create adspathname instance with 0x%x"), hr));
        goto Exit;
    }


    //
    // Add the domain name
    //

    bstrForest = SysAllocString( lpForest );
    if ( bstrForest == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->Set (bstrForest, ADS_SETTYPE_FULL);
    SysFreeString( bstrForest );
    bstrForest = NULL;

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to set pathname with 0x%x"), hr));
        goto Exit;
    }

    //
    // Add the Configuration folder to the path
    //

    BSTR bstrCNConfiguration = SysAllocString( TEXT("CN=Configuration") );
    if ( bstrCNConfiguration == NULL )
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to allocate BSTR memory.")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = pADsPathname->AddLeafElement (bstrCNConfiguration);
    SysFreeString( bstrCNConfiguration );

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to add configuration folder with 0x%x"), hr));
        goto Exit;
    }

    //
    // Retreive the GPC path
    //

    hr = pADsPathname->Retrieve (ADS_FORMAT_X500, &bstrForest);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetPathToForest: Failed to retreive container path with 0x%x"), hr));
        goto Exit;
    }

    DebugMsg((DM_VERBOSE, TEXT("GetPathToForest: conatiner path is:  %s"), bstrForest));

    ULONG ulNoChars = SysStringLen(bstrForest)+1;

    szReturn = new OLECHAR[ulNoChars];
    hr = StringCchCopy(szReturn, ulNoChars, bstrForest);
    ASSERT(SUCCEEDED(hr));

Exit:
    if (bstrForest)
    {
        SysFreeString(bstrForest);
    }

    if (pADsPathname)
    {
        pADsPathname->Release();
    }

    if (lpForest)
    {
        LocalFree(lpForest);
    }
    if (lpDCName)
    {
        LocalFree(lpDCName);
    }
    if (lpTemp)
    {
        LocalFree(lpTemp);
    }

    if (!szReturn)
    {
        SetLastError(hr);
    }

    return szReturn;
}

BOOL IsForest(LPOLESTR szLDAPPath)
{
#if FGPO_SUPPORT
    return ((StrStrI(szLDAPPath, TEXT("CN=Configuration"))) ? TRUE : FALSE);
#else
    return FALSE;
#endif
}

//*************************************************************
//
//  IsStandaloneComputer()
//
//  Purpose:    Determines if the computer is not a member of a domain
//
//  Parameters: none
//
//
//  Return:     TRUE if the computer is running standalone
//              FALSE if not
//
//*************************************************************

BOOL IsStandaloneComputer (VOID)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasic;
    DWORD dwResult;
    BOOL bRetVal = FALSE;

    //
    // Ask for the role of this machine
    //

    dwResult = DsRoleGetPrimaryDomainInformation(NULL, DsRolePrimaryDomainInfoBasic,
                                                 (PBYTE *)&pBasic);


    if (dwResult == ERROR_SUCCESS)
    {

        //
        // Check for standalone flags
        //

        if ((pBasic->MachineRole == DsRole_RoleStandaloneWorkstation) ||
            (pBasic->MachineRole == DsRole_RoleStandaloneServer))
        {
            bRetVal = TRUE;
        }

        DsRoleFreeMemory (pBasic);
    }
    else
    {
        DebugMsg((DM_WARNING, TEXT("IsStandaloneComputer:  DsRoleGetPrimaryDomainInformation failed with %d."),
                 dwResult));
    }

    return bRetVal;
}

//*************************************************************
//
//  GetNewGPODisplayName()
//
//  Purpose:    Gets the new GPO display name
//
//  Parameters: lpDisplayName      -  Receives the display name
//              dwDisplayNameSize  -  Size of lpDisplayName
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

BOOL GetNewGPODisplayName (LPTSTR lpDisplayName, DWORD dwDisplayNameSize)
{
    TCHAR szName[256];
    LONG lResult;
    HKEY hKey;
    DWORD dwSize, dwType;


    //
    // Load the default string
    //

    LoadString(g_hInstance, IDS_NEWGPO, szName, ARRAYSIZE(szName));


    //
    // Check for a user preference
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(szName);
        RegQueryValueEx (hKey, GPO_DISPLAY_NAME_VALUE, NULL, &dwType,
                         (LPBYTE) szName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Check for a user policy
    //

    lResult = RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        dwSize = sizeof(szName);
        RegQueryValueEx (hKey, GPO_DISPLAY_NAME_VALUE, NULL, &dwType,
                         (LPBYTE) szName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    // Expand the string to resolve any environment variables
    //

    if (!ExpandEnvironmentStrings (szName, lpDisplayName, dwDisplayNameSize))
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT GetWMIFilterName (LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat, LPTSTR *lpName)
{
    IWbemLocator * pLocator = NULL;
    IWbemServices * pNamespace = NULL;
    IWbemClassObject *pObject = NULL;
    BSTR bstrParam = NULL;
    BSTR bstrObject = NULL;
    HRESULT hr;
    LPTSTR lpID, lpDSPath, lpTemp, lpFullFilter = NULL, lpObject = NULL;
    LPTSTR lpDomain = NULL;
    ULONG ulNoChars;


    *lpName = NULL;

    hr = E_OUTOFMEMORY;

    if (bDSFormat)
    {
        //
        // Parse the filter path
        //

        ulNoChars = lstrlen(lpFilter) + 1;

        lpFullFilter = new TCHAR [ulNoChars];

        if (!lpFullFilter)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for full filter path")));
            goto Cleanup;
        }

        hr = StringCchCopy (lpFullFilter, ulNoChars, lpFilter);
        ASSERT(SUCCEEDED(hr));

        lpTemp = lpFullFilter;


        //
        // Skip over the opening [ character
        //

        lpTemp++;
        lpDSPath = lpTemp;


        //
        // Find the semi-colon.  This is the end of the DS Path
        //

        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (!(*lpTemp))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Filter parsing problem")));
            goto Cleanup;
        }

        *lpTemp = TEXT('\0');
        lpTemp++;


        //
        // Next is the ID  (a guid).  Find the next semi-colon and the ID is complete
        //

        lpID = lpTemp;


        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (!(*lpTemp))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Filter parsing problem")));
            goto Cleanup;
        }

        *lpTemp = TEXT('\0');



        //
        // Now build the query
        //

        ulNoChars = lstrlen(lpDSPath) + lstrlen(lpID) + 50;
        lpObject = new TCHAR [ulNoChars];

        if (!lpObject)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for object path")));
            goto Cleanup;
        }

        hr = StringCchPrintf (lpObject, ulNoChars, TEXT("MSFT_SomFilter.ID=\"%s\",Domain=\"%s\""), lpID, lpDSPath);
        if (FAILED(hr)) 
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to copy object path")));
            goto Cleanup;
        }
    }
    else
    {
        //
        // The filter is already in the correct format.  Just dup it and go.
        //

        ulNoChars = lstrlen(lpFilter) + 1;
        lpObject = new TCHAR [ulNoChars];

        if (!lpObject)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for object path")));
            goto Cleanup;
        }

        hr = StringCchCopy (lpObject, ulNoChars, lpFilter);
        ASSERT(SUCCEEDED(hr));
    }


    //
    // Get a locator instance
    //

    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (LPVOID *) &pLocator);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: CoCreateInstance failed with 0x%x"), hr));
        goto Cleanup;
    }


    //
    // Build a path to the policy provider
    //

    bstrParam = SysAllocString(TEXT("\\\\.\\root\\policy"));

    if (!bstrParam)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate bstr for namespace path")));
        goto Cleanup;
    }


    //
    // Connect to the namespace
    //

    hr = pLocator->ConnectServer(bstrParam,
                                 NULL,
                                 NULL,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 &pNamespace);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: ConnectServer failed with 0x%x"), hr));
        goto Cleanup;
    }


    //
    // Set the proper security to prevent the GetObject call from failing and to enable encryption
    //

    hr = CoSetProxyBlanket(pNamespace,
                           RPC_C_AUTHN_DEFAULT,
                           RPC_C_AUTHZ_DEFAULT,
                           COLE_DEFAULT_PRINCIPAL,
                           RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Cleanup;
    }



    bstrObject = SysAllocString(lpObject);

    if (!bstrObject)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate bstr for namespace path")));
        goto Cleanup;
    }

    hr = pNamespace->GetObject(bstrObject,
                               WBEM_FLAG_RETURN_WBEM_COMPLETE,
                               NULL,
                               &pObject,
                               NULL);

    if (FAILED(hr))
    {
        TCHAR szDefault[100];

        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetObject for %s failed with 0x%x"), bstrObject, hr));

        goto Cleanup;
    }



    hr = GetParameter(pObject, TEXT("Name"), *lpName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetParameter failed with 0x%x"), hr));
    }


    if (bRetRsopFormat) {
        LPTSTR lpTemp1;
        TCHAR szRsopQueryFormat[200];

        hr = GetParameter(pObject, TEXT("Domain"), lpDomain);

        if (FAILED(hr))
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetParameter failed with 0x%x"), hr));
        }

        if (lpDomain) {
            szRsopQueryFormat[0] = TEXT('\0');
            LoadString(g_hInstance, IDS_RSOPWMIQRYFMT, szRsopQueryFormat, ARRAYSIZE(szRsopQueryFormat));

            ulNoChars = lstrlen(szRsopQueryFormat)+lstrlen(*lpName)+lstrlen(lpDomain)+2;
            lpTemp1 = new TCHAR[ulNoChars];

            if (!lpTemp1) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                delete [] *lpName;
                *lpName = NULL;
                DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to allocate memory with 0x%x"), hr));
                goto Cleanup;
            }

            hr = StringCchPrintf(lpTemp1, 
                                 ulNoChars, 
                                 szRsopQueryFormat, 
                                 *lpName, 
                                 lpDomain);
            if (FAILED(hr)) 
            {
                delete [] *lpName;
                *lpName = NULL;
                delete [] lpTemp1;
                DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to copy rsop query with 0x%x"), hr));
                goto Cleanup;
            }

            delete [] *lpName;
            *lpName = lpTemp1;

            delete [] lpDomain;
        }
    }

Cleanup:
    SysFreeString(bstrParam);

    if (pObject)
    {
        pObject->Release();
    }

    if (pNamespace)
    {
        pNamespace->Release();
    }

    if (pLocator)
    {
        pLocator->Release();
    }

    if (bstrParam)
    {
        SysFreeString (bstrParam);
    }

    if (bstrObject)
    {
        SysFreeString (bstrParam);
    }

    if (lpFullFilter)
    {
        delete [] lpFullFilter;
    }

    if (lpObject)
    {
        delete [] lpObject;
    }

    return hr;
}


//*************************************************************
//
//  GetWMIFilter()
//
//  Purpose:    Displays the WMI filter UI and returns back a dspath, id,
//              and friendly display name if the user selects OK.
//
//  Parameters: bBrowser      -  Browser or full manager.
//              hwndParent    -  Hwnd of parent window
//              bDSFormat     -  Boolean that states DS vs WMI format
//              lpDisplayName -  Address of pointer to friendly display name
//              lpFilter      -  Address of pointer to filter
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Notes:      The filter is returned in either DS or WMI format.
//                 The DS format is: [DSPath;id;flags]     flags is always 0
//                 The WMI format is: MSFT_SomFilter.ID="<id>",Domain="<context>"
//
//*************************************************************

BOOL GetWMIFilter(  BOOL bBrowser,
                    HWND hwndParent,
                    BOOL bDSFormat,
                    LPTSTR *lpDisplayName,
                    LPTSTR * lpFilter,
                    BSTR    bstrDomain )
{
    HRESULT hr;
    VARIANT var;
    IWMIFilterManager * pWMIFilterManager;
    IWbemClassObject * pFilter;
    LPTSTR lpName = NULL, lpDSPath = NULL, lpID = NULL;

    VariantInit (&var);

    //
    // Display the appropriate WMI filter UI
    //

    hr = CoCreateInstance (CLSID_WMIFilterManager, NULL,
                           CLSCTX_SERVER, IID_IWMIFilterManager,
                           (void**)&pWMIFilterManager);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  CoCreateInstance failed with 0x%x."),hr));
        return FALSE;
    }


    if (bBrowser)
    {
        hr = pWMIFilterManager->RunBrowser( hwndParent,
                                            bstrDomain,
                                            &var );
    }
    else
    {
        hr = pWMIFilterManager->RunManager( hwndParent,
                                            bstrDomain,
                                            &var);
    }


    pWMIFilterManager->Release();


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  RunBrowser / RunManager failed with 0x%x."),hr));
        return FALSE;
    }

    if (hr == S_FALSE)
    {
        if (*lpFilter) {
            hr = GetWMIFilterName (*lpFilter, TRUE, FALSE, lpDisplayName);

            if (!(*lpDisplayName)) {
                DebugMsg((DM_VERBOSE, TEXT("GetWMIFilter:  Currently attached WMI filter doesn't exist.")));

                if (hwndParent)
                {
                    ReportError(hwndParent, 0, IDS_WMIFILTERFORCEDNONE);
                }


                delete [] *lpFilter;
                *lpFilter = NULL;
            }
        }

        return TRUE;
    }


    if (var.vt != VT_UNKNOWN)
    {
         DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  variant isn't of type VT_UNKNOWN.")));
         VariantClear (&var);
         return FALSE;
    }


    //
    //  Get the IWbemClassobject interface pointer
    //

    hr = var.punkVal->QueryInterface (IID_IWbemClassObject, (void**)&pFilter);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  QueryInterface failed with 0x%x."),hr));
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the display name
    //

    hr = GetParameter (pFilter, TEXT("Name"), lpName);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for Name failed with 0x%x."),hr));
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the DS Path (Domain)
    //

    hr = GetParameter (pFilter, TEXT("Domain"), lpDSPath);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for DsContext failed with 0x%x."),hr));
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    //  Get the ID
    //

    hr = GetParameter (pFilter, TEXT("ID"), lpID);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  GetParameter for ID failed with 0x%x."),hr));
        delete [] lpDSPath;
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }


    //
    // Put the path together
    //


    LPTSTR lpTemp = NULL;
    ULONG ulNoChars = lstrlen(lpDSPath) + lstrlen(lpID) + 50;

    lpTemp = new TCHAR[ulNoChars];

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("GetWMIFilter:  New failed")));
        delete [] lpID;
        delete [] lpDSPath;
        delete [] lpName;
        pFilter->Release();
        VariantClear (&var);
        return FALSE;
    }

    if (bDSFormat)
    {
        hr = StringCchPrintf (lpTemp, ulNoChars, TEXT("[%s;%s;0]"), lpDSPath, lpID);

    }
    else
    {
        hr = StringCchPrintf (lpTemp, ulNoChars, TEXT("MSFT_SomFilter.ID=\"%s\",Domain=\"%s\""), lpID, lpDSPath);
    }

    //
    // Save the display name
    //

    delete [] lpID;
    delete [] lpDSPath;
    pFilter->Release();
    VariantClear (&var);

    if (SUCCEEDED(hr)) 
    {
        *lpDisplayName = lpName;
        delete [] *lpFilter;
        *lpFilter = lpTemp;
        DebugMsg((DM_VERBOSE, TEXT("GetWMIFilter:  Name:  %s   Filter:  %s"), *lpDisplayName, *lpFilter));
        return TRUE;
    }
    else
    {
        delete [] lpTemp;
        delete [] lpName;
        return FALSE;
    }
}

//*************************************************************
//
//  GetWMIFilterDisplayName()
//
//  Purpose:    Gets the friendly display name for the specified
//              WMI filter link
//
//  Parameters: lpFilter - filter string
//              bDSFormat - in ds format or wmi format
//
//
//  Return:     Pointer to display name if successful
//              NULL if an error occurs
//
//*************************************************************
LPTSTR GetWMIFilterDisplayName (HWND hParent, LPTSTR lpFilter, BOOL bDSFormat, BOOL bRetRsopFormat)
{
    LPTSTR lpName = NULL;
    HRESULT hr;


    hr = GetWMIFilterName(lpFilter, bDSFormat, bRetRsopFormat, &lpName);

    if (FAILED(hr) || (lpName == NULL ) || ((*lpName) == NULL)) {
        TCHAR szDefault[100];

        DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: GetObject for %s failed with 0x%x"), lpFilter, hr));

        if (hParent)
        {
            ReportError(hParent, hr, IDS_WMIFILTERMISSING);
        }

        LoadString(g_hInstance, IDS_MISSINGFILTER, szDefault, ARRAYSIZE(szDefault));

        ULONG ulNoChars = lstrlen(szDefault) + 1;

        lpName = new TCHAR [ulNoChars];

        if (!lpName)
        {
            DebugMsg((DM_WARNING, TEXT("GetWMIFilterDisplayName: Failed to alloc memory for default name")));
            goto Cleanup;
        }

        hr = StringCchCopy (lpName, ulNoChars, szDefault);
        ASSERT(SUCCEEDED(hr));
    }


Cleanup:
    return lpName;
}

//*************************************************************
//
//  SaveString()
//
//  Purpose:    Saves the given string to the stream
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT SaveString(IStream *pStm, LPTSTR lpString)
{
    ULONG nBytesWritten;
    DWORD dwBufferSize;
    HRESULT hr;

    //
    // Check to see if there is a string to save or what its length is
    //

    if ( lpString == NULL )
    {
        dwBufferSize = 0;
    }
    else
    {
        dwBufferSize = ( lstrlen (lpString) + 1 ) * sizeof(TCHAR);
    }

    //
    // Save the buffer size - (string length+1)*sizeof(TCHAR)
    //

    hr = pStm->Write(&dwBufferSize, sizeof(dwBufferSize), &nBytesWritten);

    if ((hr != S_OK) || (nBytesWritten != sizeof(dwBufferSize)))
    {
        DebugMsg((DM_WARNING, TEXT("SaveString: Failed to write string length with %d."), hr));
        goto Exit;
    }


    //
    // Save the string
    //

    if ( dwBufferSize != 0 )
    {
        hr = pStm->Write(lpString, dwBufferSize, &nBytesWritten);

        if ((hr != S_OK) || (nBytesWritten != dwBufferSize))
        {
            DebugMsg((DM_WARNING, TEXT("SaveString: Failed to write string with %d."), hr));
            goto Exit;
        }
    }

Exit:

    return hr;
}

HRESULT ReadString(IStream *pStm, LPTSTR *lpString, BOOL bUseLocalAlloc /*= FALSE*/)
{
    HRESULT hr;
    DWORD dwBufferSize;
    ULONG nBytesRead;


    //
    // Read in the buffer size - (string length+1)*sizeof(TCHAR)
    //

    hr = pStm->Read(&dwBufferSize, sizeof(dwBufferSize), &nBytesRead);

    if ((hr != S_OK) || (nBytesRead != sizeof(dwBufferSize)))
    {
        DebugMsg((DM_WARNING, TEXT("ReadString: Failed to read string size with 0x%x."), hr));
        hr = E_FAIL;
        goto Exit;
    }


    //
    // Read in the string if there is one
    //

    if (dwBufferSize > 0)
    {
        if ( bUseLocalAlloc )
        {
            *lpString = (TCHAR*)LocalAlloc( LPTR, dwBufferSize );
        }
        else
        {
            *lpString = new TCHAR[(dwBufferSize/sizeof(TCHAR))];
        }

        if (!(*lpString))
        {
            DebugMsg((DM_WARNING, TEXT("ReadString: Failed to allocate memory with %d."),
                     GetLastError()));
            hr = E_FAIL;
            goto Exit;
        }

        hr = pStm->Read(*lpString, dwBufferSize, &nBytesRead);

        if ((hr != S_OK) || (nBytesRead != dwBufferSize))
        {
            DebugMsg((DM_WARNING, TEXT("ReadString: Failed to read String with 0x%x."), hr));
            hr = E_FAIL;
            if ( bUseLocalAlloc )
            {
                LocalFree( *lpString );
            }
            else
            {
                delete [] (*lpString);
            }
            *lpString = NULL;
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("ReadString: String is: <%s>"), *lpString));
    }

Exit:


    return hr;

}


//*************************************************************
//
//  GetSiteFriendlyName()
//
//  Purpose:    Returns the sites friendly name
//
//  Parameters:
//
//          szSitePath  - Path to the site
//          pszSiteName - Friendly name of the site
//
//  Return:     currently it always returns true, if it
//              couldn't get the sitename, returns itself
//
//*************************************************************

BOOL GetSiteFriendlyName (LPWSTR szSitePath, LPWSTR *pszSiteName)
{
    HRESULT hr;
    ULONG ulNoChars;
    ULONG ulNoCharsSiteName;

    ulNoCharsSiteName = wcslen(szSitePath)+1;
    *pszSiteName = new WCHAR[ulNoCharsSiteName];

    if (!*pszSiteName) {
        return FALSE;
    }

    LPWSTR szData;

    //
    // Build the LDAP path (serverless)
    //

    ulNoChars = wcslen(szSitePath)+1+7;
    szData = new WCHAR[ulNoChars];

    if (szData)
    {
        hr = StringCchCopy(szData, ulNoChars, TEXT("LDAP://"));
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat(szData, ulNoChars, szSitePath);
        }
        if (SUCCEEDED(hr)) 
        {
            //
            // Setup the default friendly name
            //    

            if (*pszSiteName)
            {
                hr = StringCchCopy(*pszSiteName, ulNoCharsSiteName, szSitePath);
            }
        }

        if (FAILED(hr)) 
        {
            delete [] *pszSiteName;
            *pszSiteName= NULL;
            delete [] szData;
            return FALSE;
        }

        //
        // Bind to the site object in the DS to try and get the
        // real friendly name
        //

        IADs * pADs = NULL;

        hr = OpenDSObject(szData, IID_IADs, (void **)&pADs);

        if (SUCCEEDED(hr))
        {
            VARIANT varName;
            BSTR bstrNameProp;
            VariantInit(&varName);
            bstrNameProp = SysAllocString(SITE_NAME_PROPERTY);

            if (bstrNameProp)
            {
                hr = pADs->Get(bstrNameProp, &varName);

                if (SUCCEEDED(hr))
                {
                    ulNoChars = wcslen(varName.bstrVal) + 1;
                    LPOLESTR sz = new OLECHAR[ulNoChars];
                    if (sz)
                    {
                        hr = StringCchCopy(sz, ulNoChars, varName.bstrVal);
                        ASSERT(SUCCEEDED(hr));

                        if (*pszSiteName)
                        {
                            delete [] *pszSiteName;
                        }
                        *pszSiteName = sz;
                    }
                }
                SysFreeString(bstrNameProp);
            }

            VariantClear(&varName);
            pADs->Release();
        }

        delete [] szData;
    }

    return TRUE;
}


//*************************************************************
//
//  SetSysvolSecurityFromDSSecurity
//
//  Purpose:     Convert a DS security access list into a
//               file system security access list and actually
//               set the security
//
//  Parameters:
//
//          lpFileSysPath - Path to the gpo subdirectory on the sysvol
//          si - information regarding which portion of the security
//               descriptor to apply
//          pSD  DS security descriptor to set on the pFileSysPath directory
//
//  Return:     ERROR_SUCCESS if successful, other Win32 failure code otherwise
//
//*************************************************************

DWORD 
SetSysvolSecurityFromDSSecurity(
    LPTSTR lpFileSysPath,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR pSD
    )
{
    PACL pSacl = NULL, pDacl = NULL;
    PSID psidOwner = NULL, psidGroup = NULL;
    BOOL bAclPresent, bDefaulted;
    DWORD dwResult;


    //
    // Get the DACL
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorDacl (pSD, &bAclPresent, &pDacl, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorDacl failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the SACL
    //

    if (si & SACL_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorSacl (pSD, &bAclPresent, &pSacl, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorSacl failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the owner
    //

    if (si & OWNER_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorOwner (pSD, &psidOwner, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorOwner failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Get the group
    //

    if (si & GROUP_SECURITY_INFORMATION)
    {
        if (!GetSecurityDescriptorGroup (pSD, &psidGroup, &bDefaulted))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: GetSecurityDescriptorGroup failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Convert the DS access control lists into file system
    // access control lists
    //

    if (pDacl)
    {
        dwResult = MapSecurityRights (pDacl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: MapSecurityRights for the DACL failed with %d"),
                     dwResult));
            goto Exit;
        }
    }

    if (pSacl)
    {
        dwResult = MapSecurityRights (pSacl);

        if (dwResult != ERROR_SUCCESS)
        {
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::SetSysvolSecurity: MapSecurityRights for the SACL failed with %d"),
                     dwResult));
            goto Exit;
        }
    }


    //
    // Switch to using the PROTECTED_DACL_SECURITY_INFORMATION and
    // PROTECTED_SACL_SECURITY_INFORMATION flags so that this subdirectory
    // does not inherit settings from it's parent (aka: "protect" it)
    //

    if (si & DACL_SECURITY_INFORMATION)
    {
        si |= PROTECTED_DACL_SECURITY_INFORMATION;
    }

    if (si & SACL_SECURITY_INFORMATION)
    {
        si |= PROTECTED_SACL_SECURITY_INFORMATION;
    }


    //
    // Set the access control information for the file system portion
    //

    dwResult = SetNamedSecurityInfo(lpFileSysPath, SE_FILE_OBJECT, si, psidOwner,
                                 psidGroup, pDacl, pSacl);


Exit:


    return dwResult;
}


//*************************************************************
//
//  MapSecurityRights
//
//  Purpose:     Convert a DS security access list into a
//               file system security access list
//
//  Parameters:
//
//          PACL -- on input, the DS security access list to convert
//                  on output, it is converted to a file system acl
//
//  Return:     ERROR_SUCCESS if successful, other Win32 failure code otherwise
//
//*************************************************************


DWORD
MapSecurityRights (PACL pAcl)
{
    WORD wIndex;
    DWORD dwResult = ERROR_SUCCESS;
    ACE_HEADER *pAceHeader;
    PACCESS_ALLOWED_ACE pAce;
    PACCESS_ALLOWED_OBJECT_ACE pObjectAce;
    ACCESS_MASK AccessMask;

#if DBG
    PSID pSid;
    TCHAR szName[150], szDomain[100];
    DWORD dwName, dwDomain;
    SID_NAME_USE SidUse;
#endif



    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ACL contains %d ACEs"), pAcl->AceCount));


    //
    // Loop through the ACL looking at each ACE entry
    //

    for (wIndex = 0; wIndex < pAcl->AceCount; wIndex++)
    {

        if (!GetAce (pAcl, (DWORD)wIndex, (LPVOID *)&pAceHeader))
        {
            dwResult = GetLastError();
            DebugMsg((DM_WARNING, TEXT("CGroupPolicyObject::MapSecurityRights: GetAce failed with %d"),
                     dwResult));
            goto Exit;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ==================")));


        switch (pAceHeader->AceType)
        {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
                {
                pAce = (PACCESS_ALLOWED_ACE) pAceHeader;
#if DBG
                pSid = (PSID) &pAce->SidStart;
                dwName = ARRAYSIZE(szName);
                dwDomain = ARRAYSIZE(szDomain);

                if (LookupAccountSid (NULL, pSid, szName, &dwName, szDomain,
                                      &dwDomain, &SidUse))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Normal ACE entry for:  Name = %s  Domain = %s"),
                             szName, szDomain));
                }
#endif

                AccessMask = pAce->Mask;
                pAce->Mask &= STANDARD_RIGHTS_ALL;


                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: DS access mask is 0x%x"),
                          AccessMask));

                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Corresponding sysvol permissions follow:")));


                //
                // Read
                //

                if ((AccessMask & ACTRL_DS_READ_PROP) &&
                    (AccessMask & ACTRL_DS_LIST))
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting Read permission")));

                    pAce->Mask |= (SYNCHRONIZE | FILE_LIST_DIRECTORY |
                                            FILE_READ_ATTRIBUTES | FILE_READ_EA |
                                            FILE_READ_DATA | FILE_EXECUTE);
                }


                //
                // Write
                //

                if (AccessMask & ACTRL_DS_WRITE_PROP)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting Write permission")));

                    pAce->Mask |= (SYNCHRONIZE | FILE_WRITE_DATA |
                                            FILE_APPEND_DATA | FILE_WRITE_EA |
                                            FILE_WRITE_ATTRIBUTES | FILE_ADD_FILE |
                                            FILE_ADD_SUBDIRECTORY);
                }


                //
                // Misc
                //

                if (AccessMask & ACTRL_DS_CREATE_CHILD)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting directory creation permission")));

                    pAce->Mask |= (FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE);
                }

                if (AccessMask & ACTRL_DS_DELETE_CHILD)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Granting directory delete permission")));

                    pAce->Mask |= FILE_DELETE_CHILD;
                }


                //
                // Inheritance
                //

                pAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);

                }
                break;


            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Clearing access mask in DS object ACE entry")));
                pObjectAce = (PACCESS_ALLOWED_OBJECT_ACE) pAceHeader;
                pObjectAce->Mask = 0;
                break;

            default:
                DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: Unknown ACE type 0x%x"), pAceHeader->AceType));
                break;
        }

        DebugMsg((DM_VERBOSE, TEXT("CGroupPolicyObject::MapSecurityRights: ==================")));
    }

Exit:

    return dwResult;
}


BOOL GetStringSid(LPTSTR szSamName, LPTSTR *szStringSid)
{
    const DOMAIN_BUFFER_LEN_IN_CHARS    = 64;
    const SID_BUFFER_LEN                = 256;

    PSID            pSid = NULL;
    LPWSTR          szDomain = NULL;
    ULONG           uDomainLen = 0;
    SID_NAME_USE    snuSidType;
    BOOL            bIsSid = FALSE;
    ULONG           uSidLen = 0;
    BOOL            bRet = FALSE;

    uSidLen = SID_BUFFER_LEN;

    pSid = (SID*) LocalAlloc(LPTR, uSidLen);

    if (!pSid) {
        DebugMsg((DM_WARNING, L"GetStringSid: LocalAlloc failed."));
        goto Exit;
    }

    uDomainLen = DOMAIN_BUFFER_LEN_IN_CHARS;

    szDomain = (LPWSTR) LocalAlloc(LPTR, uDomainLen * sizeof(WCHAR));

    if (!szDomain) {
        DebugMsg((DM_WARNING, L"GetStringSid: LocalAlloc failed."));
        goto Exit;
    }

    //
    // Translate SID.  A lot of the out parameters, we don't need, but LookupAccountSid
    // can't seem to handle them being NULL.
    //

    if (!LookupAccountName(NULL, szSamName, pSid, &uSidLen, szDomain, &uDomainLen, &snuSidType)) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // Try again with the given buffer sizes.
            //

            // pSid and szDomain are smart pointers and the orig value will get freed
            LocalFree(pSid);
            pSid = NULL;
            LocalFree(szDomain);
            szDomain = NULL;

            pSid = (SID*) LocalAlloc(LPTR, uSidLen);

            if (!pSid) {
                DebugMsg((DM_WARNING, L"GetStringSid: LocalAlloc failed."));
                goto Exit;
            }

            szDomain = (LPWSTR) LocalAlloc(LPTR, uDomainLen * sizeof(WCHAR));

            if (!szDomain) {
                DebugMsg((DM_WARNING, L"GetStringSid: LocalAlloc failed."));
                goto Exit;
            }

            if (!LookupAccountName(NULL, szSamName, pSid, &uSidLen, szDomain, &uDomainLen, &snuSidType)) {
                DebugMsg((DM_WARNING, L"GetStringSid: LookupAccountSid failed with %d.", GetLastError()));
                goto Exit;
            }
        }

        else {
            DebugMsg((DM_WARNING, L"GetStringSid: LookupAccountSid failed with %d.", GetLastError()));
            goto Exit;
        }
    }

    //
    // Convert SID to string.
    //

    if (!ConvertSidToStringSid(pSid, szStringSid)) {
        DebugMsg((DM_WARNING, L"GetStringSid: ConvertSidToStringSid failed with %d.", GetLastError()));
        goto Exit;
    }

    bRet = TRUE;

Exit:
    if (szDomain) {
        LocalFree(szDomain);
    }

    if (pSid) {
        LocalFree(pSid);
    }

    return bRet;
}


BOOL GetUserNameFromStringSid(LPTSTR szStringSid, LPTSTR *szSamName)
{
    const DOMAIN_BUFFER_LEN_IN_CHARS    = 64;
    const SID_BUFFER_LEN                = 256;
    const NAME_BUFFER_LEN_IN_CHARS      = 64;

    LPWSTR          szName = NULL;
    PSID            pSid = NULL;
    LPWSTR          szDomain = NULL;
    ULONG           uDomainLen = 0;
    SID_NAME_USE    snuSidType;
    BOOL            bIsSid = FALSE;
    ULONG           uSidLen = 0;
    ULONG           uNameLen = 0;
    BOOL            bRet = FALSE;
    ULONG           ulNoChars;
    HRESULT         hr;

    if (!ConvertStringSidToSid(szStringSid, &pSid))
    {
        DebugMsg((DM_WARNING, L"GetNameFromStringSid: Cannot ."));
        goto Exit;
    }
    //
    // Allocate buffers to map to name.
    //

    uNameLen = NAME_BUFFER_LEN_IN_CHARS;

    szName = (LPWSTR) LocalAlloc(LPTR, uNameLen * sizeof(WCHAR));

    if (!szName) {
        DebugMsg((DM_WARNING, L"GetNameFromStringSid: LocalAlloc failed."));
        goto Exit;
    }

    uDomainLen = DOMAIN_BUFFER_LEN_IN_CHARS;

    szDomain = (LPWSTR) LocalAlloc(LPTR, uDomainLen * sizeof(WCHAR));

    if (!szDomain) {
        DebugMsg((DM_WARNING, L"GetNameFromStringSid: LocalAlloc failed."));
        goto Exit;
    }

    //
    // Translate SID.  A lot of the out parameters, we don't need, but LookupAccountSid
    // can't seem to handle them being NULL.
    //

    if (!LookupAccountSid(NULL, (SID *)pSid, szName, &uNameLen, szDomain, &uDomainLen, &snuSidType)) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // Try again with the given buffer sizes.
            //

            // szName and szDomain are smart pointers and the orig value will get freed
            LocalFree(szName);
            szName = NULL;
            LocalFree(szDomain);
            szDomain = NULL;

            szName = (LPWSTR) LocalAlloc(LPTR, uNameLen * sizeof(WCHAR));

            if (!szName) {
                DebugMsg((DM_WARNING, L"GetNameFromStringSid: LocalAlloc failed."));
                goto Exit;
            }

            szDomain = (LPWSTR) LocalAlloc(LPTR, uDomainLen * sizeof(WCHAR));

            if (!szDomain) {
                DebugMsg((DM_WARNING, L"GetNameFromStringSid: LocalAlloc failed."));
                goto Exit;
            }

            if (!LookupAccountSid(NULL, pSid, szName, &uNameLen, szDomain, &uDomainLen, &snuSidType)) {
                DebugMsg((DM_WARNING, L"GetNameFromStringSid: LookupAccountSid failed with 0x%x.", GetLastError()));
                goto Exit;
            }
        }

        else {
            DebugMsg((DM_WARNING, L"GetNameFromStringSid: LookupAccountSid failed with 0x%x.", GetLastError()));
            goto Exit;
        }
    }

    // space for domain\\username

    hr = S_OK;
    ulNoChars = lstrlen(szName) + (szDomain ? lstrlen(szDomain) : 1) + 3;
    *szSamName = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);

    if (!(*szSamName))
    {
        DebugMsg((DM_WARNING, L"GetNameFromStringSid: failed to allocate memory for samname with 0x%x.", GetLastError()));
        goto Exit;
    }
    if (szDomain && szDomain[0])
    {
        hr = StringCchCopy((*szSamName), ulNoChars, szDomain);
        if (SUCCEEDED(hr)) 
        {
            hr = StringCchCat ((*szSamName), ulNoChars, L"\\");
        }
    }
    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCat((*szSamName), ulNoChars, szName);
    }

    if (SUCCEEDED(hr))         
    {
        bRet = TRUE;
    }
    else
    {
        DebugMsg((DM_WARNING, L"GetNameFromStringSid: failed to copy sam name with 0x%x.", hr));
        LocalFree(*szSamName);
        *szSamName = NULL;
        goto Exit;
    }

Exit:
    if (szDomain) {
        LocalFree(szDomain);
    }

    if (szName) {
        LocalFree(szName);
    }

    if (pSid) {
        LocalFree(pSid);
    }

    return bRet;
}


HRESULT UnEscapeLdapPath(LPWSTR szDN, LPWSTR *szUnEscapedPath)
/*++

Routine Description:
    Unescapes the given ldap path and returns. Note that the input is LPWSTR
    and output is BSTR. Also input should not be prefixed with LDAP:// and output
    also will not be prefixxed with LDAP://
    
    
Arguments:

    [in]    szDN          - The LDAP path to the object to escape

    [out]   pbstrEscapedPath    - Escaped path
Return Value:

    S_OK on success.  Error code otherwise
    On failure the corresponding error code will be returned.
    Any API calls that are made in this function might fail and these error
    codes will be returned directly.

--*/

{
    HRESULT                     hr                  = S_OK;
    IADsPathname               *pADsPath            = NULL;
    BSTR                        bstrPath            = NULL;
    BSTR                        bstrUnescapedPath   = NULL;

    *szUnEscapedPath = NULL;

    //
    // Initialize path
    //

    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**) &pADsPath);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    bstrPath = SysAllocString(szDN);

    if (!bstrPath) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: BSTR allocation failed")));
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pADsPath->put_EscapedMode(ADS_ESCAPEDMODE_ON);
    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: Failed to set escaped mode(1) with 0x%x"), hr));
        goto Exit;
    }

    hr = pADsPath->Set(bstrPath, ADS_SETTYPE_DN);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: Set failed with 0x%x"), hr));
        goto Exit;
    }

    //
    // Set the escape mode
    //

    hr = pADsPath->put_EscapedMode(ADS_ESCAPEDMODE_OFF);
    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: Failed to set escaped mode with 0x%x"), hr));
        goto Exit;
    }


    hr = pADsPath->Retrieve(ADS_FORMAT_X500_DN, &bstrUnescapedPath);

    if (FAILED(hr)) {
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: Retrieve failed with 0x%x"), hr));
        goto Exit;
    }

    ULONG ulNoChars = lstrlen(bstrUnescapedPath)+1;
    *szUnEscapedPath = (LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)*ulNoChars);

    if (!(*szUnEscapedPath))
    {
        hr = E_OUTOFMEMORY;
        DebugMsg((DM_WARNING, TEXT("EscapeLdapPath: Failed to allocate memory with 0x%x"), hr));
        goto Exit;
    }

    hr = StringCchCopy(*szUnEscapedPath, ulNoChars, bstrUnescapedPath);
    ASSERT(SUCCEEDED(hr));

Exit:
    if (bstrPath)
    {
        SysFreeString(bstrPath);
    }

    if (bstrUnescapedPath)
    {
        SysFreeString(bstrUnescapedPath);
    }

    if (pADsPath)
    {
        pADsPath->Release();
    }

    return S_OK;
}

#if !defined(_WIN64)
/*+-------------------------------------------------------------------------*
 * IsWin64
 *
 * Returns true if we're running on Win64, false otherwise.
 *--------------------------------------------------------------------------*/

bool IsWin64()
{
    /*
     * get a pointer to kernel32!GetSystemWow64Directory
     */

    bool  bWin64 = false;
    DWORD LastError = GetLastError();

    HMODULE hmod = GetModuleHandle (_T("kernel32.dll"));
    if (hmod == NULL)
        goto IsWin64_Exit;

    UINT (WINAPI* pfnGetSystemWow64Directory)(LPTSTR, UINT);
    (FARPROC&)pfnGetSystemWow64Directory = GetProcAddress (hmod, "GetSystemWow64DirectoryW");

    if (pfnGetSystemWow64Directory == NULL)
        goto IsWin64_Exit;

    /*
     * if GetSystemWow64Directory fails and sets the last error to
     * ERROR_CALL_NOT_IMPLEMENTED, we're on a 32-bit OS
     */
    TCHAR szWow64Dir[MAX_PATH];
    if (((pfnGetSystemWow64Directory)(szWow64Dir, ARRAYSIZE(szWow64Dir)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED))
    {
        goto IsWin64_Exit;
    }

    /*
     * if we get here, we're on Win64
     */
    bWin64 = true;

 IsWin64_Exit:

    SetLastError(LastError);
 
    return bWin64;   
}
#endif // !defined(_WIN64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\gptext.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include <lm.h>
#include <ole2.h>
#include <olectl.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commctrl.h>
#include <commdlg.h>
#include <prsht.h>
#include <mmc.h>
#include <activeds.h>
#include <gpedit.h>
#define _USERENV_NO_LINK_APIS_ 1
#include <userenv.h>
#include <userenvp.h>
#include <wbemcli.h>
#include <tchar.h>
#include <winsock2.h>

class CScriptsSnapIn;
class CPolicyComponentData;

#include "debug.h"
#include "util.h"
#include "pcommon.h"

//
// From comctrlp.h
//
#if (_WIN32_IE >= 0x0501)
#define UDS_UNSIGNED            0x0200
#endif

//
// Resource ids
//

#define IDS_SCRIPTS_NAME                        1
#define IDS_SCRIPTS_NAME_MACHINE                2
#define IDS_SCRIPTS_NAME_USER                   3
#define IDS_NAME                                4
#define IDS_STATE                               5
#define IDS_SETTING                             6
#define IDS_PARAMETERS                          7
#define IDS_ENABLED                             8
#define IDS_DISABLED                            9
#define IDS_NOTCONFIGURED                      10
#define IDS_LOGON                              11
#define IDS_LOGOFF                             12
#define IDS_STARTUP                            13
#define IDS_SHUTDOWN                           14
#define IDS_BROWSEFILTER                       15
#define IDS_BROWSE                             16
#define IDS_SCRIPT_EDIT                        17
#define IDS_SCRIPT_FILTER                      18
#define IDS_POLICY_NAME                        19
#define IDS_POLICY_NAME_MACHINE                20
#define IDS_POLICY_NAME_USER                   21
#define IDS_TEMPLATES                          22
#define IDS_TEMPLATESDESC                      23
#define IDS_SIZE                               24
#define IDS_MODIFIED                           25
#define IDS_POLICYFILTER                       26
#define IDS_POLICYTITLE                        27
#define IDS_DEFAULTTEMPLATES                   28
#define IDS_LISTBOX_SHOW                       29
#define IDS_VALUE                              31
#define IDS_VALUENAME                          32
#define IDS_VALUENAMENOTUNIQUE                 33
#define IDS_EMPTYVALUENAME                     34
#define IDS_VALUEDATANOTUNIQUE                 35
#define IDS_EMPTYVALUEDATA                     36
#define IDS_FILTERING                          37
#define IDS_FILTERINGDESC                      38
#define IDS_ADDITIONALTTEMPLATES               39

#define IDS_GPONAME                            41
#define IDS_MULTIPLEGPOS                       42
#define IDS_DESCTEXT                           43
#define IDS_LASTEXECUTED                       44
#define IDS_SAVEFAILED                         45
#define IDS_DISPLAYPROPERTIES                  46
#define IDS_EXTRAREGSETTINGS                   47
#define IDS_STRINGTOOLONG                      48
#define IDS_WORDTOOLONG                        49
#define IDS_ErrOUTOFMEMORY                     50

#define IDS_ParseErr_UNEXPECTED_KEYWORD        51
#define IDS_ParseErr_UNEXPECTED_EOF            52
#define IDS_ParseErr_DUPLICATE_KEYNAME         53
#define IDS_ParseErr_DUPLICATE_VALUENAME       54
#define IDS_ParseErr_NO_KEYNAME                55
#define IDS_ParseErr_NO_VALUENAME              56
#define IDS_ParseErr_NO_VALUE                  57
#define IDS_ParseErr_NOT_NUMERIC               58
#define IDS_ParseErr_DUPLICATE_ITEMNAME        59
#define IDS_ParseErr_NO_ITEMNAME               60
#define IDS_ParseErr_DUPLICATE_ACTIONLIST      61
#define IDS_ParseErr_STRING_NOT_FOUND          62
#define IDS_ParseErr_UNMATCHED_DIRECTIVE       63
#define IDS_ParseErr_DUPLICATE_HELP            64
#define IDS_ParseErr_DUPLICATE_CLIENTEXT       65
#define IDS_ParseErr_INVALID_CLIENTEXT         66
#define IDS_ParseErr_DUPLICATE_SUPPORTED       67
#define IDS_ParseErr_MISSINGVALUEON_OR_OFF     68

#define IDS_ParseFmt_MSG_FORMAT                90
#define IDS_ParseFmt_FOUND                     91
#define IDS_ParseFmt_EXPECTED                  92
#define IDS_ParseFmt_FATAL                     93

#define IDS_ENTRYREQUIRED                     100
#define IDS_INVALIDNUM                        101
#define IDS_NUMBERTOOLARGE                    102
#define IDS_NUMBERTOOSMALL                    103
#define IDS_POLICYCHANGEDFAILED               104
#define IDS_INVALIDADMFILE                    105

#define IDS_IPSEC_NAME                        200
#define IDS_PSCHED_NAME                       201
#define IDS_WIRELESS_NAME                     202

#define IDS_LOGON_DESC                        225
#define IDS_LOGOFF_DESC                       226
#define IDS_STARTUP_DESC                      227
#define IDS_SHUTDOWN_DESC                     228
#define IDS_SCRIPTS_DESC                      229
#define IDS_SCRIPTS_USER_DESC                 230
#define IDS_SCRIPTS_COMPUTER_DESC             231
#define IDS_SCRIPTS_LOGON                     232
#define IDS_SCRIPTS_LOGOFF                    233
#define IDS_SCRIPTS_STARTUP                   234
#define IDS_SCRIPTS_SHUTDOWN                  235
#define IDS_POLICY_DESC                       236
#define IDS_NONE                              237
#define IDS_RSOP_ADMFAILED                    238

#define IDS_BINARYDATA                        240
#define IDS_UNKNOWNDATA                       241
#define IDS_EXSETROOT_DESC                    242
#define IDS_EXSET_DESC                        243
#define IDS_PREFERENCE                        246
#define IDS_SUPPORTEDDESC                     247
#define IDS_NOSUPPORTINFO                     248

#define IDS_FAILED_RSOPFMT                    250


//
// Menus
//

#define IDM_TEMPLATES            1
#define IDM_TEMPLATES2           3
#define IDM_FILTERING            4


//
// Icons
//

#define IDI_POLICY               1
#define IDI_POLICY2              2
#define IDI_POLICY3              3
#define IDI_DOCUMENT             4
#define IDI_SCRIPT               5
#define IDI_FILTER               6


//
// Bitmaps
//

#define IDB_16x16                1
#define IDB_32x32                2


//
// Dialogs
//

#define IDD_SCRIPT             100
#define IDC_SCRIPT_TITLE       101
#define IDC_SCRIPT_HEADING     102
#define IDC_SCRIPT_LIST        103
#define IDC_SCRIPT_UP          104
#define IDC_SCRIPT_DOWN        105
#define IDC_SCRIPT_ADD         106
#define IDC_SCRIPT_EDIT        107
#define IDC_SCRIPT_REMOVE      108
#define IDC_SCRIPT_SHOW        109

#define IDD_SCRIPT_EDIT        150
#define IDC_SCRIPT_NAME        151
#define IDC_SCRIPT_ARGS        152
#define IDC_SCRIPT_BROWSE      153


#define IDD_POLICY             200
#define IDC_POLICY             201
#define IDC_POLICY_TITLE       202
#define IDC_POLICY_SETTINGS    203
#define IDC_POLICY_PREVIOUS    204
#define IDC_POLICY_NEXT        205
#define IDC_POLICYICON         206
#define IDC_NOCONFIG           207
#define IDC_ENABLED            208
#define IDC_DISABLED           209
#define IDC_SUPPORTED          210
#define IDC_SUPPORTEDTITLE     211
#define IDD_SETTINGCTRL       1000

#define IDD_POLICY_HELP        225
#define IDC_POLICY_HELP        226

#define IDD_POLICY_PRECEDENCE  275
#define IDC_POLICY_PRECEDENCE  276

#define IDD_TEMPLATES          300
#define IDC_TEMPLATE_TEXT      301
#define IDC_TEMPLATELIST       302
#define IDC_ADDTEMPLATES       303
#define IDC_REMOVETEMPLATES    304

#define IDD_POLICY_LBADD       400
#define IDD_POLICY_LBADD2      401
#define IDC_POLICY_VALUENAME   402
#define IDC_POLICY_VALUEDATA   403

#define IDD_POLICY_SHOWLISTBOX 500
#define IDC_POLICY_LISTBOX     501
#define IDC_POLICY_ADD         502
#define IDC_POLICY_REMOVE      503

#define IDD_POLICY_FILTERING   600
#define IDC_SUPPORTEDOPTION    601
#define IDC_FILTERLIST         602
#define IDC_SELECTALL          603
#define IDC_DESELECTALL        604
#define IDC_SHOWCONFIG         605
#define IDC_SHOWPOLICIES       606
#define IDC_SUPPORTEDONTITLE   607

#define IDC_STATIC             608
#define IDC_FILTERING_ICON     609


//
// Help ids
//

#define IDH_SCRIPT_TITLE         1
#define IDH_SCRIPT_HEADING       2
#define IDH_SCRIPT_LIST          3
#define IDH_SCRIPT_UP            4
#define IDH_SCRIPT_DOWN          5
#define IDH_SCRIPT_ADD           6
#define IDH_SCRIPT_EDIT          7
#define IDH_SCRIPT_REMOVE        8
#define IDH_SCRIPT_SHOW          9

#define IDH_SCRIPT_NAME         10
#define IDH_SCRIPT_ARGS         11
#define IDH_SCRIPT_BROWSE       12


//
// Error dialog defines
//

#define IDD_ERROR_ADMTEMPLATES  800
#define IDC_ERRORTEXT           801
#define IDC_DETAILSBORDER       802
#define IDC_DETAILSTEXT         803
#define IDC_ERROR_ICON          804



//
// Global variables
//

extern LONG g_cRefThisDll;
extern HINSTANCE g_hInstance;
extern TCHAR g_szSnapInLocation[];
extern CRITICAL_SECTION  g_ADMCritSec;
extern TCHAR g_szDisplayProperties[];


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL         0x10000000
#endif


//
// Help
//

#define HELP_FILE           TEXT("gptext.hlp")
#define IDH_HELPFIRST       5000


//
// Structures
//

#define MAX_DISPLAYNAME_SIZE    100


typedef struct _RESULTITEM
{
    DWORD        dwID;
    DWORD        dwNameSpaceItem;
    INT          iStringID;
    INT          iDescStringID;
    INT          iImage;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
} RESULTITEM, *LPRESULTITEM;


typedef struct _NAMESPACEITEM
{
    DWORD        dwID;
    DWORD        dwParent;
    INT          iStringID;
    INT          iDescStringID;
    INT          cChildren;
    TCHAR        szDisplayName[MAX_DISPLAYNAME_SIZE];
    INT          cResultItems;
    LPRESULTITEM pResultItems;
    const GUID   *pNodeID;
} NAMESPACEITEM, *LPNAMESPACEITEM;



//
// Functions to create class factories
//

HRESULT CreateScriptsComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
BOOL InitScriptsNameSpace();
HRESULT RegisterScripts(void);
HRESULT UnregisterScripts(void);

HRESULT CreatePolicyComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv);
HRESULT RegisterPolicy(void);
HRESULT UnregisterPolicy(void);


HRESULT RegisterIPSEC(void);
HRESULT UnregisterIPSEC(void);
HRESULT RegisterPSCHED(void);
HRESULT UnregisterPSCHED(void);
HRESULT RegisterWireless(void);
HRESULT UnregisterWireless(void);


//
// Private message that refreshes the button status
//
#define WM_REFRESHDISPLAY   (WM_USER + 532)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\gptext.cpp ===
#include <gptext.h>
#include <initguid.h>
#include <gpedit.h>



//
// Global variables for this DLL
//

LONG g_cRefThisDll = 0;
HINSTANCE g_hInstance;
TCHAR g_szSnapInLocation[] = TEXT("%SystemRoot%\\System32\\gptext.dll");
CRITICAL_SECTION  g_ADMCritSec;
TCHAR g_szDisplayProperties[150] = {0};


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
       g_hInstance = hInstance;
       DisableThreadLibraryCalls(hInstance);
       InitScriptsNameSpace();
       InitDebugSupport();
       InitializeCriticalSection (&g_ADMCritSec);

       LoadString (hInstance, IDS_DISPLAYPROPERTIES, g_szDisplayProperties, ARRAYSIZE(g_szDisplayProperties));
    }

    if (dwReason == DLL_PROCESS_DETACH)
    {
        DeleteCriticalSection (&g_ADMCritSec);
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    hr = CreateScriptsComponentDataClassFactory (rclsid, riid, ppv);

    if (hr != CLASS_E_CLASSNOTAVAILABLE)
        return S_OK;


    hr = CreatePolicyComponentDataClassFactory (rclsid, riid, ppv);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    RegisterScripts();
    RegisterPolicy();
    RegisterIPSEC();
    RegisterWireless();
    RegisterPSCHED();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    UnregisterScripts();
    UnregisterPolicy();
    UnregisterIPSEC();
    UnregisterWireless();
    UnregisterPSCHED();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\ipsecext.h ===
#include "polstore2.h"

HRESULT
CreateChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    );

HRESULT
RetrieveIPSECPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR pszIPSecPolicy,
    DWORD dwPolLen,
    LPWSTR pszIPSecPolicyName,
    DWORD dwPolNameLen,
    LPWSTR pszIPSecPolicyDescription,
    DWORD dwPolDescLen);


DWORD
DeleteIPSECPolicyFromRegistry(
    );

DWORD
WriteIPSECPolicyToRegistry(
    LPWSTR pszIPSecPolicyPath,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    );


HRESULT
RegisterIPSEC(void);

HRESULT
UnregisterIPSEC(void);

VOID
PingPolicyAgent(
    );

VOID
NotifyPolicyAgent(
    );

WCHAR *
StripPrefixIpsec(
    WCHAR *pwszPath
    );

WCHAR *
StripLinkPrefixIpsec(
    WCHAR *pwszPath
    );
    
HRESULT
CreatePolstoreGPOInfo(
    PGROUP_POLICY_OBJECT pGPO,
    UINT32 uiPrecedence,
    UINT32 uiTotalGPOs,
    PGPO_INFO pGPOInfo
    );

HRESULT
FreePolstoreGPOInfo(
    PGPO_INFO pGPOInfo
    );

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) { \
        goto error;  \
    }

#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\ipsecext.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <iadsp.h>
#include "ipsecext.h"
#include "SmartPtr.h"
#include "wbemtime.h"
#include <strsafe.h>

#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{e437bc1c-aa7d-11d2-a382-00c04f991e27}")

#define POLICY_PATH   TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy")

LPWSTR GetAttributes[] = {L"ipsecOwnersReference", L"ipsecName", L"description"};




HRESULT
RegisterIPSEC(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString (g_hInstance, IDS_IPSEC_NAME, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicyEx"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessIPSECPolicyEx"),
                (lstrlen(TEXT("ProcessIPSECPolicyEx")) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("GenerateGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("GenerateIPSECPolicy"),
                (lstrlen(TEXT("GenerateIPSECPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    (void) StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    dwValue = 0;
    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}


HRESULT
UnregisterIPSEC(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}


DWORD
ProcessIPSECPolicyEx(
    DWORD dwFlags,                           // GPO_INFO_FLAGS
    HANDLE hToken,                           // User or machine token
    HKEY hKeyRoot,                           // Root of registry
    PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    BOOL *pbAbort,                           // If true, then abort GPO processing
    PFNSTATUSMESSAGECALLBACK pStatusCallback,// Callback function for displaying status messages
    IWbemServices *pWbemServices,            // Pointer to namespace to log diagnostic mode data
                                             // Note, this will be NULL when Rsop logging is disabled
    HRESULT      *pRsopStatus                // RSOP Logging succeeded or not.
    )

{
    
    // Call ProcessIPSECPolicy & get path -> polstore funcs
    WCHAR szIPSECPolicy[MAX_PATH];        //policy path
    WCHAR szIPSECPolicyName[MAX_PATH];    //policy name
    WCHAR szIPSECPolicyDescription[512];  //policy descr
    HRESULT hr = S_OK;
    DWORD dwError = ERROR_SUCCESS;
    PGROUP_POLICY_OBJECT pGPO = NULL;
    GPO_INFO GPOInfo;
    BOOL ForcePolicyReload = FALSE;

    //
    // ASSERT: CoInitializeEx was called before this function
    //         was invoked.
    //

    ForcePolicyReload = (dwFlags & GPO_INFO_FLAG_FORCED_REFRESH) ||
    					!(dwFlags & GPO_INFO_FLAG_NOCHANGES);

	if (!ForcePolicyReload) {
		NotifyPolicyAgent();
	} else {	
	    memset(szIPSECPolicy, 0, sizeof(WCHAR)*MAX_PATH);
	    memset(szIPSECPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
	    memset(szIPSECPolicyDescription, 0, sizeof(WCHAR)*512);

	    // First process the Deleted GPO List. If there is a single
	    // entry on the GPO list, just delete the entire list.
	    // Example Rex->Cassius->Brutus. If the delete List has
	    // Cassius to be deleted, then really, we shouldn't be deleting
	    // our registry entry because we're interested in Brutus which
	    // has not be deleted. But in our case, the pChangedGPOList will
	    // have all the information, so Brutus gets written back in the
	    // next stage.
	    //
	    if (pDeletedGPOList) {
		    dwError = IPSecChooseDriverBootMode(
	            HKEY_LOCAL_MACHINE,
	            IPSEC_DIRECTORY_PROVIDER,
	            POL_ACTION_UNASSIGN
	            );
		    hr = HRESULT_FROM_WIN32(dwError);
            if (dwError) {
                goto error;
            }

	        DeleteIPSECPolicyFromRegistry();

	        //
	        //  Also Clear WMI store if no GPO's applied and logging enabled
	        //
	        
	        if (!pChangedGPOList && pWbemServices) {
	            hr = IPSecClearWMIStore(
	                    pWbemServices
	                    );
	            if (FAILED(hr)) {
	                    goto error;
	            }
	            DebugMsg( (DM_WARNING, L"ipsecext::ProcessIPSECPolicyEx: IPSec WMI store cleared") );
	        }
	    }
	    
	    if(pChangedGPOList) {

	        DWORD dwNumGPO = 0;
	        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
	            dwNumGPO++;

	            //
	            // Write only the last, highest precedence policy to registry
	            //
	            if(pGPO->pNext == NULL) {
	                hr = RetrieveIPSECPolicyFromDS(
	                    pGPO,
	                    szIPSECPolicy,
	                    ARRAYSIZE(szIPSECPolicy),
	                    szIPSECPolicyName,
	                    ARRAYSIZE(szIPSECPolicyName),
	                    szIPSECPolicyDescription,
	                    ARRAYSIZE(szIPSECPolicyDescription)
	                    );
	                if (FAILED(hr)) {
	                    goto success; // WMI store still consistent
	                }

	                dwError = WriteIPSECPolicyToRegistry(
	                    szIPSECPolicy,
	                    szIPSECPolicyName,
	                    szIPSECPolicyDescription
	                    );
	                if (dwError) {
	                    goto success; // WMI store still consistent
	                }
				    dwError = IPSecChooseDriverBootMode(
				                HKEY_LOCAL_MACHINE,
				                IPSEC_DIRECTORY_PROVIDER,
				                POL_ACTION_ASSIGN
				                );
				    hr = HRESULT_FROM_WIN32(dwError);				    
	                if (dwError) {
	                    goto error;
	                }
	            }
	        }
	        DebugMsg( (DM_WARNING, L"ipsecext::ProcessIPSECPolicyEx: dwNumGPO: %d", dwNumGPO) );

	        // Write WMI log if logging enabled
	        if (pWbemServices) {
	            DWORD dwPrecedence = dwNumGPO;
	            for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
	                hr = RetrieveIPSECPolicyFromDS(
	                    pGPO,
	                    szIPSECPolicy,
	                    ARRAYSIZE(szIPSECPolicy),
	                    szIPSECPolicyName,
	                    ARRAYSIZE(szIPSECPolicyName),
	                    szIPSECPolicyDescription,
	                    ARRAYSIZE(szIPSECPolicyDescription)
	                    );
	                if (FAILED(hr)) {
	                    goto error;
	                }

	                LPWSTR pszIPSECPolicy = szIPSECPolicy + wcslen(L"LDAP://");
	                DebugMsg( (DM_WARNING, L"ipsecext::ProcessIPSECPolicyEx: pszIPSECPolicy: %s", pszIPSECPolicy) );

	                (VOID) CreatePolstoreGPOInfo(
	                           pGPO,
	                           dwPrecedence--,
	                           dwNumGPO,
	                           &GPOInfo
	                           );

	                hr = WriteDirectoryPolicyToWMI(
	                    0, //pszMachineName
	                    pszIPSECPolicy,
	                    &GPOInfo,
	                    pWbemServices
	                    );
	                (VOID) FreePolstoreGPOInfo(&GPOInfo);
	                if (FAILED(hr)) {
	                    DebugMsg( (DM_WARNING, L"ipsecext::ProcessIPSECPolicyEx: WriteDirectoryPolicyToWMI failed: 0x%x", hr) );
	                    goto error;
	                }
	            }
	        }
	    }
	    
	    DebugMsg( (DM_WARNING, L"ipsecext::ProcessIPSECPolicyEx completed") );

	    PingPolicyAgent();
	}

success:    
    *pRsopStatus = S_OK;
    return(ERROR_SUCCESS);
    
error:
    
    *pRsopStatus = hr;
    return(ERROR_POLICY_OBJECT_NOT_FOUND);

}


DWORD 
GenerateIPSECPolicy(   
    DWORD dwFlags,
    BOOL *pbAbort,
    WCHAR *pwszSite,
    PRSOP_TARGET pMachTarget,
    PRSOP_TARGET pUserTarget 
    )
{

    // Call ProcessIPSECPolicy & get path -> polstore funcs
    WCHAR szIPSECPolicy[MAX_PATH];        //policy path
    WCHAR szIPSECPolicyName[MAX_PATH];    //policy name
    WCHAR szIPSECPolicyDescription[512];  //policy descr
    HRESULT hr = S_OK;
    PGROUP_POLICY_OBJECT pGPO = NULL;
    GPO_INFO GPOInfo;


    //
    // ASSERT: CoInitializeEx was called before this function
    //         was invoked.
    //

    memset(szIPSECPolicy, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szIPSECPolicyName, 0, sizeof(WCHAR)*MAX_PATH);
    memset(szIPSECPolicyDescription, 0, sizeof(WCHAR)*512);
    
    ////start
    PGROUP_POLICY_OBJECT  pChangedGPOList = NULL;
    IWbemServices *pWbemServices = NULL;
    
    if(pMachTarget) {
        pChangedGPOList = pMachTarget->pGPOList;
        pWbemServices = pMachTarget->pWbemServices;
    }

    if(pUserTarget) {
        pChangedGPOList = pUserTarget->pGPOList;
        pWbemServices = pUserTarget->pWbemServices;
    }

    if(pChangedGPOList && pWbemServices) {

        DWORD dwNumGPO = 0;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            dwNumGPO++;
        }
        DebugMsg( (DM_WARNING, L"ipsecext::GenerateIPSECPolicy: dwNumGPO: %d", dwNumGPO) );
        
        DWORD dwPrecedence = dwNumGPO;
        for(pGPO = pChangedGPOList; pGPO; pGPO = pGPO->pNext) {
            hr = RetrieveIPSECPolicyFromDS(
                pGPO,
                szIPSECPolicy,
                ARRAYSIZE(szIPSECPolicy),
                szIPSECPolicyName,
                ARRAYSIZE(szIPSECPolicyName),
                szIPSECPolicyDescription,
                ARRAYSIZE(szIPSECPolicyDescription)
                );
            if (FAILED(hr)) {
                goto error;
            }
            
            LPWSTR pszIPSECPolicy = szIPSECPolicy + wcslen(L"LDAP://");
            DebugMsg( (DM_WARNING, L"ipsecext::GenerateIPSECPolicy: pszIPSECPolicy: %s", pszIPSECPolicy) );

            (VOID) CreatePolstoreGPOInfo(
                       pGPO,
                       dwPrecedence--,
                       dwNumGPO,
                       &GPOInfo
                       );

            hr = WriteDirectoryPolicyToWMI(
                0, //pszMachineName
                pszIPSECPolicy,
                &GPOInfo,
                pWbemServices
                );
            (VOID) FreePolstoreGPOInfo(&GPOInfo);
            if (FAILED(hr)) {
                DebugMsg( (DM_WARNING, L"ipsecext::GenerateIPSECPolicy: WriteDirectoryPolicyToWMI failed: 0x%x", hr) );
                goto error;
            }

        }
    }
    
    DebugMsg( (DM_WARNING, L"ipsecext::GenerateIPSECPolicy completed") );
    
    return(ERROR_SUCCESS);
    
error:
    
    return(ERROR_POLICY_OBJECT_NOT_FOUND);

}


HRESULT
CreatePolstoreGPOInfo(
    PGROUP_POLICY_OBJECT pGPO,
    UINT32 uiPrecedence,
    UINT32 uiTotalGPOs,
    PGPO_INFO pGPOInfo
    )
{
  XBStr xbstrCurrentTime;
  HRESULT hr;
    
  memset(pGPOInfo, 0, sizeof(GPO_INFO));
  
  pGPOInfo->uiPrecedence = uiPrecedence;
  pGPOInfo->uiTotalGPOs = uiTotalGPOs;
  pGPOInfo->bsGPOID = SysAllocString(
                         StripPrefixIpsec(pGPO->lpDSPath)
                         );
  pGPOInfo->bsSOMID = SysAllocString(
                         StripLinkPrefixIpsec(pGPO->lpLink)
                         );
  // (Failing safe above by ignoring mem alloc errors)
  hr = GetCurrentWbemTime(xbstrCurrentTime);
  if ( FAILED (hr) ) {
      pGPOInfo->bsCreationtime = 0;
  }
  else {
      pGPOInfo->bsCreationtime = xbstrCurrentTime.Acquire();
  }

  return S_OK;
}


HRESULT
FreePolstoreGPOInfo(
    PGPO_INFO pGPOInfo
    )
{
    if (pGPOInfo && pGPOInfo->bsCreationtime) {
        SysFreeString(pGPOInfo->bsCreationtime);
    }
    if (pGPOInfo && pGPOInfo->bsGPOID) {
        SysFreeString(pGPOInfo->bsGPOID);
    }
    if (pGPOInfo && pGPOInfo->bsSOMID) {
        SysFreeString(pGPOInfo->bsSOMID);
    }


    return S_OK;
}
 
HRESULT
CreateChildPath(
    LPWSTR pszParentPath,
    LPWSTR pszChildComponent,
    BSTR * ppszChildPath
    )
{
    HRESULT hr = S_OK;
    IADsPathname     *pPathname = NULL;

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(pszParentPath, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->AddLeafElement(pszChildComponent);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Retrieve(ADS_FORMAT_X500, ppszChildPath);
    BAIL_ON_FAILURE(hr);

error:
    if (pPathname) {
        pPathname->Release();
    }

    return(hr);
}



HRESULT
RetrieveIPSECPolicyFromDS(
    PGROUP_POLICY_OBJECT pGPOInfo,
    LPWSTR pszIPSecPolicy,
    DWORD dwPolLen,
    LPWSTR pszIPSecPolicyName,
    DWORD dwPolNameLen,
    LPWSTR pszIPSecPolicyDescription,
    DWORD dwPolDescLen
    )
{
    LPWSTR pszMachinePath = NULL;
    BSTR pszMicrosoftPath = NULL;
    BSTR pszWindowsPath = NULL;
    BSTR pszIpsecPath = NULL;
    IDirectoryObject * pDirectoryObject = NULL;
    IDirectoryObject * pIpsecObject = NULL;
    BOOL bFound = FALSE;
    HRESULT hr = S_OK;

    LPWSTR pszOwnersReference = L"ipsecOwnersReference";

    PADS_ATTR_INFO pAttributeEntries = NULL;
    DWORD dwNumAttributesReturned = 0;

    DWORD i = 0;
    PADS_ATTR_INFO pAttributeEntry = NULL;


    pszMachinePath = pGPOInfo->lpDSPath;

    // Build the fully qualified ADsPath for my object

    hr = CreateChildPath(
                pszMachinePath,
                L"cn=Microsoft",
                &pszMicrosoftPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszMicrosoftPath,
                L"cn=Windows",
                &pszWindowsPath
                );
    BAIL_ON_FAILURE(hr);

    hr = CreateChildPath(
                pszWindowsPath,
                L"cn=ipsec",
                &pszIpsecPath
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsOpenObject(
            pszIpsecPath,
            NULL,
            NULL,
            ADS_SECURE_AUTHENTICATION | ADS_USE_SEALING | ADS_USE_SIGNING,
            IID_IDirectoryObject,
            (void **)&pIpsecObject
            );
    BAIL_ON_FAILURE(hr);

    hr = pIpsecObject->GetObjectAttributes(
                        GetAttributes,
                        3,
                        &pAttributeEntries,
                        &dwNumAttributesReturned
                        );
    BAIL_ON_FAILURE(hr);

    if (dwNumAttributesReturned == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }

    //
    // Process the PathName
    //

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"ipsecOwnersReference")) {

            hr = StringCchCopy(pszIPSecPolicy, dwPolLen, L"LDAP://");
            BAIL_ON_FAILURE(hr);
            
            hr = StringCchCat(pszIPSecPolicy, dwPolLen, pAttributeEntry->pADsValues->DNString);
            BAIL_ON_FAILURE(hr);

            bFound = TRUE;
            break;
        }
    }

    if (!bFound) {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Process the name
    //
    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"ipsecName")) {
            hr = StringCchCopy(pszIPSecPolicyName, dwPolNameLen, pAttributeEntry->pADsValues->DNString);
            BAIL_ON_FAILURE(hr);
            break;
        }
    }

    //
    // Process the description
    //

    for (i = 0; i < dwNumAttributesReturned; i++) {

        pAttributeEntry = pAttributeEntries + i;
        if (!_wcsicmp(pAttributeEntry->pszAttrName, L"description")) {
            hr = StringCchCopy(pszIPSecPolicyDescription, dwPolDescLen, pAttributeEntry->pADsValues->DNString);
            BAIL_ON_FAILURE(hr);
            break;
        }
    }


error:

    if (pAttributeEntries) {

        FreeADsMem(pAttributeEntries);
    }

    if (pIpsecObject) {
        pIpsecObject->Release();
    }

    if (pszMicrosoftPath) {
        SysFreeString(pszMicrosoftPath);
    }

    if (pszWindowsPath) {
        SysFreeString(pszWindowsPath);
    }

    if (pszIpsecPath) {
        SysFreeString(pszIpsecPath);
    }

    return(hr);

}


DWORD
DeleteIPSECPolicyFromRegistry(
    )
{

    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwDisp = 0;


    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    TEXT("Software\\Policies\\Microsoft\\Windows\\IPSec"),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    dwError = RegDeleteKey(
                    hKey,
                    L"GPTIPSECPolicy"
                    );

/*
    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSIPSECPolicyPath")
                    );

    dwError = RegDeleteValue(
                    hKey,
                    TEXT("DSIPSECPolicyName")
                    );*/
error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);
}

DWORD
WriteIPSECPolicyToRegistry(
    LPWSTR pszIPSecPolicyPath,
    LPWSTR pszIPSecPolicyName,
    LPWSTR pszIPSecPolicyDescription
    )
{
    DWORD dwError = 0;
    DWORD dwDisp = 0;
    HKEY hKey = NULL;
    DWORD dwFlags = 1;

    dwError = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    POLICY_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisp
                    );
    if (dwError) {
        goto error;
    }


    if (pszIPSecPolicyPath && *pszIPSecPolicyPath) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyPath"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyPath,
                       (lstrlen(pszIPSecPolicyPath) + 1) * sizeof(TCHAR)
                       );

        dwFlags = 1;

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyFlags"),
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwFlags,
                        sizeof(dwFlags)
                       );

    }


    if (pszIPSecPolicyName && *pszIPSecPolicyName) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyName"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyName,
                       (lstrlen(pszIPSecPolicyName) + 1) * sizeof(TCHAR)
                       );
    }





    if (pszIPSecPolicyDescription && *pszIPSecPolicyDescription) {

        dwError = RegSetValueEx (
                        hKey,
                        TEXT("DSIPSECPolicyDescription"),
                        0,
                        REG_SZ,
                        (LPBYTE)pszIPSecPolicyDescription,
                       (lstrlen(pszIPSecPolicyDescription) + 1) * sizeof(TCHAR)
                       );
    }

error:

    if (hKey) {

        RegCloseKey (hKey);

    }

    return(dwError);

}


VOID
PingPolicyAgent(
    )
{
    HANDLE hPolicyChangeEvent = NULL;

    hPolicyChangeEvent = OpenEvent(
                             EVENT_ALL_ACCESS,
                             FALSE,
                             L"IPSEC_POLICY_CHANGE_EVENT"
                             );

    if (hPolicyChangeEvent) {
        SetEvent(hPolicyChangeEvent);
        CloseHandle(hPolicyChangeEvent);
    }
}

VOID
NotifyPolicyAgent(
    )
{
    HANDLE hGpRefreshEvent = NULL;

    hGpRefreshEvent = OpenEvent(
                             EVENT_ALL_ACCESS,
                             FALSE,
                             IPSEC_GP_REFRESH_EVENT
                             );

    if (hGpRefreshEvent) {
        SetEvent(hGpRefreshEvent);
        CloseHandle(hGpRefreshEvent);
    }
}

//
// Prefix stripping functions copied from 
// gina\userenv\rsop\logger.cpp written by SitaramR
//

//*************************************************************
//
//  StripPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to Gpo
//
//  Parameters: lpGPOInfo     - Gpo Info
//              pWbemServices - Wbem services
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripPrefixIpsec( WCHAR *pwszPath )
{
    WCHAR wszMachPrefix[] = TEXT("LDAP://CN=Machine,");
    INT iMachPrefixLen = lstrlen( wszMachPrefix );
    WCHAR wszUserPrefix[] = TEXT("LDAP://CN=User,");
    INT iUserPrefixLen = lstrlen( wszUserPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Gpo
    //

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iUserPrefixLen, wszUserPrefix, iUserPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iUserPrefixLen;
    } else if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iMachPrefixLen, wszMachPrefix, iMachPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iMachPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}


//*************************************************************
//
//  StripLinkPrefix()
//
//  Purpose:    Strips out prefix to get canonical path to DS
//              object
//
//  Parameters: pwszPath - path to strip
//
//  Returns:    Pointer to suffix
//
//*************************************************************

WCHAR *StripLinkPrefixIpsec( WCHAR *pwszPath )
{
    WCHAR wszPrefix[] = TEXT("LDAP://");
    INT iPrefixLen = lstrlen( wszPrefix );
    WCHAR *pwszPathSuffix;

    //
    // Strip out prefix to get the canonical path to Som
    //

    if ( wcslen(pwszPath) <= (DWORD) iPrefixLen ) {
        return pwszPath;
    }

    if ( CompareString( LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                        pwszPath, iPrefixLen, wszPrefix, iPrefixLen ) == CSTR_EQUAL ) {
        pwszPathSuffix = pwszPath + iPrefixLen;
    } else
        pwszPathSuffix = pwszPath;

    return pwszPathSuffix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\scriplog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        ScripLog.h
//
// Contents:
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRIPLOG_H_
#define _SCRIPLOG_H_

#include <initguid.h>
#include <wbemcli.h>
#include "smartptr.h"
#include "scrpdata.h"

class CScriptsLogger
{
public:
    CScriptsLogger( IWbemServices*  pWbemServices );

    //
    // Creates or Updates RSOP_ScriptPolicySetting
    //

    HRESULT
    Log(PRSOP_ScriptList        pList,
                LPWSTR          wszGPOID,
                LPWSTR          wszSOMID,
                LPWSTR          wszRSOPGPOID,
                DWORD           cOrder );

    //
    // Updates matching RSOP_ScriptPolicySetting
    //

    HRESULT
    Update( PRSOP_ScriptList    pList,
            LPCWSTR             wszGPOID,
            LPCWSTR             wszSOMID );

    //
    // Deletes all RSOP_ScriptPolicySetting of RSOP_ScriptList type
    //

    HRESULT
    Delete( PRSOP_ScriptList    pList );

private:
    LPSAFEARRAY
    MakeSafeArrayOfScripts(PRSOP_ScriptList     pList);

    IUnknown*
    PutScriptCommand( LPCWSTR szCommand, LPCWSTR szParams, SYSTEMTIME* pExecTime );

    //
    // house keeping
    //

    BOOL                           m_bInitialized;
    IWbemServices*                 m_pWbemServices;
    XBStr                          m_xbstrPath;

    //
    // RSOP_PolicySetting
    //

    XBStr                           m_xbstrId;
    XBStr                           m_xbstrName;
    XBStr                           m_xbstrGPO;
    XBStr                           m_xbstrSOM;
    XBStr                           m_xbstrOrderClass;

    //
    // RSOP_ScriptPolicySetting
    //

    XBStr                          m_xbstrScriptPolicySetting;
    XInterface<IWbemClassObject>   m_xScriptPolicySetting;
    XInterface<IWbemClassObject>   m_pInstance;
    XBStr                          m_xbstrScriptType;
    XBStr                          m_xbstrScriptList;
    XBStr                          m_xbstrOrder;

    //
    // RSOP_ScriptCmd
    //

    XBStr                          m_xbstrScriptCommand;
    XInterface<IWbemClassObject>   m_xScriptCommand;

    XBStr                          m_xbstrScript;
    XBStr                          m_xbstrArguments;
    XBStr                          m_xbstrExecutionTime;

};

#endif // !_SCRIPTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\psched.cpp ===
#include "gptext.h"
#include <initguid.h>
#include <devioctl.h>
#include <strsafe.h>

#define GPEXT_PATH   TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions\\{426031c0-0b47-4852-b0ca-ac3d37bfcb39}")

#define DriverName   TEXT("\\\\.\\PSCHED")

#define IOCTL_PSCHED_ZAW_EVENT  CTL_CODE( \
                                        FILE_DEVICE_NETWORK, \
                                        20, \
                                        METHOD_BUFFERED, \
                                        FILE_ANY_ACCESS \
                                        )

HRESULT
RegisterPSCHED(void)
{
    HKEY hKey;
    LONG lResult;
    DWORD dwDisp, dwValue;
    TCHAR szBuffer[512];


    lResult = RegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    GPEXT_PATH,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp
                    );

    if (lResult != ERROR_SUCCESS)
    {
        return lResult;
    }

    LoadString (g_hInstance, IDS_PSCHED_NAME, szBuffer, ARRAYSIZE(szBuffer));

    RegSetValueEx (
                hKey,
                NULL,
                0,
                REG_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    RegSetValueEx (
                hKey,
                TEXT("ProcessGroupPolicy"),
                0,
                REG_SZ,
                (LPBYTE)TEXT("ProcessPSCHEDPolicy"),
                (lstrlen(TEXT("ProcessPSCHEDPolicy")) + 1) * sizeof(TCHAR)
                );

    szBuffer[0] = L'\0';
    (void) StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), L"gptext.dll");

    RegSetValueEx (
                hKey,
                TEXT("DllName"),
                0,
                REG_EXPAND_SZ,
                (LPBYTE)szBuffer,
                (lstrlen(szBuffer) + 1) * sizeof(TCHAR)
                );

    dwValue = 1;
    RegSetValueEx (
                hKey,
                TEXT("NoUserPolicy"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegSetValueEx (
                hKey,
                TEXT("NoGPOListChanges"),
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(dwValue));

    RegCloseKey (hKey);

    return S_OK;
}


HRESULT
UnregisterPSCHED(void)
{

    RegDeleteKey (HKEY_LOCAL_MACHINE, GPEXT_PATH);

    return S_OK;
}

VOID
PingPsched()
{
    HANDLE   PschedDriverHandle;
    ULONG    BytesReturned;
    BOOL     IOStatus;

    PschedDriverHandle = CreateFile(
                             DriverName,
                             GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                             NULL
                             );

    if (PschedDriverHandle != INVALID_HANDLE_VALUE) {

        IOStatus = DeviceIoControl(
                       PschedDriverHandle,
                       IOCTL_PSCHED_ZAW_EVENT,
                       NULL,
                       0,
                       NULL,
                       0,
                       &BytesReturned,
                       NULL
                       );

        CloseHandle(PschedDriverHandle);
    }
}

DWORD WINAPI
ProcessPSCHEDPolicy(
    IN DWORD dwFlags,                           // GPO_INFO_FLAGS
    IN HANDLE hToken,                           // User or machine token
    IN HKEY hKeyRoot,                           // Root of registry
    IN PGROUP_POLICY_OBJECT  pDeletedGPOList,   // Linked list of deleted GPOs
    IN PGROUP_POLICY_OBJECT  pChangedGPOList,   // Linked list of changed GPOs
    IN ASYNCCOMPLETIONHANDLE pHandle,           // For asynchronous completion
    IN BOOL *pbAbort,                           // If true, then abort GPO processing
    IN PFNSTATUSMESSAGECALLBACK pStatusCallback // Callback function for displaying status messages
    )

{
    HRESULT hr = S_OK;

    if (pDeletedGPOList || pChangedGPOList) 
    {
        PingPsched();
    }

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\policy.h ===
//
// Current ADM version
//
// Version 1 -> Windows 95
// Version 2 -> Windows NT v4.0
// Version 3 -> Windows 2000
// Version 4 -> Windows Whistler
//

#define CURRENT_ADM_VERSION 4

//
// Hash table entry
//

typedef struct tagHASHENTRY {
    DWORD   dwHashValue;
    DWORD   dwVariableLength;
    LPTSTR  lpStringEntry;
    struct tagHASHENTRY *pNext;
} HASHENTRY, *LPHASHENTRY;

#define HASH_BUCKET_COUNT 100

typedef struct tagHASHTABLE {
    LPHASHENTRY lpEntries[HASH_BUCKET_COUNT];
} HASHTABLE, *LPHASHTABLE;

//
// Add/Remove template entry
//

typedef struct tagTEMPLATEENTRY {
    LPTSTR    lpFileName;
    DWORD     dwSize;
    FILETIME  ftTime;
} TEMPLATEENTRY, *LPTEMPLATEENTRY;


//
// Supported On strings
//

typedef struct tagSUPPORTEDENTRY {
    LPTSTR lpString;
    BOOL   bEnabled;
    BOOL   bNull;
    struct tagSUPPORTEDENTRY * pNext;
} SUPPORTEDENTRY, *LPSUPPORTEDENTRY;


//
// RSOP link list data structures
//

typedef struct tagRSOPREGITEM {
    LPTSTR  lpKeyName;
    LPTSTR  lpValueName;
    LPTSTR  lpGPOName;
    DWORD   dwType;
    DWORD   dwSize;
    LPBYTE  lpData;
    BOOL    bFoundInADM;
    UINT    uiPrecedence;
    BOOL    bDeleted;
    struct tagRSOPREGITEM * pNext;
} RSOPREGITEM, *LPRSOPREGITEM;

typedef struct tagRSOPADMFILE {
    TCHAR    szFileName[100];
    TCHAR    szFullFileName[MAX_PATH];
    FILETIME FileTime;
    DWORD     dwError;
    struct tagRSOPADMFILE * pNext;
} RSOPADMFILE, *LPRSOPADMFILE;


//
// From admincfg.h
//

#define REGBUFLEN                     255
#define MAXSTRLEN                    1024
#define SMALLBUF                       48
#define ERROR_ALREADY_DISPLAYED    0xFFFF

#define GETNAMEPTR(x)         (x->uOffsetName       ? ((TCHAR *)((BYTE *) x + x->uOffsetName)) : NULL)
#define GETKEYNAMEPTR(x)      (x->uOffsetKeyName    ? ((TCHAR *)((BYTE *) x + x->uOffsetKeyName)) : NULL)
#define GETVALUENAMEPTR(x)    (x->uOffsetValueName  ? ((TCHAR *)((BYTE *) x + x->uOffsetValueName)) : NULL)
#define GETOBJECTDATAPTR(x)   (x->uOffsetObjectData ? ((BYTE *) x + x->uOffsetObjectData) : NULL)
#define GETVALUESTRPTR(x)     (x->uOffsetValueStr  ? ((TCHAR *)((BYTE *) x + x->uOffsetValueStr)) : NULL)
#define GETSUPPORTEDPTR(x)    (x->uOffsetSupported  ? ((TCHAR *)((BYTE *) x + x->uOffsetSupported)) : NULL)

//
// From memory.h
//

#define DEFAULT_ENUM_BUF_SIZE 256

//      Entry type ID's
#define ETYPE_CATEGORY          0x0001
#define ETYPE_POLICY            0x0002
#define ETYPE_SETTING           0x0004
#define ETYPE_ROOT              0x0008
#define ETYPE_REGITEM           0x0010

#define ETYPE_MASK              0x001F

//  Setting type ID's
#define STYPE_TEXT              0x0010
#define STYPE_CHECKBOX          0x0020
#define STYPE_ENUM              0x0040
#define STYPE_EDITTEXT          0x0080
#define STYPE_NUMERIC           0x0100
#define STYPE_COMBOBOX          0x0200
#define STYPE_DROPDOWNLIST      0x0400
#define STYPE_LISTBOX           0x0800

#define STYPE_MASK              0xFFF0

//  Flags
#define DF_REQUIRED             0x0001  // text or numeric field required to have entry
#define DF_USEDEFAULT           0x0002  // use specified text or numeric value
#define DF_DEFCHECKED           0x0004  // initialize checkbox or radio button as checked
#define DF_TXTCONVERT           0x0008  // save numeric values as text rather than binary
#define DF_ADDITIVE             0x0010  // listbox is additive, rather than destructive
#define DF_EXPLICITVALNAME      0x0020  // listbox value names need to be specified for each entry
#define DF_NOSORT               0x0040  // listbox is not sorted alphabetically.  Uses order in ADM.
#define DF_EXPANDABLETEXT       0x0080  // write REG_EXPAND_SZ text value
#define VF_ISNUMERIC            0x0100  // value is numeric (rather than text)
#define VF_DELETE               0x0200  // value should be deleted
#define VF_SOFT                 0x0400  // value is soft (only propagated if doesn't exist on destination)

// generic table entry
typedef struct tagTABLEENTRY {
        DWORD   dwSize;
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        // table entry information here
} TABLEENTRY;

typedef struct tagACTION {
        DWORD   dwFlags;                        // can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
        UINT    uOffsetKeyName;
        UINT    uOffsetValueName;
        union {
                UINT    uOffsetValue;   // offset to value, if text
                DWORD   dwValue;                // value, if numeric
        };
        UINT    uOffsetNextAction;
        // key name, value name, value stored here
} ACTION;

typedef struct tagACTIONLIST {
        UINT    nActionItems;
        ACTION  Action[1];
} ACTIONLIST;

typedef struct tagSTATEVALUE {
        DWORD dwFlags;                          // can be VF_ISNUMERIC, VF_DELETE, VF_SOFT
        union {
                TCHAR   szValue[1];              // value, if text
                DWORD   dwValue;                // value, if numeric
        };
} STATEVALUE;

// specialized nodes -- CATEGORY, POLICY, SETTING and REGITEM can all be cast to TABLEENTRY
typedef struct tagCATEGORY {
        DWORD   dwSize;                         // size of this struct (including variable-length name)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetHelp;                    // offset from beginning of struct to help text
        // category name stored here
        // category registry key name stored here
} CATEGORY;

typedef struct tagPOLICY {
        DWORD   dwSize;                         // size of this struct (including variable-length name)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueName;               // offset from beginning of struct to value name
        UINT    uDataIndex;                     // index into user's data buffer for this setting
        UINT    uOffsetValue_On;                // offset to STATEVALUE for ON state
        UINT    uOffsetValue_Off;               // offset to STATEVALUE for OFF state
        UINT    uOffsetActionList_On;   // offset to ACTIONLIST for ON state
        UINT    uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
        UINT    uOffsetHelp;                    // offset from beginning of struct to help text
        UINT    uOffsetClientExt;               // offset from beginning of struct to clientext text
        BOOL    bTruePolicy;                    // something located under the Policies key
        UINT    uOffsetSupported;               // list of supported products
        // name stored here
        // policy registry key name stored here
} POLICY;

typedef struct tagSETTINGS {
        DWORD   dwSize;                         // size of this struct (including variable-length data)
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueName;               // offset from beginning of struct to value name
        UINT    uDataIndex;                     // index into user's data buffer for this setting
        UINT    uOffsetObjectData;              // offset to object data
        UINT    uOffsetClientExt;               // offset from beginning of struct to clientext text
        DWORD   dwFlags;                                // can be DF_REQUIRED, DF_USEDEFAULT, DF_DEFCHECKED,
                                                                        // VF_SOFT, DF_NO_SORT
        // settings registry value name stored here
        // object-dependent data stored here  (a CHECKBOXINFO,
        // RADIOBTNINFO, EDITTEXTINFO, or NUMERICINFO struct)
} SETTINGS;

typedef struct tagREGITEM {
        DWORD   dwSize;
        DWORD   dwType;
        struct  tagTABLEENTRY * pNext;  // ptr to next sibling in node
        struct  tagTABLEENTRY * pPrev;  // ptr to previous sibling in node
        struct  tagTABLEENTRY * pChild; // ptr to child node
        UINT    uOffsetName;                    // offset from beginning of struct to name
        UINT    uOffsetKeyName;                 // offset from beginning of struct to key name
        UINT    uOffsetValueStr;                // offset from beginning of struct to the value in string format
        BOOL    bTruePolicy;                    // something located under the Policies key
        LPRSOPREGITEM lpItem;                   // Pointer to a rsop registry item
        // Name and keyname information here
} REGITEM;

typedef struct tagCHECKBOXINFO {
        UINT    uOffsetValue_On;                // offset to STATEVALUE for ON state
        UINT    uOffsetValue_Off;               // offset to STATEVALUE for OFF state
        UINT    uOffsetActionList_On;   // offset to ACTIONLIST for ON state
        UINT    uOffsetActionList_Off;  // offset to ACTIONLIST for OFF state
} CHECKBOXINFO;

typedef struct tagEDITTEXTINFO {
        UINT    uOffsetDefText;
        UINT    nMaxLen;                        // max len of edit field
} EDITTEXTINFO;

typedef struct tagPOLICYCOMBOBOXINFO {
        UINT    uOffsetDefText;
        UINT    nMaxLen;                        // max len of edit field
        UINT    uOffsetSuggestions;
} POLICYCOMBOBOXINFO;

typedef struct tagNUMERICINFO {
        UINT    uDefValue;                      // default value
        UINT    uMaxValue;                      // minimum value
        UINT    uMinValue;                      // maximum value
        UINT    uSpinIncrement;         // if 0, spin box is not displayed.
} NUMERICINFO;

typedef struct tagCLASSLIST {
        TABLEENTRY * pMachineCategoryList;              // per-machine category list
        UINT    nMachineDataItems;
        TABLEENTRY * pUserCategoryList;                 // per-user category table
        UINT    nUserDataItems;
} CLASSLIST;

typedef struct tagDROPDOWNINFO {
        UINT    uOffsetItemName;
        UINT    uDefaultItemIndex;      // only used in 1st DROPDOWNINFO struct in list
        DWORD   dwFlags;
        union {
                UINT uOffsetValue;
                DWORD dwValue;
        };
        UINT    uOffsetActionList;
        UINT    uOffsetNextDropdowninfo;
} DROPDOWNINFO;

typedef struct tagLISTBOXINFO {
        UINT uOffsetPrefix;     // offset to prefix to use for value names (e.g
                                                // "stuff" -> "stuff1", "stuff2", etc

        UINT uOffsetValue;      // offset to STATEVALUE to use for value data for each entry
                                                // (can't have both a data value and a prefix)
} LISTBOXINFO;


//
// From policy.h
//

#define NO_DATA_INDEX   (UINT) -1
#define DEF_CONTROLS    10

typedef struct tagPOLICYCTRLINFO {
        HWND hwnd;
        DWORD dwType;
        UINT uDataIndex;               // index into user's data buffer
        SETTINGS * pSetting;
} POLICYCTRLINFO;

typedef struct tagSTRDATA {
        DWORD dwSize;                  // size of structure incl. variable-len data
        TCHAR  szData[1];              // variable-length data
} STRDATA;

typedef struct tagPOLICYDLGINFO {
        TABLEENTRY * pEntryRoot;       // root template
        SETTINGS * pCurrentSettings;   // template for current settings
        HWND    hwndSettings;
        HWND    hwndApp;
        BOOL    fActive;

        POLICYCTRLINFO * pControlTable;
        DWORD dwControlTableSize;
        UINT nControls;
} POLICYDLGINFO;


//
// From settings.h
//

#define WT_CLIP                 1
#define WT_SETTINGS             2

#define SSTYLE_STATIC           WS_CHILD | WS_VISIBLE
#define SSTYLE_CHECKBOX         WS_CHILD | WS_VISIBLE | BS_CHECKBOX
#define SSTYLE_EDITTEXT         WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL | WS_BORDER
#define SSTYLE_UPDOWN           WS_CHILD | WS_VISIBLE | UDS_NOTHOUSANDS
#define SSTYLE_COMBOBOX         WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWN \
                                | WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_DROPDOWNLIST     WS_CHILD | WS_VISIBLE | CBS_AUTOHSCROLL | CBS_DROPDOWNLIST \
                                | WS_BORDER | CBS_SORT | WS_VSCROLL
#define SSTYLE_LISTVIEW         WS_CHILD | WS_VISIBLE | WS_BORDER
#define SSTYLE_LBBUTTON         WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON

#define LISTBOX_BTN_WIDTH    100
#define LISTBOX_BTN_HEIGHT    20

#define SC_XSPACING            5
#define SC_YSPACING            5
#define SC_YPAD                8
#define SC_EDITWIDTH         220
#define SC_UPDOWNWIDTH        60
#define SC_UPDOWNWIDTH2       30
#define SC_XLEADING            5
#define SC_XINDENT             5
#define SC_YTEXTDROP           3
#define SC_YCONTROLWRAP        1


//
// From parse.h
//

#define KYWD_ID_KEYNAME                1
#define KYWD_ID_VALUENAME              2
#define KYWD_ID_CATEGORY               3
#define KYWD_ID_POLICY                 4
#define KYWD_ID_PART                   5
#define KYWD_ID_CHECKBOX               6
#define KYWD_ID_TEXT                   7
#define KYWD_ID_EDITTEXT               8
#define KYWD_ID_NUMERIC                9
#define KYWD_ID_DEFCHECKED            10
#define KYWD_ID_MAXLENGTH             11
#define KYWD_ID_MIN                   12
#define KYWD_ID_MAX                   13
#define KYWD_ID_SPIN                  14
#define KYWD_ID_REQUIRED              15
#define KYWD_ID_EDITTEXT_DEFAULT      16
#define KYWD_ID_COMBOBOX_DEFAULT      17
#define KYWD_ID_NUMERIC_DEFAULT       18
#define KYWD_ID_OEMCONVERT            19
#define KYWD_ID_CLASS                 20
#define KYWD_ID_USER                  21
#define KYWD_ID_MACHINE               22
#define KYWD_ID_TXTCONVERT            23
#define KYWD_ID_VALUE                 24
#define KYWD_ID_VALUEON               25
#define KYWD_ID_VALUEOFF              26
#define KYWD_ID_ACTIONLIST            27
#define KYWD_ID_ACTIONLISTON          28
#define KYWD_ID_ACTIONLISTOFF         29
#define KYWD_ID_DELETE                30
#define KYWD_ID_COMBOBOX              31
#define KYWD_ID_SUGGESTIONS           32
#define KYWD_ID_DROPDOWNLIST          33
#define KYWD_ID_NAME                  34
#define KYWD_ID_ITEMLIST              35
#define KYWD_ID_DEFAULT               36
#define KYWD_ID_SOFT                  37
#define KYWD_ID_STRINGSSECT           38
#define KYWD_ID_LISTBOX               39
#define KYWD_ID_VALUEPREFIX           40
#define KYWD_ID_ADDITIVE              41
#define KYWD_ID_EXPLICITVALUE         42
#define KYWD_ID_VERSION               43
#define KYWD_ID_GT                    44
#define KYWD_ID_GTE                   45
#define KYWD_ID_LT                    46
#define KYWD_ID_LTE                   47
#define KYWD_ID_EQ                    48
#define KYWD_ID_NE                    49
#define KYWD_ID_END                   50
#define KYWD_ID_NOSORT                51
#define KYWD_ID_EXPANDABLETEXT        52
#define KYWD_ID_HELP                  53
#define KYWD_ID_CLIENTEXT             54
#define KYWD_ID_SUPPORTED             55

#define KYWD_DONE                    100


#define DEFAULT_TMP_BUF_SIZE         512
#define STRINGS_BUF_SIZE            8096
#define WORDBUFSIZE                  255
#define FILEBUFSIZE                 8192
#define HELPBUFSIZE                 4096


typedef struct tagKEYWORDINFO {
    LPCTSTR pWord;
    UINT nID;
} KEYWORDINFO;

typedef struct tagENTRYDATA {
    BOOL    fHasKey;
    BOOL    fHasValue;
    BOOL     fParentHasKey;
} ENTRYDATA;

typedef struct tagPARSEPROCSTRUCT {
    HGLOBAL        hTable;              // handle of current table
    TABLEENTRY    *pTableEntry;         // pointer to struct for current entry
    DWORD        *pdwBufSize;           // size of buffer of pTableEntry
    ENTRYDATA    *pData;                // used to maintain state between calls to parseproc
    KEYWORDINFO    *pEntryCmpList;
} PARSEPROCSTRUCT;

typedef UINT (* PARSEPROC) (CPolicyComponentData *, UINT,PARSEPROCSTRUCT *,BOOL *,BOOL *, LPTSTR);

typedef struct tagPARSEENTRYSTRUCT {
    TABLEENTRY * pParent;
    DWORD        dwEntryType;
    KEYWORDINFO    *pEntryCmpList;
    KEYWORDINFO    *pTypeCmpList;
    PARSEPROC    pParseProc;
    DWORD        dwStructSize;
    BOOL        fHasSubtable;
    BOOL        fParentHasKey;
} PARSEENTRYSTRUCT;


//
// From load.c
//

// flags for detected settings
#define FS_PRESENT      0x0001
#define FS_DELETED      0x0002
#define FS_DISABLED     0x0004

#define WM_MYCHANGENOTIFY  (WM_USER + 123)
#define WM_MOVEFOCUS       (WM_USER + 124)
#define WM_UPDATEITEM      (WM_USER + 125)
#define WM_SETPREVNEXT     (WM_USER + 126)
#define WM_MYREFRESH       (WM_USER + 127)


//
// GPE root node ids
//

// {8FC0B739-A0E1-11d1-A7D3-0000F87571E3}
DEFINE_GUID(NODEID_MachineRoot, 0x8fc0b739, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {8FC0B73B-A0E1-11d1-A7D3-0000F87571E3}
DEFINE_GUID(NODEID_UserRoot, 0x8fc0b73b, 0xa0e1, 0x11d1, 0xa7, 0xd3, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP root node ids
//
// {e753a11a-66cc-4816-8dd8-3cbe46717fd3}
DEFINE_GUID(NODEID_RSOPMachineRoot, 0xe753a11a, 0x66cc, 0x4816, 0x8d, 0xd8, 0x3c, 0xbe, 0x46, 0x71, 0x7f, 0xd3);

//
// {99d5b872-1ad0-4d87-acf1-82125d317653}
DEFINE_GUID(NODEID_RSOPUserRoot, 0x99d5b872, 0x1ad0, 0x4d87, 0xac, 0xf1, 0x82, 0x12, 0x5d, 0x31, 0x76, 0x53);


//
// GPE Policy SnapIn extension GUIDs
//

// {0F6B957D-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInMachine,0xf6b957d, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {0F6B957E-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInUser,0xf6b957e, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP SnapIn extension GUIDs
//

// {B6F9C8AE-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(CLSID_RSOPolicySnapInMachine,0xb6f9c8ae, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);

// {B6F9C8AF-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(CLSID_RSOPolicySnapInUser,0xb6f9c8af, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);


//
// GPE Policy node ids
//

// {0F6B957F-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(NODEID_PolicyRootMachine,0xf6b957f, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {0F6B9580-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(NODEID_PolicyRootUser,0xf6b9580, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP node ids
//

// {B6F9C8B0-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(NODEID_RSOPolicyRootMachine,0xb6f9c8b0, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);

// {B6F9C8B1-EF3A-41c8-A911-37370C331DD4}
DEFINE_GUID(NODEID_RSOPolicyRootUser,0xb6f9c8b1, 0xef3a, 0x41c8, 0xa9, 0x11, 0x37, 0x37, 0xc, 0x33, 0x1d, 0xd4);



#define ROOT_NAME_SIZE  50

//
// CPolicyComponentData class
//

class CPolicyComponentData:
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStreamInit,
    public ISnapinHelp
{
    friend class CPolicyDataObject;
    friend class CPolicySnapIn;

protected:
    ULONG                m_cRef;
    HWND                 m_hwndFrame;
    LPCONSOLENAMESPACE2  m_pScope;
    LPCONSOLE            m_pConsole;
    HSCOPEITEM           m_hRoot;
    HSCOPEITEM           m_hSWPolicies;
    LPGPEINFORMATION     m_pGPTInformation;
    LPRSOPINFORMATION    m_pRSOPInformation;
    LPRSOPREGITEM        m_pRSOPRegistryData;
    LPOLESTR             m_pszNamespace;
    DWORD                m_bTemplatesColumn;
    BOOL                 m_bUserScope;
    BOOL                 m_bRSOP;
    TCHAR                m_szRootName[ROOT_NAME_SIZE];
    HANDLE               m_ADMEvent;
    HANDLE               m_hTemplateThread;
    INT                  m_iSWPoliciesLen;
    INT                  m_iWinPoliciesLen;
    BOOL                 m_bShowConfigPoliciesOnly;
    BOOL                 m_bUseSupportedOnFilter;
    CPolicySnapIn *      m_pSnapin;
    REGITEM *            m_pExtraSettingsRoot;
    BOOL                 m_bExtraSettingsInitialized;

    //
    // Parsing globals (review)
    //

    UINT                 m_nFileLine;

    TABLEENTRY          *m_pMachineCategoryList;  // per-machine category list
    UINT                 m_nMachineDataItems;
    TABLEENTRY          *m_pUserCategoryList;     // per-user category table
    UINT                 m_nUserDataItems;
    LPSUPPORTEDENTRY     m_pSupportedStrings;

    TABLEENTRY          *m_pListCurrent;          // Current category list (either user or machine)
    UINT                *m_pnDataItemCount;
    BOOL                 m_bRetrieveString;

    LPTSTR               m_pszParseFileName;      // Template currently being parsed or NULL

    // buffer to read .INF file into
    TCHAR               *m_pFilePtr;
    TCHAR               *m_pFileEnd;
    TCHAR               *m_pDefaultStrings;
    TCHAR               *m_pLanguageStrings;
    TCHAR               *m_pLocaleStrings;
    LPHASHTABLE          m_pDefaultHashTable;
    LPHASHTABLE          m_pLanguageHashTable;
    LPHASHTABLE          m_pLocaleHashTable;

    BOOL                 m_fInComment;


public:
    CPolicyComponentData(BOOL bUser, BOOL bRSOP);
    ~CPolicyComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);

    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);

    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);

private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    BOOL CheckForChildCategories (TABLEENTRY *pParent);
#if DBG
    VOID DumpEntry (TABLEENTRY * pEntry, UINT uIndent);
    VOID DumpCurrentTable (void);
#endif
    VOID FreeTemplates (void);
    static DWORD LoadTemplatesThread (CPolicyComponentData * pCD);
    void AddTemplates(LPTSTR lpDest, LPCTSTR lpValueName, UINT idRes);
    void AddDefaultTemplates(LPTSTR lpDest);
    void AddNewADMsToExistingGPO (LPTSTR lpDest);
    void UpdateExistingTemplates(LPTSTR lpDest);
    BOOL CPolicyComponentData::IsADMAutoUpdateDisabled(void);
    HRESULT CPolicyComponentData::CreateAdmIniFile (WCHAR *szAdmDirPath);
    HRESULT LoadGPOTemplates (void);
    BOOL IsSlowLink (LPTSTR lpFileName);
    HRESULT AddADMFile (LPTSTR lpFileName, LPTSTR lpFullFileName,
                        FILETIME *pFileTime, DWORD dwErr, LPRSOPADMFILE *lpHead);
    HRESULT GetLocalADMFiles(LPRSOPADMFILE *lpHead);
    HRESULT LoadRSOPTemplates (void);
    HRESULT LoadTemplates (void);
    BOOL ParseTemplate (LPTSTR lpFileName);

    UINT ParseClass(BOOL *pfMore);
    TABLEENTRY * FindCategory(TABLEENTRY *pParent, LPTSTR lpName);
    UINT ParseEntry(PARSEENTRYSTRUCT *ppes,BOOL *pfMore, LPTSTR pKeyName);
    UINT ParseCategory(TABLEENTRY * pParent, BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT CategoryParseProc(CPolicyComponentData *, UINT nMsg,PARSEPROCSTRUCT * ppps,
                                  BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT ParsePolicy(TABLEENTRY * pParent,
                     BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT PolicyParseProc(CPolicyComponentData *, UINT nMsg,PARSEPROCSTRUCT * ppps,
                                BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT ParseSettings(TABLEENTRY * pParent,
                      BOOL fParentHasKey,BOOL *pfMore,LPTSTR pKeyName);
    static UINT SettingsParseProc(CPolicyComponentData *pCD, UINT nMsg,PARSEPROCSTRUCT * ppps,
                           BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName);

    UINT InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
                           KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,BYTE **ppObjectData);

    UINT ParseValue_W(PARSEPROCSTRUCT * ppps,TCHAR * pszWordBuf,
                      DWORD cbWordBuf,DWORD * pdwValue,DWORD * pdwFlags,
                      BOOL * pfMore);

    UINT ParseValue(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                      TABLEENTRY ** ppTableEntryNew,BOOL * pfMore);

    UINT ParseSuggestions(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                          TABLEENTRY ** ppTableEntryNew,BOOL * pfMore);

    UINT ParseActionList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                         TABLEENTRY ** ppTableEntryNew,
                         LPCTSTR pszKeyword,BOOL * pfMore);

    UINT ParseItemList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                       BOOL * pfMore);

    BOOL AddActionListString(TCHAR * pszData,DWORD cbData,BYTE ** ppBase,UINT * puOffset,
                             DWORD * pdwAlloc,DWORD *pdwUsed);
    BYTE * AddDataToEntry(TABLEENTRY * pTableEntry, BYTE * pData,UINT cbData,
                          UINT * puOffsetData,DWORD * pdwBufSize);
    BOOL CompareKeyword(TCHAR * szWord,KEYWORDINFO *pKeywordList, UINT * pnListIndex);
    TCHAR * GetNextWord(TCHAR * szBuf,UINT cbBuf,BOOL * pfMore,
                        UINT * puErr);
    TCHAR * GetNextSectionWord(TCHAR * szBuf,UINT cbBuf,
                               KEYWORDINFO * pKeywordList, UINT *pnListIndex,
                               BOOL * pfMore,UINT * puErr);
    UINT GetNextSectionNumericWord(UINT * pnVal);

    TCHAR * GetNextChar(BOOL * pfMore,UINT * puErr);
    BOOL GetString (LPHASHTABLE lpHashTable, LPTSTR lpStringName,
                    LPTSTR lpResult, DWORD dwSize);
    VOID FillHashTable(LPHASHTABLE lpTable, LPTSTR lpStrings);
    LPTSTR CreateStringArray(LPTSTR lpStrings);
    LPTSTR FindSection (LPTSTR lpSection);
    BOOL IsComment(TCHAR * pBuf);
    BOOL IsQuote(TCHAR * pBuf);
    BOOL IsEndOfLine(TCHAR * pBuf);
    BOOL IsWhitespace(TCHAR * pBuf);
    BOOL IsLocalizedString(TCHAR * pBuf);

    VOID DisplayKeywordError(UINT uErrorID,TCHAR * szFound,KEYWORDINFO * pExpectedList);
    int MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons);
    int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
    int MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,UINT uButtons);
    LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);

    UINT FindMatchingDirective(BOOL *pfMore,BOOL fElseOK);
    UINT ProcessIfdefs(TCHAR * pBuf,UINT cbBuf,BOOL * pfMore);
    BOOL FreeTable(TABLEENTRY * pTableEntry);

    LPTSTR GetStringSection (LPCTSTR lpSection, LPCTSTR lpFileName);
    static INT TemplatesSortCallback (LPARAM lParam1, LPARAM lParam2, LPARAM lColumn);

    BOOL FillADMFiles (HWND hDlg);
    BOOL InitializeTemplatesDlg (HWND hDlg);
    BOOL AddTemplates(HWND hDlg);
    BOOL RemoveTemplates(HWND hDlg);
    static INT_PTR CALLBACK TemplatesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

    BOOL AddRSOPRegistryDataNode(LPTSTR lpKeyName, LPTSTR lpValueName, DWORD dwType,
                                 DWORD dwDataSize, LPBYTE lpData, UINT uiPrecedence,
                                 LPTSTR lpGPOName, BOOL bDeleted);
    VOID FreeRSOPRegistryData(VOID);
    HRESULT InitializeRSOPRegistryData(VOID);
    HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                               LPTSTR lpGPOID, BSTR pLanguage,
                               LPTSTR *pGPOName);
    UINT ReadRSOPRegistryValue(HKEY uiPrecedence, TCHAR * pszKeyName,TCHAR * pszValueName,
                               LPBYTE pData, DWORD dwMaxSize, DWORD *dwType,
                               LPTSTR *lpGPOName, LPRSOPREGITEM lpItem);
    UINT EnumRSOPRegistryValues(HKEY uiPrecedence, TCHAR * pszKeyName,
                                TCHAR * pszValueName, DWORD dwMaxSize,
                                LPRSOPREGITEM *lpEnum);
    UINT FindRSOPRegistryEntry(HKEY uiPrecedence, TCHAR * pszKeyName,
                               TCHAR * pszValueName, LPRSOPREGITEM *lpEnum);
    VOID DumpRSOPRegistryData (VOID);
    VOID InitializeExtraSettings (VOID);
    BOOL FindEntryInActionList(POLICY * pPolicy, ACTIONLIST *pActionList, LPTSTR lpKeyName, LPTSTR lpValueName);
    BOOL FindEntryInTable(TABLEENTRY * pTable, LPTSTR lpKeyName, LPTSTR lpValueName);
    VOID AddEntryToList (TABLEENTRY *pItem);

    BOOL DoesNodeExist (LPSUPPORTEDENTRY *pList, LPTSTR lpString);
    BOOL CheckSupportedFilter (POLICY *pPolicy);
    BOOL IsAnyPolicyAllowedPastFilter(TABLEENTRY * pCategory);
    VOID AddSupportedNode (LPSUPPORTEDENTRY *pList, LPTSTR lpString, BOOL bNull);
    VOID FreeSupportedData(LPSUPPORTEDENTRY lpList);
    VOID InitializeSupportInfo(TABLEENTRY * pTable, LPSUPPORTEDENTRY *pList);
};



//
// ComponentData class factory
//


class CPolicyComponentDataCF : public IClassFactory
{
protected:
    ULONG m_cRef;
    BOOL  m_bUser;
    BOOL  m_bRSOP;

public:
    CPolicyComponentDataCF(BOOL bUser, BOOL bRSOP);
    ~CPolicyComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// SnapIn class
//

class CPolicySnapIn:
    public IComponent,
    public IExtendContextMenu,
    public IExtendPropertySheet
{

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;           // Console's IFrame interface
    CPolicyComponentData *m_pcd;
    LPRESULTDATA         m_pResult;            // Result pane's interface
    LPHEADERCTRL         m_pHeader;            // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb;       // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp;       // IDisplayHelp interface
    WCHAR                m_pName[40];          // Name text
    WCHAR                m_pState[40];         // State text
    WCHAR                m_pSetting[40];       // Setting text
    WCHAR                m_pGPOName[40];       // GPO Name text
    WCHAR                m_pMultipleGPOs[75];  // Multiple GPOs text
    INT                  m_nColumn1Size;       // Size of column 1
    INT                  m_nColumn2Size;       // Size of column 2
    INT                  m_nColumn3Size;       // Size of column 3
    LONG                 m_lViewMode;          // View mode
    WCHAR                m_pEnabled[30];       // Enabled text
    WCHAR                m_pDisabled[30];      // Disabled text
    WCHAR                m_pNotConfigured[30]; // Not configured text
    BOOL                 m_bPolicyOnly;        // Show policies only
    DWORD                m_dwPolicyOnlyPolicy; // Policy for enforcing Show Policies Only
    HWND                 m_hMsgWindow;         // Hidden message window

    POLICY              *m_pCurrentPolicy;     // Currently selected policy
    HWND                 m_hPropDlg;           // Properties dialog
    HICON                m_hPolicyIcon;        // Policy icon
    HICON                m_hPreferenceIcon;    // Preference icon
    BOOL                 m_bDirty;             // Has something changed in the policy UI
    HHOOK                m_hKbdHook;           // Keyboard hook handle

    static unsigned int  m_cfNodeType;

public:
    UINT                 m_uiRefreshMsg;       // Reload the adm namespace

    CPolicySnapIn(CPolicyComponentData *pComponent);
    ~CPolicySnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendContextMenu methods
    //

    STDMETHODIMP         AddMenuItems(LPDATAOBJECT piDataObject, LPCONTEXTMENUCALLBACK pCallback,
                                      LONG *pInsertionAllowed);
    STDMETHODIMP         Command(LONG lCommandID, LPDATAOBJECT piDataObject);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                      LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


    BOOL IsAnyPolicyEnabled(TABLEENTRY * pCategory);

private:
    VOID RefreshSettingsControls(HWND hDlg);
    HRESULT UpdateItemWorker (VOID);
    HRESULT MoveFocusWorker (BOOL bPrevious);
    HRESULT MoveFocus (HWND hDlg, BOOL bPrevious);
    HRESULT SetPrevNextButtonState (HWND hDlg);
    HRESULT SetPrevNextButtonStateWorker (HWND hDlg);
    static INT_PTR CALLBACK PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PolicyHelpDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static INT_PTR CALLBACK PolicyPrecedenceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam,LPARAM lParam);
    VOID SetKeyboardHook(HWND hDlg);
    VOID RemoveKeyboardHook(VOID);
    INT GetPolicyState (TABLEENTRY *pTableEntry, UINT uiPrecedence, LPTSTR *lpGPOName);
    BOOL CheckActionList (POLICY * pPolicy, HKEY hKeyRoot, BOOL bActionListOn, LPTSTR *lpGPOName);
    UINT LoadSettings(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                      DWORD * pdwFound, LPTSTR *lpGPOName);
    UINT LoadListboxData(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                         TCHAR * pszCurrentKeyName,DWORD * pdwFound, HGLOBAL * phGlobal, LPTSTR *lpGPOName);
    BOOL ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                         TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags,LPTSTR *lpGPOName);
    BOOL CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            STATEVALUE * pStateValue,DWORD * pdwFound, LPTSTR *lpGPOName);
    BOOL ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                           TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound, LPTSTR *lpGPOName);
    VOID PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
                          UINT cbNewValueName);
    UINT WriteRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName, DWORD dwValue);
    UINT ReadRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                DWORD * pdwValue, LPTSTR *lpGPOName);
    UINT WriteRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                  TCHAR * pszValue, BOOL bExpandable);
    UINT ReadRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                 TCHAR * pszValue,UINT cbValue, LPTSTR *lpGPOName);
    UINT DeleteRegistryValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName);
    UINT WriteCustomValue_W(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            TCHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase);
    UINT WriteCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                          STATEVALUE * pStateValue,BOOL fErase);
    UINT WriteStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                            TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,
                            BOOL fWriteZero);
    TCHAR * ResizeBuffer(TCHAR *pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize);
    static LRESULT CALLBACK MessageWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    static LRESULT CALLBACK ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
    VOID ProcessCommand(HWND hWnd,WPARAM wParam,HWND hwndCtrl, POLICYDLGINFO * pdi);
    VOID EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl);
    VOID ProcessScrollBar(HWND hWnd,WPARAM wParam,BOOL bVert);
    VOID FreeSettingsControls(HWND hDlg);
    VOID InsertComboboxItems(HWND hwndControl,TCHAR * pSuggestionList);
    BOOL CreateSettingsControls(HWND hDlg,SETTINGS * pSetting,BOOL fEnable);
    HWND CreateSetting(POLICYDLGINFO * pdi,TCHAR * pszClassName,TCHAR * pszWindowName,
        DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
        SETTINGS * pSetting, HFONT hFontDlg);
    BOOL SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
                        UINT uDataIndex,SETTINGS * pSetting);
    int AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo);
    BOOL AdjustWindowToText(HWND hWnd,TCHAR * szText,UINT xStart,UINT yStart,
        UINT yPad,UINT * pnWidth,UINT * pnHeight, HFONT hFontDlg);
    BOOL GetTextSize(HWND hWnd,TCHAR * szText,SIZE * pSize, HFONT hFontDlg);
    HRESULT SaveSettings(HWND hDlg);
    VOID DeleteOldListboxData(SETTINGS * pSetting,HKEY hkeyRoot, TCHAR * pszCurrentKeyName);
    UINT SaveListboxData(HGLOBAL hData,SETTINGS * pSetting,HKEY hkeyRoot,
                         TCHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted, BOOL bEnabled, BOOL *bFoundNone);
    UINT ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
                                    TCHAR * pszCurrentKeyName,DWORD dwData,
                                    BOOL fErase, BOOL fMarkAsDeleted,BOOL bPolicy);
    UINT WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
           LPTSTR pszCurrentKeyName,BOOL fErase, BOOL fMarkAsDeleted);
    int FindComboboxItemData(HWND hwndControl,UINT nData);
    HRESULT InitializeSettingsControls(HWND hDlg, BOOL fEnable);
    VOID ShowListbox(HWND hParent,SETTINGS * pSettings);
    static INT_PTR CALLBACK ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                            LPARAM lParam);
    BOOL InitShowlistboxDlg(HWND hDlg);
    BOOL ProcessShowlistboxDlg(HWND hDlg);
    VOID EnableShowListboxButtons(HWND hDlg);
    VOID ListboxRemove(HWND hDlg,HWND hwndListbox);
    VOID ListboxAdd(HWND hwndListbox, BOOL fExplicitValName,BOOL fValuePrefix);
    static INT_PTR CALLBACK ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void InitializeFilterDialog (HWND hDlg);
    static INT_PTR CALLBACK FilterDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT CallNextHook(int nCode, WPARAM wParam, LPARAM lParam);
    };


//
// Structure passed to Settings / Properties dialog
//

typedef struct tagSETTINGSINFO {
    CPolicySnapIn * pCS;
    POLICYDLGINFO * pdi;
    HFONT hFontDlg;
} SETTINGSINFO, *LPSETTINGSINFO;


//
// From listbox.c
//

typedef struct tagLISTBOXDLGINFO {
    CPolicySnapIn * pCS;
    SETTINGS * pSettings;
    HGLOBAL hData;
} LISTBOXDLGINFO;

typedef struct tagADDITEMINFO {
    CPolicySnapIn * pCS;
    BOOL fExplicitValName;
    BOOL fValPrefix;
    HWND hwndListbox;
    TCHAR szValueName[MAX_PATH+1];  // only used if fExplicitValName is set
    TCHAR szValueData[MAX_PATH+1];
} ADDITEMINFO;


//
// IPolicyDataObject interface id
//

// {0F6B9580-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(IID_IPolicyDataObject,0xf6b9580, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IPolicyDataObject
DECLARE_INTERFACE_(IPolicyDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IPolicyDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IPolicyDataObject *LPPOLICYDATAOBJECT;



//
// CPolicyDataObject class
//

class CPolicyDataObject : public IDataObject,
                           public IPolicyDataObject
{
    friend class CPolicySnapIn;

protected:

    ULONG                  m_cRef;
    CPolicyComponentData  *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;

    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CPolicyDataObject(CPolicyComponentData *pComponent);
    ~CPolicyDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };


    //
    // Implemented IPolicyDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK; };

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK; };

    STDMETHOD(SetCookie) (MMC_COOKIE cookie)
    { m_cookie = cookie; return S_OK; };

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK; };


private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};

VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize);
BOOL ReportAdmError (HWND hParent, DWORD dwError, UINT idMsg, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\scripts.h ===
//
// GPE Script SnapIn extension GUIDs
//

// {40B6664F-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_ScriptSnapInMachine,0x40b6664f, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66650-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_ScriptSnapInUser,0x40b66650, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// GPE Script node ids
//

// {40B66651-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRootMachine,0x40b66651, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66652-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRootUser,0x40b66652, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66653-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_ScriptRoot,0x40b66653, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



//
// RSOP Script SnapIn extension GUIDs
//

// {40B66660-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_RSOPScriptSnapInMachine,0x40b66660, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66661-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(CLSID_RSOPScriptSnapInUser,0x40b66661, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);


//
// RSOP Script node ids
//

// {40B66662-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRootMachine,0x40b66662, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66663-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRootUser,0x40b66663, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66664-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPScriptRoot,0x40b66664, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66665-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPLogon,0x40b66665, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66666-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPLogoff,0x40b66666, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66667-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPStartup,0x40b66667, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

// {40B66668-4972-11d1-A7CA-0000F87571E3}
DEFINE_GUID(NODEID_RSOPShutdown,0x40b66668, 0x4972, 0x11d1, 0xa7, 0xca, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);

//
// RSOP link list data structures
//

typedef struct tagRSOPSCRIPTITEM {
    LPTSTR  lpCommandLine;
    LPTSTR  lpArgs;
    LPTSTR  lpGPOName;
    LPTSTR  lpDate;
    struct tagRSOPSCRIPTITEM * pNext;
} RSOPSCRIPTITEM, *LPRSOPSCRIPTITEM;

typedef struct tagSCRIPTRESULTITEM {
    LPRESULTITEM      lpResultItem;
    LPRSOPSCRIPTITEM  lpRSOPScriptItem;
    const GUID       *pNodeID;
    INT               iDescStringID;
} SCRIPTRESULTITEM, *LPSCRIPTRESULTITEM;


//
// CScriptsComponentData class
//

class CScriptsComponentData:
public IComponentData,
public IPersistStreamInit,
public ISnapinHelp {
    friend class CScriptsDataObject;
    friend class CScriptsSnapIn;

protected:
    ULONG                m_cRef;
    BOOL                 m_bUserScope;
    BOOL                 m_bRSOP;
    HWND         m_hwndFrame;
    LPCONSOLENAMESPACE   m_pScope;
    LPCONSOLE2           m_pConsole;
    HSCOPEITEM           m_hRoot;
    LPGPEINFORMATION     m_pGPTInformation;
    LPRSOPINFORMATION    m_pRSOPInformation;
    LPTSTR               m_pScriptsDir;
    LPOLESTR             m_pszNamespace;
    LPNAMESPACEITEM      m_pNameSpaceItems;
    DWORD                m_dwNameSpaceItemCount;
    LPRSOPSCRIPTITEM     m_pRSOPLogon;
    LPRSOPSCRIPTITEM     m_pRSOPLogoff;
    LPRSOPSCRIPTITEM     m_pRSOPStartup;
    LPRSOPSCRIPTITEM     m_pRSOPShutdown;

public:
    CScriptsComponentData(BOOL bUser, BOOL bRSOP);
    ~CScriptsComponentData();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //
    // Implemented IComponentData methods
    //

    STDMETHODIMP         Initialize(LPUNKNOWN pUnknown);
    STDMETHODIMP         CreateComponent(LPCOMPONENT* ppComponent);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHODIMP         Destroy(void);
    STDMETHODIMP         Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHODIMP         GetDisplayInfo(LPSCOPEDATAITEM pItem);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);


    //
    // Implemented IPersistStreamInit interface members
    //

    STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(VOID);
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);
    STDMETHODIMP         InitNew(VOID);


    //
    // Implemented ISnapinHelp interface members
    //

    STDMETHODIMP         GetHelpTopic(LPOLESTR *lpCompiledHelpFile);


private:
    HRESULT EnumerateScopePane(LPDATAOBJECT lpDataObject, HSCOPEITEM hParent);
    BOOL AddRSOPScriptDataNode(LPTSTR lpCommandLine, LPTSTR lpArgs,
                               LPTSTR lpGPOName, LPTSTR lpDate, UINT uiScriptType);
    VOID FreeRSOPScriptData(VOID);
    HRESULT InitializeRSOPScriptsData(VOID);
    HRESULT GetGPOFriendlyName(IWbemServices *pIWbemServices,
                               LPTSTR lpGPOID, BSTR pLanguage,
                               LPTSTR *pGPOName);
    VOID DumpRSOPScriptsData(LPRSOPSCRIPTITEM lpList);
};



//
// ComponentData class factory
//


class CScriptsComponentDataCF : public IClassFactory {
protected:
    ULONG m_cRef;
    BOOL  m_bUserScope;
    BOOL  m_bRSOP;

public:
    CScriptsComponentDataCF(BOOL bUser, BOOL bRSOP);
    ~CScriptsComponentDataCF();


    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory methods
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
    STDMETHODIMP LockServer(BOOL);
};



//
// SnapIn class
//

class CScriptsSnapIn:
public IComponent,
public IExtendPropertySheet {

protected:
    ULONG                m_cRef;
    LPCONSOLE            m_pConsole;   // Console's IFrame interface
    CScriptsComponentData *m_pcd;
    LPRESULTDATA         m_pResult;      // Result pane's interface
    LPHEADERCTRL         m_pHeader;      // Result pane's header control interface
    LPCONSOLEVERB        m_pConsoleVerb; // pointer the console verb
    LPDISPLAYHELP        m_pDisplayHelp; // IDisplayHelp interface
    WCHAR                m_column1[40];  // Text for column 1
    INT                  m_nColumn1Size; // Size of column 1
    WCHAR                m_column2[40];  // Text for column 2
    INT                  m_nColumn2Size; // Size of column 2
    WCHAR                m_column3[60];  // Text for column 3
    INT                  m_nColumn3Size; // Size of column 3
    WCHAR                m_column4[40];  // Text for column 4
    INT                  m_nColumn4Size; // Size of column 4
    LONG                 m_lViewMode;    // View mode

    static unsigned int  m_cfNodeType;

public:
    CScriptsSnapIn(CScriptsComponentData *pComponent);
    ~CScriptsSnapIn();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IComponent methods
    //

    STDMETHODIMP         Initialize(LPCONSOLE);
    STDMETHODIMP         Destroy(MMC_COOKIE);
    STDMETHODIMP         Notify(LPDATAOBJECT, MMC_NOTIFY_TYPE, LPARAM, LPARAM);
    STDMETHODIMP         QueryDataObject(MMC_COOKIE, DATA_OBJECT_TYPES, LPDATAOBJECT *);
    STDMETHODIMP         GetDisplayInfo(LPRESULTDATAITEM);
    STDMETHODIMP         GetResultViewType(MMC_COOKIE, LPOLESTR*, long*);
    STDMETHODIMP         CompareObjects(LPDATAOBJECT, LPDATAOBJECT);


    //
    // Implemented IExtendPropertySheet methods
    //

    STDMETHODIMP         CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                                             LONG_PTR handle, LPDATAOBJECT lpDataObject);
    STDMETHODIMP         QueryPagesFor(LPDATAOBJECT lpDataObject);


private:
    static INT_PTR CALLBACK ScriptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
    BOOL AddScriptToList (HWND hLV, LPTSTR lpName, LPTSTR lpArgs);
    LPTSTR GetSectionNames (LPTSTR lpFileName);
    BOOL OnApplyNotify (HWND hDlg);
    static INT_PTR CALLBACK ScriptEditDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
};



//
// IScriptDataobject interface id
//

// {4c1dd2a5-3a79-4c98-bcb9-c150291fbab1}
DEFINE_GUID(IID_IScriptDataObject,0x4c1dd2a5, 0x3a79, 0x4c98, 0xbc, 0xb9, 0xc1, 0x50, 0x29, 0x1f, 0xba, 0xb1);


//
// This is a private dataobject interface for GPTs.
// When the GPT snapin receives a dataobject and needs to determine
// if it came from the GPT snapin or a different component, it can QI for
// this interface.
//

#undef INTERFACE
#define INTERFACE   IScriptDataObject
DECLARE_INTERFACE_(IScriptDataObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;


    // *** IScriptDataObject methods ***

    STDMETHOD(SetType) (THIS_ DATA_OBJECT_TYPES type) PURE;
    STDMETHOD(GetType) (THIS_ DATA_OBJECT_TYPES *type) PURE;

    STDMETHOD(SetCookie) (THIS_ MMC_COOKIE cookie) PURE;
    STDMETHOD(GetCookie) (THIS_ MMC_COOKIE *cookie) PURE;
};
typedef IScriptDataObject *LPSCRIPTDATAOBJECT;



//
// CScriptsDataObject class
//

class CScriptsDataObject : public IDataObject,
public IScriptDataObject {
    friend class CScriptsSnapIn;

protected:

    ULONG                  m_cRef;
    CScriptsComponentData  *m_pcd;
    DATA_OBJECT_TYPES      m_type;
    MMC_COOKIE             m_cookie;
    MMC_COOKIE             m_cookiePrevRes;
    
    //
    // Clipboard formats that are required by the console
    //

    static unsigned int    m_cfNodeType;
    static unsigned int    m_cfNodeTypeString;
    static unsigned int    m_cfDisplayName;
    static unsigned int    m_cfCoClass;
    static unsigned int    m_cfDescription;
    static unsigned int    m_cfHTMLDetails;



public:
    CScriptsDataObject(CScriptsComponentData *pComponent);
    ~CScriptsDataObject();


    //
    // IUnknown methods
    //

    STDMETHODIMP         QueryInterface(REFIID, LPVOID FAR *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


    //
    // Implemented IDataObject methods
    //

    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);


    //
    // Unimplemented IDataObject methods
    //

    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL;};

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL;};

    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc)
    { return E_NOTIMPL;};

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL;};

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL;};

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                       LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL;};

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL;};

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL;};


    //
    // Implemented IScriptDataObject methods
    //

    STDMETHOD(SetType) (DATA_OBJECT_TYPES type)
    { m_type = type; return S_OK;};

    STDMETHOD(GetType) (DATA_OBJECT_TYPES *type)
    { *type = m_type; return S_OK;};

    STDMETHOD(SetCookie) (MMC_COOKIE cookie);

    STDMETHOD(GetCookie) (MMC_COOKIE *cookie)
    { *cookie = m_cookie; return S_OK;};

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);

    HRESULT Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\policy.cpp ===
#include "gptext.h"
#include <initguid.h>
#include "Policy.h"
#include "smartptr.h"
#include "wbemtime.h"
#include <strsafe.h>

#define RSOP_HELP_FILE TEXT("gpedit.hlp")

//
// ADM directory name
//

const TCHAR g_szADM[] = TEXT("Adm");
const TCHAR g_szNull[]  = TEXT("");
const TCHAR g_szStrings[] = TEXT("strings");

const TCHAR szIFDEF[]           = TEXT("#ifdef");
const TCHAR szIF[]              = TEXT("#if");
const TCHAR szENDIF[]           = TEXT("#endif");
const TCHAR szIFNDEF[]          = TEXT("#ifndef");
const TCHAR szELSE[]            = TEXT("#else");
const TCHAR szVERSION[]         = TEXT("version");
const TCHAR szLT[]              = TEXT("<");
const TCHAR szLTE[]             = TEXT("<=");
const TCHAR szGT[]              = TEXT(">");
const TCHAR szGTE[]             = TEXT(">=");
const TCHAR szEQ[]              = TEXT("==");
const TCHAR szNE[]              = TEXT("!=");

const TCHAR szLISTBOX[]         = TEXT("LISTBOX");
const TCHAR szEDIT[]            = TEXT("EDIT");
const TCHAR szBUTTON[]          = TEXT("BUTTON");
const TCHAR szSTATIC[]          = TEXT("STATIC");

const TCHAR szCLASS[]           = TEXT("CLASS");
const TCHAR szCATEGORY[]        = TEXT("CATEGORY");
const TCHAR szPOLICY[]          = TEXT("POLICY");
const TCHAR szUSER[]            = TEXT("USER");
const TCHAR szMACHINE[]         = TEXT("MACHINE");

const TCHAR szCHECKBOX[]        = TEXT("CHECKBOX");
const TCHAR szTEXT[]            = TEXT("TEXT");
const TCHAR szEDITTEXT[]        = TEXT("EDITTEXT");
const TCHAR szNUMERIC[]         = TEXT("NUMERIC");
const TCHAR szCOMBOBOX[]        = TEXT("COMBOBOX");
const TCHAR szDROPDOWNLIST[]    = TEXT("DROPDOWNLIST");
const TCHAR szUPDOWN[]          = UPDOWN_CLASS;

const TCHAR szKEYNAME[]         = TEXT("KEYNAME");
const TCHAR szVALUENAME[]       = TEXT("VALUENAME");
const TCHAR szNAME[]            = TEXT("NAME");
const TCHAR szEND[]             = TEXT("END");
const TCHAR szPART[]            = TEXT("PART");
const TCHAR szSUGGESTIONS[]     = TEXT("SUGGESTIONS");
const TCHAR szDEFCHECKED[]      = TEXT("DEFCHECKED");
const TCHAR szDEFAULT[]         = TEXT("DEFAULT");
const TCHAR szMAXLENGTH[]       = TEXT("MAXLEN");
const TCHAR szMIN[]             = TEXT("MIN");
const TCHAR szMAX[]             = TEXT("MAX");
const TCHAR szSPIN[]            = TEXT("SPIN");
const TCHAR szREQUIRED[]        = TEXT("REQUIRED");
const TCHAR szOEMCONVERT[]      = TEXT("OEMCONVERT");
const TCHAR szTXTCONVERT[]      = TEXT("TXTCONVERT");
const TCHAR szEXPANDABLETEXT[]  = TEXT("EXPANDABLETEXT");
const TCHAR szVALUEON[]         = TEXT("VALUEON");
const TCHAR szVALUEOFF[]        = TEXT("VALUEOFF");
const TCHAR szVALUE[]           = TEXT("VALUE");
const TCHAR szACTIONLIST[]      = TEXT("ACTIONLIST");
const TCHAR szACTIONLISTON[]    = TEXT("ACTIONLISTON");
const TCHAR szACTIONLISTOFF[]   = TEXT("ACTIONLISTOFF");
const TCHAR szDELETE[]          = TEXT("DELETE");
const TCHAR szITEMLIST[]        = TEXT("ITEMLIST");
const TCHAR szSOFT[]            = TEXT("SOFT");
const TCHAR szVALUEPREFIX[]     = TEXT("VALUEPREFIX");
const TCHAR szADDITIVE[]        = TEXT("ADDITIVE");
const TCHAR szEXPLICITVALUE[]   = TEXT("EXPLICITVALUE");
const TCHAR szNOSORT[]          = TEXT("NOSORT");
const TCHAR szHELP[]            = TEXT("EXPLAIN");
const TCHAR szCLIENTEXT[]       = TEXT("CLIENTEXT");
const TCHAR szSUPPORTED[]       = TEXT("SUPPORTED");
const TCHAR szStringsSect[]     = TEXT("[strings]");
const TCHAR szStrings[]         = TEXT("strings");

const TCHAR szDELETEPREFIX[]    = TEXT("**del.");
const TCHAR szSOFTPREFIX[]      = TEXT("**soft.");
const TCHAR szDELVALS[]         = TEXT("**delvals.");
const TCHAR szNOVALUE[]         = TEXT(" ");

const TCHAR szUserPrefKey[]     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor");
const TCHAR szPoliciesKey[]     = TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor");
const TCHAR szDefaultTemplates[] = TEXT("DefaultTemplates");
const TCHAR szAdditionalTemplates[] = TEXT("AdditionalTemplates");

// list of legal keyword entries in "CATEGORY" section
KEYWORDINFO pCategoryEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szCATEGORY,KYWD_ID_CATEGORY},{szPOLICY,KYWD_ID_POLICY},
    {szEND,KYWD_ID_END},{szHELP,KYWD_ID_HELP}, {NULL,0} };
KEYWORDINFO pCategoryTypeCmpList[] = { {szCATEGORY,KYWD_ID_CATEGORY},
    {NULL,0} };

// list of legal keyword entries in "POLICY" section
KEYWORDINFO pPolicyEntryCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
    {szVALUENAME,KYWD_ID_VALUENAME}, {szPART,KYWD_ID_PART},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szEND,KYWD_ID_END},{szHELP,KYWD_ID_HELP}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},
    {szSUPPORTED,KYWD_ID_SUPPORTED}, {NULL, 0} };
KEYWORDINFO pPolicyTypeCmpList[] = { {szPOLICY,KYWD_ID_POLICY}, {NULL,0} };

// list of legal keyword entries in "PART" section
KEYWORDINFO pSettingsEntryCmpList[] = { {szCHECKBOX,KYWD_ID_CHECKBOX},
    {szTEXT,KYWD_ID_TEXT},{szEDITTEXT,KYWD_ID_EDITTEXT},
    {szNUMERIC,KYWD_ID_NUMERIC},{szCOMBOBOX,KYWD_ID_COMBOBOX},
    {szDROPDOWNLIST,KYWD_ID_DROPDOWNLIST},{szLISTBOX,KYWD_ID_LISTBOX},
    {szEND,KYWD_ID_END}, {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0}};
KEYWORDINFO pSettingsTypeCmpList[] = {{szPART,KYWD_ID_PART},{NULL,0}};

KEYWORDINFO pCheckboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szVALUEON,KYWD_ID_VALUEON},{szVALUEOFF,KYWD_ID_VALUEOFF},
    {szACTIONLISTON,KYWD_ID_ACTIONLISTON},{szACTIONLISTOFF,KYWD_ID_ACTIONLISTOFF},
    {szDEFCHECKED, KYWD_ID_DEFCHECKED}, {szCLIENTEXT,KYWD_ID_CLIENTEXT},
    {szEND,KYWD_ID_END},{NULL,0} };

KEYWORDINFO pTextCmpList[] = {{szEND,KYWD_ID_END},{NULL,0}};

KEYWORDINFO pEditTextCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_EDITTEXT_DEFAULT},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},
    {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pComboboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szDEFAULT,KYWD_ID_COMBOBOX_DEFAULT},{szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
    {szREQUIRED,KYWD_ID_REQUIRED},{szMAXLENGTH,KYWD_ID_MAXLENGTH},
    {szOEMCONVERT,KYWD_ID_OEMCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pNumericCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szMIN, KYWD_ID_MIN},{szMAX,KYWD_ID_MAX},{szSPIN,KYWD_ID_SPIN},
    {szDEFAULT,KYWD_ID_NUMERIC_DEFAULT},{szREQUIRED,KYWD_ID_REQUIRED},
    {szTXTCONVERT,KYWD_ID_TXTCONVERT},{szSOFT,KYWD_ID_SOFT},
    {szEND,KYWD_ID_END}, {szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pDropdownlistCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUENAME,KYWD_ID_VALUENAME},
    {szREQUIRED,KYWD_ID_REQUIRED},{szITEMLIST,KYWD_ID_ITEMLIST},
    {szEND,KYWD_ID_END},{szNOSORT, KYWD_ID_NOSORT},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0}};

KEYWORDINFO pListboxCmpList[] = {
    {szKEYNAME,KYWD_ID_KEYNAME},{szVALUEPREFIX,KYWD_ID_VALUEPREFIX},
    {szADDITIVE,KYWD_ID_ADDITIVE},{szNOSORT, KYWD_ID_NOSORT},
    {szEXPLICITVALUE,KYWD_ID_EXPLICITVALUE},{szEXPANDABLETEXT,KYWD_ID_EXPANDABLETEXT},
    {szEND,KYWD_ID_END},{szCLIENTEXT,KYWD_ID_CLIENTEXT}, {NULL,0} };

KEYWORDINFO pClassCmpList[] = { {szCLASS, KYWD_ID_CLASS},
    {szCATEGORY,KYWD_ID_CATEGORY}, {szStringsSect,KYWD_ID_STRINGSSECT},
    {NULL,0} };
KEYWORDINFO pClassTypeCmpList[] = { {szUSER, KYWD_ID_USER},
    {szMACHINE,KYWD_ID_MACHINE}, {NULL,0} };

KEYWORDINFO pVersionCmpList[] = { {szVERSION, KYWD_ID_VERSION}, {NULL,0}};
KEYWORDINFO pOperatorCmpList[] = { {szGT, KYWD_ID_GT}, {szGTE,KYWD_ID_GTE},
    {szLT, KYWD_ID_LT}, {szLTE,KYWD_ID_LTE}, {szEQ,KYWD_ID_EQ},
    {szNE, KYWD_ID_NE}, {NULL,0}};


//
// Help ID's
//

DWORD aADMHelpIds[] = {

    // Templates dialog
    IDC_TEMPLATELIST,             (IDH_HELPFIRST + 0),
    IDC_ADDTEMPLATES,             (IDH_HELPFIRST + 1),
    IDC_REMOVETEMPLATES,          (IDH_HELPFIRST + 2),

    0, 0
};

DWORD aPolicyHelpIds[] = {

    // ADM Policy UI page
    IDC_NOCONFIG,                 (IDH_HELPFIRST + 11),
    IDC_ENABLED,                  (IDH_HELPFIRST + 12),
    IDC_DISABLED,                 (IDH_HELPFIRST + 13),
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),
    0, 0
};

DWORD aExplainHelpIds[] = {

    // Explain page
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),

    0, 0
};

DWORD aPrecedenceHelpIds[] = {

    // Precedence page
    IDC_POLICY_PRECEDENCE,        (IDH_HELPFIRST + 16),
    IDC_POLICY_PREVIOUS,          (IDH_HELPFIRST + 14),
    IDC_POLICY_NEXT,              (IDH_HELPFIRST + 15),

    0, 0
};

DWORD aFilteringHelpIds[] = {

    // Filtering options
    IDC_STATIC,                   (DWORD)         (-1),                 // disabled help
    IDC_FILTERING_ICON,           (DWORD)         (-1),                 // disabled help
    IDC_SUPPORTEDONTITLE,         (DWORD)         (-1),                 // disabled help
    IDC_SUPPORTEDOPTION,          (IDH_HELPFIRST + 20),
    IDC_FILTERLIST,               (IDH_HELPFIRST + 21),
    IDC_SELECTALL,                (IDH_HELPFIRST + 22),
    IDC_DESELECTALL,              (IDH_HELPFIRST + 23),
    IDC_SHOWCONFIG,               (IDH_HELPFIRST + 24),
    IDC_SHOWPOLICIES,             (IDH_HELPFIRST + 25),

    0, 0
};

#define ADM_USELOCAL_KEY            TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy")
#define GPE_KEY                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy Editor")
#define GPE_POLICIES_KEY            TEXT("Software\\Policies\\Microsoft\\Windows\\Group Policy Editor")
#define ADM_USELOCAL_VALUE          TEXT("OnlyUseLocalAdminFiles")
#define POLICYONLY_VALUE            TEXT("ShowPoliciesOnly")
#define DISABLE_AUTOUPDATE_VALUE    TEXT("DisableAutoADMUpdate")
#define SOFTWARE_POLICIES           TEXT("Software\\Policies")
#define WINDOWS_POLICIES            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies")


typedef struct _GPOERRORINFO
{
    DWORD   dwError;
    LPTSTR  lpMsg;
    LPTSTR  lpDetails;
} GPOERRORINFO, *LPGPOERRORINFO;

//
// Help ids
//

DWORD aErrorHelpIds[] =
{

    0, 0
};

LPHASHTABLE CreateHashTable (void);
VOID FreeHashTable (LPHASHTABLE lpTable);
ULONG CalculateHashInfo(LPTSTR lpName, DWORD dwChars, DWORD *pdwHashValue);
BOOL AddHashEntry (LPHASHTABLE lpTable, LPTSTR lpName, DWORD dwChars);
LPTSTR FindHashEntry (LPHASHTABLE lpTable, LPTSTR lpName, DWORD dwChars);
#if DBG
VOID DumpHashTableDetails (LPHASHTABLE lpTable);
#endif




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicyComponentData::CPolicyComponentData(BOOL bUser, BOOL bRSOP)
{
    TCHAR szEvent[200];
    HRESULT hr = S_OK;

    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_hSWPolicies = NULL;
    m_pGPTInformation = NULL;
    m_pRSOPInformation = NULL;
    m_pRSOPRegistryData = NULL;
    m_pszNamespace = NULL;
    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
    m_pMachineCategoryList = NULL;
    m_nMachineDataItems = 0;
    m_pUserCategoryList = NULL;
    m_nUserDataItems = 0;
    m_pSupportedStrings = 0;
    m_iSWPoliciesLen = lstrlen(SOFTWARE_POLICIES);
    m_iWinPoliciesLen = lstrlen(WINDOWS_POLICIES);
    m_bUseSupportedOnFilter = FALSE;
    m_pDefaultHashTable = NULL;
    m_pLanguageHashTable = NULL;
    m_pLocaleHashTable = NULL;


    if (bRSOP)
    {
        m_bShowConfigPoliciesOnly = TRUE;
    }
    else
    {
        m_bShowConfigPoliciesOnly = FALSE;
    }

    m_pSnapin = NULL;
    m_hTemplateThread = NULL;
    
    hr = StringCchPrintf (szEvent, ARRAYSIZE(szEvent), TEXT("gptext: ADM files ready event, %d:%d"), bUser, GetTickCount());
    ASSERT(SUCCEEDED(hr));

    m_ADMEvent = CreateEvent (NULL, TRUE, FALSE, szEvent);

    if (!m_ADMEvent)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::CPolicyComponentData: Failed to create ADM event with %d."),
                 GetLastError()));
    }


    LoadString (g_hInstance, IDS_POLICY_NAME, m_szRootName, ROOT_NAME_SIZE);

    m_pExtraSettingsRoot = NULL;
    m_bExtraSettingsInitialized = FALSE;
}

CPolicyComponentData::~CPolicyComponentData()
{

    //
    // Wait for the Template thread to finish before continuing.
    //
    
    if (m_hTemplateThread)
        WaitForSingleObject(m_hTemplateThread, INFINITE);

    FreeTemplates ();

    if (m_pExtraSettingsRoot)
    {
        FreeTable ((TABLEENTRY *)m_pExtraSettingsRoot);
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    if (m_pRSOPInformation)
    {
        m_pRSOPInformation->Release();
    }

    if (m_pRSOPRegistryData)
    {
        FreeRSOPRegistryData();
    }

    if (m_pszNamespace)
    {
        LocalFree (m_pszNamespace);
    }

    CloseHandle (m_ADMEvent);
    
    if (m_hTemplateThread) 
        CloseHandle (m_hTemplateThread);

    m_hTemplateThread = NULL;

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IUnknown)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicyComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicyComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IComponentData)               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }

    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();


    //
    // Create the root of the Extra Settings node if appropriate
    //

    if (m_bRSOP)
    {
        DWORD dwBufSize;
        REGITEM *pTmp;
        TCHAR szBuffer[100];

        m_pExtraSettingsRoot = (REGITEM *) GlobalAlloc(GPTR, sizeof(REGITEM));

        if (!m_pExtraSettingsRoot)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: GlobalAlloc failed with %d"), GetLastError()));
            return HRESULT_FROM_WIN32(GetLastError());
        }

        m_pExtraSettingsRoot->dwSize = sizeof(REGITEM);
        m_pExtraSettingsRoot->dwType = (ETYPE_ROOT | ETYPE_REGITEM);


        LoadString (g_hInstance, IDS_EXTRAREGSETTINGS, szBuffer, ARRAYSIZE(szBuffer));

        pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)m_pExtraSettingsRoot,
            (BYTE *)szBuffer,(lstrlen(szBuffer)+1) * sizeof(TCHAR),&(m_pExtraSettingsRoot->uOffsetName),
            &dwBufSize);

        if (!pTmp)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Initialize: AddDataToEntry failed.")));
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }

        m_pExtraSettingsRoot = pTmp;
    }


    return S_OK;
}

STDMETHODIMP CPolicyComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CPolicyComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CPolicySnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CPolicySnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::CreateComponent: Failed to create CPolicySnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI

    m_pSnapin = pSnapIn;

    return hr;
}

STDMETHODIMP CPolicyComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CPolicyDataObject *pDataObject;
    LPPOLICYDATAOBJECT pPolicyDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CPolicyDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pPolicyDataObject->SetType(type);
    pPolicyDataObject->SetCookie(cookie);
    pPolicyDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

    STDMETHODIMP CPolicyComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_REMOVE_CHILDREN:
            if ( ((HSCOPEITEM)arg != NULL) && m_bRSOP && (m_pRSOPInformation != NULL) )
            {
                if ( (m_hRoot == NULL) || ((HSCOPEITEM)arg == m_hRoot) )
                {
                    FreeRSOPRegistryData();
                    m_hRoot = NULL;
                    m_hSWPolicies = NULL;
                    m_pRSOPInformation->Release();
                    m_pRSOPInformation = NULL;
                }
            }
            break;
            
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (m_bRSOP)
                {
                    if ( m_pRSOPInformation == NULL )
                    {
                        lpDataObject->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);

                        if (m_pRSOPInformation)
                        {
                            m_pszNamespace = (LPOLESTR) LocalAlloc (LPTR, 350 * sizeof(TCHAR));

                            if (m_pszNamespace)
                            {
                                if (m_pRSOPInformation->GetNamespace((m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                                                      m_pszNamespace, 350) == S_OK)
                                {
                                    InitializeRSOPRegistryData();

                                    // Check if there are any entries
                                    if ( m_pRSOPRegistryData == NULL )
                                    {
                                        LocalFree( m_pszNamespace );
                                        m_pszNamespace = NULL;
                                        m_pRSOPInformation->Release();
                                        m_pRSOPInformation = NULL;
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::Notify:  Failed to query for namespace")));
                                    LocalFree (m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }
                    }

                    if (m_pszNamespace && m_pRSOPRegistryData)
                    {
                        hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                    }
                }
                else
                {
                    if (!m_pGPTInformation)
                    {
                        lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                    }

                    if (m_pGPTInformation)
                    {
                        hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                    }
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CPolicyComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    TABLEENTRY * pTableEntry;

    if (pItem == NULL)
        return E_POINTER;


    if (pItem->lParam == 0)
    {
        pItem->displayname = m_szRootName;
    }
    else
    {
        pTableEntry = (TABLEENTRY *)(pItem->lParam);
        pItem->displayname = GETNAMEPTR(pTableEntry);
    }

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPPOLICYDATAOBJECT pPolicyDataObjectA, pPolicyDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectB)))
    {
        pPolicyDataObjectA->Release();
        return S_FALSE;
    }

    pPolicyDataObjectA->GetCookie(&cookie1);
    pPolicyDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pPolicyDataObjectA->Release();
    pPolicyDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IExtendContextMenu)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;
    LPPOLICYDATAOBJECT pPolicyDataObject;
    MMC_COOKIE cookie = -1;
    DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;

    if (!m_bRSOP)
    {
        if (SUCCEEDED(piDataObject->QueryInterface(IID_IPolicyDataObject,
                     (LPVOID *)&pPolicyDataObject)))
        {
            pPolicyDataObject->GetType(&type);
            pPolicyDataObject->GetCookie(&cookie);

            pPolicyDataObject->Release();
        }


        if ((type == CCT_SCOPE) && (cookie == 0))
        {
            LoadString (g_hInstance, IDS_TEMPLATES, szMenuItem, 100);
            LoadString (g_hInstance, IDS_TEMPLATESDESC, szDescription, 250);

            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_TEMPLATES;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);

            if (FAILED(hr))
                return (hr);


            item.strName = szMenuItem;
            item.strStatusBarText = szDescription;
            item.lCommandID = IDM_TEMPLATES2;
            item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            item.fFlags = 0;
            item.fSpecialFlags = 0;

            hr = pCallback->AddItem(&item);
        }
    }

    return (hr);
}

STDMETHODIMP CPolicyComponentData::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    if ((lCommandID == IDM_TEMPLATES) || (lCommandID == IDM_TEMPLATES2))
    {
        m_bTemplatesColumn = 0;
        if (DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_TEMPLATES),
                        m_hwndFrame, TemplatesDlgProc, (LPARAM) this))
        {
            //
            // Refresh the adm namespace
            //

            PostMessage (HWND_BROADCAST, m_pSnapin->m_uiRefreshMsg, 0, (LPARAM) GetCurrentProcessId());
        }
    }

    return S_OK;

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (IPersistStreamInit)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    if (m_bUserScope)
        *pClassID = CLSID_PolicySnapInUser;
    else
        *pClassID = CLSID_PolicySnapInMachine;

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CPolicyComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CPolicyComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CPolicyComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CPolicyComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (ISnapinHelp)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicyComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gptext.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyComponentData object implementation (Internal functions)           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    TABLEENTRY *pTemp = NULL;
    DWORD dwResult;
    CPolicySnapIn * pSnapin = NULL, *pSnapinTemp;
    BOOL bRootItem = FALSE;
    HANDLE hEvents[1];


    if (!m_hRoot)
    {
        DWORD dwID;

        m_hRoot = hParent;

        m_hTemplateThread = CreateThread (NULL, 0,
                               (LPTHREAD_START_ROUTINE) LoadTemplatesThread,
                               (LPVOID) this, 0, &dwID);

        if (m_hTemplateThread)
        {
            SetThreadPriority(m_hTemplateThread, THREAD_PRIORITY_LOWEST);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: Failed to create adm thread with %d"),
                      GetLastError()));
            LoadTemplates();
        }
    }


    if (m_hRoot == hParent)
    {
        item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
        item.displayname = MMC_CALLBACK;
        item.nImage = 0;
        item.nOpenImage = 1;
        item.nState = 0;
        item.cChildren = 1;
        item.lParam = 0;
        item.relativeID =  hParent;

        m_pScope->Expand(hParent);

        if (SUCCEEDED(m_pScope->InsertItem (&item)))
        {
            m_hSWPolicies = item.ID;
        }

        return S_OK;
    }

    hEvents[0] = m_ADMEvent;

    if (WaitForSingleObject (m_ADMEvent, 250) != WAIT_OBJECT_0)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Waiting for ADM event to be signaled.")));

        for (;;) {
            SetCursor (LoadCursor(NULL, IDC_WAIT));

            dwResult = MsgWaitForMultipleObjects(1, hEvents, FALSE, INFINITE, QS_ALLINPUT);

            if (dwResult == WAIT_OBJECT_0 ) {
                break;
            }
            else if (dwResult == WAIT_OBJECT_0 + 1 ) {
                MSG msg;
                
                while ( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) )
                {
                  TranslateMessage(&msg);
                  DispatchMessage(&msg);
                }
            }
            else {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: MsgWaitForMultipleObjects returned %d ."), dwResult));
                break;
            }

        }
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumerateScopePane: ADM event has been signaled.")));
        SetCursor (LoadCursor(NULL, IDC_ARROW));
    }

    
    item.mask = SDI_PARAM;
    item.ID = hParent;

    hr = m_pScope->GetItem (&item);

    if (FAILED(hr))
        return hr;


    EnterCriticalSection (&g_ADMCritSec);

    if (item.lParam)
    {
        pTemp = ((TABLEENTRY *)item.lParam)->pChild;
    }
    else
    {
        bRootItem = TRUE;

        if (m_bUserScope)
        {
            if (m_pUserCategoryList)
            {
                pTemp = m_pUserCategoryList->pChild;
            }
            else
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Empty user list.")));
            }
        }
        else
        {
            if (m_pMachineCategoryList)
            {
                pTemp = m_pMachineCategoryList->pChild;
            }
            else
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::EnumerateScopePane: Empty machine list.")));
            }
        }
    }

    //
    // If the user has set the focus on a adm node and then saves the console file,
    // the IComponent won't be created yet.  We need to create a temporary IComponent
    // to parse the data and then release it.
    //

    if (m_pSnapin)
    {
        pSnapinTemp = m_pSnapin;
    }
    else
    {
        pSnapinTemp = pSnapin = new CPolicySnapIn(this);
    }

    while (pTemp)
    {
        if (pTemp->dwType == ETYPE_CATEGORY)
        {
            BOOL bAdd = TRUE;

            if (m_bUseSupportedOnFilter)
            {
                bAdd = IsAnyPolicyAllowedPastFilter(pTemp);
            }

            if (bAdd && m_bShowConfigPoliciesOnly)
            {
               if (pSnapinTemp)
               {
                   bAdd = pSnapinTemp->IsAnyPolicyEnabled(pTemp);
               }
            }


            if (bAdd)
            {
                m_pScope->Expand(hParent);
                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = 0;
                item.nOpenImage = 1;
                item.nState = 0;
                item.cChildren = (CheckForChildCategories(pTemp) ? 1 : 0);
                item.lParam = (LPARAM) pTemp;
                item.relativeID =  hParent;

                m_pScope->InsertItem (&item);
            }
        }

        pTemp = pTemp->pNext;
    }

    //
    // Add the Extra Registry Settings node if appropriate
    //

    if (bRootItem && m_pExtraSettingsRoot)
    {
        if (!m_bExtraSettingsInitialized)
        {
            InitializeExtraSettings();
            m_bExtraSettingsInitialized = TRUE;

            if (LOWORD(dwDebugLevel) == DL_VERBOSE)
            {
                DumpRSOPRegistryData();
            }
        }

        if (m_pExtraSettingsRoot->pChild)
        {
            m_pScope->Expand(hParent);
            
            item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
            item.displayname = MMC_CALLBACK;
            item.nImage = 0;
            item.nOpenImage = 1;
            item.nState = 0;
            item.cChildren = 0;
            item.lParam = (LPARAM) m_pExtraSettingsRoot;
            item.relativeID =  hParent;

            m_pScope->InsertItem (&item);
        }
    }

    if (pSnapin)
    {
        pSnapin->Release();
    }

    LeaveCriticalSection (&g_ADMCritSec);

    return S_OK;
}

BOOL CPolicyComponentData::CheckForChildCategories (TABLEENTRY *pParent)
{
    TABLEENTRY * pTemp;

    if (pParent->pChild)
    {
        pTemp = pParent->pChild;

        while (pTemp)
        {
            if (pTemp->dwType == ETYPE_CATEGORY)
            {
                return TRUE;
            }

            pTemp = pTemp->pNext;
        }
    }

    return FALSE;
}

#if DBG

//
// These are a couple of debugging helper functions that will dump
// the adm namespace to the debugger.  Call DumpCurrentTable() to
// get the full namespace.
//

VOID CPolicyComponentData::DumpEntry (TABLEENTRY * pEntry, UINT uIndent)
{
    UINT i;
    TCHAR szDebug[50];

    if (!pEntry)
        return;

    if (pEntry == (TABLEENTRY*) ULongToPtr(0xfeeefeee))
    {
        OutputDebugString (TEXT("Invalid memory address found.\r\n"));
        return;
    }

    while (pEntry)
    {
        if ((pEntry->dwType & ETYPE_CATEGORY) || (pEntry->dwType & ETYPE_POLICY))
        {
            for (i=0; i<uIndent; i++)
                OutputDebugString(TEXT(" "));

            OutputDebugString (GETNAMEPTR(pEntry));

            if (pEntry->pNext && pEntry->pChild)
                StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT(" (0x%x, 0x%x)"),pEntry->pNext, pEntry->pChild);

            else if (!pEntry->pNext && pEntry->pChild)
                StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT(" (NULL, 0x%x)"),pEntry->pChild);

            else if (pEntry->pNext && !pEntry->pChild)
                StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT(" (0x%x, NULL)"),pEntry->pNext);

            OutputDebugString (szDebug);
            OutputDebugString (TEXT("\r\n"));
        }

        if (pEntry->pChild)
            DumpEntry(pEntry->pChild, (uIndent + 4));

        pEntry = pEntry->pNext;
    }
}


VOID CPolicyComponentData::DumpCurrentTable (void)
{
    OutputDebugString (TEXT("\r\n"));
    OutputDebugString (TEXT("\r\n"));
    DumpEntry (m_pListCurrent, 4);
    OutputDebugString (TEXT("\r\n"));
    OutputDebugString (TEXT("\r\n"));
}
#endif

VOID CPolicyComponentData::FreeTemplates (void)
{

    EnterCriticalSection (&g_ADMCritSec);

    if (m_pMachineCategoryList)
    {
        FreeTable(m_pMachineCategoryList);
        m_pMachineCategoryList = NULL;
        m_nMachineDataItems = 0;
    }

    if (m_pUserCategoryList)
    {
        FreeTable(m_pUserCategoryList);
        m_pUserCategoryList = NULL;
        m_nUserDataItems = 0;
    }

    if (m_pSupportedStrings)
    {
        FreeSupportedData(m_pSupportedStrings);
        m_pSupportedStrings = NULL;
    }

    LeaveCriticalSection (&g_ADMCritSec);
}





////////////////////////////////////////////////////////////////////////////
//                                                                        //
//  BOOL CPolicyComponentData::IsADMAutoUpdateDisabled()                  //
//                                                                        //
//  Purpose: Checks if autoupdate of ADM templates is disabled or not     //
//                                                                        //
//  Returns: TRUE if autoupdate is disabled.                              //
//           FALSE  otherwise                                             //  
//                                                                        //
////////////////////////////////////////////////////////////////////////////

BOOL CPolicyComponentData::IsADMAutoUpdateDisabled(void)
{
    BOOL    bDisableAutoUpdate = FALSE;
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_KEY, 0,
                  KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bDisableAutoUpdate);
        RegQueryValueEx (hKey, DISABLE_AUTOUPDATE_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisableAutoUpdate, &dwSize);
        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bDisableAutoUpdate);
        RegQueryValueEx (hKey, DISABLE_AUTOUPDATE_VALUE, NULL, &dwType,
                         (LPBYTE) &bDisableAutoUpdate, &dwSize);

        RegCloseKey (hKey);
    }


    if (bDisableAutoUpdate)
    {
        DebugMsg((DM_VERBOSE, TEXT("IsADMAutoUpdateDisabled: Automatic update of ADM files is disabled.")));
        return TRUE;
    }

    return FALSE;
}



DWORD CPolicyComponentData::LoadTemplatesThread (CPolicyComponentData * pCD)
{
    HRESULT hr;
    HINSTANCE hInstDLL;

    hInstDLL = LoadLibrary (TEXT("gptext.dll"));

    Sleep(0);

    hr = pCD->LoadTemplates();

    if (hInstDLL)
    {
        FreeLibraryAndExitThread (hInstDLL, (DWORD) hr);
    }

    return (DWORD)hr;
}

void CPolicyComponentData::AddTemplates(LPTSTR lpDest, LPCTSTR lpValueName, UINT idRes)
{
    TCHAR szFiles[MAX_PATH];
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szLogFile[MAX_PATH];
    LPTSTR lpTemp, lpFileName, lpSrc, lpEnd;
    HKEY hKey;
    DWORD dwSize, dwType;
    HRESULT hr = S_OK;

    //
    // Add the adm files.  We get this list from 3 possible
    // places.  The resources, user preferences, policy.
    //

    hr = StringCchCopy (szDest, ARRAYSIZE(szDest), lpDest);
    ASSERT(SUCCEEDED(hr));

    lpEnd = CheckSlash (szDest);

    hr = StringCchCopy (szLogFile, ARRAYSIZE(szLogFile), lpDest);
    ASSERT(SUCCEEDED(hr));

    hr = StringCchCat (szLogFile, ARRAYSIZE(szLogFile), TEXT("\\admfiles.ini"));
    ASSERT(SUCCEEDED(hr));

    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szSrc, ARRAYSIZE(szSrc));
    lpSrc = CheckSlash (szSrc);
    ZeroMemory (szFiles, sizeof(szFiles));

    LoadString (g_hInstance, idRes, szFiles,
                ARRAYSIZE(szFiles));

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szUserPrefKey, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szFiles);
        RegQueryValueEx (hKey, lpValueName, NULL, &dwType,
                         (LPBYTE) szFiles, &dwSize);
        RegCloseKey (hKey);
    }

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szPoliciesKey, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szFiles);
        RegQueryValueEx (hKey, lpValueName, NULL, &dwType,
                         (LPBYTE) szFiles, &dwSize);
        RegCloseKey (hKey);
    }


    //
    // Parse off the filenames
    //

    lpTemp = lpFileName = szFiles;

    while (*lpTemp)
    {

        while (*lpTemp && (*lpTemp != TEXT(';')))
            lpTemp++;

        if (*lpTemp == TEXT(';'))
        {
            *lpTemp = TEXT('\0');
            lpTemp++;
        }

        while (*lpFileName == TEXT(' '))
            lpFileName++;

        hr = StringCchCopy (lpEnd, ARRAYSIZE(szDest) - (lpEnd - szDest), lpFileName);
        ASSERT(SUCCEEDED(hr));

        hr = StringCchCopy (lpSrc, ARRAYSIZE(szSrc) - (lpSrc - szSrc), lpFileName);
        ASSERT(SUCCEEDED(hr));

        //
        // Check if this file is already in the admfile.ini log
        // If so, skip it
        //

        if (!GetPrivateProfileInt (TEXT("FileList"), lpFileName, 0, szLogFile))
        {
            if (CopyFile (szSrc, szDest, FALSE))
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::AddTemplates: Successfully copied %s to %s."), szSrc, szDest));
                WritePrivateProfileString (TEXT("FileList"), lpFileName, TEXT("1"), szLogFile);
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to copy %s to %s with %d."), szSrc, szDest, GetLastError()));
            }
        }

        lpFileName = lpTemp;
    }

    SetFileAttributes (szLogFile, FILE_ATTRIBUTE_HIDDEN);

}

void CPolicyComponentData::AddDefaultTemplates(LPTSTR lpDest)
{
    AddTemplates (lpDest, szDefaultTemplates, IDS_DEFAULTTEMPLATES);
}

void CPolicyComponentData::AddNewADMsToExistingGPO (LPTSTR lpDest)
{
    TCHAR szLogFile[MAX_PATH];
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HRESULT hr = S_OK;


    //
    // This method will add any new adm files to a GPO.
    //
    // Note: the admfiles.ini file is new post-W2k, so we have to do a special
    // case when upgrading a GPO created by w2k to create that file and add
    // the default filenames
    //

    hr = StringCchCopy (szLogFile, ARRAYSIZE(szLogFile), lpDest);
    ASSERT(SUCCEEDED(hr));

    hr = StringCchCat (szLogFile, ARRAYSIZE(szLogFile), TEXT("\\admfiles.ini"));
    ASSERT(SUCCEEDED(hr));

    if (!GetFileAttributesEx (szLogFile, GetFileExInfoStandard, &fad))
    {
        WritePrivateProfileString (TEXT("FileList"), TEXT("system.adm"), TEXT("1"), szLogFile);
        WritePrivateProfileString (TEXT("FileList"), TEXT("inetres.adm"), TEXT("1"), szLogFile);
        WritePrivateProfileString (TEXT("FileList"), TEXT("conf.adm"), TEXT("1"), szLogFile);
    }

    AddTemplates (lpDest, szAdditionalTemplates, IDS_ADDITIONALTTEMPLATES);
}


HRESULT CPolicyComponentData::CreateAdmIniFile (WCHAR *szAdmDirPath)
{
    WCHAR      szIniFilePath[MAX_PATH];
    WCHAR      szFileList[MAX_PATH];
    WCHAR      *lpStart;
    WCHAR      *lpCharLoc;
    HRESULT    hr;

    hr = StringCchCopy(szIniFilePath, ARRAYSIZE(szIniFilePath), szAdmDirPath);
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (lstrlen (szIniFilePath) < MAX_PATH - 1) 
    {
        CheckSlash (szIniFilePath);
    }
    else
    {
        return STRSAFE_E_INSUFFICIENT_BUFFER;
    }

    hr = StringCchCat (szIniFilePath, ARRAYSIZE(szIniFilePath), L"admfiles.ini");
    if (FAILED(hr)) 
    {
        return hr;
    }

    if (LoadString (g_hInstance, IDS_DEFAULTTEMPLATES, szFileList, ARRAYSIZE(szFileList)) == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    lpStart = szFileList;
    lpCharLoc = szFileList;

    while (lpCharLoc)
    {
        lpCharLoc = wcschr (lpStart, L';');
        if (lpCharLoc) 
        {
            *lpCharLoc = L'\0';
        }

        if (!WritePrivateProfileString (L"FileList", lpStart, L"1", szIniFilePath))
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }

        if (lpCharLoc) 
        {
            lpStart = lpCharLoc + 1;
        }
    }

    (void) SetFileAttributes (szIniFilePath, FILE_ATTRIBUTE_HIDDEN);
    return S_OK;
}

void CPolicyComponentData::UpdateExistingTemplates(LPTSTR lpDest)
{
    WIN32_FILE_ATTRIBUTE_DATA fadSrc, fadDest;
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    LPTSTR lpSrc, lpEnd;
    WIN32_FIND_DATA fd;
    HANDLE hFindFile;
    HRESULT hr = S_OK;

    //
    // Add any new adm files shipped with the OS
    //

    AddNewADMsToExistingGPO (lpDest);


    //
    // Build the path to the source directory
    //

    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szSrc, ARRAYSIZE(szSrc));
    lpSrc = CheckSlash (szSrc);


    //
    // Build the path to the destination directory
    //

    hr = StringCchCopy (szDest, ARRAYSIZE(szDest), lpDest);
    ASSERT(SUCCEEDED(hr));

    lpEnd = CheckSlash (szDest);
    
    hr = StringCchCopy (lpEnd, ARRAYSIZE(szDest) - (lpEnd - szDest), TEXT("*.adm"));
    ASSERT(SUCCEEDED(hr));

    //
    // Enumerate the files
    //

    hFindFile = FindFirstFile(szDest, &fd);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                hr = StringCchCopy (lpEnd, ARRAYSIZE(szDest) - (lpEnd - szDest), fd.cFileName);
                ASSERT(SUCCEEDED(hr));

                hr = StringCchCopy (lpSrc, ARRAYSIZE(szSrc) - (lpSrc - szSrc), fd.cFileName);
                ASSERT(SUCCEEDED(hr));

                //
                // Get the file attributes of the source and destination
                //

                ZeroMemory (&fadSrc, sizeof(fadSrc));
                ZeroMemory (&fadDest, sizeof(fadDest));

                GetFileAttributesEx (szSrc, GetFileExInfoStandard, &fadSrc);
                GetFileAttributesEx (szDest, GetFileExInfoStandard, &fadDest);


                //
                // If the source is a newer than the dest
                // copy the .adm file
                //
                BOOL bUpdateNeeded;

                bUpdateNeeded = FALSE;

                //
                // Check the time stamp to see if the
                // source is newer than the destination -- if so, an update is needed
                //

                if (CompareFileTime(&fadSrc.ftLastWriteTime, &fadDest.ftLastWriteTime) == 1)
                {
                    bUpdateNeeded = TRUE;
                }

                if ( bUpdateNeeded )
                {
                    if (CopyFile (szSrc, szDest, FALSE))
                        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::UpdateExistingTemplates: Successfully copied %s to %s."), szSrc, szDest));
                    else
                        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::UpdateExistingTemplates: Failed to copy %s to %s with %d."), szSrc, szDest, GetLastError()));
                }
            }

        } while (FindNextFile(hFindFile, &fd));

        FindClose(hFindFile);
    }
}


HRESULT CPolicyComponentData::LoadGPOTemplates (void)
{

    LPTSTR   lpEnd;
    UINT     iResult;
    HKEY     hAdmKey; 
    DWORD    dwError;
    DWORD    dwRegVal = 0;
    DWORD    dwSize;
    TCHAR    szPath[MAX_PATH];
    BOOL     bADMAutoUpdateDisabled = FALSE;
    BOOL     bReadFromINF = FALSE;
    HRESULT  hr;

    // 
    // Get the path to the GPO directory in sysvol
    //

    hr = m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath, MAX_PATH);        
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadGPOTemplates: Failed to get gpt path.")));
        return hr;
    }

    //
    // Build the ADM path name
    //

    (void) CheckSlash (szPath);
    hr = StringCchCat (szPath, ARRAYSIZE(szPath), g_szADM);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Create ADM directory, if it doesn't exist
    // 

    iResult = CreateNestedDirectory (szPath, NULL);

    if (!iResult)
    {
        return E_FAIL;
    }

    //
    // Check if adm use local adm policy is set
    // 

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADM_USELOCAL_KEY, 0, KEY_EXECUTE, &hAdmKey);
    if ( ERROR_SUCCESS  == dwError )
    {
        dwSize = sizeof(DWORD);
        dwError = RegQueryValueEx(hAdmKey, ADM_USELOCAL_VALUE, NULL, NULL, (LPBYTE) &dwRegVal, &dwSize);
        if ( ERROR_SUCCESS == dwError && 1 == dwRegVal)
        {
            bReadFromINF = TRUE;
        }

        RegCloseKey(hAdmKey);
    }

    if (!bReadFromINF)
    {
        //
        // Check if the user wants their ADM files updated automatically
        //

        bADMAutoUpdateDisabled = IsADMAutoUpdateDisabled();


        if (bADMAutoUpdateDisabled) 
        {
            if (1 == iResult) 
            {
                //
                // Empty ADM directory is created. Read from INF
                //

                bReadFromINF = TRUE;
            }
            else
            {
                //
                // Check if any files of type *.adm exists
                // If not, read from INF directory
                //

                hr = IsFilePresent (szPath, L"*.adm");

                if (SUCCEEDED(hr)) 
                {
                    if (S_FALSE == hr) 
                    {
                        bReadFromINF = TRUE;
                    }
                }
                else
                {
                    return hr;
                }                
            }
        }
        else
        {
            if (1 == iResult)
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: adding default templates")));
                AddDefaultTemplates(szPath);
            }
            else
            {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: Updating templates")));
                UpdateExistingTemplates(szPath);
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: Finished updating templates")));
            }
        }
    }

    if (bReadFromINF) 
    {
        // 
        // Create admfiles.ini file if Adm file is created
        // This need not be done when update is done since
        // AddDefaultTemplates function creates this file.
        //

        if (1 == iResult) 
        {
            hr = CreateAdmIniFile (szPath);
            if (FAILED(hr)) 
            {
                return hr;
            }
        }

        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadGPOTemplates: Reading from inf")));
        iResult = ExpandEnvironmentStrings ( L"%SystemRoot%\\inf", szPath, MAX_PATH);
        if (0 == iResult )
        {
            dwError = GetLastError();
            return (HRESULT_FROM_WIN32(dwError));
        }
    }

    //
    // Enumerate the files
    //

    lpEnd = CheckSlash (szPath);
    hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), TEXT("*.adm"));
    if (FAILED(hr))
    {
        return hr;
    }

    HANDLE          hFindFile;
    WIN32_FIND_DATA fd;

    hFindFile = FindFirstFile(szPath, &fd);
    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), fd.cFileName);
                if (FAILED(hr)) 
                {
                    FindClose(hFindFile);
                    return hr;
                }
                ParseTemplate (szPath);
            }

        } while (FindNextFile(hFindFile, &fd));


        FindClose(hFindFile);
    }

    return S_OK;
}

#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define SLOW_LINK_TRANSFER_RATE      500  // Kbps

BOOL CPolicyComponentData::IsSlowLink (LPTSTR lpFileName)
{
    LPTSTR lpComputerName = NULL, lpTemp;
    LPSTR lpComputerNameA = NULL;
    BOOL bResult = FALSE;
    DWORD dwSize, dwResult, dwType;
    struct hostent *hostp;
    ULONG inaddr, ulSpeed, ulTransferRate;
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;
    DWORD dwLen = 0;

    //
    // Get the slow timeout
    //

    ulTransferRate = SLOW_LINK_TRANSFER_RATE;

    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           WINLOGON_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           SYSTEM_POLICIES_KEY,
                           0,
                           KEY_READ,
                           &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwSize = sizeof(ulTransferRate);
        RegQueryValueEx (hKey,
                         TEXT("GroupPolicyMinTransferRate"),
                         NULL,
                         &dwType,
                         (LPBYTE) &ulTransferRate,
                         &dwSize);

        RegCloseKey (hKey);
    }


    //
    // If the transfer rate is 0, then always download adm files
    //

    if (!ulTransferRate)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::IsSlowLink: Slow link transfer rate is 0.  Always download adm files.")));
        goto Exit;
    }


    //
    // Copy the namespace to a buffer we can edit and drop the leading \\ if present
    //

    dwLen = lstrlen(lpFileName) + 1;
    lpComputerName = (LPTSTR) LocalAlloc (LPTR, (dwLen) * sizeof(TCHAR));

    if (!lpComputerName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Failed to allocate memory for computer name with %d"),
                 GetLastError()));
        goto Exit;
    }


    if ((*lpFileName == TEXT('\\')) && (*(lpFileName+1) == TEXT('\\')))
    {
        hr = StringCchCopy (lpComputerName, dwLen, (lpFileName+2));
    }
    else
    {
        hr = StringCchCopy (lpComputerName, dwLen, lpFileName);
    }
    ASSERT(SUCCEEDED(hr));


    //
    // Find the slash between the computer name and the share name and replace it with null
    //

    lpTemp = lpComputerName;

    while (*lpTemp && (*lpTemp != TEXT('\\')))
    {
        lpTemp++;
    }

    if (!(*lpTemp))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Didn't find slash between computer name and share name in %s"),
                 lpComputerName));
        goto Exit;
    }


    *lpTemp = TEXT('\0');


    //
    // Allocate a buffer for the ANSI name
    //
    // Note this buffer is allocated twice as large so handle DBCS characters
    //

    dwSize = (lstrlen(lpComputerName) + 1) * 2;

    lpComputerNameA = (LPSTR) LocalAlloc (LPTR, dwSize);

    if (!lpComputerNameA)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::IsSlowLink:  Failed to allocate memory for ansi computer name with %d"),
                 GetLastError()));
        goto Exit;
    }


    //
    // Convert the computer name to ANSI
    //

    if (WideCharToMultiByte (CP_ACP, 0, lpComputerName, -1, lpComputerNameA, dwSize, NULL, NULL))
    {

        //
        // Get the host information for the computer
        //

        hostp = gethostbyname(lpComputerNameA);

        if (hostp)
        {

            //
            // Get the ip address of the computer
            //

            inaddr = *(long *)hostp->h_addr;


            //
            // Get the transfer rate
            //

            dwResult = PingComputer (inaddr, &ulSpeed);

            if (dwResult == ERROR_SUCCESS)
            {

                if (ulSpeed)
                {

                    //
                    // If the delta time is greater that the timeout time, then this
                    // is a slow link.
                    //

                    if (ulSpeed < ulTransferRate)
                    {
                        bResult = TRUE;
                    }
                }
            }
            else {
                DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::IsSlowLink: PingComputer failed with error %d. Treat it as slow link"), dwResult));
                bResult = TRUE;
            }
        }
    }


Exit:
    if (lpComputerName)
    {
        LocalFree (lpComputerName);
    }

    if (lpComputerNameA)
    {
        LocalFree (lpComputerNameA);
    }

    return bResult;

}

HRESULT CPolicyComponentData::AddADMFile (LPTSTR lpFileName, LPTSTR lpFullFileName,
                                          FILETIME *pFileTime, DWORD dwErr, LPRSOPADMFILE *lpHead)
{
    LPRSOPADMFILE lpTemp;
    HRESULT hr = S_OK;

    //
    // First, check if this file is already in the link list
    //

    lpTemp = *lpHead;

    while (lpTemp)
    {
        if (!lstrcmpi(lpFileName, lpTemp->szFileName))
        {
            if (CompareFileTime(pFileTime, &lpTemp->FileTime) == 1)
            {
                hr = StringCchCopy (lpTemp->szFullFileName, ARRAYSIZE(lpTemp->szFullFileName), lpFullFileName);

                if(FAILED(hr))
                    return hr;

                lpTemp->FileTime.dwLowDateTime = pFileTime->dwLowDateTime;
                lpTemp->FileTime.dwHighDateTime = pFileTime->dwHighDateTime;
            }

            return S_OK;
        }

        lpTemp = lpTemp->pNext;
    }

    //
    // Add a new node
    //

    lpTemp = (LPRSOPADMFILE) LocalAlloc (LPTR, sizeof(RSOPADMFILE));

    if (!lpTemp)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddADMFile: Failed to allocate memory for adm file node")));
        return (HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY));
    }

    hr = StringCchCopy (lpTemp->szFileName, ARRAYSIZE(lpTemp->szFileName), lpFileName);
    if (FAILED(hr))
    {
        LocalFree(lpTemp);
        return hr;
    }

    hr = StringCchCopy (lpTemp->szFullFileName, ARRAYSIZE(lpTemp->szFullFileName), lpFullFileName);
    if (FAILED(hr))
    {
        LocalFree(lpTemp);
        return hr;
    }

    lpTemp->FileTime.dwLowDateTime = pFileTime->dwLowDateTime;
    lpTemp->FileTime.dwHighDateTime = pFileTime->dwHighDateTime;
    lpTemp->dwError = dwErr;

    lpTemp->pNext = *lpHead;

    *lpHead = lpTemp;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////
//                                                                       //
// HRESULT CPolicyComponentData::GetLocalADMFiles(LPRSOPADMFILE *lpHead) // 
//                                                                       //    
// Purpose: Prepares a list of the *.adm filees present in %windir%\inf  //   
//          directory                                                    //  
//                                                                       //
// Parameters:                                                           //
//          lpHead [IN OUT] - Linked list containing list of file names  //
//                                                                       //
////////////////////////////////////////////////////////////////////////////

HRESULT CPolicyComponentData::GetLocalADMFiles( 
    LPRSOPADMFILE *lpHead)
{
    WCHAR       szPath[MAX_PATH];
    WCHAR       szFileName[MAX_PATH];
    WCHAR       szFullFileName[MAX_PATH];
    WCHAR       *pTemp;
    HANDLE      hFindFile;
    HRESULT     hr;
    FILETIME    FileTime;
    WIN32_FIND_DATA fd;
    
    ExpandEnvironmentStrings (L"%SystemRoot%\\Inf", szPath, ARRAYSIZE(szPath));
    pTemp = CheckSlash (szPath);
    hr = StringCchCopy (pTemp, ARRAYSIZE(szPath) - (pTemp - szPath), L"*.adm");
    ASSERT(SUCCEEDED(hr));
 
    FileTime.dwLowDateTime = 0;
    FileTime.dwHighDateTime = 0;

    //
    // Enumerate the files
    //

    hFindFile = FindFirstFile(szPath, &fd);

    if (hFindFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                hr = StringCchCopy (szFileName, ARRAYSIZE(szFileName), fd.cFileName);
                if (FAILED(hr))
                {
                    FindClose(hFindFile);
                    return hr;
                }

                ExpandEnvironmentStrings (L"%SystemRoot%\\Inf\\", szFullFileName, ARRAYSIZE(szPath));
                
                hr = StringCchCat (szFullFileName, ARRAYSIZE(szFileName), szFileName);
                if (FAILED(hr))
                {
                    FindClose(hFindFile);
                    return hr;
                }

                hr = AddADMFile (szFileName, szFullFileName, &FileTime, 0, lpHead);
                if (FAILED(hr))
                {
                    FindClose(hFindFile);
                    return hr;
                }
            }
        } while (FindNextFile(hFindFile, &fd));

        FindClose(hFindFile);
    }

    return S_OK;
}


HRESULT CPolicyComponentData::LoadRSOPTemplates (void)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pName = NULL, pLastWriteTime = NULL, pNamespace = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varName, varLastWriteTime;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    SYSTEMTIME SysTime;
    FILETIME FileTime;
    LPTSTR lpFileName;
    LPRSOPADMFILE lpADMFiles = NULL, lpTemp, lpDelete, lpFailedAdmFiles = NULL;
    DWORD dwFailedAdm = 0;
    XBStr xbstrWbemTime;
    DWORD dwError;
    TCHAR szPath[MAX_PATH];
    BOOL bSlowLink = FALSE;


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Entering")));

    CoInitialize(NULL);

    //
    // First get the local ADM files
    // Any ADM Files found in the sysvol will be overwrite local ADM files
    //

    GetLocalADMFiles(&lpADMFiles);

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pQuery = SysAllocString (TEXT("SELECT name, lastWriteTime FROM RSOP_AdministrativeTemplateFile"));

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pLastWriteTime = SysAllocString (TEXT("lastWriteTime"));

    if (!pLastWriteTime)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for last write time")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pIWbemServices,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Exit;
    }

    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
    {

        //
        // Check for the "data not available case"
        //

        if (ulRet == 0)
        {
            hr = S_OK;
            goto Exit;
        }


        //
        // Get the name
        //

        hr = pObjects[0]->Get (pName, 0, &varName, NULL, NULL);

        if (SUCCEEDED(hr))
        {
            //
            // Get the last write time
            //

            hr = pObjects[0]->Get (pLastWriteTime, 0, &varLastWriteTime, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                xbstrWbemTime = varLastWriteTime.bstrVal;

                hr = WbemTimeToSystemTime(xbstrWbemTime, SysTime);

                if (SUCCEEDED(hr))
                {
                    SystemTimeToFileTime (&SysTime, &FileTime);

                    lpFileName = varName.bstrVal + lstrlen(varName.bstrVal);

                    while ((lpFileName > varName.bstrVal) && (*lpFileName != TEXT('\\')))
                        lpFileName--;

                    if (*lpFileName == TEXT('\\'))
                    {
                        lpFileName++;
                    }

                    AddADMFile (lpFileName, varName.bstrVal, &FileTime, 0, &lpADMFiles);
                }

                VariantClear (&varLastWriteTime);
            }

            VariantClear (&varName);
        }

        pObjects[0]->Release();
    }


    //
    // Parse the adm files
    //

    lpTemp = lpADMFiles;

    while (lpTemp)
    {
        SetLastError(ERROR_SUCCESS);

        if (!bSlowLink)
        {
            bSlowLink = IsSlowLink (lpTemp->szFullFileName);
        }

        if (bSlowLink || !ParseTemplate(lpTemp->szFullFileName))
        {
            //
            // If the adm file failed to parse for any of the reasons listed
            // below, switch over to using the local copy of the ADM file
            //

            dwError = GetLastError();

            if (bSlowLink || ((dwError != ERROR_SUCCESS) && 
                              (dwError != ERROR_ALREADY_DISPLAYED)))
            {
                if (bSlowLink)
                {
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Using local copy of %s due to slow link detection."),
                    lpTemp->szFileName));
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Unable to parse template %s due to error %d.  Switching to the local copy of %s."),
                    lpTemp->szFullFileName, dwError, lpTemp->szFileName));
                    AddADMFile (lpTemp->szFileName, lpTemp->szFullFileName, &(lpTemp->FileTime), dwError, &lpFailedAdmFiles);
                    dwFailedAdm++;
                }
                ExpandEnvironmentStrings (TEXT("%SystemRoot%\\inf\\"), szPath, MAX_PATH);

                hr = StringCchCat (szPath, ARRAYSIZE(szPath), lpTemp->szFileName);
                ASSERT(SUCCEEDED(hr));

                ParseTemplate (szPath);
            }
        }

        lpDelete = lpTemp;
        lpTemp = lpTemp->pNext;
        LocalFree (lpDelete);
    }



    hr = S_OK;

    //
    // Format a error msg for the failed adm files
    // ignore any errors
    //

    if (dwFailedAdm) {
        LPTSTR lpErr = NULL, lpEnd = NULL;
        TCHAR szErrFormat[MAX_PATH];
        TCHAR szError[MAX_PATH];

        LoadString (g_hInstance, IDS_FAILED_RSOPFMT, szErrFormat, ARRAYSIZE(szErrFormat));

        lpErr = (LPTSTR)LocalAlloc(LPTR, (600*dwFailedAdm)*sizeof(TCHAR));

        if (!lpErr) {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Couldn't allocate memory for the error buffer."), GetLastError()));
            goto Exit;
        }

        lpTemp = lpFailedAdmFiles;

        lpEnd = lpErr;

        while (lpTemp) {

            LoadMessage(lpTemp->dwError, szError, ARRAYSIZE(szError));

            hr = StringCchPrintf(lpEnd, 600*dwFailedAdm - (lpEnd - lpErr), szErrFormat, lpTemp->szFileName, lpTemp->szFullFileName, szError);
            ASSERT(SUCCEEDED(hr));

            lpEnd += lstrlen(lpEnd);

            lpDelete = lpTemp;
            lpTemp = lpTemp->pNext;
            LocalFree (lpDelete);
        }

        // we cannot pass in a owner window handle here, b'cos this
        // is being done in a seperate thread and the main thread can be
        // waiting for the templatethread event

        ReportAdmError(NULL, 0, IDS_RSOP_ADMFAILED, lpErr);
        lpFailedAdmFiles = NULL;

        LocalFree(lpErr);
    }

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    if (pLastWriteTime)
    {
        SysFreeString (pLastWriteTime);
    }

    if (pNamespace)
    {
        SysFreeString (pNamespace);
    }

    lpTemp = lpFailedAdmFiles;

    while (lpTemp) {
        lpDelete = lpTemp;
        lpTemp = lpTemp->pNext;
        LocalFree (lpDelete);
    }
    
    lpFailedAdmFiles = NULL;

    CoUninitialize();

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadRSOPTemplates:  Leaving")));

    return hr;
}

HRESULT CPolicyComponentData::LoadTemplates (void)
{
    HRESULT hr = E_FAIL;

    if (m_bUserScope)
    {
       DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Entering for User")));
    }
    else
    {
       DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Entering for Machine")));
    }

    //
    // Reset the ADM event
    //

    ResetEvent (m_ADMEvent);


    //
    // Free any old templates
    //

    FreeTemplates ();



    EnterCriticalSection (&g_ADMCritSec);


    //
    // Prepare to load the templates
    //

    m_nUserDataItems = 0;
    m_nMachineDataItems = 0;

    m_pMachineCategoryList = (TABLEENTRY *) GlobalAlloc(GPTR,sizeof(TABLEENTRY));

    if (!m_pMachineCategoryList)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadTemplates: Failed to alloc memory with %d"),
                 GetLastError()));
        goto Exit;
    }

    m_pUserCategoryList = (TABLEENTRY *) GlobalAlloc(GPTR,sizeof(TABLEENTRY));

    if (!m_pUserCategoryList)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::LoadTemplates: Failed to alloc memory with %d"),
                 GetLastError()));
        GlobalFree (m_pMachineCategoryList);
        goto Exit;
    }


    m_pMachineCategoryList->dwSize = m_pUserCategoryList->dwSize = sizeof(TABLEENTRY);
    m_pMachineCategoryList->dwType = m_pUserCategoryList->dwType = ETYPE_ROOT;



    //
    // Load the appropriate template files
    //

    if (m_bRSOP)
    {
        hr = LoadRSOPTemplates();
    }
    else
    {
        hr = LoadGPOTemplates();

        if (SUCCEEDED(hr))
        {
            TCHAR szUnknown[150];

            LoadString (g_hInstance, IDS_NOSUPPORTINFO, szUnknown, ARRAYSIZE(szUnknown));
            AddSupportedNode (&m_pSupportedStrings, szUnknown, TRUE);

            if (m_bUserScope)
            {
                InitializeSupportInfo(m_pUserCategoryList, &m_pSupportedStrings);
            }
            else
            {
                InitializeSupportInfo(m_pMachineCategoryList, &m_pSupportedStrings);
            }
        }
    }


Exit:

    SetEvent (m_ADMEvent);

    LeaveCriticalSection (&g_ADMCritSec);

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::LoadTemplates: Leaving")));

    return hr;
}

BOOL CPolicyComponentData::ParseTemplate (LPTSTR lpFileName)
{
    HANDLE hFile;
    BOOL fMore;
    UINT uRet;
    LANGID langid;
    TCHAR szLocalizedSection[20];
    DWORD dwSize, dwRead;
    LPVOID lpFile, lpTemp;
    HRESULT hr = S_OK;

    //
    // Verbose output
    //

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Loading <%s>..."),
             lpFileName));


    //
    // Set defaults
    //

    m_nFileLine = 1;
    m_pListCurrent = m_pMachineCategoryList;
    m_pnDataItemCount = &m_nMachineDataItems;
    m_pszParseFileName = lpFileName;


    //
    // Read in the adm file
    //

    hFile = CreateFile (lpFileName, GENERIC_READ, FILE_SHARE_READ,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL |
                        FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplate: Failed to load <%s> with %d"),
                 lpFileName, GetLastError()));
        return FALSE;
    }


    dwSize = GetFileSize (hFile, NULL);

    if (dwSize == 0xFFFFFFFF)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to get file size with %d."),
                 GetLastError()));
        CloseHandle (hFile);
        return FALSE;
    }


    if (!(lpFile = GlobalAlloc(GPTR, dwSize)))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to allocate memory for %d bytes with %d."),
                 dwSize, GetLastError()));
        CloseHandle (hFile);
        return FALSE;
    }


    if (!ReadFile (hFile, lpFile, dwSize, &dwRead, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to read file with %d."),
                 GetLastError()));
        GlobalFree(lpFile);
        CloseHandle (hFile);
        return FALSE;
    }


    CloseHandle (hFile);

    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Finished reading file.")));


    if (dwRead >= sizeof(WCHAR))
    {
        if (!IsTextUnicode(lpFile, dwRead, NULL))
        {
            if (!(lpTemp = GlobalAlloc(GPTR, dwSize * sizeof(WCHAR))))
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to allocate memory for %d WCHARS with %d."),
                         dwSize, GetLastError()));
                GlobalFree(lpFile);
                return FALSE;
            }

            if ( !MultiByteToWideChar (CP_ACP, 0, (LPCSTR) lpFile, dwRead, (LPWSTR)lpTemp, dwRead) )
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ParseTemplates: Failed to convert ANSI adm file to Unicode with %d."),
                         GetLastError()));
                GlobalFree(lpTemp);
                GlobalFree(lpFile);
                return FALSE;
            }

            GlobalFree (lpFile);
            lpFile = lpTemp;
            dwRead *= sizeof(WCHAR);
        }
    }


    m_pFilePtr = (LPWSTR)lpFile;
    m_pFileEnd = (LPWSTR)((LPBYTE)lpFile + dwRead - 1);


    //
    // Read in the string sections
    //

    langid = GetUserDefaultLangID();
    hr = StringCchPrintf (szLocalizedSection, ARRAYSIZE(szLocalizedSection), TEXT("[%04x]"), langid);
    ASSERT(SUCCEEDED(hr));

    m_pLocaleStrings = FindSection (szLocalizedSection);

    if (m_pLocaleStrings)
    {
        m_pLocaleStrings += lstrlen(szLocalizedSection) + 2;
        m_pLocaleStrings = CreateStringArray(m_pLocaleStrings);
        m_pLocaleHashTable = CreateHashTable();

        FillHashTable(m_pLocaleHashTable, m_pLocaleStrings);
    }

    hr = StringCchPrintf (szLocalizedSection, ARRAYSIZE(szLocalizedSection), TEXT("[%04x]"), PRIMARYLANGID(langid));
    ASSERT(SUCCEEDED(hr));
    
    m_pLanguageStrings = FindSection (szLocalizedSection);

    if (m_pLanguageStrings)
    {
        m_pLanguageStrings += lstrlen(szLocalizedSection) + 2;
        m_pLanguageStrings = CreateStringArray(m_pLanguageStrings);
        m_pLanguageHashTable = CreateHashTable();

        FillHashTable(m_pLanguageHashTable, m_pLanguageStrings);
    }


    m_pDefaultStrings = FindSection ((LPTSTR)szStringsSect);

    if (m_pDefaultStrings)
    {
        LPTSTR lpEnd;

        m_pDefaultStrings += lstrlen(szStringsSect) + 2;

        lpEnd = m_pDefaultStrings;

        m_pDefaultStrings = CreateStringArray(m_pDefaultStrings);
        m_pDefaultHashTable = CreateHashTable();

        FillHashTable(m_pDefaultHashTable, m_pDefaultStrings);
#if DBG
        //DumpHashTableDetails (m_pDefaultHashTable);
#endif

        //
        // Now that all the string arrays are created, we can remove the strings
        // from the end of the adm file so we don't have 2 copies of the strings
        // in memory at the same time.  Note, the [Strings] section has to come
        // before the language or locale sections (because [strings] is a tag to the parser
        // to stop parsing the adm language).  So, we can safely chop off the file
        // right after the [strings] tag.
        //

        GlobalReAlloc (m_pFilePtr, (lpEnd - m_pFilePtr + 1) * sizeof(WCHAR), 0);

        m_pFileEnd = lpEnd;
    }


    //
    // Parse the file
    //

    m_fInComment = FALSE;

    do {

        uRet=ParseClass(&fMore);

    } while (fMore && uRet == ERROR_SUCCESS);


    //
    // Cleanup
    //

    GlobalFree(lpFile);

    if (m_pLocaleStrings)
    {
        GlobalFree(m_pLocaleStrings);
    }


    if (m_pLanguageStrings)
    {
        GlobalFree(m_pLanguageStrings);
    }


    if (m_pDefaultStrings)
    {
        GlobalFree(m_pDefaultStrings);
    }

    if (m_pLocaleHashTable)
    {
        FreeHashTable (m_pLocaleHashTable);
        m_pLocaleHashTable = NULL;
    }

    if (m_pLanguageHashTable)
    {
        FreeHashTable (m_pLanguageHashTable);
        m_pLanguageHashTable = NULL;
    }

    if (m_pDefaultHashTable)
    {
        FreeHashTable (m_pDefaultHashTable);
        m_pDefaultHashTable = NULL;
    }


    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseTemplate: Finished.")));

    return TRUE;
}


UINT CPolicyComponentData::ParseClass(BOOL *pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr, nKeywordID, nClassID;


    if (!GetNextWord(szWordBuf,ARRAYSIZE(szWordBuf),pfMore,&uErr))
        return uErr;


    if (!CompareKeyword(szWordBuf,pClassCmpList,&nKeywordID))
        return ERROR_ALREADY_DISPLAYED;

    switch (nKeywordID) {

        case KYWD_ID_CATEGORY:

            return ParseCategory(m_pListCurrent, FALSE,pfMore, NULL);

        case KYWD_ID_CLASS:

            if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                pClassTypeCmpList,&nClassID,pfMore,&uErr))
               return uErr;

            switch (nClassID) {

                case KYWD_ID_USER:
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseClass: User section")));
                    m_pListCurrent = m_pUserCategoryList;
                    m_pnDataItemCount = &m_nUserDataItems;
                    m_bRetrieveString = (m_bUserScope ? TRUE : FALSE);
                    break;

                case KYWD_ID_MACHINE:
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::ParseClass: Machine section")));
                    m_pListCurrent = m_pMachineCategoryList;
                    m_pnDataItemCount = &m_nMachineDataItems;
                    m_bRetrieveString = (m_bUserScope ? FALSE : TRUE);
                    break;
            }
            break;

        // hack for localization: allow a "strings" section at the bottom, if we
        // encounter that then we're thru with parsing
        case KYWD_ID_STRINGSSECT:
            *pfMore = FALSE;    // that's all, folks
            return ERROR_SUCCESS;
            break;
    }

    return ERROR_SUCCESS;
}

TABLEENTRY * CPolicyComponentData::FindCategory(TABLEENTRY *pParent, LPTSTR lpName)
{
    TABLEENTRY *pEntry = NULL, *pTemp;


    if (m_bRetrieveString && pParent) {

        pTemp = pParent->pChild;

        while (pTemp) {

            if (pTemp->dwType & ETYPE_CATEGORY) {
                if (!lstrcmpi (lpName, GETNAMEPTR(pTemp))) {
                    pEntry = pTemp;
                    break;
                }
            }
            pTemp = pTemp->pNext;
        }
    }

    return pEntry;
}


/*******************************************************************

    NAME:       ParseEntry

    SYNOPSIS:   Main parsing "engine" for category, policy and part
                parsing

    NOTES:      Allocates memory to build a temporary TABLEENTRY struct
                describing the parsed information.  Reads the beginning and end of a
                section and loops through the words in each section, calling
                a caller-defined ParseProc for each keyword to let the
                caller handle appropriately.  Passes the newly-constucted
                TABLEENTRY to AddTableEntry to save it, and frees the temporary
                memory.
                This function is re-entrant.
                The ENTRYDATA struct is declared on ParseEntry's stack
                but used by the ParseProc to maintain state between
                calls-- e.g., whether or not a key name has been found.
                This can't be maintained as a static in the ParseProc because
                the ParseProc may be reentered (for instance, if categories
                have subcategories).
                There are many possible error paths and there is some
                memory dealloc that needs to be done in an error case. Rather
                than do deallocs by hand on every error path or use a "goto
                cleanup" (ick!), items to be freed are added to a "cleanup
                list" and then CleanupAndReturn is called in an error condition,
                which frees items on the list and returns a specified value.

    ENTRY:      ppes-- PARSEENTRYSTRUCT that specifes type of entry, the
                    parent table, a keyword list, a ParseProc callback
                    and other goodies
                pfMore-- set to FALSE if at end of file

    EXIT:       ERROR_SUCCESS if successful, otherwise an error code
                (can be ERROR_ALREADY_DISPLAYED)

********************************************************************/
UINT CPolicyComponentData::ParseEntry(PARSEENTRYSTRUCT *ppes,BOOL *pfMore,
                                      LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr,nListIndex;
    BOOL fFoundEnd = FALSE;
    PARSEPROCSTRUCT pps;
    ENTRYDATA EntryData;
    DWORD dwBufSize = DEFAULT_TMP_BUF_SIZE;
    TABLEENTRY *pTmp = NULL;
    BOOL bNewEntry = TRUE;

    memset(&pps,0,sizeof(pps));
    memset(&EntryData,0,sizeof(EntryData));

    pps.pdwBufSize = &dwBufSize;
    pps.pData = &EntryData;
    pps.pData->fParentHasKey = ppes->fParentHasKey;
    pps.pEntryCmpList = ppes->pEntryCmpList;

    // get the entry name
    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr)) {
        return uErr;
    }

    if (ppes->dwEntryType & ETYPE_CATEGORY) {

        pTmp = FindCategory (ppes->pParent, szWordBuf);
    }

    if (pTmp) {

        bNewEntry = FALSE;

    } else {

        //
        // Create a new table entry
        //

        if (!(pps.pTableEntry = (TABLEENTRY *) GlobalAlloc(GPTR,*pps.pdwBufSize)))
            return ERROR_NOT_ENOUGH_MEMORY;

        // initialize TABLEENTRY struct
        pps.pTableEntry->dwSize = ppes->dwStructSize;
        pps.pTableEntry->dwType = ppes->dwEntryType;

        // store the entry name in pTableEntry
        pTmp = (TABLEENTRY *) AddDataToEntry(pps.pTableEntry,
            (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pps.pTableEntry->uOffsetName),
            pps.pdwBufSize);

        if (!pTmp) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

    }


    pps.pTableEntry = pTmp;

    // loop through the body of the declaration
    while (!fFoundEnd && GetNextSectionWord(szWordBuf,
        ARRAYSIZE(szWordBuf),pps.pEntryCmpList,&nListIndex,pfMore,&uErr)) {

        if ( (uErr = (*ppes->pParseProc) (this, nListIndex,&pps,pfMore,&fFoundEnd,pKeyName))
            != ERROR_SUCCESS) {
            if (bNewEntry) {
                GlobalFree ((HGLOBAL)pps.pTableEntry);
            }
            return (uErr);
        }

        if (!bNewEntry) {

            if (pTmp != pps.pTableEntry) {

                //
                // We need to fix up the link list of pointers in case the tableentry
                // has moved due to a realloc
                //

                if (pps.pTableEntry->pPrev) {
                    pps.pTableEntry->pPrev->pNext = pps.pTableEntry;
                } else {
                    ppes->pParent->pChild = pps.pTableEntry;
                }

                if (pps.pTableEntry->pNext) {
                    pps.pTableEntry->pNext->pPrev = pps.pTableEntry;
                }

                pTmp = pps.pTableEntry;
            }
        }
    }

    if (uErr != ERROR_SUCCESS) {
        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    // Last word was "END"

    // get the keyword that goes with "END" ("END CATGORY", "END POLICY", etc.)
    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        ppes->pTypeCmpList,&nListIndex,pfMore,&uErr)) {

        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    // call the object's parse proc one last time to let it object if
    // key name or something like that is missing
    if ( (uErr = (*ppes->pParseProc) (this, KYWD_DONE,&pps,pfMore,&fFoundEnd,pKeyName))
        != ERROR_SUCCESS) {
        if (bNewEntry) {
            GlobalFree ((HGLOBAL)pps.pTableEntry);
        }
        return (uErr);
    }

    if (bNewEntry) {

        // fix up linked list pointers.  If parent has no children yet, make this
        // 1st child; otherwise walk the list of children and insert this at the end
        if (!ppes->pParent->pChild) {
            ppes->pParent->pChild = pps.pTableEntry;
        } else {
            TABLEENTRY * pLastChild = ppes->pParent->pChild;
            while (pLastChild->pNext) {
                pLastChild = pLastChild->pNext;
            }
            pLastChild->pNext = pps.pTableEntry;
            pps.pTableEntry->pPrev = pLastChild;
        }
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

    NAME:       ParseCategory

    SYNOPSIS:   Parses a category

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT CPolicyComponentData::ParseCategory(TABLEENTRY * pParent,
                                         BOOL fParentHasKey,BOOL *pfMore,
                                         LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_CATEGORY;
    pes.pEntryCmpList = pCategoryEntryCmpList;
    pes.pTypeCmpList = pCategoryTypeCmpList;
    pes.pParseProc = CategoryParseProc;
    pes.dwStructSize = sizeof(CATEGORY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore,pKeyName);
}

/*******************************************************************

    NAME:       CategoryParseProc

    SYNOPSIS:   Keyword callback ParseProc for category parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::CategoryParseProc(CPolicyComponentData * pCD,
                                             UINT nMsg,PARSEPROCSTRUCT * ppps,
                                             BOOL * pfMore,BOOL * pfFoundEnd,
                                             LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    CATEGORY * pCategory = (CATEGORY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry, *pTmp;
    LPTSTR lpHelpBuf;
    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pCategory
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pCategory->uOffsetKeyName),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_POLICY:
        case KYWD_ID_CATEGORY:

            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                if (nMsg == KYWD_ID_POLICY)
                    uErr=pCD->ParsePolicy((TABLEENTRY *) pCategory,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pCategory) : pKeyName));
                else
                    uErr=pCD->ParseCategory((TABLEENTRY *) pCategory,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pCategory) : pKeyName));
            }

            return uErr;
            break;

        case KYWD_ID_HELP:

            // have we already found a help string already?
            if (pCategory->uOffsetHelp) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_HELP,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            lpHelpBuf = (LPTSTR) LocalAlloc (LPTR, HELPBUFSIZE * sizeof(TCHAR));

            if (!lpHelpBuf) {
                pCD->DisplayKeywordError(IDS_ErrOUTOFMEMORY,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the help string
            if (!pCD->GetNextSectionWord(lpHelpBuf,HELPBUFSIZE,
                NULL,NULL,pfMore,&uErr)) {
                LocalFree (lpHelpBuf);
                return uErr;
            }

            // store the help string
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                (BYTE *)lpHelpBuf,(lstrlen(lpHelpBuf)+1) * sizeof(TCHAR),&(pCategory->uOffsetHelp),
                ppps->pdwBufSize);

            LocalFree (lpHelpBuf);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_DONE:
            if (!ppps->pData->fHasKey && pKeyName) {

                // store the key name in pCategory
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pCategory,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1) * sizeof(TCHAR),&(pCategory->uOffsetKeyName),
                    ppps->pdwBufSize);

                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;

                ppps->pData->fHasKey = TRUE;

            }
            return ERROR_SUCCESS;
            break;

        default:
            return ERROR_SUCCESS;
            break;
    }
}


/*******************************************************************

    NAME:       ParsePolicy

    SYNOPSIS:   Parses a policy

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.
********************************************************************/

UINT CPolicyComponentData::ParsePolicy(TABLEENTRY * pParent,
                                       BOOL fParentHasKey,BOOL *pfMore,
                                       LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_POLICY;
    pes.pEntryCmpList = pPolicyEntryCmpList;
    pes.pTypeCmpList = pPolicyTypeCmpList;
    pes.pParseProc = PolicyParseProc;
    pes.dwStructSize = sizeof(POLICY);
    pes.fHasSubtable = TRUE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore, pKeyName);
}

/*******************************************************************

    NAME:       PolicyParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::PolicyParseProc(CPolicyComponentData * pCD,
                     UINT nMsg,PARSEPROCSTRUCT * ppps,
                     BOOL * pfMore,BOOL * pfFoundEnd,LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    LPTSTR lpHelpBuf, lpKeyName;
    POLICY * pPolicy = (POLICY *) ppps->pTableEntry;
    TABLEENTRY * pOld = ppps->pTableEntry, *pTmp;
    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pPolicy
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&(pPolicy->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;

        case KYWD_ID_VALUENAME:

            // have we already found a key name?
            if (ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;

        case KYWD_ID_HELP:

            // have we already found a help string already?
            if (pPolicy->uOffsetHelp) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_HELP,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            lpHelpBuf = (LPTSTR) LocalAlloc (LPTR, HELPBUFSIZE * sizeof(TCHAR));

            if (!lpHelpBuf) {
                pCD->DisplayKeywordError(IDS_ErrOUTOFMEMORY,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the help string
            if (!pCD->GetNextSectionWord(lpHelpBuf,HELPBUFSIZE,
                NULL,NULL,pfMore,&uErr)) {
                LocalFree (lpHelpBuf);
                return uErr;
            }

            // store the help string
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)lpHelpBuf,(lstrlen(lpHelpBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetHelp),
                ppps->pdwBufSize);

            LocalFree (lpHelpBuf);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_CLIENTEXT:

            // have we already found a clientext string already?
            if (pPolicy->uOffsetClientExt) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            if (!ValidateGuid(szWordBuf))
            {
                pCD->DisplayKeywordError(IDS_ParseErr_INVALID_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // store the clientext string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetClientExt),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_SUPPORTED:

            // have we already found a supported string already?
            if (pPolicy->uOffsetSupported) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_SUPPORTED,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the supported platforms
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the supported string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pPolicy->uOffsetSupported),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;

        case KYWD_ID_PART:
            {
                BOOL fHasKey = ppps->pData->fHasKey | ppps->pData->fParentHasKey;
                return pCD->ParseSettings((TABLEENTRY *) pPolicy,fHasKey,pfMore,
                                          (ppps->pData->fHasKey ? GETKEYNAMEPTR(pPolicy) : pKeyName));
            }

        case KYWD_ID_VALUEON:
            return pCD->ParseValue(ppps,&pPolicy->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);


        case KYWD_ID_VALUEOFF:
            return pCD->ParseValue(ppps,&pPolicy->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);


        case KYWD_ID_ACTIONLISTON:
            return pCD->ParseActionList(ppps,&pPolicy->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);


        case KYWD_ID_ACTIONLISTOFF:
            return pCD->ParseActionList(ppps,&pPolicy->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);


        case KYWD_DONE:

            if (!ppps->pData->fHasKey) {

                if (!ppps->pData->fParentHasKey) {
                    pCD->DisplayKeywordError(IDS_ParseErr_NO_KEYNAME,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }

                // store the key name in pPolicy
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pPolicy,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1)*sizeof(TCHAR),&(pPolicy->uOffsetKeyName),ppps->pdwBufSize);

                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                pPolicy = (POLICY *) pTmp;

                ppps->pData->fHasKey = TRUE;
            }

            if (!pPolicy->uOffsetValueName && !pPolicy->pChild)
            {
                if ((!pPolicy->uOffsetValue_On && pPolicy->uOffsetValue_Off) ||
                    (pPolicy->uOffsetValue_On && !pPolicy->uOffsetValue_Off))
                {
                    pCD->DisplayKeywordError(IDS_ParseErr_MISSINGVALUEON_OR_OFF,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }
            }

            //
            // Check if this is a real policy
            //

            lpKeyName = GETKEYNAMEPTR(ppps->pTableEntry);

            if (!lpKeyName) {
                return ERROR_INVALID_PARAMETER;
            }

            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, pCD->m_iSWPoliciesLen,
                              SOFTWARE_POLICIES, pCD->m_iSWPoliciesLen) == CSTR_EQUAL)
            {
                ((POLICY *) ppps->pTableEntry)->bTruePolicy = TRUE;
            }

            else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, pCD->m_iWinPoliciesLen,
                              WINDOWS_POLICIES, pCD->m_iWinPoliciesLen) == CSTR_EQUAL)
            {
                ((POLICY *) ppps->pTableEntry)->bTruePolicy = TRUE;
            }


            ( (POLICY *) ppps->pTableEntry)->uDataIndex = *pCD->m_pnDataItemCount;
            (*pCD->m_pnDataItemCount) ++;

            return ERROR_SUCCESS;

        default:
            break;
    }

    return ERROR_SUCCESS;
}


/*******************************************************************

    NAME:       ParseSettings

    SYNOPSIS:   Parses a policy setting

    NOTES:      Sets up a PARSEENTRYSTRUCT and lets ParseEntry do the
                work.

********************************************************************/
UINT CPolicyComponentData::ParseSettings(TABLEENTRY * pParent,
                                         BOOL fParentHasKey,BOOL *pfMore,
                                         LPTSTR pKeyName)
{
    PARSEENTRYSTRUCT pes;

    pes.pParent = pParent;
    pes.dwEntryType = ETYPE_SETTING;
    pes.pEntryCmpList = pSettingsEntryCmpList;
    pes.pTypeCmpList = pSettingsTypeCmpList;
    pes.pParseProc = SettingsParseProc;
    pes.dwStructSize = sizeof(SETTINGS);
    pes.fHasSubtable = FALSE;
    pes.fParentHasKey = fParentHasKey;

    return ParseEntry(&pes,pfMore, pKeyName);
}

/*******************************************************************

    NAME:       SettingsParseProc

    SYNOPSIS:   Keyword callback ParseProc for policy settings parsing

    ENTRY:      nMsg-- index into pEntryCmpList array which specifies
                    keyword that was found.
                ppps-- pointer to PARSEPROCSTRUCT that contains useful
                    data like a pointer to the TABLEENTRY being built
                    and a pointer to an ENTRYDATA struct to maintain
                    state between calls to the ParseProc

********************************************************************/
UINT CPolicyComponentData::SettingsParseProc(CPolicyComponentData *pCD,
                                             UINT nMsg,PARSEPROCSTRUCT * ppps,
                                             BOOL * pfMore,BOOL * pfFoundEnd,
                                             LPTSTR pKeyName)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];

    SETTINGS * pSettings = (SETTINGS *) ppps->pTableEntry;
    BYTE * pObjectData = GETOBJECTDATAPTR(pSettings);
    TABLEENTRY *pTmp;

    UINT uErr;

    switch (nMsg) {
        case KYWD_ID_KEYNAME:

            // have we already found a key name?
            if (ppps->pData->fHasKey) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the key name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the key name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetKeyName),ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasKey = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_VALUENAME:

            // have we already found a value name?
            if (ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_VALUENAME,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the value name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the value name in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;
            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CLIENTEXT:

            // have we already found a clientext string already?
            if (pSettings->uOffsetClientExt) {
                pCD->DisplayKeywordError(IDS_ParseErr_DUPLICATE_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // get the clientext name
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            if (!ValidateGuid(szWordBuf))
            {
                pCD->DisplayKeywordError(IDS_ParseErr_INVALID_CLIENTEXT,
                    NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            // store the clientext string in pSettings
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),&(pSettings->uOffsetClientExt),
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            return ERROR_SUCCESS;

        case KYWD_ID_REQUIRED:
            pSettings->dwFlags |= DF_REQUIRED;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EXPANDABLETEXT:
            pSettings->dwFlags |= DF_EXPANDABLETEXT;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_SUGGESTIONS:

            return pCD->ParseSuggestions(ppps,&((POLICYCOMBOBOXINFO *)
                (GETOBJECTDATAPTR(pSettings)))->uOffsetSuggestions,
                &ppps->pTableEntry,pfMore);

        case KYWD_ID_TXTCONVERT:
            pSettings->dwFlags |= DF_TXTCONVERT;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_END:
            *pfFoundEnd = TRUE;
            return ERROR_SUCCESS;
            break;

        case KYWD_ID_SOFT:
            pSettings->dwFlags |= VF_SOFT;
            return ERROR_SUCCESS;
            break;

        case KYWD_DONE:
            if (!ppps->pData->fHasKey) {

                if (!ppps->pData->fParentHasKey) {
                    pCD->DisplayKeywordError(IDS_ParseErr_NO_KEYNAME,NULL,NULL);
                    return ERROR_ALREADY_DISPLAYED;
                }

                // store the key name in pSettings
                pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                    (BYTE *)pKeyName,(lstrlen(pKeyName)+1) * sizeof(TCHAR),&(pSettings->uOffsetKeyName),ppps->pdwBufSize);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;

                ppps->pTableEntry = pTmp;

                ppps->pData->fHasKey = TRUE;
            }

            if (!ppps->pData->fHasValue) {
                pCD->DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,NULL,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }

            ( (SETTINGS *) ppps->pTableEntry)->uDataIndex = *pCD->m_pnDataItemCount;
            (*pCD->m_pnDataItemCount) ++;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_CHECKBOX:
            return (pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_CHECKBOX,
                sizeof(CHECKBOXINFO),pCheckboxCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_TEXT:
            ppps->pData->fHasValue = TRUE;  // no key value for static text items
            return (pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_TEXT,
                0,pTextCmpList,&pSettings,&pObjectData));
            break;

        case KYWD_ID_EDITTEXT:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_EDITTEXT,
                sizeof(EDITTEXTINFO),pEditTextCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                if (!pEditTextInfo) {
                    return ERROR_INVALID_PARAMETER;
                }
                pEditTextInfo->nMaxLen = MAXSTRLEN-1;

            }
            break;

        case KYWD_ID_COMBOBOX:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_COMBOBOX,
                sizeof(POLICYCOMBOBOXINFO),pComboboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(((SETTINGS *) ppps->pTableEntry)));

                pEditTextInfo->nMaxLen = MAXSTRLEN-1;

            }
            break;

        case KYWD_ID_NUMERIC:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_NUMERIC,
                sizeof(NUMERICINFO),pNumericCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            if (!pObjectData) return ERROR_INVALID_PARAMETER;

            ( (NUMERICINFO *) pObjectData)->uDefValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMinValue = 1;
            ( (NUMERICINFO *) pObjectData)->uMaxValue = 9999;
            ( (NUMERICINFO *) pObjectData)->uSpinIncrement = 1;

            break;

        case KYWD_ID_DROPDOWNLIST:
            ppps->pEntryCmpList = pDropdownlistCmpList;
            ppps->pTableEntry->dwType = ETYPE_SETTING | STYPE_DROPDOWNLIST;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_LISTBOX:
            uErr=pCD->InitSettingsParse(ppps,ETYPE_SETTING | STYPE_LISTBOX,
                sizeof(LISTBOXINFO),pListboxCmpList,&pSettings,&pObjectData);
            if (uErr != ERROR_SUCCESS) return uErr;

            // listboxes have no single value name, set the value name to ""
            pTmp  = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *) pSettings,
                (BYTE *) g_szNull,(lstrlen(g_szNull)+1) * sizeof(TCHAR),&(pSettings->uOffsetValueName),
                ppps->pdwBufSize);
            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;

            ppps->pData->fHasValue = TRUE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EDITTEXT_DEFAULT:
        case KYWD_ID_COMBOBOX_DEFAULT:
            // get the default text
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the default text in pTableEntry
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *)
                pSettings,(BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                &((EDITTEXTINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetDefText,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;

            ppps->pTableEntry = pTmp;

            ((SETTINGS *) ppps->pTableEntry)->dwFlags |= DF_USEDEFAULT;

            break;

        case KYWD_ID_MAXLENGTH:
            {
                EDITTEXTINFO *pEditTextInfo = (EDITTEXTINFO *)
                    (GETOBJECTDATAPTR(pSettings));

                if ((uErr=pCD->GetNextSectionNumericWord(
                    &pEditTextInfo->nMaxLen)) != ERROR_SUCCESS)
                    return uErr;
            }
            break;

        case KYWD_ID_MAX:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uMaxValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_MIN:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uMinValue)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_SPIN:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uSpinIncrement)) != ERROR_SUCCESS)
                return uErr;
        break;

        case KYWD_ID_NUMERIC_DEFAULT:
            if ((uErr=pCD->GetNextSectionNumericWord(
                &((NUMERICINFO *)pObjectData)->uDefValue)) != ERROR_SUCCESS)
                return uErr;

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

        break;

        case KYWD_ID_DEFCHECKED:

            pSettings->dwFlags |= (DF_DEFCHECKED | DF_USEDEFAULT);

            break;

        case KYWD_ID_VALUEON:

            return pCD->ParseValue(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_On,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_VALUEOFF:

            return pCD->ParseValue(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetValue_Off,
                &ppps->pTableEntry,pfMore);
            break;

        case KYWD_ID_ACTIONLISTON:
            return pCD->ParseActionList(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_On,
                &ppps->pTableEntry,szACTIONLISTON,pfMore);
            break;

        case KYWD_ID_ACTIONLISTOFF:
            return pCD->ParseActionList(ppps,&((CHECKBOXINFO *)
                pObjectData)->uOffsetActionList_Off,
                &ppps->pTableEntry,szACTIONLISTOFF,pfMore);
            break;

        case KYWD_ID_ITEMLIST:
            return pCD->ParseItemList(ppps,&pSettings->uOffsetObjectData,
                pfMore);
            break;

        case KYWD_ID_VALUEPREFIX:
            // get the string to be ised as prefix
            if (!pCD->GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                NULL,NULL,pfMore,&uErr))
                return uErr;

            // store the string pTableEntry
            pTmp = (TABLEENTRY *) pCD->AddDataToEntry((TABLEENTRY *)
                pSettings,(BYTE *)szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                &((LISTBOXINFO *) (GETOBJECTDATAPTR(pSettings)))->uOffsetPrefix,
                ppps->pdwBufSize);

            if (!pTmp)
                return ERROR_NOT_ENOUGH_MEMORY;
            ppps->pTableEntry = pTmp;
            break;

        case KYWD_ID_ADDITIVE:

            pSettings->dwFlags |= DF_ADDITIVE;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_EXPLICITVALUE:

            pSettings->dwFlags |= DF_EXPLICITVALNAME;

            return ERROR_SUCCESS;
            break;

        case KYWD_ID_NOSORT:

            pSettings->dwFlags |= DF_NOSORT;

            break;

    }

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::InitSettingsParse(PARSEPROCSTRUCT *ppps,DWORD dwType,DWORD dwSize,
    KEYWORDINFO * pKeyList,SETTINGS ** ppSettings,BYTE **ppObjectData)
{
    TABLEENTRY *pTmp;

    if (dwSize) {
        // increase the buffer to fit object-specific data if specified
        pTmp = (TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
            NULL,dwSize,&( ((SETTINGS * )ppps->pTableEntry)->uOffsetObjectData),
            ppps->pdwBufSize);
        if (!pTmp) return ERROR_NOT_ENOUGH_MEMORY;
        ppps->pTableEntry = pTmp;

    }
    else ( (SETTINGS *) ppps->pTableEntry)->uOffsetObjectData= 0;

    ppps->pEntryCmpList = pKeyList;
    ppps->pTableEntry->dwType = dwType;

    *ppSettings = (SETTINGS *) ppps->pTableEntry;
    *ppObjectData = GETOBJECTDATAPTR((*ppSettings));

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::ParseValue_W(PARSEPROCSTRUCT * ppps,TCHAR * pszWordBuf,
    DWORD cbWordBuf,DWORD * pdwValue,DWORD * pdwFlags,BOOL * pfMore)
{
    UINT uErr;
    *pdwFlags = 0;
    *pdwValue = 0;

    // get the next word
    if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
        NULL,NULL,pfMore,&uErr))
        return uErr;

    // if this keyword is "SOFT", set the soft flag and get the next word
    if (!lstrcmpi(szSOFT,pszWordBuf)) {
        *pdwFlags |= VF_SOFT;
        if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;
    }

    // this word is either the value to use, or the keyword "NUMERIC"
    // followed by a numeric value to use
    if (!lstrcmpi(szNUMERIC,pszWordBuf)) {
        // get the next word
        if (!GetNextSectionWord(pszWordBuf,cbWordBuf,
            NULL,NULL,pfMore,&uErr))
            return uErr;

        if (!StringToNum(pszWordBuf,(UINT *)pdwValue)) {
            DisplayKeywordError(IDS_ParseErr_NOT_NUMERIC,
                pszWordBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }

        *pdwFlags |= VF_ISNUMERIC;
    } else {

        // "DELETE" is a special word
        if (!lstrcmpi(pszWordBuf,szDELETE))
            *pdwFlags |= VF_DELETE;
    }

    return ERROR_SUCCESS;
}

UINT CPolicyComponentData::ParseValue(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    STATEVALUE * pStateValue;
    DWORD dwValue;
    DWORD dwFlags = 0;
    DWORD dwAlloc;
    UINT uErr;
    TABLEENTRY *pTmp;
    HRESULT hr = S_OK;

    // call worker function
    uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),&dwValue,
        &dwFlags,pfMore);
    if (uErr != ERROR_SUCCESS) return uErr;

    dwAlloc = sizeof(STATEVALUE);
    if (!dwFlags) dwAlloc += (lstrlen(szWordBuf) + 1) * sizeof(TCHAR);

    // allocate temporary buffer to build STATEVALUE struct
    pStateValue = (STATEVALUE *) GlobalAlloc(GPTR,dwAlloc);
    if (!pStateValue)
        return ERROR_NOT_ENOUGH_MEMORY;

    pStateValue->dwFlags = dwFlags;
    if (dwFlags & VF_ISNUMERIC)
        pStateValue->dwValue = dwValue;
    else if (!dwFlags) {
        hr = StringCchCopy(pStateValue->szValue, lstrlen(szWordBuf) + 1, szWordBuf);
        ASSERT(SUCCEEDED(hr));
    }

    pTmp=(TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
        (BYTE *) pStateValue,dwAlloc,puOffsetData,NULL);

    GlobalFree(pStateValue);

    if (!pTmp)
        return ERROR_NOT_ENOUGH_MEMORY;

    *ppTableEntryNew = pTmp;

    return FALSE;
}

#define DEF_SUGGESTBUF_SIZE     1024
#define SUGGESTBUF_INCREMENT    256
UINT CPolicyComponentData::ParseSuggestions(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    TABLEENTRY ** ppTableEntryNew,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    TCHAR *pTmpBuf, *pTmp;
    DWORD dwAlloc=DEF_SUGGESTBUF_SIZE * sizeof(TCHAR);
    DWORD dwUsed = 0;
    BOOL fContinue = TRUE;
    UINT uErr;
    TABLEENTRY *pTmpTblEntry;
    HRESULT hr = S_OK;

    KEYWORDINFO pSuggestionsTypeCmpList[] = { {szSUGGESTIONS,KYWD_ID_SUGGESTIONS},
        {NULL,0} };

    if (!(pTmpBuf = (TCHAR *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // get the next word
    while (fContinue && GetNextSectionWord(szWordBuf,
        ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr)) {

        // if this word is "END", add the whole list to the setting object data
        if (!lstrcmpi(szEND,szWordBuf)) {
            // get the next word after "END, make sure it's "SUGGESTIONS"
            if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                pSuggestionsTypeCmpList,NULL,pfMore,&uErr)) {
                GlobalFree(pTmpBuf);
                return uErr;
            }

            // doubly-NULL terminate the list
            *(pTmpBuf+dwUsed) = '\0';
            dwUsed++;

            pTmpTblEntry=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                (BYTE *)pTmpBuf,(dwUsed * sizeof(TCHAR)),puOffsetData,NULL);

            if (!pTmpTblEntry) {
                GlobalFree(pTmpBuf);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            *ppTableEntryNew = pTmpTblEntry;
            fContinue = FALSE;

        } else {
            // pack the word into the temporary buffer
            UINT nLength = lstrlen(szWordBuf);
            DWORD dwNeeded = (dwUsed + nLength + 2) * sizeof(TCHAR);

            // resize buffer as necessary
            if (dwNeeded > dwAlloc) {
                while (dwAlloc < dwNeeded)
                    dwAlloc += SUGGESTBUF_INCREMENT;

                if (!(pTmp = (TCHAR *) GlobalReAlloc(pTmpBuf,dwAlloc,
                    GMEM_MOVEABLE | GMEM_ZEROINIT)))
                {
                    GlobalFree (pTmpBuf);
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
                pTmpBuf = pTmp;
            }

            hr = StringCchCopy(pTmpBuf + dwUsed, dwNeeded - dwUsed, szWordBuf);
            ASSERT(SUCCEEDED(hr));
            dwUsed += lstrlen(szWordBuf) +1;

        }
    }

    GlobalFree(pTmpBuf);

    return uErr;
}

UINT CPolicyComponentData::ParseActionList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
                                           TABLEENTRY ** ppTableEntryNew,
                                           LPCTSTR pszKeyword,BOOL * pfMore)
{
    TCHAR szWordBuf[WORDBUFSIZE+1];
    ACTIONLIST *pActionList;
    ACTION *pActionCurrent;
    UINT uOffsetActionCurrent;
    DWORD dwAlloc=(DEF_SUGGESTBUF_SIZE * sizeof(TCHAR));
    DWORD dwUsed = sizeof(ACTION) + sizeof(UINT);
    UINT uErr=ERROR_SUCCESS,nIndex;
    BOOL fContinue = TRUE;
    TABLEENTRY *pTmp;
    KEYWORDINFO pActionlistTypeCmpList[] = { {szKEYNAME,KYWD_ID_KEYNAME},
        {szVALUENAME,KYWD_ID_VALUENAME},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{NULL,0} };
    KEYWORDINFO pActionlistCmpList[] = { {pszKeyword,KYWD_ID_ACTIONLIST},
        {NULL,0} };
    BOOL fHasKeyName=FALSE,fHasValueName=FALSE;

    if (!(pActionList = (ACTIONLIST *) GlobalAlloc(GPTR,dwAlloc)))
        return ERROR_NOT_ENOUGH_MEMORY;

    pActionCurrent = pActionList->Action;
    uOffsetActionCurrent = sizeof(UINT);

    // get the next word
    while ((uErr == ERROR_SUCCESS) && fContinue &&
        GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        pActionlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_KEYNAME:

                if (fHasKeyName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the key name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the key name away
                if (!AddActionListString(szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                    (BYTE **)&pActionList,
                    &pActionCurrent->uOffsetKeyName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasKeyName = TRUE;
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUENAME:

                if (fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_KEYNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the value name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // store the value name away
                if (!AddActionListString(szWordBuf,(lstrlen(szWordBuf)+1) * sizeof(TCHAR),
                    (BYTE **)&pActionList,
                    &pActionCurrent->uOffsetValueName,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                fHasValueName = TRUE;
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_VALUE:
                if (!fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),
                    &pActionCurrent->dwValue,&pActionCurrent->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pActionCurrent->dwFlags && !AddActionListString(szWordBuf,
                    (lstrlen(szWordBuf)+1) * sizeof(TCHAR),(BYTE **)&pActionList,
                    &pActionCurrent->uOffsetValue,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                // done with this action in the list, get ready for the next one
                pActionList->nActionItems++;
                fHasValueName = fHasKeyName = FALSE;

                uOffsetActionCurrent = dwUsed;
                // make room for next ACTION struct
                if (!AddActionListString(NULL,sizeof(ACTION),(BYTE **)&pActionList,
                    &pActionCurrent->uOffsetNextAction,&dwAlloc,&dwUsed)) {
                    uErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
                pActionCurrent = (ACTION *) ((BYTE *) pActionList + uOffsetActionCurrent);

                break;

            case KYWD_ID_END:
                if (fHasKeyName || fHasValueName) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUENAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ACTIONLIST"
                if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                    pActionlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                // commit the action list we've built to table entry

                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    (BYTE *)pActionList,dwUsed,puOffsetData,NULL);

                if (!pTmp) {
                    uErr=ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    *ppTableEntryNew = pTmp;
                    uErr = ERROR_SUCCESS;
                    fContinue = FALSE;
                }

                break;
        }
    }

    GlobalFree(pActionList);

    return uErr;
}

UINT CPolicyComponentData::ParseItemList(PARSEPROCSTRUCT * ppps,UINT * puOffsetData,
    BOOL * pfMore)
{
    // ptr to location to put the offset to next DROPDOWNINFO struct in chain
    UINT * puLastOffsetPtr = puOffsetData;
    TABLEENTRY * pTableEntryOld, *pTmp;
    int nItemIndex=-1;
    BOOL fHasItemName = FALSE,fHasActionList=FALSE,fHasValue=FALSE,fFirst=TRUE;
    DROPDOWNINFO * pddi;
    TCHAR szWordBuf[WORDBUFSIZE+1];
    UINT uErr=ERROR_SUCCESS,nIndex;
    KEYWORDINFO pItemlistTypeCmpList[] = { {szNAME,KYWD_ID_NAME},
        {szACTIONLIST,KYWD_ID_ACTIONLIST},{szVALUE,KYWD_ID_VALUE},
        {szEND,KYWD_ID_END},{szDEFAULT,KYWD_ID_DEFAULT},{NULL,0} };
    KEYWORDINFO pItemlistCmpList[] = { {szITEMLIST,KYWD_ID_ITEMLIST},
        {NULL,0} };

    // get the next word
    while ((uErr == ERROR_SUCCESS) &&
        GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        pItemlistTypeCmpList,&nIndex,pfMore,&uErr)) {

        switch (nIndex) {

            case KYWD_ID_NAME:
                // if this is the first keyword after a prior item
                // (e.g., item and value flags both set) reset for next one
                if (fHasItemName && fHasValue) {
                    fHasValue = fHasActionList= fHasItemName = FALSE;
                    puLastOffsetPtr = &pddi->uOffsetNextDropdowninfo;
                }

                if (fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // get the next word, which is the item name
                if (!GetNextSectionWord(szWordBuf,
                    ARRAYSIZE(szWordBuf),NULL,NULL,pfMore,&uErr))
                    break;

                // add room for a DROPDOWNINFO struct at end of buffer
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    NULL,sizeof(DROPDOWNINFO),puLastOffsetPtr,NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                // store the key name away
                pTableEntryOld=ppps->pTableEntry;
                pTmp=(TABLEENTRY *)AddDataToEntry(ppps->pTableEntry,
                    (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&pddi->uOffsetItemName,
                    NULL);
                if (!pTmp)
                    return ERROR_NOT_ENOUGH_MEMORY;
                ppps->pTableEntry = pTmp;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                nItemIndex++;

                fHasItemName = TRUE;

                break;

            case KYWD_ID_DEFAULT:

                if (nItemIndex<0) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                ( (SETTINGS *) ppps->pTableEntry)->dwFlags |= DF_USEDEFAULT;
                ( (DROPDOWNINFO *) GETOBJECTDATAPTR(((SETTINGS *)ppps->pTableEntry)))
                    ->uDefaultItemIndex = nItemIndex;

                break;

            case KYWD_ID_VALUE:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // call worker function to get value and value type
                uErr=ParseValue_W(ppps,szWordBuf,ARRAYSIZE(szWordBuf),
                    &pddi->dwValue,&pddi->dwFlags,pfMore);
                if (uErr != ERROR_SUCCESS)
                    break;

                // if value is string, add it to buffer
                if (!pddi->dwFlags) {
                    // store the key name away
                    TABLEENTRY * pTmpTable;

                    pTableEntryOld = ppps->pTableEntry;
                    pTmpTable = (TABLEENTRY *) AddDataToEntry(ppps->pTableEntry,
                        (BYTE *)szWordBuf,(lstrlen(szWordBuf)+1)*sizeof(TCHAR),&pddi->uOffsetValue,
                        NULL);
                    if (!pTmpTable)
                        return ERROR_NOT_ENOUGH_MEMORY;
                    ppps->pTableEntry = pTmpTable;

                    // adjust pointer to offset, in case table moved
                    puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                        ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                    pddi = (DROPDOWNINFO *)
                        ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);
                }
                fHasValue = TRUE;

                break;

            case KYWD_ID_ACTIONLIST:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                if (fHasActionList) {
                    DisplayKeywordError(IDS_ParseErr_DUPLICATE_ACTIONLIST,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                pTableEntryOld=ppps->pTableEntry;
                uErr=ParseActionList(ppps,&pddi->uOffsetActionList,
                    &ppps->pTableEntry,szACTIONLIST,pfMore);
                if (uErr != ERROR_SUCCESS)
                    return uErr;
                // adjust pointer to offset, in case table moved
                puLastOffsetPtr = (UINT *) (((BYTE *) puLastOffsetPtr) +
                    ((BYTE *) ppps->pTableEntry - (BYTE *) pTableEntryOld));
                pddi = (DROPDOWNINFO *)
                    ((BYTE *) ppps->pTableEntry + *puLastOffsetPtr);

                fHasActionList = TRUE;

                break;

            case KYWD_ID_END:

                if (!fHasItemName) {
                    DisplayKeywordError(IDS_ParseErr_NO_ITEMNAME,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }
                if (!fHasValue) {
                    DisplayKeywordError(IDS_ParseErr_NO_VALUE,
                        NULL,NULL);
                    uErr = ERROR_ALREADY_DISPLAYED;
                    break;
                }

                // make sure word following "END" is "ITEMLIST"
                if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
                    pItemlistCmpList,NULL,pfMore,&uErr)) {
                    break;
                }

                return ERROR_SUCCESS;
                break;
        }
    }

    return uErr;
}

BOOL CPolicyComponentData::AddActionListString(TCHAR * pszData,DWORD cbData,BYTE ** ppBase,UINT * puOffset,
                                               DWORD * pdwAlloc,DWORD *pdwUsed)
{
    DWORD dwNeeded = *pdwUsed + cbData, dwAdd;


    dwAdd = dwNeeded % sizeof(DWORD);
    dwNeeded += dwAdd;

    // realloc if necessary
    if (dwNeeded > *pdwAlloc) {
        while (*pdwAlloc < dwNeeded)
        {
            *pdwAlloc += SUGGESTBUF_INCREMENT;
        }

        BYTE *pNewBase = (BYTE *) GlobalReAlloc(*ppBase,*pdwAlloc,GMEM_MOVEABLE | GMEM_ZEROINIT);
        if ( pNewBase == NULL )
        {
            return FALSE;
        }

        puOffset = (UINT *)(pNewBase + ((BYTE *)puOffset - *ppBase));
        *ppBase = pNewBase;
    }

    *puOffset = *pdwUsed;

    if (pszData) memcpy(*ppBase + *puOffset,pszData,cbData);
    *pdwUsed = dwNeeded;

    return TRUE;
}

BYTE * CPolicyComponentData::AddDataToEntry(TABLEENTRY * pTableEntry,
                                            BYTE * pData,UINT cbData,
                                            UINT * puOffsetData,DWORD * pdwBufSize)
{
    TABLEENTRY * pTemp;
    DWORD dwNeeded,dwOldSize = pTableEntry->dwSize, dwNewDataSize, dwAdd;

    // puOffsetData points to location that holds the offset to the
    // new data-- size we're adding this to the end of the table, the
    // offset will be the current size of the table.  Set this offset
    // in *puOffsetData.  Also, notice we touch *puOffsetData BEFORE
    // the realloc, in case puOffsetData points into the region being
    // realloced and the block of memory moves.
    //
    *puOffsetData = pTableEntry->dwSize;

    // reallocate entry buffer if necessary
    dwNewDataSize = cbData;

    dwAdd = dwNewDataSize % sizeof(DWORD);

    dwNewDataSize += dwAdd;

    dwNeeded = pTableEntry->dwSize + dwNewDataSize;

    if (!(pTemp = (TABLEENTRY *) GlobalReAlloc(pTableEntry,
        dwNeeded,GMEM_ZEROINIT | GMEM_MOVEABLE)))
        return NULL;

    pTableEntry = pTemp;
    pTableEntry->dwSize = dwNeeded;

    if (pData) memcpy((BYTE *)pTableEntry + dwOldSize,pData,cbData);
    if (pdwBufSize) *pdwBufSize = pTableEntry->dwSize;

    return (BYTE *) pTableEntry;
}

/*******************************************************************

    NAME:       CompareKeyword

    SYNOPSIS:   Compares a specified buffer to a list of valid keywords.
                If it finds a match, the index of the match in the list
                is returned in *pnListIndex.  Otherwise an error message
                is displayed.

    EXIT:       Returns TRUE if a keyword match is found, FALSE otherwise.
                If TRUE, *pnListIndex contains matching index.

********************************************************************/
BOOL CPolicyComponentData::CompareKeyword(TCHAR * szWord,KEYWORDINFO *pKeywordList,
                                          UINT * pnListIndex)
{
    KEYWORDINFO * pKeywordInfo = pKeywordList;

    while (pKeywordInfo->pWord) {
        if (!lstrcmpi(szWord,pKeywordInfo->pWord)) {
            if (pnListIndex)
                *pnListIndex = pKeywordInfo->nID;
            return TRUE;
        }
        pKeywordInfo ++;
    }

    DisplayKeywordError(IDS_ParseErr_UNEXPECTED_KEYWORD,
        szWord,pKeywordList);

    return FALSE;
}


/*******************************************************************

    NAME:       GetNextWord

    SYNOPSIS:   Fills input buffer with next word in file stream

    NOTES:      Calls GetNextChar() to get character stream.  Whitespace
                and comments are skipped.  Quoted strings are returned
                as one word (including whitespace) with the quotes removed.

    EXIT:       If successful, returns a pointer to the input buffer
                (szBuf).  *pfMore indicates if there are more words to
                be read.  If an error occurs, its value is returned in *puErr.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextWord(TCHAR * szBuf,UINT cbBuf,BOOL * pfMore,
                                          UINT * puErr)
{
    TCHAR * pChar;
    BOOL fInWord = FALSE;
    BOOL fInQuote = FALSE;
    BOOL fEmptyString = FALSE;
    TCHAR * pWord = szBuf;
    UINT cbWord = 0;
    LPTSTR lpTemp;
    HRESULT hr = S_OK;

    // clear buffer to start with
    (void) StringCchCopy(szBuf, cbBuf, g_szNull);

    while (pChar = GetNextChar(pfMore,puErr)) {

        // keep track of which file line we're on
        if (IsEndOfLine(pChar)) m_nFileLine++;

        // keep track of wheter we are inside quoted string or not
        if (IsQuote(pChar) && !m_fInComment) {
            if (!fInQuote)
                fInQuote = TRUE;  // entering quoted string
            else {
                fInQuote = FALSE; // leaving quoted string
                if (cbWord == 0) {
                    // special case "" to be an empty string
                    DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::GetNextWord: Found empty quotes")));
                    fEmptyString = TRUE;
                }
                break;  // end of word
            }

        }

        if (!fInQuote) {

            // skip over lines with comments (';')
            if (!m_fInComment && IsComment(pChar)) {
                m_fInComment = TRUE;
            }
            
            if (m_fInComment) {
                if (IsEndOfLine(pChar)) {
                    m_fInComment = FALSE;
                }
                continue;
            }

            if (IsWhitespace(pChar)) {

                // if we haven't found word yet, skip over whitespace
                if (!fInWord)
                    continue;

                // otherwise, whitespace signals end of word
                break;
            }
        }

        // found a non-comment, non-whitespace character
        if (!fInWord) fInWord = TRUE;

        if (!IsQuote(pChar)) {
            // add this character to word

            *pWord = *pChar;
            pWord++;
            cbWord++;

            if (cbWord >= cbBuf) {
                *(pWord - 1) = TEXT('\0');
                MsgBoxParam(NULL,IDS_WORDTOOLONG,szBuf,MB_ICONEXCLAMATION,MB_OK);
                *puErr = ERROR_ALREADY_DISPLAYED;
                goto Exit;
            }

    #if 0
            if (IsDBCSLeadByte((BYTE) *pChar)) {
                *pWord = *pChar;
                pWord++;
                cbWord++;
            }
    #endif
        }
    }

    *pWord = '\0';  // null-terminate

    // if found string a la '!!abc', then look for a string in the [strings]
    // section with the key name 'abc' and use that instead.  This is because
    // our localization tools are brainless and require a [strings] section.
    // So although template files are sectionless, we allow a [strings] section
    // at the bottom.
    if (IsLocalizedString(szBuf)) {

        lpTemp = (LPTSTR) GlobalAlloc (GPTR, (cbBuf * sizeof(TCHAR)));

        if (!lpTemp) {
            *puErr = GetLastError();
            return NULL;
        }

        if (GetString (m_pLocaleHashTable, szBuf+2, lpTemp, cbBuf) ||
            GetString (m_pLanguageHashTable, szBuf+2, lpTemp, cbBuf) ||
            GetString (m_pDefaultHashTable, szBuf+2, lpTemp, cbBuf))
        {
            hr = StringCchCopy(szBuf, cbBuf, lpTemp);
            ASSERT(SUCCEEDED(hr));
            GlobalFree (lpTemp);
        }
        else
        {
            DisplayKeywordError(IDS_ParseErr_STRING_NOT_FOUND,
                szBuf,NULL);
            *puErr=ERROR_ALREADY_DISPLAYED;
            GlobalFree (lpTemp);
            return NULL;
        }

    } else {
        *puErr = ProcessIfdefs(szBuf,cbBuf,pfMore);

        if (*puErr == ERROR_SUCCESS)
        {
            if ((szBuf[0] == TEXT('\0')) && (!fEmptyString))
            {
                fInWord = FALSE;
            }
        }
    }

Exit:

    if (*puErr != ERROR_SUCCESS || !fInWord) return NULL;
    return szBuf;
}

/*******************************************************************

    NAME:       GetNextSectionWord

    SYNOPSIS:   Gets next word and warns if end-of-file encountered.
                Optionally checks the keyword against a list of valid
                keywords.

    NOTES:      Calls GetNextWord() to get word.  This is called in
                situations where we expect there to be another word
                (e.g., inside a section) and it's an error if the
                file ends.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextSectionWord(TCHAR * szBuf,UINT cbBuf,
                                                 KEYWORDINFO * pKeywordList,
                                                 UINT *pnListIndex,
                                                 BOOL * pfMore,UINT * puErr)
{
    TCHAR * pch;

    if (!(pch=GetNextWord(szBuf,cbBuf,pfMore,puErr))) {

        if (!*pfMore && *puErr != ERROR_ALREADY_DISPLAYED) {
            DisplayKeywordError(IDS_ParseErr_UNEXPECTED_EOF,
                NULL,pKeywordList);
            *puErr = ERROR_ALREADY_DISPLAYED;
        }

        return NULL;
    }

    if (pKeywordList && !CompareKeyword(szBuf,pKeywordList,pnListIndex)) {
        *puErr = ERROR_ALREADY_DISPLAYED;
        return NULL;
    }

    return pch;
}

/*******************************************************************

    NAME:       GetNextSectionNumericWord

    SYNOPSIS:   Gets next word and converts string to number.  Warns if
                not a numeric value

********************************************************************/
UINT CPolicyComponentData::GetNextSectionNumericWord(UINT * pnVal)
{
    UINT uErr;
    TCHAR szWordBuf[WORDBUFSIZE];
    BOOL fMore;

    if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
        NULL,NULL,&fMore,&uErr))
        return uErr;

    if (!StringToNum(szWordBuf,pnVal)) {
        DisplayKeywordError(IDS_ParseErr_NOT_NUMERIC,szWordBuf,
            NULL);
        return ERROR_ALREADY_DISPLAYED;
    }

    return ERROR_SUCCESS;
}


/*******************************************************************

    NAME:       GetNextChar

    SYNOPSIS:   Returns a pointer to the next character from the
                file stream.

********************************************************************/
TCHAR * CPolicyComponentData::GetNextChar(BOOL * pfMore,UINT * puErr)
{
    TCHAR * pCurrentChar;

    *puErr = ERROR_SUCCESS;


    if (m_pFilePtr > m_pFileEnd) {
        *pfMore = FALSE;
        return NULL;
    }

    pCurrentChar = m_pFilePtr;
    m_pFilePtr = CharNext(m_pFilePtr);
    *pfMore = TRUE;

    return pCurrentChar;
}

/*******************************************************************

    NAME:       GetString

    SYNOPSIS:   Returns the display string

********************************************************************/
BOOL CPolicyComponentData::GetString (LPHASHTABLE lpHashTable,
                                     LPTSTR lpStringName,
                                     LPTSTR lpResult, DWORD dwSize)
{
    LPTSTR lpTemp, lpDest;
    DWORD  dwCCH, dwIndex;
    BOOL   bFoundQuote = FALSE;
    TCHAR  cTestChar;


    if (!lpHashTable)
    {
        return FALSE;
    }

    if (!m_bRetrieveString)
    {
        lpResult = TEXT('\0');
        return TRUE;
    }

    dwCCH = lstrlen (lpStringName);

    lpTemp = FindHashEntry (lpHashTable, lpStringName, dwCCH);

    if (!lpTemp)
    {
        return FALSE;
    }

    lpTemp += dwCCH;

    while (*lpTemp == TEXT(' '))
        lpTemp++;

    if (*lpTemp == TEXT('='))
    {
        lpTemp++;

        if (*lpTemp == TEXT('\"'))
        {
            lpTemp++;
            bFoundQuote = TRUE;
        }

        lpDest = lpResult;
        dwIndex = 0;

        while (*lpTemp && (dwIndex < dwSize))
        {
            *lpDest = *lpTemp;

             lpDest++;
             lpTemp++;
             dwIndex++;
        }

        if (dwIndex == dwSize)
        {
            lpDest--;
            *lpDest = TEXT('\0');
            MsgBoxParam(NULL,IDS_STRINGTOOLONG,lpResult,MB_ICONEXCLAMATION,MB_OK);
        }
        else
        {
            *lpDest = TEXT('\0');
        }


        if (bFoundQuote)
        {
            lpTemp = lpResult + lstrlen (lpResult) - 1;

            if (*lpTemp == TEXT('\"'))
            {
                *lpTemp = TEXT('\0');
            }
        }

        //
        // Replace any \n combinations with a CR LF
        //

        lpTemp = lpResult;

        while (*lpTemp)
        {
            if ((*lpTemp == TEXT('\\')) && (*(lpTemp + 1) == TEXT('n')))
            {
                *lpTemp = TEXT('\r');
                 lpTemp++;
                *lpTemp = TEXT('\n');
            }

            lpTemp++;
        }

        return TRUE;
    }

    return FALSE;
}

VOID CPolicyComponentData::FillHashTable(LPHASHTABLE lpTable, LPTSTR lpStrings)
{
    LPTSTR lpTemp, lpStart;

    lpTemp = lpStrings;


    while (*lpTemp)
    {
        lpStart = lpTemp;

        while ((*lpTemp) && (*lpTemp != TEXT(' ')) && (*lpTemp != TEXT('=')))
        {
            lpTemp++;
        }

        if (!(*lpTemp))
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillHashTable: Found end of line when expected a equal sign.  Line found:  %s"), lpStart));
            return;
        }

        // The string will not be longer than 2^32 characters
        ASSERT( (lpTemp - lpStart) <= 0xffffffff );
        DWORD entryLength = (DWORD)(lpTemp - lpStart);
        AddHashEntry (lpTable, lpStart, entryLength);

        while (*lpTemp)
        {
            lpTemp++;
        }

        lpTemp++;
    }
}

//
// CreateStringArray takes a string section and converts it to a array of strings.
// Each string is null terminated and the entire array is double null terminated at
// the end.  This function is very similary to GetPrivateProfileSection, but considerably
// faster to execute.
//

LPTSTR CPolicyComponentData::CreateStringArray(LPTSTR lpStrings)
{
    LPTSTR lpStrArray, lpSrc, lpDest;
    DWORD dwIndex = 0;
    TCHAR chLetter = 0;

    lpStrArray = (LPTSTR) GlobalAlloc (GPTR, (m_pFileEnd - lpStrings + 1) * sizeof(WCHAR));

    if (!lpStrArray)
    {
        return NULL;
    }

    lpSrc = lpStrings;
    lpDest = lpStrArray;


    while (lpSrc <= m_pFileEnd)
    {
        if (dwIndex == 0)
        {
            //
            // Strip the white space off of the front of the line
            //

            while (*lpSrc == TEXT(' '))
            {
                lpSrc++;
            }

            //
            // If we found a square bracket open, that is the beginning of a different
            // string section.  Exit now.
            //

            if (*lpSrc == TEXT('['))
            {
                break;
            }

            //
            // If we found a semi-colon, this line is commented out
            //

            if (*lpSrc == TEXT(';'))
            {
                while (*lpSrc != TEXT('\r'))
                {
                    lpSrc++;
                }

                lpSrc += 2;
            }
        }

        if ((dwIndex == 0) && (*lpSrc == TEXT('\r')))
        {
            //
            // Found a blank line
            //

            lpSrc += 2;
        }
        else
        {
            //
            // Handle CR / LF combinations.  Two cases:
            // 1) If the line ends with a backslash, then the user has more text on the
            //    next line down (a continuation)
            // 2) If the line does not end with a backslash, then that is the end of a
            //    string variable.  Null terminate the string.
            //

            if (*lpSrc == TEXT('\r'))
            {
                //
                // If the previous character was a backsash, we back the destination
                // pointer up by 1 so that the backslash is removed.
                //

                if (chLetter == TEXT('\\'))
                {
                    lpDest--;
                }
                else
                {
                    *lpDest = TEXT('\0');
                    lpDest++;

                    dwIndex = 0;
                }

                lpSrc += 2;
            }
            else
            {
                chLetter = *lpDest = *lpSrc;
                lpDest++;
                lpSrc++;
                dwIndex++;
            }
        }
    }

    return lpStrArray;
}

LPTSTR CPolicyComponentData::FindSection (LPTSTR lpSection)
{
    LPTSTR lpTemp = m_pFilePtr;
    DWORD dwColumn = 0;
    DWORD dwStrLen = lstrlen (lpSection);


    while (lpTemp < m_pFileEnd)
    {
        if ((*lpTemp == TEXT('[')) && (dwColumn == 0))
        {
            if (CompareString (LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpTemp, dwStrLen,
                               lpSection, dwStrLen) == CSTR_EQUAL)
            {
                return lpTemp;
            }
        }

        dwColumn++;

        if (*lpTemp == TEXT('\n'))
        {
            dwColumn = 0;
        }

        lpTemp++;
    }

    return NULL;
}

BOOL CPolicyComponentData::IsComment(TCHAR * pBuf)
{
    return (*pBuf == TEXT(';'));
}


BOOL CPolicyComponentData::IsQuote(TCHAR * pBuf)
{
    return (*pBuf == TEXT('\"'));
}

BOOL CPolicyComponentData::IsEndOfLine(TCHAR * pBuf)
{
    return (*pBuf == TEXT('\r'));     // CR
}


BOOL CPolicyComponentData::IsWhitespace(TCHAR * pBuf)
{
    return (   *pBuf == TEXT(' ')     // space
            || *pBuf == TEXT('\r')    // CR
            || *pBuf == TEXT('\n')    // LF
            || *pBuf == TEXT('\t')    // tab
            || *pBuf == 0x001A        // EOF
            || *pBuf == 0xFEFF        // Unicode marker
           );
}

BOOL CPolicyComponentData::IsLocalizedString(TCHAR * pBuf)
{
    return (*pBuf == TEXT('!') && *(pBuf+1) == TEXT('!'));
}


#define MSGSIZE 1024
#define FMTSIZE 512
VOID CPolicyComponentData::DisplayKeywordError(UINT uErrorID,TCHAR * szFound,
    KEYWORDINFO * pExpectedList)
{
    TCHAR * pMsg,*pFmt,*pErrTxt,*pTmp;

    pMsg = (TCHAR *) GlobalAlloc(GPTR,(MSGSIZE * sizeof(TCHAR)));
    pFmt = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));
    pErrTxt = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));
    pTmp = (TCHAR *) GlobalAlloc(GPTR,(FMTSIZE * sizeof(TCHAR)));

    if (!pMsg || !pFmt || !pErrTxt || !pTmp) {
        if (pMsg) GlobalFree(pMsg);
        if (pFmt) GlobalFree(pFmt);
        if (pErrTxt) GlobalFree(pErrTxt);
        if (pTmp) GlobalFree(pTmp);

        MsgBox(NULL,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return;
    }

    LoadSz(IDS_ParseFmt_MSG_FORMAT,pFmt,FMTSIZE);
    (void) StringCchPrintf(pMsg, MSGSIZE, pFmt, m_pszParseFileName, m_nFileLine,uErrorID, LoadSz(uErrorID,
        pErrTxt,FMTSIZE));

    if (szFound) {
        LoadSz(IDS_ParseFmt_FOUND,pFmt,FMTSIZE);
        (void) StringCchPrintf(pTmp, FMTSIZE, pFmt, szFound);
        (void) StringCchCat(pMsg, MSGSIZE, pTmp);
    }

    if (pExpectedList) {
        UINT nIndex=0;
        LoadSz(IDS_ParseFmt_EXPECTED,pFmt,FMTSIZE);
        (void) StringCchCopy(pErrTxt, FMTSIZE, g_szNull);

        while (pExpectedList[nIndex].pWord) {
            (void) StringCchCat(pErrTxt, FMTSIZE, pExpectedList[nIndex].pWord);
            if (pExpectedList[nIndex+1].pWord) {
                (void) StringCchCat(pErrTxt, FMTSIZE, TEXT(", "));
            }

            nIndex++;
        }

        (void) StringCchPrintf(pTmp, FMTSIZE, pFmt, pErrTxt);
        (void) StringCchCat(pMsg, MSGSIZE, pTmp);
    }

    (void) StringCchCat(pMsg, MSGSIZE, LoadSz(IDS_ParseFmt_FATAL, pTmp, FMTSIZE));

    DebugMsg((DM_WARNING, TEXT("Keyword error: %s"), pMsg));

    MsgBoxSz(NULL,pMsg,MB_ICONEXCLAMATION,MB_OK);

    GlobalFree(pMsg);
    GlobalFree(pFmt);
    GlobalFree(pErrTxt);
    GlobalFree(pTmp);
}


int CPolicyComponentData::MsgBox(HWND hWnd,UINT nResource,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[REGBUFLEN];
    TCHAR szSmallBuf[SMALLBUF];

    LoadSz(IDS_POLICY_NAME,szSmallBuf,ARRAYSIZE(szSmallBuf));
    LoadSz(nResource,szMsgBuf,ARRAYSIZE(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

int CPolicyComponentData::MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALLBUF];

    LoadSz(IDS_POLICY_NAME,szSmallBuf,ARRAYSIZE(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

int CPolicyComponentData::MsgBoxParam(HWND hWnd,UINT nResource,TCHAR * szReplaceText,UINT uIcon,
        UINT uButtons)
{
    TCHAR szFormat[REGBUFLEN];
    LPTSTR lpMsgBuf;
    INT iResult;
    HRESULT hr = S_OK;
    DWORD dwMsgLen = lstrlen(szReplaceText) + 1 + REGBUFLEN;

    lpMsgBuf = (LPTSTR) LocalAlloc (LPTR, (dwMsgLen) * sizeof(TCHAR));

    if (!lpMsgBuf)
    {
        return 0;
    }

    LoadSz(nResource,szFormat,ARRAYSIZE(szFormat));

    hr = StringCchPrintf(lpMsgBuf, dwMsgLen, szFormat, szReplaceText);
    ASSERT(SUCCEEDED(hr));

    iResult = MsgBoxSz(hWnd,lpMsgBuf,uIcon,uButtons);

    LocalFree (lpMsgBuf);

    return iResult;
}

LPTSTR CPolicyComponentData::LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = TEXT('\0');
        LoadString( g_hInstance, idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

BOOL fFilterDirectives = TRUE;
UINT nGlobalNestedLevel = 0;

// reads up through the matching directive #endif in current scope
//and sets file pointer immediately past the directive
UINT CPolicyComponentData::FindMatchingDirective(BOOL *pfMore,BOOL fElseOK)
{
    TCHAR szWordBuf[WORDBUFSIZE];
    UINT uErr=ERROR_SUCCESS,nNestedLevel=1;
    BOOL fContinue = TRUE;

    // set the flag to stop catching '#' directives in low level word-fetching
    // routine
    fFilterDirectives = FALSE;

    // keep reading words.  Keep track of how many layers of #ifdefs deep we
    // are.  Every time we encounter an #ifdef or #ifndef, increment the level
    // count (nNestedLevel) by one.  For every #endif decrement the level count.
    // When the level count hits zero, we've found the matching #endif.
    while (nNestedLevel > 0) {
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),NULL,NULL,
            pfMore,&uErr))
            break;

        if (!lstrcmpi(szWordBuf,szIFDEF) || !lstrcmpi(szWordBuf,szIFNDEF) ||
            !lstrcmpi(szWordBuf,szIF))
            nNestedLevel ++;
        else if (!lstrcmpi(szWordBuf,szENDIF)) {
            nNestedLevel --;
        }
        else if (!lstrcmpi(szWordBuf,szELSE) && (nNestedLevel == 1)) {
            if (fElseOK) {
                // ignore "#else" unless it's on the same level as the #ifdef
                // we're finding a match for (nNestedLevel == 1), in which
                // case treat it as the matching directive
                nNestedLevel --;
                // increment global nesting so we expect an #endif to come along
                // later to match this #else
                nGlobalNestedLevel++;
            } else {
                // found a #else where we already had a #else in this level
                DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                    szWordBuf,NULL);
                return ERROR_ALREADY_DISPLAYED;
            }
        }
    }

    fFilterDirectives = TRUE;

    return uErr;
}


// if the word in the word buffer is #ifdef, #if, #ifndef, #else or #endif,
// this function reads ahead an appropriate amount (
UINT CPolicyComponentData::ProcessIfdefs(TCHAR * pBuf,UINT cbBuf,BOOL * pfMore)
{
    UINT uRet;

    if (!fFilterDirectives)
        return ERROR_SUCCESS;

    if (!lstrcmpi(pBuf,szIFDEF)) {
    // we've found an '#ifdef <something or other>, where ISV policy editors
    // can understand particular keywords they make up.  We don't have any
    // #ifdef keywords of our own so always skip this
        uRet = FindMatchingDirective(pfMore,TRUE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIFNDEF)) {
        // this is an #ifndef, and since nothing is ever ifdef'd for our policy
        // editor, this always evaluates to TRUE

        // keep reading this section but increment the nested level count,
        // when we find the matching #endif or #else we'll be able to respond
        // correctly
        nGlobalNestedLevel ++;

        // get next word (e.g. "abc" for #ifndef abc) and throw it away
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        // get next word and return it for real
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;

    } else if (!lstrcmpi(pBuf,szENDIF)) {
        // if we ever encounter an #endif here, we must have processed
        // the preceeding section.  Just step over the #endif and go on

        if (!nGlobalNestedLevel) {
            // found an endif without a preceeding #if<xx>

            DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szIF)) {
        // syntax is "#if VERSION (comparision) (version #)"
        // e.g. "#if VERSION >= 2"
        TCHAR szWordBuf[WORDBUFSIZE];
        UINT nIndex,nVersion,nOperator;
        BOOL fDirectiveTrue = FALSE;

        // get the next word (must be "VERSION")
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
            pVersionCmpList,&nIndex,pfMore,&uRet))
            return uRet;

        // get the comparison operator (>, <, ==, >=, <=)
        if (!GetNextSectionWord(szWordBuf,ARRAYSIZE(szWordBuf),
            pOperatorCmpList,&nOperator,pfMore,&uRet))
            return uRet;

        // get the version number
        uRet=GetNextSectionNumericWord(&nVersion);
        if (uRet != ERROR_SUCCESS)
            return uRet;

        // now evaluate the directive

        switch (nOperator) {
            case KYWD_ID_GT:
                fDirectiveTrue = (CURRENT_ADM_VERSION > nVersion);
                break;

            case KYWD_ID_GTE:
                fDirectiveTrue = (CURRENT_ADM_VERSION >= nVersion);
                break;

            case KYWD_ID_LT:
                fDirectiveTrue = (CURRENT_ADM_VERSION < nVersion);
                break;

            case KYWD_ID_LTE:
                fDirectiveTrue = (CURRENT_ADM_VERSION <= nVersion);
                break;

            case KYWD_ID_EQ:
                fDirectiveTrue = (CURRENT_ADM_VERSION == nVersion);
                break;

            case KYWD_ID_NE:
                fDirectiveTrue = (CURRENT_ADM_VERSION != nVersion);
                break;
        }


        if (fDirectiveTrue) {
            // keep reading this section but increment the nested level count,
            // when we find the matching #endif or #else we'll be able to respond
            // correctly
            nGlobalNestedLevel ++;
        } else {
            // skip over this section
            uRet = FindMatchingDirective(pfMore,TRUE);
            if (uRet != ERROR_SUCCESS)
                return uRet;
        }

        // get next word and return it for real
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;

        return ERROR_SUCCESS;
    } else if (!lstrcmpi(pBuf,szELSE)) {
        // found an #else, which means we took the upper branch, skip over
        // the lower branch
        if (!nGlobalNestedLevel) {
            // found an #else without a preceeding #if<xx>

            DisplayKeywordError(IDS_ParseErr_UNMATCHED_DIRECTIVE,
                pBuf,NULL);
            return ERROR_ALREADY_DISPLAYED;
        }
        nGlobalNestedLevel--;

        uRet = FindMatchingDirective(pfMore,FALSE);
        if (uRet != ERROR_SUCCESS)
            return uRet;
        if (!GetNextWord(pBuf,cbBuf,pfMore,&uRet))
            return uRet;
        return ERROR_SUCCESS;
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

        NAME:           FreeTable

        SYNOPSIS:       Frees the specified table and all sub-tables of that
                                table.

        NOTES:          Walks through the table entries and calls itself to
                                recursively free sub-tables.

        EXIT:           Returns TRUE if successful, FALSE if a memory error
                                occurs.

********************************************************************/
BOOL CPolicyComponentData::FreeTable(TABLEENTRY * pTableEntry)
{
        TABLEENTRY * pNext = pTableEntry->pNext;

        // free all children
        if (pTableEntry->pChild)
                FreeTable(pTableEntry->pChild);

        GlobalFree(pTableEntry);

        if (pNext) FreeTable(pNext);

        return TRUE;
}


LPTSTR CPolicyComponentData::GetStringSection (LPCTSTR lpSection, LPCTSTR lpFileName)
{
    DWORD dwSize, dwRead;
    LPTSTR lpStrings;


    //
    // Read in the default strings section
    //

    dwSize = STRINGS_BUF_SIZE;
    lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

    if (!lpStrings)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetStringSection: Failed to alloc memory for default strings with %d."),
                 GetLastError()));
        return NULL;
    }


    do {
        dwRead = GetPrivateProfileSection (lpSection,
                                           lpStrings,
                                           dwSize, lpFileName);

        if (dwRead != (dwSize - 2))
        {
            break;
        }

        GlobalFree (lpStrings);

        dwSize *= 2;
        lpStrings = (TCHAR *) GlobalAlloc (GPTR, dwSize * sizeof(TCHAR));

        if (!lpStrings)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::GetStringSection: Failed to alloc memory for Default strings with %d."),
                     GetLastError()));
            return FALSE;
        }

     }  while (TRUE);


    if (dwRead == 0)
    {
        GlobalFree (lpStrings);
        lpStrings = NULL;
    }

    return lpStrings;
}

INT CPolicyComponentData::TemplatesSortCallback (LPARAM lParam1, LPARAM lParam2,
                                                  LPARAM lColumn)
{
    LPTEMPLATEENTRY lpEntry1, lpEntry2;
    INT iResult;

    lpEntry1 = (LPTEMPLATEENTRY) lParam1;
    lpEntry2 = (LPTEMPLATEENTRY) lParam2;


    if (lColumn == 0)
    {
        iResult = lstrcmpi (lpEntry1->lpFileName, lpEntry2->lpFileName);
    }
    else if (lColumn == 1)
    {

        if (lpEntry1->dwSize < lpEntry2->dwSize)
        {
            iResult = -1;
        }
        else if (lpEntry1->dwSize > lpEntry2->dwSize)
        {
            iResult = 1;
        }
        else
        {
            iResult = 0;
        }
    }
    else
    {
        iResult = CompareFileTime (&lpEntry1->ftTime, &lpEntry2->ftTime);
    }

    return iResult;
}

BOOL CPolicyComponentData::FillADMFiles (HWND hDlg)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szDate[20];
    TCHAR szTime[20];
    TCHAR szBuffer[45];
    HWND hLV;
    INT iItem;
    LVITEM item;
    FILETIME filetime;
    SYSTEMTIME systime;
    WIN32_FIND_DATA fd;
    LPTEMPLATEENTRY lpEntry;
    HANDLE hFile;
    LPTSTR lpEnd, lpTemp;
    HRESULT hr = S_OK;
    XLastError xe;

    //
    // Ask for the root of the GPT so we can access the
    // adm files.
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to get gpt path.")));
        return FALSE;
    }

    //
    // Create the directory
    //

    lpEnd = CheckSlash (szPath);

    hr = StringCchCopy (lpEnd, ARRAYSIZE(szPath) - (lpEnd - szPath), g_szADM);
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    if (!CreateNestedDirectory(szPath, NULL))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to create adm directory.")));
        return FALSE;
    }


    //
    // Prepare the listview
    //

    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);
    SendMessage (hLV, WM_SETREDRAW, FALSE, 0);
    ListView_DeleteAllItems(hLV);


    //
    // Enumerate the files
    //

    hr = StringCchCat (szPath, ARRAYSIZE(szPath), TEXT("\\*.adm"));
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    hFile = FindFirstFile(szPath, &fd);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            if (!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {

                lpEntry = (LPTEMPLATEENTRY) LocalAlloc (LPTR,
                         sizeof(TEMPLATEENTRY) + ((lstrlen(fd.cFileName) + 1) * sizeof(TCHAR)));

                if (lpEntry)
                {

                    lpEntry->lpFileName = (LPTSTR)((LPBYTE)lpEntry + sizeof(TEMPLATEENTRY));
                    lpEntry->dwSize = fd.nFileSizeLow / 1024;

                    if (lpEntry->dwSize == 0)
                    {
                        lpEntry->dwSize = 1;
                    }

                    lpEntry->ftTime.dwLowDateTime = fd.ftLastWriteTime.dwLowDateTime;
                    lpEntry->ftTime.dwHighDateTime = fd.ftLastWriteTime.dwHighDateTime;

                    hr = StringCchCopy (lpEntry->lpFileName, lstrlen(fd.cFileName) + 1, fd.cFileName);
                    ASSERT(SUCCEEDED(hr));

                    //
                    // Add the filename
                    //

                    lpTemp = fd.cFileName + lstrlen (fd.cFileName) - 4;

                    if (*lpTemp == TEXT('.'))
                    {
                        *lpTemp = TEXT('\0');
                    }

                    item.mask = LVIF_TEXT | LVIF_IMAGE  | LVIF_STATE | LVIF_PARAM;
                    item.iItem = 0;
                    item.iSubItem = 0;
                    item.state = 0;
                    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                    item.pszText = fd.cFileName;
                    item.iImage = 0;
                    item.lParam = (LPARAM) lpEntry;

                    iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);

                    if (iItem == -1)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to insert item.")));
                        return FALSE;
                    }

                    //
                    // Add the size
                    //

                    hr = StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%dKB"), lpEntry->dwSize);
                    ASSERT(SUCCEEDED(hr));

                    item.mask = LVIF_TEXT;
                    item.iItem = iItem;
                    item.iSubItem = 1;
                    item.pszText = szBuffer;

                    SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


                    //
                    // And the last modified date
                    //

                    FileTimeToLocalFileTime (&fd.ftLastWriteTime, &filetime);
                    FileTimeToSystemTime (&filetime, &systime);

                    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE,
                                   &systime, NULL, szDate, 20);

                    GetTimeFormat (LOCALE_USER_DEFAULT, TIME_NOSECONDS,
                                   &systime, NULL, szTime, 20);

                    hr = StringCchPrintf (szBuffer, ARRAYSIZE(szBuffer), TEXT("%s %s"), szDate, szTime);
                    ASSERT(SUCCEEDED(hr));

                    item.mask = LVIF_TEXT;
                    item.iItem = iItem;
                    item.iSubItem = 2;
                    item.pszText = szBuffer;

                    SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::FillADMFiles: Failed to allocate memory for an entry %d."),
                             GetLastError()));
                }
            }

        } while (FindNextFile(hFile, &fd));


        FindClose(hFile);
    }

    if (SendMessage(hLV, LVM_GETITEMCOUNT, 0, 0) > 0)
    {
        //
        // Sort the listview
        //

        ListView_SortItems (hLV, TemplatesSortCallback, m_bTemplatesColumn);


        //
        // Select the first item
        //

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);

        EnableWindow (GetDlgItem (hDlg, IDC_REMOVETEMPLATES), TRUE);
    }
    else
    {
        EnableWindow (GetDlgItem (hDlg, IDC_REMOVETEMPLATES), FALSE);
        SetFocus (GetDlgItem (hDlg, IDC_ADDTEMPLATES));
    }


    SendMessage (hLV, WM_SETREDRAW, TRUE, 0);

    return TRUE;
}


BOOL CPolicyComponentData::InitializeTemplatesDlg (HWND hDlg)
{
    LVCOLUMN lvc;
    LVITEM item;
    TCHAR szTitle[50];
    INT iNameWidth;
    HIMAGELIST hLarge, hSmall;
    HICON hIcon;
    HWND hLV;
    RECT rc;


    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);
    GetClientRect (hLV, &rc);


    //
    // Create the imagelists
    //

    hLarge = ImageList_Create (32, 32, ILC_MASK, 1, 1);

    if (!hLarge)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::InitializeTemplatesDlg: Failed to create large imagelist.")));
        return FALSE;
    }

    hSmall = ImageList_Create (16, 16, ILC_MASK, 1, 1);

    if (!hSmall)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::InitializeTemplatesDlg: Failed to create small imagelist.")));
        ImageList_Destroy (hLarge);
        return FALSE;
    }


    //
    // Add the icon
    //

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_DOCUMENT),
                               IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);


    if ( hIcon )
    {
        ImageList_AddIcon (hLarge, hIcon);

        DestroyIcon (hIcon);
    }

    hIcon = (HICON) LoadImage (g_hInstance, MAKEINTRESOURCE(IDI_DOCUMENT),
                               IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);


    if ( hIcon )
    {
        ImageList_AddIcon (hSmall, hIcon);

        DestroyIcon (hIcon);
    }


    //
    // Associate the imagelist with the listview.
    // The listview will free this when the
    // control is destroyed.
    //

    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_NORMAL, (LPARAM) hLarge);
    SendMessage (hLV, LVM_SETIMAGELIST, LVSIL_SMALL, (LPARAM) hSmall);



    //
    // Set extended LV style for whole line selection
    //

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);


    //
    // Insert the columns
    //

    LoadString (g_hInstance, IDS_NAME, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    iNameWidth = (int)(rc.right * .60);
    lvc.cx = iNameWidth;
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 0;

    SendMessage (hLV, LVM_INSERTCOLUMN,  0, (LPARAM) &lvc);


    LoadString (g_hInstance, IDS_SIZE, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_RIGHT;
    iNameWidth += (int)(rc.right * .15);
    lvc.cx = (int)(rc.right * .15);
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 0;

    SendMessage (hLV, LVM_INSERTCOLUMN,  1, (LPARAM) &lvc);


    LoadString (g_hInstance, IDS_MODIFIED, szTitle, 50);

    lvc.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - iNameWidth;
    lvc.pszText = szTitle;
    lvc.cchTextMax = 50;
    lvc.iSubItem = 1;

    SendMessage (hLV, LVM_INSERTCOLUMN,  2, (LPARAM) &lvc);


    //
    // Fill the list view with the adm files
    //

    FillADMFiles (hDlg);

    return TRUE;
}

BOOL CPolicyComponentData::AddTemplates(HWND hDlg)
{
    OPENFILENAME ofn;
    LVITEM item;
    INT iCount, iResult;
    BOOL bResult = FALSE;
    LPTSTR lpFileName, lpTemp, lpEnd, lpSrcList = NULL;
    DWORD dwListLen, dwTemp, dwNextString;
    TCHAR szFilter[100];
    TCHAR szTitle[100];
    TCHAR szFile[2*MAX_PATH];
    TCHAR szInf[MAX_PATH];
    TCHAR szDest[MAX_PATH];
    TCHAR szSrc[2*MAX_PATH];
    SHFILEOPSTRUCT fileop;
    HRESULT hr = S_OK;
    XLastError xe;

    //
    // Prompt for new files
    //

    LoadString (g_hInstance, IDS_POLICYFILTER, szFilter, ARRAYSIZE(szFilter));
    LoadString (g_hInstance, IDS_POLICYTITLE, szTitle, ARRAYSIZE(szTitle));
    ExpandEnvironmentStrings (TEXT("%SystemRoot%\\Inf"), szInf, MAX_PATH);


    lpTemp = szFilter;

    while (*lpTemp)
    {
        if (*lpTemp == TEXT('#'))
            *lpTemp = TEXT('\0');

        lpTemp++;
    }

    ZeroMemory (&ofn, sizeof(ofn));
    szFile[0] = TEXT('\0');
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.hInstance = g_hInstance;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = 2*MAX_PATH;
    ofn.lpstrInitialDir = szInf;
    ofn.lpstrTitle = szTitle;
    ofn.Flags = OFN_ALLOWMULTISELECT | OFN_NOCHANGEDIR | OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_EXPLORER;

    if (!GetOpenFileName (&ofn))
    {
        return FALSE;
    }


    //
    // Setup the destination
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szDest,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to get gpt path.")));
        return FALSE;
    }

    lpEnd = CheckSlash (szDest);
    
    hr = StringCchCopy (lpEnd, ARRAYSIZE(szDest) - (lpEnd - szDest), g_szADM);

    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    //
    // Setup up the source
    //

    *(szFile + ofn.nFileOffset - 1) = TEXT('\0');
    
    hr = StringCchCopy (szSrc, ARRAYSIZE(szSrc), szFile);
    
    if (FAILED(hr))
    {
        xe = HRESULT_CODE(hr);
        return FALSE;
    }

    lpEnd = CheckSlash (szSrc);

    lpFileName = szFile + lstrlen (szFile) + 1;


    //
    // Loop through the files copying and adding them to the list.
    //

    while (*lpFileName)
    {
        lpTemp = lpFileName + lstrlen (lpFileName) - 4;

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, lpTemp, -1, TEXT(".adm"), -1) == CSTR_EQUAL)
        {
            hr = StringCchCopy (lpEnd, ARRAYSIZE(szSrc) - (lpEnd - szSrc), lpFileName);
            ASSERT(SUCCEEDED(hr));

            if (lpSrcList)
            {
                dwTemp = dwListLen + ((lstrlen (szSrc) + 1) * sizeof(TCHAR));
                lpTemp = (LPTSTR) LocalReAlloc (lpSrcList, dwTemp, LMEM_MOVEABLE | LMEM_ZEROINIT);

                if (lpTemp)
                {
                    lpSrcList = lpTemp;
                    dwListLen = dwTemp;

                    hr = StringCchCopy ((lpSrcList + dwNextString), lstrlen(szSrc) + 1, szSrc);
                    ASSERT(SUCCEEDED(hr));
                    dwNextString += lstrlen (szSrc) + 1;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to realloc memory for Src list. %d"),
                             GetLastError()));
                }
            }
            else
            {
                dwListLen = (lstrlen (szSrc) + 2) * sizeof(TCHAR);

                lpSrcList = (LPTSTR) LocalAlloc (LPTR, dwListLen);

                if (lpSrcList)
                {
                    hr = StringCchCopy (lpSrcList, dwListLen/sizeof(TCHAR), szSrc);
                    ASSERT(SUCCEEDED(hr));
                    dwNextString = lstrlen (lpSrcList) + 1;
                }
                else
                {
                    DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to alloc memory for src list. %d"),
                             GetLastError()));
                }
            }
        }
        else
        {
            MsgBoxParam(hDlg, IDS_INVALIDADMFILE, lpFileName, MB_ICONERROR, MB_OK);
        }

        lpFileName = lpFileName + lstrlen (lpFileName) + 1;
    }


    if (lpSrcList)
    {
        fileop.hwnd = hDlg;
        fileop.wFunc = FO_COPY;
        fileop.pFrom = lpSrcList;
        fileop.pTo = szDest;
        fileop.fFlags = FOF_NOCONFIRMMKDIR;

        iResult = SHFileOperation(&fileop);

        if (!iResult)
        {
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to copy <%s> to <%s> with %d."),
                     szSrc, szDest, iResult));
        }


        LocalFree (lpSrcList);

        if (bResult)
        {
            FillADMFiles (hDlg);
        }
    }


    return bResult;
}

BOOL CPolicyComponentData::RemoveTemplates(HWND hDlg)
{
    HWND hLV;
    LVITEM item;
    BOOL bResult = FALSE;
    INT iResult, iIndex = -1;
    LPTEMPLATEENTRY lpEntry;
    LPTSTR lpEnd, lpTemp, lpDeleteList = NULL;
    TCHAR szPath[MAX_PATH];
    DWORD dwSize, dwListLen, dwTemp, dwNextString;
    SHFILEOPSTRUCT fileop;
    HRESULT hr = S_OK;
    XLastError xe;

    hLV = GetDlgItem (hDlg, IDC_TEMPLATELIST);


    //
    // Get the path to the adm directory
    //

    if (m_pGPTInformation->GetFileSysPath(GPO_SECTION_ROOT, szPath,
                                      MAX_PATH) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddTemplates: Failed to get gpt path.")));
        return FALSE;
    }

    lpEnd = CheckSlash (szPath);
    hr = StringCchCopy (lpEnd, MAX_PATH - (lpEnd - szPath), g_szADM);
    if (FAILED(hr))
    {   
        xe = HRESULT_CODE(hr);
        return bResult;
    }

    lpEnd = CheckSlash (szPath);
    
    dwSize = MAX_PATH - (DWORD)(lpEnd - szPath);



    //
    // Build a list of selected items
    //

    while ((iIndex = ListView_GetNextItem (hLV, iIndex,
           LVNI_ALL | LVNI_SELECTED)) != -1)
    {

        item.mask = LVIF_PARAM;
        item.iItem = iIndex;
        item.iSubItem = 0;

        if (!ListView_GetItem (hLV, &item))
        {
            continue;
        }

        lpEntry = (LPTEMPLATEENTRY) item.lParam;
        lstrcpyn (lpEnd, lpEntry->lpFileName, dwSize);

        if (lpDeleteList)
        {
            dwTemp = dwListLen + ((lstrlen (szPath) + 1) * sizeof(TCHAR));
            lpTemp = (LPTSTR) LocalReAlloc (lpDeleteList, dwTemp, LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (lpTemp)
            {
                lpDeleteList = lpTemp;
                dwListLen = dwTemp;

                hr = StringCchCopy ((lpDeleteList + dwNextString), lstrlen(szPath) + 1, szPath);
                ASSERT(SUCCEEDED(hr));
                dwNextString += lstrlen (szPath) + 1;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to realloc memory for delete list. %d"),
                         GetLastError()));
            }
        }
        else
        {
            dwListLen = (lstrlen (szPath) + 2) * sizeof(TCHAR);

            lpDeleteList = (LPTSTR) LocalAlloc (LPTR, dwListLen);

            if (lpDeleteList)
            {
                hr = StringCchCopy (lpDeleteList, dwListLen/sizeof(WCHAR), szPath);
                ASSERT(SUCCEEDED(hr));
                dwNextString = lstrlen (lpDeleteList) + 1;
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to alloc memory for delete list. %d"),
                         GetLastError()));
            }
        }
    }


    if (lpDeleteList)
    {
        fileop.hwnd = hDlg;
        fileop.wFunc = FO_DELETE;
        fileop.pFrom = lpDeleteList;
        fileop.pTo = NULL;
        fileop.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;

        iResult = SHFileOperation(&fileop);

        if (!iResult)
        {
            bResult = TRUE;
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::RemoveTemplates: Failed to delete file <%s> with %d."),
                     szPath, iResult));
        }

        LocalFree (lpDeleteList);

        if (bResult)
        {
            FillADMFiles (hDlg);
        }
    }

    return bResult;
}

INT_PTR CALLBACK CPolicyComponentData::TemplatesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CPolicyComponentData * pCD;
    static BOOL bTemplatesDirty;

    switch (message)
    {
        case WM_INITDIALOG:
            pCD = (CPolicyComponentData*) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCD);

            bTemplatesDirty = FALSE;

            if (!pCD->InitializeTemplatesDlg(hDlg))
            {
                EndDialog (hDlg, FALSE);
            }

            PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                case IDCLOSE:
                    EndDialog (hDlg, bTemplatesDirty);
                    break;

                case IDC_ADDTEMPLATES:
                    pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pCD && pCD->AddTemplates(hDlg))
                    {
                        bTemplatesDirty = TRUE;
                    }
                    break;

                case IDC_REMOVETEMPLATES:
                    pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pCD && pCD->RemoveTemplates(hDlg))
                    {
                        bTemplatesDirty = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            if (((NMHDR FAR*)lParam)->code == LVN_DELETEITEM)
            {
                LVITEM item;
                LPTEMPLATEENTRY lpEntry;

                item.mask = LVIF_PARAM;
                item.iItem = ((NMLISTVIEW FAR*)lParam)->iItem;
                item.iSubItem = 0;

                if (ListView_GetItem (GetDlgItem (hDlg, IDC_TEMPLATELIST), &item))
                {
                    lpEntry = (LPTEMPLATEENTRY) item.lParam;
                    LocalFree (lpEntry);
                }
            }
            else if (((NMHDR FAR*)lParam)->code == LVN_COLUMNCLICK)
            {
                pCD = (CPolicyComponentData*) GetWindowLongPtr (hDlg, DWLP_USER);

                if (pCD)
                {
                    pCD->m_bTemplatesColumn = ((NMLISTVIEW FAR*)lParam)->iSubItem;
                    ListView_SortItems (GetDlgItem (hDlg, IDC_TEMPLATELIST),
                                        TemplatesSortCallback, pCD->m_bTemplatesColumn);
                }
            }
            else
            {
                PostMessage (hDlg, WM_REFRESHDISPLAY, 0, 0);
            }
            break;

        case WM_REFRESHDISPLAY:
            if (ListView_GetNextItem (GetDlgItem(hDlg, IDC_TEMPLATELIST),
                                      -1, LVNI_ALL | LVNI_SELECTED) == -1)
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVETEMPLATES), FALSE);
            }
            else
            {
                EnableWindow (GetDlgItem(hDlg, IDC_REMOVETEMPLATES), TRUE);
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aADMHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aADMHelpIds);
            return TRUE;

    }

    return FALSE;
}

BOOL CPolicyComponentData::AddRSOPRegistryDataNode(LPTSTR lpKeyName, LPTSTR lpValueName, DWORD dwType,
                             DWORD dwDataSize, LPBYTE lpData, UINT uiPrecedence, LPTSTR lpGPOName, BOOL bDeleted)
{
    DWORD dwSize;
    LPRSOPREGITEM lpItem;
    BOOL bSystemEntry = FALSE;
    HRESULT hr = S_OK;

    //
    // Special case some registry key / values and do not add them to the link list.
    // These registry entries are specific to snapins we write and we know for sure
    // they have rsop UI that will show their values.
    //

    if (lpKeyName)
    {
        const TCHAR szCerts[] = TEXT("Software\\Policies\\Microsoft\\SystemCertificates");
        int iCertLen = lstrlen (szCerts);


        //
        // Remove all system certificates
        //

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          lpKeyName, iCertLen, szCerts, iCertLen) == CSTR_EQUAL)
        {
            bSystemEntry = TRUE;
        }

        if ( ! bSystemEntry )
        {
            const TCHAR szCryptography[] = TEXT("Software\\Policies\\Microsoft\\Cryptography");
            int iCryptographyLen = lstrlen (szCryptography);

            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                              lpKeyName, iCryptographyLen, szCryptography, iCryptographyLen) == CSTR_EQUAL)
            {
                bSystemEntry = TRUE;
            }
        }

        //
        // Hide the digial signature policies for Software Installation
        //

        if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          lpKeyName, -1, TEXT("Software\\Policies\\Microsoft\\Windows\\Installer"), -1) == CSTR_EQUAL)
        {
            if (lpValueName)
            {
                if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                  lpValueName, -1, TEXT("InstallKnownPackagesOnly"), -1) == CSTR_EQUAL)
                {
                    bSystemEntry = TRUE;
                }

                else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                       lpValueName, -1, TEXT("IgnoreSignaturePolicyForAdmins"), -1) == CSTR_EQUAL)
                {
                    bSystemEntry = TRUE;
                }
            }
        }

        //
        // Hide all the SAFER policies
        //

        const TCHAR szSaferKey[] = TEXT("Software\\Policies\\Microsoft\\Windows\\Safer");
        int         iSaferKeyLen = sizeof(szSaferKey) / sizeof(TCHAR) - 1;

        if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                          lpKeyName, iSaferKeyLen, szSaferKey, iSaferKeyLen) == CSTR_EQUAL)
        {
            bSystemEntry = TRUE;
        }
    }


    if (bSystemEntry)
    {
        DebugMsg((DM_VERBOSE, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Ignoring %s entry"), lpKeyName));
        return TRUE;
    }


    //
    // Calculate the size of the new registry item
    //

    dwSize = sizeof (RSOPREGITEM);

    if (lpKeyName) {
        dwSize += ((lstrlen(lpKeyName) + 1) * sizeof(TCHAR));
    }

    if (lpValueName) {
        dwSize += ((lstrlen(lpValueName) + 1) * sizeof(TCHAR));
    }

    if (lpGPOName) {
        dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));
    }

    //
    // Allocate space for it
    //

    lpItem = (LPRSOPREGITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    lpItem->dwType = dwType;
    lpItem->dwSize = dwDataSize;
    lpItem->uiPrecedence = uiPrecedence;
    lpItem->bDeleted = bDeleted;

    if (lpKeyName)
    {
        lpItem->lpKeyName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
        hr = StringCchCopy (lpItem->lpKeyName, lstrlen(lpKeyName) + 1, lpKeyName);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpValueName)
    {
        if (lpKeyName)
        {
            lpItem->lpValueName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
        }
        else
        {
            lpItem->lpValueName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
        }

        hr = StringCchCopy (lpItem->lpValueName, lstrlen(lpValueName) + 1, lpValueName);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpGPOName)
    {
        if (lpValueName)
        {
            lpItem->lpGPOName = lpItem->lpValueName + lstrlen (lpItem->lpValueName) + 1;
        }
        else
        {
            if (lpKeyName)
            {
                lpItem->lpGPOName = lpItem->lpKeyName + lstrlen (lpItem->lpKeyName) + 1;
            }
            else
            {
                lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPREGITEM));
            }
        }

        hr = StringCchCopy (lpItem->lpGPOName, lstrlen(lpGPOName) + 1, lpGPOName);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpData)
    {

        lpItem->lpData = (LPBYTE) LocalAlloc (LPTR, dwDataSize);

        if (!lpItem->lpData) {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::AddRSOPRegistryDataNode: Failed to allocate memory for data with %d"),
                     GetLastError()));
            LocalFree (lpItem);
            return FALSE;
        }

        CopyMemory (lpItem->lpData, lpData, dwDataSize);
    }


    //
    // Add item to link list
    //

    lpItem->pNext = m_pRSOPRegistryData;
    m_pRSOPRegistryData = lpItem;

    return TRUE;
}

VOID CPolicyComponentData::FreeRSOPRegistryData(VOID)
{
    LPRSOPREGITEM lpTemp;


    if (!m_pRSOPRegistryData)
    {
        return;
    }


    do {
        lpTemp = m_pRSOPRegistryData->pNext;
        if (m_pRSOPRegistryData->lpData)
        {
            LocalFree (m_pRSOPRegistryData->lpData);
        }
        LocalFree (m_pRSOPRegistryData);
        m_pRSOPRegistryData = lpTemp;

    } while (lpTemp);
}

HRESULT CPolicyComponentData::InitializeRSOPRegistryData(VOID)
{
    BSTR pLanguage = NULL, pQuery = NULL;
    BSTR pRegistryKey = NULL, pValueName = NULL, pValueType = NULL, pValue = NULL, pDeleted = NULL;
    BSTR pPrecedence = NULL, pGPOid = NULL, pNamespace = NULL, pCommand = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varRegistryKey, varValueName, varValueType, varData, varDeleted;
    VARIANT varPrecedence, varGPOid, varCommand;
    SAFEARRAY * pSafeArray;
    IWbemLocator *pIWbemLocator = NULL;
    IWbemServices *pIWbemServices = NULL;
    LPTSTR lpGPOName;
    DWORD dwDataSize;
    LPBYTE lpData;
    BSTR pValueTemp;


    DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::InitializeRSOPRegistryData:  Entering")));

    //
    // Allocate BSTRs for the query language and for the query itself
    //

    pLanguage = SysAllocString (TEXT("WQL"));

    if (!pLanguage)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for language")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    pQuery = SysAllocString (TEXT("SELECT registryKey, valueName, valueType, value, deleted, precedence, GPOID, command FROM RSOP_RegistryPolicySetting"));

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pRegistryKey = SysAllocString (TEXT("registryKey"));

    if (!pRegistryKey)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for registryKey")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValueName = SysAllocString (TEXT("valueName"));

    if (!pValueName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for valueName")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValueType = SysAllocString (TEXT("valueType"));

    if (!pValueType)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for valueType")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pValue = SysAllocString (TEXT("value"));

    if (!pValue)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for value")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pDeleted = SysAllocString (TEXT("deleted"));

    if (!pDeleted)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for deleted")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pPrecedence = SysAllocString (TEXT("precedence"));

    if (!pPrecedence)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for precedence")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pGPOid = SysAllocString (TEXT("GPOID"));

    if (!pGPOid)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for GPO id")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    pCommand = SysAllocString (TEXT("command"));

    if (!pCommand)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for command")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    //
    // Create an instance of the WMI locator service
    //

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator, (LPVOID *) &pIWbemLocator);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: CoCreateInstance failed with 0x%x"), hr));
        goto Exit;
    }


    //
    // Allocate a BSTR for the namespace
    //

    pNamespace = SysAllocString (m_pszNamespace);

    if (!pNamespace)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to allocate memory for namespace")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Connect to the server
    //

    hr = pIWbemLocator->ConnectServer(pNamespace, NULL, NULL, 0L, 0L, NULL, NULL,
                                      &pIWbemServices);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: ConnectServer failed with 0x%x"), hr));
        goto Exit;
    }


    // Set the proper security to encrypt the data
    hr = CoSetProxyBlanket(pIWbemServices,
                        RPC_C_AUTHN_DEFAULT,
                        RPC_C_AUTHZ_DEFAULT,
                        COLE_DEFAULT_PRINCIPAL,
                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                        RPC_C_IMP_LEVEL_IMPERSONATE,
                        NULL,
                        0);
    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: CoSetProxyBlanket failed with 0x%x"), hr));
        goto Exit;
    }

    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeRSOPRegistryData: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    while (pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet) == S_OK)
    {

        //
        // Check for the "data not available case"
        //

        if (ulRet == 0)
        {
            hr = S_OK;
            goto Exit;
        }


        //
        // Get the deleted flag
        //

        hr = pObjects[0]->Get (pDeleted, 0, &varDeleted, NULL, NULL);

        if (SUCCEEDED(hr))
        {

            //
            // Get the registry key
            //

            hr = pObjects[0]->Get (pRegistryKey, 0, &varRegistryKey, NULL, NULL);

            if (SUCCEEDED(hr))
            {

                //
                // Get the value name
                //

                hr = pObjects[0]->Get (pValueName, 0, &varValueName, NULL, NULL);

                if (SUCCEEDED(hr))
                {

                    //
                    // Get the value type
                    //

                    hr = pObjects[0]->Get (pValueType, 0, &varValueType, NULL, NULL);

                    if (SUCCEEDED(hr))
                    {

                        //
                        // Get the value data
                        //

                        hr = pObjects[0]->Get (pValue, 0, &varData, NULL, NULL);

                        if (SUCCEEDED(hr))
                        {

                            //
                            // Get the precedence
                            //

                            hr = pObjects[0]->Get (pPrecedence, 0, &varPrecedence, NULL, NULL);

                            if (SUCCEEDED(hr))
                            {

                                //
                                // Get the command
                                //

                                hr = pObjects[0]->Get (pCommand, 0, &varCommand, NULL, NULL);

                                if (SUCCEEDED(hr))
                                {

                                    //
                                    // Get the GPO ID
                                    //

                                    hr = pObjects[0]->Get (pGPOid, 0, &varGPOid, NULL, NULL);

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = GetGPOFriendlyName (pIWbemServices, varGPOid.bstrVal,
                                                                 pLanguage, &lpGPOName);

                                        if (SUCCEEDED(hr))
                                        {

                                            if (varValueName.vt != VT_NULL)
                                            {
                                                pValueTemp = varValueName.bstrVal;
                                            }
                                            else
                                            {
                                                pValueTemp = NULL;
                                            }


                                            if (varData.vt != VT_NULL)
                                            {
                                                pSafeArray = varData.parray;
                                                dwDataSize = pSafeArray->rgsabound[0].cElements;
                                                lpData = (LPBYTE) pSafeArray->pvData;
                                            }
                                            else
                                            {
                                                dwDataSize = 0;
                                                lpData = NULL;
                                            }

                                            if ((varValueType.uintVal == REG_NONE) && pValueTemp &&
                                                (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                                              pValueTemp, -1, TEXT("**command"), -1) == CSTR_EQUAL))
                                            {
                                                pValueTemp = varCommand.bstrVal;
                                                dwDataSize = 0;
                                                lpData = NULL;
                                            }

                                            AddRSOPRegistryDataNode(varRegistryKey.bstrVal, pValueTemp,
                                                                    varValueType.uintVal, dwDataSize, lpData,
                                                                    varPrecedence.uintVal, lpGPOName,
                                                                    (varDeleted.boolVal == 0) ? FALSE : TRUE);

                                            LocalFree (lpGPOName);
                                        }

                                        VariantClear (&varGPOid);
                                    }

                                    VariantClear (&varCommand);
                                }

                                VariantClear (&varPrecedence);
                            }

                            VariantClear (&varData);
                        }

                        VariantClear (&varValueType);
                    }

                    VariantClear (&varValueName);
                }

                VariantClear (&varRegistryKey);
            }

            VariantClear (&varDeleted);
        }

        pObjects[0]->Release();

    }


    hr = S_OK;


Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pIWbemLocator)
    {
        pIWbemLocator->Release();
    }

    if (pIWbemServices)
    {
        pIWbemServices->Release();
    }

    if (pLanguage)
    {
        SysFreeString (pLanguage);
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (pRegistryKey)
    {
        SysFreeString (pRegistryKey);
    }

    if (pValueType)
    {
        SysFreeString (pValueType);
    }

    if (pValueName)
    {
        SysFreeString (pValueName);
    }

    if (pDeleted)
    {
        SysFreeString (pDeleted);
    }


    if (pValue)
    {
        SysFreeString (pValue);
    }

    if (pNamespace)
    {
        SysFreeString (pNamespace);
    }

    if (pPrecedence)
    {
        SysFreeString (pPrecedence);
    }

    if (pGPOid)
    {
        SysFreeString (pGPOid);
    }

    if (pCommand)
    {
        SysFreeString (pCommand);
    }

    DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::InitializeRSOPRegistryData:  Leaving")));

    return hr;
}

HRESULT CPolicyComponentData::GetGPOFriendlyName(IWbemServices *pIWbemServices,
                                                LPTSTR lpGPOID, BSTR pLanguage,
                                                LPTSTR *pGPOName)
{
    BSTR pQuery = NULL, pName = NULL;
    LPTSTR lpQuery = NULL;
    IEnumWbemClassObject * pEnum = NULL;
    IWbemClassObject *pObjects[2];
    HRESULT hr;
    ULONG ulRet;
    VARIANT varGPOName;
    DWORD dwGPONameLen = 0;
    
    //
    // Set the default
    //

    *pGPOName = NULL;


    //
    // Build the query
    //

    DWORD dwQryLen = lstrlen(lpGPOID) + 50;
    lpQuery = (LPTSTR) LocalAlloc (LPTR, ( dwQryLen * sizeof(TCHAR)));

    if (!lpQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for unicode query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hr = StringCchPrintf (lpQuery, dwQryLen, TEXT("SELECT name, id FROM RSOP_GPO where id=\"%s\""), lpGPOID);
    ASSERT(SUCCEEDED(hr));

    pQuery = SysAllocString (lpQuery);

    if (!pQuery)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for query")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Allocate BSTRs for the property names we want to retreive
    //

    pName = SysAllocString (TEXT("name"));

    if (!pName)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    //
    // Execute the query
    //

    hr = pIWbemServices->ExecQuery (pLanguage, pQuery,
                                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                                    NULL, &pEnum);


    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to query for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Loop through the results
    //

    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Check for the "data not available case"
    //

    if (ulRet == 0)
    {
        hr = S_OK;
        goto Exit;
    }


    //
    // Get the name
    //

    hr = pObjects[0]->Get (pName, 0, &varGPOName, NULL, NULL);

    pObjects[0]->Release();

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x"),
                  pQuery, hr));
        goto Exit;
    }


    //
    // Save the name
    //

    dwGPONameLen = lstrlen(varGPOName.bstrVal) + 1;
    *pGPOName = (LPTSTR) LocalAlloc (LPTR, (dwGPONameLen) * sizeof(TCHAR));

    if (!(*pGPOName))
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetGPOFriendlyName: Failed to allocate memory for GPO Name")));
        hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hr = StringCchCopy (*pGPOName, dwGPONameLen, varGPOName.bstrVal);
    ASSERT(SUCCEEDED(hr));

    VariantClear (&varGPOName);

    hr = S_OK;

Exit:

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pQuery)
    {
        SysFreeString (pQuery);
    }

    if (lpQuery)
    {
        LocalFree (lpQuery);
    }

    if (pName)
    {
        SysFreeString (pName);
    }

    return hr;
}

//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::ReadRSOPRegistryValue(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                 TCHAR * pszValueName, LPBYTE pData,
                                                 DWORD dwMaxSize, DWORD *dwType,
                                                 LPTSTR *lpGPOName, LPRSOPREGITEM lpItem)
{
    LPRSOPREGITEM lpTemp;
    BOOL bDeleted = FALSE;
    LPTSTR lpValueNameTemp = pszValueName;


    if (!lpItem)
    {
        lpTemp = m_pRSOPRegistryData;

        if (pszValueName)
        {
            INT iDelPrefixLen = lstrlen(szDELETEPREFIX);

            if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                               pszValueName, iDelPrefixLen,
                               szDELETEPREFIX, iDelPrefixLen) == CSTR_EQUAL)
            {
                lpValueNameTemp = pszValueName+iDelPrefixLen;
                bDeleted = TRUE;
            }
        }


        //
        // Find the item
        //

        while (lpTemp)
        {
            if (pszKeyName && lpValueNameTemp &&
                lpTemp->lpKeyName && lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
                            !lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                        {
                           break;
                        }
                    }
                }
            }
            else if (!pszKeyName && lpValueNameTemp &&
                     !lpTemp->lpKeyName && lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp))
                        {
                           break;
                        }
                    }
                }
            }
            else if (pszKeyName && !lpValueNameTemp &&
                     lpTemp->lpKeyName && !lpTemp->lpValueName)
            {
                if (bDeleted == lpTemp->bDeleted)
                {
                    if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                    {
                        if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                        {
                           break;
                        }
                    }
                }
            }

            lpTemp = lpTemp->pNext;
        }

    }
    else
    {

        //
        // Read a specific item
        //

        lpTemp = lpItem;
    }


    //
    // Exit now if the item wasn't found
    //

    if (!lpTemp)
    {
        return ERROR_FILE_NOT_FOUND;
    }


    //
    // Check if the data will fit in the buffer passed in
    //

    if (lpTemp->dwSize > dwMaxSize)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::ReadRSOPRegistryValue: The returned data size of %d is greater than the buffer size passed in of %d for %s\\%s"),
                  lpTemp->dwSize, dwMaxSize, pszKeyName, pszValueName));
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Copy the data
    //

    if (lpTemp->lpData)
    {
        CopyMemory (pData, lpTemp->lpData, lpTemp->dwSize);
    }

    *dwType = lpTemp->dwType;

    if (lpGPOName)
    {
        *lpGPOName = lpTemp->lpGPOName;
    }

    return ERROR_SUCCESS;
}


//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::EnumRSOPRegistryValues(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                  TCHAR * pszValueName, DWORD dwMaxSize,
                                                  LPRSOPREGITEM *lpEnum)
{
    LPRSOPREGITEM lpTemp;
    HRESULT hr = S_OK;

    if (lpEnum && *lpEnum)
    {
        lpTemp = (*lpEnum)->pNext;
    }
    else
    {
        lpTemp = m_pRSOPRegistryData;
    }


    //
    // Find the next item
    //

    while (lpTemp)
    {
        if (!pszKeyName && !lpTemp->lpKeyName)
        {
            if (!lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    break;
                }
            }
        }
        else if (pszKeyName && lpTemp->lpKeyName)
        {
            if (!lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Exit now if an item wasn't found
    //

    if (!lpTemp)
    {
        *lpEnum = NULL;
        return ERROR_NO_MORE_ITEMS;
    }


    if (lpTemp->lpValueName)
    {

        //
        // Check if the value name will fit in the buffer passed in
        //

        if ((DWORD)(lstrlen(lpTemp->lpValueName) + 1) > dwMaxSize)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicyComponentData::EnumRSOPRegistryValues: The valuename buffer size is too small")));
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        hr = StringCchCopy (pszValueName, dwMaxSize, lpTemp->lpValueName);
        ASSERT(SUCCEEDED(hr));
    }
    else
    {
        *pszValueName = TEXT('\0');
    }


    //
    // Save the item pointer
    //

    *lpEnum = lpTemp;

    return ERROR_SUCCESS;
}

//
// Note:  the data in the uiPrecedence argument is really a UINT.  It's declared
// as a HKEY so the hkeyRoot variable that calls this method can be used for both
// GPE and RSOP mode.
//

UINT CPolicyComponentData::FindRSOPRegistryEntry(HKEY uiPrecedence, TCHAR * pszKeyName,
                                                  TCHAR * pszValueName, LPRSOPREGITEM *lpEnum)
{
    LPRSOPREGITEM lpTemp;
    BOOL bDeleted = FALSE;
    LPTSTR lpValueNameTemp = pszValueName;


    if (lpEnum && *lpEnum)
    {
        lpTemp = (*lpEnum)->pNext;
    }
    else
    {
        lpTemp = m_pRSOPRegistryData;
    }


    if (pszValueName)
    {
        INT iDelPrefixLen = lstrlen(szDELETEPREFIX);

        if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                           pszValueName, iDelPrefixLen,
                           szDELETEPREFIX, iDelPrefixLen) == CSTR_EQUAL)
        {
            lpValueNameTemp = pszValueName+iDelPrefixLen;
            bDeleted = TRUE;
        }
    }


    //
    // Find the next item
    //

    while (lpTemp)
    {
        if (pszKeyName && lpValueNameTemp &&
            lpTemp->lpKeyName && lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp) &&
                        !lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }
        else if (!pszKeyName && lpValueNameTemp &&
                 !lpTemp->lpKeyName && lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpValueName, lpValueNameTemp))
                    {
                       break;
                    }
                }
            }
        }
        else if (pszKeyName && !lpValueNameTemp &&
                 lpTemp->lpKeyName && !lpTemp->lpValueName)
        {
            if (bDeleted == lpTemp->bDeleted)
            {
                if ((uiPrecedence == 0) || (uiPrecedence == (HKEY)LongToHandle(lpTemp->uiPrecedence)))
                {
                    if (!lstrcmpi(lpTemp->lpKeyName, pszKeyName))
                    {
                       break;
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }


    //
    // Exit now if an item wasn't found
    //

    if (!lpTemp)
    {
        *lpEnum = NULL;
        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Save the item pointer
    //

    *lpEnum = lpTemp;

    return ERROR_SUCCESS;
}


VOID CPolicyComponentData::DumpRSOPRegistryData(void)
{
    LPRSOPREGITEM lpTemp;
    TCHAR szDebug[50];

    lpTemp = m_pRSOPRegistryData;

    if (m_bUserScope)
        OutputDebugString (TEXT("\n\nDump of RSOP user registry data\n"));
    else
        OutputDebugString (TEXT("\n\nDump of RSOP computer registry data\n"));

    while (lpTemp)
    {
        OutputDebugString (TEXT("\n\n"));

        if (lpTemp->lpKeyName)
            OutputDebugString (lpTemp->lpKeyName);
        else
            OutputDebugString (TEXT("NULL Key Name"));

        OutputDebugString (TEXT("\n"));

        if (lpTemp->lpValueName)
            OutputDebugString (lpTemp->lpValueName);
        else
            OutputDebugString (TEXT("NULL Value Name"));

        OutputDebugString (TEXT("\n"));

        if (lpTemp->dwType == REG_DWORD)
        {
            (void) StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT("REG_DWORD\n%d\n"), *((LPDWORD)lpTemp->lpData));
            OutputDebugString (szDebug);
        }

        else if (lpTemp->dwType == REG_SZ)
        {
            OutputDebugString (TEXT("REG_SZ\n"));

            if (lpTemp->lpData)
                OutputDebugString ((LPTSTR)lpTemp->lpData);

            OutputDebugString (TEXT("\n"));
        }

        else if (lpTemp->dwType == REG_EXPAND_SZ)
        {
            OutputDebugString (TEXT("REG_EXPAND_SZ\n"));

            if (lpTemp->lpData)
                OutputDebugString ((LPTSTR)lpTemp->lpData);

            OutputDebugString (TEXT("\n"));
        }

        else if (lpTemp->dwType == REG_BINARY)
        {
            OutputDebugString (TEXT("REG_BINARY\n"));
            OutputDebugString (TEXT("<Binary data not displayed>\n"));
        }

        else if (lpTemp->dwType == REG_NONE)
        {
            OutputDebugString (TEXT("REG_NONE\n"));
        }

        else
        {
            (void) StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT("Unknown type:  %d\n"), lpTemp->dwType);
            OutputDebugString (szDebug);
        }

        (void) StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT("Precedence:  %d\n"), lpTemp->uiPrecedence);
        OutputDebugString(szDebug);

        (void) StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT("Deleted:  %d\n"), lpTemp->bDeleted);
        OutputDebugString(szDebug);

        (void) StringCchPrintf (szDebug, ARRAYSIZE(szDebug), TEXT("bFoundInADM:  %d\n"), lpTemp->bFoundInADM);
        OutputDebugString(szDebug);

        OutputDebugString (TEXT("GPOName:  "));

        if (lpTemp->lpGPOName)
            OutputDebugString (lpTemp->lpGPOName);
        else
            OutputDebugString (TEXT("NULL GPO Name"));

        OutputDebugString (TEXT("\n"));

        lpTemp = lpTemp->pNext;
    }

    OutputDebugString (TEXT("\n\n"));
}

BOOL CPolicyComponentData::FindEntryInActionList(POLICY * pPolicy, ACTIONLIST * pActionList, LPTSTR lpKeyName, LPTSTR lpValueName)
{
    
    UINT uIndex;
    ACTION * pAction = NULL;
    TCHAR * pszKeyName = NULL;
    TCHAR * pszValueName = NULL;


    //
    // Loop through each of the entries to see if they match
    //

    pAction = &pActionList->Action[0];
    for (uIndex = 0; uIndex < pActionList->nActionItems; uIndex++)
    {

        if (uIndex == 0)
        {
            // already set up pAction
        }
        else
        {
            pAction = (ACTION *)(((LPBYTE)pActionList) + pAction->uOffsetNextAction);
        }

        //
        // Get the value and keynames
        //

        pszValueName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValueName);
        
        if (pAction->uOffsetKeyName)
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetKeyName);
        }
        else
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pPolicy) + pPolicy->uOffsetKeyName);
        }
        
        if (!lstrcmpi(pszKeyName, lpKeyName) && !lstrcmpi(pszValueName, lpValueName))  {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL CPolicyComponentData::FindEntryInTable(TABLEENTRY * pTable, LPTSTR lpKeyName, LPTSTR lpValueName)
{
    POLICY * pEntry = (POLICY *) pTable;


    if ((pEntry->dwType & ETYPE_POLICY) || (pEntry->dwType & ETYPE_SETTING))
    {
        if (!lstrcmpi(lpKeyName, GETKEYNAMEPTR(pEntry))) 
        {
            if ( (!(GETVALUENAMEPTR(pEntry)) || (!lstrcmpi(GETVALUENAMEPTR(pEntry), TEXT("")))) ) {
                if (pEntry->dwType & STYPE_LISTBOX) {
                    return TRUE;
                }
            }
            else if (!lstrcmpi(lpValueName, GETVALUENAMEPTR(pEntry)))
            {
                return TRUE;
            }
        }

        // look in the actionlists

        // actionslist can be at 3 places. under policy itself or under the dropdown lists below

        ACTIONLIST * pActionList;

        if (pEntry->dwType & ETYPE_POLICY) {
            if (pEntry->uOffsetActionList_On) {
                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pEntry->uOffsetActionList_On);

                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                    return TRUE;
            }

            if (pEntry->uOffsetActionList_Off) {
                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pEntry->uOffsetActionList_Off);

                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                    return TRUE;
            }
        }

        if (pEntry->dwType & ETYPE_SETTING) {
            SETTINGS * pSettings = (SETTINGS *)pTable;

            if (pSettings) {

                BYTE * pObjectData = GETOBJECTDATAPTR(pSettings);

                if (pObjectData) {

                    if ((pEntry->dwType & STYPE_MASK) == STYPE_CHECKBOX) {
                        if (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_On) {
                            pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_On));

                            if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                return TRUE;
                        }

                        if (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_Off) {
                            pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + (((CHECKBOXINFO *)pObjectData)->uOffsetActionList_Off));

                            if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                return TRUE;
                        }
                    }

                    if ((pEntry->dwType & STYPE_MASK) == STYPE_DROPDOWNLIST) {
                        DROPDOWNINFO * pddi;
    
                        pddi = (DROPDOWNINFO *)  pObjectData;
    
                        while (pddi) {
                            if (pddi->uOffsetActionList) {
                                pActionList = (ACTIONLIST *)(((LPBYTE)pEntry) + pddi->uOffsetActionList);
                                if (FindEntryInActionList(pEntry, pActionList, lpKeyName, lpValueName)) 
                                    return TRUE;
    
                            }

                            if (pddi->uOffsetNextDropdowninfo) {
                                pddi = (DROPDOWNINFO *) ( (BYTE *) pEntry + pddi->uOffsetNextDropdowninfo);
                            }
                            else {
                                pddi = NULL;
                            }
                        }
                    }
                }
            }

        }
    }

    if (pEntry->pChild)
    {
        if (FindEntryInTable(pEntry->pChild, lpKeyName, lpValueName))
        {
            return TRUE;
        }
    }

    if (pEntry->pNext)
    {
        if (FindEntryInTable(pEntry->pNext, lpKeyName, lpValueName))
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID CPolicyComponentData::AddEntryToList (TABLEENTRY *pItem)
{
    TABLEENTRY *lpTemp;


    lpTemp = m_pExtraSettingsRoot->pChild;


    if (!lpTemp)
    {
        m_pExtraSettingsRoot->pChild = pItem;
        return;
    }


    while (lpTemp->pNext)
    {
        lpTemp = lpTemp->pNext;
    }

    lpTemp->pNext = pItem;
    pItem->pPrev = lpTemp;

}

VOID CPolicyComponentData::InitializeExtraSettings (VOID)
{
    LPRSOPREGITEM lpTemp;
    TCHAR szValueStr[MAX_PATH];
    HRESULT hr = S_OK;

    lpTemp = m_pRSOPRegistryData;

    while (lpTemp)
    {
        //
        // Build REGITEM structures for every registry entry that has a precedence of 1
        // and that is not found in any adm file
        //

        if ((lpTemp->uiPrecedence == 1) && (lpTemp->dwType != REG_NONE) && (!lpTemp->bDeleted))
        {
            DWORD dwBufSize = 0;
            REGITEM *pTmp, *pItem;
            LPTSTR lpName;

            //
            // Check to see if this registry entry is used by any adm policy / part
            //


            if (m_bUserScope)
            {
                if (m_pUserCategoryList)
                {
                    lpTemp->bFoundInADM = FindEntryInTable(m_pUserCategoryList,
                                                           lpTemp->lpKeyName,
                                                           lpTemp->lpValueName);
                }
            }
            else
            {
                if (m_pMachineCategoryList)
                {
                    lpTemp->bFoundInADM = FindEntryInTable(m_pMachineCategoryList,
                                                           lpTemp->lpKeyName,
                                                           lpTemp->lpValueName);
                }
            }


            if (!lpTemp->bFoundInADM)
            {
                
                //
                // Build regitem entry
                //

                pItem = (REGITEM *) GlobalAlloc(GPTR, sizeof(REGITEM));

                if (pItem)
                {

                    pItem->dwSize = sizeof(REGITEM);
                    pItem->dwType = ETYPE_REGITEM;
                    pItem->lpItem = lpTemp;


                    dwBufSize += lstrlen (lpTemp->lpKeyName) + 1;

                    if (lpTemp->lpValueName && *lpTemp->lpValueName)
                    {
                        dwBufSize += lstrlen (lpTemp->lpValueName) + 1;
                    }

                    lpName = (LPTSTR) LocalAlloc (LPTR, dwBufSize * sizeof(TCHAR));

                    if (lpName)
                    {
                        hr = StringCchCopy (lpName, dwBufSize, lpTemp->lpKeyName);
                        ASSERT(SUCCEEDED(hr));

                        if (lpTemp->lpValueName && *lpTemp->lpValueName)
                        {
                            hr = StringCchCat (lpName, dwBufSize, TEXT("\\"));
                            ASSERT(SUCCEEDED(hr));
                            
                            hr = StringCchCat (lpName, dwBufSize, lpTemp->lpValueName);
                            ASSERT(SUCCEEDED(hr));
                        }

                        //
                        // Add the display name
                        //

                        pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                            (BYTE *)lpName,(lstrlen(lpName)+1) * sizeof(TCHAR),&(pItem->uOffsetName),
                            &dwBufSize);

                        if (pTmp)
                        {
                            pItem = pTmp;

                            //
                            // Add the keyname
                            //

                            pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                                (BYTE *)lpTemp->lpKeyName,(lstrlen(lpTemp->lpKeyName)+1) * sizeof(TCHAR),&(pItem->uOffsetKeyName),
                                &dwBufSize);

                            if (pTmp)
                            {
                                pItem = pTmp;


                                szValueStr[0] = TEXT('\0');

                                if (lpTemp->dwType == REG_DWORD)
                                {
                                    hr = StringCchPrintf (szValueStr, ARRAYSIZE(szValueStr), TEXT("%d"), (DWORD) *((LPDWORD)lpTemp->lpData));
                                    ASSERT(SUCCEEDED(hr));
                                }

                                else if (lpTemp->dwType == REG_SZ)
                                {
                                    lstrcpyn (szValueStr, (LPTSTR)lpTemp->lpData, ARRAYSIZE(szValueStr));
                                }

                                else if (lpTemp->dwType == REG_EXPAND_SZ)
                                {
                                    lstrcpyn (szValueStr, (LPTSTR)lpTemp->lpData, ARRAYSIZE(szValueStr));
                                }

                                else if (lpTemp->dwType == REG_BINARY)
                                {
                                    LoadString(g_hInstance, IDS_BINARYDATA, szValueStr, ARRAYSIZE(szValueStr));
                                }

                                else
                                {
                                    LoadString(g_hInstance, IDS_UNKNOWNDATA, szValueStr, ARRAYSIZE(szValueStr));
                                }


                                //
                                // Add the value in string format
                                //

                                pTmp = (REGITEM *) AddDataToEntry((TABLEENTRY *)pItem,
                                    (BYTE *)szValueStr,(lstrlen(szValueStr)+1) * sizeof(TCHAR),&(pItem->uOffsetValueStr),
                                    &dwBufSize);

                                if (pTmp)
                                {
                                    pItem = pTmp;



                                    //
                                    // Check if this is a real policy
                                    //

                                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                                      lpTemp->lpKeyName, m_iSWPoliciesLen,
                                                      SOFTWARE_POLICIES, m_iSWPoliciesLen) == CSTR_EQUAL)
                                    {
                                        pItem->bTruePolicy = TRUE;
                                    }

                                    else if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                                      lpTemp->lpKeyName, m_iWinPoliciesLen,
                                                      WINDOWS_POLICIES, m_iWinPoliciesLen) == CSTR_EQUAL)
                                    {
                                        pItem->bTruePolicy = TRUE;
                                    }

                                    AddEntryToList ((TABLEENTRY *)pItem);
                                }
                                else
                                {
                                    GlobalFree (pItem);
                                }
                            }
                            else
                            {
                                GlobalFree (pItem);
                            }
                        }
                        else
                        {
                            GlobalFree (pItem);
                        }

                        LocalFree (lpName);
                    }
                    else
                    {
                         GlobalFree (pItem);
                    }
                }
            }
        }

        lpTemp = lpTemp->pNext;
    }
}

BOOL CPolicyComponentData::DoesNodeExist (LPSUPPORTEDENTRY *pList, LPTSTR lpString)
{
    LPSUPPORTEDENTRY lpItem;

    if (!(*pList))
    {
        return FALSE;
    }

    lpItem = *pList;

    while (lpItem)
    {
        if (!lstrcmpi(lpItem->lpString, lpString))
        {
            return TRUE;
        }

        lpItem = lpItem->pNext;
    }

    return FALSE;
}

BOOL CPolicyComponentData::CheckSupportedFilter (POLICY *pPolicy)
{
    LPSUPPORTEDENTRY lpItem = m_pSupportedStrings;
    LPTSTR lpString = GETSUPPORTEDPTR(pPolicy);


    if (!lpItem || !m_bUseSupportedOnFilter)
    {
        return TRUE;
    }

    while (lpItem)
    {
        if (!lpString)
        {
            if (lpItem->bNull)
            {
                return lpItem->bEnabled;
            }
        }
        else
        {
            if (!lstrcmpi(lpItem->lpString, lpString))
            {
                return lpItem->bEnabled;
            }
        }

        lpItem = lpItem->pNext;
    }

    return TRUE;
}

BOOL CPolicyComponentData::IsAnyPolicyAllowedPastFilter(TABLEENTRY * pCategory)
{
    TABLEENTRY * pEntry;
    INT iState;

    if (!pCategory || !pCategory->pChild)
    {
        return FALSE;
    }

    pEntry = pCategory->pChild;

    while (pEntry)
    {
        if (pEntry->dwType & ETYPE_CATEGORY)
        {
            if (IsAnyPolicyAllowedPastFilter(pEntry))
            {
                return TRUE;
            }
        }
        else if (pEntry->dwType & ETYPE_POLICY)
        {
            if (CheckSupportedFilter((POLICY *) pEntry))
            {
                return TRUE;
            }
        }

        pEntry = pEntry->pNext;
    }

    return FALSE;
}


VOID CPolicyComponentData::AddSupportedNode (LPSUPPORTEDENTRY *pList, LPTSTR lpString,
                                             BOOL bNull)
{
    LPSUPPORTEDENTRY lpItem;
    DWORD dwSize;

    
    //
    // Check if this item is already in the link list first
    //

    if (DoesNodeExist (pList, lpString))
    {
        return;
    }


    //
    // Add it to the list
    //

    dwSize = sizeof(SUPPORTEDENTRY);
    dwSize += ((lstrlen(lpString) + 1) * sizeof(TCHAR));

    lpItem = (LPSUPPORTEDENTRY) LocalAlloc (LPTR, dwSize);

    if (!lpItem)
    {
        return;
    }

    lpItem->lpString = (LPTSTR)(((LPBYTE)lpItem) + sizeof(SUPPORTEDENTRY));
    (void) StringCchCopy (lpItem->lpString, lstrlen(lpString) + 1, lpString);

    lpItem->bEnabled = TRUE;
    lpItem->bNull = bNull;

    lpItem->pNext = *pList;
    *pList = lpItem;
}

VOID CPolicyComponentData::FreeSupportedData(LPSUPPORTEDENTRY lpList)
{
    LPSUPPORTEDENTRY lpTemp;


    do {
        lpTemp = lpList->pNext;
        LocalFree (lpList);
        lpList = lpTemp;

    } while (lpTemp);
}

VOID CPolicyComponentData::InitializeSupportInfo(TABLEENTRY * pTable, LPSUPPORTEDENTRY *pList)
{
    POLICY * pEntry = (POLICY *) pTable;
    LPTSTR lpString;


    if (pEntry->dwType & ETYPE_POLICY)
    {
        lpString = GETSUPPORTEDPTR(pEntry);

        if (lpString)
        {
            AddSupportedNode (pList, lpString, FALSE);
        }
    }

    if (pEntry->pChild)
    {
        InitializeSupportInfo(pEntry->pChild, pList);
    }

    if (pEntry->pNext)
    {
        InitializeSupportInfo(pEntry->pNext, pList);
    }

}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicyComponentDataCF::CPolicyComponentDataCF(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_bUser = bUser;
    m_bRSOP = bRSOP;
}

CPolicyComponentDataCF::~CPolicyComponentDataCF()
{
    InterlockedDecrement(&g_cRefThisDll);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP_(ULONG)
CPolicyComponentDataCF::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG)
CPolicyComponentDataCF::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP
CPolicyComponentDataCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object implementation (IClassFactory)                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CPolicyComponentDataCF::CreateInstance(LPUNKNOWN   pUnkOuter,
                             REFIID      riid,
                             LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    CPolicyComponentData *pComponentData = new CPolicyComponentData(m_bUser, m_bRSOP); // ref count == 1

    if (!pComponentData)
        return E_OUTOFMEMORY;

    HRESULT hr = pComponentData->QueryInterface(riid, ppvObj);
    pComponentData->Release();                       // release initial ref

    return hr;
}


STDMETHODIMP
CPolicyComponentDataCF::LockServer(BOOL fLock)
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Class factory object creation (IClassFactory)                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CreatePolicyComponentDataClassFactory (REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;

    //
    // Admin Templates in editing mode
    //

    if (IsEqualCLSID (rclsid, CLSID_PolicySnapInMachine)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(FALSE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_PolicySnapInUser)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(TRUE, FALSE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    //
    // Admin Templates in RSOP mode
    //

    if (IsEqualCLSID (rclsid, CLSID_RSOPolicySnapInMachine)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(FALSE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }

    if (IsEqualCLSID (rclsid, CLSID_RSOPolicySnapInUser)) {

        CPolicyComponentDataCF *pComponentDataCF = new CPolicyComponentDataCF(TRUE, TRUE);   // ref == 1

        if (!pComponentDataCF)
            return E_OUTOFMEMORY;

        hr = pComponentDataCF->QueryInterface(riid, ppv);

        pComponentDataCF->Release();     // release initial ref

        return hr;
    }


    return CLASS_E_CLASSNOTAVAILABLE;
}



unsigned int CPolicySnapIn::m_cfNodeType = RegisterClipboardFormat(CCF_NODETYPE);

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CPolicySnapIn::CPolicySnapIn(CPolicyComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;

    m_pConsole = NULL;
    m_pResult = NULL;
    m_pHeader = NULL;
    m_pConsoleVerb = NULL;
    m_pDisplayHelp = NULL;
    m_nColumn1Size = 350;
    m_nColumn2Size = 100;
    m_nColumn3Size = 200;
    m_lViewMode = LVS_REPORT;

    if (m_pcd->m_bRSOP)
    {
        m_bPolicyOnly = FALSE;
    }
    else
    {
        m_bPolicyOnly = TRUE;
    }

    m_dwPolicyOnlyPolicy = 2;
    m_hMsgWindow = NULL;
    m_uiRefreshMsg = RegisterWindowMessage (TEXT("ADM Template Reload"));
    m_pCurrentPolicy = NULL;
    m_hPropDlg = NULL;

    LoadString(g_hInstance, IDS_NAME, m_pName, ARRAYSIZE(m_pName));
    LoadString(g_hInstance, IDS_STATE, m_pState, ARRAYSIZE(m_pState));
    LoadString(g_hInstance, IDS_SETTING, m_pSetting, ARRAYSIZE(m_pSetting));
    LoadString(g_hInstance, IDS_GPONAME, m_pGPOName, ARRAYSIZE(m_pGPOName));
    LoadString(g_hInstance, IDS_MULTIPLEGPOS, m_pMultipleGPOs, ARRAYSIZE(m_pMultipleGPOs));

    LoadString(g_hInstance, IDS_ENABLED, m_pEnabled, ARRAYSIZE(m_pEnabled));
    LoadString(g_hInstance, IDS_DISABLED, m_pDisabled, ARRAYSIZE(m_pDisabled));
    LoadString(g_hInstance, IDS_NOTCONFIGURED, m_pNotConfigured, ARRAYSIZE(m_pNotConfigured));
}

CPolicySnapIn::~CPolicySnapIn()
{
    InterlockedDecrement(&g_cRefThisDll);

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IUnknown)                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicySnapIn::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponent) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendContextMenu))
    {
        *ppv = (LPEXTENDCONTEXTMENU)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    {
        *ppv = (LPEXTENDPROPERTYSHEET)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicySnapIn::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicySnapIn::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IComponent)                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::Initialize(LPCONSOLE lpConsole)
{
    HRESULT   hr;
    WNDCLASS  wc;
    HKEY hKey;
    DWORD dwSize, dwType;

    // Save the IConsole pointer
    m_pConsole = lpConsole;
    m_pConsole->AddRef();

    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IDisplayHelp,
                        reinterpret_cast<void**>(&m_pDisplayHelp));


    ZeroMemory (&wc, sizeof(wc));
    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wc.lpfnWndProc   = ClipWndProc;
    wc.cbWndExtra    = sizeof(DWORD);
    wc.hInstance     = (HINSTANCE) g_hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = TEXT("ClipClass");

    if (!RegisterClass(&wc))
    {
        if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: RegisterClass for clipclass failed with %d."),
                     GetLastError()));
            return E_FAIL;
        }
    }


    ZeroMemory (&wc, sizeof(wc));
    wc.lpfnWndProc   = MessageWndProc;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = (HINSTANCE) g_hInstance;
    wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName = TEXT("GPMessageWindowClass");

    if (!RegisterClass(&wc))
    {
        if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: RegisterClass for message window class failed with %d."),
                     GetLastError()));
            return E_FAIL;
        }
    }

    m_hMsgWindow = CreateWindow (TEXT("GPMessageWindowClass"), TEXT("GP Hidden Message Window"),
                                 WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, 0, 0, NULL, NULL, NULL,
                                 (LPVOID) this);
    if (!m_hMsgWindow)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::Initialize: CreateWindow failed with %d."),
                 GetLastError()));
        return E_FAIL;
    }

    //
    // Load the user's options
    //

    if (RegOpenKeyEx (HKEY_CURRENT_USER, GPE_POLICIES_KEY, 0,
                      KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(m_dwPolicyOnlyPolicy);
        RegQueryValueEx (hKey, POLICYONLY_VALUE, NULL, &dwType,
                         (LPBYTE) &m_dwPolicyOnlyPolicy, &dwSize);

        RegCloseKey (hKey);
    }

    if (m_dwPolicyOnlyPolicy == 0)
    {
        m_bPolicyOnly = FALSE;
    }
    else if (m_dwPolicyOnlyPolicy == 1)
    {
        m_bPolicyOnly = TRUE;
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::Destroy(MMC_COOKIE cookie)
{

    DestroyWindow (m_hMsgWindow);

    if (m_pConsole != NULL)
    {
        m_pConsole->SetHeader(NULL);
        m_pConsole->Release();
        m_pConsole = NULL;
    }

    if (m_pHeader != NULL)
    {
        m_pHeader->Release();
        m_pHeader = NULL;
    }
    if (m_pResult != NULL)
    {
        m_pResult->Release();
        m_pResult = NULL;
    }

    if (m_pConsoleVerb != NULL)
    {
        m_pConsoleVerb->Release();
        m_pConsoleVerb = NULL;
    }

    if (m_pDisplayHelp != NULL)
    {
        m_pDisplayHelp->Release();
        m_pDisplayHelp = NULL;
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
   
    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;

    case MMCN_DBLCLICK:
        hr = S_FALSE;
        break;

    case MMCN_ADD_IMAGES:
        HBITMAP hbmp16x16;
        HBITMAP hbmp32x32;


        hbmp16x16 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

        if (hbmp16x16)
        {
            hbmp32x32 = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_32x32));

            if (hbmp32x32)
            {
                LPIMAGELIST pImageList = (LPIMAGELIST) arg;

                // Set the images
                pImageList->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(hbmp16x16),
                                                  reinterpret_cast<LONG_PTR *>(hbmp32x32),
                                                  0, RGB(255, 0, 255));

                DeleteObject(hbmp32x32);
            }

            DeleteObject(hbmp16x16);
        }
        break;

    case MMCN_SHOW:
        if (arg == TRUE)
        {
            RESULTDATAITEM resultItem;
            LPPOLICYDATAOBJECT pPolicyDataObject;
            TABLEENTRY * pNode, *pTemp = NULL;
            MMC_COOKIE cookie;
            INT i, iState;
            BOOL bAdd;

            //
            // Get the cookie of the scope pane item
            //

            hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

            if (FAILED(hr))
                return S_OK;

            hr = pPolicyDataObject->GetCookie(&cookie);

            pPolicyDataObject->Release();     // release initial ref
            if (FAILED(hr))
                return S_OK;

            pNode = (TABLEENTRY *)cookie;

            if (pNode)
            {
                pTemp = pNode->pChild;
            }

            //
            // Prepare the view
            //

            m_pHeader->InsertColumn(0, m_pSetting, LVCFMT_LEFT, m_nColumn1Size);
            m_pHeader->InsertColumn(1, m_pState, LVCFMT_CENTER, m_nColumn2Size);

            if (m_pcd->m_bRSOP)
            {
                m_pHeader->InsertColumn(2, m_pGPOName, LVCFMT_CENTER, m_nColumn3Size);
            }

            m_pResult->SetViewMode(m_lViewMode);



            //
            // Add the Policies
            //

            while (pTemp)
            {
                if (pTemp->dwType == ETYPE_POLICY)
                {
                    bAdd = TRUE;

                    if (m_pcd->m_bUseSupportedOnFilter)
                    {
                        bAdd = m_pcd->CheckSupportedFilter((POLICY *)pTemp);
                    }

                    if (bAdd && m_pcd->m_bShowConfigPoliciesOnly)
                    {
                        iState = GetPolicyState(pTemp, 1, NULL);

                        if (iState == -1)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (bAdd && m_bPolicyOnly)
                    {
                        if (((POLICY *) pTemp)->bTruePolicy != TRUE)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (bAdd)
                    {
                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;

                        if (((POLICY *) pTemp)->bTruePolicy)
                        {
                            resultItem.nImage = 4;
                        }
                        else
                        {
                            resultItem.nImage = 5;
                        }

                        resultItem.nCol = 0;
                        resultItem.lParam = (LPARAM) pTemp;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            resultItem.mask = RDI_STR;
                            resultItem.str = MMC_CALLBACK;
                            resultItem.bScopeItem = FALSE;
                            resultItem.nCol = 1;

                            m_pResult->SetItem(&resultItem);
                        }
                    }
                }

                else if (pTemp->dwType == ETYPE_REGITEM)
                {
                    bAdd = TRUE;

                    if (m_bPolicyOnly)
                    {
                        if (((REGITEM *) pTemp)->bTruePolicy != TRUE)
                        {
                            bAdd = FALSE;
                        }
                    }

                    if (((REGITEM *) pTemp)->lpItem->bFoundInADM == TRUE)
                    {
                        bAdd = FALSE;
                    }


                    if (bAdd)
                    {
                        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
                        resultItem.str = MMC_CALLBACK;

                        if (((REGITEM *) pTemp)->bTruePolicy)
                        {
                            resultItem.nImage = 4;
                        }
                        else
                        {
                            resultItem.nImage = 5;
                        }

                        resultItem.nCol = 0;
                        resultItem.lParam = (LPARAM) pTemp;

                        if (SUCCEEDED(m_pResult->InsertItem(&resultItem)))
                        {
                            resultItem.mask = RDI_STR;
                            resultItem.str = MMC_CALLBACK;
                            resultItem.bScopeItem = FALSE;
                            resultItem.nCol = 1;

                            m_pResult->SetItem(&resultItem);
                        }
                    }
                }

                pTemp = pTemp->pNext;
            }

        }
        else
        {
            m_pHeader->GetColumnWidth(0, &m_nColumn1Size);
            m_pHeader->GetColumnWidth(1, &m_nColumn2Size);
            if (m_pcd->m_bRSOP)
            {
                m_pHeader->GetColumnWidth(2, &m_nColumn3Size);
            }
            m_pResult->GetViewMode(&m_lViewMode);
        }
        break;


    case MMCN_SELECT:
        {
        LPPOLICYDATAOBJECT pPolicyDataObject;
        DATA_OBJECT_TYPES type;
        MMC_COOKIE cookie;
        POLICY * pPolicy;

        //
        // See if this is one of our items.
        //

        hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

        if (FAILED(hr))
            break;

        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->GetCookie(&cookie);
        pPolicyDataObject->Release();


        if (m_pConsoleVerb)
        {

            //
            // Set the default verb to open
            //

            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);


            //
            // If this is a result pane item or the root of the namespace
            // nodes, enable the Properties menu item
            //

            if (type == CCT_RESULT)
            {
                if (HIWORD(arg))
                {
                    m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
                    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
                }
            }
        }

        if (m_hPropDlg && (type == CCT_RESULT) && HIWORD(arg))
        {
            pPolicy = (POLICY *)cookie;

            if (pPolicy->dwType & ETYPE_POLICY)
            {
                m_pCurrentPolicy = pPolicy;
                SendMessage (GetParent(m_hPropDlg), PSM_QUERYSIBLINGS, 1000, 0);
            }
        }

        }
        break;

    case MMCN_CONTEXTHELP:
        {

        if (m_pDisplayHelp)
        {
            LPPOLICYDATAOBJECT pPolicyDataObject;
            DATA_OBJECT_TYPES type;
            MMC_COOKIE cookie;
            LPOLESTR pszHelpTopic;


            //
            // See if this is one of our items.
            //

            hr = lpDataObject->QueryInterface(IID_IPolicyDataObject, (LPVOID *)&pPolicyDataObject);

            if (FAILED(hr))
                break;

            pPolicyDataObject->Release();


            //
            // Display the admin templates help page
            //

            DWORD dwHlpLen = 50;
            pszHelpTopic = (LPOLESTR) CoTaskMemAlloc (dwHlpLen * sizeof(WCHAR));

            if (pszHelpTopic)
            {
                hr = StringCchCopy (pszHelpTopic, dwHlpLen, TEXT("gpedit.chm::/adm.htm"));
                ASSERT(SUCCEEDED(hr));
                m_pDisplayHelp->ShowTopic (pszHelpTopic);
            }
        }

        }
        break;

    default:
        hr = E_UNEXPECTED;
        break;
    }

    return hr;
}

STDMETHODIMP CPolicySnapIn::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    if (pResult)
    {
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                if (pResult->nCol == 0)
                {
                    if (pResult->lParam == 0)
                    {
                        pResult->str = m_pcd->m_szRootName;
                    }
                    else
                    {
                        TABLEENTRY * pTableEntry;

                        pTableEntry = (TABLEENTRY *)(pResult->lParam);
                        pResult->str = GETNAMEPTR(pTableEntry);
                    }
                }
                else
                {
                    pResult->str = L"";
                }
            }

            if (pResult->mask & RDI_IMAGE)
            {
                pResult->nImage = 0;
            }
        }
        else
        {
            if (pResult->mask & RDI_STR)
            {
                TABLEENTRY * pTableEntry;
                INT iState;
                LPTSTR lpGPOName = NULL;

                pTableEntry = (TABLEENTRY *)(pResult->lParam);


                if (pTableEntry->dwType & ETYPE_REGITEM)
                {
                    REGITEM *pItem = (REGITEM*)pTableEntry;

                    if (pResult->nCol == 0)
                    {
                        pResult->str = GETNAMEPTR(pTableEntry);

                        if (pResult->str == NULL)
                        {
                            pResult->str = (LPOLESTR)L"";
                        }
                    }
                    else if (pResult->nCol == 1)
                    {
                        pResult->str = GETVALUESTRPTR(pItem);
                    }
                    else if (pResult->nCol == 2)
                    {
                        pResult->str = pItem->lpItem->lpGPOName;
                    }
                }
                else
                {
                    iState = GetPolicyState (pTableEntry, 1, &lpGPOName);


                    if (pResult->nCol == 0)
                    {
                        pResult->str = GETNAMEPTR(pTableEntry);

                        if (pResult->str == NULL)
                        {
                            pResult->str = (LPOLESTR)L"";
                        }
                    }
                    else if (pResult->nCol == 1)
                    {
                        if (iState == 1)
                        {
                            pResult->str = m_pEnabled;
                        }
                        else if (iState == 0)
                        {
                            pResult->str = m_pDisabled;
                        }
                        else
                        {
                            pResult->str = m_pNotConfigured;
                        }
                    }
                    else if (pResult->nCol == 2)
                    {
                        pResult->str = lpGPOName;
                    }
                }
            }
        }
    }

    return S_OK;
}

STDMETHODIMP CPolicySnapIn::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    return m_pcd->QueryDataObject(cookie, type, ppDataObject);
}


STDMETHODIMP CPolicySnapIn::GetResultViewType(MMC_COOKIE cookie, LPOLESTR *ppViewType,
                                        long *pViewOptions)
{
    return S_FALSE;
}

STDMETHODIMP CPolicySnapIn::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPPOLICYDATAOBJECT pPolicyDataObjectA, pPolicyDataObjectB;
    MMC_COOKIE cookie1, cookie2;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObjectB)))
    {
        pPolicyDataObjectA->Release();
        return S_FALSE;
    }

    pPolicyDataObjectA->GetCookie(&cookie1);
    pPolicyDataObjectB->GetCookie(&cookie2);

    if (cookie1 == cookie2)
    {
        hr = S_OK;
    }


    pPolicyDataObjectA->Release();
    pPolicyDataObjectB->Release();

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn:: object implementation (IExtendContextMenu)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::AddMenuItems(LPDATAOBJECT piDataObject,
                                          LPCONTEXTMENUCALLBACK pCallback,
                                          LONG *pInsertionAllowed)
{
    HRESULT hr = S_OK;
    TCHAR szMenuItem[100];
    TCHAR szDescription[250];
    CONTEXTMENUITEM item;
    LPPOLICYDATAOBJECT pPolicyDataObject;
    DATA_OBJECT_TYPES type = CCT_UNINITIALIZED;
    MMC_COOKIE cookie;
    POLICY *pPolicy;


    if (SUCCEEDED(piDataObject->QueryInterface(IID_IPolicyDataObject,
                 (LPVOID *)&pPolicyDataObject)))
    {
        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->GetCookie(&cookie);
        pPolicyDataObject->Release();
    }


    if (type == CCT_SCOPE)
    {
        pPolicy = (POLICY *)cookie;

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
        {

            if (!m_pcd->m_bRSOP)
            {
                LoadString (g_hInstance, IDS_FILTERING, szMenuItem, 100);
                LoadString (g_hInstance, IDS_FILTERINGDESC, szDescription, 250);

                item.strName = szMenuItem;
                item.strStatusBarText = szDescription;
                item.lCommandID = IDM_FILTERING;
                item.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
                item.fFlags = 0;
                item.fSpecialFlags = 0;

                hr = pCallback->AddItem(&item);
            }
        }
    }

    return (hr);
}

STDMETHODIMP CPolicySnapIn::Command(LONG lCommandID, LPDATAOBJECT piDataObject)
{

    if (lCommandID == IDM_FILTERING)
    {
        if (DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_POLICY_FILTERING),
                           m_pcd->m_hwndFrame, FilterDlgProc,(LPARAM) this))
        {
            //
            // Refresh the display
            //

            m_pcd->m_pScope->DeleteItem (m_pcd->m_hSWPolicies, FALSE);
            m_pcd->EnumerateScopePane (NULL, m_pcd->m_hSWPolicies);
        }
    }

    return S_OK;

}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (IExtendPropertySheet)                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CPolicySnapIn::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                             LONG_PTR handle, LPDATAOBJECT lpDataObject)

{
    HRESULT hr;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage[3];
    LPPOLICYDATAOBJECT pPolicyDataObject;
    MMC_COOKIE cookie;
    LPSETTINGSINFO lpSettingsInfo;


    //
    // Make sure this is one of our objects
    //

    if (FAILED(lpDataObject->QueryInterface(IID_IPolicyDataObject,
                                            (LPVOID *)&pPolicyDataObject)))
    {
        return S_OK;
    }


    //
    // Get the cookie
    //

    pPolicyDataObject->GetCookie(&cookie);
    pPolicyDataObject->Release();


    m_pCurrentPolicy = (POLICY *)cookie;


    //
    // Allocate a settings info structure
    //

    lpSettingsInfo = (LPSETTINGSINFO) LocalAlloc(LPTR, sizeof(SETTINGSINFO));

    if (!lpSettingsInfo)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        return S_OK;
    }

    lpSettingsInfo->pCS = this;


    //
    // Allocate a POLICYDLGINFO structure
    //

    lpSettingsInfo->pdi = (POLICYDLGINFO *) LocalAlloc(LPTR,sizeof(POLICYDLGINFO));

    if (!lpSettingsInfo->pdi)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        LocalFree (lpSettingsInfo);
        return S_OK;
    }


    //
    // Initialize POLICYDLGINFO
    //

    lpSettingsInfo->pdi->dwControlTableSize = DEF_CONTROLS * sizeof(POLICYCTRLINFO);
    lpSettingsInfo->pdi->nControls = 0;
    lpSettingsInfo->pdi->pEntryRoot = (lpSettingsInfo->pCS->m_pcd->m_bUserScope ?
            lpSettingsInfo->pCS->m_pcd->m_pUserCategoryList :
            lpSettingsInfo->pCS->m_pcd->m_pMachineCategoryList);
    lpSettingsInfo->pdi->hwndApp = lpSettingsInfo->pCS->m_pcd->m_hwndFrame;

    lpSettingsInfo->pdi->pControlTable = (POLICYCTRLINFO *) LocalAlloc(LPTR,
                                          lpSettingsInfo->pdi->dwControlTableSize);

    if (!lpSettingsInfo->pdi->pControlTable) {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to allocate memory with %d."),
                 GetLastError()));
        LocalFree (lpSettingsInfo->pdi);
        LocalFree (lpSettingsInfo);
        return S_OK;
    }


    //
    // Initialize the common fields in the property sheet structure
    //

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = 0;
    psp.hInstance = g_hInstance;
    psp.lParam = (LPARAM) lpSettingsInfo;


    //
    // Add the pages
    //

    if (m_pCurrentPolicy->dwType & ETYPE_REGITEM)
    {
        psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_PRECEDENCE);
        psp.pfnDlgProc = PolicyPrecedenceDlgProc;


        hPage[0] = CreatePropertySheetPage(&psp);

        if (hPage[0])
        {
            hr = lpProvider->AddPage(hPage[0]);
        }
    }
    else
    {

        psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY);
        psp.pfnDlgProc = PolicyDlgProc;


        hPage[0] = CreatePropertySheetPage(&psp);

        if (hPage[0])
        {
            hr = lpProvider->AddPage(hPage[0]);

            psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_HELP);
            psp.pfnDlgProc = PolicyHelpDlgProc;


            hPage[1] = CreatePropertySheetPage(&psp);

            if (hPage[1])
            {
                hr = lpProvider->AddPage(hPage[1]);

                if (m_pcd->m_bRSOP)
                {
                    psp.pszTemplate = MAKEINTRESOURCE(IDD_POLICY_PRECEDENCE);
                    psp.pfnDlgProc = PolicyPrecedenceDlgProc;


                    hPage[2] = CreatePropertySheetPage(&psp);

                    if (hPage[2])
                    {
                        hr = lpProvider->AddPage(hPage[2]);
                    }
                }
            }
            else
            {
                DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                         GetLastError()));
                hr = E_FAIL;
            }
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::CreatePropertyPages: Failed to create property sheet page with %d."),
                     GetLastError()));
            hr = E_FAIL;
        }
    }


    return (hr);
}

STDMETHODIMP CPolicySnapIn::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    LPPOLICYDATAOBJECT pPolicyDataObject;
    DATA_OBJECT_TYPES type;

    if (SUCCEEDED(lpDataObject->QueryInterface(IID_IPolicyDataObject,
                                               (LPVOID *)&pPolicyDataObject)))
    {
        pPolicyDataObject->GetType(&type);
        pPolicyDataObject->Release();

        if (type == CCT_RESULT)
        {
            if (!m_hPropDlg)
                return S_OK;
            // There's already a propety sheet open so we'll bring it to the front.
            BringWindowToTop(GetParent(m_hPropDlg));
        }
    }

    return S_FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicySnapIn object implementation (Internal functions)                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOL CPolicySnapIn::IsAnyPolicyEnabled(TABLEENTRY * pCategory)
{
    TABLEENTRY * pEntry;
    INT iState;

    if (!pCategory || !pCategory->pChild)
    {
        return FALSE;
    }

    pEntry = pCategory->pChild;

    while (pEntry)
    {
        if (pEntry->dwType & ETYPE_CATEGORY)
        {
            if (IsAnyPolicyEnabled(pEntry))
            {
                return TRUE;
            }
        }
        else if (pEntry->dwType & ETYPE_POLICY)
        {
            iState = GetPolicyState(pEntry, 1, NULL);

            if ((iState == 1) || (iState == 0))
            {
                return TRUE;
            }
        }

        pEntry = pEntry->pNext;
    }

    return FALSE;
}

VOID CPolicySnapIn::RefreshSettingsControls(HWND hDlg)
{
    BOOL fEnabled = FALSE;
    INT iState;
    LPTSTR lpSupported;
    POLICY *pPolicy = (POLICY *)m_pCurrentPolicy;

    FreeSettingsControls(hDlg);

    SetDlgItemText (hDlg, IDC_POLICY, GETNAMEPTR(m_pCurrentPolicy));

    if (pPolicy->bTruePolicy)
    {
        SendMessage (GetDlgItem(hDlg, IDC_POLICYICON), STM_SETIMAGE, IMAGE_ICON,
                     (LPARAM) (HANDLE) m_hPolicyIcon);
    }
    else
    {
        SendMessage (GetDlgItem(hDlg, IDC_POLICYICON), STM_SETIMAGE, IMAGE_ICON,
                     (LPARAM) (HANDLE) m_hPreferenceIcon);
    }

    lpSupported = GETSUPPORTEDPTR(pPolicy);

    if (lpSupported)
    {
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTEDTITLE), SW_SHOW);
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTED), SW_SHOW);
        SetDlgItemText (hDlg, IDC_SUPPORTED, lpSupported);
    }
    else
    {
        SetDlgItemText (hDlg, IDC_SUPPORTED, TEXT(""));
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTEDTITLE), SW_HIDE);
        ShowWindow (GetDlgItem(hDlg, IDC_SUPPORTED), SW_HIDE);
    }

    iState = GetPolicyState((TABLEENTRY *)m_pCurrentPolicy, 1, NULL);

    if (iState == 1)
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_ENABLED);
        fEnabled = TRUE;
    }
    else if (iState == 0)
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_DISABLED);
    }
    else
    {
        CheckRadioButton(hDlg, IDC_NOCONFIG, IDC_DISABLED, IDC_NOCONFIG);
    }

    if (m_pcd->m_bRSOP)
    {
        EnableWindow (GetDlgItem(hDlg, IDC_ENABLED), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_DISABLED), FALSE);
        EnableWindow (GetDlgItem(hDlg, IDC_NOCONFIG), FALSE);
    }

    if (m_pCurrentPolicy->pChild) {

        CreateSettingsControls(hDlg, (SETTINGS *) m_pCurrentPolicy->pChild, fEnabled);
        InitializeSettingsControls(hDlg, fEnabled);
    } else {
        ShowScrollBar(GetDlgItem(hDlg,IDC_POLICY_SETTINGS),SB_BOTH, FALSE);
    }

    m_bDirty = FALSE;
    PostMessage (GetParent(hDlg), PSM_UNCHANGED, (WPARAM) hDlg, 0);

    SetPrevNextButtonState(hDlg);
}

HRESULT CPolicySnapIn::UpdateItemWorker (VOID)
{
    HRESULTITEM hItem;

    //
    // Update the display
    //

    if (SUCCEEDED(m_pResult->FindItemByLParam((LPARAM)m_pCurrentPolicy, &hItem)))
    {
        if (m_pcd->m_bShowConfigPoliciesOnly)
            m_pResult->DeleteItem(hItem, 0);
        else
            m_pResult->UpdateItem(hItem);
    }

    return S_OK;
}

HRESULT CPolicySnapIn::MoveFocusWorker (BOOL bPrevious)
{
    HRESULTITEM hItem;
    TABLEENTRY * pTemp;
    HRESULT hr;
    RESULTDATAITEM item;
    INT iIndex = 0;



    //
    // Find the currently selected item's index
    //

    while (TRUE)
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = RDI_INDEX | RDI_PARAM;
        item.nIndex = iIndex;

        hr = m_pResult->GetItem (&item);

        if (FAILED(hr))
        {
            return hr;
        }

        if (item.lParam == (LPARAM) m_pCurrentPolicy)
        {
            break;
        }

        iIndex++;
    }


    //
    // Find the currently selected item's hItem
    //

    hr = m_pResult->FindItemByLParam((LPARAM)m_pCurrentPolicy, &hItem);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Remove the focus from the original item
    //

    m_pResult->ModifyItemState(0, hItem, 0, LVIS_FOCUSED | LVIS_SELECTED);
    m_pResult->UpdateItem(hItem);


    //
    // Adjust appropriately
    //

    if (bPrevious)
    {
        if (iIndex > 0)
        {
            iIndex--;
        }
    }
    else
    {
        iIndex++;
    }


    //
    // Get the lParam for the new item
    //

    ZeroMemory (&item, sizeof(item));
    item.mask = RDI_INDEX | RDI_PARAM;
    item.nIndex = iIndex;

    hr = m_pResult->GetItem(&item);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Find the hItem for the new item
    //

    hr = m_pResult->FindItemByLParam(item.lParam, &hItem);

    if (FAILED(hr))
    {
        return hr;
    }


    //
    // Save this as the currently selected item
    //

    m_pCurrentPolicy = (POLICY *)item.lParam;



    //
    // Set the focus on the new item
    //

    m_pResult->ModifyItemState(0, hItem, LVIS_FOCUSED | LVIS_SELECTED, 0);
    m_pResult->UpdateItem(hItem);


    return S_OK;
}

HRESULT CPolicySnapIn::MoveFocus (HWND hDlg, BOOL bPrevious)
{

    //
    // Send the move focus message to the hidden window on the main
    // thread so it can use the mmc interfaces
    //

    SendMessage (m_hMsgWindow, WM_MOVEFOCUS, (WPARAM) bPrevious, 0);


    //
    // Update the display
    //

    SendMessage (GetParent(hDlg), PSM_QUERYSIBLINGS, 1000, 0);


    return S_OK;
}


HRESULT CPolicySnapIn::SetPrevNextButtonStateWorker (HWND hDlg)
{

    TABLEENTRY * pTemp;
    HRESULT hr;
    RESULTDATAITEM item;
    INT iIndex = 0;
    BOOL bPrev = FALSE, bNext = FALSE, bFound = FALSE;


    //
    // Loop through the items looking for Policies
    //

    while (TRUE)
    {
        ZeroMemory (&item, sizeof(item));
        item.mask = RDI_INDEX | RDI_PARAM;
        item.nIndex = iIndex;

        hr = m_pResult->GetItem (&item);

        if (FAILED(hr))
        {
            break;
        }

        if (item.lParam == (LPARAM) m_pCurrentPolicy)
        {
            bFound = TRUE;
        }
        else
        {
            pTemp = (TABLEENTRY *) item.lParam;

            if ((pTemp->dwType & ETYPE_POLICY) || (pTemp->dwType & ETYPE_REGITEM))
            {
                if ((m_pcd->m_bShowConfigPoliciesOnly) && (pTemp->dwType & ETYPE_POLICY))
                {
                    INT iState;

                    iState = GetPolicyState(pTemp, 1, NULL);

                    if ((iState == 1) || (iState == 0))
                    {
                        if (bFound)
                        {
                            bNext = TRUE;
                        }
                        else
                        {
                            bPrev = TRUE;
                        }
                    }
                }
                else
                {
                    if (bFound)
                    {
                        bNext = TRUE;
                    }
                    else
                    {
                        bPrev = TRUE;
                    }
                }
            }
        }

        iIndex++;
    }


    if (!bNext && (GetFocus() == GetDlgItem(hDlg,IDC_POLICY_NEXT)))
    {
        SetFocus (GetNextDlgTabItem(hDlg, GetDlgItem(hDlg,IDC_POLICY_NEXT), TRUE));
    }

    EnableWindow (GetDlgItem(hDlg,IDC_POLICY_NEXT), bNext);


    if (!bPrev && (GetFocus() == GetDlgItem(hDlg,IDC_POLICY_PREVIOUS)))
    {
        SetFocus (GetNextDlgTabItem(hDlg, GetDlgItem(hDlg,IDC_POLICY_PREVIOUS), FALSE));
    }

    EnableWindow (GetDlgItem(hDlg,IDC_POLICY_PREVIOUS), bPrev);

    
    return S_OK;
}

HRESULT CPolicySnapIn::SetPrevNextButtonState (HWND hDlg)
{

    //
    // Send the SetPrevNext message to the hidden window on the main
    // thread so it can use the mmc interfaces
    //

    SendMessage (m_hMsgWindow, WM_SETPREVNEXT, (WPARAM) hDlg, 0);

    return S_OK;
}


INT_PTR CALLBACK CPolicySnapIn::PolicyDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    switch (message)
    {
    case WM_INITDIALOG:

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);

            lpSettingsInfo->pCS->m_hPropDlg = hDlg;

            lpSettingsInfo->pdi->fActive=TRUE;

            lpSettingsInfo->pCS->m_hPolicyIcon = (HICON) LoadImage (g_hInstance,
                                                               MAKEINTRESOURCE(IDI_POLICY2),
                                                               IMAGE_ICON, 16, 16,
                                                               LR_DEFAULTCOLOR);

            lpSettingsInfo->pCS->m_hPreferenceIcon = (HICON) LoadImage (g_hInstance,
                                                               MAKEINTRESOURCE(IDI_POLICY3),
                                                               IMAGE_ICON, 16, 16,
                                                               LR_DEFAULTCOLOR);

            // now that we've stored pointer to POLICYDLGINFO struct in our extra
            // window data, send WM_USER to clip window to tell it to create a
            // child container window (and store the handle in our POLICYDLGINFO)
            SendDlgItemMessage(hDlg,IDC_POLICY_SETTINGS,WM_USER,0,0L);

            lpSettingsInfo->pCS->RefreshSettingsControls(hDlg);

            lpSettingsInfo->pCS->SetKeyboardHook(hDlg);

            break;

        case WM_MYCHANGENOTIFY:
            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (lpSettingsInfo) {
                lpSettingsInfo->pCS->m_bDirty = TRUE;
                SendMessage (GetParent(hDlg), PSM_CHANGED, (WPARAM) hDlg, 0);
            }
            break;

        case PSM_QUERYSIBLINGS:
            if (wParam == 1000) {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }

                lpSettingsInfo->pCS->RefreshSettingsControls(hDlg);

                SendMessage (GetParent(hDlg), PSM_SETTITLE, PSH_PROPTITLE,
                             (LPARAM)GETNAMEPTR(lpSettingsInfo->pCS->m_pCurrentPolicy));
            }
            break;

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }


            if ((LOWORD (wParam) == IDC_NOCONFIG) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, FALSE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if ((LOWORD (wParam) == IDC_ENABLED) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, TRUE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if ((LOWORD (wParam) == IDC_DISABLED) && (HIWORD (wParam) == BN_CLICKED))
            {
                lpSettingsInfo->pCS->InitializeSettingsControls(hDlg, FALSE);
                PostMessage (hDlg, WM_MYCHANGENOTIFY, 0, 0);
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                if (SUCCEEDED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                {
                    lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
                }
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                if (SUCCEEDED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                {
                    lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
                }
            }

            break;

        case WM_NOTIFY:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                    {
                    LPPSHNOTIFY lpNotify = (LPPSHNOTIFY) lParam;

                    if (FAILED(lpSettingsInfo->pCS->SaveSettings(hDlg)))
                    {
                        SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }

                    if (lpNotify->lParam)
                    {
                        lpSettingsInfo->pCS->RemoveKeyboardHook();
                        lpSettingsInfo->pCS->m_hPropDlg = NULL;

                        lpSettingsInfo->pCS->FreeSettingsControls(hDlg);

                        DestroyIcon(lpSettingsInfo->pCS->m_hPolicyIcon);
                        lpSettingsInfo->pCS->m_hPolicyIcon = NULL;
                        DestroyIcon(lpSettingsInfo->pCS->m_hPreferenceIcon);
                        lpSettingsInfo->pCS->m_hPreferenceIcon = NULL;

                        LocalFree (lpSettingsInfo->pdi->pControlTable);
                        LocalFree (lpSettingsInfo->pdi);
                        LocalFree (lpSettingsInfo);
                        SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) NULL);
                    }

                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
                    }

            case PSN_RESET:
                    lpSettingsInfo->pCS->RemoveKeyboardHook();
                    lpSettingsInfo->pCS->m_hPropDlg = NULL;
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aPolicyHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aPolicyHelpIds);
            return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK CPolicySnapIn::PolicyHelpDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    switch (message)
    {
        case WM_INITDIALOG:

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);

            wParam = 1000;

            // fall through...

        case PSM_QUERYSIBLINGS:
        {
            CPolicySnapIn * pCS;
            LPTSTR lpHelpText;

            if (wParam == 1000)
            {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }


                pCS = lpSettingsInfo->pCS;
                SetDlgItemText (hDlg, IDC_POLICY_TITLE, GETNAMEPTR(pCS->m_pCurrentPolicy));

                if (pCS->m_pCurrentPolicy->uOffsetHelp)
                {
                    lpHelpText = (LPTSTR) ((BYTE *) pCS->m_pCurrentPolicy + pCS->m_pCurrentPolicy->uOffsetHelp);
                    SetDlgItemText (hDlg, IDC_POLICY_HELP, lpHelpText);
                }
                else
                {
                    SetDlgItemText (hDlg, IDC_POLICY_HELP, TEXT(""));
                }
                
                pCS->SetPrevNextButtonState(hDlg);
            }

            PostMessage(hDlg, WM_MYREFRESH, 0, 0);
            break;
        }

        case WM_MYREFRESH:
        {
            CPolicySnapIn * pCS;
            BOOL    bAlone;

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);
            pCS = lpSettingsInfo->pCS;

            SendMessage(GetDlgItem(hDlg, IDC_POLICY_HELP), EM_SETSEL, -1, 0);

            bAlone = !(((pCS->m_pCurrentPolicy)->pNext) ||
                        ((pCS->m_pCurrentPolicy)->pPrev) );
            
            if (bAlone) {
                SetFocus(GetDlgItem(GetParent(hDlg), IDOK));
            }
            break;
        }

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
            }

            if (LOWORD(wParam) == IDCANCEL)
            {
                SendMessage(GetParent(hDlg), message, wParam, lParam);
            }

            break;


        case WM_NOTIFY:

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
                case PSN_SETACTIVE:
                    PostMessage(hDlg, WM_MYREFRESH, 0, 0);
                break;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aExplainHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aExplainHelpIds);
            return TRUE;
    }

    return FALSE;
}

INT_PTR CALLBACK CPolicySnapIn::PolicyPrecedenceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;
    HRESULT hr = S_OK;

    switch (message)
    {
        case WM_INITDIALOG:
            {
            RECT rc;
            TCHAR szHeaderName[50];
            INT iTotal = 0, iCurrent;
            HWND hLV = GetDlgItem (hDlg, IDC_POLICY_PRECEDENCE);
            LV_COLUMN col;

            lpSettingsInfo = (LPSETTINGSINFO) (((LPPROPSHEETPAGE)lParam)->lParam);

            if (!lpSettingsInfo) {
                break;
            }

            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) lpSettingsInfo);


            //
            // Add the columns
            //

            GetClientRect (hLV, &rc);
            LoadString(g_hInstance, IDS_GPONAME, szHeaderName, ARRAYSIZE(szHeaderName));
            col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            col.fmt = LVCFMT_LEFT;
            iCurrent = (int)(rc.right * .70);
            iTotal += iCurrent;
            col.cx = iCurrent;
            col.pszText = szHeaderName;
            col.iSubItem = 0;

            ListView_InsertColumn (hLV, 0, &col);

            LoadString(g_hInstance, IDS_SETTING, szHeaderName, ARRAYSIZE(szHeaderName));
            col.iSubItem = 1;
            col.cx = rc.right - iTotal;
            col.fmt = LVCFMT_CENTER;
            ListView_InsertColumn (hLV, 1, &col);


            //
            // Set extended LV styles
            //

            SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                        LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


            }

            wParam = 1000;

            // fall through...

        case PSM_QUERYSIBLINGS:
        {
            CPolicySnapIn * pCS;
            INT iState;
            LPTSTR lpGPOName;
            UINT uiPrecedence = 1;
            LVITEM item;
            INT iItem, iIndex = 0;
            HWND hLV = GetDlgItem (hDlg, IDC_POLICY_PRECEDENCE);

            if (wParam == 1000)
            {
                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

                if (!lpSettingsInfo) {
                    break;
                }


                pCS = lpSettingsInfo->pCS;
                SetDlgItemText (hDlg, IDC_POLICY_TITLE, GETNAMEPTR(pCS->m_pCurrentPolicy));

                SendMessage (hLV, LVM_DELETEALLITEMS, 0, 0);

                if (pCS->m_pCurrentPolicy->dwType & ETYPE_REGITEM)
                {
                    LPRSOPREGITEM pItem = ((REGITEM*)pCS->m_pCurrentPolicy)->lpItem;
                    LPRSOPREGITEM lpEnum;
                    TCHAR szValueStr[MAX_PATH];


                    while (TRUE)
                    {
                        lpEnum = NULL;

                        if (pCS->m_pcd->FindRSOPRegistryEntry((HKEY) LongToHandle(uiPrecedence), pItem->lpKeyName,
                                                  pItem->lpValueName, &lpEnum) != ERROR_SUCCESS)
                        {
                            break;
                        }


                        //
                        // Add the GPO Name
                        //

                        item.mask = LVIF_TEXT | LVIF_STATE;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.state = 0;
                        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                        item.pszText = lpEnum->lpGPOName;

                        iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);


                        if (iItem != -1)
                        {
                            szValueStr[0] = TEXT('\0');

                            if (pItem->dwType == REG_DWORD)
                            {
                                hr = StringCchPrintf (szValueStr, ARRAYSIZE(szValueStr), TEXT("%d"), *((LPDWORD)pItem->lpData));
                                ASSERT(SUCCEEDED(hr));
                            }

                            else if (pItem->dwType == REG_SZ)
                            {
                                lstrcpyn (szValueStr, (LPTSTR)pItem->lpData, ARRAYSIZE(szValueStr));
                            }

                            else if (pItem->dwType == REG_EXPAND_SZ)
                            {
                                lstrcpyn (szValueStr, (LPTSTR)pItem->lpData, ARRAYSIZE(szValueStr));
                            }

                            else if (pItem->dwType == REG_BINARY)
                            {
                                LoadString(g_hInstance, IDS_BINARYDATA, szValueStr, ARRAYSIZE(szValueStr));
                            }

                            else
                            {
                                LoadString(g_hInstance, IDS_UNKNOWNDATA, szValueStr, ARRAYSIZE(szValueStr));
                            }


                            //
                            // Add the state
                            //

                            item.mask = LVIF_TEXT;
                            item.iItem = iItem;
                            item.iSubItem = 1;
                            item.pszText = szValueStr;

                            SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                        }

                        uiPrecedence++;
                        iIndex++;
                    }

                }
                else
                {
                    while (TRUE)
                    {
                        lpGPOName = NULL; // just in case we have missed a case

                        iState = pCS->GetPolicyState ((TABLEENTRY *)pCS->m_pCurrentPolicy, uiPrecedence, &lpGPOName);

                        if (iState == -1)
                        {
                            uiPrecedence++;
                            iState = pCS->GetPolicyState ((TABLEENTRY *)pCS->m_pCurrentPolicy, uiPrecedence, &lpGPOName);

                            if (iState == -1)
                            {
                                break;
                            }
                        }


                        //
                        // Add the GPO Name
                        //

                        item.mask = LVIF_TEXT | LVIF_STATE;
                        item.iItem = iIndex;
                        item.iSubItem = 0;
                        item.state = 0;
                        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
                        item.pszText = lpGPOName ? lpGPOName : TEXT("");

                        iItem = (INT)SendMessage (hLV, LVM_INSERTITEM, 0, (LPARAM) &item);


                        if (iItem != -1)
                        {

                            //
                            // Add the state
                            //

                            item.mask = LVIF_TEXT;
                            item.iItem = iItem;
                            item.iSubItem = 1;
                            item.pszText = (iState == 1) ? pCS->m_pEnabled : pCS->m_pDisabled;

                            SendMessage (hLV, LVM_SETITEMTEXT, iItem, (LPARAM) &item);
                        }

                        uiPrecedence++;
                        iIndex++;
                    }
                }

                //
                // Select the first item
                //

                item.mask = LVIF_STATE;
                item.iItem = 0;
                item.iSubItem = 0;
                item.state = LVIS_SELECTED | LVIS_FOCUSED;
                item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                SendMessage (hLV, LVM_SETITEMSTATE, 0, (LPARAM) &item);

                pCS->SetPrevNextButtonState(hDlg);

            }

            break;
        }

        case WM_COMMAND:

            lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!lpSettingsInfo) {
                break;
            }

            if (LOWORD(wParam) == IDC_POLICY_NEXT)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, FALSE);
            }

            if (LOWORD(wParam) == IDC_POLICY_PREVIOUS)
            {
                lpSettingsInfo->pCS->MoveFocus (hDlg, TRUE);
            }

            break;


        case WM_NOTIFY:

            switch (((NMHDR FAR*)lParam)->code)
            {
                case PSN_APPLY:
                case PSN_RESET:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, RSOP_HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPDWORD) aPrecedenceHelpIds);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, RSOP_HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPDWORD) aPrecedenceHelpIds);
            return TRUE;
    }

    return FALSE;
}

LRESULT CPolicySnapIn::CallNextHook(int nCode, WPARAM wParam,LPARAM lParam)
{ 
    if (m_hKbdHook)
    {
        return CallNextHookEx(
            m_hKbdHook,
            nCode, 
            wParam, 
            lParam);
    }
    else
    {    
        DebugMsg((DM_WARNING, L"CPolicySnapIn::CallNextHook m_hKbdHook is Null"));
        return 0;
    }
}

HWND g_hDlgActive = NULL;

LRESULT CALLBACK CPolicySnapIn::KeyboardHookProc(int nCode, WPARAM wParam,LPARAM lParam)
{
    LPSETTINGSINFO lpSettingsInfo;

    lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(g_hDlgActive, DWLP_USER);

    if (!lpSettingsInfo)
    {
        DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc:GetWindowLongPtr returned NULL"));
        return 0;
    }


    if ( nCode < 0)
    {
        if (lpSettingsInfo->pCS) 
        {
            return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                    wParam, 
                                                    lParam); 
        }
        else
        {
            DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
            return 0;
        }
    }

    if (wParam == VK_TAB && !(lParam & 0x80000000)) {       // tab key depressed
        BOOL fShift = (GetKeyState(VK_SHIFT) & 0x80000000);
        HWND hwndFocus = GetFocus();
        HWND hChild;
        POLICYDLGINFO * pdi;
        int iIndex;
        int iDelta;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
        {    
            if (lpSettingsInfo->pCS) 
            {
                return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                      wParam, 
                                                      lParam); 
            }
            else
            {
                DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
                return 0;
            }
        }

        // see if the focus control is one of the setting controls
        for (iIndex=0;iIndex<(int)pdi->nControls;iIndex++) {

            if (pdi->pControlTable[iIndex].hwnd == hwndFocus) {
                goto BreakOut;
            }

            hChild = GetWindow (pdi->pControlTable[iIndex].hwnd, GW_CHILD);

            while (hChild) {

                if (hChild == hwndFocus) {
                    goto BreakOut;
                }

                hChild = GetWindow (hChild, GW_HWNDNEXT);
            }
        }

        BreakOut:
            if (iIndex == (int) pdi->nControls)
            {
                if (lpSettingsInfo->pCS) 
                {
                    return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                            wParam, 
                                                            lParam); 
                }
                else   // no, we don't care
                {
                    DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
                    return 0;
                }
            }
            iDelta = (fShift ? -1 : 1);

            // from the current setting control, scan forwards or backwards
            // (depending if on shift state, this can be TAB or shift-TAB)
            // to find the next control to give focus to
            for (iIndex += iDelta;iIndex>=0 && iIndex<(int) pdi->nControls;
                 iIndex += iDelta) {
                if (pdi->pControlTable[iIndex].uDataIndex !=
                    NO_DATA_INDEX &&
                    IsWindowEnabled(pdi->pControlTable[iIndex].hwnd)) {

                    // found it, set the focus on that control and return 1
                    // to eat the keystroke
                    SetFocus(pdi->pControlTable[iIndex].hwnd);
                    lpSettingsInfo->pCS->EnsureSettingControlVisible(g_hDlgActive,
                                                                     pdi->pControlTable[iIndex].hwnd);
                    return 1;
                }
            }

            // at first or last control in settings table, let dlg code
            // handle it and give focus to next (or previous) control in dialog
    }
    else
    {
        if (lpSettingsInfo->pCS) 
        {
            return lpSettingsInfo->pCS->CallNextHook(nCode, 
                                                    wParam, 
                                                    lParam); 
        }
        else
        {
            DebugMsg((DM_WARNING, L"CPolicySnapIn::KeyboardHookProc NULL CPolicySnapIn Pointer"));
            return 0;
        }
    }    

    return 0;
}

VOID CPolicySnapIn::SetKeyboardHook(HWND hDlg)
{
        // hook the keyboard to trap TABs.  If this fails for some reason,
        // fail silently and go on, not critical that tabs work correctly
        // (unless you have no mouse :)  )

        if (m_hKbdHook = SetWindowsHookEx(WH_KEYBOARD,
                                          KeyboardHookProc,
                                          g_hInstance,
                                          GetCurrentThreadId())) 
        {
            g_hDlgActive = hDlg;
        }
}


VOID CPolicySnapIn::RemoveKeyboardHook(VOID)
{
        if (m_hKbdHook) {
            UnhookWindowsHookEx(m_hKbdHook);
            g_hDlgActive = NULL;
            m_hKbdHook = NULL;
        }
}

INT CPolicySnapIn::GetPolicyState (TABLEENTRY *pTableEntry, UINT uiPrecedence, LPTSTR *lpGPOName)
{
    DWORD dwData=0;
    UINT uRet;
    TCHAR * pszValueName;
    TCHAR * pszKeyName;
    DWORD dwFoundSettings=0, dwTemp;
    BOOL fFound=FALSE,fCustomOn=FALSE, fCustomOff=FALSE;
    HKEY hKeyRoot;
    INT  iRetVal = -1;
    TABLEENTRY *pChild;


    if (m_pcd->m_bRSOP)
    {
        hKeyRoot = (HKEY) LongToHandle(uiPrecedence);
    }
    else
    {

        if (m_pcd->m_pGPTInformation->GetRegistryKey(
                     (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                          &hKeyRoot) != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::GetPolicyState: Failed to get registry key handle.")));
            return -1;
        }
    }


    //
    // Get the name of the value to read, if any
    //

    if (((POLICY *)pTableEntry)->uOffsetValueName)
    {
        pszKeyName =   GETKEYNAMEPTR(pTableEntry);
        pszValueName = GETVALUENAMEPTR(((POLICY *)pTableEntry));


        //
        // First look for custom on/off values
        //

        if (((POLICY *)pTableEntry)->uOffsetValue_On)
        {
            fCustomOn = TRUE;
            if (CompareCustomValue(hKeyRoot,pszKeyName,pszValueName,
                                   (STATEVALUE *) ((BYTE *) pTableEntry + ((POLICY *)
                                   pTableEntry)->uOffsetValue_On),&dwFoundSettings,lpGPOName)) {
                dwData = 1;
                fFound =TRUE;
            }
        }

        if (!fFound && ((POLICY *)pTableEntry)->uOffsetValue_Off)
        {
            fCustomOff = TRUE;
            if (CompareCustomValue(hKeyRoot,pszKeyName,pszValueName,
                                   (STATEVALUE *) ((BYTE *) pTableEntry + ((POLICY *)
                                   pTableEntry)->uOffsetValue_Off),&dwFoundSettings,lpGPOName)) {
                dwData = 0;
                fFound = TRUE;
            }
        }

        //
        // Look for standard values if custom values have not been specified
        //

        if (!fCustomOn && !fCustomOff && ReadStandardValue(hKeyRoot, pszKeyName, pszValueName,
                                        pTableEntry, &dwData, &dwFoundSettings, lpGPOName))
        {
            fFound = TRUE;
        }


        if (fFound)
        {
            if (dwData)
                iRetVal = 1;
            else
                iRetVal = 0;
        }
    }
    else if ((((POLICY *)pTableEntry)->uOffsetActionList_On) &&
             CheckActionList((POLICY *)pTableEntry, hKeyRoot, TRUE, lpGPOName))
    {
        iRetVal = 1;
    }
    else if ((((POLICY *)pTableEntry)->uOffsetActionList_Off) &&
             CheckActionList((POLICY *)pTableEntry, hKeyRoot, FALSE, lpGPOName))
    {
        iRetVal = 0;
    }
    else
    {
        BOOL bDisabled = TRUE;


        //
        // Process settings underneath this policy (if any)
        //

        if (pTableEntry->pChild) {

            dwFoundSettings = 0;
            pChild = pTableEntry->pChild;

            while (pChild) {

                dwTemp = 0;
                LoadSettings(pChild, hKeyRoot, &dwTemp, lpGPOName);

                dwFoundSettings |= dwTemp;

                if ((dwTemp & FS_PRESENT) && (!(dwTemp & FS_DISABLED))) {
                    bDisabled = FALSE;
                }

                pChild = pChild->pNext;
            }

            if (dwFoundSettings) {
                if (bDisabled)
                    iRetVal = 0;
                else
                    iRetVal = 1;
            }


        }
    }

    if (!m_pcd->m_bRSOP)
    {
        RegCloseKey (hKeyRoot);
    }

    return iRetVal;
}

BOOL CPolicySnapIn::CheckActionList (POLICY * pPolicy, HKEY hKeyRoot, BOOL bActionListOn, LPTSTR *lpGPOName)
{
    UINT uIndex;
    ACTIONLIST * pActionList;
    ACTION * pAction;
    TCHAR szValue[MAXSTRLEN];
    DWORD dwValue;
    TCHAR szNewValueName[MAX_PATH+1];
    TCHAR * pszKeyName;
    TCHAR * pszValueName;
    TCHAR * pszValue;


    //
    // Get the correct action list
    //

    if (bActionListOn)
    {
        pActionList = (ACTIONLIST *)(((LPBYTE)pPolicy) + pPolicy->uOffsetActionList_On);
    }
    else
    {
        pActionList = (ACTIONLIST *)(((LPBYTE)pPolicy) + pPolicy->uOffsetActionList_Off);
    }


    //
    // Loop through each of the entries to see if they match
    //

    for (uIndex = 0; uIndex < pActionList->nActionItems; uIndex++)
    {

        if (uIndex == 0)
        {
            pAction = &pActionList->Action[0];
        }
        else
        {
            pAction = (ACTION *)(((LPBYTE)pActionList) + pAction->uOffsetNextAction);
        }


        //
        // Get the value and keynames
        //

        pszValueName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValueName);

        if (pAction->uOffsetKeyName)
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetKeyName);
        }
        else
        {
            pszKeyName = (TCHAR *)(((LPBYTE)pPolicy) + pPolicy->uOffsetKeyName);
        }


        //
        // Add prefixes if appropriate
        //

        PrependValueName(pszValueName, pAction->dwFlags,
                         szNewValueName, ARRAYSIZE(szNewValueName));

        if (pAction->dwFlags & VF_ISNUMERIC)
        {
            if (ReadRegistryDWordValue(hKeyRoot, pszKeyName,
                                       szNewValueName, &dwValue, lpGPOName) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            if (dwValue != pAction->dwValue)
            {
                return FALSE;
            }
        }
        else if (pAction->dwFlags & VF_DELETE)
        {
            //
            // See if this is a value that's marked for deletion
            // (valuename is prepended with "**del."
            //

            if ((ReadRegistryStringValue(hKeyRoot, pszKeyName, szNewValueName,
                                         szValue,ARRAYSIZE(szValue),lpGPOName)) != ERROR_SUCCESS) {
                 return FALSE;
            }
        }
        else
        {
            if (ReadRegistryStringValue(hKeyRoot, pszKeyName, szNewValueName,
                                        szValue, ARRAYSIZE(szValue),lpGPOName) != ERROR_SUCCESS)
            {
                return FALSE;
            }

            pszValue = (TCHAR *)(((LPBYTE)pActionList) + pAction->uOffsetValue);

            if (lstrcmpi(szValue,pszValue) != 0)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

UINT CPolicySnapIn::LoadSettings(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
                                 DWORD * pdwFound, LPTSTR *lpGPOName)
{
    UINT uRet = ERROR_SUCCESS;
    TCHAR * pszValueName = NULL;
    TCHAR * pszKeyName = NULL;
    DWORD dwData=0,dwFlags,dwFoundSettings=0;
    TCHAR szData[MAXSTRLEN];
    BOOL fCustomOn=FALSE,fCustomOff=FALSE,fFound=FALSE;
    BYTE * pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));
    TCHAR szNewValueName[MAX_PATH+1];

    // get the name of the key to read
    if (((SETTINGS *) pTableEntry)->uOffsetKeyName) {
            pszKeyName = GETKEYNAMEPTR(((SETTINGS *) pTableEntry));
    }
    else return ERROR_NOT_ENOUGH_MEMORY;

    // get the name of the value to read
    if (((SETTINGS *) pTableEntry)->uOffsetValueName) {
            pszValueName = GETVALUENAMEPTR(((SETTINGS *) pTableEntry));
    }
    else return ERROR_NOT_ENOUGH_MEMORY;

    switch (pTableEntry->dwType & STYPE_MASK) {

            case STYPE_EDITTEXT:
            case STYPE_COMBOBOX:

                    dwFlags = ( (SETTINGS *) pTableEntry)->dwFlags;

                    // add prefixes if appropriate
                    PrependValueName(pszValueName,dwFlags,
                            szNewValueName,ARRAYSIZE(szNewValueName));

                    if ((uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,szData,ARRAYSIZE(szData),lpGPOName)) == ERROR_SUCCESS) {

                            // set flag that we found setting in registry/policy file
                            if (pdwFound)
                                    *pdwFound |= FS_PRESENT;
                    } else if (!(dwFlags & VF_DELETE)) {

                            // see if this key is marked as deleted
                            PrependValueName(pszValueName,VF_DELETE,
                                    szNewValueName,ARRAYSIZE(szNewValueName));
                            if ((uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                                    szNewValueName,szData,ARRAYSIZE(szData) * sizeof(TCHAR),lpGPOName)) == ERROR_SUCCESS) {

                                    // set flag that we found setting marked as deleted in
                                    // policy file
                                    if (pdwFound)
                                            *pdwFound |= FS_DELETED;
                            }
                    }

                    return ERROR_SUCCESS;
                    break;

            case STYPE_CHECKBOX:

                    if (!pObjectData) {
                        return ERROR_INVALID_PARAMETER;
                    }

                    // first look for custom on/off values
                    if (((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) {
                            fCustomOn = TRUE;
                            if (CompareCustomValue(hkeyRoot,pszKeyName,pszValueName,
                                    (STATEVALUE *) ((BYTE *) pTableEntry + ((CHECKBOXINFO *)
                                    pObjectData)->uOffsetValue_On),&dwFoundSettings, lpGPOName)) {
                                            dwData = 1;
                                            fFound = TRUE;
                            }
                    }

                    if (!fFound && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) {
                            fCustomOff = TRUE;
                            if (CompareCustomValue(hkeyRoot,pszKeyName,pszValueName,
                                    (STATEVALUE *) ((BYTE *) pTableEntry + ((CHECKBOXINFO *)
                                    pObjectData)->uOffsetValue_Off),&dwFoundSettings, lpGPOName)) {
                                            dwData = 0;
                                            fFound = TRUE;
                            }
                    }

                    // look for standard values if custom values have not been specified
                    if (!fFound &&
                            ReadStandardValue(hkeyRoot,pszKeyName,pszValueName,
                            pTableEntry,&dwData,&dwFoundSettings, lpGPOName)) {
                            fFound = TRUE;
                    }

                    if (fFound) {
                            // set flag that we found setting in registry
                            if (pdwFound) {
                                *pdwFound |= dwFoundSettings;

                                if (dwData == 0) {
                                    *pdwFound |= FS_DISABLED;
                                }
                            }
                    }

                    return ERROR_SUCCESS;
                    break;

            case STYPE_NUMERIC:

                    if (ReadStandardValue(hkeyRoot,pszKeyName,pszValueName,
                            pTableEntry,&dwData,&dwFoundSettings,lpGPOName)) {

                            // set flag that we found setting in registry
                            if (pdwFound)
                                    *pdwFound |= dwFoundSettings;
                    }
                    break;

            case STYPE_DROPDOWNLIST:

                    if (ReadCustomValue(hkeyRoot,pszKeyName,pszValueName,
                            szData,ARRAYSIZE(szData),&dwData,&dwFlags, lpGPOName)) {
                            BOOL fMatch = FALSE;

                            if (dwFlags & VF_DELETE) {
                                    // set flag that we found setting marked as deleted
                                    // in policy file
                                    if (pdwFound)
                                            *pdwFound |= FS_DELETED;
                                    return ERROR_SUCCESS;
                            }

                            // walk the list of DROPDOWNINFO structs (one for each state),
                            // and see if the value we found matches the value for the state

                            if ( ((SETTINGS *) pTableEntry)->uOffsetObjectData) {
                                    DROPDOWNINFO * pddi = (DROPDOWNINFO *)
                                            GETOBJECTDATAPTR( ((SETTINGS *) pTableEntry));
                                    UINT nIndex = 0;

                                    do {
                                            if (dwFlags == pddi->dwFlags) {

                                                    if (pddi->dwFlags & VF_ISNUMERIC) {
                                                            if (dwData == pddi->dwValue)
                                                                    fMatch = TRUE;
                                                    } else if (!pddi->dwFlags) {
                                                            if (!lstrcmpi(szData,(TCHAR *)((BYTE *)pTableEntry +
                                                                    pddi->uOffsetValue)))
                                                                    fMatch = TRUE;
                                                    }
                                            }

                                            if (!pddi->uOffsetNextDropdowninfo || fMatch)
                                                    break;

                                            pddi = (DROPDOWNINFO *) ( (BYTE *) pTableEntry +
                                                    pddi->uOffsetNextDropdowninfo);
                                            nIndex++;

                                    } while (!fMatch);

                                    if (fMatch) {
                                            // set flag that we found setting in registry
                                            if (pdwFound)
                                                    *pdwFound |= FS_PRESENT;
                                    }
                            }
                    }

                    break;

            case STYPE_LISTBOX:

                    return LoadListboxData(pTableEntry,hkeyRoot,
                            pszKeyName,pdwFound, NULL, lpGPOName);

                    break;

    }
    return ERROR_SUCCESS;
}


UINT CPolicySnapIn::LoadListboxData(TABLEENTRY * pTableEntry,HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName,DWORD * pdwFound, HGLOBAL * phGlobal, LPTSTR *lpGPOName)
{
        HKEY hKey = NULL;
        UINT nIndex=0,nLen;
        TCHAR szValueName[MAX_PATH+1],szValueData[MAX_PATH+1];
        DWORD cbValueName,cbValueData;
        DWORD dwType,dwAlloc=1024 * sizeof(TCHAR),dwUsed=0;
        HGLOBAL hBuf;
        TCHAR * pBuf;
        SETTINGS * pSettings = (SETTINGS *) pTableEntry;
        LISTBOXINFO * pListboxInfo = (LISTBOXINFO *)
                GETOBJECTDATAPTR(pSettings);
        BOOL fFoundValues=FALSE,fFoundDelvals=FALSE;
        UINT uRet=ERROR_SUCCESS;
        LPRSOPREGITEM lpItem = NULL;
        BOOL bMultiple;
        HRESULT hr = S_OK;
        DWORD dwBufLen = 0;

        if (m_pcd->m_bRSOP)
        {
            //
            // If this is an additive listbox, we want to pick up entries from
            // any GPO, not just the GPOs of precedence 1, so set hkeyRoot to 0
            //

            if ((pSettings->dwFlags & DF_ADDITIVE) && (hkeyRoot == (HKEY) 1))
            {
                hkeyRoot = (HKEY) 0;
            }
        }
        else
        {
            if (RegOpenKeyEx(hkeyRoot,pszCurrentKeyName,0,KEY_READ,&hKey) != ERROR_SUCCESS)
                    return ERROR_SUCCESS;   // nothing to do
        }

        // allocate a temp buffer to read entries into
        if (!(hBuf = GlobalAlloc(GHND,dwAlloc)) ||
                !(pBuf = (TCHAR *) GlobalLock(hBuf))) {
                if (hBuf)
                        GlobalFree(hBuf);

                uRet = ERROR_NOT_ENOUGH_MEMORY;
                goto CPolicySnapin_LoadListBoxData_exit;
        }

        while (TRUE) {
                cbValueName=ARRAYSIZE(szValueName);
                cbValueData=ARRAYSIZE(szValueData) * sizeof(TCHAR);

                if (m_pcd->m_bRSOP)
                {
                    uRet = m_pcd->EnumRSOPRegistryValues(hkeyRoot, pszCurrentKeyName,
                                                         szValueName, cbValueName,
                                                         &lpItem);

                    if (uRet == ERROR_SUCCESS)
                    {
                        //
                        // Check if the GPO name is changing
                        //

                        bMultiple = FALSE;

                        if (lpGPOName && *lpGPOName && lpItem->lpGPOName && (hkeyRoot == 0))
                        {
                            if (lstrcmpi(*lpGPOName, lpItem->lpGPOName))
                            {
                                bMultiple = TRUE;
                            }
                        }

                        uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszCurrentKeyName,
                                                            szValueName, (LPBYTE)szValueData,
                                                            cbValueData, &dwType, lpGPOName,
                                                            lpItem);

                        if (bMultiple)
                        {
                            *lpGPOName = m_pMultipleGPOs;
                        }
                    }
                }
                else
                {
                    uRet=RegEnumValue(hKey,nIndex,szValueName,&cbValueName,NULL,
                            &dwType,(LPBYTE)szValueData,&cbValueData);
                }

                // stop if we're out of items
                if (uRet != ERROR_SUCCESS && uRet != ERROR_MORE_DATA)
                        break;
                nIndex++;

                if (szValueName[0] == TEXT('\0')) {
                        // if the value is empty, it is the key creation code
                        continue;
                }

                // if valuename prefixed with '**', it's a control code, ignore it
                if (szValueName[0] == TEXT('*') && szValueName[1] == TEXT('*')) {
                        // if we found **delvals., then some sort of listbox stuff
                        // is going on, remember that we found this code
                        if (!lstrcmpi(szValueName,szDELVALS))
                                fFoundDelvals = TRUE;
                        continue;
                }

                // only process this item if enum was successful
                // (so we'll skip items with weird errors like ERROR_MORE_DATA and
                // but keep going with the enum)
                if (uRet == ERROR_SUCCESS) {
                        TCHAR * pszData;

                        // if there's no value name prefix scheme specified (e.g.
                        // value names are "abc1", "abc2", etc), and the explicit valuename
                        // flag isn't set where we remember the value name as well as
                        // the data for every value, then we need the value name to
                        // be the same as the value data ("thing.exe=thing.exe").
                        if (!(pSettings->dwFlags & DF_EXPLICITVALNAME) &&
                                !(pListboxInfo->uOffsetPrefix) && !(pListboxInfo->uOffsetValue)) {
                                if (dwType != (DWORD)((pSettings->dwFlags & DF_EXPANDABLETEXT) ? REG_EXPAND_SZ : REG_SZ) ||
                                    lstrcmpi(szValueName,szValueData))
                                        continue;       // skip this value if val name != val data
                        }


                        //
                        // If there is a valueprefix, only pick up values that start
                        // with that prefix
                        //

                        if (pListboxInfo->uOffsetPrefix) {
                            LPTSTR lpPrefix = (LPTSTR)((LPBYTE)pTableEntry + pListboxInfo->uOffsetPrefix);
                            INT iPrefixLen = lstrlen(lpPrefix);

                            if (CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL,
                                              lpPrefix, iPrefixLen, szValueName,
                                              iPrefixLen) != CSTR_EQUAL) {
                                continue;
                            }
                        }


                        // if explicit valuenames used, then copy the value name into
                        // buffer
                        if (pSettings->dwFlags & DF_EXPLICITVALNAME) {
                                nLen = lstrlen(szValueName) + 1;
                                dwBufLen = dwUsed+nLen+4;

                                if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwBufLen) * sizeof(TCHAR),&dwAlloc)))
                                {
                                    uRet = ERROR_NOT_ENOUGH_MEMORY;
                                    goto CPolicySnapin_LoadListBoxData_exit;
                                }

                                hr = StringCchCopy(pBuf+dwUsed, dwBufLen - dwUsed, szValueName);
                                ASSERT(SUCCEEDED(hr));
                                dwUsed += nLen;
                        }


                        // for default listbox type, value data is the actual "data"
                        // and value name either will be the same as the data or
                        // some prefix + "1", "2", etc.  If there's a data value to
                        // write for each entry, then the "data" is the value name
                        // (e.g. "Larry = abc", "Dave = abc"), etc.  If explicit value names
                        // are turned on, then both the value name and data are stored
                        // and editable

                        // copy value data into buffer
                        if (pListboxInfo->uOffsetValue) {
                                // data value set, use value name for data
                                pszData = szValueName;
                        } else pszData = szValueData;

                        nLen = lstrlen(pszData) + 1;
                        dwBufLen = dwUsed+nLen+4;
                        if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwBufLen) * sizeof(TCHAR),&dwAlloc)))
                        {
                             uRet = ERROR_NOT_ENOUGH_MEMORY;
                             goto CPolicySnapin_LoadListBoxData_exit;
                        }

                        hr = StringCchCopy(pBuf+dwUsed, dwBufLen - dwUsed, pszData);
                        ASSERT(SUCCEEDED(hr));

                        dwUsed += nLen;
                        fFoundValues=TRUE;

                        //
                        // Add the GPO name if this is RSOP mode
                        //

                        if (m_pcd->m_bRSOP)
                        {
                            nLen = lstrlen(lpItem->lpGPOName) + 1;
                            dwBufLen = dwUsed+nLen+4;
                            if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwBufLen) * sizeof(TCHAR),&dwAlloc)))
                            {
                                uRet = ERROR_NOT_ENOUGH_MEMORY;
                                goto CPolicySnapin_LoadListBoxData_exit;
                            }
                            hr = StringCchCopy(pBuf+dwUsed, dwBufLen - dwUsed, lpItem->lpGPOName);
                            ASSERT(SUCCEEDED(hr));

                            dwUsed += nLen;
                        }
                }
        }

        // doubly null-terminate the buffer... safe to do this because we
        // tacked on the extra "+4" in the ResizeBuffer calls above
        *(pBuf+dwUsed) = TEXT('\0');
        dwUsed++;

        uRet = ERROR_SUCCESS;

        if (fFoundValues) {
                // set flag that we found setting in registry/policy file
                if (pdwFound)
                        *pdwFound |= FS_PRESENT;
        } else {
                if (fFoundDelvals && pdwFound) {
                        *pdwFound |= FS_DELETED;
                }
        }

        GlobalUnlock(hBuf);

        if ((uRet == ERROR_SUCCESS) && phGlobal)
        {
            *phGlobal = hBuf;
        }
        else
        {
            GlobalFree(hBuf);
        }

CPolicySnapin_LoadListBoxData_exit:

        if (hKey)
        {
            RegCloseKey(hKey);
        }

        return uRet;
}


BOOL CPolicySnapIn::ReadCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,UINT cbValue,DWORD * pdwValue,DWORD * pdwFlags,LPTSTR *lpGPOName)
{
        HKEY hKey;
        DWORD dwType,dwSize=cbValue * sizeof(TCHAR);
        BOOL fSuccess = FALSE;
        TCHAR szNewValueName[MAX_PATH+1];

        *pdwValue=0;
        *pszValue = TEXT('\0');


        if (m_pcd->m_bRSOP)
        {
            if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE)pszValue,
                                      dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
            {
                if (dwType == REG_SZ)
                {
                        // value returned in pszValueName
                        *pdwFlags = 0;
                        fSuccess = TRUE;
                }
                else if (dwType == REG_DWORD || dwType == REG_BINARY)
                {
                        // copy value to *pdwValue
                        memcpy(pdwValue,pszValue,sizeof(DWORD));
                        *pdwFlags = VF_ISNUMERIC;
                        fSuccess = TRUE;
                }
            }
            else
            {
                // see if this is a value that's marked for deletion
                // (valuename is prepended with "**del."
                PrependValueName(pszValueName,VF_DELETE,
                        szNewValueName,ARRAYSIZE(szNewValueName));

                if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, szNewValueName, (LPBYTE)pszValue,
                                          dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
                {
                    fSuccess=TRUE;
                    *pdwFlags = VF_DELETE;
                }
                else
                {
                    // see if this is a soft value
                    // (valuename is prepended with "**soft."
                    PrependValueName(pszValueName,VF_SOFT,
                            szNewValueName,ARRAYSIZE(szNewValueName));

                    if (m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, szNewValueName, (LPBYTE)pszValue,
                                              dwSize, &dwType, lpGPOName, NULL) == ERROR_SUCCESS)
                    {
                            fSuccess=TRUE;
                            *pdwFlags = VF_SOFT;
                    }
                }
            }
        }
        else
        {
            if (RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey) == ERROR_SUCCESS) {
                    if (RegQueryValueEx(hKey,pszValueName,NULL,&dwType,(LPBYTE) pszValue,
                            &dwSize) == ERROR_SUCCESS) {

                            if (dwType == REG_SZ) {
                                    // value returned in pszValueName
                                    *pdwFlags = 0;
                                    fSuccess = TRUE;
                            } else if (dwType == REG_DWORD || dwType == REG_BINARY) {
                                    // copy value to *pdwValue
                                    memcpy(pdwValue,pszValue,sizeof(DWORD));
                                    *pdwFlags = VF_ISNUMERIC;
                                    fSuccess = TRUE;
                            }

                    } else {
                            // see if this is a value that's marked for deletion
                            // (valuename is prepended with "**del."
                            PrependValueName(pszValueName,VF_DELETE,
                                    szNewValueName,ARRAYSIZE(szNewValueName));

                            if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
                                    &dwSize) == ERROR_SUCCESS) {
                                    fSuccess=TRUE;
                                    *pdwFlags = VF_DELETE;
                            } else {
                                    // see if this is a soft value
                                    // (valuename is prepended with "**soft."
                                    PrependValueName(pszValueName,VF_SOFT,
                                            szNewValueName,ARRAYSIZE(szNewValueName));

                                    if (RegQueryValueEx(hKey,szNewValueName,NULL,&dwType,(LPBYTE) pszValue,
                                            &dwSize) == ERROR_SUCCESS) {
                                            fSuccess=TRUE;
                                            *pdwFlags = VF_SOFT;
                                    }
                            }
                    }

                    RegCloseKey(hKey);
            }

        }

        return fSuccess;
}


BOOL CPolicySnapIn::CompareCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
                                       STATEVALUE * pStateValue,DWORD * pdwFound, LPTSTR *lpGPOName)
{
        TCHAR szValue[MAXSTRLEN];
        DWORD dwValue;
        TCHAR szNewValueName[MAX_PATH+1];

        // add prefixes if appropriate
        PrependValueName(pszValueName,pStateValue->dwFlags,
                szNewValueName,ARRAYSIZE(szNewValueName));

        if (pStateValue->dwFlags & VF_ISNUMERIC) {
                if ((ReadRegistryDWordValue(hkeyRoot,pszKeyName,
                        szNewValueName,&dwValue,lpGPOName) == ERROR_SUCCESS) &&
                        dwValue == pStateValue->dwValue) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        } else if (pStateValue->dwFlags & VF_DELETE) {

                // see if this is a value that's marked for deletion
                // (valuename is prepended with "**del."

                if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szValue,ARRAYSIZE(szValue),lpGPOName)) == ERROR_SUCCESS) {
                        *pdwFound = FS_DELETED;
                        return TRUE;
                }
        } else {
                if ((ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szValue,ARRAYSIZE(szValue),lpGPOName)) == ERROR_SUCCESS &&
                        !lstrcmpi(szValue,pStateValue->szValue)) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        }

        return FALSE;
}


BOOL CPolicySnapIn::ReadStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TABLEENTRY * pTableEntry,DWORD * pdwData,DWORD * pdwFound, LPTSTR *lpGPOName)
{
        UINT uRet;
        TCHAR szNewValueName[MAX_PATH+1];

        // add prefixes if appropriate
        PrependValueName(pszValueName,((SETTINGS *) pTableEntry)->dwFlags,
                szNewValueName,ARRAYSIZE(szNewValueName));

        if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
                // read numeric value as text if specified
                TCHAR szNum[11];
                uRet = ReadRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName,szNum,ARRAYSIZE(szNum),lpGPOName);
                if (uRet == ERROR_SUCCESS) {
                        StringToNum(szNum, (UINT *)pdwData);
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        } else {
                // read numeric value as binary
                uRet = ReadRegistryDWordValue(hkeyRoot,pszKeyName,
                        szNewValueName,pdwData, lpGPOName);
                if (uRet == ERROR_SUCCESS) {
                        *pdwFound = FS_PRESENT;
                        return TRUE;
                }
        }

        // see if this settings has been marked as 'deleted'
        TCHAR szVal[MAX_PATH+1];
        *pdwData = 0;
        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                ARRAYSIZE(szNewValueName));
        uRet=ReadRegistryStringValue(hkeyRoot,pszKeyName,
                szNewValueName,szVal,ARRAYSIZE(szVal),lpGPOName);
        if (uRet == ERROR_SUCCESS) {
                *pdwFound = FS_DELETED;
                return TRUE;
        }


        return FALSE;
}

// adds the special prefixes "**del." and "**soft." if writing to a policy file,
// and VF_DELETE/VF_SOFT flags are set
VOID CPolicySnapIn::PrependValueName(TCHAR * pszValueName,DWORD dwFlags,TCHAR * pszNewValueName,
                                     UINT cbNewValueName)
{
        UINT nValueNameLen = lstrlen(pszValueName) + 1;
        HRESULT hr = S_OK;

        (void) StringCchCopy(pszNewValueName, cbNewValueName, g_szNull);

        if (cbNewValueName < nValueNameLen)     // check length of buffer, just in case
            return;

        // prepend special prefixes for "delete" or "soft" values
        if ((dwFlags & VF_DELETE) && (cbNewValueName > nValueNameLen +
                ARRAYSIZE(szDELETEPREFIX))) {
                (void) StringCchCopy(pszNewValueName, cbNewValueName, szDELETEPREFIX);
        } else if ((dwFlags & VF_SOFT) && (cbNewValueName > nValueNameLen +
                ARRAYSIZE(szSOFTPREFIX))) {
                (void) StringCchCopy(pszNewValueName, cbNewValueName, szSOFTPREFIX);
        }


        (void) StringCchCat(pszNewValueName, cbNewValueName, pszValueName);
}

UINT CPolicySnapIn::WriteRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        DWORD dwValue)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegSetValueEx(hKey,pszValueName,0,REG_DWORD,
                (LPBYTE) &dwValue,sizeof(dwValue));
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::ReadRegistryDWordValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        DWORD * pdwValue, LPTSTR *lpGPOName)
{
        HKEY hKey;
        UINT uRet;
        DWORD dwType,dwSize = sizeof(DWORD);

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;
        *pdwValue = 0;

        if (m_pcd->m_bRSOP)
        {
            uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE) pdwValue, 4,
                                                &dwType, lpGPOName, NULL);
        }
        else
        {
            // open appropriate key
            if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey))
                    != ERROR_SUCCESS)
                    return uRet;

            uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
                    (LPBYTE) pdwValue,&dwSize);
            RegCloseKey(hKey);
        }

        return uRet;
}

UINT CPolicySnapIn::WriteRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue, BOOL bExpandable)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegCreateKey(hkeyRoot,pszKeyName,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegSetValueEx(hKey,pszValueName,0,
                bExpandable ?  REG_EXPAND_SZ : REG_SZ,
                (LPBYTE) pszValue,(lstrlen(pszValue)+1) * sizeof(TCHAR));
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::ReadRegistryStringValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,UINT cbValue, LPTSTR *lpGPOName)
{
        HKEY hKey;
        UINT uRet;
        DWORD dwType;
        DWORD dwSize = cbValue * sizeof(TCHAR);

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        if (m_pcd->m_bRSOP)
        {
            uRet = m_pcd->ReadRSOPRegistryValue(hkeyRoot, pszKeyName, pszValueName, (LPBYTE) pszValue,
                                        dwSize, &dwType, lpGPOName, NULL);
        }
        else
        {
            // create the key with appropriate name
            if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_READ,&hKey))
                    != ERROR_SUCCESS)
                    return uRet;

            uRet = RegQueryValueEx(hKey,pszValueName,0,&dwType,
                    (LPBYTE) pszValue,&dwSize);
            RegCloseKey(hKey);
        }

        return uRet;
}

UINT CPolicySnapIn::DeleteRegistryValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName)
{
        HKEY hKey;
        UINT uRet;

        if (!pszKeyName || !pszValueName)
                return ERROR_INVALID_PARAMETER;

        // create the key with appropriate name
        if ( (uRet = RegOpenKeyEx(hkeyRoot,pszKeyName,0,KEY_WRITE,&hKey))
                != ERROR_SUCCESS)
                return uRet;

        uRet = RegDeleteValue(hKey,pszValueName);
        RegCloseKey(hKey);

        return uRet;
}

UINT CPolicySnapIn::WriteCustomValue_W(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TCHAR * pszValue,DWORD dwValue,DWORD dwFlags,BOOL fErase)
{
        UINT uRet=ERROR_SUCCESS;
        TCHAR szNewValueName[MAX_PATH+1];

        // first: "clean house" by deleting both the specified value name,
        // and the value name with the delete (**del.) prefix.
        // Then write the appropriate version back out if need be

        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                         ARRAYSIZE(szNewValueName));
        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);


        // add prefixes if appropriate
        PrependValueName(pszValueName,(dwFlags & ~VF_DELETE),szNewValueName,
                         ARRAYSIZE(szNewValueName));
        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);

        if (fErase) {
                // just need to delete value, done above

                uRet = ERROR_SUCCESS;
                RegCleanUpValue (hkeyRoot, pszKeyName, pszValueName);
        } else if (dwFlags & VF_DELETE) {
                // need to delete value (done above) and mark as deleted if writing
                // to policy file

                uRet = ERROR_SUCCESS;
                PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                                 ARRAYSIZE(szNewValueName));
                uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                        szNewValueName, (TCHAR *)szNOVALUE, FALSE);

        } else {
                if (dwFlags & VF_ISNUMERIC) {
                    uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
                                                 szNewValueName,dwValue);
                } else {
                    uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,pszValue,
                            (dwFlags & DF_EXPANDABLETEXT) ? TRUE : FALSE);
                }
        }

        return uRet;
}

UINT CPolicySnapIn::WriteCustomValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        STATEVALUE * pStateValue,BOOL fErase)
{
        // pull info out of STATEVALUE struct and call worker function
        return WriteCustomValue_W(hkeyRoot,pszKeyName,pszValueName,
                pStateValue->szValue,pStateValue->dwValue,pStateValue->dwFlags,
                fErase);
}

// writes a numeric value given root key, key name and value name.  The specified
// value is removed if fErase is TRUE.  Normally if the data (dwData) is zero
// the value will be deleted, but if fWriteZero is TRUE then the value will
// be written as zero if the data is zero.
UINT CPolicySnapIn::WriteStandardValue(HKEY hkeyRoot,TCHAR * pszKeyName,TCHAR * pszValueName,
        TABLEENTRY * pTableEntry,DWORD dwData,BOOL fErase,BOOL fWriteZero)
{
        UINT uRet=ERROR_SUCCESS;
        TCHAR szNewValueName[MAX_PATH+1];
        HRESULT hr  = S_OK;

        // first: "clean house" by deleting both the specified value name,
        // and the value name with the delete (**del.) prefix (if writing to policy
        // file).  Then write the appropriate version back out if need be

        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                ARRAYSIZE(szNewValueName));

        DeleteRegistryValue(hkeyRoot,pszKeyName,szNewValueName);
        DeleteRegistryValue(hkeyRoot,pszKeyName,pszValueName);

        if (fErase) {
                // just need to delete value, done above
                uRet = ERROR_SUCCESS;
                RegCleanUpValue (hkeyRoot, pszKeyName, pszValueName);
        } else if ( ((SETTINGS *) pTableEntry)->dwFlags & DF_TXTCONVERT) {
                // if specified, save value as text
                TCHAR szNum[11];
                hr = StringCchPrintf(szNum, ARRAYSIZE(szNum), TEXT("%lu"),dwData);
                ASSERT(SUCCEEDED(hr));

                if (!dwData && !fWriteZero) {
                    // if value is 0, delete the value (done above), and mark
                    // it as deleted if writing to policy file

                    PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                            ARRAYSIZE(szNewValueName));
                    uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,(TCHAR *)szNOVALUE, FALSE);
                } else {

                    PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
                            szNewValueName,ARRAYSIZE(szNewValueName));
                    uRet = WriteRegistryStringValue(hkeyRoot,pszKeyName,
                            szNewValueName,szNum, FALSE);
                }
        } else {
                if (!dwData && !fWriteZero) {
                        // if value is 0, delete the value (done above), and mark
                        // it as deleted if writing to policy file

                        PrependValueName(pszValueName,VF_DELETE,szNewValueName,
                                ARRAYSIZE(szNewValueName));
                        uRet=WriteRegistryStringValue(hkeyRoot,pszKeyName,
                                szNewValueName,(TCHAR *)szNOVALUE, FALSE);


                } else {
                        // save value as binary
                        PrependValueName(pszValueName,((SETTINGS *)pTableEntry)->dwFlags,
                                szNewValueName,ARRAYSIZE(szNewValueName));
                        uRet=WriteRegistryDWordValue(hkeyRoot,pszKeyName,
                                szNewValueName,dwData);
                        return 0;
                }
        }

        return uRet;
}

TCHAR * CPolicySnapIn::ResizeBuffer(TCHAR * pBuf,HGLOBAL hBuf,DWORD dwNeeded,DWORD * pdwCurSize)
{
    TCHAR * pNew;

    if (dwNeeded <= *pdwCurSize) return pBuf; // nothing to do
    *pdwCurSize = dwNeeded;

    GlobalUnlock(hBuf);

    if (!GlobalReAlloc(hBuf,dwNeeded,GHND))
            return NULL;

    if (!(pNew = (TCHAR *) GlobalLock(hBuf))) return NULL;

    return pNew;
}
/*******************************************************************

        NAME:           MessageWndProc

        SYNOPSIS:       Window proc for GPMessageWndProc window

********************************************************************/
LRESULT CALLBACK CPolicySnapIn::MessageWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{

    switch (message)
    {
        case WM_CREATE:
            SetWindowLongPtr (hWnd, GWLP_USERDATA, (LONG_PTR)((CREATESTRUCT *) lParam)->lpCreateParams);
            break;

        case WM_MOVEFOCUS:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->MoveFocusWorker ((BOOL)wParam);
            }
            }
            break;

        case WM_UPDATEITEM:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->UpdateItemWorker ();
            }
            }
            break;

        case WM_SETPREVNEXT:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                pPS->SetPrevNextButtonStateWorker ((HWND) wParam);
            }
            }
            break;

        default:
            {
            CPolicySnapIn * pPS;

            pPS = (CPolicySnapIn *) GetWindowLongPtr (hWnd, GWLP_USERDATA);

            if (pPS)
            {
                if (message == pPS->m_uiRefreshMsg)
                {
                    if ((DWORD) lParam == GetCurrentProcessId())
                    {
                        if (!pPS->m_hPropDlg)
                        {
                            pPS->m_pcd->m_pScope->DeleteItem (pPS->m_pcd->m_hSWPolicies, FALSE);
                            pPS->m_pcd->LoadTemplates();
                            pPS->m_pcd->EnumerateScopePane (NULL, pPS->m_pcd->m_hSWPolicies);
                        }
                    }
                }
            }

            return (DefWindowProc(hWnd, message, wParam, lParam));
            }
    }

    return (0);
}

/*******************************************************************

        NAME:           ClipWndProc

        SYNOPSIS:       Window proc for ClipClass window

********************************************************************/
LRESULT CALLBACK CPolicySnapIn::ClipWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{

        switch (message) {

                case WM_CREATE:

                        if (!((CREATESTRUCT *) lParam)->lpCreateParams) {

                                // this is the clip window in the dialog box.
                                SetScrollRange(hWnd,SB_VERT,0,0,TRUE);
                                SetScrollRange(hWnd,SB_HORZ,0,0,TRUE);
                        } else {
                                // this is the container window

                                // store away the dialog box HWND (the grandparent of this
                                // window) because the pointer to instance data we need lives
                                // in the dialog's window data
                                SetWindowLong(hWnd,0,WT_SETTINGS);
                        }

                        break;

                case WM_USER:
                        {
                                HWND hwndParent = GetParent(hWnd);
                                LPSETTINGSINFO lpSettingsInfo;
                                POLICYDLGINFO * pdi;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hwndParent, DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                pdi = lpSettingsInfo->pdi;

                                if (!pdi)
                                    return FALSE;

                                if (!lpSettingsInfo->hFontDlg)
                                    lpSettingsInfo->hFontDlg = (HFONT) SendMessage(GetParent(hWnd),WM_GETFONT,0,0L);

                                // make a container window that is clipped by this windows
                                if (!(pdi->hwndSettings=CreateWindow(TEXT("ClipClass"),(TCHAR *) g_szNull,
                                        WS_CHILD | WS_VISIBLE,0,0,400,400,hWnd,NULL,g_hInstance,
                                        (LPVOID) hWnd)))
                                        return FALSE;
                                SetWindowLong(hWnd,0,WT_CLIP);
                                return TRUE;
                        }
                        break;

                case WM_VSCROLL:
                case WM_HSCROLL:

                        if (GetWindowLong(hWnd,0) == WT_CLIP)
                        {
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                lpSettingsInfo->pCS->ProcessScrollBar(hWnd,wParam,
                                                    (message == WM_VSCROLL) ? TRUE : FALSE);
                        }
                        else goto defproc;

                        return 0;


                case WM_COMMAND:

                        if (GetWindowLong(hWnd,0) == WT_SETTINGS) {
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(GetParent(hWnd)), DWLP_USER);

                                if (!lpSettingsInfo)
                                    break;

                                lpSettingsInfo->pCS->ProcessCommand(hWnd,wParam,(HWND) lParam, lpSettingsInfo->pdi);
                        }

                        break;

                case WM_GETDLGCODE:

                        if (GetWindowLong(hWnd,0) == WT_CLIP) {
                                SetWindowLongPtr(GetParent(hWnd),DWLP_MSGRESULT,DLGC_WANTTAB |
                                        DLGC_WANTALLKEYS);
                                return DLGC_WANTTAB | DLGC_WANTALLKEYS;
                        }
                        break;

                case WM_SETFOCUS:
                        // if clip window gains keyboard focus, transfer focus to first
                        // control owned by settings window
                        if (GetWindowLong(hWnd,0) == WT_CLIP) {
                                HWND hwndParent = GetParent(hWnd);
                                POLICYDLGINFO * pdi;
                                INT nIndex;
                                BOOL fForward=TRUE;
                                HWND hwndPrev = GetDlgItem(hwndParent,IDC_POLICY_PREVIOUS);
                                HWND hwndNext = GetDlgItem(hwndParent,IDC_POLICY_NEXT);
                                HWND hwndOK = GetDlgItem(GetParent(hwndParent),IDOK);
                                int iDelta;
                                LPSETTINGSINFO lpSettingsInfo;

                                lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

                                if (!lpSettingsInfo)
                                    return FALSE;

                                pdi = lpSettingsInfo->pdi;

                                if (!pdi)
                                    return FALSE;


                                // if Previous Policy button lost focus, then we're going backwards
                                // in tab order; otherwise we're going forwards
                                if ( (HWND) wParam == hwndPrev)
                                        fForward = FALSE;
                                else if ( (HWND) wParam == hwndNext)
                                        fForward = FALSE;
                                else if ( (HWND) wParam == hwndOK)
                                        fForward = FALSE;

                                // find the first control that has a data index (e.g. is
                                // not static text) and give it focus

                                if (pdi->nControls) {
                                        if (fForward) {         // search from start of table forwards
                                                nIndex = 0;
                                                iDelta = 1;
                                        } else {                        // search from end of table backwards
                                                nIndex = pdi->nControls-1;
                                                iDelta = -1;
                                        }

                                        for (;nIndex>=0 && nIndex<(int)pdi->nControls;nIndex += iDelta) {
                                                if (pdi->pControlTable[nIndex].uDataIndex !=
                                                        NO_DATA_INDEX &&
                                                        IsWindowEnabled(pdi->pControlTable[nIndex].hwnd)) {
                                                                SetFocus(pdi->pControlTable[nIndex].hwnd);
                                                        lpSettingsInfo->pCS->EnsureSettingControlVisible(hwndParent,
                                                                pdi->pControlTable[nIndex].hwnd);
                                                        return FALSE;
                                                }
                                        }
                                }

                                // only get here if there are no setting windows that can
                                // receive keyboard focus.  Give keyboard focus to the
                                // next guy in line.  This is the "OK" button, unless we
                                // shift-tabbed to get here from the "OK" button in which
                                // case the tree window is the next guy in line

                                if (fForward) {
                                    if (IsWindowEnabled (hwndPrev))
                                        SetFocus(hwndPrev);
                                    else if (IsWindowEnabled (hwndNext))
                                        SetFocus(hwndNext);
                                    else
                                        SetFocus(hwndOK);
                                } else {
                                    if (IsDlgButtonChecked (hwndParent, IDC_ENABLED) == BST_CHECKED) {
                                        SetFocus (GetDlgItem(hwndParent,IDC_ENABLED));
                                    } else if (IsDlgButtonChecked (hwndParent, IDC_DISABLED) == BST_CHECKED) {
                                        SetFocus (GetDlgItem(hwndParent,IDC_DISABLED));
                                    } else {
                                        SetFocus (GetDlgItem(hwndParent,IDC_NOCONFIG));
                                    }
                                }

                                return FALSE;
                        }
                        break;


                default:
defproc:

                        return (DefWindowProc(hWnd, message, wParam, lParam));

        }

        return (0);
}

/*******************************************************************

        NAME:           ProcessCommand

        SYNOPSIS:       WM_COMMAND handler for ClipClass window

********************************************************************/
VOID CPolicySnapIn::ProcessCommand(HWND hWnd,WPARAM wParam,HWND hwndCtrl, POLICYDLGINFO * pdi)
{
        // get instance-specific struct from dialog
        UINT uID = GetWindowLong(hwndCtrl,GWL_ID);

        if ( (uID >= IDD_SETTINGCTRL) && (uID < IDD_SETTINGCTRL+pdi->nControls)) {
                POLICYCTRLINFO * pPolicyCtrlInfo= &pdi->pControlTable[uID - IDD_SETTINGCTRL];

                switch (pPolicyCtrlInfo->dwType) {

                        case STYPE_CHECKBOX:

                                SendMessage(hwndCtrl,BM_SETCHECK,
                                           !(SendMessage(hwndCtrl,BM_GETCHECK,0,0)),0);

                                break;

                        case STYPE_LISTBOX:
                                ShowListbox(hwndCtrl,pPolicyCtrlInfo->pSetting);
                                break;


                        default:
                                // nothing to do
                                break;
                }

                if ((HIWORD(wParam) == BN_CLICKED) ||
                    (HIWORD(wParam) == EN_CHANGE)  ||
                    (HIWORD(wParam) == CBN_SELCHANGE) ||
                    (HIWORD(wParam) == CBN_EDITCHANGE))
                {
                    PostMessage (GetParent(GetParent(hWnd)), WM_MYCHANGENOTIFY, 0, 0);
                }
        }
}

// scrolls the control window into view if it's not visible
VOID CPolicySnapIn::EnsureSettingControlVisible(HWND hDlg,HWND hwndCtrl)
{
        // get the clip window, which owns the scroll bar
        HWND hwndClip = GetDlgItem(hDlg,IDC_POLICY_SETTINGS);
        POLICYDLGINFO * pdi;
        UINT nPos = GetScrollPos(hwndClip,SB_VERT),ySettingWindowSize,yClipWindowSize;
        UINT nExtra;
        int iMin,iMax=0;
        WINDOWPLACEMENT wp;
        RECT rcCtrl;
        LPSETTINGSINFO lpSettingsInfo;

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

        if (!lpSettingsInfo)
            return;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return;

        // find the scroll range
        GetScrollRange(hwndClip,SB_VERT,&iMin,&iMax);
        if (!iMax)      // no scroll bar, nothing to do
                return;

        // find the y size of the settings window that contains the settings controls
        // (this is clipped by the clip window in the dialog, scroll bar moves the
        // setting window up and down behind the clip window)
        wp.length = sizeof(wp);
        if (!GetWindowPlacement(pdi->hwndSettings,&wp))
                return; // unlikely to fail, but just bag out if it does rather than do something wacky
        ySettingWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;

        // find y size of clip window
        if (!GetWindowPlacement(hwndClip,&wp))
                return; // unlikely to fail, but just bag out if it does rather than do something wacky
        yClipWindowSize=wp.rcNormalPosition.bottom-wp.rcNormalPosition.top;
        nExtra = ySettingWindowSize - yClipWindowSize;

        // if setting window is smaller than clip window, there should be no
        // scroll bar so we should never get here.  Check just in case though...
        if (ySettingWindowSize < yClipWindowSize)
                return;

        // get y position of control to be made visible
        if (!GetWindowPlacement(hwndCtrl,&wp))
                return;
        rcCtrl = wp.rcNormalPosition;
        rcCtrl.bottom = min ((int) ySettingWindowSize,rcCtrl.bottom + SC_YPAD);
        rcCtrl.top = max ((int) 0,rcCtrl.top - SC_YPAD);

        // if bottom of control is out of view, scroll the settings window up
        if ((float) rcCtrl.bottom >
                (float) (yClipWindowSize + ( (float) nPos/(float)iMax) * (ySettingWindowSize -
                yClipWindowSize))) {
                UINT nNewPos = (UINT)
                        ( ((float) (nExtra - (ySettingWindowSize - rcCtrl.bottom)) / (float) nExtra) * iMax);

                SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
                ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos), TRUE);
                return;
        }

        // if top of control is out of view, scroll the settings window down
        if ((float) rcCtrl.top <
                (float) ( (float) nPos/(float)iMax) * nExtra) {
                UINT nNewPos = (UINT)
                        ( ((float) rcCtrl.top / (float) nExtra) * iMax);

                SetScrollPos(hwndClip,SB_VERT,nNewPos,TRUE);
                ProcessScrollBar(hwndClip,MAKELPARAM(SB_THUMBTRACK,nNewPos), TRUE);
                return;
        }
}


VOID CPolicySnapIn::ProcessScrollBar(HWND hWnd,WPARAM wParam,BOOL bVert)
{
        UINT nPos = GetScrollPos(hWnd,bVert ? SB_VERT : SB_HORZ);
        RECT rcParent,rcChild;
        POLICYDLGINFO * pdi;
        LPSETTINGSINFO lpSettingsInfo;

        // get instance-specific struct from dialog

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(GetParent(hWnd), DWLP_USER);

        if (!lpSettingsInfo)
            return;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return;

        if (LOWORD(wParam) == SB_ENDSCROLL)
            return;

        switch (LOWORD(wParam)) {

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                        nPos = HIWORD(wParam);
                        break;

                case SB_TOP:
                        nPos = 0;
                        break;

                case SB_BOTTOM:
                        nPos = 100;
                        break;

                case SB_LINEUP:
                        if (nPos >= 10)
                            nPos -= 10;
                        else
                            nPos = 0;
                        break;

                case SB_LINEDOWN:
                        if (nPos <= 90)
                            nPos += 10;
                        else
                            nPos = 100;
                        break;

                case SB_PAGEUP:
                        if (nPos >= 30)
                            nPos -= 30;
                        else
                            nPos = 0;
                        break;

                case SB_PAGEDOWN:
                        if (nPos <= 70)
                            nPos += 30;
                        else
                            nPos = 100;
                        break;
        }

        SetScrollPos(hWnd,bVert ? SB_VERT : SB_HORZ,nPos,TRUE);

        GetClientRect(hWnd,&rcParent);
        GetClientRect(pdi->hwndSettings,&rcChild);

        if (bVert)
        {
            SetWindowPos(pdi->hwndSettings,NULL,0,-(int) ((( (float)
                    (rcChild.bottom-rcChild.top)-(rcParent.bottom-rcParent.top))
                    /100.0) * (float) nPos),rcChild.right,rcChild.bottom,SWP_NOZORDER |
                    SWP_NOSIZE);
        }
        else
        {
            SetWindowPos(pdi->hwndSettings,NULL,-(int) ((( (float)
                    (rcChild.right-rcChild.left)-(rcParent.right-rcParent.left))
                    /100.0) * (float) nPos),rcChild.top, rcChild.right,rcChild.bottom,SWP_NOZORDER |
                    SWP_NOSIZE);
        }
}


/*******************************************************************

        NAME:           FreeSettingsControls

        SYNOPSIS:       Frees all settings controls

********************************************************************/
VOID CPolicySnapIn::FreeSettingsControls(HWND hDlg)
{
     UINT nIndex;
     HGLOBAL hData;
     POLICYDLGINFO * pdi;
     LPSETTINGSINFO lpSettingsInfo;

     // get instance-specific struct from dialog

     lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

     if (!lpSettingsInfo)
         return;

     pdi = lpSettingsInfo->pdi;

     if (!pdi)
         return;

     for (nIndex=0;nIndex<pdi->nControls;nIndex++) {

         if (pdi->pControlTable[nIndex].dwType == STYPE_LISTBOX)
         {
            hData = (HGLOBAL) GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd,
                                             GWLP_USERDATA);

            if (hData)
            {
                GlobalFree (hData);
            }
         }

         DestroyWindow(pdi->pControlTable[nIndex].hwnd);
     }

     pdi->pCurrentSettings = NULL;
     pdi->nControls = 0;

     SetScrollRange(pdi->hwndSettings,SB_VERT,0,0,TRUE);
     SetScrollRange(pdi->hwndSettings,SB_HORZ,0,0,TRUE);
}

/*******************************************************************

        NAME:           CreateSettingsControls

        SYNOPSIS:       Creates controls in settings window

        NOTES:          Looks at a table of SETTINGS structs to determine
                                type of control to create and type-specific information.
                                For some types, more than one control can be created
                                (for instance, edit fields get a static control with
                                the title followed by an edit field control).

        ENTRY:          hDlg - owner dialog
                                hTable - table of SETTINGS structs containing setting
                                        control information

********************************************************************/
BOOL CPolicySnapIn::CreateSettingsControls(HWND hDlg,SETTINGS * pSetting,BOOL fEnable)
{
        LPBYTE pObjectData;
        POLICYDLGINFO * pdi;
        UINT xMax=0,yStart=SC_YSPACING,nHeight,nWidth,yMax,xWindowMax;
        HWND hwndControl,hwndBuddy,hwndParent;
        RECT rcParent;
        DWORD dwType, dwStyle;
        UINT uEnable = (fEnable ? 0 : WS_DISABLED);
        WINDOWPLACEMENT wp;
        LPSETTINGSINFO lpSettingsInfo;


        // get instance-specific struct from dialog

        lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

        if (!lpSettingsInfo)
            return FALSE;

        pdi = lpSettingsInfo->pdi;

        if (!pdi)
            return FALSE;

        wp.length = sizeof(wp);
        if (!GetWindowPlacement(GetDlgItem(hDlg,IDC_POLICY_SETTINGS),&wp))
                return FALSE;
        xWindowMax = wp.rcNormalPosition.right - wp.rcNormalPosition.left;

        pdi->pCurrentSettings = pSetting;

        while (pSetting) {

                pObjectData = GETOBJECTDATAPTR(pSetting);

                dwType = pSetting->dwType & STYPE_MASK;
                nWidth = 0;
                nHeight = 0;

                switch (dwType) {

                        case STYPE_TEXT:

                                // create static text control
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        (TCHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_STATIC | uEnable,0,
                                        yStart,0,15,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,(TCHAR *) (GETNAMEPTR(pSetting))
                                        ,SC_XSPACING,yStart,0,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                yStart += nHeight + SC_YSPACING;
                                nWidth += SC_XSPACING;

                                break;

                        case STYPE_CHECKBOX:

                                // create checkbox control
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szBUTTON,
                                        (TCHAR *) (GETNAMEPTR(pSetting)),0,SSTYLE_CHECKBOX | uEnable,
                                        0,yStart,200,nHeight,STYPE_CHECKBOX,pSetting->uDataIndex,
                                        pSetting, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                nWidth = 20;
                                AdjustWindowToText(hwndControl,(TCHAR *) (GETNAMEPTR(pSetting))
                                        ,SC_XSPACING,yStart,0,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                yStart += nHeight + SC_YSPACING;
                                nWidth += SC_XSPACING;
                                break;

                        case STYPE_EDITTEXT:
                        case STYPE_COMBOBOX:

                                // create static text with setting name
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,SSTYLE_STATIC | uEnable,0,0,0,0,
                                        STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,
                                        &nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                nWidth += SC_XSPACING + 5;

                                if (nWidth + SC_EDITWIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                // create edit field or combo box control
                                if (dwType == STYPE_EDITTEXT) {
                                        hwndControl = CreateSetting(pdi,(TCHAR *) szEDIT,(TCHAR *) g_szNull,
                                                WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_EDITWIDTH,nHeight,
                                                STYPE_EDITTEXT,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                } else {

                                        dwStyle = SSTYLE_COMBOBOX | uEnable;

                                        if (pSetting->dwFlags & DF_NOSORT) {
                                            dwStyle &= ~CBS_SORT;
                                        }

                                        hwndControl = CreateSetting(pdi,(TCHAR *) szCOMBOBOX,(TCHAR *)g_szNull,
                                                WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*6,
                                                STYPE_COMBOBOX,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                }
                                if (!hwndControl) return FALSE;

                                // limit the text length appropriately
                                if (dwType == STYPE_COMBOBOX) {
                                    SendMessage(hwndControl,CB_LIMITTEXT,
                                            (WPARAM) ((POLICYCOMBOBOXINFO *) pObjectData)->nMaxLen,0L);
                                } else {
                                    SendMessage(hwndControl,EM_SETLIMITTEXT,
                                            (WPARAM) ((EDITTEXTINFO *) pObjectData)->nMaxLen,0L);
                                }

                                if (dwType == STYPE_COMBOBOX &&
                                        ((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions)
                                        InsertComboboxItems(hwndControl,(TCHAR *) ((LPBYTE)pSetting +
                                                ((POLICYCOMBOBOXINFO *) pObjectData)->uOffsetSuggestions));


                                yStart += (UINT) ((float) nHeight*1.3) + SC_YSPACING;
                                nWidth += SC_EDITWIDTH;

                                break;

                        case STYPE_NUMERIC:
                                // create static text for setting
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,(yStart + SC_YTEXTDROP),SC_YPAD,
                                        &nWidth,&nHeight, lpSettingsInfo->hFontDlg);

                                nWidth += SC_XSPACING + 5;

                                // create edit field
                                if (!(hwndBuddy = CreateSetting(pdi,(TCHAR *) szEDIT,
                                        (TCHAR *) g_szNull,WS_EX_CLIENTEDGE,SSTYLE_EDITTEXT | uEnable,nWidth,yStart,SC_UPDOWNWIDTH,
                                        nHeight,STYPE_NUMERIC,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                //SendMessage(hwndBuddy,EM_LIMITTEXT,4,0);

                                nWidth += SC_UPDOWNWIDTH;

                                // create spin (up-down) control if specifed
                                if (((NUMERICINFO *)pObjectData)->uSpinIncrement)  {
                                        UDACCEL udAccel = {0,0};
                                        UINT nMax,nMin;
                                        if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szUPDOWN,
                                                (TCHAR *) g_szNull,WS_EX_CLIENTEDGE,SSTYLE_UPDOWN | UDS_SETBUDDYINT | UDS_ALIGNRIGHT | UDS_UNSIGNED | uEnable,nWidth,yStart,SC_UPDOWNWIDTH2,
                                                nHeight,STYPE_TEXT | STYPE_NUMERIC,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;


                                        nWidth += SC_UPDOWNWIDTH2;

                                        nMax = ((NUMERICINFO *) pObjectData)->uMaxValue;
                                        nMin = ((NUMERICINFO *) pObjectData)->uMinValue;
                                        udAccel.nInc = ((NUMERICINFO *) pObjectData)->uSpinIncrement;

                                        SendMessage(hwndControl,UDM_SETBUDDY,(WPARAM) hwndBuddy,0L);
                                        SendMessage(hwndControl,UDM_SETRANGE32,(WPARAM) nMin,(LPARAM) nMax);
                                        SendMessage(hwndControl,UDM_SETACCEL,1,(LPARAM) &udAccel);
                                }
                                yStart += nHeight + SC_YSPACING;

                                break;

                        case STYPE_DROPDOWNLIST:

                                // create text description
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,
                                        GETNAMEPTR(pSetting),SC_XSPACING,yStart,SC_YPAD,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                nWidth += SC_XLEADING + 5;

                                if (nWidth + SC_EDITWIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                dwStyle = SSTYLE_DROPDOWNLIST | uEnable;

                                    if (pSetting->dwFlags & DF_NOSORT) {
                                    dwStyle &= ~CBS_SORT;
                                }

                                // create drop down listbox
                                hwndControl = CreateSetting(pdi,(TCHAR *) szCOMBOBOX,(TCHAR *) g_szNull,
                                WS_EX_CLIENTEDGE,dwStyle,nWidth,yStart,SC_EDITWIDTH,nHeight*6,
                                                STYPE_DROPDOWNLIST,pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                if (!hwndControl) return FALSE;
                                nWidth += SC_EDITWIDTH;

                                {
                                        // insert dropdown list items into control
                                        UINT uOffset = pSetting->uOffsetObjectData,nIndex=0;
                                        DROPDOWNINFO * pddi;
                                        int iSel;

                                        while (uOffset) {
                                                pddi = (DROPDOWNINFO *) ( (LPBYTE) pSetting + uOffset);
                                                iSel=(int)SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM)
                                                        ((LPBYTE) pSetting + pddi->uOffsetItemName));
                                                if (iSel<0) return FALSE;
                                                SendMessage(hwndControl,CB_SETITEMDATA,iSel,nIndex);
                                                nIndex++;
                                                uOffset = pddi->uOffsetNextDropdowninfo;
                                        }
                                }

                                yStart += (UINT) ((float) nHeight*1.3) + 1;
                                break;

                        case STYPE_LISTBOX:
                                {
                                TCHAR szShow[50];

                                // create static text with description
                                if (!(hwndControl = CreateSetting(pdi,(TCHAR *) szSTATIC,
                                        GETNAMEPTR(pSetting),0,
                                        SSTYLE_STATIC | uEnable,0,0,0,0,STYPE_TEXT,NO_DATA_INDEX,0, lpSettingsInfo->hFontDlg)))
                                        return FALSE;
                                AdjustWindowToText(hwndControl,GETNAMEPTR(pSetting),SC_XSPACING,yStart,
                                        SC_YPAD,&nWidth,&nHeight, lpSettingsInfo->hFontDlg);
                                nWidth += SC_XLEADING;

                                if (nWidth + LISTBOX_BTN_WIDTH> xWindowMax) {
                                        // if next control will stick out of settings window,
                                        // put it on the next line
                                        if (nWidth > xMax)
                                                xMax = nWidth;
                                        yStart += nHeight + SC_YCONTROLWRAP;
                                        nWidth = SC_XINDENT;
                                } else {
                                     SetWindowPos(hwndControl,NULL,SC_XSPACING,(yStart + SC_YTEXTDROP),0,0,SWP_NOZORDER | SWP_NOSIZE);
                                }

                                // create pushbutton to show listbox contents
                                LoadString(g_hInstance, IDS_LISTBOX_SHOW, szShow, ARRAYSIZE(szShow));
                                hwndControl = CreateSetting(pdi,(TCHAR *) szBUTTON,szShow,0,
                                        SSTYLE_LBBUTTON | uEnable,nWidth+5,yStart,
                                        LISTBOX_BTN_WIDTH,nHeight,STYPE_LISTBOX,
                                        pSetting->uDataIndex,pSetting, lpSettingsInfo->hFontDlg);
                                if (!hwndControl) return FALSE;
                                SetWindowLongPtr(hwndControl,GWLP_USERDATA,0);
                                nWidth += LISTBOX_BTN_WIDTH + SC_XLEADING;

                                yStart += nHeight+1;
                                }
                }

                if (nWidth > xMax)
                        xMax = nWidth;
                pSetting = (SETTINGS *) pSetting->pNext;
        }

        yMax = yStart - 1;

        SetWindowPos(pdi->hwndSettings,NULL,0,0,xMax,yMax,SWP_NOZORDER);
        hwndParent = GetParent(pdi->hwndSettings);
        GetClientRect(hwndParent,&rcParent);

        if (yMax > (UINT) rcParent.bottom-rcParent.top) {
                SetScrollRange(hwndParent,SB_VERT,0,100,TRUE);
                SetScrollPos(hwndParent,SB_VERT,0,TRUE);
                ShowScrollBar(hwndParent,SB_VERT, TRUE);
        } else {
                SetScrollRange(hwndParent,SB_VERT,0,0,TRUE);
                ShowScrollBar(hwndParent,SB_VERT, FALSE);
        }

        if (xMax > (UINT) rcParent.right-rcParent.left) {
                SetScrollRange(hwndParent,SB_HORZ,0,100,TRUE);
                SetScrollPos(hwndParent,SB_HORZ,0,TRUE);
                ShowScrollBar(hwndParent,SB_HORZ, TRUE);
        } else {
                SetScrollRange(hwndParent,SB_HORZ,0,0,TRUE);
                ShowScrollBar(hwndParent,SB_HORZ, FALSE);
        }


        return TRUE;
}

VOID CPolicySnapIn::InsertComboboxItems(HWND hwndControl,TCHAR * pSuggestionList)
{
        while (*pSuggestionList) {
                SendMessage(hwndControl,CB_ADDSTRING,0,(LPARAM) pSuggestionList);
                pSuggestionList += lstrlen(pSuggestionList) + 1;
        }
}


/*******************************************************************

        NAME:           CreateSettings

        SYNOPSIS:       Creates a control and add it to the table of settings
                                controls

********************************************************************/
HWND CPolicySnapIn::CreateSetting(POLICYDLGINFO * pdi,TCHAR * pszClassName,TCHAR * pszWindowName,
        DWORD dwExStyle,DWORD dwStyle,int x,int y,int cx,int cy,DWORD dwType,UINT uIndex,
        SETTINGS * pSetting, HFONT hFontDlg)
{
        HWND hwndControl;

        if (!(hwndControl = CreateWindowEx(WS_EX_NOPARENTNOTIFY | dwExStyle,
                pszClassName,pszWindowName,dwStyle,x,y,cx,cy,pdi->hwndSettings,NULL,
                g_hInstance,NULL))) return NULL;

        if (!SetWindowData(pdi,hwndControl,dwType,uIndex,pSetting)) {
                DestroyWindow(hwndControl);
                return NULL;
        }

        SendMessage(hwndControl,WM_SETFONT,(WPARAM) hFontDlg,MAKELPARAM(TRUE,0));

        return hwndControl;
}

BOOL CPolicySnapIn::SetWindowData(POLICYDLGINFO * pdi,HWND hwndControl,DWORD dwType,
        UINT uDataIndex,SETTINGS * pSetting)
{
        POLICYCTRLINFO PolicyCtrlInfo;
        int iCtrl;

        PolicyCtrlInfo.hwnd = hwndControl;
        PolicyCtrlInfo.dwType = dwType;
        PolicyCtrlInfo.uDataIndex = uDataIndex;
        PolicyCtrlInfo.pSetting = pSetting;

        iCtrl = AddControlHwnd(pdi,&PolicyCtrlInfo);
        if (iCtrl < 0) return FALSE;

        SetWindowLong(hwndControl,GWL_ID,iCtrl + IDD_SETTINGCTRL);

        return TRUE;
}

int CPolicySnapIn::AddControlHwnd(POLICYDLGINFO * pdi,POLICYCTRLINFO * pPolicyCtrlInfo)
{
        int iRet;
        DWORD dwNeeded;
        POLICYCTRLINFO * pTemp;

        // grow table if necessary
        dwNeeded = (pdi->nControls+1) * sizeof(POLICYCTRLINFO);
        if (dwNeeded > pdi->dwControlTableSize) {
                pTemp = (POLICYCTRLINFO *) LocalReAlloc(pdi->pControlTable,
                                     dwNeeded,LMEM_ZEROINIT | LMEM_MOVEABLE);
                if (!pTemp) return (-1);
                pdi->pControlTable = pTemp;
                pdi->dwControlTableSize = dwNeeded;
        }

        pdi->pControlTable[pdi->nControls] = *pPolicyCtrlInfo;

        iRet = (int) pdi->nControls;

        (pdi->nControls)++;

        return iRet;
}

BOOL CPolicySnapIn::AdjustWindowToText(HWND hWnd,TCHAR * szText,UINT xStart,UINT yStart,
        UINT yPad,UINT * pnWidth,UINT * pnHeight, HFONT hFontDlg)
{
        SIZE size;

        if (GetTextSize(hWnd,szText,&size, hFontDlg))
        {
            *pnHeight =size.cy + yPad;
            *pnWidth += size.cx;
            SetWindowPos(hWnd,NULL,xStart,yStart,*pnWidth,*pnHeight,SWP_NOZORDER);
        }

        return FALSE;
}

BOOL CPolicySnapIn::GetTextSize(HWND hWnd,TCHAR * szText,SIZE * pSize, HFONT hFontDlg)
{
        HDC hDC;
        BOOL fRet;

        if (!(hDC = GetDC(hWnd))) return FALSE;

        SelectObject(hDC, hFontDlg);
        fRet=GetTextExtentPoint(hDC,szText,lstrlen(szText),pSize);

        ReleaseDC(hWnd,hDC);

        return fRet;
}


//*************************************************************
//
//  SaveSettings()
//
//  Purpose:    Saves the results of the settings
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT CPolicySnapIn::SaveSettings(HWND hDlg)
{
     UINT nIndex;
     POLICYDLGINFO * pdi;
     LPSETTINGSINFO lpSettingsInfo;
     SETTINGS * pSetting;
     HKEY hKeyRoot;
     DWORD dwTemp;
     UINT uRet = ERROR_SUCCESS, uPolicyState;
     int iSel, iIndex;
     LPTSTR lpBuffer;
     BOOL fTranslated;
     NUMERICINFO * pNumericInfo;
     HRESULT hr;
     LPBYTE pObjectData;
     BOOL fErase;
     DROPDOWNINFO * pddi;
     GUID guidRegistryExt = REGISTRY_EXTENSION_GUID;
     GUID guidSnapinMach = CLSID_PolicySnapInMachine;
     GUID guidSnapinUser = CLSID_PolicySnapInUser;
     GUID ClientGUID;
     LPTSTR lpClientGUID;
     TCHAR szFormat[100];
     TCHAR szMsg[150];
     BOOL  bFoundNone; // used in the listbox case alone


     //
     // Check for RSOP mode
     //

     if (m_pcd->m_bRSOP)
     {
        DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::SaveSettings: Running in RSOP mode, nothing to save.")));
        return S_OK;
     }


     //
     // Check the dirty bit
     //

     if (!m_bDirty)
     {
        DebugMsg((DM_VERBOSE, TEXT("CPolicySnapIn::SaveSettings: No changes detected.  Exiting successfully.")));
        return S_OK;
     }


     // get instance-specific struct from dialog

     lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

     if (!lpSettingsInfo)
         return E_FAIL;

     pdi = lpSettingsInfo->pdi;

     if (!pdi)
         return E_FAIL;

    if (m_pcd->m_pGPTInformation->GetRegistryKey(
                 (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                      &hKeyRoot) != S_OK)
    {
        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to get registry key handle.")));
        return S_FALSE;
    }


    //
    // Get the policy state
    //

    if (IsDlgButtonChecked (hDlg, IDC_NOCONFIG) == BST_CHECKED)
    {
        uPolicyState = BST_INDETERMINATE;
    }
    else if (IsDlgButtonChecked (hDlg, IDC_ENABLED) == BST_CHECKED)
    {
        uPolicyState = BST_CHECKED;
    }
    else
    {
        uPolicyState = BST_UNCHECKED;
    }


    if (uPolicyState == BST_INDETERMINATE)
    {
        fErase = TRUE;
    }
    else
    {
        fErase = FALSE;
    }

    //
    // Validate the state of the parts
    //

    for (nIndex=0;nIndex<pdi->nControls;nIndex++)
    {
        pSetting = pdi->pControlTable[nIndex].pSetting;

        if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX)
        {
            switch (pdi->pControlTable[nIndex].dwType)
            {

            case STYPE_CHECKBOX:
                if (BST_CHECKED == uPolicyState) 
                {
                    pObjectData = GETOBJECTDATAPTR(pSetting);

                    if (!pObjectData) 
                    {
                        return E_INVALIDARG;
                    }
                }
                
                break;

            case STYPE_EDITTEXT:
            case STYPE_COMBOBOX:

                if (uPolicyState == BST_CHECKED)
                {
                    dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                         WM_GETTEXTLENGTH,0,0);

                    if (!dwTemp)
                    {
                        if (pSetting->dwFlags & DF_REQUIRED)
                        {
                            m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                               MB_ICONINFORMATION,MB_OK);
                            RegCloseKey (hKeyRoot);
                            return E_FAIL;
                        }
                    }
                }

                break;

            case STYPE_NUMERIC:

                if (uPolicyState == BST_CHECKED)
                {
                    if (pSetting->dwFlags & DF_REQUIRED)
                    {
                        dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                             WM_GETTEXTLENGTH,0,0);

                        if (!dwTemp)
                        {
                            if (pSetting->dwFlags & DF_REQUIRED)
                            {
                                m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                                   MB_ICONINFORMATION,MB_OK);
                                RegCloseKey (hKeyRoot);
                                return E_FAIL;
                            }
                        }
                    }

                    uRet=GetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                       &fTranslated,FALSE);

                    if (!fTranslated)
                    {
                        m_pcd->MsgBoxParam(hDlg,IDS_INVALIDNUM,
                                           GETNAMEPTR(pSetting),MB_ICONINFORMATION,
                                           MB_OK);
                        SetFocus(pdi->pControlTable[nIndex].hwnd);
                        SendMessage(pdi->pControlTable[nIndex].hwnd,
                                EM_SETSEL,0,-1);
                        RegCloseKey (hKeyRoot);
                        return E_FAIL;
                    }

                }
                
                break;

            case STYPE_DROPDOWNLIST:

                if (uPolicyState == BST_CHECKED)
                {
                    iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                            CB_GETCURSEL,0,0L);
                    iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                            CB_GETITEMDATA,iSel,0L);

                    if (iSel < 0)
                    {
                        m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                MB_ICONINFORMATION,MB_OK);
                        SetFocus(pdi->pControlTable[nIndex].hwnd);
                        RegCloseKey (hKeyRoot);
                        return E_FAIL;
                    }
                }
                else
                {
                    iSel = 0;
                }

                pddi = (DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting);
                iIndex = 0;

                // walk the chain of DROPDOWNINFO structs to find the entry that
                // we want to write.  (for value n, find the nth struct)
                while (iIndex < iSel) 
                {
                    // selected val is higher than # of structs in chain,
                    // should never happen but check just in case...
                    if (!pddi->uOffsetNextDropdowninfo) 
                    {
                        RegCloseKey (hKeyRoot);
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    pddi = (DROPDOWNINFO *)
                    ((LPBYTE) pSetting + pddi->uOffsetNextDropdowninfo);
                    iIndex++;
                }

                break;

            case STYPE_LISTBOX:

                HGLOBAL hData = (HGLOBAL)GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA);
                BOOL    bEnabled;
                WCHAR   *pszData;

                bFoundNone = FALSE;
                bEnabled = (uPolicyState == BST_INDETERMINATE) ? FALSE : TRUE;

                if ((bEnabled) && (!hData)) 
                {
                    bFoundNone = TRUE;
                }
                else if (bEnabled) 
                {
                    pszData = (TCHAR *)GlobalLock (hData);
                    GlobalUnlock(hData);

                    // if there are no items at all
                    if (!(*pszData)) 
                    {
                        bFoundNone = TRUE;
                    }
                    pszData = NULL;
                }

                // if the policy is enabled and no values are set
                if ((uPolicyState == BST_CHECKED) && (bFoundNone)) 
                {
                    m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                       MB_ICONINFORMATION,MB_OK);
                    SetFocus(pdi->pControlTable[nIndex].hwnd);
                    RegCloseKey (hKeyRoot);
                    return E_FAIL;
                }

                break;
            }
        }
    }

    //
    // Save the overall policy state
    //

    if (uPolicyState != BST_INDETERMINATE)
    {
        if (uPolicyState == BST_CHECKED)
            dwTemp = 1;
        else
            dwTemp = 0;


        if (dwTemp && m_pCurrentPolicy->uOffsetValue_On)
        {
            uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                            (STATEVALUE *) ((LPBYTE) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetValue_On),
                            fErase);
        }
        else if (!dwTemp && m_pCurrentPolicy->uOffsetValue_Off)
        {
                uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                        (STATEVALUE *) ((LPBYTE) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetValue_Off),
                        fErase);
        }
        else
        {
            if (m_pCurrentPolicy->uOffsetValueName)
            {
                uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                        (TABLEENTRY *)m_pCurrentPolicy,dwTemp,fErase,FALSE);
            }
            else
            {
                uRet = ERROR_SUCCESS;
            }
        }


        if (uRet == ERROR_SUCCESS)
        {
            uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)m_pCurrentPolicy,
                    GETKEYNAMEPTR(m_pCurrentPolicy),dwTemp,FALSE, !dwTemp, TRUE);
        }
        else
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
        }
    }
    else
    {
        if (m_pCurrentPolicy->uOffsetValueName)
        {
            uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(m_pCurrentPolicy),GETVALUENAMEPTR(m_pCurrentPolicy),
                    (TABLEENTRY *)m_pCurrentPolicy,0,TRUE,FALSE);
        }

        if (uRet == ERROR_SUCCESS)
        {
            uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)m_pCurrentPolicy,
                    GETKEYNAMEPTR(m_pCurrentPolicy),0,TRUE,FALSE, TRUE);
        }

    }

    //
    // Save the state of the parts
    //

    for (nIndex=0;nIndex<pdi->nControls;nIndex++)
    {
        pSetting = pdi->pControlTable[nIndex].pSetting;

        if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX)
        {

            switch (pdi->pControlTable[nIndex].dwType)
            {

                case STYPE_CHECKBOX:

                    dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,BM_GETCHECK,0,0L);

                    pObjectData = GETOBJECTDATAPTR(pSetting);

                    if (!pObjectData) 
                    {
                        if (BST_CHECKED == uPolicyState) 
                        {
                            return E_INVALIDARG;
                        }
                        else
                        {
                            break;
                        }
                    }

                    if (dwTemp && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_On) 
                    {
                        uRet= WriteCustomValue(hKeyRoot,
                                               GETKEYNAMEPTR(pSetting),
                                               GETVALUENAMEPTR(pSetting),
                                               (STATEVALUE *) ((LPBYTE) pSetting + ((CHECKBOXINFO *) pObjectData)->uOffsetValue_On),
                                               fErase);
                    } 
                    else if (!dwTemp && ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off) 
                    {
                        uRet= WriteCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),
                                               GETVALUENAMEPTR(pSetting),
                                               (STATEVALUE *) ((LPBYTE) pSetting + ((CHECKBOXINFO *) pObjectData)->uOffsetValue_Off),
                                               fErase);
                    }
                    else 
                    {
                        uRet=WriteStandardValue(hKeyRoot,
                                                GETKEYNAMEPTR(pSetting),
                                                GETVALUENAMEPTR(pSetting),
                                                (TABLEENTRY *)pSetting,
                                                dwTemp,
                                                fErase,
                                                FALSE);
                    }

                    if (uRet == ERROR_SUCCESS) 
                    {
                        uRet = ProcessCheckboxActionLists(hKeyRoot,(TABLEENTRY *)pSetting,
                                                          GETKEYNAMEPTR(pSetting),
                                                          dwTemp,
                                                          fErase,
                                                          (uPolicyState == BST_UNCHECKED),
                                                          FALSE);
                    } 
                    else 
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }

                    break;

                case STYPE_EDITTEXT:
                case STYPE_COMBOBOX:

                    if (uPolicyState == BST_CHECKED)
                    {
                        dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                             WM_GETTEXTLENGTH,0,0);

                        if (!dwTemp)
                        {
                            if (pSetting->dwFlags & DF_REQUIRED)
                            {
                                m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                                   MB_ICONINFORMATION,MB_OK);
                                RegCloseKey (hKeyRoot);
                                return E_FAIL;
                            }
                        }

                        lpBuffer = (LPTSTR) LocalAlloc (LPTR, (dwTemp + 1) * sizeof(TCHAR));

                        if (lpBuffer)
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,WM_GETTEXT,
                                    (dwTemp+1),(LPARAM) lpBuffer);

                            uRet = WriteCustomValue_W(hKeyRoot,
                                                      GETKEYNAMEPTR(pSetting),
                                                      GETVALUENAMEPTR(pSetting),
                                                      lpBuffer, 0, pSetting->dwFlags, FALSE);

                            if (uRet != ERROR_SUCCESS)
                            {
                                DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                            }

                            LocalFree (lpBuffer);
                        }
                        else
                        {
                            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to allocate memory with %d."),
                                     GetLastError()));
                        }
                    }
                    else
                    {
                        WriteCustomValue_W(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                           (LPTSTR)g_szNull,0,
                                           (uPolicyState == BST_UNCHECKED) ? VF_DELETE : 0,
                                           fErase);
                    }

                    break;

                case STYPE_NUMERIC:

                    if (uPolicyState == BST_CHECKED)
                    {
                        if (pSetting->dwFlags & DF_REQUIRED)
                        {
                            dwTemp = (DWORD)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                                 WM_GETTEXTLENGTH,0,0);

                            if (!dwTemp)
                            {
                                if (pSetting->dwFlags & DF_REQUIRED)
                                {
                                    m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                                       MB_ICONINFORMATION,MB_OK);
                                    RegCloseKey (hKeyRoot);
                                    return E_FAIL;
                                }
                            }
                        }

                        uRet=GetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                           &fTranslated,FALSE);

                        // validate for max and min
                        pNumericInfo = (NUMERICINFO *) GETOBJECTDATAPTR(pSetting);

                        if (pNumericInfo && uRet < pNumericInfo->uMinValue)
                        {
                            LoadString(g_hInstance, IDS_NUMBERTOOSMALL, szFormat, ARRAYSIZE(szFormat));
                            hr = StringCchPrintf(szMsg, ARRAYSIZE(szMsg), szFormat, uRet, pNumericInfo->uMinValue, pNumericInfo->uMinValue, uRet);
                            ASSERT(SUCCEEDED(hr));

                            m_pcd->MsgBoxSz(hDlg,szMsg, MB_ICONINFORMATION, MB_OK);
                            uRet = pNumericInfo->uMinValue;
                        }

                        if (pNumericInfo && uRet > pNumericInfo->uMaxValue)
                        {
                            LoadString(g_hInstance, IDS_NUMBERTOOLARGE, szFormat, ARRAYSIZE(szFormat));
                            hr = StringCchPrintf (szMsg, ARRAYSIZE(szMsg), szFormat, uRet, pNumericInfo->uMaxValue, pNumericInfo->uMaxValue, uRet);
                            ASSERT(SUCCEEDED(hr));

                            m_pcd->MsgBoxSz(hDlg,szMsg, MB_ICONINFORMATION, MB_OK);
                            uRet = pNumericInfo->uMaxValue;
                        }
                    }
                    else
                    {
                        uRet = 0;
                    }

                    uRet=WriteStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),
                                            GETVALUENAMEPTR(pSetting),
                                            (TABLEENTRY *)pSetting,uRet,
                                            fErase,(uPolicyState == BST_UNCHECKED) ? FALSE : TRUE);

                    if (uRet != ERROR_SUCCESS)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }

                    break;

                case STYPE_DROPDOWNLIST:

                    if (uPolicyState == BST_CHECKED)
                    {
                        iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                CB_GETCURSEL,0,0L);
                        iSel = (int)SendMessage(pdi->pControlTable[nIndex].hwnd,
                                CB_GETITEMDATA,iSel,0L);

                        if (iSel < 0)
                        {
                            m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(pdi->pControlTable[nIndex].hwnd);
                            RegCloseKey (hKeyRoot);
                            return E_FAIL;
                        }
                    }
                    else
                    {
                        iSel = 0;
                    }

                    pddi = (DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting);
                    iIndex = 0;

                    // walk the chain of DROPDOWNINFO structs to find the entry that
                    // we want to write.  (for value n, find the nth struct)
                    while (iIndex < iSel) {
                            // selected val is higher than # of structs in chain,
                            // should never happen but check just in case...
                            if (!pddi->uOffsetNextDropdowninfo) 
                            {
                                    RegCloseKey (hKeyRoot);
                                    return ERROR_NOT_ENOUGH_MEMORY;
                            }
                            pddi = (DROPDOWNINFO *)
                                    ((LPBYTE) pSetting + pddi->uOffsetNextDropdowninfo);
                            iIndex++;
                    }

                    uRet=WriteCustomValue_W(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                            (LPTSTR) ((LPBYTE)pSetting+pddi->uOffsetValue),pddi->dwValue,
                            pddi->dwFlags | ((uPolicyState == BST_UNCHECKED) ? VF_DELETE : 0),
                            fErase);

                    if (uRet == ERROR_SUCCESS && pddi->uOffsetActionList) {
                            uRet=WriteActionList(hKeyRoot,(ACTIONLIST *) ( (LPBYTE)
                                    pSetting + pddi->uOffsetActionList),GETKEYNAMEPTR(pSetting),
                                    fErase, (uPolicyState == BST_UNCHECKED));
                    }

                    if (uRet != ERROR_SUCCESS)
                    {
                        DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::SaveSettings: Failed to set registry value with %d."), uRet));
                    }
                    break;

                case STYPE_LISTBOX:

                    bFoundNone = FALSE;

                    SaveListboxData((HGLOBAL)GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA),
                                    pSetting, hKeyRoot, GETKEYNAMEPTR(pSetting), fErase,
                                    ((uPolicyState == BST_INDETERMINATE) ? FALSE : TRUE), 
                                    (uPolicyState == BST_CHECKED), &bFoundNone);

                    // if the policy is enabled and no values are set
                    if ((uPolicyState == BST_CHECKED) && (bFoundNone)) {
                        m_pcd->MsgBoxParam(hDlg,IDS_ENTRYREQUIRED,GETNAMEPTR(pSetting),
                                           MB_ICONINFORMATION,MB_OK);
                        SetFocus(pdi->pControlTable[nIndex].hwnd);
                        RegCloseKey (hKeyRoot);
                        return E_FAIL;
                    }

                    break;
            }


            if (pSetting->uOffsetClientExt)
            {
                lpClientGUID = (LPTSTR) ((BYTE *) pSetting + pSetting->uOffsetClientExt);

                StringToGuid (lpClientGUID, &ClientGUID);
                m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &ClientGUID,
                                                        m_pcd->m_bUserScope ? &guidSnapinUser
                                                                            : &guidSnapinMach );
            }
        }
    }

    hr = m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &guidRegistryExt,
                                            m_pcd->m_bUserScope ? &guidSnapinUser
                                                                : &guidSnapinMach );

    if (FAILED(hr))
    {
        LPTSTR lpError;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                          FORMAT_MESSAGE_IGNORE_INSERTS,
                          0, hr, 0, (LPTSTR) &lpError, 0, NULL))
        {
            m_pcd->MsgBoxParam(hDlg,IDS_POLICYCHANGEDFAILED,lpError,
                    MB_ICONERROR, MB_OK);

            LocalFree (lpError);
        }
    }

    if (m_pCurrentPolicy->uOffsetClientExt)
    {
        lpClientGUID = (LPTSTR) ((BYTE *) m_pCurrentPolicy + m_pCurrentPolicy->uOffsetClientExt);

        StringToGuid (lpClientGUID, &ClientGUID);
        m_pcd->m_pGPTInformation->PolicyChanged(!m_pcd->m_bUserScope, TRUE, &ClientGUID,
                                                m_pcd->m_bUserScope ? &guidSnapinUser
                                                                    : &guidSnapinMach );
    }

    RegCloseKey (hKeyRoot);


    SendMessage (m_hMsgWindow, WM_UPDATEITEM, 0, 0);

    if (SUCCEEDED(hr))
    {
        m_bDirty = FALSE;
        PostMessage (GetParent(hDlg), PSM_UNCHANGED, (WPARAM) hDlg, 0);
    }

    return S_OK;
}

VOID CPolicySnapIn::DeleteOldListboxData(SETTINGS * pSetting, HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName)
{
    HGLOBAL hData = NULL;
    LPTSTR lpData;
    HKEY hKey;
    TCHAR szValueName[MAX_PATH+1];
    INT nItem=1;
    LISTBOXINFO * pListboxInfo = (LISTBOXINFO *) GETOBJECTDATAPTR(pSetting);
    HRESULT hr = S_OK;

    //
    // Open the target registry key
    //

    if (RegOpenKeyEx (hkeyRoot, pszCurrentKeyName, 0, KEY_WRITE, &hKey) != ERROR_SUCCESS)
    {
        return;
    }


    //
    // Load the old listbox data
    //

    if (LoadListboxData((TABLEENTRY *) pSetting, hkeyRoot,
                        pszCurrentKeyName, NULL, &hData, NULL) == ERROR_SUCCESS)
    {

        if (hData)
        {
            //
            // Delete the listbox's old data
            //

            if ((lpData = (LPTSTR) GlobalLock(hData)))
            {
                while (*lpData) {

                    if (pSetting->dwFlags & DF_EXPLICITVALNAME)
                    {
                        // if explicit valuename flag set, entries are stored
                        // <value name>\0<value>\0....<value name>\0<value>\0\0
                        // otherwise, entries are stored
                        // <value>\0<value>\0....<value>\0

                        RegDeleteValue (hKey, lpData);
                        lpData += lstrlen(lpData) +1;
                        lpData += lstrlen(lpData) +1;
                    }
                    else
                    {
                        //
                        // Value name is either same as the data, or a prefix
                        // with a number
                        //

                        if (!pListboxInfo->uOffsetPrefix)
                        {
                            // if no prefix set, then name = data
                            RegDeleteValue (hKey, lpData);
                            lpData += lstrlen(lpData) +1;
                        }
                        else
                        {
                            // value name is "<prefix><n>" where n=1,2,etc.
                            hr = StringCchPrintf(szValueName, ARRAYSIZE(szValueName), TEXT("%s%lu"),(TCHAR *) ((LPBYTE)pSetting +
                                    pListboxInfo->uOffsetPrefix),nItem);
                            ASSERT(SUCCEEDED(hr));

                            RegDeleteValue (hKey, szValueName);
                            lpData += lstrlen(lpData) +1;
                            nItem++;
                        }
                    }
                }

                GlobalUnlock(hData);
            }

            GlobalFree (hData);
        }
    }

    RegCloseKey (hKey);
}

UINT CPolicySnapIn::SaveListboxData(HGLOBAL hData,SETTINGS * pSetting,HKEY hkeyRoot,
        TCHAR * pszCurrentKeyName,BOOL fErase,BOOL fMarkDeleted, BOOL bEnabled, BOOL * bFoundNone)
{
    UINT uOffset,uRet,nItem=1;
    HKEY hKey;
    TCHAR * pszData,* pszName;
    TCHAR szValueName[MAX_PATH+1];
    DWORD cbValueName, dwDisp;
    LISTBOXINFO * pListboxInfo = (LISTBOXINFO *) GETOBJECTDATAPTR(pSetting);
    HRESULT hr = S_OK;

    // these checks need to be done first before any other operations are done
    if ((bEnabled) && (!hData)) {
        *bFoundNone = TRUE;
        return ERROR_INVALID_PARAMETER;
    }

    if (bEnabled) {
        pszData = (TCHAR *)GlobalLock (hData);
        // if there are no items at all
        if (!(*pszData)) {
            *bFoundNone = TRUE;
            GlobalUnlock(hData);
            return ERROR_INVALID_PARAMETER;
        }
        
        GlobalUnlock(hData);
        pszData = NULL;
    }

    *bFoundNone = FALSE;

    if (fErase)
    {
        RegDelnode (hkeyRoot, pszCurrentKeyName);
        RegCleanUpValue (hkeyRoot, pszCurrentKeyName, TEXT("some value that won't exist"));
        return ERROR_SUCCESS;
    }

    if (pSetting->dwFlags & DF_ADDITIVE)
    {
        DeleteOldListboxData(pSetting, hkeyRoot, pszCurrentKeyName);
    }
    else
    {
        RegDelnode (hkeyRoot, pszCurrentKeyName);
    }

    uRet = RegCreateKeyEx (hkeyRoot,pszCurrentKeyName,0,NULL,
                           REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                           &hKey, &dwDisp);

    if (uRet != ERROR_SUCCESS)
        return uRet;


    uRet=ERROR_SUCCESS;

    if (fMarkDeleted)
    {
        //
        // Write a control code that will cause
        // all values under that key to be deleted when client downloads from the file.
        // Don't do this if listbox is additive (DF_ADDITIVE), in that case whatever
        // we write here will be dumped in along with existing values
        //

        if (!(pSetting->dwFlags & DF_ADDITIVE))
        {
            uRet=WriteRegistryStringValue(hkeyRoot,pszCurrentKeyName,
                                          (TCHAR *) szDELVALS,
                                          (TCHAR *) szNOVALUE, FALSE);
        }
    }


    if (hData) {
        pszData = (TCHAR *)GlobalLock (hData);

        while (*pszData && (uRet == ERROR_SUCCESS))
        {
            UINT nLen = lstrlen(pszData)+1;

            if (pSetting->dwFlags & DF_EXPLICITVALNAME)
            {
                // value name specified for each item
                pszName = pszData;      // value name
                pszData += nLen;        // now pszData points to value data
                nLen = lstrlen(pszData)+1;
            }
            else
            {
                // value name is either same as the data, or a prefix
                // with a number

                if (!pListboxInfo->uOffsetPrefix) {
                        // if no prefix set, then name = data
                        pszName = pszData;
                } else {
                        // value name is "<prefix><n>" where n=1,2,etc.
                        hr = StringCchPrintf(szValueName, ARRAYSIZE(szValueName), TEXT("%s%lu"),(TCHAR *) ((LPBYTE)pSetting +
                                pListboxInfo->uOffsetPrefix),nItem);
                        ASSERT(SUCCEEDED(hr));

                        pszName = szValueName;
                        nItem++;
                }
            }

            uRet=RegSetValueEx(hKey,pszName,0,
                               (pSetting->dwFlags & DF_EXPANDABLETEXT) ?
                               REG_EXPAND_SZ : REG_SZ, (LPBYTE) pszData,
                               (lstrlen(pszData) + 1) * sizeof(TCHAR));

            pszData += nLen;
        }
        GlobalUnlock (hData);
    }


    RegCloseKey(hKey);

    return uRet;
}

UINT CPolicySnapIn::ProcessCheckboxActionLists(HKEY hkeyRoot,TABLEENTRY * pTableEntry,
                                               TCHAR * pszCurrentKeyName,DWORD dwData,
                                               BOOL fErase, BOOL fMarkAsDeleted,
                                               BOOL bPolicy)
{

    UINT uOffsetActionList_On,uOffsetActionList_Off,uRet=ERROR_SUCCESS;


    if (bPolicy)
    {
        POLICY * pPolicy = (POLICY *) pTableEntry;

        uOffsetActionList_On = pPolicy->uOffsetActionList_On;
        uOffsetActionList_Off = pPolicy->uOffsetActionList_Off;
    }
    else
    {
        LPBYTE pObjectData = GETOBJECTDATAPTR(((SETTINGS *)pTableEntry));

        if (!pObjectData) {
            return ERROR_INVALID_PARAMETER;
        }

        uOffsetActionList_On = ((CHECKBOXINFO *) pObjectData)
                ->uOffsetActionList_On;
        uOffsetActionList_Off = ((CHECKBOXINFO *) pObjectData)
                ->uOffsetActionList_Off;
    }

    if (dwData)
    {
        if (uOffsetActionList_On)
        {
            uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                               ((LPBYTE) pTableEntry + uOffsetActionList_On),
                               pszCurrentKeyName,fErase,fMarkAsDeleted);
        }
    }
    else
    {
        if (uOffsetActionList_Off)
        {
            uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                               ((LPBYTE) pTableEntry + uOffsetActionList_Off),
                               pszCurrentKeyName,fErase,FALSE);
        }
        else
        {
            if (uOffsetActionList_On)
            {
                uRet = WriteActionList(hkeyRoot,(ACTIONLIST *)
                                   ((LPBYTE) pTableEntry + uOffsetActionList_On),
                                   pszCurrentKeyName,fErase,TRUE);
            }
        }
    }

    return uRet;
}

UINT CPolicySnapIn::WriteActionList(HKEY hkeyRoot,ACTIONLIST * pActionList,
        LPTSTR pszCurrentKeyName,BOOL fErase, BOOL fMarkAsDeleted)
{
    UINT nCount;
    LPTSTR pszValueName;
    LPTSTR pszValue=NULL;
    UINT uRet;

    ACTION * pAction = pActionList->Action;

    for (nCount=0;nCount < pActionList->nActionItems; nCount++)
    {
         //
         // Not every action in the list has to have a key name.  But if one
         // is specified, use it and it becomes the current key name for the
         // list until we encounter another one.
         //

         if (pAction->uOffsetKeyName)
         {
             pszCurrentKeyName = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetKeyName);
         }

         //
         // Every action must have a value name, enforced at parse time
         //

         pszValueName = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetValueName);

         //
         // String values have a string elsewhere in buffer
         //

         if (!pAction->dwFlags && pAction->uOffsetValue)
         {
             pszValue = (LPTSTR) ((LPBYTE)pActionList + pAction->uOffsetValue);
         }

         //
         // Write the value in list
         //

         uRet=WriteCustomValue_W(hkeyRoot,pszCurrentKeyName,pszValueName,
                 pszValue,pAction->dwValue,
                 pAction->dwFlags | (fMarkAsDeleted ? VF_DELETE : 0),
                 fErase);

         if (uRet != ERROR_SUCCESS)
         {
             return uRet;
         }

         pAction = (ACTION*) ((LPBYTE) pActionList + pAction->uOffsetNextAction);
    }

    return ERROR_SUCCESS;
}

/*******************************************************************

        NAME:           FindComboboxItemData

        SYNOPSIS:       Returns the index of item in combobox whose item data
                                is equal to nData.  Returns -1 if no items have data
                                which matches.

********************************************************************/
int CPolicySnapIn::FindComboboxItemData(HWND hwndControl,UINT nData)
{
    UINT nIndex;

    for (nIndex=0;nIndex<(UINT) SendMessage(hwndControl,CB_GETCOUNT,0,0L);
            nIndex++) {

        if ((UINT) SendMessage(hwndControl,CB_GETITEMDATA,nIndex,0L) == nData)
            return (int) nIndex;
    }

    return -1;
}


//*************************************************************
//
//  InitializeSettingsControls()
//
//  Purpose:    Initializes the settings controls
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

HRESULT CPolicySnapIn::InitializeSettingsControls(HWND hDlg, BOOL fEnable)
{
    UINT nIndex;
    POLICYDLGINFO * pdi;
    LPSETTINGSINFO lpSettingsInfo;
    SETTINGS * pSetting;
    HKEY hKeyRoot;
    DWORD dwTemp, dwData, dwFlags, dwFoundSettings;
    UINT uRet;
    int iSel;
    HGLOBAL hData;
    LPTSTR lpBuffer;
    BOOL fTranslated, fFound;
    NUMERICINFO * pNumericInfo;
    TCHAR szBuffer[MAXSTRLEN];
    TCHAR szNewValueName[MAX_PATH+1];
    BOOL bChangeableState;
    HRESULT hr = S_OK;

    // get instance-specific struct from dialog

    lpSettingsInfo = (LPSETTINGSINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpSettingsInfo)
        return E_FAIL;

    pdi = lpSettingsInfo->pdi;

    if (!pdi)
        return E_FAIL;


    if (m_pcd->m_bRSOP)
    {
        hKeyRoot = (HKEY) 1;
    }
    else
    {
        if (m_pcd->m_pGPTInformation->GetRegistryKey(
                     (m_pcd->m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                          &hKeyRoot) != S_OK)
        {
            DebugMsg((DM_WARNING, TEXT("CPolicySnapIn::InitializeSettingsControls: Failed to get registry key handle.")));
            return S_FALSE;
        }
    }


    for (nIndex=0;nIndex<pdi->nControls;nIndex++)
    {
        pSetting = pdi->pControlTable[nIndex].pSetting;

        if (pdi->pControlTable[nIndex].uDataIndex != NO_DATA_INDEX)
        {

            switch (pdi->pControlTable[nIndex].dwType)
            {

                case STYPE_CHECKBOX:

                    if (fEnable)
                    {
                        CHECKBOXINFO * pcbi = (CHECKBOXINFO *) GETOBJECTDATAPTR(pSetting);

                        //
                        // First look for custom on/off values
                        //

                        dwTemp = 0;
                        fFound = FALSE;
                        dwFoundSettings = 0;

                        if (pcbi->uOffsetValue_On)
                        {
                            if (CompareCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                       (STATEVALUE *) ((BYTE *) pSetting + pcbi->uOffsetValue_On),
                                       &dwFoundSettings, NULL))
                            {
                                dwTemp = 1;
                                fFound = TRUE;
                            }
                        }

                        if (!fFound && pcbi->uOffsetValue_Off)
                        {
                            if (CompareCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                    (STATEVALUE *) ((BYTE *) pSetting+ pcbi->uOffsetValue_Off),
                                    &dwFoundSettings, NULL))
                            {
                                dwTemp = 0;
                                fFound = TRUE;
                            }
                        }


                        //
                        // Look for standard values if custom values have not been specified
                        //

                        if (!fFound &&
                                ReadStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                (TABLEENTRY*)pSetting,&dwTemp,&dwFoundSettings,NULL))
                        {
                                fFound = TRUE;
                        }

                        //
                        // If still not found, check for the def checked flag
                        //

                        if (!fFound)
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                fFound = TRUE;
                                dwTemp = 1;
                            }
                        }

                        if (fFound && dwTemp)
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_CHECKED,0L);
                        }
                        else
                        {
                            SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_UNCHECKED,0L);
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,BM_SETCHECK,BST_UNCHECKED,0L);
                    }


                    break;

                case STYPE_EDITTEXT:
                case STYPE_COMBOBOX:

                    szBuffer[0] = TEXT('\0');

                    if (fEnable)
                    {
                        uRet = ReadRegistryStringValue(hKeyRoot,
                                                       GETKEYNAMEPTR(pSetting),
                                                       GETVALUENAMEPTR(pSetting),
                                                       szBuffer, ARRAYSIZE(szBuffer),NULL);

                        //
                        // Use default text if it exists
                        //

                        if (uRet != ERROR_SUCCESS)
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                LPTSTR pszDefaultText;
                                EDITTEXTINFO * peti = ((EDITTEXTINFO *) GETOBJECTDATAPTR(pSetting));

                                pszDefaultText = (LPTSTR) ((LPBYTE)pSetting + peti->uOffsetDefText);

                                hr = StringCchCopy (szBuffer, ARRAYSIZE(szBuffer), pszDefaultText);
                                ASSERT(SUCCEEDED(hr));
                            }
                        }
                    }

                    SendMessage (pdi->pControlTable[nIndex].hwnd, WM_SETTEXT,
                                 0, (LPARAM) szBuffer);
                    break;

                case STYPE_NUMERIC:

                    if (fEnable)
                    {
                        if (ReadStandardValue(hKeyRoot,GETKEYNAMEPTR(pSetting),GETVALUENAMEPTR(pSetting),
                                              (TABLEENTRY*)pSetting,&dwTemp,&dwFoundSettings,NULL) &&
                                              (!(dwFoundSettings & FS_DELETED)))
                        {
                            SetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                          dwTemp,FALSE);
                        }
                        else
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                NUMERICINFO * pni = (NUMERICINFO *)GETOBJECTDATAPTR(pSetting);

                                SetDlgItemInt(pdi->hwndSettings,nIndex+IDD_SETTINGCTRL,
                                              pni->uDefValue,FALSE);
                            }
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,WM_SETTEXT,0,(LPARAM) g_szNull);
                    }

                    break;

                case STYPE_DROPDOWNLIST:

                    if (fEnable)
                    {
                        dwData = 0;
                        dwFlags = 0;

                        if (ReadCustomValue(hKeyRoot,GETKEYNAMEPTR(pSetting),
                                            GETVALUENAMEPTR(pSetting),
                                            szBuffer,ARRAYSIZE(szBuffer),
                                            &dwData,&dwFlags, NULL) && (!(dwFlags & VF_DELETE)))
                        {
                            BOOL fMatch = FALSE;

                            //
                            // Walk the list of DROPDOWNINFO structs (one for each state),
                            // and see if the value we found matches the value for the state
                            //

                            if (pSetting->uOffsetObjectData)
                            {
                                DROPDOWNINFO * pddi = (DROPDOWNINFO *) GETOBJECTDATAPTR(pSetting);
                                iSel = 0;

                                do {
                                    if (dwFlags == pddi->dwFlags)
                                    {
                                        if (pddi->dwFlags & VF_ISNUMERIC)
                                        {
                                            if (dwData == pddi->dwValue)
                                                fMatch = TRUE;
                                        }
                                        else if (!pddi->dwFlags)
                                        {
                                            if (!lstrcmpi(szBuffer,(TCHAR *)((BYTE *)pSetting +
                                                pddi->uOffsetValue)))
                                                fMatch = TRUE;
                                        }
                                    }

                                    if (!pddi->uOffsetNextDropdowninfo || fMatch)
                                        break;

                                    pddi = (DROPDOWNINFO *) ( (BYTE *) pSetting +
                                            pddi->uOffsetNextDropdowninfo);
                                    iSel++;

                                } while (!fMatch);

                                if (fMatch) {
                                    SendMessage (pdi->pControlTable[nIndex].hwnd,
                                                 CB_SETCURSEL,
                                                 FindComboboxItemData(pdi->pControlTable[nIndex].hwnd, iSel),0);
                                }
                            }
                        }
                        else
                        {
                            if (pSetting->dwFlags & DF_USEDEFAULT)
                            {
                                DROPDOWNINFO * pddi = (DROPDOWNINFO *)GETOBJECTDATAPTR(pSetting);

                                if ( pddi )
                                {
                                    SendMessage (pdi->pControlTable[nIndex].hwnd, CB_SETCURSEL,
                                                FindComboboxItemData(pdi->pControlTable[nIndex].hwnd, pddi->uDefaultItemIndex),0);
                                }
                            }
                        }
                    }
                    else
                    {
                        SendMessage(pdi->pControlTable[nIndex].hwnd,CB_SETCURSEL,(UINT) -1,0L);
                    }

                    break;

                case STYPE_LISTBOX:

                    hData = (HGLOBAL) GetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA);

                    if (fEnable)
                    {
                        if (!hData)
                        {
                             if (LoadListboxData((TABLEENTRY *) pSetting, hKeyRoot,
                                                 GETKEYNAMEPTR(pSetting),NULL,
                                                 &hData, NULL) == ERROR_SUCCESS)
                             {
                                SetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA, (LONG_PTR)hData);
                             }
                        }
                    }
                    else
                    {
                        if (hData)
                        {
                            GlobalFree (hData);
                            SetWindowLongPtr (pdi->pControlTable[nIndex].hwnd, GWLP_USERDATA, 0);
                        }
                    }
                    break;
            }
        }


        //
        // Decide if the part should be enabled or not
        //
        // Special case text, numeric and listbox controls.
        // When the policy is disabled, text controls should still be enabled.
        // Numeric controls are special because they use the NO_DATA_INDEX
        // flag, so we need to check for those. Listbox controls are special
        // in RSOP only.
        //

        bChangeableState = TRUE;

        if (pdi->pControlTable[nIndex].uDataIndex == NO_DATA_INDEX)
        {
            if (pdi->pControlTable[nIndex].dwType != (STYPE_TEXT | STYPE_NUMERIC))
            {
                bChangeableState = FALSE;
            }
        }

        if (pdi->pControlTable[nIndex].dwType == STYPE_LISTBOX)
        {
            if (m_pcd->m_bRSOP)
            {
                bChangeableState = FALSE;
            }
        }


        if (bChangeableState)
    {
            if (m_pcd->m_bRSOP && (STYPE_EDITTEXT == pdi->pControlTable[nIndex].dwType) )
            {
                EnableWindow(pdi->pControlTable[nIndex].hwnd, TRUE);
                SendMessage( pdi->pControlTable[nIndex].hwnd, EM_SETREADONLY, TRUE, 0);
            }

            else
                EnableWindow(pdi->pControlTable[nIndex].hwnd, (m_pcd->m_bRSOP ? FALSE :fEnable));
            
        }

        else
            EnableWindow(pdi->pControlTable[nIndex].hwnd,TRUE);
    }
    
    if (!m_pcd->m_bRSOP)
    {
        RegCloseKey (hKeyRoot);
    }

    return S_OK;
}

VOID CPolicySnapIn::ShowListbox(HWND hParent,SETTINGS * pSettings)
{
    LISTBOXDLGINFO ListboxDlgInfo;

    ListboxDlgInfo.pCS = this;
    ListboxDlgInfo.pSettings = pSettings;
    ListboxDlgInfo.hData = (HGLOBAL)GetWindowLongPtr (hParent, GWLP_USERDATA);

    if (DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_POLICY_SHOWLISTBOX),hParent,
                       ShowListboxDlgProc,(LPARAM) &ListboxDlgInfo))
    {
        SetWindowLongPtr (hParent, GWLP_USERDATA, (LONG_PTR) ListboxDlgInfo.hData);
    }
}

INT_PTR CALLBACK CPolicySnapIn::ShowListboxDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
        LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
            LISTBOXDLGINFO * pLBInfo = (LISTBOXDLGINFO *)lParam;

            //
            // Store away pointer to ListboxDlgInfo in window data
            //

            SetWindowLongPtr(hDlg,DWLP_USER,lParam);

            if (!pLBInfo->pCS->InitShowlistboxDlg(hDlg)) {
                pLBInfo->pCS->m_pcd->MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
                EndDialog(hDlg,FALSE);
            }
            }
            return TRUE;

        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);


                    if (!pListboxDlgInfo->pCS->m_pcd->m_bRSOP)
                    {
                        if (!pListboxDlgInfo->pCS->ProcessShowlistboxDlg(hDlg)) {
                            pListboxDlgInfo->pCS->m_pcd->MsgBox(hDlg,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
                            return FALSE;
                        }
                    }
                    EndDialog(hDlg,TRUE);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;

                case IDC_POLICY_ADD:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);
                    pListboxDlgInfo->pCS->ListboxAdd(GetDlgItem(hDlg,IDC_POLICY_LISTBOX), (BOOL)
                            pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME,
                            (BOOL)( ((LISTBOXINFO *)
                            GETOBJECTDATAPTR(pListboxDlgInfo->pSettings))->
                            uOffsetPrefix));
                    }
                    break;

                case IDC_POLICY_REMOVE:
                    {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

                    pListboxDlgInfo->pCS->ListboxRemove(hDlg,GetDlgItem(hDlg,IDC_POLICY_LISTBOX));
                    }
                    break;
            }
            break;

        case WM_NOTIFY:

            if (wParam == IDC_POLICY_LISTBOX) {
                if (((NMHDR FAR*)lParam)->code == LVN_ITEMCHANGED) {
                    LISTBOXDLGINFO * pListboxDlgInfo =
                            (LISTBOXDLGINFO *) GetWindowLongPtr(hDlg,DWLP_USER);

                    if (!pListboxDlgInfo->pCS->m_pcd->m_bRSOP)
                    {
                        pListboxDlgInfo->pCS->EnableShowListboxButtons(hDlg);
                    }
                }

            }
            break;
    }

    return FALSE;
}

BOOL CPolicySnapIn::InitShowlistboxDlg(HWND hDlg)
{
    LISTBOXDLGINFO * pListboxDlgInfo;
    SETTINGS * pSettings;
    LV_COLUMN lvc;
    RECT rcListbox;
    UINT uColWidth,uOffsetData;
    HWND hwndListbox;
    BOOL fSuccess=TRUE;
    LONG lStyle;
    TCHAR szBuffer[SMALLBUF];
    LPTSTR lpData;

    pListboxDlgInfo = (LISTBOXDLGINFO *)GetWindowLongPtr (hDlg, DWLP_USER);

    if (!pListboxDlgInfo)
        return FALSE;

    pSettings = pListboxDlgInfo->pSettings;

    hwndListbox = GetDlgItem(hDlg,IDC_POLICY_LISTBOX);

    //
    // Turn off the header if we don't need it
    //

    if (!m_pcd->m_bRSOP)
    {
        if (!(pSettings->dwFlags & DF_EXPLICITVALNAME))
        {
            lStyle = GetWindowLong (hwndListbox, GWL_STYLE);
            lStyle |= LVS_NOCOLUMNHEADER;
            SetWindowLong (hwndListbox, GWL_STYLE, lStyle);
        }
    }

    SendMessage(hwndListbox, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);


    //
    // Set the setting title in the dialog
    //

    SetDlgItemText(hDlg,IDC_POLICY_TITLE,GETNAMEPTR(pSettings));

    GetClientRect(hwndListbox,&rcListbox);
    uColWidth = rcListbox.right-rcListbox.left;

    if (m_pcd->m_bRSOP)
    {
        if (pSettings->dwFlags & DF_EXPLICITVALNAME)
        {
            uColWidth /= 3;
        }
        else
        {
            uColWidth /= 2;
        }
    }
    else
    {
        if (pSettings->dwFlags & DF_EXPLICITVALNAME)
        {
            uColWidth /= 2;
        }
    }



    if (pSettings->dwFlags & DF_EXPLICITVALNAME) {

        //
        // add a 2nd column to the listview control
        //

        LoadString(g_hInstance,IDS_VALUENAME,szBuffer,ARRAYSIZE(szBuffer));
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = uColWidth-1;
        lvc.pszText = szBuffer;
        lvc.cchTextMax = lstrlen(lvc.pszText)+1;
        lvc.iSubItem = 0;
        ListView_InsertColumn(hwndListbox,0,&lvc);
    }

    //
    // Add a column to the listview control
    //

    LoadString(g_hInstance,IDS_VALUE,szBuffer,ARRAYSIZE(szBuffer));
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = uColWidth;
    lvc.pszText = szBuffer;
    lvc.cchTextMax = lstrlen(lvc.pszText)+1;
    lvc.iSubItem = (pSettings->dwFlags & DF_EXPLICITVALNAME ? 1 : 0);
    ListView_InsertColumn(hwndListbox,lvc.iSubItem,&lvc);

    if (m_pcd->m_bRSOP)
    {
        //
        // Add the GPO Name column to the listview control
        //

        LoadString(g_hInstance,IDS_GPONAME,szBuffer,ARRAYSIZE(szBuffer));
        lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvc.fmt = LVCFMT_LEFT;
        lvc.cx = uColWidth;
        lvc.pszText = szBuffer;
        lvc.cchTextMax = lstrlen(lvc.pszText)+1;
        lvc.iSubItem = (pSettings->dwFlags & DF_EXPLICITVALNAME ? 2 : 1);
        ListView_InsertColumn(hwndListbox,lvc.iSubItem,&lvc);
    }


    if (m_pcd->m_bRSOP)
    {
        EnableWindow(GetDlgItem(hDlg,IDC_POLICY_REMOVE), FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_POLICY_ADD), FALSE);
    }
    else
    {
        EnableShowListboxButtons(hDlg);
    }


    if (pListboxDlgInfo->hData)
    {
        //
        // Insert the items from user's data buffer into the listbox
        //

        if ((lpData = (LPTSTR) GlobalLock(pListboxDlgInfo->hData)))
        {
            while (*lpData && fSuccess) {

                LV_ITEM lvi;

                lvi.pszText=lpData;
                lvi.mask = LVIF_TEXT;
                lvi.iItem=-1;
                lvi.iSubItem=0;
                lvi.cchTextMax = lstrlen(lpData)+1;

                fSuccess=((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi)) >= 0);
                lpData += lstrlen(lpData) +1;


                // if explicit valuename flag set, entries are stored
                // <value name>\0<value>\0....<value name>\0<value>\0\0
                // otherwise, entries are stored
                // <value>\0<value>\0....<value>\0

                if (pSettings->dwFlags & DF_EXPLICITVALNAME) {

                    if (fSuccess) {
                        if (*lpData) {
                            lvi.iSubItem=1;
                            lvi.pszText=lpData;
                            lvi.cchTextMax = lstrlen(lpData)+1;
                            fSuccess=(ListView_SetItem(hwndListbox,&lvi) >= 0);
                        }
                        lpData += lstrlen(lpData) +1;
                    }
                }

                if (m_pcd->m_bRSOP) {

                    if (fSuccess) {
                        if (*lpData) {
                            lvi.iSubItem=(pSettings->dwFlags & DF_EXPLICITVALNAME) ? 2 : 1;
                            lvi.pszText=lpData;
                            lvi.cchTextMax = lstrlen(lpData)+1;
                            fSuccess=(ListView_SetItem(hwndListbox,&lvi) >= 0);
                        }
                        lpData += lstrlen(lpData) +1;
                    }
                }
            }

            GlobalUnlock(pListboxDlgInfo->hData);
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    return fSuccess;
}

BOOL CPolicySnapIn::ProcessShowlistboxDlg(HWND hDlg)
{
    LISTBOXDLGINFO * pListboxDlgInfo = (LISTBOXDLGINFO *)
            GetWindowLongPtr(hDlg,DWLP_USER);   // get pointer to struct from window data
    DWORD dwAlloc=1024 * sizeof(TCHAR),dwUsed=0;
    HGLOBAL hBuf;
    TCHAR * pBuf;
    HWND hwndListbox = GetDlgItem(hDlg,IDC_POLICY_LISTBOX);
    LV_ITEM lvi;
    UINT nLen;
    int nCount;
    TCHAR pszText[MAX_PATH+1];
    HRESULT hr = S_OK;
    DWORD dwBufLen;

    // allocate a temp buffer to read entries into
    if (!(hBuf = GlobalAlloc(GHND,dwAlloc)) ||
            !(pBuf = (TCHAR *) GlobalLock(hBuf))) {
            if (hBuf)
                    GlobalFree(hBuf);
            return FALSE;
    }

    lvi.mask = LVIF_TEXT;
    lvi.iItem=0;
    lvi.pszText = pszText;
    lvi.cchTextMax = ARRAYSIZE(pszText);
    nCount = ListView_GetItemCount(hwndListbox);

    // retrieve the items out of listbox, pack into temp buffer
    for (;lvi.iItem<nCount;lvi.iItem ++) {
            lvi.iSubItem = 0;
            if (ListView_GetItem(hwndListbox,&lvi)) {
                    nLen = lstrlen(lvi.pszText) + 1;
                    dwBufLen = dwUsed+nLen+4;
                    if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwBufLen) * sizeof(TCHAR),&dwAlloc)))
                            return ERROR_NOT_ENOUGH_MEMORY;
                    hr = StringCchCopy(pBuf+dwUsed, dwBufLen - dwUsed, lvi.pszText);
                    ASSERT(SUCCEEDED(hr));
                    dwUsed += nLen;
            }

            if (pListboxDlgInfo->pSettings->dwFlags & DF_EXPLICITVALNAME) {
                    lvi.iSubItem = 1;
                    if (ListView_GetItem(hwndListbox,&lvi)) {
                            nLen = lstrlen(lvi.pszText) + 1;
                            dwBufLen = dwUsed+nLen+4;
                            if (!(pBuf=ResizeBuffer(pBuf,hBuf,(dwBufLen) * sizeof(TCHAR),&dwAlloc)))
                                    return ERROR_NOT_ENOUGH_MEMORY;
                            hr = StringCchCopy(pBuf+dwUsed, dwBufLen - dwUsed, lvi.pszText);
                            ASSERT(SUCCEEDED(hr));
                            dwUsed += nLen;
                    }
            }
    }
    // doubly null-terminate the buffer... safe to do this because we
    // tacked on the extra "+4" in the ResizeBuffer calls above
    *(pBuf+dwUsed) = TEXT('\0');
    dwUsed ++;

    GlobalUnlock(hBuf);

    if (pListboxDlgInfo->hData)
    {
        GlobalFree (pListboxDlgInfo->hData);
    }

    pListboxDlgInfo->hData = hBuf;

    return TRUE;
}


VOID CPolicySnapIn::EnableShowListboxButtons(HWND hDlg)
{
    BOOL fEnable;

    // enable Remove button if there are any items selected
    fEnable = (ListView_GetNextItem(GetDlgItem(hDlg,IDC_POLICY_LISTBOX),
            -1,LVNI_SELECTED) >= 0);

    EnableWindow(GetDlgItem(hDlg,IDC_POLICY_REMOVE),fEnable);
}

VOID CPolicySnapIn::ListboxRemove(HWND hDlg,HWND hwndListbox)
{
    int nItem;

    while ( (nItem=ListView_GetNextItem(hwndListbox,-1,LVNI_SELECTED))
            >= 0) {
            ListView_DeleteItem(hwndListbox,nItem);
    }

    EnableShowListboxButtons(hDlg);
}

VOID CPolicySnapIn::ListboxAdd(HWND hwndListbox, BOOL fExplicitValName,BOOL fValuePrefix)
{
    ADDITEMINFO AddItemInfo;
    LV_ITEM lvi;

    ZeroMemory(&AddItemInfo,sizeof(AddItemInfo));

    AddItemInfo.pCS = this;
    AddItemInfo.fExplicitValName = fExplicitValName;
    AddItemInfo.fValPrefix = fValuePrefix;
    AddItemInfo.hwndListbox = hwndListbox;

    //
    // Bring up the appropriate add dialog-- one edit field ("type the thing
    // to add") normally, two edit fields ("type the name of the thing, type
    // the value of the thing") if the explicit value style is used
    //

    if (!DialogBoxParam(g_hInstance,MAKEINTRESOURCE((fExplicitValName ? IDD_POLICY_LBADD2 :
            IDD_POLICY_LBADD)),hwndListbox,ListboxAddDlgProc,(LPARAM) &AddItemInfo))
            return; // user cancelled

    // add the item to the listbox
    lvi.mask = LVIF_TEXT;
    lvi.iItem=lvi.iSubItem=0;
    lvi.pszText=(fExplicitValName ? AddItemInfo.szValueName :
            AddItemInfo.szValueData);
    lvi.cchTextMax = lstrlen(lvi.pszText)+1;
    if ((lvi.iItem=ListView_InsertItem(hwndListbox,&lvi))<0) {
        // if add fails, display out of memory error
        m_pcd->MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
        return;
    }

    if (fExplicitValName) {
        lvi.iSubItem=1;
        lvi.pszText=AddItemInfo.szValueData;
        lvi.cchTextMax = lstrlen(lvi.pszText)+1;
        if (ListView_SetItem(hwndListbox,&lvi) < 0) {
            m_pcd->MsgBox(hwndListbox,IDS_ErrOUTOFMEMORY,MB_ICONEXCLAMATION,MB_OK);
            return;
        }
    }
}

INT_PTR CALLBACK CPolicySnapIn::ListboxAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                               LPARAM lParam)
{
    switch (uMsg) {

        case WM_INITDIALOG:
            {
            ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)lParam;

            // store away pointer to additeminfo in window data
            SetWindowLongPtr(hDlg,DWLP_USER,lParam);
            SendDlgItemMessage(hDlg,IDC_POLICY_VALUENAME,EM_LIMITTEXT,MAX_PATH,0L);
            SendDlgItemMessage(hDlg,IDC_POLICY_VALUEDATA,EM_LIMITTEXT,MAX_PATH,0L);

            if (!pAddItemInfo->fExplicitValName) {
                ShowWindow (GetDlgItem (hDlg, IDC_POLICY_VALUENAME), SW_HIDE);
            }
            }
            break;

        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
                    {
                    ADDITEMINFO * pAddItemInfo = (ADDITEMINFO *)
                    GetWindowLongPtr(hDlg,DWLP_USER);

                    GetDlgItemText(hDlg,IDC_POLICY_VALUENAME,
                            pAddItemInfo->szValueName,
                            ARRAYSIZE(pAddItemInfo->szValueName));

                    GetDlgItemText(hDlg,IDC_POLICY_VALUEDATA,
                            pAddItemInfo->szValueData,
                            ARRAYSIZE(pAddItemInfo->szValueData));

                    // if explicit value names used, value name must
                    // not be empty, and it must be unique
                    if (pAddItemInfo->fExplicitValName) {
                        LV_FINDINFO lvfi;
                        int iSel;

                        if (!lstrlen(pAddItemInfo->szValueName)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUENAME,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUENAME));
                            return FALSE;
                        }

                        lvfi.flags = LVFI_STRING;
                        lvfi.psz = pAddItemInfo->szValueName;

                        iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
                                -1,&lvfi);

                        if (iSel >= 0) {
                            // value name already used
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_VALUENAMENOTUNIQUE,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUENAME));
                            SendDlgItemMessage(hDlg,IDC_POLICY_VALUENAME,
                                    EM_SETSEL,0,-1);
                            return FALSE;
                        }
                    } else if (!pAddItemInfo->fValPrefix) {
                        // if value name == value data, then value data
                        // must be unique

                        LV_FINDINFO lvfi;
                        int iSel;

                        if (!lstrlen(pAddItemInfo->szValueData)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUEDATA,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            return FALSE;
                        }

                        lvfi.flags = LVFI_STRING;
                        lvfi.psz = pAddItemInfo->szValueData;

                        iSel=ListView_FindItem(pAddItemInfo->hwndListbox,
                                -1,&lvfi);

                        if (iSel >= 0) {
                            // value name already used
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_VALUEDATANOTUNIQUE,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            SendDlgItemMessage(hDlg,IDC_POLICY_VALUEDATA,
                                    EM_SETSEL,0,-1);
                            return FALSE;
                        }

                    }
                    else
                    {
                        if (!lstrlen(pAddItemInfo->szValueData)) {
                            // can't be empty
                            pAddItemInfo->pCS->m_pcd->MsgBox(hDlg,IDS_EMPTYVALUEDATA,
                                    MB_ICONINFORMATION,MB_OK);
                            SetFocus(GetDlgItem(hDlg,IDC_POLICY_VALUEDATA));
                            return FALSE;
                        }
                    }
                    EndDialog(hDlg,TRUE);
                    }

                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;
            }

            break;
    }

    return FALSE;
}

void CPolicySnapIn::InitializeFilterDialog (HWND hDlg)
{
    INT iIndex;
    RECT rect;
    LV_COLUMN lvcol;
    LONG lWidth;
    DWORD dwCount = 0;
    HWND hList = GetDlgItem(hDlg, IDC_FILTERLIST);
    LPSUPPORTEDENTRY lpTemp;
    LVITEM item;


    //
    // Count the number of Supported On strings
    //

    lpTemp = m_pcd->m_pSupportedStrings;

    while (lpTemp)
    {
        lpTemp = lpTemp->pNext;
        dwCount++;
    }


    //
    // Decide on the column width
    //

    GetClientRect(hList, &rect);

    if (dwCount > (DWORD)ListView_GetCountPerPage(hList))
    {
        lWidth = (rect.right - rect.left) - GetSystemMetrics(SM_CYHSCROLL);
    }
    else
    {
        lWidth = rect.right - rect.left;
    }


    //
    // Insert the first column
    //

    memset(&lvcol, 0, sizeof(lvcol));

    lvcol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcol.fmt = LVCFMT_LEFT;
    lvcol.cx = lWidth;
    ListView_InsertColumn(hList, 0, &lvcol);


    //
    // Turn on some listview features
    //

    SendMessage(hList, LVM_SETEXTENDEDLISTVIEWSTYLE, 0,
                LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_CHECKBOXES);


    //
    // Insert the Supported On strings
    //

    lpTemp = m_pcd->m_pSupportedStrings;

    while (lpTemp)
    {
        ZeroMemory (&item, sizeof(item));

        item.mask = LVIF_TEXT | LVIF_PARAM;
        item.iItem = 0;
        item.pszText = lpTemp->lpString;
        item.lParam = (LPARAM) lpTemp;
        iIndex = ListView_InsertItem (hList, &item);

        if (iIndex > -1)
        {
            ZeroMemory (&item, sizeof(item));
            item.mask = LVIF_STATE;
            item.state = lpTemp->bEnabled ? INDEXTOSTATEIMAGEMASK(2) : INDEXTOSTATEIMAGEMASK(1);
            item.stateMask = LVIS_STATEIMAGEMASK;

            SendMessage (hList, LVM_SETITEMSTATE, (WPARAM)iIndex, (LPARAM)&item);
        }


        lpTemp = lpTemp->pNext;
    }


    //
    // Select the first item
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendMessage (hList, LVM_SETITEMSTATE, 0, (LPARAM) &item);


    //
    // Initialize the checkboxes
    //

    if (m_pcd->m_bUseSupportedOnFilter)
    {
        CheckDlgButton (hDlg, IDC_SUPPORTEDOPTION, BST_CHECKED);
    }
    else
    {
        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), FALSE);
    }

    if (m_pcd->m_bShowConfigPoliciesOnly)
    {
        CheckDlgButton (hDlg, IDC_SHOWCONFIG, BST_CHECKED);
    }

    if ((m_dwPolicyOnlyPolicy == 0) || (m_dwPolicyOnlyPolicy == 1))
    {
        if (m_dwPolicyOnlyPolicy == 1)
        {
            CheckDlgButton (hDlg, IDC_SHOWPOLICIES, BST_CHECKED);
        }

        EnableWindow (GetDlgItem (hDlg, IDC_SHOWPOLICIES), FALSE);
    }
    else
    {
        if (m_bPolicyOnly)
        {
            CheckDlgButton (hDlg, IDC_SHOWPOLICIES, BST_CHECKED);
        }
    }
}


INT_PTR CALLBACK CPolicySnapIn::FilterDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                               LPARAM lParam)
{
    CPolicySnapIn * pCS;

    switch (uMsg)
    {

        case WM_INITDIALOG:
            pCS = (CPolicySnapIn *) lParam;
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pCS);

            if (pCS)
            {
                pCS->InitializeFilterDialog(hDlg);
            }
            break;

        case WM_COMMAND:

            switch (wParam)
            {
                case IDC_SUPPORTEDOPTION:
                    if (IsDlgButtonChecked (hDlg, IDC_SUPPORTEDOPTION) == BST_CHECKED)
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), TRUE);
                        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), TRUE);
                    }
                    else
                    {
                        EnableWindow (GetDlgItem (hDlg, IDC_SUPPORTEDONTITLE), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_FILTERLIST), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_SELECTALL), FALSE);
                        EnableWindow (GetDlgItem (hDlg, IDC_DESELECTALL), FALSE);
                    }

                    break;

                case IDC_SELECTALL:
                    {
                        LVITEM item;

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_STATE;
                        item.state = INDEXTOSTATEIMAGEMASK(2);
                        item.stateMask = LVIS_STATEIMAGEMASK;

                        SendMessage (GetDlgItem (hDlg, IDC_FILTERLIST), LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&item);
                    }
                    break;

                case IDC_DESELECTALL:
                    {
                        LVITEM item;

                        ZeroMemory (&item, sizeof(item));
                        item.mask = LVIF_STATE;
                        item.state = INDEXTOSTATEIMAGEMASK(1);
                        item.stateMask = LVIS_STATEIMAGEMASK;

                        SendMessage (GetDlgItem (hDlg, IDC_FILTERLIST), LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&item);
                    }
                    break;

                case IDOK:
                    {
                    LVITEM item;
                    INT iIndex = 0;
                    LPSUPPORTEDENTRY lpItem;

                    pCS = (CPolicySnapIn *) GetWindowLongPtr(hDlg,DWLP_USER);

                    if (!pCS)
                    {
                        break;
                    }

                    if (IsDlgButtonChecked (hDlg, IDC_SUPPORTEDOPTION) == BST_CHECKED)
                    {
                        pCS->m_pcd->m_bUseSupportedOnFilter = TRUE;
                        while (TRUE)
                        {
                            ZeroMemory (&item, sizeof(item));

                            item.mask = LVIF_PARAM | LVIF_STATE;
                            item.iItem = iIndex;
                            item.stateMask = LVIS_STATEIMAGEMASK;

                            if (!ListView_GetItem (GetDlgItem (hDlg, IDC_FILTERLIST), &item))
                            {
                                break;
                            }

                            lpItem = (LPSUPPORTEDENTRY) item.lParam;

                            if (lpItem)
                            {
                                if (item.state == INDEXTOSTATEIMAGEMASK(2))
                                {
                                    lpItem->bEnabled = TRUE;
                                }
                                else
                                {
                                    lpItem->bEnabled = FALSE;
                                }
                            }

                            iIndex++;
                        }
                    }
                    else
                    {
                        pCS->m_pcd->m_bUseSupportedOnFilter = FALSE;
                    }


                    if (IsDlgButtonChecked (hDlg, IDC_SHOWCONFIG) == BST_CHECKED)
                    {
                        pCS->m_pcd->m_bShowConfigPoliciesOnly = TRUE;
                    }
                    else
                    {
                        pCS->m_pcd->m_bShowConfigPoliciesOnly = FALSE;
                    }


                    if (IsDlgButtonChecked (hDlg, IDC_SHOWPOLICIES) == BST_CHECKED)
                    {
                        pCS->m_bPolicyOnly = TRUE;
                    }
                    else
                    {
                        pCS->m_bPolicyOnly = FALSE;
                    }


                    EndDialog(hDlg,TRUE);
                    }

                    break;

                case IDCANCEL:
                    EndDialog(hDlg,FALSE);
                    break;
            }

            break;

        case WM_NOTIFY:

            pCS = (CPolicySnapIn *) GetWindowLongPtr (hDlg, DWLP_USER);

            if (!pCS) {
                break;
            }

            switch (((NMHDR FAR*)lParam)->code)
            {
                case LVN_ITEMACTIVATE:
                    {
                    LPNMITEMACTIVATE pItem = (LPNMITEMACTIVATE) lParam;
                    LPSUPPORTEDENTRY lpItem;
                    LVITEM item;
                    HWND hLV = GetDlgItem(hDlg, IDC_FILTERLIST);

                    ZeroMemory (&item, sizeof(item));
                    item.mask = LVIF_STATE | LVIF_PARAM;
                    item.iItem = pItem->iItem;
                    item.stateMask = LVIS_STATEIMAGEMASK;

                    if (!ListView_GetItem (hLV, &item))
                    {
                        break;
                    }

                    lpItem = (LPSUPPORTEDENTRY) item.lParam;

                    if (!lpItem)
                    {
                        break;
                    }


                    if (lpItem)
                    {
                        if (item.state == INDEXTOSTATEIMAGEMASK(2))
                        {
                            item.state = INDEXTOSTATEIMAGEMASK(1);
                        }
                        else
                        {
                            item.state = INDEXTOSTATEIMAGEMASK(2);
                        }

                        item.mask = LVIF_STATE;
                        SendMessage (hLV, LVM_SETITEMSTATE, (WPARAM)pItem->iItem, (LPARAM)&item);
                    }

                    }
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aFilteringHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aFilteringHelpIds);
            return (TRUE);
    }

    return FALSE;
}


unsigned int CPolicyDataObject::m_cfNodeType       = RegisterClipboardFormat(CCF_NODETYPE);
unsigned int CPolicyDataObject::m_cfNodeTypeString = RegisterClipboardFormat(CCF_SZNODETYPE);
unsigned int CPolicyDataObject::m_cfDisplayName    = RegisterClipboardFormat(CCF_DISPLAY_NAME);
unsigned int CPolicyDataObject::m_cfCoClass        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
unsigned int CPolicyDataObject::m_cfDescription    = RegisterClipboardFormat(L"CCF_DESCRIPTION");
unsigned int CPolicyDataObject::m_cfHTMLDetails    = RegisterClipboardFormat(L"CCF_HTML_DETAILS");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject implementation                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


CPolicyDataObject::CPolicyDataObject(CPolicyComponentData *pComponent)
{
    m_cRef = 1;
    InterlockedIncrement(&g_cRefThisDll);

    m_pcd = pComponent;
    m_pcd->AddRef();
    m_type = CCT_UNINITIALIZED;
    m_cookie = -1;
}

CPolicyDataObject::~CPolicyDataObject()
{
    m_pcd->Release();
    InterlockedDecrement(&g_cRefThisDll);
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (IUnknown)                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CPolicyDataObject::QueryInterface (REFIID riid, void **ppv)
{

    if (IsEqualIID(riid, IID_IPolicyDataObject))
    {
        *ppv = (LPPOLICYDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IDataObject) ||
             IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPDATAOBJECT)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CPolicyDataObject::AddRef (void)
{
    return ++m_cRef;
}

ULONG CPolicyDataObject::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (IDataObject)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CPolicyDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;
    TCHAR szBuffer[300];


    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if(cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if(cf == m_cfNodeTypeString)
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if (cf == m_cfDescription)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie)
            {
                TABLEENTRY * pEntry = (TABLEENTRY *) m_cookie;

                if (pEntry->dwType & ETYPE_POLICY)
                {
                    POLICY * pPolicy = (POLICY *) m_cookie;
                    IStream *lpStream = lpMedium->pstm;


                    if (lpStream)
                    {
                        if (pPolicy->uOffsetHelp)
                        {
                            LPTSTR sz = (LPTSTR)((BYTE *)pPolicy + pPolicy->uOffsetHelp);
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }

                        if (!pPolicy->bTruePolicy)
                        {
                            LoadString (g_hInstance, IDS_PREFERENCE, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
                else if (pEntry->dwType & ETYPE_CATEGORY)
                {
                    CATEGORY * pCat = (CATEGORY *) m_cookie;

                    if (pCat->uOffsetHelp)
                    {
                        LPTSTR sz = (LPTSTR)((BYTE *)pCat + pCat->uOffsetHelp);

                        IStream *lpStream = lpMedium->pstm;

                        if (lpStream)
                        {
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
                else if (pEntry->dwType == (ETYPE_ROOT | ETYPE_REGITEM))
                {
                    IStream *lpStream = lpMedium->pstm;

                    LoadString (g_hInstance, IDS_EXSETROOT_DESC, szBuffer, ARRAYSIZE(szBuffer));

                    if (lpStream)
                    {
                        hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                    }
                }
                else if (pEntry->dwType == ETYPE_REGITEM)
                {
                    IStream *lpStream = lpMedium->pstm;

                    LoadString (g_hInstance, IDS_EXSET_DESC, szBuffer, ARRAYSIZE(szBuffer));

                    if (lpStream)
                    {
                        REGITEM * pItem = (REGITEM *) m_cookie;

                        hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);

                        if (!pItem->bTruePolicy)
                        {
                            LoadString (g_hInstance, IDS_PREFERENCE, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
            }
            else
            {
                LoadString (g_hInstance, IDS_POLICY_DESC, szBuffer, ARRAYSIZE(szBuffer));

                IStream *lpStream = lpMedium->pstm;

                if (lpStream)
                {
                    hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                }
            }
        }
    }
    else if (cf == m_cfHTMLDetails)
    {
        hr = DV_E_TYMED;

        if (lpMedium->tymed == TYMED_ISTREAM)
        {
            ULONG ulWritten;

            if (m_cookie)
            {
                POLICY * pPolicy = (POLICY *) m_cookie;

                if ((pPolicy->dwType & ETYPE_POLICY) || (pPolicy->dwType == ETYPE_REGITEM))
                {
                    IStream *lpStream = lpMedium->pstm;

                    if(lpStream)
                    {
                        LPTSTR sz = GETSUPPORTEDPTR(pPolicy);

                        hr = lpStream->Write(g_szDisplayProperties, lstrlen(g_szDisplayProperties) * sizeof(TCHAR), &ulWritten);

                        if ((pPolicy->dwType & ETYPE_POLICY) && sz)
                        {
                            LoadString (g_hInstance, IDS_SUPPORTEDDESC, szBuffer, ARRAYSIZE(szBuffer));
                            hr = lpStream->Write(szBuffer, lstrlen(szBuffer) * sizeof(TCHAR), &ulWritten);
                            hr = lpStream->Write(sz, lstrlen(sz) * sizeof(TCHAR), &ulWritten);
                        }
                    }
                }
            }
        }
    }
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CPolicyDataObject object implementation (Internal functions)              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT CPolicyDataObject::Create(LPVOID pBuffer, INT len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE',
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

    return hr;
}

HRESULT CPolicyDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    LPRESULTITEM lpResultItem = (LPRESULTITEM) m_cookie;


    if (m_cookie == -1)
        return E_UNEXPECTED;

    // Create the node type object in GUID format
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&NODEID_PolicyRootUser, sizeof(GUID), lpMedium);
    else
        return Create((LPVOID)&NODEID_PolicyRootMachine, sizeof(GUID), lpMedium);
}

HRESULT CPolicyDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    TCHAR szNodeType[50];

    if (m_cookie == -1)
        return E_UNEXPECTED;

    szNodeType[0] = TEXT('\0');
    if (m_pcd->m_bUserScope)
        StringFromGUID2 (NODEID_PolicyRootUser, szNodeType, 50);
    else
        StringFromGUID2 (NODEID_PolicyRootMachine, szNodeType, 50);

    // Create the node type object in GUID string format
    return Create((LPVOID)szNodeType, ((lstrlenW(szNodeType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CPolicyDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    WCHAR  szDisplayName[100] = {0};

    LoadStringW (g_hInstance, IDS_POLICY_NAME, szDisplayName, 100);

    return Create((LPVOID)szDisplayName, (lstrlenW(szDisplayName) + 1) * sizeof(WCHAR), lpMedium);
}

HRESULT CPolicyDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    if (m_pcd->m_bUserScope)
        return Create((LPVOID)&CLSID_PolicySnapInUser, sizeof(CLSID), lpMedium);
    else
        return Create((LPVOID)&CLSID_PolicySnapInMachine, sizeof(CLSID), lpMedium);
}

const TCHAR szViewDescript [] = TEXT("MMCViewExt 1.0 Object");
const TCHAR szViewGUID [] = TEXT("{B708457E-DB61-4C55-A92F-0D4B5E9B1224}");
const TCHAR szThreadingModel[] = TEXT("Apartment");

HRESULT RegisterPolicyExtension (REFGUID clsid, UINT uiStringId, REFGUID RootNodeID,
                           REFGUID ExtNodeId, LPTSTR lpSnapInNameIndirect)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szSnapInName[100];
    TCHAR szGUID[50];
    DWORD dwDisp;
    LONG lResult;
    HKEY hKey;
    HRESULT hr = S_OK;

    //
    // First register the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);


    //
    // Register SnapIn in HKEY_CLASSES_ROOT
    //

    LoadString (g_hInstance, uiStringId, szSnapInName, 100);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s\\InProcServer32"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_CLASSES_ROOT, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_EXPAND_SZ, (LPBYTE)g_szSnapInLocation,
                   (lstrlen(g_szSnapInLocation) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("ThreadingModel"), 0, REG_SZ, (LPBYTE)szThreadingModel,
                   (lstrlen(szThreadingModel) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);



    //
    // Register SnapIn with MMC
    //

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, TEXT("NameString"), 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));

    RegSetValueEx (hKey, TEXT("NameStringIndirect"), 0, REG_SZ, (LPBYTE)lpSnapInNameIndirect,
                   (lstrlen(lpSnapInNameIndirect) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    StringFromGUID2 (RootNodeID, szGUID, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s\\NodeTypes\\%s"),
              szSnapInKey, szGUID);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);



    //
    // Register in the NodeTypes key
    //

    StringFromGUID2 (RootNodeID, szGUID, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);


    //
    // Register for the view extension
    //

    hr = StringCchCat (szSubKey, ARRAYSIZE(szSubKey), TEXT("\\Extensions\\View"));
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szViewGUID, 0, REG_SZ, (LPBYTE)szViewDescript,
                   (lstrlen(szViewDescript) + 1) * sizeof(TCHAR));

    RegCloseKey (hKey);


    //
    // Register as an extension for various nodes
    //

    StringFromGUID2 (ExtNodeId, szGUID, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    ASSERT(SUCCEEDED(hr));

    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, szSnapInKey, 0, REG_SZ, (LPBYTE)szSnapInName,
                   (lstrlen(szSnapInName) + 1) * sizeof(TCHAR));


    RegCloseKey (hKey);

    return S_OK;
}



HRESULT RegisterPolicy(void)
{
    HRESULT hr;


    hr = RegisterPolicyExtension (CLSID_PolicySnapInMachine, IDS_POLICY_NAME_MACHINE,
                            NODEID_PolicyRootMachine, NODEID_MachineRoot, TEXT("@gptext.dll,-20"));

    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_PolicySnapInUser, IDS_POLICY_NAME_USER,
                                NODEID_PolicyRootUser, NODEID_UserRoot, TEXT("@gptext.dll,-21"));
    }


    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_RSOPolicySnapInMachine, IDS_POLICY_NAME_MACHINE,
                                NODEID_RSOPolicyRootMachine, NODEID_RSOPMachineRoot, TEXT("@gptext.dll,-20"));
    }

    if (hr == S_OK)
    {
        hr = RegisterPolicyExtension (CLSID_RSOPolicySnapInUser, IDS_POLICY_NAME_USER,
                                NODEID_RSOPolicyRootUser, NODEID_RSOPUserRoot, TEXT("@gptext.dll,-21"));
    }


    return hr;
}

HRESULT UnregisterPolicyExtension (REFGUID clsid, REFGUID RootNodeID, REFGUID ExtNodeId)
{
    TCHAR szSnapInKey[50];
    TCHAR szSubKey[200];
    TCHAR szGUID[50];
    LONG lResult;
    HKEY hKey;
    DWORD dwDisp;
    HRESULT hr = S_OK;

    //
    // First unregister the extension
    //

    StringFromGUID2 (clsid, szSnapInKey, 50);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("CLSID\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_CLASSES_ROOT, szSubKey);

    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\SnapIns\\%s"), szSnapInKey);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);

    StringFromGUID2 (RootNodeID, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s"), szGUID);
    ASSERT(SUCCEEDED(hr));
    RegDelnode (HKEY_LOCAL_MACHINE, szSubKey);



    StringFromGUID2 (ExtNodeId, szGUID, 50);
    hr = StringCchPrintf (szSubKey, ARRAYSIZE(szSubKey), TEXT("Software\\Microsoft\\MMC\\NodeTypes\\%s\\Extensions\\NameSpace"), szGUID);
    ASSERT(SUCCEEDED(hr));


    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSubKey, 0,
                              KEY_WRITE, &hKey);


    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }

    return S_OK;
}


HRESULT UnregisterPolicy(void)
{
    HRESULT hr;

    hr = UnregisterPolicyExtension (CLSID_PolicySnapInMachine, NODEID_PolicyRootMachine,
                              NODEID_Machine);

    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_PolicySnapInUser, NODEID_PolicyRootUser,
                                  NODEID_User);
    }

    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_RSOPolicySnapInMachine, NODEID_RSOPolicyRootMachine,
                                  NODEID_RSOPMachineRoot);
    }


    if (hr == S_OK)
    {
        hr = UnregisterPolicyExtension (CLSID_RSOPolicySnapInUser, NODEID_RSOPolicyRootUser,
                                  NODEID_RSOPUserRoot);
    }

    return hr;
}



VOID LoadMessage (DWORD dwID, LPTSTR lpBuffer, DWORD dwSize)
{
    HINSTANCE hInstActiveDS;
    HINSTANCE hInstWMI;


    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL, dwID,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  lpBuffer, dwSize, NULL))
    {
        hInstActiveDS = LoadLibrary (TEXT("activeds.dll"));

        if (hInstActiveDS)
        {
            if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                          hInstActiveDS, dwID,
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                          lpBuffer, dwSize, NULL))
            {
                hInstWMI = LoadLibrary (TEXT("wmiutils.dll"));

                if (hInstWMI)
                {

                    if (!FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                                  hInstWMI, dwID,
                                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                                  lpBuffer, dwSize, NULL))
                    {
                        DebugMsg((DM_WARNING, TEXT("LoadMessage: Failed to query error message text for %d due to error %d"),
                                 dwID, GetLastError()));
                        (void) StringCchPrintf (lpBuffer, dwSize, TEXT("%d (0x%x)"), dwID, dwID);
                    }

                    FreeLibrary (hInstWMI);
                }
            }

            FreeLibrary (hInstActiveDS);
        }
    }
}

//*************************************************************
//
//  ErrorDlgProc()
//
//  Purpose:    Dialog box procedure for errors
//
//  Parameters:
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//*************************************************************

INT_PTR CALLBACK ErrorDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szError[MAX_PATH];
            LPGPOERRORINFO lpEI = (LPGPOERRORINFO) lParam;
            HICON hIcon;

            hIcon = LoadIcon (NULL, IDI_INFORMATION);

            if (hIcon)
            {
                SendDlgItemMessage (hDlg, IDC_ERROR_ICON, STM_SETICON, (WPARAM)hIcon, 0);
            }

            SetDlgItemText (hDlg, IDC_ERRORTEXT, lpEI->lpMsg);

            if (lpEI->lpDetails) {
                // if details is provided use that
                SetDlgItemText (hDlg, IDC_DETAILSTEXT, lpEI->lpDetails);
            }
            else {
                szError[0] = TEXT('\0');
                if (lpEI->dwError)
                {
                    LoadMessage (lpEI->dwError, szError, ARRAYSIZE(szError));
                }

                if (szError[0] == TEXT('\0'))
                {
                    LoadString (g_hInstance, IDS_NONE, szError, ARRAYSIZE(szError));
                }

                SetDlgItemText (hDlg, IDC_DETAILSTEXT, szError);

            }

            // this is the only way I know to remove focus from the details
            PostMessage(hDlg, WM_MYREFRESH, 0, 0);

            return TRUE;
        }


        case WM_MYREFRESH:
        {
            SetFocus(GetDlgItem(hDlg, IDCLOSE));
        }

        case WM_COMMAND:
            if (LOWORD(wParam) == IDCLOSE || LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPSTR) aErrorHelpIds);
            return (TRUE);
    }

    return FALSE;
}

//*************************************************************
//
//  ReportError()
//
//  Purpose:    Displays an error message to the user
//
//  Parameters: hParent     -   Parent window handle
//              dwError     -   Error number
//              idMsg       -   Error message id
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ReportAdmError (HWND hParent, DWORD dwError, UINT idMsg, ...)
{
    GPOERRORINFO ei;
    TCHAR szMsg[MAX_PATH];
    TCHAR szErrorMsg[2*MAX_PATH+40];
    va_list marker;
    HRESULT hr = S_OK;

    //
    // Load the error message
    //

    if (!LoadString (g_hInstance, idMsg, szMsg, MAX_PATH))
    {
        return FALSE;
    }


    //
    // Plug in the arguments
    //


    va_start(marker, idMsg);
    if (idMsg == IDS_RSOP_ADMFAILED) {
        ei.lpDetails = va_arg(marker, LPTSTR);
        (void) StringCchCopy(szErrorMsg, ARRAYSIZE(szErrorMsg), szMsg);
    }
    else {
        va_start(marker, idMsg);
        (void) StringCchVPrintf(szErrorMsg, ARRAYSIZE(szErrorMsg), szMsg, marker);
    }
    va_end(marker);

    //
    // Display the message
    //

    ei.dwError = dwError;
    ei.lpMsg   = szErrorMsg;

    DialogBoxParam (g_hInstance, MAKEINTRESOURCE(IDD_ERROR_ADMTEMPLATES), hParent,
                    ErrorDlgProc, (LPARAM) &ei);

    return TRUE;
}



LPHASHTABLE CreateHashTable (void)
{
    LPHASHTABLE lpTable;

    lpTable = (LPHASHTABLE)LocalAlloc (LPTR, sizeof(LPHASHTABLE) * HASH_BUCKET_COUNT);

    return lpTable;
}

VOID FreeHashTable (LPHASHTABLE lpTable)
{
    INT i;
    LPHASHENTRY lpItem, lpNext;


    for (i = 0; i < HASH_BUCKET_COUNT; i++)
    {
        lpItem = lpTable->lpEntries[i];

        while (lpItem)
        {
            lpNext = lpItem->pNext;

            LocalFree (lpItem);
            lpItem = lpNext;
        }
    }

    LocalFree (lpTable);
}

ULONG CalculateHashInfo(LPTSTR lpName, DWORD dwChars, DWORD *pdwHashValue)
{
    DWORD  dwHash = 314159269;
    DWORD dwIndex;

    CharLowerBuff (lpName, dwChars);

    for (dwIndex = 0; dwIndex < dwChars; dwIndex++)
    {
        dwHash ^= (dwHash<<11) + (dwHash<<5) + (dwHash>>2) + (unsigned int) lpName[dwIndex];
    }

    dwHash = (dwHash & 0x7FFFFFFF);

    *pdwHashValue = dwHash;

    return (dwHash % HASH_BUCKET_COUNT);
}

BOOL AddHashEntry (LPHASHTABLE lpTable, LPTSTR lpName, DWORD dwChars)
{
    DWORD dwHashValue, dwBucket;
    LPHASHENTRY lpTemp, lpItem;

    dwBucket = CalculateHashInfo(lpName, dwChars, &dwHashValue);


    lpItem = (LPHASHENTRY) LocalAlloc (LPTR, sizeof(HASHENTRY));

    if (!lpItem)
    {
        return FALSE;
    }

    lpItem->dwHashValue = dwHashValue;
    lpItem->dwVariableLength = dwChars;
    lpItem->lpStringEntry = lpName;

    lpTemp = lpTable->lpEntries[dwBucket];

    if (lpTemp)
    {
        while (lpTemp->pNext)
        {
            lpTemp = lpTemp->pNext;
        }

        lpTemp->pNext = lpItem;
    }
    else
    {
        lpTable->lpEntries[dwBucket] = lpItem;
    }

    return TRUE;
}

LPTSTR FindHashEntry (LPHASHTABLE lpTable, LPTSTR lpName, DWORD dwChars)
{
    DWORD dwHashValue, dwBucket;
    LPHASHENTRY lpTemp, lpItem;

    dwBucket = CalculateHashInfo(lpName, dwChars, &dwHashValue);

    lpTemp = lpTable->lpEntries[dwBucket];

    if (lpTemp)
    {
        while (lpTemp)
        {
            if ((lpTemp->dwHashValue == dwHashValue) && (lpTemp->dwVariableLength == dwChars))
            {
                if (CompareString (LOCALE_USER_DEFAULT, NORM_IGNORECASE,
                                  lpTemp->lpStringEntry, dwChars,
                                  lpName, dwChars) == CSTR_EQUAL)
                {
                    return lpTemp->lpStringEntry;
                }
            }

            lpTemp = lpTemp->pNext;
        }
    }

    return NULL;
}

#if DBG
VOID DumpHashTableDetails (LPHASHTABLE lpTable)
{
    INT i;
    DWORD dwCount = 0;
    LPHASHENTRY lpItem, lpNext;


    for (i = 0; i < HASH_BUCKET_COUNT; i++)
    {
        dwCount = 0;

        lpItem = lpTable->lpEntries[i];

        while (lpItem)
        {
            dwCount++;
            lpItem = lpItem->pNext;
        }

        DebugMsg((DM_VERBOSE, TEXT("Hash Bucket %d has %d entries"), i, dwCount));
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\scrptlog.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        ScrptLog.h
//
// Contents:    
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRPTLOG_H_
#define _SCRPTLOG_H_

#include <wbemcli.h>

#ifdef  __cplusplus
extern "C" {
#endif

//
// handle
//

typedef void* RSOPScriptList;

//
// script type strings
//

#define LOGON_VALUE       L"Logon"
#define LOGOFF_VALUE      L"Logoff"
#define STARTUP_VALUE     L"Startup"
#define SHUTDOWN_VALUE    L"Shutdown"

#define LOGON_SOM_VALUE       L"Logon-SOMIDs"
#define LOGOFF_SOM_VALUE      L"Logoff-SOMIDs"
#define STARTUP_SOM_VALUE     L"Startup-SOMIDs"
#define SHUTDOWN_SOM_VALUE    L"Shutdown-SOMIDs"

#define LOGON_NS_VALUE      L"User-RSoP-NS"
#define LOGOFF_NS_VALUE     L"User-RSoP-NS"
#define STARTUP_NS_VALUE    L"Mach-RSoP-NS"
#define SHUTDOWN_NS_VALUE   L"Mach-RSoP-NS"

#define LOGON_RSOP_LOGGING_VALUE    L"Logon-RSoP-Logging"
#define LOGOFF_RSOP_LOGGING_VALUE   L"Logoff-RSoP-Logging"
#define STARTUP_RSOP_LOGGING_VALUE  L"Startup-RSoP-Logging"
#define SHUTDOWN_RSOP_LOGGING_VALUE L"Shutdown-RSoP-Logging"

//
// Script List creation APIs
//

RSOPScriptList
CreateScriptListOfStr( LPCWSTR szScriptType );

//
// Script list destructor API
//

void
DestroyScriptList( RSOPScriptList pList );

//
// Script list building API
//

BOOL
AddScript( RSOPScriptList pList, LPCWSTR  szCommand, LPCWSTR  szParams, SYSTEMTIME* execTime );

//
// Misc. APIs
//

HRESULT
LogScriptsRsopData( RSOPScriptList	pScriptList,
                    IWbemServices*  pWbemServices,
                    LPCWSTR			wszGPOID,
                    LPCWSTR			wszSOMID,
                    LPCWSTR                     wszRSOPGPOID,
                    DWORD           cOrder );

HRESULT
DeleteScriptsRsopData(  RSOPScriptList  pScriptList,
                        IWbemServices*  pWbemServices );

HRESULT
UpdateScriptsRsopData(  RSOPScriptList	pScriptList,
                        IWbemServices*  pWbemServices,
                        LPCWSTR         wszGPOID,
                        LPCWSTR			wszSOMID );

LPWSTR
GPOIDFromPath( LPCWSTR wszPath );

LPWSTR
GetNamespace( IWbemServices* pWbemServices );

//
// delay load
//

#define RSOP_SCRIPT_LOG_DLL L"gptext.dll"

typedef RSOPScriptList (*PFNCREATESCRIPTLISTOFSTR)( LPCWSTR );
typedef void (*PFNDESTROYSCRIPTLIST)( RSOPScriptList );
typedef BOOL (*PFNADDSCRIPT)( RSOPScriptList, LPCWSTR, LPCWSTR );
typedef BOOL (*PFNRSOPLOGGINGENABLED)();
typedef HRESULT (*PFNLOGSCRIPTSRSOPDATA)( RSOPScriptList, IWbemServices*, LPCWSTR, LPCWSTR, LPCWSTR, DWORD );
typedef HRESULT (*PFNDELETESCRIPTSRSOPDATA)(RSOPScriptList, IWbemServices*);
typedef HRESULT (*PFNUPDATESCRIPTSRSOPDATA)( RSOPScriptList, IWbemServices*, LPCWSTR, LPCWSTR );
typedef LPWSTR (*PFNGPOIDFROMPATH)( LPCWSTR );
typedef LPWSTR (*PFNGETNAMESPACE)( IWbemServices* );

typedef struct _SCRPTLOG_API
{
    HINSTANCE                       hInstance;
    PFNCREATESCRIPTLISTOFSTR        pfnCreateScriptListOfStr;
    PFNDESTROYSCRIPTLIST            pfnDestroyScriptList;
    PFNADDSCRIPT                    pfnAddScript;
    PFNLOGSCRIPTSRSOPDATA           pfnLogScriptsRsopData;
    PFNDELETESCRIPTSRSOPDATA        pfnDeleteScriptsRsopData;
    PFNUPDATESCRIPTSRSOPDATA        pfnUpdateScriptsRsopData;
    PFNGPOIDFROMPATH                pfnGPOIDFromPath;
    PFNGETNAMESPACE                 pfnGetNamespace;
} SCRPTLOG_API, *PSCRPTLOG_API;

//
// API names
//

#define DESTROYSCRIPTLIST               "DestroyScriptList"
#define DELETESCRIPTSRSOPDATA           "DeleteScriptsRsopData"
#define CREATESCRIPTLISTOFSTR           "CreateScriptListOfStr"
#define ADDSCRIPT                       "AddScript"
#define LOGSCRIPTSRSOPDATA              "LogScriptsRsopData"
#define UPDATESCRIPTSRSOPDATA           "UpdateScriptsRsopData"
#define GPOIDFROMPATH                   "GPOIDFromPath"
#define GETNAMESPACE                    "GetNamespace"

#ifdef  __cplusplus
}
#endif

#endif // _SCRPTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\util.h ===
//
// Function proto-types for util.cpp
//

LPTSTR CheckSlash (LPTSTR lpDir);
BOOL RegCleanUpValue (HKEY hKeyRoot, LPTSTR lpSubKey, LPTSTR lpValueName);
UINT CreateNestedDirectory(LPCTSTR lpDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
BOOL StringToNum(TCHAR *pszStr,UINT * pnVal);
BOOL ImpersonateUser (HANDLE hNewUser, HANDLE *hOldUser);
BOOL RevertToUser (HANDLE *hUser);
void StringToGuid( TCHAR *szValue, GUID *pGuid );
void GuidToString( GUID *pGuid, TCHAR * szValue );
BOOL ValidateGuid( TCHAR *szValue );
INT CompareGuid( GUID *pGuid1, GUID *pGuid2 );
HRESULT IsFilePresent (WCHAR *szDirName, WCHAR *szFormat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\scrpdata.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998
//
// File:        Scrpdata.h
//
// Contents:    
//
// History:     9-Aug-99       NishadM    Created
//
//---------------------------------------------------------------------------

#ifndef _SCRPDATA_H_
#define _SCRPDATA_H_

//
// GPO script and its parameters
//

typedef struct tag_RSOP_Script
{
    LPWSTR      szCommand;      // full path to the script file
    LPWSTR      szParams;       // list of parameters
    SYSTEMTIME  executionTime;  // time of execution
    struct tag_RSOP_Script*  pNextCommand;          // next link in the chain   

} RSOP_Script, * PRSOP_Script;

//
// script types
//

typedef enum
{
    Undefined = 0,
    Logon,
    Logoff,
    Startup,
    Shutdown    
} ScriptType;

//
// GPO scripts collection
//

typedef struct tag_RSOP_ScriptList
{
    ScriptType   type;               // type of script
    ULONG        nCommand;           // number of scripts
    PRSOP_Script scriptCommand;      // list of scripts
    PRSOP_Script listTail;           // 
    
} RSOP_ScriptList, *PRSOP_ScriptList;

//
// ScriptType to Strings
//
extern LPCWSTR  g_pwszScriptTypes[];

#define ScriptTypeString(x) ( g_pwszScriptTypes[(ULONG)(x)] )

//
// Housekeeping internal APIs
//

PRSOP_ScriptList
CreateScriptList( ScriptType type );

ScriptType
GetScriptType( PRSOP_ScriptList pList );

void
SetScriptType( PRSOP_ScriptList pList, ScriptType type );

ULONG
GetScriptCount( PRSOP_ScriptList pList );

void
GetFirstScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime );

void
GetNextScript( PRSOP_ScriptList pList, void** pHandle, LPCWSTR* pszCommand, LPCWSTR* pszParams, SYSTEMTIME** pExecTime );

//
// exported APIs and definitions
//

#include "ScrptLog.h"

#endif // _SCRPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\gina\snapins\gptext\scripts.cpp ===
#include "gptext.h"
#include <initguid.h>
#include "scripts.h"
#include "smartptr.h"
#include "wbemtime.h"
#include <Psapi.h>
#include <strsafe.h>

//
// Result pane items for the GPE Scripts node
//

RESULTITEM g_GPEScriptsRoot[] =
{
    { 1, 0, 0, 0, 0, {0} },
};


RESULTITEM g_GPEScriptsUser[] =
{
    { 2, 1, IDS_LOGON, IDS_SCRIPTS_LOGON, 3, {0} },
    { 3, 1, IDS_LOGOFF, IDS_SCRIPTS_LOGOFF, 3, {0} },
};

RESULTITEM g_GPEScriptsMachine[] =
{
    { 4, 2, IDS_STARTUP, IDS_SCRIPTS_STARTUP, 3, {0} },
    { 5, 2, IDS_SHUTDOWN, IDS_SCRIPTS_SHUTDOWN, 3, {0} },
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_GPEScriptsNameSpace[] =
{
    { 0, -1, 0,                        IDS_SCRIPTS_DESC,          1, {0}, 0, g_GPEScriptsRoot, &NODEID_ScriptRoot },           // Scripts Root
    { 1 , 0, IDS_SCRIPTS_NAME_USER,    IDS_SCRIPTS_USER_DESC,     0, {0}, 2, g_GPEScriptsUser, &NODEID_ScriptRootUser },       // Scripts node (user)
    { 2 , 0, IDS_SCRIPTS_NAME_MACHINE, IDS_SCRIPTS_COMPUTER_DESC, 0, {0}, 2, g_GPEScriptsMachine, &NODEID_ScriptRootMachine }  // Scripts node (machine)
};


//
// Result pane items for the RSOP Scripts node
//

RESULTITEM g_RSOPScriptsRoot[] =
{
    { 1, 0, 0, 0, 0, {0} },
};


RESULTITEM g_RSOPScriptsUser[] =
{
    { 2, 1, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsMachine[] =
{
    { 3, 2, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsLogon[] =
{
    { 4, 3, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsLogoff[] =
{
    { 5, 4, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsStartup[] =
{
    { 6, 5, 0, 0, 0, {0} },
};

RESULTITEM g_RSOPScriptsShutdown[] =
{
    { 7, 6, 0, 0, 0, {0} },
};


//
// Namespace (scope) items
//

NAMESPACEITEM g_RSOPScriptsNameSpace[] =
{
    { 0, -1, 0,                        IDS_SCRIPTS_DESC,          1, {0}, 0, g_RSOPScriptsRoot, &NODEID_RSOPScriptRoot },           // Scripts Root
    { 1 , 0, IDS_SCRIPTS_NAME_USER,    IDS_SCRIPTS_USER_DESC,     2, {0}, 0, g_RSOPScriptsUser, &NODEID_RSOPScriptRootUser },       // Scripts node (user)
    { 2 , 0, IDS_SCRIPTS_NAME_MACHINE, IDS_SCRIPTS_COMPUTER_DESC, 2, {0}, 0, g_RSOPScriptsMachine, &NODEID_RSOPScriptRootMachine }, // Scripts node (machine)

    { 3 , 1, IDS_LOGON,                IDS_SCRIPTS_LOGON,         0, {0}, 0, g_RSOPScriptsLogon, &NODEID_RSOPLogon },               // Logon node
    { 4 , 1, IDS_LOGOFF,               IDS_SCRIPTS_LOGOFF,        0, {0}, 0, g_RSOPScriptsLogoff, &NODEID_RSOPLogoff },             // Logoff node

    { 5 , 2, IDS_STARTUP,              IDS_SCRIPTS_STARTUP,       0, {0}, 0, g_RSOPScriptsStartup, &NODEID_RSOPStartup },           // Startup node
    { 6 , 2, IDS_SHUTDOWN,             IDS_SCRIPTS_SHUTDOWN,      0, {0}, 0, g_RSOPScriptsShutdown, &NODEID_RSOPShutdown }          // Shutdown node
};




//
// Script types
//

typedef enum _SCRIPTINFOTYPE {
    ScriptType_Logon = 0,
    ScriptType_Logoff,
    ScriptType_Startup,
    ScriptType_Shutdown
} SCRIPTINFOTYPE, *LPSCRIPTINFOTYPE;


//
// Structure passed to a script dialog
//

typedef struct _SCRIPTINFO
{
    CScriptsSnapIn * pCS;
    SCRIPTINFOTYPE   ScriptType;
} SCRIPTINFO, *LPSCRIPTINFO;


//
// Structure passed to a Add / edit script dialog
//

typedef struct _SCRIPTEDITINFO
{
    LPSCRIPTINFO     lpScriptInfo;
    BOOL             bEdit;
    LPTSTR           lpName;
    LPTSTR           lpArgs;
} SCRIPTEDITINFO, *LPSCRIPTEDITINFO;


//
// Structure stored in listview item
//

typedef struct _SCRIPTITEM
{
    LPTSTR  lpName;
    LPTSTR  lpArgs;
} SCRIPTITEM, *LPSCRIPTITEM;


//
// Scripts directory and ini file names in GPO
//

#define SCRIPTS_DIR_NAME    TEXT("Scripts")
#define SCRIPTS_FILE_NAME   TEXT("scripts.ini")


//
// Help ids
//

DWORD aScriptsHelpIds[] =
{
    IDC_SCRIPT_TITLE,             IDH_SCRIPT_TITLE,
    IDC_SCRIPT_HEADING,           IDH_SCRIPT_HEADING,
    IDC_SCRIPT_LIST,              IDH_SCRIPT_LIST,
    IDC_SCRIPT_UP,                IDH_SCRIPT_UP,
    IDC_SCRIPT_DOWN,              IDH_SCRIPT_DOWN,
    IDC_SCRIPT_ADD,               IDH_SCRIPT_ADD,
    IDC_SCRIPT_EDIT,              IDH_SCRIPT_EDIT,
    IDC_SCRIPT_REMOVE,            IDH_SCRIPT_REMOVE,
    IDC_SCRIPT_SHOW,              IDH_SCRIPT_SHOW,

    0, 0
};


DWORD aScriptsEditHelpIds[] =
{
    IDC_SCRIPT_NAME,              IDH_SCRIPT_NAME,
    IDC_SCRIPT_ARGS,              IDH_SCRIPT_ARGS,
    IDC_SCRIPT_BROWSE,            IDH_SCRIPT_BROWSE,

    0, 0
};


void FreeResultItem(LPSCRIPTRESULTITEM pScriptResultItem)
{
    LPRSOPSCRIPTITEM    pRsopScriptItem = NULL; 
    LPRSOPSCRIPTITEM    pNext = NULL;
    if(NULL == pScriptResultItem)
    {
        return;
    }

    LocalFree(pScriptResultItem->lpResultItem);
    LocalFree((HLOCAL)pScriptResultItem->pNodeID);

    pRsopScriptItem = pScriptResultItem->lpRSOPScriptItem;
    while(pRsopScriptItem != NULL)
    {
        pNext = pRsopScriptItem->pNext;
        LocalFree(pRsopScriptItem->lpCommandLine);
        LocalFree(pRsopScriptItem->lpArgs);
        LocalFree(pRsopScriptItem->lpGPOName);
        LocalFree(pRsopScriptItem->lpDate);
        LocalFree(pRsopScriptItem);
        pRsopScriptItem = pNext;
    }

    LocalFree(pScriptResultItem);
}


HRESULT CScriptsDataObject::SetCookie(MMC_COOKIE cookie)
{ 
    HRESULT hr = E_OUTOFMEMORY;

    LPSCRIPTRESULTITEM pDest = NULL;

    if ( CCT_RESULT == m_type ) 
    {
        //    
        // Free the old cookie
        //

        if (NULL == cookie)
        {
            m_cookie = NULL;
            return hr;
        }
        
        FreeResultItem((LPSCRIPTRESULTITEM) m_cookiePrevRes);
        m_cookiePrevRes = NULL;

        LPSCRIPTRESULTITEM pSrc = (LPSCRIPTRESULTITEM) cookie;
        
        pDest = (LPSCRIPTRESULTITEM) LocalAlloc( LPTR, sizeof(SCRIPTRESULTITEM) );
        
        if ( ! pDest ) 
        {            
            goto CScriptsDataObject_SetCookie_exit;
        }

        if ( pSrc->lpResultItem != NULL) 
        {
            pDest->lpResultItem = (LPRESULTITEM) LocalAlloc(LPTR, sizeof(RESULTITEM));

            if ( pDest->lpResultItem )
            {
                memcpy((void *) (pDest->lpResultItem), pSrc->lpResultItem, sizeof(RESULTITEM));
            }
            else
            {
                goto CScriptsDataObject_SetCookie_exit;
            }
        }
        else
        {
            pDest->lpResultItem = NULL;
        }

        if (pSrc->pNodeID != NULL) 
        {
            pDest->pNodeID =  (GUID *) LocalAlloc(LPTR, sizeof(GUID));

            if ( pDest->pNodeID )
            {
                memcpy((void *)(pDest->pNodeID),pSrc->pNodeID,sizeof(GUID));
            }
            else
            {
                goto CScriptsDataObject_SetCookie_exit;
            }
        }
        else
        {
            pDest->pNodeID = NULL;
        }

        pDest->iDescStringID = pSrc->iDescStringID;


        LPRSOPSCRIPTITEM pSrcItem;
        LPRSOPSCRIPTITEM pDestItem = NULL;

        for (pSrcItem = pSrc->lpRSOPScriptItem; pSrcItem != NULL; pSrcItem = pSrcItem->pNext, pDestItem = pDestItem->pNext) 
        {
            ULONG ulNoChars;

            pDestItem = (LPRSOPSCRIPTITEM) LocalAlloc(LPTR, sizeof(RSOPSCRIPTITEM));

            if ( pDestItem )
            {
                if (pSrcItem->lpCommandLine) 
                {
                    ulNoChars = lstrlen(pSrcItem->lpCommandLine) + 1;
                    pDestItem->lpCommandLine = (LPTSTR) LocalAlloc(LPTR, ulNoChars * sizeof(WCHAR)); 
                    hr = StringCchCopy (pDestItem->lpCommandLine, ulNoChars, pSrcItem->lpCommandLine);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    pDestItem->lpCommandLine = NULL;
                }

                if (pSrcItem->lpArgs) 
                {
                    ulNoChars = lstrlen(pSrcItem->lpArgs) + 1;
                    pDestItem->lpArgs = (LPTSTR) LocalAlloc(LPTR, ulNoChars * sizeof(WCHAR)); 
                    hr = StringCchCopy (pDestItem->lpArgs, ulNoChars, pSrcItem->lpArgs);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    pDestItem->lpArgs = NULL;
                }

                if (pSrcItem->lpGPOName) 
                {
                    ulNoChars = lstrlen(pSrcItem->lpGPOName) + 1;
                    pDestItem->lpGPOName = (LPTSTR) LocalAlloc(LPTR, ulNoChars* sizeof(WCHAR)); 
                    hr = StringCchCopy (pDestItem->lpGPOName, ulNoChars, pSrcItem->lpGPOName);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    pDestItem->lpGPOName = NULL;
                }

                if (pSrcItem->lpDate) 
                {
                    ulNoChars = lstrlen(pSrcItem->lpDate) + 1;
                    pDestItem->lpDate = (LPTSTR) LocalAlloc (LPTR, ulNoChars * sizeof(WCHAR)); 
                    hr = StringCchCopy (pDestItem->lpDate, ulNoChars, pSrcItem->lpDate);
                    ASSERT(SUCCEEDED(hr));
                }
                else
                {
                    pDestItem->lpDate = NULL;
                }
            }
            else
            {
                goto CScriptsDataObject_SetCookie_exit;
            }
        
            if ( pSrcItem == pSrc->lpRSOPScriptItem )
            {
                pDest->lpRSOPScriptItem = pDestItem;
            }
        }
        if( pDestItem != NULL)
        {        
            pDestItem->pNext = NULL;
        }
        else
        {
            pDest->lpRSOPScriptItem = NULL;
        }

        m_cookie = (MMC_COOKIE) pDest;
        m_cookiePrevRes = m_cookie;
    } 
    else {
        m_cookie = cookie;             
    }
    
    hr = S_OK;

CScriptsDataObject_SetCookie_exit:

    if ( FAILED(hr) )
    {
        FreeResultItem( pDest );
    }

    return hr; 
}


HRESULT CompareDataObjects(LPSCRIPTDATAOBJECT pScriptDataObjectA, LPSCRIPTDATAOBJECT pScriptDataObjectB)
{
    HRESULT             hr = S_FALSE;
    MMC_COOKIE          cookie1;
    MMC_COOKIE          cookie2;
    DATA_OBJECT_TYPES   type1;
    DATA_OBJECT_TYPES   type2;

    pScriptDataObjectA->GetCookie(&cookie1);
    pScriptDataObjectA->GetType(&type1);

    pScriptDataObjectB->GetCookie(&cookie2);
    pScriptDataObjectB->GetType(&type2);
    
    if( type1 != type2 )
    {
        hr = S_FALSE;
    }
    else if ( type1 == CCT_SCOPE )
    {
        if (cookie1 == cookie2)
        {
            hr = S_OK;
        }
    }
    else
    {
        if ( NULL == cookie1 || NULL == cookie2 || -1 == cookie1 || -1 == cookie2)
        {
            if (cookie1 == cookie2) 
            {
                hr = S_OK;
            }
        }
        else
        {
            LPSCRIPTRESULTITEM item1 = (LPSCRIPTRESULTITEM) cookie1;
            LPSCRIPTRESULTITEM item2 = (LPSCRIPTRESULTITEM) cookie2;

            if ((item1->lpResultItem->dwID == item2->lpResultItem->dwID) && !memcmp(item1->pNodeID, item2->pNodeID, sizeof(GUID))) 
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation                               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

CScriptsComponentData::CScriptsComponentData(BOOL bUser, BOOL bRSOP)
{
    m_cRef = 1;
    m_bUserScope = bUser;
    m_bRSOP = bRSOP;
    InterlockedIncrement(&g_cRefThisDll);
    m_hwndFrame = NULL;
    m_pScope = NULL;
    m_pConsole = NULL;
    m_hRoot = NULL;
    m_pGPTInformation = NULL;
    m_pRSOPInformation = NULL;
    m_pScriptsDir = NULL;
    m_pszNamespace = NULL;

    if (bRSOP)
    {
        m_pNameSpaceItems = g_RSOPScriptsNameSpace;
        m_dwNameSpaceItemCount = ARRAYSIZE(g_RSOPScriptsNameSpace);
    }
    else
    {
        m_pNameSpaceItems = g_GPEScriptsNameSpace;
        m_dwNameSpaceItemCount = ARRAYSIZE(g_GPEScriptsNameSpace);
    }

    m_pRSOPLogon = NULL;
    m_pRSOPLogoff = NULL;
    m_pRSOPStartup = NULL;
    m_pRSOPShutdown = NULL;

}

CScriptsComponentData::~CScriptsComponentData()
{

    FreeRSOPScriptData();

    if (m_pScriptsDir)
    {
        LocalFree (m_pScriptsDir);
    }

    if (m_pszNamespace)
    {
        LocalFree (m_pszNamespace);
    }

    if (m_pScope)
    {
        m_pScope->Release();
    }

    if (m_pConsole)
    {
        m_pConsole->Release();
    }

    if (m_pGPTInformation)
    {
        m_pGPTInformation->Release();
    }

    if (m_pRSOPInformation)
    {
        m_pRSOPInformation->Release();
    }

    InterlockedDecrement(&g_cRefThisDll);

}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IUnknown)                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsComponentData::QueryInterface (REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IComponentData) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (LPCOMPONENTDATA)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
    {
        *ppv = (LPPERSISTSTREAMINIT)this;
        m_cRef++;
        return S_OK;
    }
    else if (IsEqualIID(riid, IID_ISnapinHelp))
    {
        *ppv = (LPSNAPINHELP)this;
        m_cRef++;
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

ULONG CScriptsComponentData::AddRef (void)
{
    return ++m_cRef;
}

ULONG CScriptsComponentData::Release (void)
{
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }

    return m_cRef;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IComponentData)                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::Initialize(LPUNKNOWN pUnknown)
{
    HRESULT hr;
    HBITMAP bmp16x16;
    LPIMAGELIST lpScopeImage;


    //
    // QI for IConsoleNameSpace
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (LPVOID *)&m_pScope);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for IConsoleNameSpace.")));
        return hr;
    }


    //
    // QI for IConsole
    //

    hr = pUnknown->QueryInterface(IID_IConsole2, (LPVOID *)&m_pConsole);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for IConsole.")));
        m_pScope->Release();
        m_pScope = NULL;
        return hr;
    }

    m_pConsole->GetMainWindow (&m_hwndFrame);


    //
    // Query for the scope imagelist interface
    //

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    if (FAILED(hr))
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Initialize: Failed to QI for scope imagelist.")));
        m_pScope->Release();
        m_pScope = NULL;
        m_pConsole->Release();
        m_pConsole=NULL;
        return hr;
    }

    // Load the bitmaps from the dll
    bmp16x16=LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16));

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(bmp16x16),
                      reinterpret_cast<LONG_PTR *>(bmp16x16),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::Destroy(VOID)
{
    return S_OK;
}

STDMETHODIMP CScriptsComponentData::CreateComponent(LPCOMPONENT *ppComponent)
{
    HRESULT hr;
    CScriptsSnapIn *pSnapIn;


    DebugMsg((DM_VERBOSE, TEXT("CScriptsComponentData::CreateComponent: Entering.")));

    //
    // Initialize
    //

    *ppComponent = NULL;


    //
    // Create the snapin view
    //

    pSnapIn = new CScriptsSnapIn(this);

    if (!pSnapIn)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::CreateComponent: Failed to create CScriptsSnapIn.")));
        return E_OUTOFMEMORY;
    }


    //
    // QI for IComponent
    //

    hr = pSnapIn->QueryInterface(IID_IComponent, (LPVOID *)ppComponent);
    pSnapIn->Release();     // release QI


    return hr;
}

STDMETHODIMP CScriptsComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                             LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = E_NOINTERFACE;
    CScriptsDataObject *pDataObject;
    LPSCRIPTDATAOBJECT pScriptDataObject;


    //
    // Create a new DataObject
    //

    pDataObject = new CScriptsDataObject(this);   // ref == 1

    if (!pDataObject)
        return E_OUTOFMEMORY;


    //
    // QI for the private GPTDataObject interface so we can set the cookie
    // and type information.
    //

    hr = pDataObject->QueryInterface(IID_IScriptDataObject, (LPVOID *)&pScriptDataObject);

    if (FAILED(hr))
    {
        pDataObject->Release();
        return (hr);
    }

    pScriptDataObject->SetType(type);
    
    pScriptDataObject->SetCookie(cookie);
    pScriptDataObject->Release();


    //
    // QI for a normal IDataObject to return.
    //

    hr = pDataObject->QueryInterface(IID_IDataObject, (LPVOID *)ppDataObject);

    pDataObject->Release();     // release initial ref

    return hr;
}

STDMETHODIMP CScriptsComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    switch(event)
    {
        case MMCN_REMOVE_CHILDREN:
            if ( ((HSCOPEITEM)arg != NULL) && m_bRSOP && (m_pRSOPInformation != NULL) )
            {
                if ( (HSCOPEITEM)arg == m_hRoot )
                {
                    FreeRSOPScriptData();
                    m_hRoot = NULL;
                    m_pRSOPInformation->Release();
                    m_pRSOPInformation = NULL;
                }
            }
            break;
            
        case MMCN_EXPAND:
            if (arg == TRUE)

                if (m_bRSOP)
                {
                    if (!m_pRSOPInformation)
                    {
                        lpDataObject->QueryInterface(IID_IRSOPInformation, (LPVOID *)&m_pRSOPInformation);

                        if (m_pRSOPInformation)
                        {
                            m_pszNamespace = (LPOLESTR) LocalAlloc (LPTR, 350 * sizeof(TCHAR));

                            if (m_pszNamespace)
                            {
                                if (m_pRSOPInformation->GetNamespace((m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE),
                                                                      m_pszNamespace, 350) == S_OK)
                                {
                                    InitializeRSOPScriptsData();

                                    if (LOWORD(dwDebugLevel) == DL_VERBOSE)
                                    {
                                        DumpRSOPScriptsData(m_pRSOPLogon);
                                        DumpRSOPScriptsData(m_pRSOPLogoff);
                                        DumpRSOPScriptsData(m_pRSOPStartup);
                                        DumpRSOPScriptsData(m_pRSOPShutdown);
                                    }
                                }
                                else
                                {
                                    DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify:  Failed to query for namespace")));
                                    LocalFree (m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }
                    }

                    if (m_pszNamespace)
                    {
                        BOOL bEnum = TRUE;

                        if (m_bUserScope)
                        {
                            if (!m_pRSOPLogon && !m_pRSOPLogoff)
                            {
                                bEnum = FALSE;
                                if (m_pRSOPInformation)
                                {
                                    FreeRSOPScriptData();
                                    m_pRSOPInformation->Release();
                                    m_pRSOPInformation = NULL;
                                    LocalFree(m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }
                        else
                        {
                            if (!m_pRSOPStartup && !m_pRSOPShutdown)
                            {
                                bEnum = FALSE;
                                if (m_pRSOPInformation)
                                {
                                    FreeRSOPScriptData();
                                    m_pRSOPInformation->Release();
                                    m_pRSOPInformation = NULL;
                                    LocalFree(m_pszNamespace);
                                    m_pszNamespace = NULL;
                                }
                            }
                        }

                        if (bEnum)
                        {
                            hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                        }
                    }
                }
                else
                {
                    if (!m_pGPTInformation)
                    {
                        lpDataObject->QueryInterface(IID_IGPEInformation, (LPVOID *)&m_pGPTInformation);
                    }

                    if (m_pGPTInformation)
                    {
                        if (!m_pScriptsDir)
                        {
                            m_pScriptsDir = (LPTSTR) LocalAlloc (LPTR, MAX_PATH * sizeof(TCHAR));

                            if (m_pScriptsDir)
                            {
                                if (SUCCEEDED(m_pGPTInformation->GetFileSysPath(m_bUserScope ? GPO_SECTION_USER : GPO_SECTION_MACHINE,
                                                               m_pScriptsDir, MAX_PATH * sizeof(TCHAR))))
                                {
                                    LPTSTR lpEnd;


                                    //
                                    // Create the Scripts directory
                                    //

                                    lpEnd = CheckSlash (m_pScriptsDir);
                                    
                                    hr = StringCchCopy(lpEnd, MAX_PATH - (lpEnd - m_pScriptsDir), SCRIPTS_DIR_NAME);
                                    ASSERT(SUCCEEDED(hr));

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }


                                    //
                                    // Create the appropriate sub directories
                                    //

                                    lpEnd = CheckSlash (m_pScriptsDir);

                                    if (m_bUserScope)
                                        hr = StringCchCopy (lpEnd, MAX_PATH - (lpEnd - m_pScriptsDir), TEXT("Logon"));
                                    else
                                        hr = StringCchCopy (lpEnd, MAX_PATH - (lpEnd - m_pScriptsDir), TEXT("Startup"));
            
                                    ASSERT(SUCCEEDED(hr));

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }

                                    if (m_bUserScope)
                                        hr = StringCchCopy (lpEnd, MAX_PATH - (lpEnd - m_pScriptsDir), TEXT("Logoff"));
                                    else
                                        hr = StringCchCopy (lpEnd, MAX_PATH - (lpEnd - m_pScriptsDir), TEXT("Shutdown"));

                                    ASSERT(SUCCEEDED(hr));

                                    if (!CreateNestedDirectory(m_pScriptsDir, NULL))
                                    {
                                        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to create scripts sub-directory with %d."),
                                                 GetLastError()));
                                        LocalFree (m_pScriptsDir);
                                        m_pScriptsDir = NULL;
                                        break;
                                    }

                                    *(lpEnd - 1) = TEXT('\0');
                                }
                                else
                                {
                                   DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::Notify: Failed to get file system path.")));
                                   LocalFree (m_pScriptsDir);
                                   m_pScriptsDir = NULL;
                                }
                            }
                        }

                        if (m_pScriptsDir)
                        {
                            hr = EnumerateScopePane(lpDataObject, (HSCOPEITEM)param);
                        }
                    }
                }
            break;

        default:
            break;
    }

    return hr;
}

STDMETHODIMP CScriptsComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DWORD dwIndex;

    if (pItem == NULL)
        return E_POINTER;

    for (dwIndex = 0; dwIndex < m_dwNameSpaceItemCount; dwIndex++)
    {
        if (m_pNameSpaceItems[dwIndex].dwID == (DWORD) pItem->lParam)
            break;
    }

    if (dwIndex == m_dwNameSpaceItemCount)
        pItem->displayname = NULL;
    else
    {
        pItem->displayname = m_pNameSpaceItems[dwIndex].szDisplayName;
    }

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    HRESULT hr = S_FALSE;
    LPSCRIPTDATAOBJECT pScriptDataObjectA, pScriptDataObjectB;


    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    //
    // QI for the private GPTDataObject interface
    //

    if (FAILED(lpDataObjectA->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectA)))
    {
        return S_FALSE;
    }


    if (FAILED(lpDataObjectB->QueryInterface(IID_IScriptDataObject,
                                            (LPVOID *)&pScriptDataObjectB)))
    {
        pScriptDataObjectA->Release();
        return S_FALSE;
    }

    hr = CompareDataObjects(pScriptDataObjectA,pScriptDataObjectB);

    pScriptDataObjectA->Release();
    pScriptDataObjectB->Release();

    return hr;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (IPersistStreamInit)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::GetClassID(CLSID *pClassID)
{

    if (!pClassID)
    {
        return E_FAIL;
    }

    if (m_bUserScope)
        *pClassID = CLSID_ScriptSnapInUser;
    else
        *pClassID = CLSID_ScriptSnapInMachine;

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::IsDirty(VOID)
{
    return S_FALSE;
}

STDMETHODIMP CScriptsComponentData::Load(IStream *pStm)
{
    return S_OK;
}


STDMETHODIMP CScriptsComponentData::Save(IStream *pStm, BOOL fClearDirty)
{
    return S_OK;
}


STDMETHODIMP CScriptsComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DWORD dwSize = 0;


    if (!pcbSize)
    {
        return E_FAIL;
    }

    ULISet32(*pcbSize, dwSize);

    return S_OK;
}

STDMETHODIMP CScriptsComponentData::InitNew(void)
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (ISnapinHelp)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CScriptsComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    LPOLESTR lpHelpFile;


    lpHelpFile = (LPOLESTR) CoTaskMemAlloc (MAX_PATH * sizeof(WCHAR));

    if (!lpHelpFile)
    {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::GetHelpTopic: Failed to allocate memory.")));
        return E_OUTOFMEMORY;
    }

    ExpandEnvironmentStringsW (L"%SystemRoot%\\Help\\gptext.chm",
                               lpHelpFile, MAX_PATH);

    *lpCompiledHelpFile = lpHelpFile;

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// CScriptsComponentData object implementation (Internal functions)                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT CScriptsComponentData::EnumerateScopePane (LPDATAOBJECT lpDataObject, HSCOPEITEM hParent)
{
    SCOPEDATAITEM item;
    HRESULT hr;
    DWORD dwIndex, i;


    if (!m_hRoot)
        m_hRoot = hParent;


    if (m_hRoot == hParent)
        dwIndex = 0;
    else
    {
        item.mask = SDI_PARAM;
        item.ID = hParent;

        hr = m_pScope->GetItem (&item);

        if (FAILED(hr))
            return hr;

        dwIndex = (DWORD)item.lParam;
    }

    for (i = 0; i < m_dwNameSpaceItemCount; i++)
    {
        if (m_pNameSpaceItems[i].dwParent == dwIndex)
        {
            BOOL bAdd = TRUE;

            //
            // Need to special case the 2 main root nodes
            //

            if (dwIndex == 0)
            {
                if (m_bUserScope)
                {
                    if (i == 2)
                    {
                        bAdd = FALSE;
                    }
                }
                else
                {
                    if (i == 1)
                    {
                        bAdd = FALSE;
                    }
                }
            }


            //
            // Don't show a node if it has no data
            //

            if ((i == 3) && !m_pRSOPLogon)
            {
                bAdd = FALSE;
            }
            else if ((i == 4) && !m_pRSOPLogoff)
            {
                bAdd = FALSE;
            }
            else if ((i == 5) && !m_pRSOPStartup)
            {
                bAdd = FALSE;
            }
            else if ((i == 6) && !m_pRSOPShutdown)
            {
                bAdd = FALSE;
            }


            if (bAdd)
            {
                item.mask = SDI_STR | SDI_STATE | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
                item.displayname = MMC_CALLBACK;
                item.nImage = (i > 2) ? 0 : 3;
                item.nOpenImage = (i > 2) ? 1 : 3;
                item.nState = 0;
                item.cChildren = m_pNameSpaceItems[i].cChildren;
                item.lParam = m_pNameSpaceItems[i].dwID;
                item.relativeID =  hParent;

                m_pScope->InsertItem (&item);

            }
        }
    }


    return S_OK;
}

BOOL CScriptsComponentData::AddRSOPScriptDataNode(LPTSTR lpCommandLine, LPTSTR lpArgs,
                             LPTSTR lpGPOName, LPTSTR lpDate, UINT uiScriptType)
{
    DWORD dwSize;
    LPRSOPSCRIPTITEM lpItem, lpTemp;
    HRESULT hr = S_OK;

    //
    // Calculate the size of the new registry item
    //

    dwSize = sizeof (RSOPSCRIPTITEM);

    if (lpCommandLine) {
        dwSize += ((lstrlen(lpCommandLine) + 1) * sizeof(TCHAR));
    }

    if (lpArgs) {
        dwSize += ((lstrlen(lpArgs) + 1) * sizeof(TCHAR));
    }

    if (lpGPOName) {
        dwSize += ((lstrlen(lpGPOName) + 1) * sizeof(TCHAR));
    }

    if (lpDate) {
        dwSize += ((lstrlen(lpDate) + 1) * sizeof(TCHAR));
    }



    //
    // Allocate space for it
    //

    lpItem = (LPRSOPSCRIPTITEM) LocalAlloc (LPTR, dwSize);

    if (!lpItem) {
        DebugMsg((DM_WARNING, TEXT("CScriptsComponentData::AddRSOPRegistryDataNode: Failed to allocate memory with %d"),
                 GetLastError()));
        return FALSE;
    }


    //
    // Fill in item
    //

    if (lpCommandLine)
    {
        lpItem->lpCommandLine = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
        hr = StringCchCopy (lpItem->lpCommandLine, lstrlen(lpCommandLine) + 1, lpCommandLine);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpArgs)
    {
        if (lpCommandLine)
        {
            lpItem->lpArgs = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
        }
        else
        {
            lpItem->lpArgs = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
        }

        hr = StringCchCopy (lpItem->lpArgs, lstrlen(lpArgs) + 1, lpArgs);
        ASSERT(SUCCEEDED(hr));
    }

    if (lpGPOName)
    {
        if (lpArgs)
        {
            lpItem->lpGPOName = lpItem->lpArgs + lstrlen (lpItem->lpArgs) + 1;
        }
        else
        {
            if (lpCommandLine)
            {
                lpItem->lpGPOName = lpItem->lpCommandLine + lstrlen (lpItem->lpCommandLine) + 1;
            }
            else
            {
                lpItem->lpGPOName = (LPTSTR)(((LPBYTE)lpItem) + sizeof(RSOPSCRIPTITEM));
            }
        }

        hr = StringCchCopy (lpItem->lpGPONam