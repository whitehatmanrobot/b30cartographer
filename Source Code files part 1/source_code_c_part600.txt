olorKey.LowColorValue;
        m_HighColor = ColorKey.HighColorValue;

        HDC hDC = GetDC( NULL );
        BOOL bPalette;
        if ( hDC )
            bPalette = (RC_PALETTE == (RC_PALETTE & GetDeviceCaps( hDC, RASTERCAPS )));
        else
            bPalette = FALSE;

        if ( m_dwKeyType&CK_INDEX && bPalette) {
            CheckRadioButton( m_hDlg, IDC_COLORKEY_NONE, IDC_COLORKEY_RGB, IDC_COLORKEY_INDEX );

            PALETTEENTRY PaletteEntry;
            UINT nTmp = GetSystemPaletteEntries( hDC, m_dwPaletteIndex, 1, &PaletteEntry );
            if ( nTmp == 1 )
            {
                m_HighColor = m_LowColor = RGB( PaletteEntry.peRed, PaletteEntry.peGreen, PaletteEntry.peBlue );
            }
            m_dwKeyType = CK_INDEX;
            SendMessage( m_hDlg, WM_COMMAND, IDC_COLORKEY_INDEX, 0L );
            SetDlgItemInt( m_hDlg, IDC_COLORKEY_INDEXENTRY, m_dwPaletteIndex, FALSE );
        }
        else if ( m_dwKeyType&CK_RGB) {
            CheckRadioButton( m_hDlg, IDC_COLORKEY_NONE, IDC_COLORKEY_RGB, IDC_COLORKEY_RGB );
            m_dwKeyType = CK_RGB;
            SendMessage( m_hDlg, WM_COMMAND, IDC_COLORKEY_RGB, 0L );
            SetDlgItemInt( m_hDlg, IDC_COLORKEY_R, GetRValue(m_LowColor), FALSE );
            SetDlgItemInt( m_hDlg, IDC_COLORKEY_G, GetGValue(m_LowColor), FALSE );
            SetDlgItemInt( m_hDlg, IDC_COLORKEY_B, GetBValue(m_LowColor), FALSE );
        }

        else {
            CheckRadioButton( m_hDlg, IDC_COLORKEY_NONE, IDC_COLORKEY_INDEX, IDC_COLORKEY_NONE );
            SendMessage( m_hDlg, WM_COMMAND, IDC_COLORKEY_NONE, 0L );
        }
        if ( hDC )
            ReleaseDC( NULL, hDC );
    }

    else
    {
        SetDlgItemText( m_hDlg, IDC_COLORKEY_R, TEXT("") );
        SetDlgItemText( m_hDlg, IDC_COLORKEY_G, TEXT("") );
        SetDlgItemText( m_hDlg, IDC_COLORKEY_B, TEXT("") );
        SetDlgItemText( m_hDlg, IDC_COLORKEY_INDEXENTRY, TEXT("") );
        lstrcat( szError, TEXT("Error Getting ColorKey\n") );
    }

    if ( 0 != lstrlen( szError ) )
        SetDlgItemText( m_hDlg, IDC_PININFO, szError );
}


//
// OnApplyChanges
//
// Override CBasePropertyPage method.
// Process changes in IMixerPinConfig properties and reset m_bDirty bit
//
HRESULT COMPinConfigProperties::OnApplyChanges()
{
    HRESULT	hr = S_OK;
    TCHAR	szError[255];

    lstrcpy( szError, TEXT("") );

    COLORKEY ColorKey;
    if (m_dwKeyType == CK_NOCOLORKEY)
        ColorKey.KeyType = CK_NOCOLORKEY;
    else {
        ColorKey.KeyType = CK_RGB;
        if (m_dwKeyType == CK_INDEX)
            ColorKey.KeyType |= CK_INDEX;
    }

    ColorKey.PaletteIndex = m_dwPaletteIndex;
    ColorKey.LowColorValue = m_LowColor;
    ColorKey.HighColorValue = m_HighColor;
    hr = m_pIMixerPinConfig3->SetColorKey( &ColorKey );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Setting ColorKey\n") );
    }

    hr = m_pIMixerPinConfig3->SetZOrder( m_dwZOrder );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Setting ZOrder\n") );
    }

    hr = m_pIMixerPinConfig3->SetBlendingParameter( m_dwBlending );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Setting Blending\n") );
    }

    hr = m_pIMixerPinConfig3->SetAspectRatioMode( m_amAspectRatioMode );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Setting Aspect Ratio\n") );
    }

    hr = m_pIMixerPinConfig3->SetStreamTransparent( m_fTransparent );
    if ( S_OK != hr )
    {
        lstrcat( szError, TEXT("Error Setting Transparency\n") );
    }

    SetDlgItemText( m_hDlg, IDC_PININFO, szError );

    // Reset dirty bit
    if ( S_OK == IsPageDirty() ) {
        m_bDirty = FALSE;
        if (m_pPageSite)
            m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

    return hr;
} // OnApplyChanges


//
// SetDirty
//
// Sets m_bDirty and notifies the property page site of the change
//
void COMPinConfigProperties::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
} // SetDirty


//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which object this property page should display.
// We query the object for the IID_IMixerPinConfig3 interface.
//
// If cObjects == 0 then we must release the interface.
// Initialize class variables
HRESULT COMPinConfigProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIMixerPinConfig3 == NULL);
    ASSERT(m_pIPin == NULL);

    HRESULT hr = S_OK;

    // Query for IEnumPinConfig, if added for the filter
    CComPtr <IEnumPinConfig> pEnumPinConfig = NULL;

    hr = pUnknown->QueryInterface(IID_IEnumPinConfig, (void**) &pEnumPinConfig);
    if (SUCCEEDED(hr) && pEnumPinConfig) {
        hr = pEnumPinConfig->Next(&m_pIMixerPinConfig3);
        if (FAILED(hr))
            return hr;
        hr = m_pIMixerPinConfig3->QueryInterface(IID_IPin, (void**) &m_pIPin);
        if (FAILED(hr)) {
            m_pIMixerPinConfig3->Release();
            return hr;
        }
    }

    // Query for IPin directly, if added for the pin
    else  {
        hr = pUnknown->QueryInterface(IID_IPin, (void**) &m_pIPin);
        if (FAILED(hr))
            return hr;
        hr = m_pIPin->QueryInterface(IID_IMixerPinConfig3, (void **) &m_pIMixerPinConfig3);
        if (FAILED(hr)) {
            m_pIPin->Release();
            return hr;
        }
    }

    ASSERT(m_pIMixerPinConfig3);
    ASSERT(m_pIPin);

    return hr;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface.
//
HRESULT COMPinConfigProperties::OnDisconnect()
{
    // Release of Interface

    if (m_pIMixerPinConfig3) {
        m_pIMixerPinConfig3->Release();
        m_pIMixerPinConfig3 = NULL;
    }

    if (m_pIPin) {
        m_pIPin->Release();
        m_pIPin = NULL;
    }

    return NOERROR;

} // OnDisconnect


//
// CreateInstance
//
// Override CClassFactory method.
// Set lpUnk to point to an IUnknown interface on a new COMVPInfoProperties object
// Part of the COM object instantiation mechanism
//
CUnknown * WINAPI COMVPInfoProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new COMVPInfoProperties(lpunk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
} // CreateInstance


//
// COMVPInfoProperties::Constructor
//
// Constructs and initialises an COMVPInfoProperties object
//
COMVPInfoProperties::COMVPInfoProperties(LPUNKNOWN pUnk, HRESULT *phr)
: CBasePropertyPage(NAME("Overlay Mixer Property Page"),pUnk,
                    IDD_IVPINFO, IDS_TITLE_VPINFO)
                    , m_pIVPInfo(NULL)
                    , m_hDlg(HWND(NULL))

{
    ASSERT(phr);

} // (constructor) COMVPInfoProperties


BOOL COMVPInfoProperties::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    m_hDlg = hwnd;
    // Set the font in the listbox to a fixed width font
    SetWindowFont(GetDlgItem (hwnd, IDC_VPINFO), GetStockObject(ANSI_FIXED_FONT), FALSE);
    return TRUE;
}


void COMVPInfoProperties::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDC_RESET:
        Reset();
        break;
    case IDC_VP_CONFIG:
    case IDC_VP_BANDWIDTH:
    case IDC_VP_CAPS:
    case IDC_VP_FX:
    case IDC_VP_INFO:
        SetEditFieldData(id);
        break;
    }
}


// Handles the messages for our property window

INT_PTR COMVPInfoProperties::OnReceiveMessage(HWND hwnd,
                                           UINT uMsg,
                                           WPARAM wParam,
                                           LPARAM lParam)
{
    switch (uMsg) {
        HANDLE_MSG(hwnd, WM_COMMAND,    OnCommand);
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    }

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}


void COMVPInfoProperties::Reset()
{
    ASSERT(m_pIVPInfo);

    m_pIVPInfo->GetPixelsPerSecond(&m_dwPixelsPerSecond);
    m_pIVPInfo->GetCropState(&m_CropState);
    m_pIVPInfo->GetVPDataInfo(&m_VPDataInfo);

    m_pIVPInfo->GetVPBandwidth(&m_sBandwidth);
    m_pIVPInfo->GetVPCaps(&m_VPCaps);
    m_pIVPInfo->GetVPInfo(&m_sVPInfo);

    CheckDlgButton(m_hDlg, IDC_VP_CONFIG, BST_CHECKED);
    SetEditFieldData(IDC_VP_CONFIG);
}


//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which object this property page should display.
// We query the object for the ITestOMProp interface.
//
// If cObjects == 0 then we must release the interface.
HRESULT COMVPInfoProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIVPInfo == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IVPInfo,
        (void **) &m_pIVPInfo);

    if (FAILED(hr))
        return hr;

    ASSERT(m_pIVPInfo);

    return hr;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface.
//
HRESULT COMVPInfoProperties::OnDisconnect()
{
    // Release of Interface

    if (m_pIVPInfo) {
        m_pIVPInfo->Release();
        m_pIVPInfo = NULL;
    }

    return NOERROR;

} // OnDisconnect


// Create the window we will use to edit properties

HRESULT COMVPInfoProperties::OnActivate()
{
    Reset();
    return NOERROR;
}


// Initialise the property page fields

void COMVPInfoProperties::SetEditFieldData(int id)
{
    TCHAR buffer[2048];
    switch (id) {
    case IDC_VP_CONFIG:
        wsprintf(buffer,
            TEXT("[VPConfig]\r\n")
            TEXT("Max Pixel Rate                 %7d\r\n")
            TEXT("Crop State                     %7d\r\n")
            TEXT("Microseconds Per Field         %7d\r\n")
            TEXT("Field Width                    %7d\r\n")
            TEXT("Field Height                   %7d\r\n")
            TEXT("VBI Width                      %7d\r\n")
            TEXT("VBI Height                     %7d\r\n")
            TEXT("Valid Region         [%3d,%3d,%3d,%3d]\r\n")
            TEXT("Pict Aspect Ratio X            %7d\r\n")
            TEXT("Pict Aspect Ratio Y            %7d\r\n")
            TEXT("Enable Double Clock            %7d\r\n")
            TEXT("Enable VACT                    %7d\r\n")
            TEXT("Data Is Interlaced             %7d\r\n")
            TEXT("Half Lines Odd                 %7ld\r\n")
            TEXT("Half Lines Even                %7ld\r\n")
            TEXT("Field Polarity Inverted        %7d\r\n")
            TEXT("Num Lines In VREF              %7d\r\n"),
            m_dwPixelsPerSecond,
            m_CropState,
            m_VPDataInfo.dwMicrosecondsPerField,
            m_VPDataInfo.amvpDimInfo.dwFieldWidth,
            m_VPDataInfo.amvpDimInfo.dwFieldHeight,
            m_VPDataInfo.amvpDimInfo.dwVBIWidth,
            m_VPDataInfo.amvpDimInfo.dwVBIHeight,
            m_VPDataInfo.amvpDimInfo.rcValidRegion.left,
            m_VPDataInfo.amvpDimInfo.rcValidRegion.top,
            m_VPDataInfo.amvpDimInfo.rcValidRegion.right,
            m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom,
            m_VPDataInfo.dwPictAspectRatioX,
            m_VPDataInfo.dwPictAspectRatioY,
            (m_VPDataInfo.bEnableDoubleClock)>0,
            (m_VPDataInfo.bEnableVACT)>0,
            (m_VPDataInfo.bDataIsInterlaced)>0,
            m_VPDataInfo.lHalfLinesOdd,
            m_VPDataInfo.lHalfLinesEven,
            (m_VPDataInfo.bFieldPolarityInverted)>0,
            m_VPDataInfo.dwNumLinesInVREF
            );
        break;
    case IDC_VP_BANDWIDTH:
        wsprintf(buffer,
            TEXT("[DDVIDEOPORTBANDWIDTH]\r\n")
            TEXT("DDVPBCAPS_DESTINATION          %7d\r\n")
            TEXT("DDVPBCAPS_SOURCE               %7d\r\n")
            TEXT("Overlay                        %7d\r\n")
            TEXT("Colorkey                       %7d\r\n")
            TEXT("Y Interpolate                  %7d\r\n")
            TEXT("Y Interp And Colorkey          %7d\r\n"),
            (m_sBandwidth.dwCaps&DDVPBCAPS_DESTINATION)>0,
            (m_sBandwidth.dwCaps&DDVPBCAPS_SOURCE)>0,
            m_sBandwidth.dwOverlay,
            m_sBandwidth.dwColorkey,
            m_sBandwidth.dwYInterpolate,
            m_sBandwidth.dwYInterpAndColorkey
            );
        break;


    case IDC_VP_CAPS:
        wsprintf(buffer,
            TEXT("[DDVIDEOPORTCAPS]\r\n")
            TEXT("Max Width                      %7d\r\n")
            TEXT("Max Height                     %7d\r\n")
            TEXT("Max VBI Width                  %7d\r\n")
            TEXT("Num Auto Flip Surfaces         %7d\r\n")
            TEXT("Align Video Port Boundary      %7d\r\n")
            TEXT("Align Video Port Prescale Wid  %7d\r\n")
            TEXT("Align Video Port Crop Boundary %7d\r\n")
            TEXT("Align Video Port Crop Width    %7d\r\n")
            TEXT("Preshrink X Step               %7d\r\n")
            TEXT("Preshrink Y Step               %7d\r\n")
            TEXT("Num VBI Auto Flip Surfaces     %7d\r\n")
            //"NumPreferredAutoflip          %d\r\n"
            //"NumFilterTapsX                %d\r\n"
            //"NumFilterTapsY                %d\r\n"
            TEXT("DDVPCAPS_AUTOFLIP              %7d\r\n")
            TEXT("DDVPCAPS_COLORCONTROL          %7d\r\n")
            TEXT("DDVPCAPS_INTERLACED            %7d\r\n")
            TEXT("DDVPCAPS_NONINTERLACED         %7d\r\n")
            TEXT("DDVPCAPS_OVERSAMPLEDVBI        %7d\r\n")
            TEXT("DDVPCAPS_READBACKFIELD         %7d\r\n")
            TEXT("DDVPCAPS_READBACKLINE          %7d\r\n")
            TEXT("DDVPCAPS_SHAREABLE             %7d\r\n")
            TEXT("DDVPCAPS_SKIPEVENFIELDS        %7d\r\n")
            TEXT("DDVPCAPS_SKIPODDFIELDS         %7d\r\n")
            TEXT("DDVPCAPS_SYNCMASTER            %7d\r\n")
            TEXT("DDVPCAPS_SYSTEMMEMORY          %7d\r\n")
            TEXT("DDVPCAPS_VBIANDVIDEOINDEPENDENT%7d\r\n")
            TEXT("DDVPCAPS_VBISURFACE            %7d\r\n"),
            m_VPCaps.dwMaxWidth,
            m_VPCaps.dwMaxHeight,
            m_VPCaps.dwMaxVBIWidth,
            m_VPCaps.dwNumAutoFlipSurfaces,
            m_VPCaps.dwAlignVideoPortBoundary,
            m_VPCaps.dwAlignVideoPortPrescaleWidth,
            m_VPCaps.dwAlignVideoPortCropBoundary,
            m_VPCaps.dwAlignVideoPortCropWidth,
            m_VPCaps.dwPreshrinkXStep,
            m_VPCaps.dwPreshrinkYStep,
            m_VPCaps.dwNumVBIAutoFlipSurfaces,
            //m_VPCaps.dwNumPreferredAutoflip,
            //m_VPCaps.wNumFilterTapsX,
            //m_VPCaps.wNumFilterTapsY,
            (m_VPCaps.dwCaps&DDVPCAPS_AUTOFLIP)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_COLORCONTROL)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_INTERLACED)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_NONINTERLACED)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_OVERSAMPLEDVBI)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_READBACKFIELD)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_READBACKLINE)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_SHAREABLE)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_SKIPEVENFIELDS)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_SKIPODDFIELDS)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_SYNCMASTER)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_SYSTEMMEMORY)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_VBIANDVIDEOINDEPENDENT)>0,
            (m_VPCaps.dwCaps&DDVPCAPS_VBISURFACE)>0
            );
        break;

    case IDC_VP_FX:
        wsprintf(buffer,
            TEXT("[DDVIDEOPORTCAPS::dwFX]\r\n")
            TEXT("DDVPFX_CROPTOPDATA             %7d\r\n")
            TEXT("DDVPFX_CROPX                   %7d\r\n")
            TEXT("DDVPFX_CROPY                   %7d\r\n")
            TEXT("DDVPFX_IGNOREVBIXCROP          %7d\r\n")
            TEXT("DDVPFX_INTERLEAVE              %7d\r\n")
            TEXT("DDVPFX_MIRRORLEFTRIGHT         %7d\r\n")
            TEXT("DDVPFX_MIRRORUPDOWN            %7d\r\n")
            TEXT("DDVPFX_PRESHRINKX              %7d\r\n")
            TEXT("DDVPFX_PRESHRINKY              %7d\r\n")
            TEXT("DDVPFX_PRESHRINKXB             %7d\r\n")
            TEXT("DDVPFX_PRESHRINKYB             %7d\r\n")
            TEXT("DDVPFX_PRESHRINKXS             %7d\r\n")
            TEXT("DDVPFX_PRESHRINKYS             %7d\r\n")
            TEXT("DDVPFX_PRESTRETCHX             %7d\r\n")
            TEXT("DDVPFX_PRESTRETCHY             %7d\r\n")
            TEXT("DDVPFX_PRESTRETCHXN            %7d\r\n")
            TEXT("DDVPFX_PRESTRETCHYN            %7d\r\n")
            TEXT("DDVPFX_VBICONVERT              %7d\r\n")
            //"DDVPFX_VBINOINTERLEAVE         %d\r\n"
            TEXT("DDVPFX_VBINOSCALE              %7d\r\n"),
            (m_VPCaps.dwFX&DDVPFX_CROPTOPDATA)>0,
            (m_VPCaps.dwFX&DDVPFX_CROPX)>0,
            (m_VPCaps.dwFX&DDVPFX_CROPY)>0,
            (m_VPCaps.dwFX&DDVPFX_IGNOREVBIXCROP)>0,
            (m_VPCaps.dwFX&DDVPFX_INTERLEAVE)>0,
            (m_VPCaps.dwFX&DDVPFX_MIRRORLEFTRIGHT)>0,
            (m_VPCaps.dwFX&DDVPFX_MIRRORUPDOWN)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKX)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKY)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKXB)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKYB)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKXS)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESHRINKYS)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESTRETCHX)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESTRETCHY)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESTRETCHXN)>0,
            (m_VPCaps.dwFX&DDVPFX_PRESTRETCHYN)>0,
            (m_VPCaps.dwFX&DDVPFX_VBICONVERT)>0,
            //m_VPCaps.dwFX&DDVPFX_VBINOINTERLEAVE,
            (m_VPCaps.dwFX&DDVPFX_VBINOSCALE)>0
            );
        break;
    case IDC_VP_INFO:
        {
            DWORD szFcc1 = 0;
            DWORD szFcc2 = 0;
            DWORD szFcc3 = 0;
            if (m_sVPInfo.lpddpfInputFormat)
                szFcc1 = m_sVPInfo.lpddpfInputFormat->dwFourCC;
            if (m_sVPInfo.lpddpfVBIInputFormat)
                szFcc2 = m_sVPInfo.lpddpfVBIInputFormat->dwFourCC;
            if (m_sVPInfo.lpddpfVBIOutputFormat)
                szFcc3 = m_sVPInfo.lpddpfVBIOutputFormat->dwFourCC;

            wsprintf(buffer,
                TEXT("[DDVIDEOPORTINFO]\r\n")
                TEXT("Origin X                       %7d\r\n")
                TEXT("Origin Y                       %7d\r\n")
                TEXT("Crop Rect            [%3d,%3d,%3d,%3d]\r\n")
                TEXT("Prescale Width                 %7d\r\n")
                TEXT("Prescale Height                %7d\r\n")
                TEXT("Input Format                   %7.4hs\r\n")
                TEXT("VBI Input Format               %7.4hs\r\n")
                TEXT("VBI Output Format              %7.4hs\r\n")
                TEXT("VBI Height                     %7d\r\n")
                TEXT("DDVP_AUTOFLIP                  %7d\r\n")
                TEXT("DDVP_CONVERT                   %7d\r\n")
                TEXT("DDVP_CROP                      %7d\r\n")
                TEXT("DDVP_IGNOREVBIXCROP            %7d\r\n")
                TEXT("DDVP_INTERLEAVE                %7d\r\n")
                TEXT("DDVP_MIRRORLEFTRIGHT           %7d\r\n")
                TEXT("DDVP_MIRRORUPDOWN              %7d\r\n")
                TEXT("DDVP_OVERRIDEBOBWEAVE          %7d\r\n")
                TEXT("DDVP_PRESCALE                  %7d\r\n")
                TEXT("DDVP_SKIPEVENFIELDS            %7d\r\n")
                TEXT("DDVP_SKIPODDFIELDS             %7d\r\n")
                TEXT("DDVP_SYNCMASTER                %7d\r\n")
                TEXT("DDVP_VBICONVERT                %7d\r\n")
                TEXT("DDVP_VBINOSCALE                %7d\r\n"),
                //"DDVP_VBINOINTERLEAVE         %d\r\n"
                m_sVPInfo.dwOriginX,
                m_sVPInfo.dwOriginY,
                m_sVPInfo.rCrop.left, m_sVPInfo.rCrop.top, m_sVPInfo.rCrop.right, m_sVPInfo.rCrop.bottom,
                m_sVPInfo.dwPrescaleWidth,
                m_sVPInfo.dwPrescaleHeight,
                &szFcc1,
                &szFcc2,
                &szFcc3,
                m_sVPInfo.dwVBIHeight,
                (m_sVPInfo.dwVPFlags&DDVP_AUTOFLIP)>0,
                (m_sVPInfo.dwVPFlags&DDVP_CONVERT)>0,
                (m_sVPInfo.dwVPFlags&DDVP_CROP)>0,
                (m_sVPInfo.dwVPFlags&DDVP_IGNOREVBIXCROP)>0,
                (m_sVPInfo.dwVPFlags&DDVP_INTERLEAVE)>0,
                (m_sVPInfo.dwVPFlags&DDVP_MIRRORLEFTRIGHT)>0,
                (m_sVPInfo.dwVPFlags&DDVP_MIRRORUPDOWN)>0,
                (m_sVPInfo.dwVPFlags&DDVP_OVERRIDEBOBWEAVE)>0,
                (m_sVPInfo.dwVPFlags&DDVP_PRESCALE)>0,
                (m_sVPInfo.dwVPFlags&DDVP_SKIPEVENFIELDS)>0,
                (m_sVPInfo.dwVPFlags&DDVP_SKIPODDFIELDS)>0,
                (m_sVPInfo.dwVPFlags&DDVP_SYNCMASTER)>0,
                (m_sVPInfo.dwVPFlags&DDVP_VBICONVERT)>0,
                (m_sVPInfo.dwVPFlags&DDVP_VBINOSCALE)>0
                //m_sVPInfo.dwVPFlags&DDVP_VBINOINTERLEAVE
                );
            break;
        }
    }
    SetDlgItemText( m_hDlg, IDC_VPINFO, buffer);
}

#pragma warning(disable: 4514) // "unreferenced inline function has been removed"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmprop\ovmprop2.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// ovmconfigpp.h
//----------------------------------------------------------------------------

#ifndef __OVMPROP2__
#define __OVMPROP2__


// {A73BEEB2-B0B7-11d2-8853-0000F80883E3}
DEFINE_GUID(CLSID_COMPinConfigProperties, 
            0xa73beeb2, 0xb0b7, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);


class COMPinConfigProperties : public CBasePropertyPage
{  
public:
    
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    
private:
    
    COMPinConfigProperties(LPUNKNOWN lpunk, HRESULT *phr);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    
    void Reset();
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    HRESULT UpdateColorKey(int id);
    HRESULT ShowColorKey();
    HRESULT UpdateItemInt(int id, DWORD* saved);
    void SetDirty();

    // IMixerPinConfig3 interface
    IMixerPinConfig3        *m_pIMixerPinConfig3;
    
    // IPin interface
    IPin                    *m_pIPin;
    
    // local data
    AM_ASPECT_RATIO_MODE    m_amAspectRatioMode;
    AM_RENDER_TRANSPORT     m_amRenderTransport;
    
    DWORD		    m_dwBlending;
    DWORD		    m_dwZOrder;
    BOOL		    m_fTransparent;
    
    DWORD		    m_dwKeyType;
    DWORD		    m_dwPaletteIndex;
    
    COLORREF	            m_LowColor;
    COLORREF	            m_HighColor;
    
    HWND		    m_hDlg;
    
};  // class COMPinConfigProperties


// {3FF23902-CD1F-11d2-8853-0000F80883E3}
DEFINE_GUID(CLSID_COMVPInfoProperties, 
            0x3ff23902, 0xcd1f, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

class COMVPInfoProperties : public CBasePropertyPage
{
public:
    
    static CUnknown *CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

private:

    COMVPInfoProperties(LPUNKNOWN lpUnk, HRESULT *phr);

    void SetEditFieldData(int id);
    void Reset();
    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();

    // IVPInfo interface
    IVPInfo                 *m_pIVPInfo; 
    AMVP_MODE		    m_CurrentMode;
    AMVP_CROP_STATE	    m_CropState;
    DWORD		    m_dwPixelsPerSecond;
    AMVPDATAINFO	    m_VPDataInfo;
    
    // vp data structures
    DDVIDEOPORTINFO 	    m_sVPInfo;
    DDVIDEOPORTBANDWIDTH    m_sBandwidth;
    DDVIDEOPORTCAPS	    m_VPCaps;
    DDVIDEOPORTCONNECT	    m_ddConnectInfo;

    HWND                    m_hDlg;    
};  // class COMVPInfoProperties

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmixer\vpobj.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_OBJECT__
#define __VP_OBJECT__

#include <vpinfo.h>


/* Temporary definitions while waiting DX5A integration
*/
#ifndef DDVPCREATE_VBIONLY
#define DDVPCREATE_VBIONLY                      0x00000001l
#endif

#ifndef DDVPCREATE_VIDEOONLY
#define DDVPCREATE_VIDEOONLY                    0x00000002l
#endif

// NOTE these two flags below have the same value but thats ok
#ifndef DDCAPS2_CANFLIPODDEVEN
// Driver supports bob using software without using a video port
#define DDCAPS2_CANFLIPODDEVEN                  0x00002000l
#endif

#ifndef DDVPCAPS_VBIANDVIDEOINDEPENDENT
 // Indicates that the VBI and video  can  be controlled by an
 // independent processes.
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT         0x00002000l
#endif

#ifndef DDVPD_PREFERREDAUTOFLIP
// Optimal number of autoflippable surfaces for hardware
#define DDVPD_PREFERREDAUTOFLIP 0x00000080l
#endif

#define EC_OVMIXER_REDRAW_ALL 0x100
#define EC_OVMIXER_VP_CONNECTED 0x101


typedef struct _VPDRAWFLAGS
{
    BOOL bUsingColorKey;
    BOOL bDoUpdateVideoPort;
    BOOL bDoTryAutoFlipping;
    BOOL bDoTryDecimation;
} VPDRAWFLAGS, *LPVPDRAWFLAGS;

typedef struct _WININFO
{
    POINT TopLeftPoint;
    RECT SrcRect;
    RECT DestRect;
    RECT SrcClipRect;
    RECT DestClipRect;
    HRGN hClipRgn;
} WININFO, *LPWININFO;

// this in a way defines the error margin
#define EPSILON 0.0001

#ifdef DEBUG
    #define DbgLogRectMacro(_x_) DbgLogRect _x_
#else
    #define DbgLogRectMacro(_x_)
#endif

extern double myfloor(double dNumber, double dEpsilon);
extern double myfloor(double fNumber);
extern double myceil(double dNumber, double dEpsilon);
extern double myceil(double fNumber);
extern RECT CalcSubRect(const RECT *pRect, const RECT *pRelativeRect);
extern void SetRect(DRECT *prdRect, LONG lLeft, LONG lTop, LONG lRight, LONG lBottom);
extern RECT MakeRect(DRECT rdRect);
extern void DbgLogRect(DWORD dwLevel, LPCTSTR pszDebugString, const DRECT *prdRect);
extern void DbgLogRect(DWORD dwLevel, LPCTSTR pszDebugString, const RECT *prRect);
extern double GetWidth(const DRECT *prdRect);
extern double GetHeight(const DRECT *prdRect);
extern BOOL IsRectEmpty(const DRECT *prdRect);
extern BOOL IntersectRect(DRECT *prdIRect, const DRECT *prdRect1, const DRECT *prdRect2);
void ScaleRect(DRECT *prdRect, double dOrigX, double dOrigY, double dNewX, double dNewY);
void ScaleRect(RECT *prRect, double dOrigX, double dOrigY, double dNewX, double dNewY);
extern double TransformRect(DRECT *pRect, double dPictAspectRatio, AM_TRANSFORM transform);
extern HRESULT CalcSrcClipRect(const DRECT *prdSrcRect, DRECT *prdSrcClipRect, const DRECT *prdDestRect, DRECT *prdDestClipRect);
extern HRESULT CalcSrcClipRect(const RECT *prSrcRect, RECT *prSrcClipRect, const RECT *prDestRect, RECT *prDestClipRect, BOOL bMaintainRatio = FALSE);
extern HRESULT AlignOverlaySrcDestRects(LPDDCAPS pddDirectCaps, RECT *pSrcRect, RECT *pDestRect);

extern DWORD DDColorMatch(IDirectDrawSurface *pdds, COLORREF rgb, HRESULT& hr);
extern DWORD DDColorMatchOffscreen(IDirectDraw *pdds, COLORREF rgb, HRESULT& hr);

extern AM_MEDIA_TYPE * WINAPI AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype);
extern AM_MEDIA_TYPE *ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType);
extern BITMAPINFOHEADER *GetbmiHeader(const CMediaType *pMediaType);
extern const DWORD *GetBitMasks(const CMediaType *pMediaType);
extern BYTE* GetColorInfo(const CMediaType *pMediaType);
extern HRESULT IsPalettised(const CMediaType *pMediaType, BOOL *pPalettised);
extern HRESULT GetPictAspectRatio(const CMediaType *pMediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY);
extern HRESULT GetSrcRectFromMediaType(const CMediaType *pMediaType, RECT *pRect);
extern HRESULT GetDestRectFromMediaType(const CMediaType *pMediaType, RECT *pRect);
extern HRESULT GetScaleCropRectsFromMediaType(const CMediaType *pMediaType, DRECT *prdScaledRect, DRECT *prdCroppedRect);
extern HRESULT GetInterlaceFlagsFromMediaType(const CMediaType *pMediaType, DWORD *pdwInterlaceFlags);
extern BOOL DisplayingFields(DWORD dwInterlacedFlags);
extern BOOL NeedToFlipOddEven(DWORD dwInterlacedFlags, DWORD dwTypeSpecificFlags, DWORD *pdwFlipFlag);
extern DWORD GetUpdateOverlayFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags);
extern BOOL CheckTypeSpecificFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags);
extern HRESULT GetTypeSpecificFlagsFromMediaSample(IMediaSample *pSample, DWORD *pdwTypeSpecificFlags);
extern HRESULT ComputeSurfaceRefCount(LPDIRECTDRAWSURFACE pDDrawSurface);
extern HRESULT PaintDDrawSurfaceBlack(LPDIRECTDRAWSURFACE pDDrawSurface);
extern HRESULT CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData);
extern HRESULT DeleteDIB(DIBDATA *pDibData);
extern void FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource);
extern void SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource);

DECLARE_INTERFACE_(IVPObject, IUnknown)
{
    STDMETHOD (GetDirectDrawSurface)(THIS_
                                     LPDIRECTDRAWSURFACE *ppDirectDrawSurface
                                    ) PURE;

    STDMETHOD (SetObjectLock)(THIS_
                              CCritSec *pMainObjLock
                             ) PURE;

    STDMETHOD (SetMediaType)(THIS_
                             const CMediaType* pmt
                            ) PURE;


    STDMETHOD (CheckMediaType)(THIS_
                               const CMediaType* pmt
                              ) PURE;


    STDMETHOD (CompleteConnect)(THIS_
                                IPin *pReceivePin,
                                BOOL bRenegotiating = FALSE
                               ) PURE;

    STDMETHOD (BreakConnect)(THIS_
                             BOOL bRenegotiating = FALSE
                            ) PURE;

    STDMETHOD (Active)(THIS_
                      ) PURE;

    STDMETHOD (Inactive)(THIS_
                        ) PURE;

    STDMETHOD (Run)(THIS_
                    REFERENCE_TIME tStart
                   ) PURE;

    STDMETHOD (RunToPause)(THIS_
                          ) PURE;

    STDMETHOD (OnClipChange)(THIS_
                             LPWININFO pWinInfo
                            ) PURE;

    STDMETHOD (CurrentMediaType)(THIS_
                                    AM_MEDIA_TYPE *pmt
                                   ) PURE;

    STDMETHOD (GetRectangles) (THIS_ RECT *prcSource, RECT *prcDest) PURE;
};


DECLARE_INTERFACE_(IVPControl, IUnknown)
{
    STDMETHOD (EventNotify)(THIS_
                            long lEventCode,
                            long lEventParam1,
                            long lEventParam2
                           ) PURE;

    STDMETHOD_(LPDIRECTDRAW, GetDirectDraw) (THIS_
                                            ) PURE;

    STDMETHOD_(LPDIRECTDRAWSURFACE, GetPrimarySurface) (THIS_
                                                       ) PURE;

    STDMETHOD_(LPDDCAPS, GetHardwareCaps) (THIS_
                                          ) PURE;

    STDMETHOD(CallUpdateOverlay)(THIS_
                              IDirectDrawSurface *pSurface,
                              LPRECT prcSrc,
                              LPDIRECTDRAWSURFACE pDestSurface,
                              LPRECT prcDest,
                              DWORD dwFlags) PURE;

    STDMETHOD(GetCaptureInfo)(THIS_
                             BOOL *lpCapturing,
                             DWORD *lpdwWidth,
                             DWORD *lpdwHeight,
                             BOOL *lpInterleaved) PURE;

    STDMETHOD(GetVideoDecimation)(THIS_
                                  IDecimateVideoImage** lplpDVI) PURE;

    STDMETHOD(GetDecimationUsage)(THIS_
                                  DECIMATION_USAGE *lpdwUsage) PURE;

    STDMETHOD(CropSourceRect)(THIS_
                              LPWININFO pWinInfo,
                              DWORD dwMinZoomFactorX,
                              DWORD dwMinZoomFactorY) PURE;
};


class CAMVideoPort : public CUnknown, public IVPNotify2, public IVPObject, public IVPInfo
{

public:
    static CUnknown* CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    CAMVideoPort(LPUNKNOWN pUnk, HRESULT *phr);
    ~CAMVideoPort();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IVPObject Interface to the outside world
    STDMETHODIMP GetDirectDrawSurface(LPDIRECTDRAWSURFACE *ppDirectDrawSurface);
    STDMETHODIMP SetObjectLock(CCritSec *pMainObjLock);
    STDMETHODIMP SetMediaType(const CMediaType* pmt);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP CompleteConnect(IPin *pReceivePin, BOOL bRenegotiating = FALSE);
    STDMETHODIMP BreakConnect(BOOL bRenegotiating = FALSE);
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP OnClipChange(LPWININFO pWinInfo);
    STDMETHODIMP CurrentMediaType(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetRectangles(RECT *prcSource, RECT *prcDest);

    // Methods belonging to IVPInfo
    STDMETHODIMP GetCropState(AMVP_CROP_STATE *pCropState);
    STDMETHODIMP GetPixelsPerSecond(DWORD* pPixelPerSec);
    STDMETHODIMP GetVPInfo(DDVIDEOPORTINFO* pVPInfo);
    STDMETHODIMP GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth);
    STDMETHODIMP GetVPCaps(DDVIDEOPORTCAPS* pVPCaps);
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO* pVPDataInfo);
    STDMETHODIMP GetVPInputFormat(LPDDPIXELFORMAT* pVPFormat);
    STDMETHODIMP GetVPOutputFormat(LPDDPIXELFORMAT* pVPFormat);

    // IVPNotify functions here
    STDMETHODIMP RenegotiateVPParameters();
    STDMETHODIMP SetDeinterlaceMode(AMVP_MODE mode);
    STDMETHODIMP GetDeinterlaceMode(AMVP_MODE *pMode);

    // functions added in IVPNotify2 here
    STDMETHODIMP SetVPSyncMaster(BOOL bVPSyncMaster);
    STDMETHODIMP GetVPSyncMaster(BOOL *pbVPSyncMaster);

private:
    // used to initialize all class member variables.
    // It is called from the contructor as well as CompleteConnect
    void InitVariables();


    // All these functions are called from within CompleteConnect
    HRESULT NegotiateConnectionParamaters();
    static HRESULT CALLBACK EnumCallback (LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext);
    HRESULT GetDataParameters();
    HRESULT NegotiatePixelFormat();
    BOOL    EqualPixelFormats(LPDDPIXELFORMAT lpFormat1, LPDDPIXELFORMAT lpFormat2);
    HRESULT GetBestFormat(DWORD dwNumInputFormats, LPDDPIXELFORMAT lpddInputFormats,
    BOOL    bGetBestBandwidth, LPDWORD lpdwBestEntry, LPDDPIXELFORMAT lpddBestOutputFormat);
    HRESULT CreateVideoPort();
    HRESULT DetermineCroppingRestrictions();
    HRESULT CreateVPOverlay(BOOL bTryDoubleHeight, DWORD dwMaxBuffers, BOOL bPreferBuffers);
    HRESULT SetSurfaceParameters();
    HRESULT InitializeVideoPortInfo();
    HRESULT CheckDDrawVPCaps();
    HRESULT DetermineModeRestrictions();
    HRESULT SetDDrawKernelHandles();

    // All these functions are called fro within OnClipChange
    HRESULT DrawImage(LPWININFO pWinInfo, AMVP_MODE mode, LPVPDRAWFLAGS pvpDrawFlags);
    HRESULT SetUpMode(LPWININFO pWinInfo, int mode);


    // Decimation functions
    BOOL
    ApplyDecimation(
        LPWININFO pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating
        );

    HRESULT
    TryVideoPortDecimation(
        LPWININFO pWinInfo,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY,
        BOOL* lpUpdateRequired
        );

    HRESULT
    TryDecoderDecimation(
        LPWININFO pWinInfo
        );

    void
    GetMinZoomFactors(
        LPWININFO pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating,
        LPDWORD lpMinX, LPDWORD lpMinY);


    BOOL
    Running();

    BOOL
    BeyondOverlayCaps(
        DWORD ScaleFactor,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY
        );

    BOOL
    ResetVPDecimationIfSet();

    void
    ResetDecoderDecimationIfSet();

    void CropSourceSize(LPWININFO pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSize(LPWININFO pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeForCapture(LPWININFO pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeWhenStopped(LPWININFO pWinInfo,  DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL CheckVideoPortAlignment(DWORD dwWidth);

    BOOL
    VideoPortDecimationBackend(
        LPWININFO pWinInfo,
        DWORD dwDexNumX,
        DWORD dwDexDenX,
        DWORD dwDexNumY,
        DWORD dwDexDenY
        );

public:
    HRESULT StopUsingVideoPort();
    HRESULT RecreateVideoPort();

private:

    // Critical sections
    CCritSec                *m_pMainObjLock;                // Lock given by controlling object
    CCritSec                m_VPObjLock;                    // VP object wide lock
    IVPControl              *m_pIVPControl;

    // window information related stuff
    BOOL                    m_bStoredWinInfoSet;
    WININFO                 m_StoredWinInfo;

    // image dimensions
    DWORD                   m_lImageWidth;
    DWORD                   m_lImageHeight;
    DWORD                   m_lDecoderImageWidth;
    DWORD                   m_lDecoderImageHeight;

    // info relating to capturing
    BOOL                    m_fCapturing;
    BOOL                    m_fCaptureInterleaved;
    DWORD                   m_cxCapture;
    DWORD                   m_cyCapture;

    // overlay surface related stuff
    LPDIRECTDRAWSURFACE     m_pOverlaySurface;
    DWORD                   m_dwBackBufferCount;
    DWORD                   m_dwOverlaySurfaceWidth;
    DWORD                   m_dwOverlaySurfaceHeight;
    DWORD                   m_dwOverlayFlags;
    BOOL                    m_bOverlayHidden;

    // vp variables to store flags, current state etc
    IVPConfig               *m_pIVPConfig;
    BOOL                    m_bStart;

    BOOL                    m_bConnected;

    AMVP_STATE              m_VPState;
    AMVP_MODE               m_CurrentMode;
    AMVP_MODE               m_StoredMode;
    AMVP_CROP_STATE         m_CropState;
    DWORD                   m_dwPixelsPerSecond;
    BOOL                    m_bVSInterlaced;
    BOOL                    m_bGarbageLine;
    BOOL                    m_bVPSyncMaster;

    // vp data structures
    DWORD                   m_dwVideoPortId;
    LPDDVIDEOPORTCONTAINER  m_pDVP;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTBANDWIDTH    m_sBandwidth;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_ddConnectInfo;
    AMVPDATAINFO            m_VPDataInfo;

    // All the pixel formats (Video)
    LPDDPIXELFORMAT         m_pddVPInputVideoFormat;
    LPDDPIXELFORMAT         m_pddVPOutputVideoFormat;

    // can we support the different modes
    BOOL                    m_bCanWeave;
    BOOL                    m_bCanBobInterleaved;
    BOOL                    m_bCanBobNonInterleaved;
    BOOL                    m_bCanSkipOdd;
    BOOL                    m_bCanSkipEven;
    BOOL                    m_bCantInterleaveHalfline;

    // decimation parameters
    enum DECIMATE_MODE {DECIMATE_NONE, DECIMATE_ARB, DECIMATE_BIN, DECIMATE_INC};
#if defined(DEBUG)
    // BOOL CheckVideoPortScaler();
    BOOL CheckVideoPortScaler(
        DECIMATE_MODE DecimationMode,
        DWORD ImageSize,
        DWORD PreScaleSize,
        ULONG ulDeciStep);
#endif
    DECIMATE_MODE           m_DecimationModeX;
    DWORD                   m_ulDeciStepX;
    DWORD                   m_dwDeciNumX;
    DWORD                   m_dwDeciDenX;

    DECIMATE_MODE           m_DecimationModeY;
    DWORD                   m_ulDeciStepY;
    DWORD                   m_dwDeciNumY;
    DWORD                   m_dwDeciDenY;

    BOOL                    m_bVPDecimating;
    BOOL                    m_bDecimating;
    LONG                    m_lWidth;
    LONG                    m_lHeight;

    // variables to store the current aspect ratio
    DWORD                   m_dwPictAspectRatioX;
    DWORD                   m_dwPictAspectRatioY;


    RECT                    m_rcSource;
    RECT                    m_rcDest;
};

DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E);

#endif //__VP_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mixer\ovmprop\ovmprop.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Video renderer property pages, Anthony Phillips, January 1996

#include <streams.h>
#include <dvp.h>
#include <vptype.h>
#include <vpinfo.h>
#include <mpconfig3.h>
#include <ovmixpos2.h>
#include <ovmprop.h>
#include <resource.h>
#include <atlbase.h>


// Helper function to print data of a rectangle to an edit field
void SetDlgItemRect(HWND hwnd, int id, const RECT& rect, BOOL valid)
{
    TCHAR temp[64];

    if ( valid) {
        wsprintf(temp, TEXT("%d, %d, %d, %d"),
            rect.left, rect.top,
            rect.right, rect.bottom);
        SetDlgItemText( hwnd, id, temp );
    }
    else
        SetDlgItemText( hwnd, id, TEXT("") );
}

// This class implements a property page dialog for the overlay mixer. We
// expose certain statistics from the quality management implementation. In
// particular we have two edit fields that show the number of frames we have
// actually drawn and the number of frames that we dropped. The number of
// frames we dropped does NOT represent the total number dropped in any play
// back sequence (as expressed through MCI status frames skipped) since the
// quality management protocol may have negotiated with the source filter for
// it to send fewer frames in the first place. Dropping frames in the source
// filter is nearly always a more efficient mechanism when we are flooded


// Constructor

COMQualityProperties::COMQualityProperties(LPUNKNOWN pUnk,HRESULT *phr) :
    CBasePropertyPage(NAME("Quality Page"),pUnk,IDD_IQUALITY,IDS_TITLE_QUALITY),
    m_pIQualProp(NULL)
{
    ASSERT(phr);
}


// Create a quality properties object

CUnknown *COMQualityProperties::CreateInstance(LPUNKNOWN lpUnk, HRESULT *phr)
{
    CUnknown *punk = new COMQualityProperties(lpUnk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


// Give us the filter to communicate with

HRESULT COMQualityProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIQualProp == NULL);

    // Ask the renderer for it's IQualProp interface

    HRESULT hr = pUnknown->QueryInterface(IID_IQualProp,(void **)&m_pIQualProp);
    if (FAILED(hr))
        return hr;

    ASSERT(m_pIQualProp);

    return hr;
}


// Release any IQualProp interface we have

HRESULT COMQualityProperties::OnDisconnect()
{
    // Release the interface

    if (m_pIQualProp == NULL) {
        return E_UNEXPECTED;
    }

    m_pIQualProp->Release();
    m_pIQualProp = NULL;
    return NOERROR;
}


// Set the text fields in the property page

HRESULT COMQualityProperties::OnActivate()
{
    Reset();
    return NOERROR;
}


// Initialise the property page fields

void COMQualityProperties::SetEditFieldData()
{
    ASSERT(m_pIQualProp);
    TCHAR buffer[50];

    SetDlgItemInt(m_Dlg, IDD_QDROPPED, m_iDropped, FALSE);
    SetDlgItemInt(m_Dlg, IDD_QDRAWN, m_iDrawn, FALSE);

    wsprintf(buffer,TEXT("%d.%02d"), m_iFrameRate/100, m_iFrameRate%100);
    SetDlgItemText(m_Dlg, IDD_QAVGFRM, buffer);

    SetDlgItemInt(m_Dlg, IDD_QJITTER, m_iFrameJitter, TRUE);
    SetDlgItemInt(m_Dlg, IDD_QSYNCAVG, m_iSyncAvg, TRUE);
    SetDlgItemInt(m_Dlg, IDD_QSYNCDEV, m_iSyncDev, TRUE);
}


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR COMQualityProperties::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    const UINT uTimerID = 0x61901; // random number to identify the timer
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            // Set a timer to go off every 1/2 second
            SetTimer(m_Dlg, 0x61901, 500, NULL);
            break;
        }

        case WM_DESTROY:
        {
            KillTimer(m_hwnd, 0x61901);
            break;
        }

        case WM_TIMER:
        {
            Reset();
            break;
        }

    } // switch
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} // OnReceiveMessage


void COMQualityProperties::Reset()
{
    ASSERT(m_pIQualProp);

    m_pIQualProp->get_FramesDroppedInRenderer(&m_iDropped);
    m_pIQualProp->get_FramesDrawn(&m_iDrawn);
    m_pIQualProp->get_AvgFrameRate(&m_iFrameRate);
    m_pIQualProp->get_Jitter(&m_iFrameJitter);
    m_pIQualProp->get_AvgSyncOffset(&m_iSyncAvg);
    m_pIQualProp->get_DevSyncOffset(&m_iSyncDev);
    SetEditFieldData();
}


//
// CreateInstance
//
// Override CClassFactory method.
// Set lpUnk to point to an IUnknown interface on a new COMPositionProperties object
// Part of the COM object instantiation mechanism
//
CUnknown * WINAPI COMPositionProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new COMPositionProperties(lpunk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
} // CreateInstance


//
// COMPositionProperties::Constructor
//
// Constructs and initialises an COMPositionProperties object
//
COMPositionProperties::COMPositionProperties(LPUNKNOWN pUnk, HRESULT *phr)
    : CBasePropertyPage(NAME("Overlay Mixer Property Page"),pUnk,
        IDD_IOVMIXERPOS, IDS_TITLE_MIXPOS)
    , m_pIMixerPinConfig3(NULL)
    , m_pIAMOverlayMixerPosition2(NULL)
    , m_hDlg(HWND(NULL))

{
    ASSERT(phr);

} // (constructor) COMPositionProperties


HRESULT COMPositionProperties::OnActivate()
{
    Reset();
    return NOERROR;
}


BOOL COMPositionProperties::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    m_hDlg = hwnd;
    return TRUE;
}


void COMPositionProperties::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDC_RESET:
        Reset();
    }
}


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR COMPositionProperties::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND,    OnCommand);
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    } // switch

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} // OnReceiveMessage


void COMPositionProperties::Reset()
{
    ASSERT(m_pIMixerPinConfig3);
    ASSERT(m_pIAMOverlayMixerPosition2);

    HRESULT hr = S_FALSE;
    RECT src, dest;

    AM_RENDER_TRANSPORT renderTransport;
    hr = m_pIMixerPinConfig3->GetRenderTransport( &renderTransport);
    if ( S_OK == hr) {
        switch (renderTransport) {
        case AM_VIDEOPORT:
            hr = m_pIAMOverlayMixerPosition2->GetVideoPortRects( &src, &dest);
            SetDlgItemText(m_hDlg, IDC_INPIN_RECTS, TEXT("Primary Input Pin -- VideoPort"));
            break;
        default:
            hr = m_pIAMOverlayMixerPosition2->GetOverlayRects( &src, &dest);
            SetDlgItemText(m_hDlg, IDC_INPIN_RECTS, TEXT("Primary Input Pin -- Overlay"));
            break;
        }
        SetDlgItemRect(m_hDlg, IDC_INPIN_SRC, src, SUCCEEDED(hr));
        SetDlgItemRect(m_hDlg, IDC_INPIN_DEST, dest, SUCCEEDED(hr));

    }

    hr = m_pIAMOverlayMixerPosition2->GetBasicVideoRects(&src, &dest);
    SetDlgItemRect(m_hDlg, IDC_BASIC_VID_SRC, src, SUCCEEDED(hr));
    SetDlgItemRect(m_hDlg, IDC_BASIC_VID_DEST, dest, SUCCEEDED(hr));
}

//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which object this property page should display.
// We query the object for the IID_IAMOverlayMixerPosition2 interface.
//
// If cObjects == 0 then we must release the interface.
HRESULT COMPositionProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIMixerPinConfig3 == NULL);
    ASSERT(m_pIAMOverlayMixerPosition2 == NULL);

    // QueryInterface for the Primary InputPin's IMixerPinConfig3 interface
    CComPtr<IBaseFilter> pFilter = NULL;
    CComPtr<IEnumPins> pEnumPins = NULL;
    CComPtr<IPin> pPin = NULL;

    HRESULT hr = pUnknown->QueryInterface(IID_IBaseFilter, (void**) &pFilter);
    if (FAILED(hr)) return hr;

    hr = pFilter->EnumPins(&pEnumPins);
    if (FAILED(hr)) return hr;
    pEnumPins->Reset();
    hr = pEnumPins->Next(1, &pPin, NULL);
    if (FAILED(hr)) return hr;

    if (pPin) {
        hr = pPin->QueryInterface(IID_IMixerPinConfig3,
        (void **) &m_pIMixerPinConfig3);
        if (FAILED(hr))
            return hr;
    }


    // QueryInterface for IAMOverlayMixerPosition2
    hr = pUnknown->QueryInterface(IID_IAMOverlayMixerPosition2,
        (void **) &m_pIAMOverlayMixerPosition2);

    if (FAILED(hr)) {
        m_pIMixerPinConfig3->Release();
        return hr;
    }

    ASSERT(m_pIMixerPinConfig3);
    ASSERT(m_pIAMOverlayMixerPosition2);

    return hr;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface.
//
HRESULT COMPositionProperties::OnDisconnect()
{
    // Release of Interface

    if (m_pIMixerPinConfig3) {
        m_pIMixerPinConfig3->Release();
        m_pIMixerPinConfig3 = NULL;
    }

    if (m_pIAMOverlayMixerPosition2) {
        m_pIAMOverlayMixerPosition2->Release();
        m_pIAMOverlayMixerPosition2 = NULL;
    }

    return NOERROR;

} // OnDisconnect



#if defined(DEBUG)
//
// CreateInstance
//
// Override CClassFactory method.
// Set lpUnk to point to an IUnknown interface on a new COMDecimationProperties object
// Part of the COM object instantiation mechanism
//
CUnknown * WINAPI COMDecimationProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new COMDecimationProperties(lpunk, phr);
    if (punk == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


//
// COMDecimationProperties::Constructor
//
// Constructs and initialises an COMDecimationProperties object
//
COMDecimationProperties::COMDecimationProperties(LPUNKNOWN pUnk, HRESULT *phr) :
    CBasePropertyPage(NAME("Overlay Mixer Property Page"),pUnk,
                      IDD_DECIMATION_USAGE, IDS_TITLE_DECIMATION),
    m_pIAMVDP(NULL),
    m_pIAMSDC(NULL),
    m_hDlg(HWND(NULL))

{
    ASSERT(phr);

}


HRESULT COMDecimationProperties::OnActivate()
{
    //Reset();
    return NOERROR;
}

extern "C" const TCHAR chMultiMonWarning[];
extern int GetRegistryDword(HKEY hk, const TCHAR *pKey, int iDefault);
extern LONG SetRegistryDword(HKEY hk, const TCHAR *pKey, int iSet);

BOOL COMDecimationProperties::OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    m_hDlg = hwnd;

    static const struct {int id; DECIMATION_USAGE val;} map[] = {
        IDS_DECIMATION_LEGACY, DECIMATION_LEGACY,
        IDS_DECIMATION_USE_DECODER_ONLY, DECIMATION_USE_DECODER_ONLY,
        IDS_DECIMATION_USE_VIDEOPORT_ONLY, DECIMATION_USE_VIDEOPORT_ONLY,
        IDS_DECIMATION_USE_OVERLAY_ONLY, DECIMATION_USE_OVERLAY_ONLY,
        IDS_DEFAULT_DECIMATION, DECIMATION_DEFAULT
    };

    DECIMATION_USAGE dwDecimation;
    m_pIAMVDP->QueryDecimationUsage(&m_dwUsage);
    int iSel = -1;

    HWND hwndCombo = GetDlgItem(hwnd, IDC_DECIMATION_OPTIONS);
    DWORD i;

    for (i = 0; i < (sizeof(map) / sizeof(map[0])); i++) {

        TCHAR sz[128];
        int idx;

        LoadString(g_hInst, map[i].id, sz, 128);
        idx = ComboBox_AddString(hwndCombo, sz);
        ComboBox_SetItemData(hwndCombo, idx, map[i].val);

        if (map[i].val == m_dwUsage) {
            iSel = idx;
        }
    }
    ComboBox_SetCurSel(hwndCombo, iSel);


    m_pIAMSDC->GetDDrawGUID(&m_GUID);
    m_pIAMSDC->GetDDrawGUIDs(&m_dwCount, &m_lpMonInfo);
    iSel = -1;

    hwndCombo = GetDlgItem(hwnd, IDC_DDRAW_DEVICE);
    for (i = 0; i < m_dwCount; i++) {

        int     idx;
        TCHAR   sz[128];

        wsprintf(sz, TEXT("%hs : %hs"), m_lpMonInfo[i].szDevice,
                 m_lpMonInfo[i].szDescription);

        idx = ComboBox_AddString(hwndCombo, sz);
        ComboBox_SetItemData(hwndCombo, idx, &m_lpMonInfo[i]);

        if (m_GUID.lpGUID) {
            if (IsEqualGUID(m_GUID.GUID, m_lpMonInfo[i].guid.GUID)) {
                iSel = i;
            }
        }
        else {
            if (m_GUID.lpGUID == m_lpMonInfo[i].guid.lpGUID) {
                iSel = i;
            }
        }

    }
    ComboBox_SetCurSel(hwndCombo, iSel);


    DWORD chk;
    if (GetRegistryDword(HKEY_CURRENT_USER, chMultiMonWarning, 1)) {
        chk = BST_CHECKED;
        m_MMonWarn = TRUE;
    }
    else {
        chk = BST_UNCHECKED;
        m_MMonWarn = FALSE;
    }

    Button_SetCheck(GetDlgItem(hwnd, IDC_MMWARNING), chk);

    return TRUE;
}


void
COMDecimationProperties::OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch(id) {
    case IDC_DECIMATION_OPTIONS:
        if (codeNotify == CBN_SELCHANGE) {

            int idx = ComboBox_GetCurSel(hwndCtl);
            DECIMATION_USAGE dwUsage =
                (DECIMATION_USAGE)ComboBox_GetItemData(hwndCtl, idx);

            if (dwUsage != m_dwUsage) {
                m_dwUsage = dwUsage;
                m_bDirty = TRUE;
                if (m_pPageSite) {
                    m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
                }
            }
        }
        break;

    case IDC_DDRAW_DEVICE:
        if (codeNotify == CBN_SELCHANGE) {

            int idx = ComboBox_GetCurSel(hwndCtl);
            AMDDRAWMONITORINFO* lpMi =
                (AMDDRAWMONITORINFO*)ComboBox_GetItemData(hwndCtl, idx);

            m_bDirty = FALSE;

            if (m_GUID.lpGUID) {
                if (lpMi->guid.lpGUID) {
                    if (!IsEqualGUID(m_GUID.GUID, lpMi->guid.GUID)) {
                        m_GUID.GUID = lpMi->guid.GUID;
                        m_bDirty = TRUE;
                    }
                }
                else {
                    m_GUID.lpGUID = NULL;
                    m_bDirty = TRUE;
                }
            }
            else {
                if (lpMi->guid.lpGUID) {
                    m_GUID.lpGUID = &m_GUID.GUID;
                    m_GUID.GUID = lpMi->guid.GUID;
                    m_bDirty = TRUE;
                }
            }

            if (m_bDirty && m_pPageSite) {
                m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
            }
        }
        break;

    case IDC_MAKE_DEFAULT:
        {
            hwndCtl = GetDlgItem(hwnd, IDC_DDRAW_DEVICE);
            int idx = ComboBox_GetCurSel(hwndCtl);
            if (idx != CB_ERR) {
                AMDDRAWMONITORINFO* lpMi =
                    (AMDDRAWMONITORINFO*)ComboBox_GetItemData(hwndCtl, idx);
                m_pIAMSDC->SetDefaultDDrawGUID(&lpMi->guid);

            }
        }
        break;

    case IDC_MMWARNING:
        if (codeNotify == BN_CLICKED) {
            BOOL fWarn = (Button_GetCheck(hwndCtl) == BST_CHECKED);
            if (fWarn != GetRegistryDword(HKEY_CURRENT_USER, chMultiMonWarning, 1)) {
                m_MMonWarn = fWarn;
                m_bDirty = TRUE;
            }

            if (m_bDirty && m_pPageSite) {
                m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
            }
        }
    }
}


//
// OnApplyChanges
//
// Override CBasePropertyPage method.
// Process changes in IID_IAMVideoDecimationProperties properties
// and reset m_bDirty bit
//
HRESULT COMDecimationProperties::OnApplyChanges()
{
    HRESULT hr = m_pIAMVDP->SetDecimationUsage(m_dwUsage);
    if (SUCCEEDED(hr)) {
        hr = m_pIAMSDC->SetDDrawGUID(&m_GUID);
    }

    SetRegistryDword(HKEY_CURRENT_USER, chMultiMonWarning, (DWORD)m_MMonWarn);

    m_bDirty = FALSE;
    return hr;
}

void
COMDecimationProperties::OnDestroy(
    HWND hwnd
    )
{
    CoTaskMemFree(m_lpMonInfo);
}

//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR
COMDecimationProperties::OnReceiveMessage(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {
    HANDLE_MSG(hwnd, WM_COMMAND,    OnCommand);
    HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitDialog);
    HANDLE_MSG(hwnd, WM_DESTROY,    OnDestroy);
    } // switch

    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}


//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which object this property page should display.
// We query the object for the IID_IAMOverlayMixerPosition2 interface.
//
// If cObjects == 0 then we must release the interface.
HRESULT COMDecimationProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT(m_pIAMVDP == NULL);

    HRESULT hr = pUnknown->QueryInterface(IID_IAMVideoDecimationProperties,
                                          (void**)&m_pIAMVDP);

    if (SUCCEEDED(hr)) {
        hr = pUnknown->QueryInterface(IID_IAMSpecifyDDrawConnectionDevice,
                                      (void**)&m_pIAMSDC);
        if (FAILED(hr)) {
            m_pIAMVDP->Release();
            m_pIAMVDP = NULL;
        }
    }

    return hr;

} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release the private interface.
//
HRESULT COMDecimationProperties::OnDisconnect()
{
    // Release of Interface

    if (m_pIAMVDP) {
        m_pIAMVDP->Release();
        m_pIAMVDP = NULL;
    }

    if (m_pIAMSDC) {
        m_pIAMSDC->Release();
        m_pIAMSDC = NULL;
    }

    return NOERROR;

} // OnDisconnect
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\mpgtime.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

/*
     mpgtime.h

        Timing stuff for MPEG :


        CSTC - model the 33 bit roll-around system time clock

        CMpegFileTime - try to track the clock around (several possible)
        roll-arounds

*/

REFERENCE_TIME inline MpegToReferenceTime(LONGLONG llTime)
{
    REFERENCE_TIME rt;
    rt = (llTime * 1000 + 500) / 9;
    return rt;
}

LONGLONG inline ReferenceTimeToMpeg(REFERENCE_TIME rt)
{
    return (rt * 9 + 4) / 1000;
}

class CSTC
{
public:
    inline CSTC()
    {
#ifdef DEBUG
        /*  Initialize to invalid */
        m_ll = 0x7F7F7F7F7F7F7F7F;
#endif
    };
    inline CSTC(LONGLONG ll)
    {
        LARGE_INTEGER li;
        li.QuadPart = ll;
        li.HighPart = -(li.HighPart & 1);
        m_ll = li.QuadPart;
    };
    inline CSTC operator-(CSTC cstc)
    {
        return CSTC(m_ll - (LONGLONG)cstc);
    };
    inline operator LONGLONG() const
    {
        ASSERT(m_ll + 0x100000000 < 0x200000000);
        return m_ll;
    };

    //  Copy constructor
    inline CSTC operator=(LONGLONG ll)
    {
        *this = CSTC(ll);
        return *this;
    }
    inline ~CSTC()
    {
    };
    inline BOOL operator<(CSTC cstc) const
    {
        LARGE_INTEGER li;
        li.QuadPart = m_ll - cstc.m_ll;
        return (li.HighPart & 1) != 0;
    };
    inline BOOL operator>(CSTC cstc) const
    {
        return cstc < *this;
    };

    inline BOOL operator>=(CSTC cstc) const
    {
        return !(*this < cstc);
    };
    inline BOOL operator<=(CSTC cstc) const
    {
        return !(*this > cstc);
    };

private:
    LONGLONG m_ll;
};

class CMpegStreamTime
{
public:
    CMpegStreamTime();
    ~CMpegStreamTime();
    void ResetToStart();
    void SeekTo(LONGLONG llGuess);
    void SetStreamTime(CSTC cstc, LONGLONG llPosition);
    LONGLONG GetStreamTime(CSTC cstc);
    BOOL StreamTimeInitialized();
    void StreamTimeDiscontinuity();
    virtual void StreamTimeError();

protected:
    LONGLONG                            m_llCurrentClock;
    BOOL                                m_bTimeDiscontinuity;

    BOOL                                m_bInitialized;
    BOOL                                m_bTimeContiguous;

    /*  m_llFirstClock is just something we remember to go back to */
    LONGLONG                            m_llFirstClock;
    LONGLONG                            m_llPositionForCurrentClock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\auddec.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	Mediamatics Audio Decoder Interface Specification
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifndef _MM_AUDIODEC_H_
#define _MM_AUDIODEC_H_

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

//	Control parameter values
#define DECODE_MONO         0x00000001L  // redundant, unused.
#define DECODE_STEREO       0x00000002L  // 1=allow stereo, 0=force mono.
#define DECODE_LEFT_ONLY    0x00000010L  // decode left  ch only, feed to both outputs
#define DECODE_RIGHT_ONLY   0x00000020L  // decode right ch only, feed to both outputs
#define DECODE_QUARTER      0x00000800L  // quarter bw:  8 sub-bands
#define DECODE_HALF         0x00001000L  // half    bw: 16 sub-bands
#define DECODE_FULL         0x00002000L  // full    bw: 32 sub-bands
#define DECODE_HALF_HIQ     0x00004000L  // half bw, hi quality
#define DECODE_HALF_FULLQ   0x00008000L  // half bw, full quality
#define DECODE_16BIT        0x00010000L  // 1=16bit output, 0=8-bit output.
#define DECODE_8BIT         0x00020000L  // redundant, unused.
#define DECODE_QSOUND       0x00040000L  // enable qsound (no longer used)
#define DECODE_INT          0x00080000L  // enable integer-only mode.
#define DECODE_MMX          0x00100000L  // enable mmx mode (has to in int mode as well).
#define DECODE_AC3          0x10000000L  // Open for AC-3 Decode.
#define DECODE_PRO_LOGIC	0x20000000L	 // Output in ProLogic for AC-3
#define DECODE_MIX_LFE		0x40000000L

#define DECODE_QUART_INT	DECODE_INT	// ## MSMM MERGE CHANGE ##

//  Function return values

#define DECODE_SUCCESS 		0x0000L
#define DECODE_ERR_MEMORY 	0x0001L
#define DECODE_ERR_DATA 	0x0002L
#define DECODE_ERR_PARM 	0x0003L
#define DECODE_ERR_VLDERROR	0x0004L
#define DECODE_ERR_SEVEREVLD	0x0005L
#define DECODE_ERR_MEMALLOC     DECODE_ERR_MEMORY
#define DECODE_ERR_TABLE        0x0081L
#define DECODE_ERR_PICKTABLE    0x0082L
#define DECODE_ERR_NOSYNC       0x0083L
#define DECODE_ERR_LAYER        0x0084L
#define DECODE_ERR_EMPH         0x0085L   // non-fatal error.
#define DECODE_ERR_CRC          0x0086L
#define DECODE_ERR_BADSTATE     0x0087L
#define DECODE_ERR_NBANDS       0x0088L
#define DECODE_ERR_BADHDR       0x0089L
#define DECODE_ERR_INBUFOV      0x008AL
#define DECODE_ERR_NOTENOUGHDATA 0x008BL
#define ERROR_BAD_DLL		0x1000L	    // A Dll had some problem loading/linking

typedef struct tagAudioDecStruct {
			DWORD	dwCtrl ;			// Control parameter
			DWORD	dwNumFrames ;		//	Number of Audio frames to decode
			DWORD	dwOutBuffSize ;	// Size of each buffer in bytes
			DWORD	dwOutBuffUsed ;	// Number of bytes used in each buffer
									// filled in by Decoder
			void *	pOutBuffer;		// Actual pointer to the buffer
			void *	pCmprHead ;			// Pointer to the Compressed Bit Buffer
										//		Head
			void *	pCmprRead ;			// Pointer to the Compressed Bit Read
										//		position
			void *	pCmprWrite ;		// Pointer to the Compressed Bit Write
										// 		position
			DWORD	dwMpegError ;
            DWORD   dwNumOutputChannels;	// input to decoder
			DWORD	dwFrameSize ; 		// output from decoder
			DWORD	dwBitRate ;			// output from decoder
			DWORD	dwSampleRate ;		// output from decoder
			DWORD	dwNumInputChannels ; // output from decoder
} stAudioDecode, * PAUDIODECODE, FAR * LPAUDIODECODE ;

typedef DWORD_PTR HADEC;

#ifdef STD_BACKAPI
#define BACKAPI APIENTRY
#else
#define BACKAPI
#endif

BOOL  BACKAPI CanDoAC3(void);
HADEC BACKAPI OpenAudio(DWORD ctrl);
DWORD BACKAPI CloseAudio(HADEC hDevice);
DWORD BACKAPI ResetAudio(HADEC hDevice, DWORD ctrl);
DWORD BACKAPI DecodeAudioFrame(HADEC hDevice, PAUDIODECODE lpAudioCtrlStruct);
#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  // _MM_AUDIODEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\id3.h ===
// 


//   ID3 parsing stuff - see www.id3.org
//   

//  Make a class for name scoping
class CID3Parse {

public:
    /*  Only support versions 2 and 3 */
    BOOL static IsV2(const BYTE *pbData)
    {
        return (MAKEFOURCC(pbData[0], pbData[1], pbData[2], 0) == MAKEFOURCC('I', 'D', '3', 0) &&
            0 == (*(UNALIGNED DWORD *)(pbData + 6) & 0x80808080)) &&
            /*  Major versions 2 and 3 */
            (MajorVersion(pbData) == 2 || MajorVersion(pbData) == 3);
    }
    
    LONG static TotalLength(const BYTE *pbData)
    {
        return ((LONG)pbData[6] << 21) +
               ((LONG)pbData[7] << 14) +
               ((LONG)pbData[8] << 7)  +
                (LONG)pbData[9]
               + ID3_HEADER_LENGTH;
    }

    /*  de'unsynchronize and return the total length */
    LONG static DeUnSynchronize(const BYTE *pbIn, PBYTE pbOut)
    {
        LONG lID3 = TotalLength(pbIn);
    
        if (Flags(pbIn) & ID3_FLAGS_UNSYNCHRONIZED) {
            /*  Copy and perform de-'unsynchronization' 
                of the header
            */
            BYTE bLast = 0x00;
            PBYTE pbDest = pbOut;
            while (lID3--) {
                /*  ff 00 ==> ff */
                if (bLast == 0xFF && *pbIn == 0x00) {
                    bLast = *pbIn++;
                } else {
                    bLast = *pbIn++;
                    *pbDest++ = bLast;
                }
            }
            /*  Now fix up the length and clear the unsync flag */
            pbOut[5] &= ~ID3_FLAGS_UNSYNCHRONIZED;
            LONG lNew = (LONG)(pbDest - pbOut);
    
            /*  Bits 27-21 */
            pbOut[6] = (BYTE)(lNew >> 21);
            /*  Bits 20-14 */
            pbOut[7] = (BYTE)((lNew >> 14) & 0x7F);
            /*  Bits 13-7 */
            pbOut[8] = (BYTE)((lNew >> 7) & 0x7F);
            /*  Bits 6-0 */
            pbOut[9] = (BYTE)(lNew & 0x7F);
            return lNew;
        } else {
            CopyMemory(pbOut, pbIn, lID3);
            return lID3;
        }
    }

    static HRESULT GetField(const BYTE *pbID3, CBasicParse::Field field, BSTR *str)
    {
        /*  Do type 1 differently */
        if (pbID3[0] == 'T') {
            const BYTE *pbField;

            switch (field) {
            case CBasicParse::Author:
            case CBasicParse::Artist:
                pbField = &pbID3[33];
                break;

            case CBasicParse::Copyright:
                return E_NOTIMPL;

            case CBasicParse::Title:
            case CBasicParse::Description:
                pbField = &pbID3[3];
                break;
            }
            return GetAnsiString(pbField, 30, str);
        }

        /*  Other types */

        DWORD dwID;

        if (MajorVersion(pbID3) == 2) {
            switch (field) {
            case CBasicParse::Author:
                dwID = MAKEFOURCC('T', 'C', 'M', 0);
                break;

            case CBasicParse::Artist:
                dwID = MAKEFOURCC('T', 'P', '1', 0);
                break;

            case CBasicParse::Copyright:
                dwID = MAKEFOURCC('T', 'C', 'R', 0);
                break;

            case CBasicParse::Title:
            case CBasicParse::Description:
                dwID = MAKEFOURCC('T', 'T', '2', 0);
                break;
            }
        } else {
            switch (field) {
            case CBasicParse::Artist:
                dwID = MAKEFOURCC('T', 'P', 'E', '1');
                break;

            case CBasicParse::Author:
                dwID = MAKEFOURCC('T', 'C', 'O', 'M');
                break;

            case CBasicParse::Copyright:
                dwID = MAKEFOURCC('T', 'C', 'O', 'P');
                break;

            case CBasicParse::Title:
            case CBasicParse::Description:
                dwID = MAKEFOURCC('T', 'I', 'T', '2');
                break;
            }
        }

        /*  Now pull out the data */
        HRESULT hr = GetFrameString(pbID3, dwID, str);
        if (SUCCEEDED(hr) && field == CBasicParse::Copyright) {
            /*  Add Copyright (c) */
            WCHAR wszNew[1000];
#ifndef UNICODE
            CHAR szCopyright[100];
            int iStr = LoadString(g_hInst, IDS_COPYRIGHT, szCopyright, 100);
            if (0 != iStr) {
                iStr = MultiByteToWideChar(
                           CP_ACP, 
                           MB_PRECOMPOSED,
                           szCopyright,
                           -1,
                           wszNew,
                           100) - 1;
            }
#else
            int iStr = LoadString(g_hInst, IDS_COPYRIGHT, wszNew, 100);
#endif
            if (iStr != 0) {
                lstrcpyWInternal(wszNew + iStr, *str);
                hr = SysReAllocString(str, wszNew);
            }
        }
        return hr;
    }

private:

    enum {
        ID3_HEADER_LENGTH          = 10,
        ID3_EXTENDED_HEADER_LENGTH = 10,
    
    
        //  ID3 flags
        ID3_FLAGS_UNSYNCHRONIZED   = 0x80,
        ID3_FLAGS_EXTENDED_HEADER  = 0x40,

        // keep sizes down
        MAX_TEXT                   = 500
    };


    static BYTE MajorVersion(const BYTE *pbData)
    {
        return pbData[3];
    }
    
    static BYTE Flags(const BYTE *pbData)
    {
        return pbData[5];
    }
    
    static LONG ExtendedHeaderLength(const BYTE *pbData)
    {
        /*  Only if == version == 3 and bit set */
        if (MajorVersion(pbData) == 3 && 
            (Flags(pbData) & ID3_FLAGS_EXTENDED_HEADER)) {
            return 10 + GetLength(pbData + ID3_HEADER_LENGTH + 6);
        } else {
            return 0;
        }
    }
    
    DWORD static GetLength(const BYTE *pbData)
    {
        return (((DWORD)pbData[0] << 24) +
                ((DWORD)pbData[1] << 16) +
                ((DWORD)pbData[2] << 8 ) +
                 (DWORD)pbData[3]);
    }
    

    DWORD static GetLength3(const BYTE *pbData)
    {
        return (((DWORD)pbData[0] << 16) +
                ((DWORD)pbData[1] << 8 ) +
                 (DWORD)pbData[2]);
    }
    
    static LONG FrameLength(const BYTE *pbID3)
    {
        BYTE bVersion = MajorVersion(pbID3);
        ASSERT(bVersion == 2 || bVersion == 3);
        return bVersion == 2 ? 6 : 10;
    }
    
    /*  ID3 stuff - given a frame id returns
        pointer to the frame and length or NULL if frame id not found
    
        Assumes not unsynchronized
    */
    static const BYTE *GetFrame(
        const BYTE *pbID3,
        DWORD dwFrameId, 
        LONG *plLength
    )
    {
        /*  Scan the header for the frame data */
        if (pbID3) {
            ASSERT(0 == (Flags(pbID3) & ID3_FLAGS_UNSYNCHRONIZED));

            /*  Ignore compressed content */
            if (Flags(pbID3) & 0x40) {
                return NULL;
            }

            LONG lID3 = TotalLength(pbID3);
        
            /*  Different for V2 and V3 */
            LONG lPos = 10;
    
            if (MajorVersion(pbID3) == 2) {
                /*  Loop until the next header doesn't fit */
                while ( (lPos + 6) < lID3 ) {
                    /* Extract the frame length (including header) */
                    LONG lLength = 6 + GetLength3(pbID3 + lPos + 3);
                    DWORD dwID = pbID3[lPos] + 
                                 (pbID3[lPos + 1] << 8) +
                                 (pbID3[lPos + 2] << 16);
                    if (dwID == dwFrameId) {
                        if ( (lPos + lLength) <= lID3 ) {
                            *plLength = lLength - 6;
                            return pbID3 + lPos + 6;
                        }
                    }
                    lPos += lLength;
                }
            } else {
                ASSERT(MajorVersion(pbID3) == 3);
    
                /*  Skip any extended header */
                lPos += ExtendedHeaderLength(pbID3);
        
                /*  Loop until the next header doesn't fit */
                while ( (lPos + 10) < lID3 ) {
                    /* Extract the frame length (including header) */
                    LONG lLength = 10 + GetLength(pbID3 + lPos + 4);
                    if (*(UNALIGNED DWORD *)(pbID3 + lPos) == dwFrameId) {
                        if ( (lPos + lLength) <= lID3 ) {
                            /*  Ignore compressed or encrypted frames 
                                and reject 0 length or huge
                            */
                            if (pbID3[lPos + 9] & 0xC0) {
                                return NULL;
                            }
                            *plLength = lLength - 10;
                            return pbID3 + lPos + 10;
                        }
                    }
                    lPos += lLength;
                }
            }
        }
        return NULL;
    }
    
    /*  Extract a BSTR for a given tag type */
    
    /*  Grab the string from the ID3 frame and make a BSTR */
    static HRESULT GetFrameString(const BYTE *pbID3, DWORD dwId, BSTR *str)
    {
        LONG lFrame;
        const BYTE *pbFrame = GetFrame(pbID3, dwId, &lFrame);

        if (pbFrame && lFrame <= MAX_TEXT) {
            LPWSTR pwszCopy;

            /*  Handle UNICODE, non-UNICODE and byte order */
            if (pbFrame[0] == 0x01) {

                BOOL bSwap = TRUE;
                if (pbFrame[0] == 0xFF && pbFrame[1] == 0xFE) {
                    bSwap = FALSE;
                }

                /*  Make a copy for WORD alignment, swapping, and 
                    NULL termination

                    Same size -1 because 
                    -  Ignore UNICODE indicator
                    -  we'll ignore the Unicode BOM
                    -  but we may need to NULL terminate
                */
                PBYTE pbCopy = (PBYTE)_alloca(lFrame);

                /*  This is meant to be UNICODE - get length by
                    scanning for NULL
                */
                if (lFrame < 3) {
                    return E_NOTIMPL;
                }
                pbFrame += 3;
                lFrame -= 3;
                LONG lPos = 0; /*  Don't need the BOM or 1st char */
                while (lPos + 1 < lFrame) {
                    if (pbFrame[lPos] == 0 && pbFrame[lPos+1] == 0) {
                        break;
                    }
                    if (bSwap) {
                        pbCopy[lPos] = pbFrame[lPos + 1];
                        pbCopy[lPos + 1] = pbFrame[lPos];
                    } else {
                        pbCopy[lPos] = pbFrame[lPos];
                        pbCopy[lPos+1] = pbFrame[lPos+1];
                    }
                    lPos += 2;
                }
                pbCopy[lPos] = 0;
                pbCopy[lPos + 1] = 0;

                pwszCopy = (LPWSTR)pbCopy;

                *str = SysAllocString((const OLECHAR *)pwszCopy);
                if (*str == NULL) {
                    return E_OUTOFMEMORY;
                }
                return S_OK;
            } else {

                /*  Encoding type must be 0 or 1 */
                if (pbFrame[0] != 0) {
                    return E_NOTIMPL;
                }

                /*  Skip encoding type byte */
                pbFrame++;
                lFrame--;

                return GetAnsiString(pbFrame, lFrame, str);
            }
        }
        return E_NOTIMPL;
    } 

    static HRESULT GetAnsiString(const BYTE *pbData, LONG lLen, BSTR *str)
    {
        LPWSTR pwszCopy = (LPWSTR)_alloca((lLen + 1) * sizeof(WCHAR));
        int cch = MultiByteToWideChar(
                      CP_ACP,
                      MB_PRECOMPOSED, /* Is this right? */
                      (LPCSTR)pbData,
                      lLen,
                      pwszCopy,
                      lLen);

        /* make sure it's NULL terminated */
        pwszCopy[cch] = 0;

        /* Also remove trailing spaces */
        while (cch--) {
            if (pwszCopy[cch] == L' ') {
                pwszCopy[cch] = 0;
            } else {
                break;
            }
        }

        *str = SysAllocString((const OLECHAR *)pwszCopy);
        if (*str == NULL) {
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\mpegdef.h ===
// Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.

/*
    mpegdef.h

    This file defines the externals for interfacing with MPEG
    components
*/

/*

    MPEG constants

*/

#define MPEG_TIME_DIVISOR (90000)
#define MPEG_MAX_TIME ((LONGLONG)0x200000000)

#define PICTURE_START_CODE       0x00000100
#define USER_DATA_START_CODE     0x000001B2
#define SEQUENCE_HEADER_CODE     0x000001B3
#define SEQUENCE_ERROR_CODE      0x000001B4
#define EXTENSION_START_CODE     0x000001B5
#define SEQUENCE_END_CODE        0x000001B7
#define GROUP_START_CODE         0x000001B8

#define ISO_11172_END_CODE       0x000001B9
#define PACK_START_CODE          0x000001BA
#define SYSTEM_HEADER_START_CODE 0x000001BB
#define PADDING_START_CODE       0x000001BE
#define PACKET_START_CODE_MIN    0x000001BC
#define PACKET_START_CODE_MAX    0x000001FF

#define AUDIO_GLOBAL             0xB8
#define VIDEO_GLOBAL             0xB9
#define RESERVED_STREAM          0xBC
#define PRIVATE_STREAM_1         0xBD
#define PADDING_STREAM           0xBE
#define PRIVATE_STREAM_2         0xBF
#define AUDIO_STREAM             0xC0
#define AUDIO_STREAM_MASK        0xE0
#define VIDEO_STREAM             0xE0
#define VIDEO_STREAM_MASK        0xF0
#define DATA_STREAM              0xF0
#define DATA_STREAM_MASK         0xF0

/*  MPEG-2 stuff */
#define PROGRAM_STREAM_DIRECTORY 0xFF
#define PROGRAM_STREAM_MAP       0xBC
#define ANCILLIARY_STREAM        0xF9
#define ECM_STREAM               0xF0
#define EMM_STREAM               0xF1

#define VALID_PACKET(data)      (((data) >= PACKET_START_CODE_MIN)  \
                              && ((data) <= PACKET_START_CODE_MAX))

#define VALID_SYSTEM_START_CODE(data)     \
       (VALID_PACKET(data)                \
    ||  (data) == SYSTEM_HEADER_START_CODE\
    ||  (data) == PACK_START_CODE         \
    ||  (data) == ISO_11172_END_CODE)


/*  Types of stream */
inline BOOL IsVideoStreamId(BYTE StreamId)
{
    return (StreamId & 0xF0) == 0xE0;
} ;
inline BOOL IsAudioStreamId(BYTE StreamId)
{
    return (StreamId & 0xE0) == 0xC0;
} ;

#define MAX_MPEG_PACKET_SIZE (65535+6)

/*  Lengths of the various structures */
#define PACK_HEADER_LENGTH 12
#define SYSTEM_HEADER_BASIC_LENGTH 12

#define DWORD_SWAP(x) \
     ((DWORD)( ((x) << 24) | ((x) >> 24) | \
               (((x) & 0xFF00) << 8) | (((x) & 0xFF0000) >> 8)))


/*  Video definitions */

/*  Frame types as defined in a picture header */
#define I_Frame 1
#define D_Frame 4
#define P_Frame 2
#define B_Frame 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\parseerr.h ===
// Copyright (c) Microsoft Corporation 1995. All Rights Reserved

/*  MPEG parsing error codes */

enum {
    Error_InvalidPack                   = 0x10000,
    Error_Scanning                      = 0x20000,
    Error_InvalidSystemHeader           = 0x30000,
    Error_InvalidPacketHeader           = 0x40000,

    Error_InvalidSystemHeaderStream     = 0x01,
    Error_InvalidStreamId               = 0x02,
    Error_DuplicateStreamId             = 0x03,
    Error_InvalidLength                 = 0x04,
    Error_InvalidStartCode              = 0x05,
    Error_NoStartCode                   = 0x06,
    Error_InvalidMarkerBits             = 0x07,
    Error_InvalidStuffingByte           = 0x08,
    Error_InvalidHeaderSize             = 0x09,
    Error_InvalidType                   = 0x0A,
    Error_InvalidClock                  = 0x0B
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\mpegprse.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

     Stuff for parsing an MPEG-I system stream.

     Unfortunately we don't call to get the data - we get called.

     If we can't see the whole structure we're trying to look at
     we wait for more data.

     If the data we're trying to parse isn't contiguous and
     we want it to be we register an error (may have to revisit?).

     The two sources we know about at the moment:

         1.  Video CD
         2.  Raw file

     Will always give pass us contiguous MPEG-I stream constructs

     NOTE - the Video CD data is not subject to random seek parse
     errors because it is all segment aligned.
*/

typedef enum {
       State_Initializing = 0,
       State_Seeking,
       State_Run,
       State_FindEnd,
       State_Stopping
} Stream_State;



/*  Define a large value which doesn't wrap around if you add a bit */
#define VALUE_INFINITY ((LONGLONG)0x7F00000000000000)

/***************************************************************************\

              Basic stream parsing

\***************************************************************************/

class CParseNotify;  // Predeclare
class CBasicStream;
class CStream;
class CVideoParse;

class CBasicParse
{
public:

    /*  Constructor/destructor */
    CBasicParse() : m_pNotify(NULL),
                    m_bSeekable(FALSE)
    {};

    virtual ~CBasicParse() {};

    /*  State setting */
    void SetNotify(CParseNotify *pNotify)
    {
        m_pNotify = pNotify;
    };
    virtual BOOL IsSeekable()
    {
        return m_bSeekable;
    };
    LONGLONG Size()
    {
        return m_llTotalSize;
    };
    virtual HRESULT Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt)
    {
        ASSERT(bSeekable || llSize == 0);
        m_pTimeFormat        = &TIME_FORMAT_MEDIA_TIME;
        m_Rate               = 1.0;
        m_Start              = 0;
        m_Stop               = VALUE_INFINITY;

        m_llTotalSize        = llSize;
        m_bSeekable          = bSeekable;
        m_State              = State_Initializing;

        m_llSeek             = 0;

        m_pmt                = pmt;
        Discontinuity();
        return S_OK;
    };
                                                  // Set to initializing state
    virtual HRESULT FindEnd()                     // Set to 'find end' state
    {
        SetState(State_FindEnd);
        return S_OK;
    };
    virtual HRESULT Replay()                      // Be prepared to restart
    {
        Discontinuity();
        return S_OK;
    };
    virtual HRESULT Run()                         // Set to Run state
    {
        SetState(State_Run);
        return S_OK;
    };
    virtual HRESULT EOS()                         // End of segment - complete
    {                                             // your state transition or
        return S_OK;                              // die!
    };

    //  Start grovelling for start position
    virtual void SetSeekState() = 0;


    virtual HRESULT Seek(LONGLONG llSeek,
                         REFERENCE_TIME *prtStart,
                         const GUID *pTimeFormat) = 0;
                                                  // Set seek target
    virtual HRESULT SetStop(LONGLONG llStop)      // Set end
    {
        m_Stop = llStop;
        return S_OK;
    };

    //  Return start and stop in time units
    virtual REFERENCE_TIME GetStartTime()
    {
        return m_Start;
    };
    virtual REFERENCE_TIME GetStopTime();

    virtual void SetRate(double dRate)
    {
        m_Rate = dRate;
    };
    double GetRate()
    {
        return m_Rate;
    };

    //  Return start and stop in current time format units
    LONGLONG GetStart()
    {
        return m_llSeek;
    }
    LONGLONG GetStop()
    {
        return m_Stop;
    }

    /*  Flags for ParseBytes */
    enum { Flags_EOS   = 0x01,
           Flags_First = 0x02,
           Flags_SlowMedium = 0x04  // Set when file end not available
         };

    virtual LONG ParseBytes(LONGLONG llPos,
                            PBYTE    pData,
                            LONG     lLength,
                            DWORD    dwFlags) = 0;

    virtual HRESULT GetDuration(LONGLONG *pllDuration,
                                const GUID *pTimeFormat = &TIME_FORMAT_MEDIA_TIME) = 0;

    virtual LONG GetBufferSize() = 0;

    /*  Stream list manipulation to build up output pins */
    virtual CBasicStream *GetStream(int i) = 0;
    virtual int NumberOfStreams() = 0;

    /*  Time Format support - default to only time */
    virtual HRESULT IsFormatSupported(const GUID *pTimeFormat);

    /*  Set the time/position format */
    virtual HRESULT SetFormat(const GUID *pFormat);

    /*  Return the medium position */
    virtual BOOL GetMediumPosition(LONGLONG *pllPosition)
    {
        UNREFERENCED_PARAMETER(pllPosition);
        return FALSE;
    };

    virtual UCHAR GetStreamId(int iIndex)
    {
        return 0xFF;
    }

    /*  Get the time format */
    const GUID *TimeFormat()
    {
        return m_pTimeFormat;
    };

    // Converts a GUID pointer into a pointer to our local GUID
    // (NULL implies default which is the one returned by our TimeFormat() above.)
    const GUID * ConvertToLocalFormatPointer( const GUID * pFormat );

    HRESULT ConvertTimeFormat( LONGLONG * pTarget, const GUID * pTargetFormat
                            , LONGLONG    Source, const GUID * pSourceFormat );

    /*  Content stuff */
    typedef enum {
        Author      = 1,
        Copyright   = 2,
        Title       = 3,
        Description = 4,
        Artist      = 5
    } Field;

    virtual BOOL HasMediaContent() const { return FALSE; };
    virtual HRESULT GetContentField(Field dwFieldId, LPOLESTR *str)
    {
        return E_NOTIMPL;
    }


protected:

    /*  Shut off some warnings */
    CBasicParse(const CBasicParse& objectSrc);          // no implementation
    void operator=(const CBasicParse& objectSrc);       // no implementation

    /*  Utility function */
    virtual void Discontinuity() = 0;

    /*  Set the current stream processing state */
    virtual void SetState(Stream_State state)
    {
        m_State = state;
        Discontinuity();
    };

    // Convert times between formats
    virtual LONGLONG Convert(LONGLONG llOld,
                     const GUID *OldFormat,
                     const GUID *NewFormat)
    {
        // Caller must check that the formats are OK
        ASSERT( NewFormat == OldFormat );
        return llOld;
    }

    /*  Our state */

    CParseNotify * m_pNotify;

    /*  Position stuff */
    const GUID     *m_pTimeFormat;
    LONGLONG        m_Start;
    LONGLONG        m_Stop;
    double          m_Rate;

    /*  Inputs from Init */
    LONGLONG                 m_llTotalSize;    // Size in bytes
    BOOL                     m_bSeekable;        // If seekable

    /*  Parsing state */
    Stream_State m_State;

    /*  Input media type */
    CMediaType  const       *m_pmt;

    /*  Starting byte position */
    LONGLONG                 m_llStart;

    /*
    **  Seek information
    **  This information is saved when Seek is called
    **  and used when SetSeekState is called
    */

    /*  Next start position (format is m_pTimeFormat) */
    LONGLONG        m_llSeek;
};

class CParseNotify
{
public:
    virtual void ParseError(UCHAR       uStreamId,
                            LONGLONG    llPosition,
                            DWORD       Error) = 0;
    virtual void SeekTo(LONGLONG llPosition) = 0;
    virtual void Complete(BOOL          bSuccess,
                          LONGLONG      llPosFound,
                          REFERENCE_TIME tFound) = 0;
    virtual HRESULT QueuePacket(UCHAR uStreamId,
                                PBYTE pbData,
                                LONG lSize,
                                REFERENCE_TIME tStart,
                                BOOL bSync) = 0;


    /*  Read data - negative start means from end */
    virtual HRESULT Read(LONGLONG llStart, DWORD dwLen, BYTE *pbData) = 0;
};

/***************************************************************************\

              Multiple stream stuff for system streams

\***************************************************************************/

class CStreamList
{
public:
    CStreamList() : m_nValid(0),
                    m_lStreams(NAME("Stream List"))
    {
    };
    virtual ~CStreamList()
    {
    };

    virtual BOOL AddStream(CStream *) = 0;
    virtual BOOL RemoveStream(CStream *) = 0;

    /*  Find the start clock time in MPEG units for the system stream */
    virtual LONGLONG StartClock() = 0;


    /*  Callbacks to get the start and stop */
    virtual CSTC GetStart() = 0;
    virtual CSTC GetStop() = 0;

    /*  Are we playing x to x ? */
    virtual LONGLONG GetPlayLength() = 0;

    /*  Stream has finished state transition */
    virtual void Complete(UCHAR uStreamId,
                          BOOL bSuccess,
                          LONGLONG llPos,
                          CSTC stc) = 0;

    virtual void CheckStop() = 0;
    /*  Is the audio fixed rate ? */
    virtual BOOL AudioLock() = 0;

    /*  For debugging allow streams to get real clock */
    virtual REFERENCE_TIME CurrentTime(CSTC stc) = 0;
protected:
    /*  List of streams */
    CGenericList<CStream> m_lStreams;

    /*  Clock stuff */
    LONGLONG m_llLength;         // Total length (in time units)
    CSTC     m_stcStartPts;      // Starting 'time'
    CSTC     m_stcRealStartPts;  // Starting 'time' at start of file


    /*  Callback stuff */
    LONG     m_nValid;           // Number of valid streams so far
    BOOL     m_bCompletion;      // OK?
    LONG     m_nPacketsProcessed;// Count up how many we've done
};

class CMpeg1SystemParse : public CBasicParse,
                          public CMpegStreamTime,
                          public CStreamList
{
    typedef struct {
        DWORD dwStartCode;
        WORD  wLength;
        BYTE  RateBound[3];
        BYTE  AudioBoundAndFlags;
        BYTE  VideoBoundAndFlags;
        BYTE  bReserved;
        BYTE  StreamData[68 * 3];
    } SystemHeader;

public:
    CMpeg1SystemParse();
    ~CMpeg1SystemParse();

    /*  CBasicParse methods */

    virtual LONG ParseBytes(LONGLONG llPos,
                            PBYTE    pData,
                            LONG     lLength,
                            DWORD    dwFlags);

    void SearchForEnd() {
        ASSERT(Initialized());
        DbgLog((LOG_TRACE, 4, TEXT("Parse state <searching for end>")));
        m_State = State_FindEnd;
    };

    /*  2-stage initialization - says what type of data */
    HRESULT Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt);

    HRESULT FindEnd();                       // Set to 'find end' state
    void    SetSeekState();                  // Actually start seeking
    HRESULT Seek(LONGLONG llSeek,
                 REFERENCE_TIME *rtStart,
                 const GUID *pTimeFormat);   // Schedule seek
    HRESULT SetStop(LONGLONG llStop);        // Set end
    HRESULT Replay();                        // Be prepared to restart

    REFERENCE_TIME GetStartTime();

    /*  Set duration information when we've got the duration */
    void SetDurationInfo()
    {
        m_Stop = MpegToReferenceTime(m_llDuration);
        m_Stop = CRefTime(m_Stop) + (LONGLONG)1;
        m_rtDuration = Int64x32Div32(m_llDuration, 1000, 9, 500);

        /*  Absolute MPEG time to stop */
        m_llStopTime = m_llDuration + StartClock();
    };


    /*  Set the time/position format */
    HRESULT SetFormat(const GUID *pFormat);

    /*  CStreamList stuff - find the start and stop time */

    CSTC GetStart();
    CSTC GetStop();

    /*  How much are we being asked to play (in time format units)? */
    virtual LONGLONG GetPlayLength();

    /*  Stream has finished its work */
    void Complete(UCHAR uStreamId, BOOL bSuccess, LONGLONG llPos, CSTC stc);
    void SetState(Stream_State);

    /*  Stream list manipulation */
    CBasicStream *GetStream(int i);
    BOOL AddStream(CStream *);

    /*  Destructor of CStream calls this */
    BOOL RemoveStream(CStream *);

    /*  Set running state (ie begin preroll) */
    HRESULT Run();

    /*  Get total duration */
    HRESULT GetDuration(LONGLONG * pllDuration,
                        const GUID *pTimeFormat = &TIME_FORMAT_MEDIA_TIME);

    /*  Get the preferred allocator buffer size */
    LONG GetBufferSize();

    void Discontinuity();


    void Fail(HRESULT hr) {
        m_FailureCode = hr;
    };

    BOOL Failed()
    {
        return m_FailureCode != S_OK;
    };

    /*  Callbacks when something happens */
    virtual void ParseError(DWORD dwError);
    virtual HRESULT EOS();
    virtual void InitStreams();


    BOOL Initialized() {
        return TRUE;
    };

    LONGLONG Duration();

    //
    //  Find stuff from the system header
    //
    BOOL AudioLock()
    {
        ASSERT(m_lSystemHeaderSize != 0);
        return (m_SystemHeader.VideoBoundAndFlags & 0x80) != 0;
    };
    void CheckStop();


    virtual int NumberOfStreams()
    {
        return m_lStreams.GetCount();
    };

    REFERENCE_TIME CurrentTime(CSTC stc)
    {
        return MpegToReferenceTime(GetStreamTime(stc) - m_llStartTime);
    };

    /*  Say if we support a given format */
    HRESULT IsFormatSupported(const GUID *pTimeFormat);

    /*  Return the medium position */
    virtual BOOL GetMediumPosition(LONGLONG *pllPosition)
    {
        if (m_pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
            return FALSE;
        }
        if (m_pTimeFormat == &TIME_FORMAT_BYTE) {
            *pllPosition = m_llPos;
            return TRUE;
        }
        ASSERT(m_pTimeFormat == &TIME_FORMAT_FRAME);
        return FALSE;
    };

    UCHAR GetStreamId(int iIndex);

protected:

    /*  Parsing helper functions */
    LONG ParsePack(PBYTE pData, LONG lBytes);
    LONG ParseSystemHeader(PBYTE pData, LONG lBytes);
    LONG ParsePacket(DWORD dwStartCode, PBYTE pData, LONG lBytes);

    /*  Extract a clock from the MPEG data stream */
    BOOL GetClock(PBYTE pData, CSTC *Clock);
    LONGLONG StartClock();
    /*  Are we complete ? */
    BOOL IsComplete();

    /*  Return the reference time to be put in the sample
        This value is adjusted for rate
    */
    REFERENCE_TIME SampleTime(REFERENCE_TIME t)
    {
        if (m_Rate != 1.0) {
            return CRefTime((LONGLONG)((double)t / m_Rate));
        } else {
            return t;
        }
    };

    BOOL SendPacket(UCHAR    uStreamId,
                    PBYTE    pbPacket,
                    LONG     lPacketSize,
                    LONG     lHeaderSize,
                    BOOL     bHasPts,
                    CSTC     cstc);

    /*  Add a stream - returns NULL if stream not added */
    CStream * AddStream(UCHAR uStreamId);

protected:

    /*  Format conversion helper */
    LONGLONG Convert(LONGLONG llOld,
                     const GUID *OldFormat,
                     const GUID *NewFormat);

    /*  Keep track of current position */
    LONGLONG                 m_llPos;

    /*  Remember if we have a video stream */
    CVideoParse             *m_pVideoStream;

    /*  Bits to chop off for video in reference time units */ 
    LONGLONG                 m_rtVideoStartOffset;
    LONGLONG                 m_rtVideoEndOffset;
    DWORD                    m_dwFrameLength;

    /*  Handle discontinuities */
    BYTE                     m_bDiscontinuity;



    /*  The variables below are only valid if seeking is supported
        (m_bSeekable)
    */

    /*  Total length in time */
    BYTE                     m_bGotDuration;
    LONGLONG                 m_llDuration;   // In MPEG units
    REFERENCE_TIME           m_rtDuration;   // In REFERENCE_TIME units

    /*  Keep track of completions */
    CSTC                     m_stcComplete;
    LONGLONG                 m_llCompletePosition;


    /*  Start and stop time as absolute times (directly comparable to
        times in the movie
    */
    LONGLONG                 m_llStartTime;
    LONGLONG                 m_llStopTime;
    BYTE                     m_bGotStart;   // Start time valid?

    /*  Are we VideoCD? */
    BYTE                     m_bVideoCD;
    bool                     m_bItem;       // Has stills

    /********************************************************************
        Concatenated streams stuff (like Silent Steel)

        The 'design' is as follows:

        1.  Detect concatenated streams if the mux rate proportionately
            doesn't match the end time.

            In this case compute the duration based on the mux rate.

        2.  For a concatenated streams file while seeking of playing
            do nothing until we get a pack start code at which point we
            compute the timestamp offset based on the pack time stamp
            and the file position :

            m_stcTSOffset + Pack SCR == File time based on position using
                                        MUX rate

        3.  Every packet time stamp has m_stcTSOffset applied to it for
            a concatenated file.

        4.  When we detect a time discontinuity in a pack reset
            m_stcTSOffset again to the file position

        Variables:

        m_bConcatenatedStreams - set during initialization if we detect
                                 this situation

        m_stcTSOffset - Offset to add to all PTSs in this case
    */

    BYTE                     m_bConcatenatedStreams;
    CSTC                     m_stcTSOffset;

    /*  System header stuff - invalid if m_lSystemHeaderSize is 0
        also we don't remember this stuff for video cd
    */
    LONG                     m_lSystemHeaderSize;
    DWORD                    m_MuxRate;
    HRESULT                  m_FailureCode;
    SystemHeader             m_SystemHeader;
};

class CVideoCDParse : public CMpeg1SystemParse
{
public:
    CVideoCDParse()
    {
        m_bVideoCD = TRUE;
    };

    virtual LONG ParseBytes(LONGLONG llPos,
                            PBYTE    pData,
                            LONG     lLength,
                            DWORD    dwFlags);

    /*  Override byte positioning stuff to seek only the MPEG */

    /*  Get total duration */
    HRESULT GetDuration(LONGLONG * pllDuration,
                        const GUID *pTimeFormat = &TIME_FORMAT_MEDIA_TIME);

    /*  Seek to a given position */
    HRESULT Seek(LONGLONG llSeek,
                 REFERENCE_TIME *prtStart,
                 const GUID *pTimeFormat);
};

//  Basic stream class
class CBasicStream
{
public:
    CBasicStream() : m_bPayloadOnly(FALSE),
                     m_bDiscontinuity(TRUE),
                     m_uStreamId(0xFF),
                     m_uNextStreamId(0xFF),
                     m_uDefaultStreamId(0xFF)
    {};
    virtual ~CBasicStream() {};

    virtual HRESULT GetMediaType(CMediaType *cmt, int iPosition) = 0;
    virtual HRESULT SetMediaType(const CMediaType *cmt, BOOL bPayload);
    virtual HRESULT ProcessType(AM_MEDIA_TYPE const *pmt)
    {
        return E_NOTIMPL;
    };

    virtual BOOL GetDiscontinuity()
    {
        BOOL bResult = m_bDiscontinuity;
        m_bDiscontinuity = FALSE;
        return bResult;
    };

    /*  Override this if you want to hear more about discontinuities */
    virtual void Discontinuity()
    {
        m_bDiscontinuity = TRUE;
        return;
    };

    /*  Id */
    UCHAR                    m_uStreamId;
    UCHAR                    m_uNextStreamId;
    UCHAR                    m_uDefaultStreamId;
    bool                     m_bStreamChanged;

    /*  Handle predefined media types */

protected:
    /*  Shut off some warnings */
    CBasicStream(const CBasicStream& objectSrc);          // no implementation
    void operator=(const CBasicStream& objectSrc);       // no implementation

    /*  Save the type information here */
    BOOL                     m_bPayloadOnly;

    /*  Discontinuity flag */
    BOOL                     m_bDiscontinuity;


};

//  Muxed stream class
class CStream : public CBasicStream
{
public:

    CStream(CStreamList *pList, UCHAR uStreamId, bool bItem=false) :
        m_bValid(FALSE),
        m_bSeeking(TRUE),
        m_bGotFirstPts(FALSE),
        m_pStreamList(pList),
        m_bTypeSet(FALSE),
        m_llStartPosition(0),
        m_bReachedEnd(FALSE),
        m_stc(0),
        m_bComplete(FALSE),
        m_bStopping(FALSE),
        m_bItem(bItem)
    {
        m_uStreamId     = uStreamId;
        m_uNextStreamId = uStreamId;
        m_uDefaultStreamId = uStreamId;
    }

    /*  Remove ourselves from the list */
    ~CStream()
    {
        m_pStreamList->RemoveStream(this);
    };


    /*  Seek to - seek target got from stream list */
    virtual void SetState(Stream_State);

    virtual BOOL ParseBytes(PBYTE pData,
                            LONG lLen,
                            LONGLONG llPos,
                            BOOL bHasPts,
                            CSTC stc) = 0;
    virtual void EOS();
    virtual BOOL    IsPayloadOnly();
    virtual CSTC    CurrentSTC(BOOL bHasPts, CSTC stc)
    {
        if (bHasPts) {
            m_stc = stc;
        }
        return m_stc;
    }

    BOOL IsPlaying(LONGLONG llPos, LONG lLen);


    /*  Utility for state change completion */
    void                      Complete(BOOL bSuccess, LONGLONG llPos, CSTC stc);

protected:
    virtual  void             Init() = 0;
    /*  Check if transition is complete */
    virtual  void             CheckComplete(BOOL bForce) = 0;

public:
    /*  Don't parse because we're running */
    BOOL  m_bRunning;

protected:
    BOOL                      m_bValid;
    BOOL                      m_bTypeSet;
    BOOL                      m_bSeeking;
    BOOL                      m_bGotFirstPts;
    CSTC                      m_stcStart;

    /*  This count increments as the streams declare themselves valid
        during initialization
    */
    LONG                     m_nValid;


    /*  Our 'parent' */
    CStreamList * const      m_pStreamList;

    /*  'current time' */
    CSTC                     m_stc;

    /*  Where to start playing from and where to stop */
    LONGLONG                 m_llStartPosition;
    BOOL                     m_bReachedEnd;

    /*  Complete ? */
    BOOL  m_bComplete;


    /*  Internal stopping state */
    BOOL  m_bStopping;

    /*  Video CD */
    bool  m_bItem;

    /*  State */
    Stream_State m_State;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\native.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    Native.h

    Parsing classes for native streams

*/

/*  Since we're only one stream we can inherit directly from
    CBasicParse and CBasicStream
*/

class CNativeParse : public CBasicParse, public CBasicStream
{
public:
    /*  Constructor/destructor */
    CNativeParse() : m_dwFlags(0), m_Duration(0) {};
    virtual ~CNativeParse() {};

    /*  CBasicParse methods */


    /*  NOTE - we inherit :
           m_bDiscontinuity     from CBasicStream
           Discontinuity        from CBasicParse
           GetDiscontinuity     from CBasicStream
    */
    void Discontinuity() { m_bDiscontinuity = TRUE; };

    /*  CBasicStream methods */
    CBasicStream *GetStream(int i)
    {
        ASSERT(i == 0 && 0 != (m_dwFlags & FLAGS_VALID));
        return this;
    };

    //  Return 0 if no valid stream was found
    int NumberOfStreams()
    {
        return (m_dwFlags & FLAGS_VALID) ? 1 : 0;
    };

    HRESULT GetDuration(
        LONGLONG *pllDuration,
        const GUID *pTimeFormat
    );   // How long is the stream?

protected:
    REFERENCE_TIME   m_Duration; // Length in 100ns units
    DWORD            m_dwFrames; // Length in frames

    /*  Parse state flags */
    /*  Values for dwFlags */
    enum { FLAGS_VALID    = 0x01   // Stream is valid stream
         };

    DWORD            m_dwFlags;

};

class CNativeVideoParse : public CNativeParse
{
public:
    HRESULT Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt);

    /*  CBasicParse methods */

    // Seek
    HRESULT     Seek(LONGLONG llSeek,
                     REFERENCE_TIME *prtStart,
                     const GUID *pTimeFormat);
    LONG        ParseBytes(                     // Process data
                    LONGLONG llPos,
                    PBYTE    pData,
                    LONG     lLength,
                    DWORD    dwFlags);

    /*  No need to look for end of small files - we've already done it */
    HRESULT FindEnd()
    {
        CBasicParse::FindEnd();

        /*  Notify a seek */
        if (m_bSeekable) {
            LONGLONG llSeekTo;

            /*  Scan around 1.5 seconds at end */
            if (m_Info.dwBitRate == 0) {
                /*  GUESS something based on the movie size */
                LONG lSize = m_Info.lWidth * m_Info.lHeight;
                if (lSize > 352 * 240) {
                    llSeekTo = m_llTotalSize -
                               MulDiv(300000,
                                      lSize,
                                      352 * 240);
                } else {
                    llSeekTo = m_llTotalSize - 300000;
                }
            } else {
                llSeekTo = m_llTotalSize -
                    MulDiv(m_Info.dwBitRate, 3, 2 * 8);
            }
            m_pNotify->SeekTo(llSeekTo < 0 ? 0 : llSeekTo);
        }
        return S_OK;
    };

    REFERENCE_TIME GetStopTime();

    /*  Set seek position */
    void SetSeekState();

    LONG GetBufferSize();                       // What input buffer size?

    void Discontinuity()
    {
        m_bDiscontinuity    = TRUE;
        m_dwCurrentTimeCode = (DWORD)-1;
        m_rtCurrent         = (REFERENCE_TIME)-1;
        m_nFrames           = 0;
        m_nTotalFrames      = 0;
        m_bIFound           = FALSE;
    };

    /*  CBasicStream methods */
    HRESULT GetMediaType(CMediaType *cmt, int iPosition);

    /*  Format support */
    HRESULT IsFormatSupported(const GUID *pTimeFormat);


    // Convert times between formats
    LONGLONG Convert(LONGLONG llOld,
                     const GUID *OldFormat,
                     const GUID *NewFormat);


private:
    /*  Utility routine
        Compute the time up to the last picture start code
        decoded
    */
    REFERENCE_TIME CurrentTime(int iSequenceNumber)
    {
        ASSERT(m_dwCurrentTimeCode != (DWORD)-1);
        return ComputeTime(m_dwCurrentTimeCode) +
               Int32x32To64(iSequenceNumber, m_Info.tPictureTime);
    };

private:
    enum { FLAGS_GOTSEQHDR = 0x08 };

    /*  Convert a time code to a reference time */
    REFERENCE_TIME ConvertTimeCode(DWORD dwCode);
    /*  Compute times of GOPs */
    REFERENCE_TIME ComputeTime(DWORD dwTimeCode);

    /*  Send chunk downstream */
    BOOL SendData(PBYTE pbData, LONG lSize, LONGLONG llPos);

    /*  Compute file stats */
    void SetDurationAndBitRate(BOOL bAtEnd, LONGLONG llPos);

    /*  Compute where we're up to */
    void ComputeCurrent();
private:
    /*  Member variables */

    SEQHDR_INFO m_Info;
    LONG m_nFrames;        /*  For counting frames from start of GOP */
    LONG m_nTotalFrames;   /*  Counting frames for time estmination */
    LONG m_lFirstFrameOffset; /* Offset of first picture start code */
    DWORD m_dwCurrentTimeCode;

    /*  Time we're up to in terms of what can be decoded */
    REFERENCE_TIME m_rtCurrent;

    /*  Time of first picture in current buffer */
    REFERENCE_TIME m_rtBufferStart;

    BOOL m_bIFound;

    /*  Track bad GOPs */
    BOOL m_bBadGOP;      /* GOP values are bad */
    BOOL m_bOneGOP;      /* Only one GOP (!) */

    /*  More hackery - try remembering the max sequence number we found */
    int m_iMaxSequence;

};

class CNativeAudioParse : public CNativeParse
{
public:
    CNativeAudioParse()
    {
        m_pbID3 = NULL;
    }

    ~CNativeAudioParse()
    {
        delete [] m_pbID3;
    }

    HRESULT Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt);

    /*  CBasicParse methods */
    HRESULT     Seek(LONGLONG llSeek,
                     REFERENCE_TIME *prtStart,
                     const GUID *pTimeFormat);
    HRESULT     SetStop(LONGLONG tStop);
    LONG        ParseBytes(                     // Process data
                    LONGLONG llPos,
                    PBYTE    pData,
                    LONG     lLength,
                    DWORD    dwFlags);

    LONG GetBufferSize();                       // What input buffer size?

    /*  CBasicStream methods */
    HRESULT GetMediaType(CMediaType *cmt, BOOL bPayload);

    HRESULT FindEnd()
    {
        CBasicParse::FindEnd();
        m_pNotify->Complete(TRUE, 0, 0);
        return S_OK;
    };
    /*  Set seek position */
    void SetSeekState();

    /*  Format checking */
    LONG CheckMPEGAudio(PBYTE pbData, LONG lData);

    /*  Content stuff */
    BOOL HasMediaContent() const { return m_pbID3 != NULL; };
    HRESULT GetContentField(CBasicParse::Field dwFieldId, LPOLESTR *str);

private:
    /*  Helper - compute time from offset */
    REFERENCE_TIME ComputeTime(LONGLONG llOffset);

    DWORD static GetLength(const BYTE *pbData)
    {
        return (((DWORD)pbData[0] << 24) +
                ((DWORD)pbData[1] << 16) +
                ((DWORD)pbData[2] << 8 ) +
                 (DWORD)pbData[3]);
    }

private:
    /*  Member variables */
    MPEG1WAVEFORMAT m_Info;

    /*  Stop position */
    LONGLONG m_llStop;

    /*  ID3 information */
    PBYTE    m_pbID3;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\driver.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

#include <mmreg.h>             // For MPEG1WAVEFORMAT
#include <mpegdef.h>           // General MPEG definitions
#include <buffers.h>           // Buffer class definition
#include <stmalloc.h>          // Allocator classes
#include <mpgtime.h>           // MPEG time base
#include <mpegprse.h>          // Parsing
#include "pullpin.h"	       // pulling from IAsyncReader
#include <rdr.h>	       // simple reader for GetStreamsAndDuration
#include <qnetwork.h>          // IAMMediaContent
#include "mpgsplit.h"          // Filter
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\alloc.cpp ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

/*  alloc.cpp - allocator for output pins */

#include <streams.h>
#include "driver.h"

CMpeg1Splitter::COutputAllocator::COutputAllocator(CStreamAllocator * pAllocator,
                                                   HRESULT          * phr) :
    CSubAllocator(NAME("CMpeg1Splitter::COutputAllocator"),
                  NULL,
                  pAllocator,
                  phr)
{
}

CMpeg1Splitter::COutputAllocator::~COutputAllocator()
{
}

long CMpeg1Splitter::COutputAllocator::GetCount()
{
    return m_lCount;
}
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\resource.h ===
/******************************Module*Header*******************************\
* Module Name: Resource.h
*
*
*
*
* Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved
\**************************************************************************/

#define MPEG_SPLITTER_BASE         5000

#define IDS_COPYRIGHT           MPEG_SPLITTER_BASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\inputpin.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

/*

    File:  inputpin.cpp

    Description:

        Definitions for CMpeg1Splitter::CInputPin

    This class defines the input pin for the MPEG-I stream splitter.

    It handles

        Connection of the input pin including allocator negotiation

        Receive() of data from its connected pin which is sends
        to the parser
*/

#include <streams.h>
#include "driver.h"
#include <seqhdr.h>
#include <native.h>

#pragma warning(disable:4355)

/*  Constructor and Destructor */
CMpeg1Splitter::CInputPin::CInputPin(CMpeg1Splitter *pSplitter,
                                     HRESULT *phr) :
    CBaseInputPin(NAME("CMpeg1Splitter::CInputPin"),
                  &pSplitter->m_Filter,
                  &pSplitter->m_csFilter,
                  phr,
                  L"Input"),
    m_pSplitter(pSplitter),
    m_pPosition(NULL),
    m_llSeekPosition(0),
    m_bPulling(FALSE),
    m_puller(this)
{
}

CMpeg1Splitter::CInputPin::~CInputPin()
{
    ASSERT(m_pPosition == NULL);
}

/*  Helper to pass stuff to the parser

    If in the process of handling the data we do a seek within the
    allocator we repeat sending the data to the parser.  If we didn't
    do this we wouldn't work properly because if the output pin we're
    connected to is at end of stream in this situation we won't get
    called again
*/
inline HRESULT CMpeg1Splitter::CInputPin::SendDataToParser(
    BOOL bEOS
)
{
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

    for (;;) {

        /*  We validate any newly valid data, call the parser and
            advance the pointer by as much as the parser ate
        */
        LONG lLengthToProcess = pAllocator->LengthValid();

        LONG lProcessed = m_pSplitter->m_pParse->ParseBytes(
                               pAllocator->GetCurrentOffset(),
                               pAllocator->GetPosition(),
                               lLengthToProcess,
                               bEOS ? CBasicParse::Flags_EOS : 0);

        DbgLog((LOG_TRACE, 3, TEXT("Processed %d bytes out of %d"),
                lProcessed, pAllocator->LengthValid()));

        pAllocator->Advance(lProcessed);

        if (m_State == State_Seeking) {
            /*  Force completion of seek */
            if (bEOS) {
                m_pSplitter->m_pParse->EOS();
            }

            /*  Check if a seek was requested */
            if (m_bSeekRequested) {
                //  This fires for some reason after time format
                //  changes due to the implicit seek
                //  generated by the format change
                //  ASSERT(m_bComplete);
                ASSERT(m_bPulling || (m_pPosition != NULL));

                /*  Note that we ate a seek but didn't request the
                    reader to seek
                */
                m_bSeekRequested = FALSE;

                CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

                /*  Check to see if the allocator can do it */
                pAllocator->Seek(m_llSeekPosition);
            }

            if (m_bComplete) {
                /*  If we've completed a seek then Run() */
                SetState(State_Run);
                m_pSplitter->m_pParse->Run();

                /*  Send any data already in the allocator

                    If we don't do this here then the next call we
                    get might be EndOfStream and we wouldn't use
                    the data we already have
                */
            } else {
                return S_OK;
            }
        } else {  // State_Running
            /*  Flush out the rest */
            m_pSplitter->SendOutput();

            /*  We don't want any more data if we've completed the play */
            if (m_bComplete || bEOS) {
                /*  We must have finished a play */
                EndOfStreamInternal();

                /*  Return S_FALSE if there was no seek - in this case
                **  WE generate the EndOfStream() call (what if none of
                **  our output pins are connected)?
                */
                return S_FALSE;
            } else {
                return S_OK;
            }

            /*  Parsing errors are reported to the filter graph - but then
                we may be completely stuck if we get one?
            */
        }
    }
}


/* IMemInputPin virtual methods */

/*  Gets called by the output pin when another sample is ready */
STDMETHODIMP CMpeg1Splitter::CInputPin::Receive(IMediaSample *pSample)
{
    // m_csReceive is held for the receive-thread operations such as Receive
    // You must hold m_csFilter already if you want both.
    CAutoLock lck(&m_pSplitter->m_csReceive);

    // This function does not check for media type changes because
    // it is extremely unlikely that the upstream filter will try to change
    // the media type by attaching a media type to a media sample.  If
    // the upstream filter tries to change the media type, the parser code
    // will reject the samples with the new media type.
    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    BOOL bDiscontinuity = pSample->IsDiscontinuity() == S_OK;

    /*  Find out the position this sample corresponds to */
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;

    if (bDiscontinuity) {
        // Make sure the parser knows
        m_pSplitter->m_pParse->Replay();

        // we can seek if we have either IAsyncReader or IMediaPosition
        if (m_bPulling || (m_pPosition != NULL)) {

            // if we are receiving data from a new segment, then
            // IPin::NewSegment will have told us the start time
            // (handled in CBasePin).
            //
            // if we are pulling data, then we maintain m_tStart and m_tStop
            // ourselves to be the selection we are fetching.

            // We must have the rounded start time from the puller
            // so do it anyway
            pAllocator->SetStart((LONGLONG)m_tStart / UNITS);


            //  Don't overlap with next seek request

            {
                CAutoLock lck(&m_pSplitter->m_csPosition);

                //  Always go to seeking state for a time-based seek
                SetState(State_Seeking);
                m_pSplitter->m_pParse->SetSeekState();

                //  May not require seek phase
                if (m_bComplete) {
                    SetState(State_Run);
                }
            }


        } else {
            /*  If the source is not seekable then the start position
                is meaningless but the allocator wants to be told something
            */
            pAllocator->SetStart(0);
        }
    }

    /*  First give the sample back to the allocator - this
        will AddRef the sample and update the length valid
    */
    PBYTE pbData;
    EXECUTE_ASSERT(SUCCEEDED(pSample->GetPointer(&pbData)));
    LONG lData = pSample->GetActualDataLength();

    /*  Avoid bugs in allocator */
    if (lData == 0) {
        DbgLog((LOG_TRACE, 0, TEXT("Unexpected End Of File")));
        EndOfStream();
        return S_FALSE;
    }

    /*  AddRef() it so we hold on to it (Advance() in the allocator balances
        this)
    */
    pSample->AddRef();

    hr = pAllocator->Receive(pbData, lData);
    if (FAILED(hr)) {

        pSample->Release();
        NotifyError(hr);

        /*  The whole allocator is now 'bad' */
        return hr;
    }

    /*  Process the new data */
    return SendDataToParser(FALSE);
}

/*  Where we're told which allocator we are using */
STDMETHODIMP CMpeg1Splitter::CInputPin::NotifyAllocator(IMemAllocator *pAllocator)
{
    // The MPEG1 Splitter's input pin is designed to only work with its' own allocator.
    if (pAllocator != m_pAllocator) {
        return E_FAIL;
    }
    return S_OK;
}

/*  Use our own allocator if possible */
STDMETHODIMP CMpeg1Splitter::CInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CAutoLock lck(m_pLock);

    HRESULT hr = S_OK;

    /*  Create our own allocator if it isn't already created */
    if (m_pAllocator == NULL) {
        m_pAllocator =
            new CStreamAllocator(NAME("CMpeg1Splitter::CInputPin::m_pAllocator"),
                                 NULL,     // No owner
                                 &hr,
                                 MAX_MPEG_PACKET_SIZE + 4);
        if (m_pAllocator == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            if (FAILED(hr)) {
                delete static_cast<CStreamAllocator *>(m_pAllocator);
                m_pAllocator = NULL;
            } else {
                m_pAllocator->AddRef();
            }
        }
    }

    *ppAllocator = m_pAllocator;

    /*  We return a reference counted pointer */
    if (m_pAllocator != NULL) {
        m_pAllocator->AddRef();
    }
    return hr;
}

/*  Start Flushing samples
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::BeginFlush()
{
    CAutoLock lck(m_pLock);

    if (m_pSplitter->m_Filter.m_State == State_Stopped) {
        return S_OK;
    }
    CBaseInputPin::BeginFlush();

    // can't flush the allocator here - need to sync with receive
    // thread, so do it in EndFlush

    /*  call the downstream pins  */
    return m_pSplitter->BeginFlush();
}

/*  End flushing samples - after this we won't send any more
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::EndFlush()
{
    CAutoLock lck(m_pLock);
    if (!IsFlushing()) {
        return S_OK;
    }

    //  Flush the allocator - need to do this after the receive
    // thread has been deactivated.
    CStreamAllocator *pAlloc = (CStreamAllocator *)m_pAllocator;
    pAlloc->ResetPosition();

    if (m_pSplitter->m_Filter.m_State != State_Stopped) {
        m_pSplitter->EndFlush();
    }
    return CBaseInputPin::EndFlush();
}

#if 0
HRESULT CMpeg1Splitter::CInputPin::SetStop(REFTIME llTime)
{
    ASSERT(m_bPulling || (m_pPosition != NULL));

    /*  We have to make the reader flush so reset its start! */
    // m_tStart is not our last SetStart value, but the last
    // NewSegment call. Thus if the app does put_Current, put_Stop
    // the put_Stop may reset the start position on the reader to
    // the start position before the put_Current.
    //
    // Safest fix according to Robin is just to not do this. The cost
    // is that if someone does (just) a put_Stop when the reader had
    // already reached the old stop position, the reader will not continue
    // to play beyond that old stop position

    // we know the start time from the last NewSegment call
    DbgLog((LOG_TRACE, 2, TEXT("CInputPin::SetStop - put_CurrentPosition(%s)"),
               (LPCTSTR)CDisp(m_tStart)));

    HRESULT hr = m_pPosition->put_CurrentPosition(m_tStart);

    return S_OK;
}
#endif


/*  Say if Receive can block
    It can't for us so we return S_FALSE
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::ReceiveCanBlock()
{
    return S_FALSE;
}

void CMpeg1Splitter::CInputPin::EndOfStreamInternal()
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::EndOfStreamInternal()")));
    CStreamAllocator *pAllocator = (CStreamAllocator *)m_pAllocator;
    pAllocator->Advance(pAllocator->TotalLengthValid());
    m_pSplitter->EndOfStream();
}

/*  End of data - either called by our input pin or by us if we
    detect it ourselves
*/
STDMETHODIMP CMpeg1Splitter::CInputPin::EndOfStream()
{
    // hold m_csReceive on receive-thread operations to sync with Stop

    CAutoLock lck(&m_pSplitter->m_csReceive);
    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }
    /*  Send any dregs to the parser
        SendDataToParser will call EndOfStreamInternal
    */
    SendDataToParser(TRUE);

    return S_OK;
}


/* CBasePin methods */

HRESULT CMpeg1Splitter::CInputPin::GetMediaType(int iPosition,CMediaType *pMediaType)
{
    pMediaType->majortype            = MEDIATYPE_Stream;
    ASSERT(pMediaType->bFixedSizeSamples);
    pMediaType->bTemporalCompression = TRUE;
    ASSERT(pMediaType->lSampleSize == 1);

    switch (iPosition) {
    case 0:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1System;
        break;

    case 1:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1VideoCD;
        break;

    case 2:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1Video;
        break;

    case 3:
        pMediaType->subtype = MEDIASUBTYPE_MPEG1Audio;
        break;

    default:
        return VFW_S_NO_MORE_ITEMS;
    }
    return S_OK;
}


/*  Connection establishment */
HRESULT CMpeg1Splitter::CInputPin::CheckMediaType(const CMediaType *pmt)
{
    for (int i = 0; ; i++) {
        CMediaType mt;
        HRESULT hr = GetMediaType(i, &mt);
        if (hr == VFW_S_NO_MORE_ITEMS) {
            break;
        }
        if (*pmt->Type() == *mt.Type() &&
            *pmt->Subtype() == *mt.Subtype()) {
            if (*pmt->FormatType() == GUID_NULL) {
                return S_OK;
            }
            if ((pmt->subtype == MEDIASUBTYPE_MPEG1System ||
                 pmt->subtype == MEDIASUBTYPE_MPEG1VideoCD) &&
                pmt->formattype == FORMAT_MPEGStreams ||
                pmt->subtype == MEDIASUBTYPE_MPEG1Audio &&
                pmt->formattype == FORMAT_WaveFormatEx ||
                pmt->subtype == MEDIASUBTYPE_MPEG1Video &&
                pmt->formattype == FORMAT_VideoInfo) {
                return S_OK;
            }
        }
    }
    return S_FALSE;
}

/*  Called when connect is broken or we fail to connect */
HRESULT CMpeg1Splitter::CInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE, 2, TEXT("CInputPin::BreakConnect()")));

    if (m_bPulling) {
        m_puller.Disconnect();
        m_bPulling = FALSE;
    }

    /*  Disconnect and remove all the output pins */
    m_pSplitter->RemoveOutputPins();
    if (m_pPosition != NULL) {
        m_pPosition->Release();
        m_pPosition = NULL;
    }

    /*  Free the parser */
    if (m_pSplitter->m_pParse != NULL) {
        delete m_pSplitter->m_pParse;
        m_pSplitter->m_pParse = NULL;
    }
    return CBaseInputPin::BreakConnect();
}

/*  Override active to tell parser we're going to get new data */
HRESULT CMpeg1Splitter::CInputPin::Active()
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::Active()")));
    HRESULT hr = m_pSplitter->m_pParse->Replay();
    if (FAILED(hr)) {
        return hr;
    }

    if (m_bPulling) {

        // since we control exactly when and where we get data from,
        // we should always explicitly set the start and stop position
        // ourselves here
        m_puller.Seek(m_tStart, m_tStop);

        // if we are pulling data from IAsyncReader, start our thread working
        hr = m_puller.Active();
        if (FAILED(hr)) {
            return hr;
        }
    }

    return CBaseInputPin::Active();
}

/*  Override Inactive to synchronize with Receive() */
HRESULT CMpeg1Splitter::CInputPin::Inactive()
{
    if (!IsConnected()) {
        return S_OK;
    }

    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::CInputPin::Inactive()")));

    // if we are pulling data from IAsyncReader, stop our thread
    if (m_bPulling) {
        HRESULT hr = m_puller.Inactive();
        if (FAILED(hr)) {
            return hr;
        }
    }

    /*  Call the base class - future Receives will now fail */
    return CBaseInputPin::Inactive();
}

/*  Override CompleteConnect so we can check out the real file data
    before accepting the connection
*/
HRESULT CMpeg1Splitter::CInputPin::CompleteConnect(IPin *pPin)
{
    DbgLog((LOG_TRACE, 3, TEXT("CMpeg1Splitter::CInputPin::CompleteConnect")));

#define READ_SIZE 32768
#define BUFFER_SIZE \
        (((MAX_MPEG_PACKET_SIZE + READ_SIZE - 1) / READ_SIZE) * READ_SIZE)

    int ReadSize = READ_SIZE;
    int BufferSize = BUFFER_SIZE;

    /*  Set up the parser */
    if (m_mt.subtype == MEDIASUBTYPE_MPEG1System) {
        m_pSplitter->m_pParse = new CMpeg1SystemParse;
        if (m_pSplitter->m_pParse == NULL) {
            return E_OUTOFMEMORY;
        }
    } else {
        if (m_mt.subtype == MEDIASUBTYPE_MPEG1VideoCD) {
            m_pSplitter->m_pParse = new CVideoCDParse;
            if (m_pSplitter->m_pParse == NULL) {
                return E_OUTOFMEMORY;
            }
        } else {
            if (m_mt.subtype == MEDIASUBTYPE_MPEG1Video) {
                m_pSplitter->m_pParse = new CNativeVideoParse;
            } else {
                if (m_mt.subtype == MEDIASUBTYPE_MPEG1Audio) {
                    m_pSplitter->m_pParse = new CNativeAudioParse;

                    //  Allow for large (64K) ID3 headers when scanning
                    ReadSize = 16 * 1024;
                    BufferSize = 128 * 1024;
                } else {
                    return E_FAIL;
                }
            }
        }
    }


    // simple file reader class for use by GetStreamsAndDuration.
    // we can build one of these on IStream or IAsyncReader
    CReader* pReader = NULL;

    //
    // look for IAsyncReader on the output pin and if found set up for
    // pulling data instead of using IMemInputPin.
    //
    // make an allocator first
    IMemAllocator* pAlloc;
    HRESULT hr = GetAllocator(&pAlloc);
    if (FAILED(hr)) {
        return hr;
    }
    pAlloc->Release();  // Our pin still has a ref count

    // Pull synchrously to avoid reading too much beyond the stop time
    // or seek position
    hr = m_puller.Connect(pPin, pAlloc, TRUE);
    if (S_OK == hr) {
        m_bPulling = TRUE;

        CReaderFromAsync* pR = new CReaderFromAsync;
        if (NULL == pR) {
            m_puller.Disconnect();
            return E_OUTOFMEMORY;
        }
        IAsyncReader* pSource = m_puller.GetReader();

        //  HACKHACK - do a huge read to download the whole of an FTP
        //  file
        ASSERT(pSource != NULL);
        BYTE bData[1];
        LONGLONG llTotal, llAvailable;
        HRESULT hr = pSource->Length(&llTotal, &llAvailable);
        if (FAILED(hr)) {
            pSource->Release();
            return hr;
        }
        if (llTotal == 0) {
            HRESULT hrRead = pSource->SyncRead(0x7FFFFFFFFFF, 1, bData);
            ASSERT(S_OK != hrRead);

            //  Reconnect to set up correct duration
            pSource->Release();
            m_puller.Disconnect();
            hr = m_puller.Connect(pPin, pAlloc, TRUE);
            if (FAILED(hr)) {
                return hr;
            }
            pSource = m_puller.GetReader();
            pSource->Length(&llTotal, &llAvailable);
            if (llTotal == 0) {
                pSource->Release();
                return FAILED(hrRead) ? hrRead : VFW_E_TYPE_NOT_ACCEPTED;
            }
            ASSERT(llTotal >= llAvailable);
        }

        hr = pR->Init(
                pSource,
                BufferSize,
                ReadSize,
                TRUE);
        if (FAILED(hr)) {
            delete pR;
            return hr;
        }
        // if it succeeded, it addrefed the interface

        pReader = pR;
   } else {


        /*  See if output pin supports IStream */
        IStream *pStream;
        hr = pPin->QueryInterface(IID_IStream, (void **)&pStream);

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("Outpin pin doesn't support IStream")));
        } else {

            /*  See if the output pin supports IMediaPosition */
            pPin->QueryInterface(IID_IMediaPosition, (void **)&m_pPosition);

            /*  Read the stream to get the stream data */
            CReaderFromStream* pR = new CReaderFromStream;
            if (pR) {
                hr = pR->Init(
                        pStream,
                        BufferSize,
                        ReadSize,
                        m_pPosition != NULL);
            } else {
                hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                pStream->Release();
                delete pR;
                return hr;
            }
            // if it succeeded it addrefed the stream.
            pReader = pR;
        }
    }

    hr = GetStreamsAndDuration(pReader);

    // releases any addrefed interfaces
    delete pReader;

    return hr;
}

/*
     Do all the basic work to create information from the MPEG data:

     1.  Read the start of the data (or from the current data if
         the stream is not seekable) and pass the data to the parser
         for it to extract format data and a start time for each
         stream

     2.  If the stream is seekable find the end (time)

     3.  For each stream found an output pins


*/
HRESULT CMpeg1Splitter::CInputPin::GetStreamsAndDuration(CReader *pReader)
{
    /*  Basically just process the file until we've got the
        data we need we use a circular buffer object for this (do
        we really need this or can we work to a fixed size?)
    */

    /*  No pins yet */
    ASSERT(m_pSplitter->m_OutputPins.GetCount() == 0);

    /*  Initialize */
    m_bSeekRequested = FALSE;

    /*  Initialize the parser */
    CBasicParse *pParse = m_pSplitter->m_pParse;
    pParse->SetNotify(this);

    LONGLONG llSize, llAvail;
    if (pReader != NULL) {
        llSize = pReader->GetSize(&llAvail);
    }
    pParse->Init(pReader == NULL ? 0 : llSize,
                 pReader == NULL ? FALSE : pReader->IsSeekable(),
                 &m_mt);

    if (pReader != NULL) {
        /*  m_bComplete is set by the completion callback from the parser
        */
        SetState(State_Initializing);
        LONGLONG llPos = 0;

        /*  Find the streams by searching from the start */
        HRESULT hr;
        while (!m_bComplete) {

            hr = pReader->ReadMore();
            if (FAILED(hr)) {
                return hr;
            }

            PBYTE    pbData;
            LONG     lLength;
            pbData = pReader->GetCurrent(lLength, llPos);

            DWORD dwFlags = llSize == llAvail ? 0 : CBasicParse::Flags_SlowMedium;
            if (S_FALSE == hr) {
                dwFlags |= CBasicParse::Flags_EOS;
            }

            LONG lProcessed = pParse->ParseBytes(llPos,
                                                  pbData,
                                                  lLength,
                                                  dwFlags);
            ASSERT(lProcessed <= lLength);
            if (hr == S_FALSE) {
                pParse->EOS();
                break;
            }
            pReader->Advance(lProcessed);
        }

        /*  If we got no streams fail */
        if (pParse->NumberOfStreams() == 0) {
            /*  Not an MPEG file */
            return E_INVALIDARG;
        }


        /*  See if we should find the length */
        if (pParse->IsSeekable() && llSize == llAvail) {

            /*  Set our own state */
            SetState(State_FindEnd);
            pParse->FindEnd();
            if (m_bSeekRequested) {
                m_bSeekRequested = FALSE;
                hr = pReader->Seek(m_llSeekPosition);
                if (FAILED(hr)) {
                    return hr;
                }
            }

            /*  Some parsing doesn't require this extra pass
                (Audio and short video files) in which case it
                will have called complete() inside FindEnd().
            */
            if (!m_bComplete) {

                for (;;) {
                    hr = pReader->ReadMore();
                    if (FAILED(hr)) {
                        return hr;
                    }

                    PBYTE    pbData;
                    LONGLONG llPos;
                    LONG     lLength;
                    pbData = pReader->GetCurrent(lLength, llPos);

                    LONG lProcessed = pParse->ParseBytes(llPos,
                                                         pbData,
                                                         lLength,
                                                         S_FALSE == hr ? CBasicParse::Flags_EOS : 0);
                    ASSERT(lProcessed <= lLength);
                    if (hr == S_FALSE) {
                        pParse->EOS();
                        break;
                    }
                    pReader->Advance(lProcessed);
                }
            }
            REFERENCE_TIME tDuration;
            HRESULT hr = pParse->GetDuration(&tDuration);
            if (FAILED(hr)) {
                return hr;
            }

            DbgLog((LOG_TRACE, 2, TEXT("Duration is %s"),
                   (LPCTSTR)CDisp(tDuration)));
        }
    } else {
        /*  If we got no streams in the media type fail */
        if (pParse->NumberOfStreams() == 0) {
            /*  Not an MPEG file */
            return E_INVALIDARG;
        }
    }

    /*  Now make a pin for each stream
    */

    for (int i = 0; i < pParse->NumberOfStreams(); i++) {

        CBasicStream *pStream;
        pStream = pParse->GetStream(i);

        HRESULT hr = S_OK;
        /*  Create an output pin for this stream */
        COutputPin *pPin = new COutputPin(m_pSplitter,
                                          pStream->m_uStreamId,
                                          pStream,
                                          &hr);
        if (pPin == NULL) {
            return E_OUTOFMEMORY;
        }
        if (FAILED(hr)) {
            delete pPin;
            return hr;
        }

        /* Release() is called when the pin is removed from the list */
        pPin->AddRef();
        POSITION pos = m_pSplitter->m_OutputPins.AddTail(pPin);
        if (pos == NULL) {
            delete pPin;
            return E_OUTOFMEMORY;
        }
    }

    /*  Fix up the allocator for this file */
    ALLOCATOR_PROPERTIES propRequest, propActual;

    /* Make sure we've got an allocator then set our preferred size */
    IMemAllocator *pAlloc;
    EXECUTE_ASSERT(SUCCEEDED(GetAllocator(&pAlloc)));
    pAlloc->Release();
    LONG lBufferSize = m_pSplitter->m_pParse->GetBufferSize();

    propRequest.cbPrefix = 0;
    propRequest.cbAlign = 1;
    propRequest.cBuffers = 4;
    propRequest.cbBuffer = lBufferSize/4;
    EXECUTE_ASSERT(SUCCEEDED(
        m_pAllocator->SetProperties(
            &propRequest,
            &propActual)));

    /*  Put ourselves into 'running' state */
    SetState(State_Run);
    pParse->Run();
    return S_OK;
}

/*  Get available and total byte counts from upstream */
HRESULT CMpeg1Splitter::CInputPin::GetAvailable(
    LONGLONG * pllTotal,
    LONGLONG * pllAvailable )
{
    if (!m_bPulling) {
        return E_FAIL;
    } else {
        IAsyncReader *pReader = m_puller.GetReader();
        HRESULT hr = pReader->Length(pllTotal, pllAvailable);
        pReader->Release();
        return hr;
    }

}

/*  Set up for seeking */
HRESULT CMpeg1Splitter::CInputPin::SetSeek(
             LONGLONG llStart,
             REFERENCE_TIME *prtStart,
             const GUID *pTimeFormat)
{
    BOOL bDoSeek = FALSE;
    REFERENCE_TIME tSeekPosition;
    {
        CAutoLock lck2(&m_pSplitter->m_csPosition);

        /*  Latch the seek time

            This will be used next time we get a discontinuity in the
            input data
        */

        /*  Ask the parser where to seek to */
        m_pSplitter->m_pParse->Seek(llStart, prtStart, pTimeFormat);

        /*  Check if this generated a seek request */
        if (m_bSeekRequested) {
            ASSERT(m_bPulling || (m_pPosition != NULL));
            m_bSeekRequested = FALSE;

            /*  Position is in seconds */
            tSeekPosition = COARefTime((REFTIME)m_llSeekPosition);
            DbgLog((LOG_TRACE, 3, TEXT("Requesting reader to seek to %s"),
                   (LPCTSTR)CDisp(tSeekPosition)));

            bDoSeek = TRUE;
        }
    }
    if (bDoSeek) {
        return DoSeek(COARefTime(tSeekPosition));
    } else {
        return S_OK;
    }
}
/*  Seek the upstream pin */
HRESULT CMpeg1Splitter::CInputPin::DoSeek(REFERENCE_TIME tSeekPosition)
{
    HRESULT hr = S_OK;
    if (m_bPulling) {
        // tell our worker thread the new segment.
        ALLOCATOR_PROPERTIES Actual;
        hr = m_pAllocator->GetProperties(&Actual);
        m_tStart = m_puller.AlignDown(tSeekPosition / UNITS, Actual.cbAlign) * UNITS;
        hr = m_puller.Seek(m_tStart, m_tStop);
    } else {
        // m_tStart will be set by the NewSegment call from the
        // upstream filter when it starts pushing this data
        hr = m_pPosition->put_CurrentPosition(COARefTime(tSeekPosition));
    }

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("Seek failed code 0x%8.8X"), hr));
    }
    return hr;
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\filter.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

/*

    File:  filter.cpp

    Description:

        Code for MPEG-I system stream splitter filter CFilter

*/

#include <streams.h>
#include "driver.h"

//  Setup data

const AMOVIESETUP_MEDIATYPE
sudMpgInputType[4] =
{
    { &MEDIATYPE_Stream, &MEDIASUBTYPE_MPEG1System },
    { &MEDIATYPE_Stream, &MEDIASUBTYPE_MPEG1VideoCD },
    { &MEDIATYPE_Stream, &MEDIASUBTYPE_MPEG1Video },
    { &MEDIATYPE_Stream, &MEDIASUBTYPE_MPEG1Audio }
};

const AMOVIESETUP_MEDIATYPE
sudMpgAudioOutputType[2] =
{
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_MPEG1Packet },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_MPEG1AudioPayload }
};

const AMOVIESETUP_MEDIATYPE
sudMpgVideoOutputType[2] =
{
    { &MEDIATYPE_Video, &MEDIASUBTYPE_MPEG1Packet },
    { &MEDIATYPE_Video, &MEDIASUBTYPE_MPEG1Payload }
};

const AMOVIESETUP_PIN
sudMpgPins[3] =
{
    { L"Input",
      FALSE,                               // bRendered
      FALSE,                               // bOutput
      FALSE,                               // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      NUMELMS(sudMpgInputType),            // Number of media types
      sudMpgInputType
    },
    { L"Audio Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      NUMELMS(sudMpgAudioOutputType),      // Number of media types
      sudMpgAudioOutputType
    },
    { L"Video Output",
      FALSE,                               // bRendered
      TRUE,                                // bOutput
      TRUE,                                // bZero
      FALSE,                               // bMany
      &CLSID_NULL,                         // clsConnectsToFilter
      NULL,                                // ConnectsToPin
      NUMELMS(sudMpgVideoOutputType),      // Number of media types
      sudMpgVideoOutputType
    }
};

const AMOVIESETUP_FILTER
sudMpgsplit =
{
    &CLSID_MPEG1Splitter,
    L"MPEG-I Stream Splitter",
    MERIT_NORMAL,
    NUMELMS(sudMpgPins),                   // 3 pins
    sudMpgPins
};

CMpeg1Splitter::CFilter::CFilter(
     CMpeg1Splitter *pSplitter,
     HRESULT *phr                // OLE failure return code
) :
     CBaseFilter(NAME("CMpeg1Splitter::CFilter"), // Object name
                      pSplitter->GetOwner(),           // Owner
                      &pSplitter->m_csFilter,          // Lock
                      CLSID_MPEG1Splitter),            // clsid
     m_pSplitter(pSplitter)
{
}


CMpeg1Splitter::CFilter::~CFilter()
{
}

int CMpeg1Splitter::CFilter::GetPinCount()
{
    CAutoLock lck(m_pLock);
    return 1 + m_pSplitter->m_OutputPins.GetCount();
}


CBasePin * CMpeg1Splitter::CFilter::GetPin(int n)
{
    CAutoLock lck(m_pLock);
    if (n == 0) {
        return &m_pSplitter->m_InputPin;
    }
    POSITION pos = m_pSplitter->m_OutputPins.GetHeadPosition();
    while (pos) {
        CBasePin *pPin = m_pSplitter->m_OutputPins.GetNext(pos);
        if (--n == 0) {
            return pPin;
        }
    }
    return NULL;
}


//
//  Override Pause() so we can prevent the input pin from starting
//  the puller before we're ready (ie have exited stopped state)
//
//  Starting the puller in Active() caused a hole where the first
//  samples could be rejected becase we seemed to be in 'stopped'
//  state
//
STDMETHODIMP
CMpeg1Splitter::CFilter::Pause()
{
    CAutoLock lockfilter(&m_pSplitter->m_csFilter);
    HRESULT hr = S_OK;
    if (m_State == State_Stopped) {
        // and do the normal inactive processing
        POSITION pos = m_pSplitter->m_OutputPins.GetHeadPosition();
        while (pos) {
            COutputPin *pPin = m_pSplitter->m_OutputPins.GetNext(pos);
            if (pPin->IsConnected()) {
                hr = pPin->COutputPin::Active();
                if (FAILED(hr)) {
                    break;
                }
            }
        }

        if (SUCCEEDED(hr)) {
            CAutoLock lockreceive(&m_pSplitter->m_csReceive);

            m_pSplitter->m_bAtEnd = FALSE;

            //  Activate our input pin only if we're connected
            if (m_pSplitter->m_InputPin.IsConnected()) {
                hr = m_pSplitter->m_InputPin.CInputPin::Active();
            }
            m_State = State_Paused;
        }
        //  Make Stop do something
        m_State = State_Paused;
        if (FAILED(hr)) {
            CFilter::Stop();
        }
    } else {
        m_State = State_Paused;
    }
    return hr;
}

// Return our current state and a return code to say if it's stable
// If we're splitting multiple streams see if one is potentially stuck
// and return VFW_S_CANT_CUE
STDMETHODIMP
CMpeg1Splitter::CFilter::GetState(DWORD dwMSecs, FILTER_STATE *pfs)
{
    CheckPointer( pfs, E_POINTER );
    CAutoLock lck(m_pLock);
    *pfs = m_State;
    if (m_State == State_Paused) {
        return m_pSplitter->CheckState();
    } else {
        return S_OK;
    }
}

// there is a Receive critsec that we need to hold to sync with the input pin,
// but we need to make it inactive before we hold it or we could deadlock.
STDMETHODIMP
CMpeg1Splitter::CFilter::Stop()
{
    // must get this one first.
    CAutoLock lockfilter(&m_pSplitter->m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    if (m_pSplitter->m_InputPin.IsConnected()) {
        // decommit the input pin or we can deadlock
        m_pSplitter->m_InputPin.CInputPin::Inactive();

        // now hold the Receive critsec to prevent further Receive and EOS calls,
        CAutoLock lockReceive(&m_pSplitter->m_csReceive);

        //  When we go active again the file reader is just going to
        //  send us the same old junk again so flush our allocator
        //
        //  Do this once we know the receive thread has been stopped (or
        //  all receives will be rejected before getting to the allocator)
        m_pSplitter->m_InputPin.Allocator()->ResetPosition();


        // and do the normal inactive processing
        POSITION pos = m_pSplitter->m_OutputPins.GetHeadPosition();
        while (pos) {
            COutputPin *pPin = m_pSplitter->m_OutputPins.GetNext(pos);
            if (pPin->IsConnected()) {
                pPin->COutputPin::Inactive();
            }
        }
    }
    m_State = State_Stopped;
    return S_OK;

}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\videocd.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

/*
    videocd.h

    This file defines the externals for interfacing with video CDs
*/

#define VIDEOCD_HEADER_SIZE 0x2C
#define VIDEOCD_SECTOR_SIZE 2352
#define VIDEOCD_DATA_SIZE 2324
typedef struct {
    BYTE Sync[12];
    BYTE Header[4];
    BYTE SubHeader[8];
    BYTE UserData[VIDEOCD_DATA_SIZE];
    BYTE EDC[4];
} VIDEOCD_SECTOR;

//
// Channel numbers (SubHeader[1]):
//
// 01 - Motion pictures
// 02 - Normal resolution still
// 03 - High resolution still
// 00 - Padding
//

#define IS_MPEG_VIDEO_SECTOR(pSector)             \
    (((pSector)->SubHeader[1] >= 0x01 &&          \
      (pSector)->SubHeader[1] <= 0x03 ) &&        \
     ((pSector)->SubHeader[2] & 0x6E) == 0x62 &&  \
     ((pSector)->SubHeader[3] & 0x0F) == 0x0F)
#define IS_MPEG_AUDIO_SECTOR(pSector)             \
    ((pSector)->SubHeader[1] == 0x01 &&           \
     ((pSector)->SubHeader[2] & 0x6E) == 0x64 &&  \
     (pSector)->SubHeader[3] == 0x7F)
#define IS_MPEG_SECTOR(pSector)                   \
     (IS_MPEG_VIDEO_SECTOR(pSector) ||            \
      IS_MPEG_AUDIO_SECTOR(pSector))


#define IS_AUTOPAUSE(pSector)                     \
      (0 != ((pSector)->SubHeader[2] & 0x10))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\inc\seqhdr.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*  Define MPEG-I video sequence header format information
    and processing function
*/
#ifndef _INC_SEQHDR_H
#define _INC_SEQHDR_H
typedef struct {
    LONG           lWidth;             //  Native Width in pixels
    LONG           lHeight;            //  Native Height in pixels
    LONG           lvbv;               //  vbv
    REFERENCE_TIME  tPictureTime;      //  Time per picture in 100ns units
    float          fPictureRate;       //  In frames per second
    LONG           lTimePerFrame;      //  Time per picture in MPEG units
    LONG           dwBitRate;          //  Bits per second
    LONG           lXPelsPerMeter;     //  Pel aspect ratio
    LONG           lYPelsPerMeter;     //  Pel aspect ratio
    DWORD          dwStartTimeCode;    //  First GOP time code (or -1)
    LONG           lActualHeaderLen;   //  Length of valid bytes in raw seq hdr
    BYTE           RawHeader[140];     //  The real sequence header
} SEQHDR_INFO;

/*  Helper */
int inline SequenceHeaderSize(const BYTE *pb)
{
    /*  No quantization matrices ? */
    if ((pb[11] & 0x03) == 0x00) {
        return 12;
    }
    /*  Just non-intra quantization matrix ? */
    if ((pb[11] & 0x03) == 0x01) {
        return 12 + 64;
    }
    /*  Intra found - is there a non-intra ? */
    if (pb[11 + 64] & 0x01) {
        return 12 + 64 + 64;
    } else {
        return 12 + 64;
    }
}

/*  Extract info from video sequence header

    Returns FALSE if the sequence header is invalid
*/

BOOL ParseSequenceHeader(const BYTE *pbData, LONG lData, SEQHDR_INFO *hdrInfo);

/*  Audio stuff too */

BOOL ParseAudioHeader(PBYTE pbData, MPEG1WAVEFORMAT *pFormat, long *pLength = NULL);

/*  Get frame length in bytes based on the header */
DWORD MPEGAudioFrameLength(BYTE *pbData);

/*  Get the time 25-bit code from a group of pictures */
inline DWORD GroupTimeCode(PBYTE pbGOP)
{
    return  ((DWORD)pbGOP[4] << 17) +
            ((DWORD)pbGOP[5] << 9) +
            ((DWORD)pbGOP[6] << 1) +
            (pbGOP[7] >> 7);
}

/*  Is time code 0 ? */
inline BOOL TimeCodeZero(DWORD dwCode)
{
    return 0 == (dwCode & (0xFFEFFF));
}

/*  Seconds in a munched GOP Time Code */
inline DWORD TimeCodeSeconds(DWORD dwCode)
{
    return ((dwCode >> 19) & 0x1F) * 3600 +
           ((dwCode >> 13) & 0x3F) * 60 +
           ((dwCode >> 6) & 0x3F);
}

/*  Minutes in a munched GOP Time Code */
inline DWORD TimeCodeMinutes(DWORD dwCode)
{
    return ((dwCode >> 19) & 0x1F) * 60 +
           ((dwCode >> 13) & 0x3F);
}

/*  Drop frame? in a munched GOP time code */
inline BOOL TimeCodeDrop(DWORD dwCode)
{
    return 0 != (dwCode & (1 << 24));
}

/*  Residual frames in a time code */
inline DWORD TimeCodeFrames(DWORD dwCode)
{
    return dwCode & 0x3F;
}

/*  Compute number of frames between 2 time codes */
DWORD FrameOffset(DWORD dwGOPTimeCode, SEQHDR_INFO const *pInfo);

/*  Find packet data */
LPBYTE
SkipToPacketData(
    LPBYTE pSrc,
    long &LenLeftInPacket
);
/*  Find the first (potential) audio frame in a buffer */
DWORD MPEG1AudioFrameOffset(PBYTE pbData, DWORD dwLen);

//  Extra layer III format support
void ConvertLayer3Format(
    MPEG1WAVEFORMAT const *pFormat,
    MPEGLAYER3WAVEFORMAT *pFormat3
);

/*  Get video format stuff */
#ifdef __MTYPE__  // CMediaType
HRESULT GetVideoMediaType(CMediaType *cmt, BOOL bPayload, const SEQHDR_INFO *pInfo,
                          bool bItem = false);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\mpgsplit.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    File:  mpgsplit.cpp

    Description:

        Code for MPEG-I system stream splitter filter object CMpeg1Splitter

*/

#include <streams.h>
#include "driver.h"


#ifdef FILTER_DLL
/* List of class IDs and creator functions for the class factory. This
   provides the link between the OLE entry point in the DLL and an object
   being created. The class factory will call the static CreateInstance
   function when it is asked to create a CLSID_MPEG1Splitter object */

extern const AMOVIESETUP_FILTER sudMpgsplit;

CFactoryTemplate g_Templates[1] = {
    { L""
    , &CLSID_MPEG1Splitter
    , CMpeg1Splitter::CreateInstance
    , NULL
    , &sudMpgsplit }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif


/* This goes in the factory template table to create new instances */

CUnknown *CMpeg1Splitter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CUnknown *pUnkRet = new CMpeg1Splitter(NAME("Mpeg-I stream splitter"), pUnk, phr);
    return pUnkRet;
}

#pragma warning(disable:4355)

/*  Constructor */

CMpeg1Splitter::CMpeg1Splitter(
    TCHAR    * pName,
    LPUNKNOWN  pUnk,
    HRESULT  * phr) :
    CUnknown(NAME("CMpeg1Splitter object"), pUnk, phr),
    m_Filter(this, phr),
    m_InputPin(this, phr),
    m_OutputPins(NAME("CMpeg1Splitter output pin list")),
    m_pParse(NULL),
    m_bAtEnd(FALSE)
{
}

/*  Destructor */

CMpeg1Splitter::~CMpeg1Splitter()
{
}

/* Override this to say what interfaces we support and where */

STDMETHODIMP
CMpeg1Splitter::NonDelegatingQueryInterface(REFIID riid,void ** ppv)
{

    if (riid == IID_IBaseFilter  ||
        riid == IID_IMediaFilter ||
        riid == IID_IPersist         ) {
        return m_Filter.NonDelegatingQueryInterface(riid,ppv);
    } else {
        /* Do we have this interface? */
        if (riid == IID_IAMStreamSelect) {
            return GetInterface((IAMStreamSelect *)this, ppv);
        } else if (riid == IID_IAMMediaContent) {
            return GetInterface((IAMMediaContent *)this, ppv);
        }
        return CUnknown::NonDelegatingQueryInterface(riid,ppv);
    }
}

/*  Tell the output pins there's more data */
void CMpeg1Splitter::SendOutput()
{
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        COutputPin *pPin = m_OutputPins.GetNext(pos);
        if (pPin->IsConnected()) {
            pPin->SendAnyway();
        }
    }
}

/*  Remove our output pins when our input pin becomes disconnected */
void CMpeg1Splitter::RemoveOutputPins()
{
    for (;;) {
        COutputPin *pPin = m_OutputPins.RemoveHead();
        if (pPin == NULL) {
            return;
        }
        IPin *pPeer = pPin->GetConnected();
        if (pPeer != NULL) {
            pPeer->Disconnect();
            pPin->Disconnect();
        }
        pPin->Release();
    }
    m_Filter.IncrementPinVersion();
}

/*  Send EndOfStream */
void CMpeg1Splitter::EndOfStream()
{
    CAutoLock lck(&m_csReceive);
    ASSERT(m_pParse != NULL);
    m_pParse->EOS();
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        COutputPin *pPin = m_OutputPins.GetNext(pos);
        if (pPin->IsConnected()) {
            DbgLog((LOG_TRACE, 3, TEXT("Calling EOS() for stream 0x%2.2X"),
                    pPin->m_uStreamId));
            pPin->m_pOutputQueue->EOS();
        }
    }
    m_bAtEnd = TRUE;
}

/*  Send BeginFlush() */
HRESULT CMpeg1Splitter::BeginFlush()
{
    CAutoLock lck(&m_csFilter);
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        COutputPin *pPin = m_OutputPins.GetNext(pos);
        if (pPin->IsConnected()) {
            DbgLog((LOG_TRACE, 3, TEXT("Calling BeginFlush() for stream 0x%2.2X"),
                    pPin->m_uStreamId));
            pPin->m_pOutputQueue->BeginFlush();
        }
    }
    return S_OK;
}

/*  Send EndFlush() */
HRESULT CMpeg1Splitter::EndFlush()
{
    CAutoLock lck(&m_csFilter);
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        COutputPin *pPin = m_OutputPins.GetNext(pos);
        if (pPin->IsConnected()) {
            DbgLog((LOG_TRACE, 3, TEXT("Calling EndFlush() for stream 0x%2.2X"),
                    pPin->m_uStreamId));
            pPin->m_pOutputQueue->EndFlush();
        }
    }
    m_bAtEnd = FALSE;
    return S_OK;
}

/* Check if a stream is stuck - filter locked on entry

   Returns S_OK           if no stream is stuck
           VFW_S_CANT_CUE if a stream is stuck

   A stream is stuck if:

         We haven't sent EndOfStream for it (!m_bAtEnd)
     AND We have exhausted our own allocator (IsBlocked())
     AND The output queue has pass all its data downstream and is not
         blocked waiting for the data to be processed (IsIdle())

   A single stream can't get stuck because if all its data has been
   processed the allocator will have free buffers
*/
HRESULT CMpeg1Splitter::CheckState()
{
    if (m_OutputPins.GetCount() <= 1) {
        /*  Can't stick on one pin */
        return S_OK;
    }

    /*  See if a pin is stuck and we've got lots of data outstanding */
    if (!m_bAtEnd && m_InputPin.Allocator()->IsBlocked()) {

        /*  Check to see if any of the streams have completed their
            data
        */
        POSITION pos = m_OutputPins.GetHeadPosition();
        while (pos) {
            COutputQueue *pQueue = m_OutputPins.GetNext(pos)->m_pOutputQueue;
            if (pQueue != NULL && pQueue->IsIdle()) {
                DbgLog((LOG_TRACE, 1, TEXT("Failed Pause!")));
                return VFW_S_CANT_CUE;
            }
        }
    }
    return S_OK;
}

/*  Implement IAMStreamSelect */

//  Returns total count of streams
STDMETHODIMP CMpeg1Splitter::Count(
    /*[out]*/ DWORD *pcStreams)       // Count of logical streams
{
    CAutoLock lck(&m_csFilter);
    *pcStreams = 0;
    if (m_pParse != NULL) {
        for (int i = 0; m_pParse->GetStreamId(i) != 0xFF; i++) {
        }
        *pcStreams = i;
    }
    return S_OK;
}

//  Return info for a given stream - S_FALSE if iIndex out of range
//  The first steam in each group is the default
STDMETHODIMP CMpeg1Splitter::Info(
    /*[in]*/ long iIndex,              // 0-based index
    /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                      // Use DeleteMediaType to free
    /*[out]*/ DWORD *pdwFlags,        // flags - optional
    /*[out]*/ LCID *plcid,            // Language id
    /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
    /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                      // Can return NULL
    /*[out]*/ IUnknown **ppPin,       // Pin if any
    /*[out]*/ IUnknown **ppUnk)       // Stream specific interface
{
    CAutoLock lck(&m_csFilter);
    UCHAR uId = m_pParse->GetStreamId(iIndex);
    if (uId == 0xFF) {
        return S_FALSE;
    }
    /*  Find the stream corresponding to this one that has a pin */
    COutputPin *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        pPin = m_OutputPins.GetNext(pos);
        if (IsVideoStreamId(pPin->m_uStreamId) == IsVideoStreamId(uId)) {
            break;
        }
    }
    if (ppszName) {
        WCHAR wszStreamName[20];
        wsprintfW(wszStreamName, L"Stream(%2.2X)", uId);
        if (S_OK != AMGetWideString(wszStreamName, ppszName)) {
            return E_OUTOFMEMORY;
        }
    }
    /* pPin cannot be NULL because each output pin corresponds to a MPEG stream. */
    ASSERT(pPin != NULL);
    if (pdwFlags) {
        *pdwFlags = uId == pPin->m_Stream->m_uNextStreamId ? AMSTREAMSELECTINFO_ENABLED : 0;
    }
    if (ppUnk) {
        *ppUnk = NULL;
    }
    if (pdwGroup) {
        *pdwGroup = IsVideoStreamId(pPin->m_uStreamId) ? 0 : 1;
    }
    if (ppmt) {
        *ppmt = CreateMediaType(pPin->MediaType());
        if (*ppmt == NULL) {
            if (ppszName) {
                CoTaskMemFree((LPVOID)*ppszName);
            }
            return E_OUTOFMEMORY;
        }
    }
    if (plcid) {
        *plcid = 0;
    }
    if (ppPin) {
        pPin->QueryInterface(IID_IUnknown, (void**)ppPin);
    }
    return S_OK;
}

//  Enable or disable a given stream
STDMETHODIMP CMpeg1Splitter::Enable(
    /*[in]*/  long iIndex,
    /*[in]*/  DWORD dwFlags)
{
    if (!(dwFlags & AMSTREAMSELECTENABLE_ENABLE)) {
        return E_NOTIMPL;
    }

    CAutoLock lck(&m_csFilter);
    /*  Find the pin from the index */
    /*  Find the stream corresponding to this one that has a pin */
    UCHAR uId = m_pParse->GetStreamId(iIndex);
    if (uId == 0xFF) {
        return E_INVALIDARG;
    }
    COutputPin *pPin = NULL;
    POSITION pos = m_OutputPins.GetHeadPosition();
    while (pos) {
        pPin = m_OutputPins.GetNext(pos);
        if (IsVideoStreamId(pPin->m_uStreamId) == IsVideoStreamId(uId)) {
            break;
        }
    }
    /* pPin cannot be NULL because each output pin corresponds to a MPEG stream. */
    ASSERT(pPin != NULL);
    pPin->m_Stream->m_uNextStreamId = uId;
    return S_OK;
}

/*  IAMMediaContent */
STDMETHODIMP CMpeg1Splitter::get_AuthorName(BSTR FAR* strAuthorName)
{
    HRESULT hr = GetContentString(CBasicParse::Author, strAuthorName);
    if (FAILED(hr)) {
        hr = GetContentString(CBasicParse::Artist, strAuthorName);
    }
    return hr;
}
STDMETHODIMP CMpeg1Splitter::get_Title(BSTR FAR* strTitle)
{
    return GetContentString(CBasicParse::Title, strTitle);
}
STDMETHODIMP CMpeg1Splitter::get_Copyright(BSTR FAR* strCopyright)
{
    return GetContentString(CBasicParse::Copyright, strCopyright);
}
STDMETHODIMP CMpeg1Splitter::get_Description(BSTR FAR* strDescription)
{
    return GetContentString(CBasicParse::Description, strDescription);
}

/*  Grab the string from the ID3 frame and make a BSTR */
HRESULT CMpeg1Splitter::GetContentString(CBasicParse::Field dwId, BSTR *str)
{
    if (m_pParse->HasMediaContent()) {
        return m_pParse->GetContentField(dwId, str);
    }  else {
        return E_NOTIMPL;
    }
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\position.cpp ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.

/*

    position.cpp

    Implementation of IMediaSeeking for the file reader source filter

*/

#include <streams.h>
#include "driver.h"

//
//  IMediaSeeking stuff
//
/*  Constructor and Destructor */
CMpeg1Splitter::CImplSeeking::CImplSeeking(CMpeg1Splitter *pSplitter,
                                               COutputPin *pPin,
                                               LPUNKNOWN pUnk,
                                               HRESULT *phr) :
    CUnknown(NAME("CMpeg1Splitter::CImplSeeking"),pUnk),
    m_pSplitter(pSplitter),
    m_pPin(pPin)
{
}

STDMETHODIMP
CMpeg1Splitter::CImplSeeking::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    if (riid == IID_IMediaSeeking && m_pSplitter->m_pParse->IsSeekable()) {
	return GetInterface(static_cast<IMediaSeeking *>(this), ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}
// returns S_OK if mode is supported, S_FALSE otherwise
STDMETHODIMP CMpeg1Splitter::CImplSeeking::IsFormatSupported(const GUID * pFormat)
{
    //  Don't support frame seeking except on the video pin - otherwise
    //  the frame seek info won't get passed through the video decoder
    //  filter by the filter graph

    //
    //  Actually now don't support ANY stuff on anything except video
    //  This works better because video is the larger component of the stream
    //  anyway
    //  However, we need to support TIME_FORMAT_MEDIA_TIME or the graph
    //  code gets confused and starts using IMediaPosition
    if (!m_pPin->IsSeekingPin()) {
        return pFormat == NULL || *pFormat == TIME_FORMAT_MEDIA_TIME ?
            S_OK : S_FALSE;
    }
    //  The parser knows if this time format is supported for this type
    return m_pSplitter->m_pParse->IsFormatSupported(pFormat);
}
STDMETHODIMP CMpeg1Splitter::CImplSeeking::QueryPreferredFormat(GUID *pFormat)
{
    /*  Don't care - they're all just as bad as one another */
    *pFormat = m_pPin->IsSeekingPin()
               ? TIME_FORMAT_MEDIA_TIME
               : TIME_FORMAT_NONE;
    return S_OK;
}

// can only change the mode when stopped
// (returns VFE_E_WRONG_STATE otherwise)
STDMETHODIMP CMpeg1Splitter::CImplSeeking::SetTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pSplitter->m_csFilter);
    if (!m_pSplitter->m_Filter.IsStopped()) {
        return VFW_E_WRONG_STATE;
    }
    if (S_OK != IsFormatSupported(pFormat)) {
        return E_INVALIDARG;
    }


    /*  Translate the format (later we compare pointers, not what they point at!) */
    if (*pFormat == TIME_FORMAT_MEDIA_TIME) {
        pFormat = &TIME_FORMAT_MEDIA_TIME;
    } else
    if (*pFormat == TIME_FORMAT_BYTE) {
        pFormat = &TIME_FORMAT_BYTE;
    } else
    if (*pFormat == TIME_FORMAT_FRAME) {
        pFormat = &TIME_FORMAT_FRAME;
    }

    HRESULT hr = m_pSplitter->m_pParse->SetFormat(pFormat);
    return hr;
}

//
//  Returns the current time format
//
STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetTimeFormat(GUID *pFormat)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    if (m_pPin->IsSeekingPin()) {
        *pFormat = *m_pSplitter->m_pParse->TimeFormat();
    } else {
        *pFormat = TIME_FORMAT_NONE;
    }
    return S_OK;
}

//
//  Returns the current time format
//
STDMETHODIMP CMpeg1Splitter::CImplSeeking::IsUsingTimeFormat(const GUID * pFormat)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    return ( m_pPin->IsSeekingPin() ? *pFormat == *m_pSplitter->m_pParse->TimeFormat() : *pFormat == TIME_FORMAT_NONE )
           ? S_OK
           : S_FALSE;
}

// return current properties
STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetDuration(LONGLONG *pDuration)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    return m_pSplitter->m_pParse->GetDuration(pDuration, m_pSplitter->m_pParse->TimeFormat());
}
STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetStopPosition(LONGLONG *pStop)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    *pStop = m_pSplitter->m_pParse->GetStop();
    return S_OK;
}
//  Return the start position if we get asked for the current position on
//  the basis that we'll only be asked if we haven't sent any position data
//  yet in any samples
STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetCurrentPosition(LONGLONG *pCurrent)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    *pCurrent = m_pSplitter->m_pParse->GetStart();
    return S_OK;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetCapabilities( DWORD * pCapabilities )
{
    *pCapabilities = AM_SEEKING_CanSeekForwards
      | AM_SEEKING_CanSeekBackwards
      | AM_SEEKING_CanSeekAbsolute
      | AM_SEEKING_CanGetStopPos
      | AM_SEEKING_CanGetDuration;
    return NOERROR;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::CheckCapabilities( DWORD * pCapabilities )
{
    DWORD dwCaps;
    HRESULT hr = GetCapabilities( &dwCaps );
    if (SUCCEEDED(hr))
    {
        dwCaps &= *pCapabilities;
        hr =  dwCaps ? ( dwCaps == *pCapabilities ? S_OK : S_FALSE ) : E_FAIL;
        *pCapabilities = dwCaps;
    }
    else *pCapabilities = 0;

    return hr;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                                             LONGLONG    Source, const GUID * pSourceFormat )
{
    return m_pSplitter->m_pParse->ConvertTimeFormat( pTarget, pTargetFormat, Source, pSourceFormat );
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::SetPositions
( LONGLONG * pCurrent, DWORD CurrentFlags
, LONGLONG * pStop, DWORD StopFlags )
{
    LONGLONG Current, Stop ;

    HRESULT hr = S_OK;

    const DWORD PosCurrentBits = CurrentFlags & AM_SEEKING_PositioningBitsMask;
    const DWORD PosStopBits    = StopFlags & AM_SEEKING_PositioningBitsMask;

    if (PosCurrentBits == AM_SEEKING_AbsolutePositioning) {
        Current = *pCurrent;
    } else {
        hr = GetCurrentPosition( &Current );
        if (FAILED(hr)) {
            return hr;
        }
        if (PosCurrentBits == AM_SEEKING_RelativePositioning) Current += *pCurrent;
    }

    if (PosStopBits == AM_SEEKING_AbsolutePositioning) {
        Stop = *pStop;
    } else if (PosStopBits == AM_SEEKING_IncrementalPositioning) {
        Stop = Current + *pStop;
    } else {
        hr = GetStopPosition( &Stop );
        if (FAILED(hr)) {
            return hr;
        }
        if (PosStopBits == AM_SEEKING_RelativePositioning) Stop += *pStop;
    }

    //  Call the input pin to call the parser and do the seek
    {
        CAutoLock lck(&m_pSplitter->m_csPosition);
        if (!m_pPin->IsSeekingPin()) {
            //  We only agreed to format setting on our seeking pin
            return E_UNEXPECTED;
        }
        LONGLONG llDuration;

        //  Check limits
        EXECUTE_ASSERT(SUCCEEDED(m_pSplitter->m_pParse->GetDuration(
            &llDuration, m_pSplitter->m_pParse->TimeFormat())));
        if (PosCurrentBits &&
            (Current < 0 || PosStopBits && Current > Stop)
           ) {
            return E_INVALIDARG;
        }


        if (PosStopBits)
        {
            if (Stop > llDuration) {
                Stop = llDuration;
            }
            m_pSplitter->m_pParse->SetStop(Stop);
        }
    }

    REFERENCE_TIME rt;

    if (PosCurrentBits)
    {
        hr = m_pSplitter->m_InputPin.SetSeek(
                          *pCurrent,
                          &rt,
                          m_pSplitter->m_pParse->TimeFormat());
        if (FAILED(hr)) {
            return hr;
        }
        if (CurrentFlags & AM_SEEKING_ReturnTime)
        {
            *pCurrent = rt;
        }
        if (StopFlags & AM_SEEKING_ReturnTime)
        {
            *pStop = llMulDiv( Stop, rt, Current, 0 );
        }
    }
    return hr;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetPositions( LONGLONG * pCurrent, LONGLONG * pStop )
{
    HRESULT hrResult = S_OK;

    if (pCurrent)
    {
        hrResult = GetCurrentPosition( pCurrent );
        if (FAILED(hrResult)) {
            return hrResult;
        }
    }

    if (pStop)
    {
        hrResult = GetStopPosition( pStop );
    }

    return hrResult;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::SetRate(double dRate)
{
    CAutoLock lck2(&m_pSplitter->m_csPosition);
    if (dRate < 0) {
        return E_INVALIDARG;
    }
    m_pSplitter->m_pParse->SetRate(dRate);
    return S_OK;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetRate(double * pdRate)
{
    CAutoLock lck(&m_pSplitter->m_csPosition);
    *pdRate = m_pSplitter->m_pParse->GetRate();
    return S_OK;
}

STDMETHODIMP CMpeg1Splitter::CImplSeeking::GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest )
{
    HRESULT hr = S_OK;
    if (pEarliest != NULL) {
        *pEarliest = 0;
    }

    if (pLatest != NULL) {
        hr = GetDuration(pLatest);

        /*  If we're being driven with IAsyncReader just get the available byte
            count and extrapolate a guess from that
        */
        if (SUCCEEDED(hr)) {
            LONGLONG llTotal;
            LONGLONG llAvailable;
            HRESULT hr1 = m_pSplitter->m_InputPin.GetAvailable(&llTotal, &llAvailable);
            if (SUCCEEDED(hr1) && llTotal != llAvailable) {
                *pLatest = llMulDiv(llAvailable, *pLatest, llTotal, llTotal / 2);
                hr = VFW_S_ESTIMATED;
            }
        }
    }
    return hr;
}



#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\outpin.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

     Output pin members for CMpeg1Splitter::COutputPin

     The pin is created with the (fixed) media type
*/

#include <streams.h>
#include <stdio.h>            // For swprintf
#include "driver.h"

#pragma warning(disable:4355)

/*  Constructor - we know the media type when we create the pin */

CMpeg1Splitter::COutputPin::COutputPin(
            CMpeg1Splitter * pSplitter,
            UCHAR            StreamId,
            CBasicStream   * pStream,
            HRESULT        * phr) :
    CBaseOutputPin(NAME("CMpeg1Splitter::COutputPin"),   // Object name
                   &pSplitter->m_Filter,                 // Filter
                   &pSplitter->m_csFilter,               // CCritsec *
                   phr,
                   IsAudioStreamId(StreamId) ? L"Audio" : L"Video"),
    m_Seeking(pSplitter, this, GetOwner(), phr),
    m_pOutputQueue(NULL),
    m_pSplitter(pSplitter),
    m_uStreamId(StreamId),
    m_Stream(pStream),
    m_bPayloadOnly(FALSE)
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::COutputPin::COutputPin - stream id 0x%2.2X"),
           StreamId));
}

/*  Destructor */

CMpeg1Splitter::COutputPin::~COutputPin()
{
    DbgLog((LOG_TRACE, 2, TEXT("CMpeg1Splitter::COutputPin::~COutputPin - stream id 0x%2.2X"),
           m_uStreamId));

    /*  We only get deleted when we're disconnected so
        we should be inactive with no thread etc etc
    */
    ASSERT(m_pOutputQueue == NULL);
}

// override say what interfaces we support where
STDMETHODIMP CMpeg1Splitter::COutputPin::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv)
{
    /* See if we have the interface */

    if (riid == IID_IStream) {
        return GetInterface((IStream *)this, ppv);
    } else if (riid == IID_IMediaSeeking) {
        if (m_pSplitter->m_pParse->IsSeekable()) {
            return GetInterface ((IMediaSeeking *)&m_Seeking, ppv);
        }
    }
    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}

/* Override revert to normal ref counting
   These pins cannot be finally Release()'d while the input pin is
   connected */

STDMETHODIMP_(ULONG)
CMpeg1Splitter::COutputPin::NonDelegatingAddRef()
{
    return CUnknown::NonDelegatingAddRef();
}


/* Override to decrement the owning filter's reference count */

STDMETHODIMP_(ULONG)
CMpeg1Splitter::COutputPin::NonDelegatingRelease()
{
    return CUnknown::NonDelegatingRelease();
}




HRESULT CMpeg1Splitter::COutputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    CAutoLock lck(m_pLock);
    if (iPosition < 0)  {
        return E_INVALIDARG;
    }
    return m_Stream->GetMediaType(pMediaType, iPosition);
}

HRESULT CMpeg1Splitter::COutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lck(m_pLock);
    for (int i = 0;; i++) {
        CMediaType mt;
        HRESULT hr = GetMediaType(i, &mt);
        if (FAILED(hr)) {
            return hr;
        }
        if (hr==VFW_S_NO_MORE_ITEMS) {
            break;
        }
        if (*pmt == mt) {
            return S_OK;
        }
    }
    return S_FALSE;
}

HRESULT CMpeg1Splitter::COutputPin::SetMediaType(const CMediaType *mt)
{
    HRESULT hr = CBaseOutputPin::SetMediaType(mt);
    if (S_OK != hr) {
        return hr;
    }

    if (mt->subtype != MEDIASUBTYPE_MPEG1Packet) {
        m_bPayloadOnly = TRUE;
    } else {
        m_bPayloadOnly = FALSE;
    }
    m_Stream->SetMediaType(mt, m_bPayloadOnly);


    return S_OK;
}

HRESULT CMpeg1Splitter::COutputPin::BreakConnect()
{
    CBaseOutputPin::BreakConnect();
    return S_OK;
}

// override this to set the buffer size and count. Return an error
// if the size/count is not to your liking.
HRESULT CMpeg1Splitter::COutputPin::DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES * pProp
    )
{
    pProp->cBuffers = 100;
    pProp->cbBuffer = MAX_MPEG_PACKET_SIZE;            /* Don't care about size */
    pProp->cbAlign = 1;
    pProp->cbPrefix = 0;
    ALLOCATOR_PROPERTIES propActual;
    return pAlloc->SetProperties(pProp, &propActual);
}

//
//  Override DecideAllocator because we insist on our own allocator since
//  it's 0 cost in terms of bytes
//
HRESULT CMpeg1Splitter::COutputPin::DecideAllocator(IMemInputPin *pPin,
                                                    IMemAllocator **ppAlloc)
{
    HRESULT hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {
        ALLOCATOR_PROPERTIES propRequest;
        ZeroMemory(&propRequest, sizeof(propRequest));
        hr = DecideBufferSize(*ppAlloc, &propRequest);
        if (SUCCEEDED(hr)) {
            // tell downstream pins that modification
            // in-place is not permitted
            hr = pPin->NotifyAllocator(*ppAlloc, TRUE);
            if (SUCCEEDED(hr)) {
                return NOERROR;
            }
        }
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
        (*ppAlloc)->Release();
        *ppAlloc = NULL;
    }
    return hr;
}

// override this to control the connection
// We use the subsample allocator derived from the input pin's allocator
HRESULT CMpeg1Splitter::COutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
    ASSERT(m_pAllocator == NULL);
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;
    COutputAllocator *pMemObject = NULL;
    IMemAllocator *pInputAllocator;
    hr = m_pSplitter->m_InputPin.GetAllocator(&pInputAllocator);
    if (FAILED(hr)) {
        return hr;
    }

    pMemObject = new COutputAllocator((CStreamAllocator *)pInputAllocator, &hr);
    pInputAllocator->Release();
    if (pMemObject == NULL) {
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete pMemObject;
        return hr;
    }
    /* Get a reference counted IID_IMemAllocator interface */

    hr = pMemObject->QueryInterface(IID_IMemAllocator,(void **)ppAlloc);
    if (FAILED(hr)) {
        delete pMemObject;
        return hr;
    }
    ASSERT(*ppAlloc != NULL);
    return NOERROR;
}


// Queue a sample to the outside world
//
// This involves allocating the sample from the pin's allocator
// (NOTE - this will ONLY involve queuing on the output pin if
// we're stretching file window too much).
//
HRESULT CMpeg1Splitter::COutputPin::QueuePacket(PBYTE         pPacket,
                                                LONG          lPacket,
                                                REFERENCE_TIME tSample,
                                                BOOL          bTimeValid)
{
    CAutoLock lck(this);
    if (!IsConnected()) {
        return S_OK;
    }
    COutputAllocator *pAllocator = (COutputAllocator *)m_pAllocator;
    IMediaSample *pSample;
    if (m_pOutputQueue == NULL) {
        return E_UNEXPECTED;
    }

    HRESULT hr = pAllocator->GetSample(pPacket, lPacket, &pSample);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("Could not get sample - code 0x%8.8X"),
                hr));
        return hr;
    }

    if (bTimeValid) {
        REFERENCE_TIME tStop = tSample + 1;
        EXECUTE_ASSERT(SUCCEEDED(pSample->SetSyncPoint(bTimeValid)));
        EXECUTE_ASSERT(SUCCEEDED(pSample->SetTime(
                (REFERENCE_TIME*)&tSample,
                (REFERENCE_TIME*)&tStop)));
        DbgLog((LOG_TRACE, 4, TEXT("Sending sample for stream %2.2X time %s"),
                m_uStreamId,
                (LPCTSTR)CDisp(CRefTime(tSample))));
    } else {
        DbgLog((LOG_TRACE, 4,
                TEXT("Sending sample for stream %2.2X - no time"),
                m_uStreamId));
    }
    if (m_Stream->GetDiscontinuity()) {
        EXECUTE_ASSERT(SUCCEEDED(pSample->SetDiscontinuity(TRUE)));
        DbgLog((LOG_TRACE, 2, TEXT("NewSegment(%s, %s, %s)"),
                (LPCTSTR)CDisp(CRefTime(m_pSplitter->m_pParse->GetStartTime())),
                (LPCTSTR)CDisp(CRefTime(m_pSplitter->m_pParse->GetStopTime())),
                (LPCTSTR)CDisp(m_pSplitter->m_pParse->GetRate())
                ));
        m_pOutputQueue->NewSegment(m_pSplitter->m_pParse->GetStartTime(),
                                   m_pSplitter->m_pParse->GetStopTime(),
                                   m_pSplitter->m_pParse->GetRate());
    }
    LONGLONG llPosition;
    if (m_pSplitter->m_pParse->GetMediumPosition(&llPosition)) {
        LONGLONG llStop = llPosition + lPacket;
        pSample->SetMediaTime(&llPosition, &llStop);
    }
    return m_pOutputQueue->Receive(pSample);
}


/*  Active and inactive methods */

/*  Active

    Create the worker thread
*/
HRESULT CMpeg1Splitter::COutputPin::Active()
{
    DbgLog((LOG_TRACE, 2, TEXT("COutputPin::Active()")));
    CAutoLock lck(m_pLock);
    CAutoLock lck1(this);

    /*  If we're not connected we don't participate so it's OK */
    if (!IsConnected()) {
        return S_OK;
    }

    HRESULT hr = CBaseOutputPin::Active();
    if (FAILED(hr)) {
        return hr;
    }

    /*  Create our batch list */
    ASSERT(m_pOutputQueue == NULL);

    hr = S_OK;
    m_pOutputQueue = new COutputQueue(GetConnected(), // input pin
                                      &hr,            // return code
                                      TRUE,           // Auto detect
                                      TRUE,           // ignored
                                      50,             // batch size
                                      TRUE,           // exact batch
                                      50);            // queue size
    if (m_pOutputQueue == NULL) {
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr)) {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }
    return hr;
}

HRESULT CMpeg1Splitter::COutputPin::Inactive()
{
    DbgLog((LOG_TRACE, 2, TEXT("COutputPin::Inactive()")));
    CAutoLock lck(m_pLock);

    /*  If we're not involved just return */
    if (!IsConnected()) {
        return S_OK;
    }

    CAutoLock lck1(this);
    HRESULT hr = CBaseOutputPin::Inactive(); /* Calls Decommit - why? */
    if (FAILED(hr)) {
        /*  Incorrect state transition */
        return hr;
    }

    delete m_pOutputQueue;
    m_pOutputQueue = NULL;
    return S_OK;
}

//  Return TRUE if we're the pin being used for seeking
//  If there's a connected video pin we use that - otherwise we
//  just choose the first in the list
BOOL CMpeg1Splitter::COutputPin::IsSeekingPin()
{
    if (IsVideoStreamId(m_uStreamId)) {
        // We're connected or we wouldn't be here(!)
        ASSERT(IsConnected());
        return TRUE;
    }
    //  See if we're the first pin and there's no
    //  video stream
    POSITION pos = m_pSplitter->m_OutputPins.GetHeadPosition();
    BOOL bGotFirst = FALSE;
    for (;;) {
        COutputPin *pPin;
        pPin = m_pSplitter->m_OutputPins.GetNext(pos);
        if (pPin == NULL) {
            break;
        }

        if (pPin->IsConnected()) {
            if (!bGotFirst) {
                if (this != pPin) {
                    return FALSE;
                }
                bGotFirst = TRUE;
            }

            //  We're not the seeking pin if there's a connected
            //  video pin
            if (IsVideoStreamId(pPin->m_uStreamId)) {
                return FALSE;
            }
        }
    }
    ASSERT(bGotFirst);
    return TRUE;
}
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\parse.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    File:  parse.cpp

    Description:

        Implement the CParseNotify class for the MPEG splitter

*/

#include <streams.h>
#include "driver.h"

void CMpeg1Splitter::CInputPin::ParseError(UCHAR       uStreamId,
                                           LONGLONG    llPosition,
                                           DWORD       Error)
{
    if (m_State != State_Initializing &&
        m_State != State_FindEnd) {
        m_pSplitter->m_Filter.NotifyEvent(EC_STREAM_ERROR_STILLPLAYING,
                                          0,
                                          (LONG)Error);
    }
}

void CMpeg1Splitter::CInputPin::SeekTo(LONGLONG llPosition)
{
    /*  Seek our input pin */

    REFERENCE_TIME tStart;
    tStart = llPosition;
    m_bSeekRequested = TRUE;
    m_llSeekPosition = llPosition;
}

void CMpeg1Splitter::CInputPin::Complete(BOOL          bSuccess,
                                         LONGLONG      llPosFound,
                                         REFERENCE_TIME tFound)
{
    UNREFERENCED_PARAMETER(tFound);
    m_bComplete       = TRUE;
    m_bSuccess        = bSuccess;
    if (m_State == State_Seeking) {
        m_llSeekPosition = llPosFound;
        m_bSeekRequested = TRUE;
    }
}

HRESULT CMpeg1Splitter::CInputPin::QueuePacket(UCHAR uStreamId,
                                               PBYTE pbData,
                                               LONG lSize,
                                               REFERENCE_TIME tStart,
                                               BOOL bSync)
{
    /*  Find the correct output pin and send the packet */
    POSITION pos = m_pSplitter->m_OutputPins.GetHeadPosition();
    while (pos) {
        COutputPin *pPin = m_pSplitter->m_OutputPins.GetNext(pos);
        ASSERT(pPin != NULL);
        if (pPin->m_uStreamId == uStreamId) {
            return pPin->QueuePacket(pbData,
                                     lSize,
                                     tStart,
                                     bSync);
        }
    }
    return S_FALSE;
}

/*  Allow the parser to read some stuff */

HRESULT CMpeg1Splitter::CInputPin::Read(LONGLONG llStart, DWORD dwLen, BYTE *pbData)
{
    if (!m_bPulling) {
        return E_NOTIMPL;
    }
    IAsyncReader* pSource = m_puller.GetReader();

    LONGLONG llTotal, llAvailable;
    HRESULT hr = pSource->Length(&llTotal, &llAvailable);
    if (S_OK == hr) {
        if (llStart < 0) {
            llStart = llTotal + llStart;
        }
        if (llStart >= 0 && llStart + dwLen <= llAvailable) {
            hr = pSource->SyncRead(llStart, dwLen, pbData);
        } else {
            hr = E_FAIL;
        }
    }
    pSource->Release();
    return hr;
}

#ifdef DEBUG
/*  State names */
LPCTSTR StateNames[] = { TEXT("Initializing"),
                         TEXT("Seeking"),
                         TEXT("Run"),
                         TEXT("Finding End"),
                         TEXT("Stopping")
                       };
#endif

/*  Set a new state for notifications */
void CMpeg1Splitter::CInputPin::SetState(Stream_State s)
{
    DbgLog((LOG_TRACE, 2, TEXT("Setting state %s"),
            StateNames[(int)s]));
    m_State = s;
    m_bComplete = FALSE;
};


#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\mpgsplit\mpgsplit.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

    File:  mpgsplit.h

    Description:

        Definitions for MPEG-I system stream splitter filter

*/

extern const AMOVIESETUP_FILTER sudMpgsplit;

class CMpeg1Splitter : public CUnknown,     // We're an object
                       public IAMStreamSelect,
                       public IAMMediaContent //  For ID3
{

public:
    DECLARE_IUNKNOWN

public:
    // global critical section
    CCritSec    m_csFilter;

    // sync stop with receive thread activities eg Receive, EndOfStream...
    // get m_csFilter before this if you need both
    CCritSec    m_csReceive;

    // Lock on setting and getting position values
    //
    CCritSec    m_csPosition;  // Integrity of values set

    /*  Internal classes */

    class CInputPin;
    class COutputPin;

    /*  Filter */

    class CFilter : public CBaseFilter
    {
    private:
         /*  Our owner */
         CMpeg1Splitter * const m_pSplitter;
         friend class CInputPin;

    public:
         /*  Constructor and destructor */
         CFilter(CMpeg1Splitter *pSplitter,
                 HRESULT        *phr);
         ~CFilter();

         /* CBaseFilter */
         int GetPinCount();
         CBasePin *GetPin(int n);

         /* IBaseFilter */

         // override Stop to sync with inputpin correctly
         STDMETHODIMP Stop();

         // override Pause to stop ourselves starting too soon
         STDMETHODIMP Pause();

         // Override GetState to signal Pause failures
         STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

         // Helper
         BOOL IsStopped()
         {
             return m_State == State_Stopped;
         };
    };

    //  Implementation if IMediaSeeking
    class CImplSeeking : public CUnknown, public IMediaSeeking
    {
    private:
        CMpeg1Splitter * const m_pSplitter;
        COutputPin     * const m_pPin;

    public:
        CImplSeeking(CMpeg1Splitter *, COutputPin *, LPUNKNOWN, HRESULT *);
        DECLARE_IUNKNOWN

        //  IMediaSeeking methods
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

        // returns S_OK if mode is supported, S_FALSE otherwise
        STDMETHODIMP IsFormatSupported(const GUID * pFormat);
        STDMETHODIMP QueryPreferredFormat(GUID *pFormat);

        // can only change the mode when stopped
        // (returns VFE_E_WRONG_STATE otherwise)
        STDMETHODIMP SetTimeFormat(const GUID * pFormat);
        STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
        STDMETHODIMP GetTimeFormat(GUID *pFormat);

        // return current properties
        STDMETHODIMP GetDuration(LONGLONG *pDuration);
        STDMETHODIMP GetStopPosition(LONGLONG *pStop);
        STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);

        STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
        STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
        STDMETHODIMP ConvertTimeFormat(LONGLONG * pTarget, const GUID * pTargetFormat,
                                       LONGLONG    Source, const GUID * pSourceFormat );
        STDMETHODIMP SetPositions( LONGLONG * pCurrent, DWORD CurrentFlags
                                 , LONGLONG * pStop, DWORD StopFlags );
        STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
        STDMETHODIMP SetRate(double dRate);
        STDMETHODIMP GetRate(double * pdRate);
        STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
        STDMETHODIMP GetPreroll(LONGLONG *pPreroll) { return E_NOTIMPL; }

    };

    /*  Input pin */
    class CInputPin : public CBaseInputPin,
                      public CParseNotify  // Parse notifications
    {
    private:
        /*  Our owner */
        CMpeg1Splitter * const m_pSplitter;

        /*  IMediaPosition of output pin connected to us */
        IMediaPosition *       m_pPosition;

        /*  Notification stuff */
        Stream_State           m_State;

        /*  Notification data  */
        BOOL                   m_bComplete;  /*  State change complete */
        BOOL                   m_bSuccess;   /*  Succeded or not       */
        BOOL                   m_bSeekRequested;
        LONGLONG               m_llSeekPosition;

    public:
        /*  Constructor and Destructor */
        CInputPin(CMpeg1Splitter *pSplitter,
                  HRESULT *hr);
        ~CInputPin();

        /*  -- IPin - override CBaseInputPin -- */

        HRESULT CompleteConnect(IPin *pPin);

        /*  Start Flushing samples
        */
        STDMETHODIMP BeginFlush();

        /*  End flushing samples - after this we won't send any more
        */
        STDMETHODIMP EndFlush();

        /*  CBasePin */
        HRESULT BreakConnect();
        HRESULT Active();
        HRESULT Inactive();

        /* -- IMemInputPin virtual methods -- */

        /*  Gets called by the output pin when another sample is ready */
        STDMETHODIMP Receive(IMediaSample *pSample);

        /*  End of data */
        STDMETHODIMP EndOfStream();

        /*  Where we're told which allocator we are using */
        STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator);

        /*  Use our own allocator if possible */
        STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);

        /*  Say if we're blocking */
        STDMETHODIMP ReceiveCanBlock();

        /* CBasePin methods */

        /* returns the preferred formats for a pin */
        virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

        /*  Connection establishment */
        HRESULT CheckMediaType(const CMediaType *pmt);

        /*  EndOfStream helper */
        void EndOfStreamInternal();


        /*  Seek from output pin's position stuff */
        HRESULT SetSeek(LONGLONG llStart,
                        REFERENCE_TIME *prtStart,
                        const GUID *pTimeFormat);
        /*  Get the available data from upstream */
        HRESULT GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );

        /*  CParseNotify Methods */

        void ParseError(UCHAR       uStreamId,
                        LONGLONG    llPosition,
                        DWORD       Error);
        void SeekTo(LONGLONG llPosition);
        void Complete(BOOL          bSuccess,
                      LONGLONG      llPosFound,
                      REFERENCE_TIME tFound);
        HRESULT QueuePacket(UCHAR uStreamId,
                            PBYTE pbData,
                            LONG lSize,
                            REFERENCE_TIME tStart,
                            BOOL bSync);

        HRESULT Read(LONGLONG llStart, DWORD dwLen, BYTE *pbData);

        /*  Set notify state */
        void SetState(Stream_State);

        /*  Check if a seek has been requested and issue it to the
            connected output pin if it has been

            We also need to know if the allocator was used or not
            because if it wasn't we want to turn off the data coming
            from the reader
        */
        HRESULT CheckSeek();

        /*  Seek the output pin we're connected to */
        HRESULT DoSeek(REFERENCE_TIME tSeekPosition);

        /*  Return our allocator */
        CStreamAllocator *Allocator() const
        {
            return (CStreamAllocator *)m_pAllocator;
        }

        /*  Report filter from reader */
        void NotifyError(HRESULT hr)
        {
            m_pFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
            EndOfStream();
        };

    private:

        // class to pull data from IAsyncReader if we detect that interface
        // on the output pin
        class CImplPullPin : public CPullPin
        {
            // forward everything to containing pin
            CInputPin* m_pPin;

        public:
            CImplPullPin(CInputPin* pPin)
              : m_pPin(pPin)
            {
            };

            // Override allocator selection to make sure we get our own
            HRESULT DecideAllocator(
        		IMemAllocator* pAlloc,
        		ALLOCATOR_PROPERTIES * pProps)
            {
                HRESULT hr = CPullPin::DecideAllocator(pAlloc, pProps);
                if (SUCCEEDED(hr) && m_pAlloc != pAlloc) {
                    return VFW_E_NO_ALLOCATOR;
                }
                return hr;
            }

	    // forward this to the pin's IMemInputPin::Receive
	    HRESULT Receive(IMediaSample* pSample) {
		return m_pPin->Receive(pSample);
	    };
	
	    // override this to handle end-of-stream
	    HRESULT EndOfStream(void) {
		return m_pPin->EndOfStream();
	    };

            // these errors have already been reported to the filtergraph
            // by the upstream filter so ignore them
            void OnError(HRESULT hr) {
                // ignore VFW_E_WRONG_STATE since this happens normally
                // during stopping and seeking
                if (hr != VFW_E_WRONG_STATE) {
                    m_pPin->NotifyError(hr);
                }
            };

            // flush the pin and all downstream
            HRESULT BeginFlush() {
                return m_pPin->BeginFlush();
            };
            HRESULT EndFlush() {
                return m_pPin->EndFlush();
            };

	};
	CImplPullPin m_puller;

        // true if we are using m_puller to get data rather than
        // IMemInputPin
        BOOL m_bPulling;


        HRESULT GetStreamsAndDuration(CReader* pReader);
        inline HRESULT SendDataToParser(BOOL bEOS);
    };

    //
    //  COutputPin defines the output pins
    //  This contain a list of samples generated by the parser to be
    //  sent to this pin and a thread handle for the sending thread
    //
    class COutputPin : public CBaseOutputPin, public CCritSec
    {
    public:
        // Constructor and Destructor

        COutputPin(
            CMpeg1Splitter * pSplitter,
            UCHAR            StreamId,
            CBasicStream   * pStream,
            HRESULT        * phr);

        ~COutputPin();

        // CUnknown methods

        // override this to say what interfaces we support where
        STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);
        STDMETHODIMP_(ULONG) NonDelegatingRelease();
        STDMETHODIMP_(ULONG) NonDelegatingAddRef();


        // CBasePin methods

        // returns the preferred formats for a pin
        virtual HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

        // check if the pin can support this specific proposed type and format
        virtual HRESULT CheckMediaType(const CMediaType *);

        // set the connection to use this format (previously agreed)
        virtual HRESULT SetMediaType(const CMediaType *);

        // override to call Commit and Decommit
        HRESULT Active();
        HRESULT Inactive();
        HRESULT BreakConnect();

        // CBaseOutputPin methods

        // override this to set the buffer size and count. Return an error
        // if the size/count is not to your liking
        HRESULT DecideBufferSize(
                            IMemAllocator * pAlloc,
                            ALLOCATOR_PROPERTIES * pProp);

        // negotiate the allocator and its buffer size/count
        // calls DecideBufferSize to call SetCountAndSize
        HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

        // override this to control the connection
        HRESULT InitAllocator(IMemAllocator **ppAlloc);

        // Queue a sample to the outside world
        HRESULT QueuePacket(PBYTE         pPacket,
                            LONG          lPacket,
                            REFERENCE_TIME tTimeStamp,
                            BOOL          bTimeValid);

        // Override to handle quality messages
        STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
        {    return E_NOTIMPL;   // We do NOT handle this
        }


        // Short cut to output queue
        void SendAnyway()
        {
            CAutoLock lck(this);
            if (m_pOutputQueue != NULL) {
                m_pOutputQueue->SendAnyway();
            }
        };

        // override DeliverNewSegment to queue with output q
        HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate) {
                m_pOutputQueue->NewSegment(tStart, tStop, dRate);
                return S_OK;
        };

        // Are we the pin being used for seeking
        BOOL IsSeekingPin();

        // Pass out a pointer to our media type
        const AM_MEDIA_TYPE *MediaType() const {
            return &m_mt;
        }
    public:
        UCHAR                  m_uStreamId;    // Stream Id
        BOOL                   m_bPayloadOnly; // Packet or payload type?

    private:
        friend class CMpeg1Splitter;
        CMpeg1Splitter * const m_pSplitter;
        CBasicStream   *       m_Stream;
        COutputQueue   *       m_pOutputQueue;

        /*  Position stuff */
        CImplSeeking           m_Seeking;
    };

    /*  Override CSubAllocator to find out what the size and count
        are.  We use the count to give us a hint about batch sizes.
    */

    class COutputAllocator : public CSubAllocator
    {
    public:
        COutputAllocator(CStreamAllocator * pAllocator,
                         HRESULT          * phr);
        ~COutputAllocator();

        long GetCount();
    };

public:
    /* Constructor and Destructor */

    CMpeg1Splitter(
        TCHAR    * pName,
        LPUNKNOWN  pUnk,
        HRESULT  * phr);

    ~CMpeg1Splitter();

    /* This goes in the factory template table to create new instances */
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    /* Overriden to say what interfaces we support and where */
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* IAMStreamSelect */

    //  Returns total count of streams
    STDMETHODIMP Count(
        /*[out]*/ DWORD *pcStreams);      // Count of logical streams

    //  Return info for a given stream - S_FALSE if iIndex out of range
    //  The first steam in each group is the default
    STDMETHODIMP Info(
        /*[in]*/ long iIndex,              // 0-based index
        /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                          // Use DeleteMediaType to free
        /*[out]*/ DWORD *pdwFlags,        // flags - optional
        /*[out]*/ LCID *plcid,            // Language id - optional
        /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
        /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                          // Can return NULL
        /*[out]*/ IUnknown **ppPin,       // Associated pin - returns NULL - optional
                                          // if no associated pin
        /*[out]*/ IUnknown **ppUnk);      // Stream specific interface

    //  Enable or disable a given stream
    STDMETHODIMP Enable(
        /*[in]*/  long iIndex,
        /*[in]*/  DWORD dwFlags);

    /*  Remove our output pins */
    void RemoveOutputPins();



    /***  IAMMediaContent - cheapo implementation - no IDispatch ***/


    /* IDispatch methods */
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo) {return E_NOTIMPL;}

    STDMETHODIMP GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo ** pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      REFIID riid,
      OLECHAR  ** rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid) { return E_NOTIMPL; }


    STDMETHODIMP Invoke(
                DISPID dispIdMember,
                REFIID riid,
                LCID lcid,
                WORD wFlags,
                DISPPARAMS * pDispParams,
                VARIANT * pVarResult,
                EXCEPINFO * pExcepInfo,
                UINT * puArgErr
            ) { return E_NOTIMPL; }
    

    /*  IAMMediaContent */
    STDMETHODIMP get_AuthorName(BSTR FAR* strAuthorName);
    STDMETHODIMP get_Title(BSTR FAR* strTitle);
    STDMETHODIMP get_Copyright(BSTR FAR* strCopyright);
    STDMETHODIMP get_Description(BSTR FAR* strDescription);

    STDMETHODIMP get_Rating(BSTR FAR* strRating){ return E_NOTIMPL;}
    STDMETHODIMP get_BaseURL(BSTR FAR* strBaseURL){ return E_NOTIMPL;}
    STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL){ return E_NOTIMPL;}
    STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL){ return E_NOTIMPL;}
    STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL){ return E_NOTIMPL;}
    STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL){ return E_NOTIMPL;}
    STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL;}
    STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL;}
    STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL;}

    /*  Helper for ID3 */
    HRESULT GetContentString(CBasicParse::Field dwId, BSTR *str);

private:
    /* Internal stream info stuff */
    BOOL    GotStreams();
    HRESULT SetDuration();
    BOOL    SendInit(UCHAR    uStreamId,
                     PBYTE    pbPacket,
                     LONG     lPacketSize,
                     LONG     lHeaderSize,
                     BOOL     bHasPts,
                     LONGLONG llPts);
    /*  Flush after receive completes */
    void    SendOutput();

    /*  Send EndOfStream downstream */
    void    EndOfStream();

    /*  Send BeginFlush() downstream */
    HRESULT BeginFlush();

    /*  Send EndFlush() downstream */
    HRESULT EndFlush();

    /*  Check state against streams and fail if one looks stuck
        Returns S_OK           if not stuck
                VFW_S_CANT_CUE if any stream is stuck
    */
    HRESULT CheckState();

private:
    /*  Allow our internal classes to see our private data */
    friend class CFilter;
    friend class COutputPin;
    friend class CInputPin;
    friend class CImplSeeking;

    /*  Members - simple really -
            filter
            input pin,
            output pin list
            parser
    */
    CFilter                  m_Filter;
    CInputPin                m_InputPin;
    CGenericList<COutputPin> m_OutputPins;

    /*  Parser */
    CBasicParse            * m_pParse;

    /*  At end of data so EndOfStream sent for all pins */
    BOOL                     m_bAtEnd;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\audio.h ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.


/*  Audio stream parsing */
class CAudioParse : public CStream
{
public:
    CAudioParse(CStreamList *pList, UCHAR uStreamId) :
        CStream(pList, uStreamId),
        m_nBytes(0)
    {
    };
    HRESULT GetMediaType(CMediaType *cmt, BOOL bPayload);
    HRESULT ProcessType(AM_MEDIA_TYPE const *pmt);

    BOOL ParseBytes(PBYTE pData,
                            LONG lLen,
                            LONGLONG llPos,
                            BOOL bHasPts,
                            CSTC stc);

    /*  Find out the 'current' time */
    CSTC GetStreamTime(BOOL bHasPts, CSTC stc);

    /*  Override SetState */
    void SetState(Stream_State);

private:
    /*  Check if transition is complete */
    void CheckComplete(BOOL bForce);

    /*  Check an audio header */
    BOOL ParseHeader();

    void Discontinuity()
    {
        m_nBytes = 0;
        m_bDiscontinuity = TRUE;
    };

    void Init();
    BOOL CurrentTime(CSTC& stc);


private:
    int   m_nBytes;

    BYTE  m_bData[4];
    BYTE  m_bHeader[4];

    /*  Timing stuff */
    BOOL  m_bFrameHasPTS;
    BOOL  m_bGotTime;
    CSTC  m_stcFrame;
    CSTC  m_stcAudio;
    CSTC  m_stcFirst;
    LONG  m_lTimePerFrame;

    /*  current position */
    LONGLONG m_llPos;
};

/*  Do basic checks on a audio header - note this doesn't check the
    sync word
*/

BOOL CheckAudioHeader(PBYTE pbData);

/*  Compute the sample rate for audio */
LONG SampleRate(PBYTE pbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\audio.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

/*

     audio.cpp

     Audio stream parsing code for the MPEG-I system stream splitter
*/
#include <streams.h>
#include <mmreg.h>

#include <mpegdef.h>           // General MPEG definitions
#include <mpgtime.h>
#include <mpegprse.h>          // Parsing
#include <seqhdr.h>
#include "audio.h"

/*  Bit rate tables */
const WORD BitRates[3][16] =
{{  0, 32,  64,  96,  128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 0 },
 {  0, 32,  48,  56,   64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 384, 0 },
 {  0, 32,  40,  48,   56,  64,  80,  96, 112, 128, 160, 192, 224, 256, 320, 0 }
};
const WORD LowBitRates[3][16] =
{{  0, 32,  48,  56,   64,  80,  96, 112, 128, 144, 160, 176, 192, 224, 256, 0 },
 {  0,  8,  16,  24,   32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160, 0 },
 {  0,  8,  16,  24,   32,  40,  48,  56,  64,  80,  96, 112, 128, 144, 160, 0 }
};

void CAudioParse::Init()
{
    m_nBytes       = 0;
    m_bGotTime     = FALSE;
    m_llPos        = 0;
    m_bFrameHasPTS = FALSE;
    m_bRunning     = FALSE;
}

/*  Where are we up to? */
BOOL CAudioParse::CurrentTime(CSTC& stc)
{
    if (!m_bGotTime) {
        return FALSE;
    }
    stc = m_stcAudio;
    return TRUE;
}

/*  Get length of a frame (on frame by frame basis) - returns 0 for variable */
DWORD MPEGAudioFrameLength(BYTE *pbData)
{
    if (!CheckAudioHeader(pbData)) {
        return 0;
    }
    DWORD dwHeadBitrate;
    int Layer = 2;

    /*  Get the layer so we can work out the bit rate */
    switch ((pbData[1] >> 1) & 3) {
        case 3:
            Layer = 1;
            break;
        case 2:
            Layer = 2;
            break;
        case 1:
            Layer = 3;
            break;
        case 0:
            DbgBreak("Invalid layer");
    }

    /*  Low bitrates if id bit is not set */
    if (pbData[1] & 8) {
        dwHeadBitrate =
            (DWORD)BitRates[Layer - 1][pbData[2] >> 4] * 1000;
    } else {
        dwHeadBitrate =
            (DWORD)LowBitRates[Layer - 1][pbData[2] >> 4] * 1000;

        /*  Bitrate is really half for FHG stuff */
        //if (0 == (pbData[1] & 0x10)) {
        //    dwHeadBitrate /= 2;
        //}
    }

    /*  free form bitrate not supported */
    if (dwHeadBitrate == 0) {
        return 0;
    }

    DWORD nSamplesPerSec = SampleRate(pbData);

    DWORD dwFrameLength;

    if (1 == Layer) {
        /*  Layer 1 */
        dwFrameLength = (4 * ((dwHeadBitrate * 12) / nSamplesPerSec));
        /*  Do padding */
        if (pbData[2] & 0x02) {
            dwFrameLength += 4;
        }
    } else {
        /*  For MPEG-2 layer 3 only 576 samples per frame
            according to Martin Seiler - can't find it in the spec */
        DWORD dwMultiplier = (Layer == 3 && 0 == (pbData[1] & 0x08) ? 72 : 144);
        dwFrameLength = ((dwMultiplier * dwHeadBitrate) / nSamplesPerSec);
        /*  Do padding */
        if (pbData[2] & 0x02) {
            dwFrameLength += 1;
        }
    }

    return dwFrameLength;
}

BOOL CheckAudioHeader(PBYTE pbData)
{
    if (pbData[0] != 0xFF ||
        ((pbData[1] & 0xE0) != 0xE0) ||

        //  Check for MPEG2.5 and Id bit or not layer 3
        (0 == (pbData[1] & 0x10) && (0 != ((pbData[1] & 0x08)) ||
                                     (pbData[1] >> 1) & 3) != 0x01)) {
        return FALSE;
    }

    /*  Just check it's valid */
    if ((pbData[2] & 0x0C) == 0x0C) {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid audio sampling frequency")));
        return FALSE;
    }
    if ((pbData[1] & 0x08) != 0x08) {
        DbgLog((LOG_TRACE, 3, TEXT("ID bit = 0")));
    }
    if (((pbData[1] >> 1) & 3) == 0x00) {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid audio Layer")));
        return FALSE;
    }

    if (((pbData[2] >> 2) & 3) == 3) {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid sample rate")));
        return FALSE;
    }
    if ((pbData[2] >> 4) == 0x0F) {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid bit rate")));
        return FALSE;
    }

    return TRUE;
}

LONG SampleRate(PBYTE pbData)
{
    LONG lRate;
    switch ((pbData[2] >> 2) & 3) {
        case 0:
            lRate = 44100;
            break;

        case 1:
            lRate = 48000;
            break;

        case 2:
            lRate = 32000;
            break;

        default:
            DbgBreak("Unexpected Sample Rate");
            lRate = 44100;
            break;
    }

    //  Support low bit rates for MPEG-2 and FHG extension (they call
    //  it MPEG2.5).
    if (0 == (pbData[1] & 0x08)) {
        lRate /= 2;
        if (0 == (pbData[1] & 0x10)) {
            lRate /= 2;
        }
    }
    return lRate;
}

DWORD AudioFrameSize(int Layer, DWORD dwHeadBitrate, DWORD nSamplesPerSec,
                     BOOL bMPEG1)
{
    DWORD dwFrameSize;
    if (Layer == 1) {
        dwFrameSize = (4 * (dwHeadBitrate * 12) / nSamplesPerSec);
    } else {
        DWORD dwMultiplier = (Layer == 3 && !bMPEG1 ? 72 : 144);
        dwFrameSize = ((dwMultiplier * dwHeadBitrate) / nSamplesPerSec);
    }
    return dwFrameSize;
}

BOOL ParseAudioHeader(PBYTE pbData, MPEG1WAVEFORMAT *pFormat, long *pLength)
{
    if (!CheckAudioHeader(pbData)) {
        return FALSE;
    }
    pFormat->wfx.wFormatTag = WAVE_FORMAT_MPEG;

    /*  Get number of channels from Mode */
    switch (pbData[3] >> 6) {
    case 0x00:
        pFormat->fwHeadMode = ACM_MPEG_STEREO;
        break;
    case 0x01:
        pFormat->fwHeadMode = ACM_MPEG_JOINTSTEREO;
        break;
    case 0x02:
        pFormat->fwHeadMode = ACM_MPEG_DUALCHANNEL;
        break;
    case 0x03:
        pFormat->fwHeadMode = ACM_MPEG_SINGLECHANNEL;
        break;
    }
    pFormat->wfx.nChannels =
        (WORD)(pFormat->fwHeadMode == ACM_MPEG_SINGLECHANNEL ? 1 : 2);
    pFormat->fwHeadModeExt = (WORD)(1 << (pbData[3] >> 4));
    pFormat->wHeadEmphasis = (WORD)((pbData[3] & 0x03) + 1);
    pFormat->fwHeadFlags   = (WORD)(((pbData[2] & 1) ? ACM_MPEG_PRIVATEBIT : 0) +
                           ((pbData[3] & 8) ? ACM_MPEG_COPYRIGHT : 0) +
                           ((pbData[3] & 4) ? ACM_MPEG_ORIGINALHOME : 0) +
                           ((pbData[1] & 1) ? ACM_MPEG_PROTECTIONBIT : 0) +
                           ((pbData[1] & 0x08) ? ACM_MPEG_ID_MPEG1 : 0));

    int Layer;

    /*  Get the layer so we can work out the bit rate */
    switch ((pbData[1] >> 1) & 3) {
        case 3:
            pFormat->fwHeadLayer = ACM_MPEG_LAYER1;
            Layer = 1;
            break;
        case 2:
            pFormat->fwHeadLayer = ACM_MPEG_LAYER2;
            Layer = 2;
            break;
        case 1:
            pFormat->fwHeadLayer = ACM_MPEG_LAYER3;
            Layer = 3;
            break;
        case 0:
            return (FALSE);
    }

    /*  Get samples per second from sampling frequency */
    pFormat->wfx.nSamplesPerSec = SampleRate(pbData);

    /*  Low bitrates if id bit is not set */
    if (pbData[1] & 8) {
        pFormat->dwHeadBitrate =
            (DWORD)BitRates[Layer - 1][pbData[2] >> 4] * 1000;
    } else {
        pFormat->dwHeadBitrate =
            (DWORD)LowBitRates[Layer - 1][pbData[2] >> 4] * 1000;

        /*  Bitrate is really half for FHG stuff */
        //if (0 == (pbData[1] & 0x10)) {
        //    pFormat->dwHeadBitrate /= 2;
        //}
    }
    pFormat->wfx.nAvgBytesPerSec = pFormat->dwHeadBitrate / 8;

    //  We don't handle variable bit rate (index 0)

    DWORD dwFrameSize = AudioFrameSize(Layer,
                                       pFormat->dwHeadBitrate,
                                       pFormat->wfx.nSamplesPerSec,
                                       0 != (pbData[1] & 0x08));

    if (pFormat->wfx.nSamplesPerSec != 44100 &&
        /*  Layer 3 can sometimes switch bitrates */
        !(Layer == 3 && /* !m_pStreamList->AudioLock() && */
            (pbData[2] >> 4) == 0)) {
        pFormat->wfx.nBlockAlign = (WORD)dwFrameSize;
    } else {
        pFormat->wfx.nBlockAlign = 1;
    }

    if (pLength) {
        *pLength = (long)dwFrameSize;
    }

    pFormat->wfx.wBitsPerSample = 0;
    pFormat->wfx.cbSize = sizeof(MPEG1WAVEFORMAT) - sizeof(WAVEFORMATEX);

    pFormat->dwPTSLow  = 0;
    pFormat->dwPTSHigh = 0;

    return TRUE;
}

BOOL CAudioParse::ParseHeader()
{

    if (!CheckAudioHeader(m_bData)) {
        return FALSE;
    }

    if (m_bFrameHasPTS) {
        DbgLog((LOG_TRACE, 3, TEXT("Audio frame at PTS %s"), (LPCTSTR)CDisp(m_stcFrame)));
        /*  See what this does for our state */
        if (!m_bGotTime) {
            if ((m_bData[1] >> 1) & 3) {
                /*  Not layer 1 */
                m_lTimePerFrame = 1152 * MPEG_TIME_DIVISOR / SampleRate(m_bData);
            } else {
                m_lTimePerFrame = 384 * MPEG_TIME_DIVISOR / SampleRate(m_bData);
            }
            m_bGotTime  = TRUE;
            m_stcFirst = m_stcFrame;
        }
        m_stcAudio = m_stcFrame;

        m_bFrameHasPTS = FALSE;
    } else {
        if (m_bGotTime) {
            m_stcAudio = m_stcAudio + m_lTimePerFrame;
        }
    }

    if (!m_bValid) {
        m_bValid = TRUE;
        CopyMemory((PVOID)m_bHeader, (PVOID)m_bData, sizeof(m_bData));
    }

    /*  See what our state transition should/might be */
    CheckComplete(FALSE);

    return m_bComplete;
}

/*  Override SetState so we can play nothing after seeks */
void CAudioParse::SetState(Stream_State state)
{
    CStream::SetState(state);
    if (state == State_Run && m_pStreamList->GetPlayLength() == 0) {
        m_bReachedEnd = TRUE;
        Complete(TRUE, 0, m_pStreamList->GetStart());
    }
}

/*  Get the media type from the audio stream - this will be a
    MPEG1WAVEFORMAT structure

    See MSDN for a description of MPEG1WAVEFORMAT
*/
HRESULT CAudioParse::GetMediaType(CMediaType *cmt, int iPosition)
{
    /*  NOTE - this stuff is only really valid if the system_audio_lock
        flag is set
    */

    if (iPosition > 5) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if (!m_bValid) {
        DbgLog((LOG_ERROR, 1, TEXT("Asking for format on invalid stream")));
        return E_UNEXPECTED;
    }
    MPEG1WAVEFORMAT Format;
    if (!ParseAudioHeader(m_bHeader, &Format)) {
        return E_INVALIDARG;
    }

    //LARGE_INTEGER Pts;

    /*  Audio PTS is starting PTS of this audio stream */
    //Pts.QuadPart     = m_stcStart;
    //Format.dwPTSLow  = Pts.LowPart;
    //Format.dwPTSHigh = (DWORD)Pts.HighPart;
    Format.dwPTSLow = 0;
    Format.dwPTSHigh = 0;

    WAVEFORMATEX *pFormat;
    MPEGLAYER3WAVEFORMAT wfx;
    if (iPosition / 3) {
        if (Format.fwHeadLayer != ACM_MPEG_LAYER3) {
            return VFW_S_NO_MORE_ITEMS;
        }
        ConvertLayer3Format(&Format, &wfx);
        pFormat = &wfx.wfx;
    } else {
        pFormat = &Format.wfx;
    }
    if (S_OK != CreateAudioMediaType(pFormat, cmt, TRUE)) {
        return E_OUTOFMEMORY;
    }
    iPosition = iPosition % 3;
    if (iPosition == 1) {
        cmt->subtype = MEDIASUBTYPE_MPEG1Payload;
    } else if (iPosition == 2) {
        cmt->subtype = MEDIASUBTYPE_MPEG1Packet;
    }

    return S_OK;
}

/*  Turn a media type back into our own data (!) */
HRESULT CAudioParse::ProcessType(AM_MEDIA_TYPE const *pmt)
{
    if (pmt->formattype != FORMAT_WaveFormatEx ||
        pmt->cbFormat != sizeof(MPEG1WAVEFORMAT)) {
        return E_INVALIDARG;
    }
    MPEG1WAVEFORMAT const *pwfx = (MPEG1WAVEFORMAT *)pmt->pbFormat;
    if (pwfx->wfx.wFormatTag != WAVE_FORMAT_MPEG ||
        0 == (ACM_MPEG_ID_MPEG1 & pwfx->fwHeadFlags)) {
    }

    m_bData[0] = (BYTE)0xFF;
    m_bData[1] = (BYTE)0xF8;
    int iLayer;
    switch (pwfx->fwHeadLayer) {
    case ACM_MPEG_LAYER1:
        m_bData[1] |= (BYTE)0x06;
        iLayer = 1;
        break;
    case ACM_MPEG_LAYER2:
        m_bData[1] |= (BYTE)0x04;
        iLayer = 2;
        break;
    case ACM_MPEG_LAYER3:
        m_bData[1] |= (BYTE)0x02;
        iLayer = 3;
        break;
    default:
        return E_INVALIDARG;
    }

    if (pwfx->fwHeadFlags & ACM_MPEG_PROTECTIONBIT) {
        m_bData[1] |= (BYTE)1;
    }

    if (pwfx->fwHeadFlags & ACM_MPEG_PRIVATEBIT) {
        m_bData[2] = (BYTE)0x01;
    } else {
        m_bData[2] = (BYTE)0x00;
    }
    switch (pwfx->wfx.nSamplesPerSec) {
    case 44100:
        break;
    case 48000:
        m_bData[2] |= (BYTE)0x04;  // 1 << 2
        break;
    case 32000:
        m_bData[2] |= (BYTE)0x08;  // 2 << 2
        break;
    default:
        return E_INVALIDARG;
    }

    switch (pwfx->fwHeadMode) {
    case ACM_MPEG_STEREO:
        m_bData[3] = (BYTE)0x00;
        break;
    case ACM_MPEG_JOINTSTEREO:
        m_bData[3] = (BYTE)0x40;
        break;
    case ACM_MPEG_DUALCHANNEL:
        m_bData[3] = (BYTE)0x80;
        break;
    case ACM_MPEG_SINGLECHANNEL:
        m_bData[3] = (BYTE)0xC0;
        break;
    default:
        return E_INVALIDARG;
    }

    switch (pwfx->fwHeadModeExt) {
    case 1:
        //m_bData[3] |= (BYTE)0;
        break;
    case 2:
        m_bData[3] |= (0x01 << 4);
        break;
    case 4:
        m_bData[3] |= (0x02 << 4);
        break;
    case 8:
        m_bData[3] |= (0x03 << 4);
        break;
    default:
        return E_INVALIDARG;
    }

    if (pwfx->fwHeadFlags & ACM_MPEG_COPYRIGHT) {
        m_bData[3] |= (BYTE)0x08;
    }
    if (pwfx->fwHeadFlags & ACM_MPEG_ORIGINALHOME) {
        m_bData[3] |= (BYTE)0x04;
    }
    if (pwfx->wHeadEmphasis > 4 || pwfx->wHeadEmphasis == 0) {
        return E_INVALIDARG;
    }
    m_bData[3] |= (BYTE)(pwfx->wHeadEmphasis - 1);

    //
    //  Set up the start time
    //
    LARGE_INTEGER liPTS;
    liPTS.LowPart = pwfx->dwPTSLow;
    liPTS.HighPart = (LONG)pwfx->dwPTSHigh;
    m_stcStart = liPTS.QuadPart;

    //  Finally try and find the bit rate
    DWORD dwBitRate = pwfx->dwHeadBitrate / 1000;
    for (int i = 0; i < 16; i++) {
        if (BitRates[iLayer - 1][i] == dwBitRate) {
            m_bData[2] |= (BYTE)(i << 4);
            ParseHeader();
            ASSERT(m_bValid);
            return S_OK;
        }
    }
    return E_INVALIDARG;
}

/*
    Check if we've completed a state change

    bForce is set at end of stream
*/
void CAudioParse::CheckComplete(BOOL bForce)
{
    ASSERT(!m_bComplete);

    /*  Have we completed a state change ? */
    CSTC stcCurrent;
    BOOL bGotTime = CurrentTime(stcCurrent);
    CSTC stcStart;

    if (bGotTime || bForce) {
        switch (m_State) {
        case State_Run:
        {
            BOOL bCompleted = FALSE;
            if (bGotTime && (stcCurrent > m_pStreamList->GetStart())) {
                // Position should really be the end of packet in this case
                if (!m_bStopping) {
                    m_bRunning = TRUE;
                    m_pStreamList->CheckStop();
                }
                if (m_bStopping) {
                    if (stcCurrent >= m_pStreamList->GetStop()) {
                        m_bReachedEnd = TRUE;
                        Complete(TRUE, m_llPos, m_pStreamList->GetStop());
                        bCompleted = TRUE;
                    }
                }
            }
            if (bForce && !bCompleted) {
                Complete(FALSE, m_llPos, 0);
            }
            break;

        }
        case State_Initializing:
            if (m_bValid && m_bGotTime) {
                /*
                    The start file position is ASSUMED to be 0 (!)
                */
                Complete(TRUE, 0, m_stcFirst);
            } else {
                if (bForce) {
                    Complete(FALSE, 0, stcCurrent);
                }
            }
            break;

        case State_Seeking:

            stcStart = m_pStreamList->GetStart();
            if (bGotTime && (stcCurrent > stcStart)) {
                /*  If we've got a clock ref by now then
                    we're all set - choose the max start position to
                    get both to start playing from
                    Otherwise we've messed up!
                */
                DbgLog((LOG_TRACE, 2, TEXT("Audio Seek complete position %s - target was %s, first PTS was %s, current is %s"),
                       (LPCTSTR)CDisp(m_llPos),
                       (LPCTSTR)CDisp(m_pStreamList->GetStart()),
                       (LPCTSTR)CDisp(m_stcFirst),
                       (LPCTSTR)CDisp(stcCurrent)));

                /*  OK provided we can play a frame close to the
                    start time
                */
                Complete((LONGLONG)(stcCurrent - stcStart) <= (LONGLONG)m_lTimePerFrame,
                         m_llPos,
                         stcCurrent);
            } else {
                /*  Don't care if we got nothing (not like video) */
                if (bForce) {
                    Complete(TRUE, m_llPos, m_pStreamList->GetStop());
                }
            }
            break;

        case State_FindEnd:
            /*  Only finish when we're forced ! */
            if (bForce) {
                // NOTE: Position is not a useful value here
                /*  We have to ASSUME the last frame was complete */
                Complete(bGotTime,
                         m_llPos,
                         bGotTime ? stcCurrent + m_lTimePerFrame :
                                    CSTC(0));
            }
            break;

        default:
            DbgBreak("Unexpected State");
            break;
        }
    }
    /*  bForce ==> complete */
    ASSERT(m_bComplete || !bForce);
}


/*  New set of bytes passed to the audio stream
*/
BOOL CAudioParse::ParseBytes(PBYTE pData,
                             LONG lData,
                             LONGLONG llPos,
                             BOOL bHasPts,
                             CSTC stc)
{
    /*  If we're not valid find some valid data first -
        in either case we need a start code
    */
    if (m_bComplete || m_bRunning) {
        return FALSE;
    }

    while (lData > 0) {
        PBYTE pDataNew;

        switch (m_nBytes) {
        case 0:
            /*  Look for a sync code */
            pDataNew = (PBYTE)memchrInternal((PVOID)pData, 0xFF, lData);
            if (pDataNew == NULL) {
                return FALSE;
            }
            lData -= (LONG)(pDataNew - pData) + 1;
            pData = pDataNew + 1;
            m_nBytes = 1;
            m_bData[0] = 0xFF;
            m_bFrameHasPTS = bHasPts;
            m_stcFrame  = stc;
            m_llPos = llPos;
            break;

        case 1:
            if ((pData[0] & 0xF0) == 0xF0) {
                m_nBytes = 2;
                m_bData[1] = pData[0];
            } else {
                m_nBytes = 0;
            }
            pData++;
            lData--;
            break;

        case 2:
            m_bData[2] = pData[0];
            pData++;
            lData--;
            m_nBytes = 3;
            break;

        case 3:
            m_bData[3] = pData[0];
            pData++;
            lData--;
            m_nBytes = 0;
            bHasPts = FALSE;
            if (ParseHeader()) {
                return TRUE;
            }
            break;

        default:
            DbgBreak("Unexpected byte count");
            break;
        }
    }
    return FALSE;
}
//  Bogus extra layer III format support
void ConvertLayer3Format(
    MPEG1WAVEFORMAT const *pFormat,
    MPEGLAYER3WAVEFORMAT *pFormat3
)
{
    pFormat3->wfx.wFormatTag        = WAVE_FORMAT_MPEGLAYER3;
    pFormat3->wfx.nChannels         = pFormat->wfx.nChannels;
    pFormat3->wfx.nSamplesPerSec    = pFormat->wfx.nSamplesPerSec;
    pFormat3->wfx.nAvgBytesPerSec   = pFormat->wfx.nAvgBytesPerSec;
    pFormat3->wfx.nBlockAlign       = 1;
    pFormat3->wfx.wBitsPerSample    = 0;
    pFormat3->wfx.cbSize            = MPEGLAYER3_WFX_EXTRA_BYTES;
    pFormat3->wID                   = MPEGLAYER3_ID_MPEG;
    pFormat3->fdwFlags              = MPEGLAYER3_FLAG_PADDING_ISO;
    pFormat3->nBlockSize            = pFormat->wfx.nBlockAlign;
    pFormat3->nFramesPerBlock       = 1;
    pFormat3->nCodecDelay           = 0;
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\mpegprse.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
    Parse the MPEG-I stream and send out samples as we go

    This parser is a bit weird because it is called rather than calls.
    The result is that we have to be very careful about what we do
    when we get to the 'end'- ie we haven't got enough bytes to make sense
    of the structure we're trying to parse (eg we can't see a whole system
    header or packet).

    Basically there are 2 cases:

    1.  End of data, not EOS - OK - try again later
    2.  End of data, EOS     - Error, invalid data

    The basic call is to ParseBytes which returns the number of bytes
    processed.

    When ParseBytes thinks it hasn't got enough bytes to complete
    the current structure it returns the number of bytes it has
    successfully parsed - a number less than the number of bytes
    it was passed.  This does not mean there is an error unless
    ParseBytes was called with the last bytes of a stream when it is up to
    the caller of ParseBytes to detect this.
*/

#include <streams.h>
#include <mmreg.h>
#include <mpegtype.h>          // Packed type format

#include <mpegdef.h>           // General MPEG definitions
#include <parseerr.h>          // Error codes

#include <mpgtime.h>
#include <mpegprse.h>          // Parsing
#include <videocd.h>           // Video CD special parsing
#include <seqhdr.h>
#include "video.h"
#include "audio.h"

const GUID * CBasicParse::ConvertToLocalFormatPointer( const GUID * pFormat )
{
    ASSERT(this);
    /*  Translate the format (later we compare pointers, not what they point at!) */
    if (pFormat == 0) {
        pFormat = TimeFormat();
    } else
    if (*pFormat == TIME_FORMAT_BYTE) {
        pFormat = &TIME_FORMAT_BYTE;
    } else
    if (*pFormat == TIME_FORMAT_FRAME) {
        pFormat = &TIME_FORMAT_FRAME;
    } else
    if (*pFormat == TIME_FORMAT_MEDIA_TIME) {
        pFormat = &TIME_FORMAT_MEDIA_TIME;  // For now
    }

    return pFormat;
}


/*  CBasicParse methods */
/*  Time Format support - default to only time */
HRESULT CBasicParse::IsFormatSupported(const GUID *pTimeFormat)
{
    if (*pTimeFormat == TIME_FORMAT_MEDIA_TIME) {
        return S_OK;
    } else {
        return S_FALSE;
    }
};

/*  Default setting the time format */
HRESULT CBasicParse::SetFormat(const GUID *pFormat)
{
    //  Caller should have checked
    ASSERT(S_OK == IsFormatSupported(pFormat));
    m_Stop = Convert(m_Stop, m_pTimeFormat, pFormat);
    m_pTimeFormat = ConvertToLocalFormatPointer(pFormat);
    return S_OK;
};

HRESULT CBasicParse::ConvertTimeFormat
( LONGLONG * pTarget, const GUID * pTargetFormat
, LONGLONG    Source, const GUID * pSourceFormat
)
{
    pTargetFormat = ConvertToLocalFormatPointer(pTargetFormat);
    pSourceFormat = ConvertToLocalFormatPointer(pSourceFormat);

    // Assume the worst...
    HRESULT hr = E_INVALIDARG;

    if ( IsFormatSupported(pTargetFormat) == S_OK
         && IsFormatSupported(pSourceFormat) == S_OK )
    {
        *pTarget = Convert( Source, pSourceFormat, pTargetFormat );
        hr = NOERROR;
    }

    return hr;
}


/*  Time format conversions
    Returns llOld converted from OldFormat to NewFormat
*/
LONGLONG CMpeg1SystemParse::Convert(LONGLONG llOld,
                                    const GUID *OldFormat,
                                    const GUID *NewFormat)
{
    if (OldFormat == NewFormat) {
        return llOld;
    }
    LONGLONG llTime;
    if (OldFormat == &TIME_FORMAT_MEDIA_TIME) {
        llTime = llOld;
    } else if (OldFormat == &TIME_FORMAT_FRAME) {
        ASSERT(m_pVideoStream != NULL);

        /*  m_pVideoStream->m_iFirstSequence is the first frame counted
            in the movie time-based duration

            So, time for 1 frame is
                (duration in time) / (number of frames counted in duration)

            Round UP when going to time

            To avoid rounding errors convert up 1ms unless it's the first frame
        */
        const int iOffset = m_pVideoStream->m_iFirstSequence;
        if (llOld >= m_dwFrameLength) {
            llTime = m_rtDuration;
        } else
        if (llOld <= 0) {
            llTime = 0;
        } else {
            llTime = m_rtVideoStartOffset +

                     //  Our adjusted duration doesn't include the
                     //  time of the last frame so scale using 1
                     //  frame less than the frame length
                     llMulDiv(llOld - iOffset,
                              m_rtDuration - m_rtVideoStartOffset - m_rtVideoEndOffset,
                              m_dwFrameLength - iOffset - 1,
                              m_dwFrameLength - iOffset - 2);
            if (llOld != 0) {
                llTime += UNITS / MILLISECONDS;

            }
        }
    } else {
        ASSERT(OldFormat == &TIME_FORMAT_BYTE);
        llTime = llMulDiv(llOld,
                          m_rtDuration,
                          m_llTotalSize,
                          m_llTotalSize/2);
    }

    /*  Now convert the other way */
    if (NewFormat == &TIME_FORMAT_FRAME) {
        ASSERT(m_pVideoStream != NULL);

        /*  Round DOWN when going to frames */
        const int iOffset = m_pVideoStream->m_iFirstSequence;

        //  Our adjusted duration of the video doesn't include the
        //  time of the last frame so scale using 1
        //  frame less than the frame length
        llTime = llMulDiv(llTime - m_rtVideoStartOffset,
                          m_dwFrameLength - iOffset - 1,
                          m_rtDuration - m_rtVideoStartOffset - m_rtVideoEndOffset,
                          0) + iOffset;
        if (llTime < 0) {
            llTime = 0;
        }
        if (llTime > m_dwFrameLength) {
            llTime = m_dwFrameLength;
        }
    } else if (NewFormat == &TIME_FORMAT_BYTE) {
        llTime = llMulDiv(llTime,
                          m_llTotalSize,
                          m_rtDuration,
                          m_rtDuration/2);
    }
    if (llTime < 0) {
        llTime = 0;
    }
    return llTime;
}

/*  Set the time format for MPEG 1 system stream */
HRESULT CMpeg1SystemParse::SetFormat(const GUID *pFormat)
{
    //  Caller should have checked
    ASSERT(S_OK == IsFormatSupported(pFormat));

    /*  Set start and stop times based on the old values */
    m_Stop = Convert(m_Stop, m_pTimeFormat, pFormat);
    REFERENCE_TIME rtStart;
    const GUID *pOldFormat = m_pTimeFormat;
    m_pTimeFormat = pFormat;
    Seek(m_llSeek, &rtStart, pOldFormat);
    return S_OK;
};

#ifdef DEBUG
    #define CONTROL_LEVEL 2
#endif

/*  Constructor and destructor */
CMpeg1SystemParse::CMpeg1SystemParse() : m_bVideoCD(FALSE)
{
}

CMpeg1SystemParse::~CMpeg1SystemParse()
{
    /*  Free the streams */
    while (m_lStreams.GetCount() != 0) {
        delete m_lStreams.RemoveHead();
    }
}

/*
    Init

    Initialize the parser:

        (re) initializes the parser.  Deletes all streams previously present.

    Parameters:

        llSize - total size of file (if Seekable, otherwise 0)

        bVideoCD - if the file is in VideoCD format

        bSeekable - if the file is seekable

    Returns

        S_OK
*/

HRESULT CMpeg1SystemParse::Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt)
{
    CBasicParse::Init(llSize, bSeekable, pmt);

    m_FailureCode          = S_OK;
    m_llPos                = 0;
    DbgLog((LOG_TRACE, 4, TEXT("Parse state <initializing>")));
    m_lSystemHeaderSize    = 0;
    m_MuxRate              = 0;
    m_bGotStart            = FALSE;
    m_llStartTime          = 0;
    m_llStopTime           = 0x7FFFFFFFFFFFFFFF;  // Init to never stop
    m_stcStartPts          = 0;
    m_bGotDuration         = FALSE;
    m_bConcatenatedStreams = FALSE;
    m_stcTSOffset          = (LONGLONG)0;
    m_pVideoStream         = NULL;
    m_dwFrameLength        = (DWORD)-1;
    m_bItem                = false;
    m_rtVideoStartOffset   = 0;
    m_rtVideoEndOffset     = 0;
    InitStreams();

    /*  Process input media type */
    if (pmt != NULL &&
        pmt->formattype == FORMAT_MPEGStreams &&
        pmt->cbFormat >= sizeof(AM_MPEGSYSTEMTYPE)) {
        AM_MPEGSYSTEMTYPE *pSystem = (AM_MPEGSYSTEMTYPE *)pmt->Format();
        AM_MPEGSTREAMTYPE *pMpegStream = pSystem->Streams;
        for (DWORD i = 0; i < pSystem->cStreams; i++) {
            /*  Add the stream to our list */
            DWORD dwStreamId = pMpegStream->dwStreamId;
            CStream *pStream = AddStream((UCHAR)dwStreamId);
            if (pStream == NULL) {
                return E_OUTOFMEMORY;
            }

            /*  Let the stream try to initialize itself using the type */
            AM_MEDIA_TYPE mt = pMpegStream->mt;
            mt.pbFormat = pMpegStream->bFormat;
            HRESULT hr = pStream->ProcessType(&mt);
            if (FAILED(hr)) {
                return hr;
            }
            pMpegStream = AM_MPEGSTREAMTYPE_NEXT(pMpegStream);
        }
        m_MuxRate = pSystem->dwBitRate / (50 * 8);
    }

    return S_OK;
}

/*
    FindEnd

        Sets the state to searching for the end.  Only valid when
        the data is seekable.

        Generates a call back to seek the source to 1 second before
        the end.
*/

HRESULT CMpeg1SystemParse::FindEnd()
{
    DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::FindEnd()")));
    ASSERT(m_bSeekable);

    m_State = State_FindEnd;

    /*  Get all the streams ready */
    SetState(State_FindEnd);

    /*  Go to near the end (end - 1.5 seconds to) */
    LONGLONG llPos = m_llTotalSize - m_MuxRate * 75;
    if (llPos < 0) {
        llPos = 0;
    }

    /*  Seek the reader  - what if this fails? */
    m_pNotify->SeekTo(llPos);

    Discontinuity();

    return S_OK;
}

/*  Return the file duration time in MPEG units
*/
LONGLONG CMpeg1SystemParse::Duration()
{
    ASSERT(m_State != State_Initializing &&
           (m_State != State_FindEnd || IsComplete()));
    ASSERT(m_bSeekable);
    return m_llDuration;
}

/*
    SetStop

        Set the stop time to tTime.
*/
HRESULT CMpeg1SystemParse::SetStop(LONGLONG llStop)
{
    if (m_pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
        REFERENCE_TIME tTime = llStop;

        DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::SetStop(%s)"),
                (LPCTSTR)CDisp(llStop)));
        if (CRefTime(tTime) == CRefTime(m_Stop)) {
            return S_OK;
        }
        m_Stop = tTime;

        m_llStopTime = ReferenceTimeToMpeg(tTime);
        if (m_llStopTime > Duration()) {
            DbgLog((LOG_ERROR, 2, TEXT("Stop time beyond end!")));
            m_llStopTime = Duration();
            CheckStop();
            return S_OK;
        }
        m_llStopTime += StartClock();
        DbgLog((LOG_TRACE, 3, TEXT("Stop time in MPEG units is %s"),
                (LPCTSTR)CDisp(m_llStopTime)));

        if (m_State == State_Run || m_State == State_Stopping) {
            CheckStop();
        }
    } else {
        /*  The stop time for these formats will immediately be
            followed by a set start time because IMediaSelection
            can't set the stop time independently so we just cache the
            value here
        */
        ASSERT(m_pTimeFormat == &TIME_FORMAT_BYTE ||
               m_pTimeFormat == &TIME_FORMAT_FRAME);
        m_Stop = llStop;
    }
    return S_OK;
}

/*
     Replay the same data.  We have to ASSUME that our
     data supplier knows where to restart sending data from because
     we already told them (and anyway they may not be seekable)
*/
HRESULT CMpeg1SystemParse::Replay()
{
    /*  Find out what we were doing and do it again (!) */
    DbgLog((LOG_TRACE, 3, TEXT("CMpeg1SystemParse::Replay")));
    SetState(m_State == State_Stopping ? State_Run : m_State);

    /*  Data not expected to tally with old */
    Discontinuity();
    return S_OK;
}

/*  Return the start time in reference time units or our best guess */
REFERENCE_TIME CMpeg1SystemParse::GetStartTime()
{
    if (m_pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
        return m_Start;
    }
    if (m_pTimeFormat == &TIME_FORMAT_FRAME) {
        return MpegToReferenceTime(m_llStartTime - StartClock());
    }

    /*  For other time formats we don't know the start time position to
        offset samples from until we see the first PTS
    */
    ASSERT(m_pTimeFormat == &TIME_FORMAT_BYTE);
    if (!m_bGotStart) {
        /*  Guess */
        return llMulDiv(m_Start,
                        m_rtDuration,
                        m_llTotalSize,
                        0);
    } else {

        /*  Return value of start time vs real start time */
        return MpegToReferenceTime(
                   m_llStartTime - (LONGLONG)m_stcRealStartPts
               );
    }
};

/*  Return the stop time in reference time units or our best guess */
REFERENCE_TIME CBasicParse::GetStopTime()
{
    return Convert(m_Stop, m_pTimeFormat, &TIME_FORMAT_MEDIA_TIME);
};

/*  Get the total file duration for Video CD */
HRESULT CVideoCDParse::GetDuration(
    LONGLONG *llDuration,
    const GUID *pTimeFormat
)
{
    if (m_pTimeFormat == &TIME_FORMAT_BYTE) {
        *llDuration =
            llMulDiv(m_llTotalSize - VIDEOCD_HEADER_SIZE,
                     VIDEOCD_DATA_SIZE,
                     VIDEOCD_SECTOR_SIZE,
                     0);
        return S_OK;
    } else {
        return CMpeg1SystemParse::GetDuration(llDuration, pTimeFormat);
    }
}

/*  Get the total file duration */
HRESULT CMpeg1SystemParse::GetDuration(
    LONGLONG *llDuration,
    const GUID *pTimeFormat
)
{
    if (!m_bGotDuration) {
        return E_FAIL;
    }
    if (pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
        *llDuration = m_rtDuration;
        return S_OK;
    } else {
        if (pTimeFormat == &TIME_FORMAT_FRAME) {
            if (m_dwFrameLength == (DWORD)-1) {
                return VFW_E_NO_TIME_FORMAT_SET;
            }
            *llDuration = m_dwFrameLength;
            return S_OK;
        }
    }
    ASSERT(pTimeFormat == &TIME_FORMAT_BYTE);
    *llDuration = m_llTotalSize;
    return S_OK;
};

/*  Seek VideoCD */
HRESULT CVideoCDParse::Seek(LONGLONG llSeek,
                            REFERENCE_TIME *prtStart,
                            const GUID *pTimeFormat)
{
    if (pTimeFormat == &TIME_FORMAT_BYTE) {
        /*  Recompute the seek based on sectors etc */
        llSeek = (llSeek / VIDEOCD_DATA_SIZE) * VIDEOCD_SECTOR_SIZE +
                 llSeek % VIDEOCD_DATA_SIZE +
                 VIDEOCD_HEADER_SIZE;
    }
    return CMpeg1SystemParse::Seek(llSeek, prtStart, pTimeFormat);
}

/*
     Seek to a new position

     This effectively generates the seek to the notify object and
     saves the seek information in

         m_llSeek     - seek position
         m_pTimeFormat - time format used for seek
*/
HRESULT CMpeg1SystemParse::Seek(LONGLONG llSeek,
                                REFERENCE_TIME *prtStart,
                                const GUID *pTimeFormat)
{
    if (pTimeFormat != m_pTimeFormat) {
        llSeek = Convert(llSeek, pTimeFormat, m_pTimeFormat);
    }
    m_llSeek = llSeek;
    LONGLONG llSeekPosition;
    if (m_pTimeFormat == &TIME_FORMAT_BYTE) {
        llSeekPosition = llSeek;
        *prtStart = llMulDiv(llSeek,
                             m_rtDuration,
                             m_llTotalSize,
                             m_llTotalSize/2);
    } else {
        DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::Seek(%s)"),
                (LPCTSTR)CDisp(CRefTime(llSeek))));
        if (llSeek < 0) {
            return E_UNEXPECTED;
        }

        LONGLONG llDuration = Duration();
        LONGLONG llStreamTime;

        if (m_pTimeFormat == &TIME_FORMAT_FRAME) {

            /*  Also return the 'where are we now' information */
            *prtStart = Convert(llSeek,
                                &TIME_FORMAT_FRAME,
                                &TIME_FORMAT_MEDIA_TIME);

        } else {
            ASSERT(m_pTimeFormat == &TIME_FORMAT_MEDIA_TIME);
            /*  Get the time in MPEG time units */
            *prtStart = llSeek;
        }
        llStreamTime = ReferenceTimeToMpeg(*prtStart);

        ASSERT(llDuration != 0);

        if (llStreamTime > llDuration) {
            llStreamTime = llDuration;
        }
        /*  Is is somewhere we could seek to ?
            (NOTE - allow some leeway at the end or we may only find audio)
        */
        if (llStreamTime > llDuration - (MPEG_TIME_DIVISOR / 2)) {
           DbgLog((LOG_ERROR, 2, TEXT("Trying to seek past end???")));
           llStreamTime = llDuration - (MPEG_TIME_DIVISOR / 2);
        }

        ASSERT(Initialized());

        /*  Cheap'n nasty seek */
        llSeekPosition = llMulDiv(llStreamTime - MPEG_TIME_DIVISOR,
                                  m_llTotalSize,
                                  llDuration,
                                  0);

        if (llSeekPosition < 0) {
            llSeekPosition = 0;
        }
    }

    /*  Seek the reader  - what if this fails? */
    m_pNotify->SeekTo(llSeekPosition);

    return S_OK;
}

/*  Set seeking state

    Here we pick up the information dumped by Seek() :

        m_llSeek            -  Where to seek to
        m_pTimeFormat        -  What time format to use

    For BYTE based seeking we don't do any prescan etc

    For Frame based seeking we don't actually generate any frame number
    in the samples - we just arrange to try to send the right data so
    that the downstream filter can pick out the frames it needs.
*/
void CMpeg1SystemParse::SetSeekState()
{
    /*  Cache new information */
    m_Start      = m_llSeek;

    /*  What we do depends on what time format we're using */
    if (m_pTimeFormat == &TIME_FORMAT_BYTE) {
        m_bGotStart = FALSE;
        SetState(State_Seeking);
        SetState(State_Run);
        m_pNotify->Complete(TRUE, 0, 0);
        return;
    } else {
        /*  Fix up any byte seeking hackery */
        m_bGotStart = TRUE;
        m_stcStartPts = m_stcRealStartPts;

        REFERENCE_TIME rtStart;
        if (m_pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
            rtStart = m_Start;
            if (rtStart < 0) {
                rtStart = 0;
            }
            m_llStopTime = ReferenceTimeToMpeg(m_Stop);
        } else {
            ASSERT(m_pTimeFormat == &TIME_FORMAT_FRAME);

            /*  Subtract half a frame in case we miss one !
                Also allow for the fact that some frames are before
                time 0 (!)
            */
            rtStart = Convert(m_Start,
                              &TIME_FORMAT_FRAME,
                              &TIME_FORMAT_MEDIA_TIME);

            /*  Add on an extra half frame just to make sure we don't miss one! */
            m_llStopTime = ReferenceTimeToMpeg(
                               Convert(m_Stop,
                                       &TIME_FORMAT_FRAME,
                                       &TIME_FORMAT_MEDIA_TIME) +
                               m_pVideoStream->m_seqInfo.tPictureTime / 2);
            if (m_llStopTime > m_llDuration) {
                m_llStopTime = m_llDuration;
            }
        }

        DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::SetSeekState(%s)"),
                (LPCTSTR)CDisp(CRefTime(rtStart))));

        /*  Get the time in MPEG time units */
        LONGLONG llStreamTime = ReferenceTimeToMpeg(rtStart);

        LONGLONG llDuration = Duration();
        ASSERT(llDuration != 0);

        if (llStreamTime > llDuration) {
            llStreamTime = llDuration;
        }
        /*  We're going to roughly the right place (I hope!) */
        m_llStartTime = llStreamTime + StartClock();
        SeekTo(m_llStartTime - MPEG_TIME_DIVISOR);

        if (m_llStopTime > Duration()) {
            DbgLog((LOG_ERROR, 2, TEXT("Stop time beyond end!")));
            m_llStopTime = Duration();
        }
        m_llStopTime += StartClock();
        DbgLog((LOG_TRACE, 3, TEXT("Stop time in MPEG units is %s"),
                (LPCTSTR)CDisp(m_llStopTime)));
    }
    /*  Seek all the streams */
    Discontinuity();
    m_State = State_Seeking;
    SetState(State_Seeking);
    DbgLog((LOG_TRACE, 4, TEXT("Parse state <seeking>")));
}

HRESULT CMpeg1SystemParse::Run()
{
    DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::Run()")));
    /*  Set all the embedded streams to run */
    if (m_State != State_Run) {
        m_State = State_Run;
        SetState(State_Run);
    }
    Discontinuity();
    return S_OK;
}

HRESULT CMpeg1SystemParse::EOS()
{
    DbgLog((LOG_TRACE, CONTROL_LEVEL, TEXT("CMpeg1SystemParse::EOS()")));
    /*  Just call EOS in all the streams in turn */
    POSITION pos = m_lStreams.GetHeadPosition();
    while (pos) {
        m_lStreams.GetNext(pos)->EOS();
    }
    return m_bCompletion ? S_OK : S_FALSE;
}

/*  Check to see if the current time is near the stop time
*/
void CMpeg1SystemParse::CheckStop()
{
    if (m_State == State_Run) {

        /*  Stream time must be offset if we're in concatenated stream mode */
        if ((m_bConcatenatedStreams &&
             m_llStopTime - m_llCurrentClock - (LONGLONG)m_stcTSOffset <=
                 MPEG_TIME_DIVISOR
            ) ||
            (!m_bConcatenatedStreams &&
             m_llStopTime - m_llCurrentClock <= MPEG_TIME_DIVISOR)
           ) {
            DbgLog((LOG_TRACE, 3, TEXT("Setting stopping state near end of play")));
            m_State = State_Stopping;
            SetState(State_Stopping);
        }
    }
}

/*
      IsComplete

          Are we complete ?  (ie have we completed the last state transition?)
*/
BOOL CMpeg1SystemParse::IsComplete()
{
    if (m_State == State_Initializing && m_nValid == 2 ||
        m_State != State_Initializing && m_nValid == m_lStreams.GetCount()) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*
    return the 'i'th stream
*/
CBasicStream * CMpeg1SystemParse::GetStream(int i)
{
    POSITION pos = m_lStreams.GetHeadPosition();
    while (pos) {
        CStream *pStream = m_lStreams.GetNext(pos);
        if (i-- == 0) {
            return pStream;
        }
    }
    return NULL;
}

/*  Add a stream to our list of streams */
BOOL CMpeg1SystemParse::AddStream(CStream *pStream)
{
    return m_lStreams.AddTail(pStream) != NULL;
}

/*  Remove a stream from our list of streams */
BOOL CMpeg1SystemParse::RemoveStream(CStream *pStream)
{
    if (pStream == m_pVideoStream) {
        m_pVideoStream = NULL;
    }
    return m_lStreams.Remove(m_lStreams.Find((CStream *)pStream)) != NULL;
}

/*  Return start time in non-wrapped MPEG units */
CSTC CMpeg1SystemParse::GetStart()
{
    return m_llStartTime;
}

/*  Return stop time in non-wrapped MPEG units */
CSTC CMpeg1SystemParse::GetStop()
{
    return m_llStopTime;
}

LONGLONG CMpeg1SystemParse::GetPlayLength()
{
    return m_Stop - m_Start;
}



/*  Get the buffer size for the reader - 2 seconds */
LONG CMpeg1SystemParse::GetBufferSize()
{
    ASSERT(m_MuxRate != 0);
    LONG lBufferSize = m_MuxRate * (50 * 2);
    if (lBufferSize < (MAX_MPEG_PACKET_SIZE * 2)) {
        lBufferSize = MAX_MPEG_PACKET_SIZE * 2;
    }
    return lBufferSize;
}

/*  Short cut to stream list parse error routine */
void CMpeg1SystemParse::ParseError(DWORD dwError)
{
    /*  Start all over again */
    switch (m_State) {
    case State_Initializing:
        InitStreams();
        break;
    default:
        break;
    }
    if (!m_bDiscontinuity) {
        /*  Note a possible discontinuity */
        Discontinuity();

        /*  Call back for notification */
        ASSERT(m_pNotify != NULL);
        m_pNotify->ParseError(0xFF, m_llPos, dwError);
    }
}

/*  Return format support for system stream and video CD */
HRESULT CMpeg1SystemParse::IsFormatSupported(const GUID *pTimeFormat)
{
    if (*pTimeFormat == TIME_FORMAT_BYTE ||
        *pTimeFormat == TIME_FORMAT_FRAME && m_dwFrameLength != (DWORD)-1 ||
        *pTimeFormat == TIME_FORMAT_MEDIA_TIME) {
        return S_OK;
    } else {
        return S_FALSE;
    }
};

/*
    Parse the data in an MPEG system stream pack header
*/

LONG CMpeg1SystemParse::ParsePack(PBYTE pData, LONG lBytes)
{
    DbgLog((LOG_TRACE, 4, TEXT("Parse pack %d bytes"), lBytes));
    /*  Note that we can validly return if there are less than
        a pack header + a start code because the stream must end
        with a start code (the end code) if it is to be valid
    */
    if (lBytes < PACK_HEADER_LENGTH + 4) {
        return 0;
    }

    /*  Additional length of system header (or 0) */
    LONG lParse;
    DWORD dwNextCode = *(UNALIGNED DWORD *)&pData[PACK_HEADER_LENGTH];

    DbgLog((LOG_TRACE, 4, TEXT("Next start code after pack is 0x%8.8X"),
           DWORD_SWAP(dwNextCode)));

    /*  Check if this is going to be followed by a system header */
    if (dwNextCode == DWORD_SWAP(SYSTEM_HEADER_START_CODE)) {
        lParse = ParseSystemHeader(pData + PACK_HEADER_LENGTH,
                                   lBytes - PACK_HEADER_LENGTH);
        if (lParse == 4) {
            /*  Don't even bother - it's an error */
            return 4;
        } else {
            if (lParse == 0) {
                /*  Try again when we've got more data */
                return 0;
            }
        }
    } else {
        if ((dwNextCode & 0xFFFFFF) != 0x010000) {
            /*  Stop now - it's an error */
            DbgLog((LOG_TRACE, 4, TEXT("Parse pack invalid next start code 0x%8.8X"),
                   DWORD_SWAP(dwNextCode)));
            return 4;
        }
        lParse = 0;
    }

    /*  Check pack */


    if ((pData[4] & 0xF1) != 0x21 ||
        (pData[6] & 0x01) != 0x01 ||
        (pData[8] & 0x01) != 0x01 ||
        (pData[9] & 0x80) != 0x80 ||
        (pData[11] & 0x01) != 0x01) {
        DbgLog((LOG_TRACE, 4, TEXT("Parse pack invalid marker bits")));
        ParseError(Error_InvalidPack | Error_InvalidMarkerBits);
        return 4;    // Try again!
    }

    CSTC Clock;
    if (!GetClock(pData + 4, &Clock)) {
        return 4;
    }

    /*  Note - for VideoCD the mux rate is the rate for the whole file,
        including the sector header junk etc so we don't need to
        munge it when using it in our position calculations
    */
    m_MuxRate     = ((LONG)(pData[9] & 0x7F) << 15) +
                    ((LONG)pData[10] << 7) +
                    ((LONG)pData[11] >> 1);
    LARGE_INTEGER liClock;
    liClock.QuadPart = Clock;
    DbgLog((LOG_TRACE, 4, TEXT("Parse pack clock 0x%1.1X%8.8X mux rate %d bytes per second"),
           liClock.HighPart & 1, liClock.LowPart, m_MuxRate * 50));

    /*  Update our internal clock - this will wrap correctly provided the
        current clock is correct
    */
    SetStreamTime(Clock, m_llPos + 8);

    if (m_bConcatenatedStreams) {
        if (!m_bTimeContiguous) {
            m_stcTSOffset =  llMulDiv(m_llPos,
                                      m_llDuration,
                                      m_llTotalSize,
                                      0) -
                             (m_llCurrentClock - m_llFirstClock);
            DbgLog((LOG_TRACE, 1,
                   TEXT("Time was discontiguous - setting offset to %s"),
                   (LPCTSTR)CDisp((double)(LONGLONG)m_stcTSOffset / 90000)));
            m_bTimeContiguous = TRUE;
        }
    }

    /*  If we're near the stop time it's time to kick the parsers back in
    */
    CheckStop();

    return PACK_HEADER_LENGTH + lParse;
}

LONG CMpeg1SystemParse::ParseSystemHeader(PBYTE pData, LONG lBytes)
{
    DbgLog((LOG_TRACE, 4, TEXT("ParseSystemHeader %d bytes"), lBytes));

    /*  Check if we already know the system header for this stream.
        VideoCD can contain different system headers for the different
        streams however

        Since other files seem to allow for this too there's nothing
        to do but allow for multiple different system headers!
    */
#if 0
    if (m_lSystemHeaderSize != 0) {

        /*  They must ALL be identical - see 2.4.5.6 or ISO-1-11172
            UNFORTUNATELY Video-CD just pretends it is two streams
            so there are at least 2 versions of the system header (!)
        */

        if (lBytes < m_lSystemHeaderSize) {
            return 0;
        } else {
            if (memcmp(pData, &m_SystemHeader, m_lSystemHeaderSize) == 0) {
                return m_lSystemHeaderSize;
            } else {
                /*  Well, of course they're not all the same (!) */
                DbgLog((LOG_ERROR, 3,
                        TEXT("System header different - size %d, new 0x%8.8X, old 0x%8.8X!"),
                             m_lSystemHeaderSize, (DWORD)pData, &m_SystemHeader));
                ParseError(Error_DifferentSystemHeader);
                return 4;
            }
        }
    }
#endif
    if (lBytes < SYSTEM_HEADER_BASIC_LENGTH) {
        return 0;
    }

    LONG lHdr = ((LONG)pData[4] << 8) + (LONG)pData[5] + 6;

    /*  Check system header */
    if (lHdr < 12 ||
        (pData[6] & 0x80) != 0x80 ||
        // (pData[8] & 0x01) != 0x01 ||  Robocop1(1) fails this test
        (pData[10] & 0x20) != 0x20 ||
         pData[11] != 0xFF) {
        DbgLog((LOG_ERROR, 3, TEXT("System header invalid marker bits")));
        ParseError(Error_InvalidSystemHeader | Error_InvalidMarkerBits);
        return 4;
    }

    if (lBytes < lHdr) {
        return 0;
    }

    /*  Pull out the streams and check the header length */
    LONG lPosition = 12;
    BYTE bStreams[0x100 - 0xB8];
    ZeroMemory((PVOID)bStreams, sizeof(bStreams));
    while (lPosition < lBytes - 2) {
        if (pData[lPosition] & 0x80) {
            if (lPosition <= sizeof(m_SystemHeader) - 3) { /* There IS a limit of 68 streams */
                /*  Check marker bits */
                if ((pData[lPosition + 1] & 0xC0) != 0xC0) {
                    DbgLog((LOG_ERROR, 3, TEXT("System header bad marker bits!")));
                    ParseError(Error_InvalidSystemHeaderStream |
                               Error_InvalidMarkerBits);
                    return 4;
                }

                /*  Check the stream id is valid - check for repeats? */
                if (pData[lPosition] != AUDIO_GLOBAL &&
                    pData[lPosition] != VIDEO_GLOBAL &&
                    pData[lPosition] < 0xBC) {
                    DbgLog((LOG_ERROR, 3, TEXT("System header bad stream id!")));
                    ParseError(Error_InvalidSystemHeaderStream |
                               Error_InvalidStreamId);
                    return 4;
                }
                if (m_State == State_Initializing) {
                    if (pData[lPosition] >= AUDIO_STREAM) {
                        AddStream(pData[lPosition]);
                    }
                }

                /*  Don't allow repeats in the list */
                if (bStreams[pData[lPosition] - 0xB8]++) {
                    // Repeat
                    DbgLog((LOG_ERROR, 3, TEXT("System header stream repeat!")));
                    ParseError(Error_InvalidSystemHeaderStream |
                               Error_DuplicateStreamId);
                    return 4;
                }
            }
            lPosition += 3;
        } else {
            break;
        }
    }
    if (lHdr != lPosition) {
        DbgLog((LOG_ERROR, 3, TEXT("System header bad size!")));
        ParseError(Error_InvalidSystemHeader |
                   Error_InvalidLength);
        return 4;
    }
    /*  VideoCD can have multiple different system headers but we'll
        ignore this for now (!)
    */
    CopyMemory((PVOID)&m_SystemHeader, (PVOID)pData, lHdr);
    m_lSystemHeaderSize = lHdr;

    DbgLog((LOG_TRACE, 4, TEXT("System header length %d"), lHdr));

    return lHdr;
}

/*  Parse a packet */
LONG CMpeg1SystemParse::ParsePacket(DWORD dwStartCode,
                                    PBYTE pData,
                                    LONG lBytes)
{
    // The minimum packet header size is 6 bytes.  3 bytes for
    // the start code, 1 byte for the stream ID and 2 byte for
    // the packet length.
    const LONG MIN_PACKET_HEADER_SIZE = 6;

#ifdef DEBUG
    if (m_bVideoCD) {
        if (!IsAudioStreamId((BYTE)dwStartCode) &&
            !IsVideoStreamId((BYTE)dwStartCode)) {
            DbgLog((LOG_ERROR, 2, TEXT("VideoCD contained packet from stream 0x%2.2X"),
                    (BYTE)dwStartCode));
        }
    }
#endif
    DbgLog((LOG_TRACE, 4, TEXT("Parse packet %d bytes"), lBytes));
    /*  Send it to the right stream */
    if (lBytes < MIN_PACKET_HEADER_SIZE) {
        return 0;
    }

    /*  Find the length */
    LONG lLen = ((LONG)pData[4] << 8) + (LONG)pData[5] + MIN_PACKET_HEADER_SIZE;
    DbgLog((LOG_TRACE, 4, TEXT("Packet length %d bytes"), lLen));
    if (lLen > lBytes) {
        return 0;
    }

    /*  Pull out PTS if any */
    BOOL bHasPts = FALSE;
    LONG lHeaderSize = MIN_PACKET_HEADER_SIZE;
    CSTC stc = 0;

    if (dwStartCode != PRIVATE_STREAM_2) {
        int lPts = 6;
        for (;;) {
            if (lPts >= lLen) {
                ParseError(Error_InvalidPacketHeader |
                           Error_InvalidLength);
                return 4;
            }

            if (pData[lPts] & 0x80) {
                /*  Stuffing byte */
                if (pData[lPts] != 0xFF) {
                    ParseError(Error_InvalidPacketHeader |
                               Error_InvalidStuffingByte);
                    return 4;
                }
                lPts++;
                continue;
            }

            /*  Check for STD (nextbits == '01') -
                we know the next bit is 0 so check the next one after that
            */
            if (pData[lPts] & 0x40) { // STD stuff
                lPts += 2;
                continue;
            }

            /*  No PTS - normal case */
            if (pData[lPts] == 0x0F) {
                lHeaderSize = lPts + 1;
                break;
            }

            if ((pData[lPts] & 0xF0) == 0x20 ||
                (pData[lPts] & 0xF0) == 0x30) {


                /*  PTS or PTS and DTS */
                lHeaderSize = (pData[lPts] & 0xF0) == 0x20 ? lPts + 5 :
                                                             lPts + 10;
                if (lHeaderSize > lLen) {
                    ParseError(Error_InvalidPacketHeader |
                               Error_InvalidHeaderSize);
                    return 4;
                }
                if (!GetClock(pData + lPts, &stc)) {
                    return 4;
                }
                bHasPts = TRUE;
                if (!m_bGotStart) {
                    if (m_bConcatenatedStreams) {
                        if (m_bTimeContiguous) {
                            m_stcStartPts = stc + m_stcTSOffset;
                            m_llStartTime = StartClock();
                            m_bGotStart = TRUE;
                        }
                    } else {
                        m_stcStartPts = stc;
                        /*  Make sure we have a valid position to play from */
                        m_llStartTime = StartClock();
                        DbgLog((LOG_TRACE, 2, TEXT("Start PTS = %s"), (LPCTSTR)CDisp(m_stcStartPts)));
                        m_bGotStart = TRUE;
                    }
                }
                break;
            } else {
                ParseError(Error_InvalidPacketHeader | Error_InvalidType);
                return 4;
                break;
            }
        }
    }


    /*  If we're not parsing video CD then there should be a valid
        start code after this packet.

        If this is a video CD we're not prone to seek errors anyway
        unless the medium is faulty.
    */
    if (!m_bVideoCD) {
        if (lLen + 3 > lBytes) {
            return 0;
        }
        /*  Check (sort of) for valid start code
            The next start code might not be straight away so we may
            only see 0s
        */
        if ((pData[lLen] | pData[lLen + 1] | (pData[lLen + 2] & 0xFE)) != 0) {
            DbgLog((LOG_ERROR, 2, TEXT("Invalid code 0x%2.2X%2.2X%2.2X after packet"),
                   pData[lLen], pData[lLen + 1], pData[lLen + 2]));
            ParseError(Error_InvalidPacketHeader | Error_InvalidStartCode);
            return 4;
        }
    }

    /*  Handle concatenated streams :

        1.  Don't do anything until we've got a pack time to sync to
        2.  Offset all times to the timestamp offset
    */

    if (m_bConcatenatedStreams) {
        if (!m_bTimeContiguous) {
            return lLen;
        }
        if (bHasPts) {
            stc = stc + m_stcTSOffset;
        }
    }

    if (lLen > lHeaderSize) {
        /*  Pass the packet on to the stream handler */
        SendPacket((BYTE)dwStartCode,
                   pData,
                   lLen,
                   lHeaderSize,
                   bHasPts,
                   stc);
    }

    /*  Ate the packet */

    /*  Clear the discontinuity flag - this means if we find another
        error we'll call the filter graph again
    */
    m_bDiscontinuity = FALSE;
    return lLen;
}

BOOL CMpeg1SystemParse::GetClock(PBYTE pData, CSTC *Clock)
{
    BYTE  Byte1 = pData[0];
    DWORD Word2 = ((DWORD)pData[1] << 8) + (DWORD)pData[2];
    DWORD Word3 = ((DWORD)pData[3] << 8) + (DWORD)pData[4];

    /*  Do checks */
    if ((Byte1 & 0xE0) != 0x20 ||
        (Word2 & 1) != 1 ||
        (Word3 & 1) != 1) {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid clock field - 0x%2.2X 0x%4.4X 0x%4.4X"),
            Byte1, Word2, Word3));
        ParseError(Error_InvalidClock | Error_InvalidMarkerBits);
        return FALSE;
    }

    LARGE_INTEGER liClock;
    liClock.HighPart = (Byte1 & 8) != 0;
    liClock.LowPart  = (DWORD)((((DWORD)Byte1 & 0x6) << 29) +
                       (((DWORD)Word2 & 0xFFFE) << 14) +
                       ((DWORD)Word3 >> 1));

    *Clock = liClock.QuadPart;

    return TRUE;
}

void CMpeg1SystemParse::Discontinuity()
{
    DbgLog((LOG_TRACE, 1, TEXT("CMpeg1SystemParse::Discontinuity")));

    POSITION pos = m_lStreams.GetHeadPosition();
    m_bDiscontinuity = TRUE;
    m_bTimeContiguous = FALSE;
    while (pos) {
        m_lStreams.GetNext(pos)->Discontinuity();
    }
}

/*  CVideoCDParse::ParseBytes

    This is a cheap wrapping for parsing a buffer full of VideoCD
    sectors
*/
LONG CVideoCDParse::ParseBytes(LONGLONG llPos,
                               PBYTE pData,
                               LONG lBytes,
                               DWORD dwFlags)
{
    LONG lOrigBytes = lBytes;

    /*  Make sure we're starting past the header */
    if (llPos < VIDEOCD_HEADER_SIZE) {
        LONG lDiff = VIDEOCD_HEADER_SIZE - (LONG)llPos;
        llPos += lDiff;
        pData += lDiff;
        lBytes -= lDiff;
    }
    LONG lRem = (LONG)((llPos - VIDEOCD_HEADER_SIZE) % VIDEOCD_SECTOR_SIZE);
    if (lRem != 0) {
        llPos += VIDEOCD_SECTOR_SIZE - lRem;
        lBytes -= VIDEOCD_SECTOR_SIZE - lRem;
        pData += VIDEOCD_SECTOR_SIZE - lRem;
    }
    /*  Should now be pointing at valid data (!) */
    while (lBytes >= VIDEOCD_SECTOR_SIZE && !IsComplete()) {
        VIDEOCD_SECTOR *pSector = (VIDEOCD_SECTOR *)pData;

        /*  Check for autopause */
        if (IS_AUTOPAUSE(pSector) && !m_bDiscontinuity) {
            /*  Set our current position correctly and send
                EndOfStream
            */
        }
        if (IS_MPEG_SECTOR(pSector)) {
            if (m_State == State_Initializing) {
                if (pSector->SubHeader[1] != 1) {
                    if (pSector->SubHeader[1] == 2 ||
                        pSector->SubHeader[1] == 3) {
                        m_bItem = true;
                    }
                }
            }
            LONG lRc = CMpeg1SystemParse::ParseBytes(
                            llPos + FIELD_OFFSET(VIDEOCD_SECTOR, UserData[0]),
                            pSector->UserData,
                            sizeof(pSector->UserData),
                            0);
            DbgLog((LOG_TRACE, 4, TEXT("Processed %d bytes in video CD sector"),
                    lRc));
        } else {
            if (m_State == State_Initializing) {
                /*  Check if this is a sector at all */
                if (*(UNALIGNED DWORD *)&pSector->Sync[0] != 0xFFFFFF00 ||
                    *(UNALIGNED DWORD *)&pSector->Sync[4] != 0xFFFFFFFF ||
                    *(UNALIGNED DWORD *)&pSector->Sync[8] != 0x00FFFFFF)
                {
                    m_pNotify->Complete(FALSE, 0, 0);
                    return 0;
                }
            }
        }
        pData += VIDEOCD_SECTOR_SIZE;
        lBytes -= VIDEOCD_SECTOR_SIZE;
        llPos += VIDEOCD_SECTOR_SIZE;
    }

    if (lBytes < 0) {
        return lOrigBytes;
    } else {
        return lOrigBytes - lBytes;
    }
}

/*  CMpeg1SystemParse::ParseBytes

    This is the basic parsing routine

    It is a loop which extracts a start code (possibly seeking) and
    then parses the data after the start code until we run out of
    bytes
*/
LONG CMpeg1SystemParse::ParseBytes(LONGLONG llPos,
                                   PBYTE pData,
                                   LONG lBytes,
                                   DWORD dwFlags)
{
    if (llPos != m_llPos) {
        if (!m_bDiscontinuity && !m_bVideoCD) {
            DbgLog((LOG_ERROR, 1, TEXT("Unexpected discontinuity!!!")));

            /*  We don't really know where we are       */
            m_bDiscontinuity = TRUE;

            /*  Tell the streams about the discontinuity */
            Discontinuity();
        }
        m_llPos = llPos;
    }

    /*  Discard rounding due to byte seeking and stop at the end */
    LONG lBytesLeft = lBytes;
    if (m_pTimeFormat == &TIME_FORMAT_BYTE) {
        if (!m_bGotStart && llPos < m_Start) {
            LONG lOffset = (LONG)(m_Start - llPos);
            if (lOffset > lBytes) {
                DbgLog((LOG_ERROR, 1, TEXT("Way off at start !")));
            }
            llPos = m_Start;
            lBytesLeft -= lOffset;
            pData += lOffset;
        }
        if (llPos + lBytesLeft >= m_Stop) {
            if (llPos >= m_Stop) {
                m_pNotify->Complete(TRUE, 0, 0);
                return 0;
            }
            lBytesLeft = (LONG)(m_Stop - llPos);
        }
    }

    DbgLog((LOG_TRACE, 4, TEXT("ParseBytes %d bytes"), lBytes));
    for (; lBytesLeft >= 4; ) {
        /*  First task is to find a start code.
            If we're not seeking and we're not at one it's an error
        */
        DWORD dwStart = *(UNALIGNED DWORD *)pData;
        DbgLog((LOG_TRACE, 4, TEXT("Start code 0x%8.8X"), DWORD_SWAP(dwStart)));
        if ((dwStart & 0x00FFFFFF) == 0x00010000) {
            dwStart = DWORD_SWAP(dwStart);
            if (VALID_SYSTEM_START_CODE(dwStart)) {
                /*  Got a start code for the system stream */
            } else {
                if (m_bVideoCD) {
                    break;
                }

                /*  4th byte might be 0 so just ignore 3 bytes */
                ParseError(Error_Scanning | Error_InvalidStartCode);
                pData += 3;
                m_llPos += 3;
                lBytesLeft -= 3;
                continue;
            }
        } else {
            if (m_bVideoCD) {
                break;
            }
            if ((dwStart & 0x00FFFFFF) != 0) {
                ParseError(Error_Scanning | Error_NoStartCode);
            }

            /*  Find a new 0 */
            PBYTE pDataNew;
            pDataNew = (PBYTE)memchrInternal((PVOID)(pData + 1), 0, lBytesLeft - 1);
            if (pDataNew == NULL) {
                m_llPos += lBytes - lBytesLeft;
                lBytesLeft = 0;
                break;
            }
            lBytesLeft -= (LONG)(pDataNew - pData);
            m_llPos += pDataNew - pData;
            pData = pDataNew;
            continue;
        }


        LONG lParsed;

        /*  Got a start code - is it a packet start code? */
        if (VALID_PACKET(dwStart)) {
            lParsed = ParsePacket(dwStart,
                                  pData,
                                  lBytesLeft);
        } else {
            /*  See if we recognize the start code */
            switch (dwStart)
            {
                case ISO_11172_END_CODE:
                    DbgLog((LOG_TRACE, 4, TEXT("ISO 11172 END CODE")));
                    /*  What if we find a bogus one while seeking? */
                    if (!((dwFlags & Flags_EOS) && lBytesLeft == 4)) {
                        DbgLog((LOG_ERROR, 1, TEXT("ISO 11172 END CODE in middle of stream")));
                    }
                    lParsed = 4;
                    break;

                case PACK_START_CODE:
                    lParsed = ParsePack(pData, lBytesLeft);
                    break;

                /*  Don't parse random system headers unless they're
                    immediately preceded by pack headers
                */
                case SYSTEM_HEADER_START_CODE:
                    /*  Just skip it */
                    if (lBytesLeft < 6 ||
                        lBytesLeft < 6 + pData[5] + 256 * pData[4]) {
                        lParsed = 0;
                    } else {
                        lParsed = 6 + pData[5] + 256 * pData[4];
                    }
                    break;

                default:
                    ParseError(Error_Scanning | Error_InvalidStartCode);
                    /*  Last byte might be 0 so only go on 3 */
                    lParsed = 3;
            }
        }
        /*  If we're stuck and need some more data get out */
        if (lParsed == 0) {
            break;
        }
        m_llPos += lParsed;
        lBytesLeft -= lParsed;
        pData     += lParsed;

        /*  Once the current action is complete just stop */
        if (VALID_PACKET(dwStart) && IsComplete()) {
            break;
        }
    }

    /*  Don't waste too much time searching for stuff during initialization */
    if (m_State == State_Initializing) {
        if (IsComplete()) {
            m_pNotify->Complete(TRUE, 0, 0);
        } else {

            /*  Hack for infogrames whose audio starts 8 seconds (!)
                into their file
            */
            if (llPos > 200000 && m_lStreams.GetCount() == m_nValid) {
                m_pNotify->Complete(FALSE, 0, 0);
            }
        }
    }

    /*  There are less than 4 bytes left or we're stuck - go and wait for some
        more!

        Note that if there isn't any more the caller will detect both
        End of Stream and the fact that we haven't eaten the data which
        is enough to conclude the data was bad
    */
    return lBytes - lBytesLeft;
}

/*  Initialize stream variables, freeing any currently existing pins
*/
void CMpeg1SystemParse::InitStreams()
{
    m_nValid = 0;
    m_nPacketsProcessed = 0;
    m_lSystemHeaderSize = 0;

    /*  Free all the pins */
    while (m_lStreams.GetCount() != 0) {
        /*  I hope the ref counts are 0 !*/
        CStream *pStream = m_lStreams.RemoveHead();
        delete pStream;
    }
}

/*  Process a packet

    Returns FALSE if no need to process rest of buffer
*/
BOOL CMpeg1SystemParse::SendPacket(UCHAR    uStreamId,
                                   PBYTE    pbPacket,
                                   LONG     lPacketSize,
                                   LONG     lHeaderSize,
                                   BOOL     bHasPts,
                                   CSTC     stc)
{
    m_nPacketsProcessed++;

    POSITION pos = m_lStreams.GetHeadPosition();
    CStream *pStream = NULL;

    /*  Look for our stream */
    while (pos) {
        pStream = m_lStreams.GetNext(pos);
        if (pStream->m_uNextStreamId == uStreamId) {
            if (pStream->m_uNextStreamId != pStream->m_uStreamId) {
                pStream->Discontinuity();
                pStream->m_uStreamId = pStream->m_uNextStreamId;
            }
            break;
        } else {
            pStream = NULL;
        }
    }

    /*  If we're initializing, we haven't seen a packet for this stream
        before and we've had a valid system header then add the
        stream
    */
    if (pStream == NULL &&
        m_State == State_Initializing &&
        m_lSystemHeaderSize != 0) {
        pStream = AddStream(uStreamId);
    }
    if (pStream == NULL) {
        DbgLog((LOG_TRACE, 2, TEXT("Packet for stream 0x%2.2X not processed"),
               uStreamId));
        return TRUE;
    } else {
        DbgLog((LOG_TRACE, 4, TEXT("Packet for stream 0x%2.2X at offset %s"),
                uStreamId, (LPCTSTR)CDisp(m_llPos)));
    }

    BOOL bPlaying = pStream->IsPlaying(m_llPos, lPacketSize);

    /*  We only parse at the start and the end.
        After we have parsed the start correctly the stream calls
        complete() so eventually we stop stream parsing
    */
    if (!IsComplete() && !pStream->m_bRunning &&
        (bPlaying || m_State != State_Run && m_State != State_Stopping)) {

         /*  This generates notifications of interesting
             events (like Seeking failed or succeeded!)

             For concatenated streams we do the hack of prentending
             the position is the last pack position so that the
             stream completes on a pack start when seeking
         */
         pStream->ParseBytes(pbPacket + lHeaderSize,
                             lPacketSize - lHeaderSize,
                             m_bConcatenatedStreams && m_State == State_Seeking ?
                                 m_llPositionForCurrentClock - 8:
                                 m_llPos,
                             bHasPts,
                             stc);
    } else {
        DbgLog((LOG_TRACE, 4, TEXT("Not processing packet for stream %2.2X"),
                uStreamId));
    }

    if ((m_State == State_Run || m_State == State_Stopping) && bPlaying) {
        HRESULT hr;
        if (pStream->IsPayloadOnly()) {
            hr = m_pNotify->QueuePacket(pStream->m_uDefaultStreamId,
                                        pbPacket + lHeaderSize,
                                        lPacketSize - lHeaderSize,
                                        SampleTime(CurrentTime(pStream->CurrentSTC(bHasPts, stc))),
                                        bHasPts);
        } else {
            hr = m_pNotify->QueuePacket(pStream->m_uDefaultStreamId,
                                        pbPacket,
                                        lPacketSize,
                                        SampleTime(CurrentTime(pStream->CurrentSTC(bHasPts, stc))),
                                        bHasPts);
        }
        if (FAILED(hr)) {
            DbgLog((LOG_TRACE, 2,
                   TEXT("Failed to queue packet to output pin - stream 0x%2.2X, code 0x%8.8X"),
                   uStreamId, hr));
            /*  Don't try sending any more */
            pStream->Complete(FALSE, m_llPos, stc);
            return FALSE;
        } else {
            return TRUE;
        }
    }
    return TRUE;
}

/*  Get the id of the nth stream */
UCHAR CMpeg1SystemParse::GetStreamId(int iIndex)
{
    long lOffset = 0;
    while (lOffset + FIELD_OFFSET(SystemHeader, StreamData[0]) <
                m_lSystemHeaderSize) {
        UCHAR uId = m_SystemHeader.StreamData[lOffset];
        if (IsVideoStreamId(uId) || IsAudioStreamId(uId)) {
            if (iIndex == 0) {
                return uId;
            }
            iIndex--;
        }
        lOffset += 3;
    }
    return 0xFF;
}

CStream * CMpeg1SystemParse::AddStream(UCHAR uStreamId)
{
    /*  Only interested in audio and video */
    if (!IsVideoStreamId(uStreamId) &&
        !IsAudioStreamId(uStreamId)) {
        return NULL;
    }

    /*  See if we've got this stream type yet */

    CStream *pStreamFound = NULL;

    POSITION pos = m_lStreams.GetHeadPosition();
    while (pos) {
        CStream *pStream = m_lStreams.GetNext(pos);

        /*  If we already have a stream of the same type then just return */
        if (IsVideoStreamId(uStreamId) && IsVideoStreamId(pStream->m_uStreamId) ||
            IsAudioStreamId(uStreamId) && IsAudioStreamId(pStream->m_uStreamId)) {
            return NULL;
        }
    }

    //  Force low-res stream for VideoCD.
    if (m_bVideoCD && IsVideoStreamId(uStreamId) && uStreamId == 0xE2) {
        return NULL;
    }

    CStream *pStream;
    if (IsVideoStreamId(uStreamId)) {
        ASSERT(m_pVideoStream == NULL);
        pStream = m_pVideoStream = new CVideoParse(this, uStreamId, m_bItem);
    } else {
        pStream = new CAudioParse(this, uStreamId);
    }

    if (pStream == NULL) {
        Fail(E_OUTOFMEMORY);
        return NULL;
    }

    /*  Set the stream state */
    pStream->SetState(State_Initializing);

    /*  Add this pin to our list */
    if (m_lStreams.AddTail(pStream) == NULL) {
        delete pStream;
        Fail(E_OUTOFMEMORY);
        return NULL;
    }

    return pStream;
}

/*  Set a new substream state */
void CMpeg1SystemParse::SetState(Stream_State s)
{
    /*  State_Stopping is not a real state change */
    if (s != State_Stopping) {
        /*  If there are 0 streams let the caller know */
        if (m_lStreams.GetCount() == 0) {
            m_pNotify->Complete(FALSE, 0, MpegToReferenceTime(StartClock()));
            return;
        }
        m_nValid = 0;
        m_bCompletion = TRUE;
    }
    POSITION pos = m_lStreams.GetHeadPosition();
    while (pos) {
        m_lStreams.GetNext(pos)->SetState(s);
    }
}

/*  Callback from stream handler to say a stream has completed the
    current state transition
*/
void CMpeg1SystemParse::Complete(UCHAR uStreamId, BOOL bSuccess, LONGLONG llPos, CSTC stc)
{
    m_nValid++;
    m_bCompletion = m_bCompletion && bSuccess;

    if (m_nValid == 1) {
        m_stcComplete        = stc;
        m_llCompletePosition = llPos;
        if (m_State == State_Initializing) {
            m_stcStartPts = m_stcComplete;
            m_stcRealStartPts = m_stcStartPts;
        }
    } else {
        switch (m_State) {
        case State_Seeking:
        case State_Initializing:
            if (bSuccess) {
                if (stc < m_stcComplete) {
                    m_stcComplete = stc;
#if 1 // We just use the first PTS we find now - easier to define
                    if (m_State == State_Initializing) {
                        m_stcStartPts = m_stcComplete;
                        m_stcRealStartPts = m_stcStartPts;
                    }
#endif
                }
                if (llPos < m_llCompletePosition) {
                    m_llCompletePosition = llPos;
                }
            }
            break;

        case State_Run:
        case State_Stopping:
        case State_FindEnd:
            if (bSuccess) {
                if (stc > m_stcComplete) {
                    m_stcComplete = stc;
                }
                if (llPos > m_llCompletePosition) {
                    m_llCompletePosition = llPos;
                }
            }
            break;
        }
    }
    if (m_State == State_Initializing) {
        /*  Guess some length stuff in case we don't get a second chance */
        m_bGotDuration = TRUE;
        m_llDuration =
            llMulDiv(m_llTotalSize, MPEG_TIME_DIVISOR, m_MuxRate * 50, 0);
        if (m_pVideoStream != NULL) {
            m_dwFrameLength = (DWORD)(((double)(m_rtDuration / 10000) *
                               m_pVideoStream->m_seqInfo.fPictureRate) /
                              1000);
        }
        /*  Initialize stop time and reference time length */
        SetDurationInfo();
    } else
    if (IsComplete()) {
        REFERENCE_TIME tComplete;
        if (m_bCompletion) {
            tComplete = MpegToReferenceTime(GetStreamTime(m_stcComplete));
        } else {
            tComplete = CRefTime(0L);
        }
        if (m_State == State_Seeking) {
            if (m_bVideoCD) {
                /*  Adjust the start time to include the sector header etc */
                if (m_llCompletePosition > VIDEOCD_HEADER_SIZE) {
                    m_llCompletePosition -=
                        (LONGLONG)(
                        (LONG)(m_llCompletePosition - VIDEOCD_HEADER_SIZE) %
                            VIDEOCD_SECTOR_SIZE);

                }
            }
        } else

        if (m_State == State_FindEnd) {

            /*  Do frame length estimation if there is a video stream
                If we didn't find a GOP while seeking for the end
                we won't allow frame seeking - which is probably OK as
                there aren't enough GOPs to do it anyway
            */
            if (m_pVideoStream != NULL &&
                m_pVideoStream->m_dwFramePosition != (DWORD)-1) {
                m_dwFrameLength = m_pVideoStream->m_dwFramePosition;

                /*  Compute video offsets */
                m_rtVideoStartOffset = MpegToReferenceTime((LONGLONG)(m_pVideoStream->m_stcRealStart - m_stcStartPts));
                if (m_pVideoStream->m_bGotEnd) {
                    m_rtVideoEndOffset = MpegToReferenceTime((LONGLONG)(m_stcComplete - m_pVideoStream->m_stcEnd));
                }
            }

            /*  Estimate the duration from the mux rate =
                length / mux_rate
            */
            LONGLONG llMuxDuration = m_llDuration;

            /*  If we found valid data at the end then use it to compute
                the length
            */
            if (m_bCompletion) {
                /*  Initial stop is end of file */
                m_llDuration = GetStreamTime(m_stcComplete) - StartClock();

                /*  Check for large files */
                if (llMuxDuration > MPEG_MAX_TIME / 2) {
                    while (m_llDuration < llMuxDuration - MPEG_MAX_TIME / 2) {
                        m_llDuration += MPEG_MAX_TIME;
                    }
                } else {
                    /*  Check for concatenated files */
                    if (llMuxDuration >= (m_llDuration << 1) - MPEG_TIME_DIVISOR) {
                        DbgLog((
                            LOG_TRACE, 1,
                            TEXT("MUX size (%s) >= Computed (%s) * 2 - assuming concatenated"),
                            (LPCTSTR)CDisp(llMuxDuration, CDISP_DEC),
                            (LPCTSTR)CDisp(m_llDuration, CDISP_DEC)));

                        m_bConcatenatedStreams = TRUE;

                        /*  Don't allow frame seeking of concatenated files */
                        m_dwFrameLength = (DWORD)-1;
                        m_llDuration = llMuxDuration;
                    }
                }

            } else {
                m_llDuration = llMuxDuration;
            }
            SetDurationInfo();
        }
        m_pNotify->Complete(m_bCompletion,
                            m_llCompletePosition,
                            tComplete);
    }
}

/*  Return the starting clock of the combined stream in MPEG units
*/
LONGLONG CMpeg1SystemParse::StartClock()
{
    /*  The CSTC class correctly sign extends the clock for us */
    ASSERT(Initialized());
    return (LONGLONG)m_stcStartPts;
}



HRESULT CBasicStream::SetMediaType(const CMediaType *cmt, BOOL bPayload)
{
    m_bPayloadOnly = bPayload;
    return S_OK;
}

BOOL CStream::IsPlaying(LONGLONG llPos, LONG lLen)
{
    return (m_llStartPosition < llPos + lLen) && !m_bReachedEnd;
};


BOOL    CStream::IsPayloadOnly()
{
    return m_bPayloadOnly;
}

/*
    Set a new state
*/
void CStream::SetState(Stream_State state)
{
    /*  State_Stopping is not really a state change */
    if (state == State_Stopping) {
        if (m_bComplete) {
            return;
        }
        m_bStopping = TRUE;
        if (!m_bRunning) {
            return;
        }
        m_bRunning = FALSE;
    } else {
        m_stc = m_pStreamList->StartClock();
    }

    /*  Reinitialize 'complete' state */
    m_bComplete = FALSE;

    /*  Reinitialize the parse state */
    Init();


    if (state == State_Run) {
        m_bReachedEnd = FALSE;
    }

    if (state == State_Seeking) {
        m_llStartPosition = 0;
    }

    /*  Set new state */
    if (state == State_Stopping) {
        ASSERT(m_State == State_Run);
    } else {
        m_bStopping = FALSE;
        m_State = state;
    }
}

/*  Internal routine calls back to the stream list */
void CStream::Complete(BOOL bSuccess, LONGLONG llPos, CSTC stc)
{
    /*  Don't complete twice */
    if (m_bComplete) {
        return;
    }
    m_bRunning = FALSE;
    m_bComplete = TRUE;
    if (m_State == State_Initializing) {
        m_stcStart = stc;
    }
    if (m_State == State_Seeking) {
        if (bSuccess) {
            m_llStartPosition = llPos;
        }
    }
    if (bSuccess) {
        DbgLog((LOG_TRACE, 3, TEXT("Stream %2.2X complete OK - STC %s"),
               m_uStreamId, (LPCTSTR)CDisp(stc)));
    } else {
        DbgLog((LOG_ERROR, 2, TEXT("Complete failed for stream 0x%2.2X"),
                m_uStreamId));
    }
    m_pStreamList->Complete(m_uStreamId, bSuccess, llPos, stc);
}


/*  End of stream */
void CStream::EOS()
{
    if (!m_bComplete) {
        if (m_State == State_Run && !m_bStopping) {
            SetState(State_Stopping);
        }
        CheckComplete(TRUE);
    }
}
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\time.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

/*
        Timing stuff for MPEG

        This should really all be inline but the compiler seems to miss
        out half the code if we do that!

*/

#include <streams.h>
#include <mpgtime.h>

#if 0 //  Inline now
CSTC::CSTC(LONGLONG ll)
{
    LARGE_INTEGER li;
    li.QuadPart = ll;
    li.HighPart = -(li.HighPart & 1);
    m_ll = li.QuadPart;
};

CSTC CSTC::operator-(CSTC cstc)
{
    return CSTC(m_ll - (LONGLONG)cstc);
};

CSTC::operator LONGLONG() const
{
    ASSERT(m_ll + 0x100000000 < 0x200000000);
    return m_ll;
};

CSTC CSTC::operator=(LONGLONG ll)
{
    *this = CSTC(ll);
    return *this;
}

BOOL CSTC::operator<(CSTC cstc) const
{
    LARGE_INTEGER li;
    li.QuadPart = m_ll - cstc.m_ll;
    return (li.HighPart & 1) != 0;
};
BOOL CSTC::operator>(CSTC cstc) const
{
    return cstc < *this;
};
BOOL CSTC::operator>=(CSTC cstc) const
{
    return !(*this < cstc);
};
BOOL CSTC::operator<=(CSTC cstc) const
{
    return !(*this > cstc);
};
#endif

/*  Stream time stuff */

CMpegStreamTime::CMpegStreamTime() : m_bInitialized(FALSE)
{
};
CMpegStreamTime::~CMpegStreamTime()
{
};

void CMpegStreamTime::ResetToStart()
{
    ASSERT(m_bInitialized);
    m_llCurrentClock = m_llFirstClock;
    m_bInitialized   = TRUE;
};
void CMpegStreamTime::SeekTo(LONGLONG llGuess) {
    if (m_bInitialized) {
        m_llCurrentClock = llGuess;
    }
    StreamTimeDiscontinuity();
};
void CMpegStreamTime::SetStreamTime(CSTC cstc, LONGLONG llPosition)
{
    if (!m_bInitialized) {
        m_llCurrentClock = m_llFirstClock = (LONGLONG)cstc;
        m_bInitialized = TRUE;
    } else {
        if (!m_bTimeDiscontinuity) {
            LONGLONG llNextClock = GetStreamTime(cstc);
            if (llNextClock < m_llCurrentClock ||
                llNextClock > m_llCurrentClock + 90000) {
                DbgLog((LOG_ERROR, 1, TEXT("Invalid clock! - Previous %s, Current %s"),
                       (LPCTSTR)CDisp(m_llCurrentClock),
                       (LPCTSTR)CDisp(llNextClock)));
                StreamTimeError();

                /*  Not time is not contiguous for concatenated streams
                    mode
                */
                m_bTimeContiguous = FALSE;
            } else {
                /*  m_bTimeContiguous is set to TRUE in ParsePack for
                    concatenated streams mode
                */
            }
        } else {
            m_bTimeDiscontinuity = FALSE;
        }
        m_llCurrentClock = GetStreamTime(cstc);
    }
    m_llPositionForCurrentClock = llPosition;
};

/*  Return stream time offset in MPEG units */
LONGLONG CMpegStreamTime::GetStreamTime(CSTC cstc)
{
    ASSERT(m_bInitialized);

    /*  We should be close so apply the correction */
    return m_llCurrentClock +
           (LONGLONG)(CSTC((LONGLONG)cstc - m_llCurrentClock));
};

BOOL CMpegStreamTime::StreamTimeInitialized()
{
    return m_bInitialized;
};
void CMpegStreamTime::StreamTimeDiscontinuity()
{
    m_bTimeDiscontinuity = TRUE;
    m_bTimeContiguous = FALSE;
};

void CMpegStreamTime::StreamTimeError()
{
    return;
};

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\video.cpp ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*
     video.cpp

     Video parsing stuff for the MPEG-I splitter

     class CVideoParse

*/
#include <streams.h>
#include <mmreg.h>

#include <mpegdef.h>           // General MPEG definitions
#include <mpgtime.h>
#include <mpegprse.h>          // Parsing
#include <seqhdr.h>            // ParseSequenceHeader
#include "video.h"

#ifdef DEBUG
LPCTSTR PictureTypes[8]   = { TEXT("forbidden frame type"),
                              TEXT("I-Frame"),
                              TEXT("P-Frame"),
                              TEXT("B-Frame"),
                              TEXT("D-Frame"),
                              TEXT("Reserved frame type"),
                              TEXT("Reserved frame type"),
                              TEXT("Reserved frame type")
                            };
LPCTSTR PelAspectRatios[16] = { TEXT("Forbidden"),
                                TEXT("1.0000 - VGA etc"),
                                TEXT("0.6735"),
                                TEXT("0.7031 - 16:9, 625 line"),
                                TEXT("0.7615"),
                                TEXT("0.8055"),
                                TEXT("0.8437 - 16:9, 525 line"),
                                TEXT("0.8935"),
                                TEXT("0.9375 - CCIR601, 625 line"),
                                TEXT("0.9815"),
                                TEXT("1.0255"),
                                TEXT("1.0695"),
                                TEXT("1.1250 - CCIR601, 525 line"),
                                TEXT("1.1575"),
                                TEXT("1.2015"),
                                TEXT("Reserved") };
LPCTSTR PictureRates[16] = { TEXT("Forbidden"),
                             TEXT("23.976"),
                             TEXT("24"),
                             TEXT("25"),
                             TEXT("29.97"),
                             TEXT("30"),
                             TEXT("50"),
                             TEXT("59.94"),
                             TEXT("60"),
                             TEXT("Reserved"),
                             TEXT("Reserved"),
                             TEXT("Reserved"),
                             TEXT("Reserved"),
                             TEXT("Reserved"),
                             TEXT("Reserved"),
                             TEXT("Reserved") };
#endif // DBG

const LONG PictureTimes[16] = { 0,
                                (LONG)((double)10000000 / 23.976),
                                (LONG)((double)10000000 / 24),
                                (LONG)((double)10000000 / 25),
                                (LONG)((double)10000000 / 29.97),
                                (LONG)((double)10000000 / 30),
                                (LONG)((double)10000000 / 50),
                                (LONG)((double)10000000 / 59.94),
                                (LONG)((double)10000000 / 60)
                              };

const float fPictureRates[] = { 0, (float)23.976, 24, 25, (float)29.97, 30, 50, (float)59.94, 60 };

const LONG AspectRatios[16] = { 2000,
                                2000,
                                (LONG)(2000.0 * 0.6735),
                                (LONG)(2000.0 * 0.7031),
                                (LONG)(2000.0 * 0.7615),
                                (LONG)(2000.0 * 0.8055),
                                (LONG)(2000.0 * 0.8437),
                                (LONG)(2000.0 * 0.8935),
                                (LONG)(2000.0 * 0.9375),
                                (LONG)(2000.0 * 0.9815),
                                (LONG)(2000.0 * 1.0255),
                                (LONG)(2000.0 * 1.0695),
                                (LONG)(2000.0 * 1.1250),
                                (LONG)(2000.0 * 1.1575),
                                (LONG)(2000.0 * 1.2015),
                                2000
                              };

HRESULT GetVideoMediaType(CMediaType *cmt, BOOL bPayload, const SEQHDR_INFO *pInfo, bool bItem)
{
    cmt->majortype = MEDIATYPE_Video;
    cmt->subtype = bPayload ? MEDIASUBTYPE_MPEG1Payload :
                              MEDIASUBTYPE_MPEG1Packet;
    VIDEOINFO *videoInfo =
        (VIDEOINFO *)cmt->AllocFormatBuffer(FIELD_OFFSET(MPEG1VIDEOINFO, bSequenceHeader[pInfo->lActualHeaderLen]));
    if (videoInfo == NULL) {
        return E_OUTOFMEMORY;
    }
    RESET_HEADER(videoInfo);

    videoInfo->dwBitRate          = pInfo->dwBitRate;
    videoInfo->rcSource.right     = pInfo->lWidth;
    videoInfo->bmiHeader.biWidth  = pInfo->lWidth;
    videoInfo->rcSource.bottom    = pInfo->lHeight;
    videoInfo->bmiHeader.biHeight = pInfo->lHeight;
    videoInfo->bmiHeader.biXPelsPerMeter = pInfo->lXPelsPerMeter;
    videoInfo->bmiHeader.biYPelsPerMeter = pInfo->lYPelsPerMeter;
    videoInfo->bmiHeader.biSize   = sizeof(BITMAPINFOHEADER);

    videoInfo->AvgTimePerFrame = bItem ? UNITS : pInfo->tPictureTime;
    MPEG1VIDEOINFO *mpgvideoInfo = (MPEG1VIDEOINFO *)videoInfo;
    mpgvideoInfo->cbSequenceHeader = pInfo->lActualHeaderLen;
    CopyMemory((PVOID)mpgvideoInfo->bSequenceHeader,
               (PVOID)pInfo->RawHeader,
               pInfo->lActualHeaderLen);
    mpgvideoInfo->dwStartTimeCode = pInfo->dwStartTimeCode;


    cmt->SetFormatType(&FORMAT_MPEGVideo);
    return S_OK;
}

HRESULT CVideoParse::GetMediaType(CMediaType *cmt, int iPosition)
{
    if (iPosition > 1) {
        return VFW_S_NO_MORE_ITEMS;
    }
    if (!m_bValid) {
        DbgLog((LOG_ERROR, 1, TEXT("Asking for format on invalid stream")));
        return E_UNEXPECTED;
    }
    return GetVideoMediaType(cmt, iPosition == 0, &m_seqInfo, m_bItem);
}

//  Process a media type given to us
HRESULT CVideoParse::ProcessType(AM_MEDIA_TYPE const *pmt)
{
    //  Just process the sequence header
    if (pmt->formattype != FORMAT_VideoInfo ||
        pmt->cbFormat < sizeof(MPEG1VIDEOINFO)) {
        return E_INVALIDARG;
    }
    MPEG1VIDEOINFO *pInfo = (MPEG1VIDEOINFO *)pmt->pbFormat;
    if (pInfo->cbSequenceHeader > 140) {
        return E_INVALIDARG;
    }
    CopyMemory((PVOID)m_bData, (PVOID)pInfo->bSequenceHeader,
               pInfo->cbSequenceHeader);
    m_nLengthRequired = pInfo->cbSequenceHeader;
    ParseSequenceHeader();
    if (m_bValid) {
        return S_OK;
    } else {
        return E_INVALIDARG;
    }
}
BOOL CVideoParse::ParseSequenceHeader()
{
    if (!m_bValid) {
        if (::ParseSequenceHeader(m_bData, m_nLengthRequired, &m_seqInfo)) {
            /*  Check for quantization matrix change */
            if (m_bData[11] & 3) {
                DbgLog((LOG_TRACE, 1, TEXT("Quantization matrix change!!")));
            }
            m_bValid = TRUE;
        }
        return FALSE;
    } else {
        /*  Check for quantization matrix change */
        if (m_bData[11] & 3) {
            DbgLog((LOG_TRACE, 1, TEXT("Quantization matrix change!!")));
        }
        return FALSE;
    }
}

BOOL ParseSequenceHeader(const BYTE *pbData, LONG lData, SEQHDR_INFO *pInfo)
{
    ASSERT(*(UNALIGNED DWORD *)pbData == DWORD_SWAP(SEQUENCE_HEADER_CODE));

    /*  Check random marker bit */
    if (!(pbData[10] & 0x20)) {
        DbgLog((LOG_ERROR, 2, TEXT("Sequence header invalid marker bit")));
        return FALSE;
    }

    DWORD dwWidthAndHeight = ((DWORD)pbData[4] << 16) +
                             ((DWORD)pbData[5] << 8) +
                             ((DWORD)pbData[6]);

    pInfo->lWidth = dwWidthAndHeight >> 12;
    pInfo->lHeight = dwWidthAndHeight & 0xFFF;
    DbgLog((LOG_TRACE, 2, TEXT("Width = %d, Height = %d"),
        pInfo->lWidth,
        pInfo->lHeight));

    /* the '8' bit is the scramble flag used by sigma designs - ignore */
    BYTE PelAspectRatioAndPictureRate = pbData[7];
    if ((PelAspectRatioAndPictureRate & 0x0F) > 8) {
        PelAspectRatioAndPictureRate &= 0xF7;
    }
    DbgLog((LOG_TRACE, 2, TEXT("Pel Aspect Ratio = %s"),
        PelAspectRatios[PelAspectRatioAndPictureRate >> 4]));
    DbgLog((LOG_TRACE, 2, TEXT("Picture Rate = %s"),
        PictureRates[PelAspectRatioAndPictureRate & 0x0F]));

    if ((PelAspectRatioAndPictureRate & 0xF0) == 0 ||
        (PelAspectRatioAndPictureRate & 0x0F) == 0) {
        DbgLog((LOG_ERROR, 2, TEXT("Sequence header invalid ratio/rate")));
        return FALSE;
    }

    pInfo->tPictureTime = (LONGLONG)PictureTimes[PelAspectRatioAndPictureRate & 0x0F];
    pInfo->fPictureRate = fPictureRates[PelAspectRatioAndPictureRate & 0x0F];
    pInfo->lTimePerFrame = MulDiv((LONG)pInfo->tPictureTime, 9, 1000);

    /*  Pull out the bit rate and aspect ratio for the type */
    pInfo->dwBitRate = ((((DWORD)pbData[8] << 16) +
                   ((DWORD)pbData[9] << 8) +
                   (DWORD)pbData[10]) >> 6);
    if (pInfo->dwBitRate == 0x3FFFF) {
        DbgLog((LOG_TRACE, 2, TEXT("Variable video bit rate")));
        pInfo->dwBitRate = 0;
    } else {
        pInfo->dwBitRate *= 400;
        DbgLog((LOG_TRACE, 2, TEXT("Video bit rate is %d bits per second"),
               pInfo->dwBitRate));
    }

#if 0
#pragma message (REMIND("Get pel aspect ratio right don't call GDI - it will create a thread!"))
    /*  Get a DC */
    HDC hdc = GetDC(GetDesktopWindow());

    ASSERT(hdc != NULL);
    /*  Guess (randomly) 39.37 inches per meter */
    LONG lNotionalPelsPerMeter = MulDiv((LONG)GetDeviceCaps(hdc, LOGICALPELSX),
                                        3937, 100);
#else
    LONG lNotionalPelsPerMeter = 2000;
#endif

    pInfo->lYPelsPerMeter = lNotionalPelsPerMeter;

    pInfo->lXPelsPerMeter = AspectRatios[PelAspectRatioAndPictureRate >> 4];

    /*  Pull out the vbv */
    pInfo->lvbv = ((((LONG)pbData[10] & 0x1F) << 5) |
             ((LONG)pbData[11] >> 3)) * 2048;

    DbgLog((LOG_TRACE, 2, TEXT("vbv size is %d bytes"), pInfo->lvbv));

    /*  Check constrained parameter stuff */
    if (pbData[11] & 0x04) {
        DbgLog((LOG_TRACE, 2, TEXT("Constrained parameter video stream")));

        if (pInfo->lvbv > 40960) {
            DbgLog((LOG_ERROR, 1, TEXT("Invalid vbv (%d) for Constrained stream"),
                    pInfo->lvbv));

            /*  Have to let this through too!  bisp.mpg has this */
            /*  But constrain it since it might be random        */
            pInfo->lvbv = 40960;
        }
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("Non-Constrained parameter video stream")));
    }

#if 0  // Allow low bitrate stuff to get started
    /*  tp_orig has a vbv of 2048 (!) */
    if (pInfo->lvbv < 20000) {
        DbgLog((LOG_TRACE, 2, TEXT("Small vbv (%d) - setting to 40960"),
               pInfo->lvbv));
        pInfo->lvbv = 40960;
    }
#endif

    pInfo->lActualHeaderLen = lData;
    CopyMemory((PVOID)pInfo->RawHeader, (PVOID)pbData, pInfo->lActualHeaderLen);
    return TRUE;
}

void CVideoParse::Complete(BOOL bSuccess, LONGLONG llPos, CSTC stc)
{
    if (m_State == State_Initializing) {
        m_stcRealStart = stc;
    } else {
        if (m_State == State_FindEnd && bSuccess) {
            m_bGotEnd = true;
            m_stcEnd = stc;
        }
    }
    CStream::Complete(bSuccess, llPos, stc);
}

/*
    Check if we've completed a state change

    bForce is set at end of stream
*/
void CVideoParse::CheckComplete(BOOL bForce)
{
    ASSERT(!m_bComplete);

    /*  Have we completed a state change ? */
    CSTC stcCurrent;
    BOOL bGotTime = CurrentTime(stcCurrent);
    CSTC stcStart;

    if (bGotTime || bForce) {
        switch (m_State) {
        case State_Run:
        {
            BOOL bCompleted = FALSE;
            if (bGotTime && (stcCurrent >= m_pStreamList->GetStart())) {
                // Position should really be the end of packet in this case
                if (!m_bStopping) {
                    m_bRunning = TRUE;
                    m_pStreamList->CheckStop();
                }
                if (m_bStopping) {
                    if (stcCurrent >= m_pStreamList->GetStop()) {
                        /*  Send at least ONE frame */
                        if (!m_bWaitingForPictureEnd) {
                            m_bWaitingForPictureEnd = TRUE;
                        } else {
                            m_bReachedEnd = TRUE;
                            Complete(TRUE, m_llPos, stcCurrent);
                            bCompleted = TRUE;
                        }
                    }
                }
            }
            if (bForce && !bCompleted) {
                Complete(FALSE, m_llPos, stcCurrent);
            }
            break;
        }
        case State_Initializing:
            if (m_bValid && m_bGotTime && m_bGotIFrame) {
                /*
                    The start file position is ASSUMED to be 0 (!)
                    We assume the first b-frames can be decoded for
                    our frame count calculations
                */
                CSTC stcStart = m_stcFirst +
                    (-m_iSequenceNumberOfFirstIFrame * m_seqInfo.lTimePerFrame);
                Complete(TRUE, 0, stcStart);
            } else {
                if (bForce) {
                    Complete(FALSE, 0, stcCurrent);
                }
            }
            break;

        case State_Seeking:

            stcStart = m_pStreamList->GetStart();
            if (bGotTime && ((stcCurrent + m_seqInfo.lTimePerFrame > stcStart) || bForce)) {
                /*  If we've got an I-Frame and a clock ref by now then
                    we're all set - choose the max start position to
                    get both to start playing from
                    Otherwise we've messed up!
                */
                LONGLONG llPos;
                llPos = m_llTimePos;
                if (m_bGotIFrame && llPos > m_llStartPos) {
                    llPos = m_llStartPos;
                }
                DbgLog((LOG_TRACE, 2, TEXT("Video Seek complete Position %s - target was %s, first PTS was %s, current is %s"),
                       (LPCTSTR)CDisp(llPos),
                       (LPCTSTR)CDisp(m_pStreamList->GetStart()),
                       (LPCTSTR)CDisp(m_stcFirst),
                       (LPCTSTR)CDisp(stcCurrent)));

                /*  OK provided we can display a picture close to the
                    start time
                */
                Complete((LONGLONG)(m_stcFirst - stcStart) <= (LONGLONG)m_seqInfo.lTimePerFrame,
                         llPos,
                         stcCurrent);
            } else {
                if (bForce) {
                    DbgLog((LOG_TRACE, 1, TEXT("Seek failed for video - pos (%s)"),
                            (LPCTSTR)CDisp(bGotTime ? stcCurrent : CSTC(0))));
                    Complete(FALSE, 0, stcCurrent);
                }
            }
            break;

        case State_FindEnd:
            /*  Only finish when we're forced ! */
            if (bForce) {
                // NOTE: Position is note a useful value here
                Complete(bGotTime, m_llPos, bGotTime ? stcCurrent : CSTC(0));
            }
            break;

        default:
            DbgBreak("Setting Invalid State");
            break;
        }
    }
    /*  bForce ==> complete */
    ASSERT(m_bComplete || !bForce);
}

/*  Handle a picture group */
BOOL CVideoParse::ParseGroup()
{
    m_bGotGOP  = true;
    m_llGOPPos = m_llPos;
    DbgLog((LOG_TRACE, 3,
           TEXT("Group of pictures - time code : %s, %d hrs %d mins %d secs %d frames"),
           m_bData[4] & 0x80 ? TEXT("drop frame") : TEXT("no drop frame"),
           (m_bData[4] >> 2) & 0x1F,
           ((m_bData[4] & 0x03) << 4) + (m_bData[5] >> 4),
           ((m_bData[5] & 0x07) << 3) + (m_bData[6] >> 5),
           ((m_bData[6] & 0x1F) << 1) + (m_bData[7] >> 7)));

    if (m_dwFramePosition == (DWORD)-1) {
        if (m_seqInfo.dwStartTimeCode == (DWORD)-1) {
            m_seqInfo.dwStartTimeCode = GroupTimeCode(m_bData);
            m_dwFramePosition = 0;
        } else {
            m_dwFramePosition = FrameOffset(GroupTimeCode(m_bData), &m_seqInfo);
        }
    } else {
#ifdef DEBUG
        DWORD dwOffset = FrameOffset(GroupTimeCode(m_bData), &m_seqInfo);
        if (m_dwFramePosition != dwOffset) {
            DbgLog((LOG_ERROR, 2,
                    TEXT("Bad GOP - predicted Frame was %d, actual is %d"),
                    dwOffset, m_dwFramePosition));
        }
#endif // DEBUG
    }

    /*  Reset the video sequence */
    ResetSequence();
    return FALSE;
}

/*  Parse the header data for a PICTURE_START_CODE */
BOOL CVideoParse::ParsePicture()
{
    /*  Pull out the sequence number so we can relate any preceding I-Frame */
    int iSeqNo = ((int)m_bData[4] << 2) + (int)(m_bData[5] >> 6);

    /*  We only care if it's an I-Frame */
    DbgLog((LOG_TIMING, 3, m_bFrameHasPTS ? TEXT("%s seq no %d PTS = %s, Time = %s") : TEXT("%s seq no %d "),
           PictureTypes[(m_bData[5] >> 3) & 0x07],
           iSeqNo,
           (LPCTSTR)CDisp((LONGLONG)m_stcFrame),
           (LPCTSTR)CDisp(m_pStreamList->CurrentTime(m_stcFrame))));

    /*  Update the video state */
    NewFrame((m_bData[5] >> 3) & 0x07, iSeqNo, m_bFrameHasPTS, m_stcFrame);

    CheckComplete(FALSE);

    /*  Advanced another frame */
    if (m_dwFramePosition != (DWORD)-1) {
        m_dwFramePosition++;
    }
    m_bFrameHasPTS = FALSE;
    return m_bComplete;
}

/*
     Maintain the video parsing state machine looking for
     start codes

     When we have parsed either :

         A sequence header
         A group of pictures header
         A picture header

     call the appropriate handler
*/
BOOL CVideoParse::ParseBytes(PBYTE pData,
                             LONG lLength,
                             LONGLONG llPos,
                             BOOL bHasPts,
                             CSTC stc)
{
    if (m_bComplete || m_bRunning) {
        return FALSE;
    }

    LONG lData = lLength;

    /*  Parse all the data we've been given
    */
    PBYTE pDataNew;
    BYTE bData;

    while (lData > 0) {
        switch (m_nBytes) {
        case 0:
            /*  Look for a start code */
            pDataNew = (PBYTE)memchrInternal((PVOID)pData, 0, lData);
            if (pDataNew == NULL) {
                return FALSE;
            }
            lData -= (LONG)(pDataNew - pData) + 1;
            pData = pDataNew + 1;
            m_nBytes = 1;

            /*  CAREFUL! - the PTS that goes with a picture is the PTS
                of the packet where the first byte of the start code
                was found
            */
            m_bFrameHasPTS = bHasPts;
            m_stcFrame  = stc;
            m_llPos = llPos;
            break;

        case 1:
            bData = *pData;
            lData--;
            pData++;
            if (bData == 0) {
                m_nBytes = 2;
            } else {
                m_nBytes = 0;
            }
            break;

        case 2:
            bData = *pData;
            lData--;
            pData++;
            if (bData == 1) {
                m_nBytes = 3;
            } else {
                if (bData != 0) {
                    m_nBytes = 0;
                } else {
                    /*  So did the start code start in this buffer ? */
                    if (lLength - lData >= 2) {
                        m_bFrameHasPTS = bHasPts;
                        m_stcFrame  = stc;
                        m_llPos = llPos;
                    }
                }
            }
            break;

        case 3:
            bData = *pData;
            lData--;
            pData++;
            switch (bData) {

            case (BYTE)SEQUENCE_HEADER_CODE:
            case (BYTE)PICTURE_START_CODE:
                m_nLengthRequired = 12;
                m_bData[3] = bData;
                m_nBytes = 4;
                break;

            case (BYTE)GROUP_START_CODE:
                m_nLengthRequired = 8;
                m_bData[3] = bData;
                m_nBytes = 4;
                break;

            default:
                m_nBytes = 0;
                break;
            }
            break;

        default:
            ASSERT(m_nBytes <= m_nLengthRequired);
            if (m_nBytes < m_nLengthRequired) {
                LONG lCopy = min(lData, m_nLengthRequired - m_nBytes);
                CopyMemory((PVOID)(m_bData + m_nBytes), pData, lCopy);
                m_nBytes += lCopy;
                lData    -= lCopy;
                pData    += lCopy;
            }
            if (m_nBytes == m_nLengthRequired) {
                m_nBytes = 0;
                switch (*(DWORD *)m_bData) {
                case DWORD_SWAP(SEQUENCE_HEADER_CODE):
                    /*  Get any quantization matrices */
                    if (m_nLengthRequired == 12 &&
                        (m_bData[11] & 0x03) ||
                        m_nLengthRequired == (12 + 64) &&
                        (m_bData[11] & 0x02) &&
                        (m_bData[11 + 64] & 0x01)) {
                        m_nBytes = m_nLengthRequired;
                        m_nLengthRequired += 64;
                        break;
                    }
                    if (ParseSequenceHeader()) {
                        return TRUE;
                    }
                    break;

                case DWORD_SWAP(GROUP_START_CODE):
                    if (ParseGroup()) {
                        return TRUE;
                    }
                    break;

                case DWORD_SWAP(PICTURE_START_CODE):
                    /*  PTS applies to FIRST picture in packet */
                    if (m_bFrameHasPTS) {
                        /*  Check whether the start code start in THIS
                            buffer (in which case we eat the PTS or in
                            the last in which case the PTS in this buffer
                            refers to the NEXT picture start code (in this
                            buffer) - clear?

                            Anyway, the spec is that the PTS refers to the
                            picture whose start code STARTs in this buffer.
                        */
                        if (lLength - lData >= 4) {
                           bHasPts = FALSE;
                        }
                    }
                    if (ParsePicture()) {
                        return TRUE;
                    }
                    break;

                default:
                    DbgBreak("Unexpected start code!");
                    return FALSE;
                }
            }
        }
    }
    return FALSE;
}


/*----------------------------------------------------------------------
 *
 *   Video frame state stuff
 *
 *   This is to track the sequence numbers in the frames to work
 *   out which is the latest frame that could be rendered given the
 *   current data and what time that frame would be rendered
 *
 *----------------------------------------------------------------------*/



CVideoState::CVideoState() : m_iCurrent(-1), m_bGotEnd(false)
{
}

CVideoState::~CVideoState()
{
}

/*  Have we had any frames yet ? */
BOOL CVideoState::Initialized()
{
    return m_iCurrent >= 0;
}

void CVideoState::Init()
{
    m_bGotTime              = false;
    m_bGotIFrame            = false;
    m_bGotGOP               = false;
    m_iCurrent              = -1;
}

void CVideoParse::Init()
{
    m_nBytes                = 0;
    m_llPos                 = 0;
    m_bWaitingForPictureEnd = FALSE;
    m_dwFramePosition       = (DWORD)-1;
    m_bRunning              = FALSE;
    CVideoState::Init();
}

/*
    Return the 'current time' of the video stream

    Returns FALSE if current time is not valid
*/
BOOL CVideoParse::CurrentTime(CSTC& stc)
{
    if (!m_bGotTime || !m_bGotIFrame) {
        if (!(m_State == State_FindEnd && m_bGotTime)) {
            return FALSE;
        } else {
            /*  We don't need an iframe to calculate the extent */
            stc = m_stcVideo;
            return TRUE;
        }
    } else {
        DbgLog((LOG_TRACE, 3, TEXT("Current video time %s"),
                (LPCTSTR)CDisp(m_stcVideo)));
        stc = m_stcVideo;
        return TRUE;
    }
}

/*  New frame received */
void CVideoParse::NewFrame(int fType, int iSequence, BOOL bSTC, CSTC stc)
{
    BOOL bGotBoth = m_bGotIFrame && m_bGotTime;
    BOOL bNextI = FALSE;

    if (fType == I_Frame || fType == D_Frame) {
        /*  Help out the hardware by starting at a GOP */
        if (m_bGotGOP) {
            m_llNextIFramePos = m_llGOPPos;
        } else {
            m_llNextIFramePos = m_llPos;
        }
        if (!m_bGotIFrame) {
            m_llStartPos = m_llNextIFramePos;
            m_bGotIFrame  = TRUE;
            m_iSequenceNumberOfFirstIFrame = iSequence;
        }
    }

    int iOldCurrent = m_iCurrent;

    if (!Initialized()) {
        m_iCurrent = iSequence;
        if (m_State == State_Initializing) {
            m_iFirstSequence = 0;
        }
        m_iAhead = iSequence;
        m_Type     = fType;
    } else {
        if (fType == B_Frame) {
            if (SeqDiff(iSequence, m_iCurrent) > 0) {
                if (m_iCurrent == m_iAhead) {
                    if (m_Type != B_Frame) {
                        DbgLog((LOG_ERROR, 1, TEXT("Out of sequence B-frame")));
                    }
                    m_iAhead = iSequence;
                }
                m_iCurrent = iSequence;
            } else {
                DbgLog((LOG_TRACE, 3, TEXT("Skipping old B-Frame")));
            }
        } else {
            /*  If we're getting another I or P then we should have caught
                up with the previous one
            */
            if (m_iCurrent != m_iAhead) {
                DbgLog((LOG_ERROR, 1, TEXT("Invalid sequence number")));
                m_iCurrent = m_iAhead;
            }
            m_Type     = fType;
            m_iAhead = iSequence;
        }
        /*  See if we've caught up */
        if (SeqDiff(m_iAhead, m_iCurrent) == 1) {
            m_iCurrent = m_iAhead;
            if (m_Type == I_Frame || m_Type == D_Frame) {
                bNextI = TRUE;
            }
        }
    }

    if (bSTC) {
        m_llTimePos = m_llPos;
        if (!m_bGotTime) {
            m_bGotTime  = TRUE;
        }
        if (m_iCurrent != iSequence) {
            m_stcVideo  = stc + SeqDiff(m_iCurrent, iSequence) * m_seqInfo.lTimePerFrame;
        } else {
            m_stcVideo  = stc;
        }
    } else {
        /*  Can only go through here if we had a previous frame so
            iOldCurrent is valid
        */
        if (m_bGotTime && m_iCurrent != iOldCurrent) {
            m_stcVideo = m_stcVideo + SeqDiff(m_iCurrent, iOldCurrent) * m_seqInfo.lTimePerFrame;
        }
    }
    if (!bGotBoth) {
        CurrentTime(m_stcFirst);
    }
    if (bNextI) {
        if (!m_bGotTime || m_stcVideo < m_pStreamList->GetStart()) {
            m_llStartPos = m_llNextIFramePos;
        }
    }
    DbgLog((LOG_TRACE, 3, TEXT("Current = %d, Ahead = %d, Time = %s"),
           m_iCurrent, m_iAhead, m_bGotTime ? (LPCTSTR)CDisp(m_stcVideo) : TEXT("No PTS yet")));
}

/*  When we get a group of pictures the numbering scheme is reset */
void CVideoState::ResetSequence() {

    /*  Maintain the difference between iCurrent and iAhead -
        iAhead is always the last frame processed
    */

    /*  The spec says (2.4.1 of the video section)
        "The last coded picture, in display order, of a group of
         pictures is either an I-Picture or a P-Picture"
        So if the last one we know about is a B-picture there must
        have been another one we didn't see
    */
    if (Initialized()) {
        if (m_Type == B_Frame) {
            m_iCurrent = 0x3FF & (m_iCurrent - m_iAhead - 2);
            m_iAhead = 0x3FF & -2;
        } else {
            m_iCurrent = 0x3FF & (m_iCurrent - m_iAhead - 1);
            m_iAhead = 0x3FF & -1;
        }
    }
}
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\video.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.

/*  Frame state machine */
class CVideoState
{
public:

    CVideoState();
    ~CVideoState();

protected:
    int SeqDiff(int a, int b) {
        return (((a - b) & 0x3FF) ^ 0xFFFFFE00) + 0x200;
    };

    void Init();
    virtual void NewFrame(int fType, int iSequence, BOOL bSTC, CSTC stc) = 0;

    /*  When we get a group of pictures the numbering scheme is reset */
    void ResetSequence();

    /*  Have we had ANY frames yet? */
    BOOL Initialized();


protected:
    /*  Timing stuff */
    CSTC      m_stcFirst;          // The first time we found

    CSTC      m_stcVideo;
    int       m_Type;              // Type of m_iAhead frame
    LONGLONG  m_llTimePos;
    bool      m_bGotTime;

public:
    bool      m_bGotEnd;           // true if and only if m_stcEnd is valid

protected:
    /*  Sequence handling stuff */
    bool      m_bGotIFrame;
    bool      m_bGotGOP;
    int       m_iCurrent;
    int       m_iAhead;
    int       m_iSequenceNumberOfFirstIFrame;
    LONGLONG  m_llStartPos;
    LONGLONG  m_llNextIFramePos;
    LONGLONG  m_llGOPPos;

public:
    CSTC      m_stcRealStart;      // Start
    CSTC      m_stcEnd;            // End
};

/*  Video stream parsing */
class CVideoParse : public CStream, public CVideoState
{
public:
    CVideoParse(CStreamList *pList, UCHAR uStreamId, bool bVideoCD) :
        CStream(pList, uStreamId, bVideoCD),
        m_nBytes(0),
        m_bGotSequenceHeader(FALSE)
    {
        m_bData[0] = 0;
        m_bData[1] = 0;
        m_bData[2] = 1;
        m_seqInfo.dwStartTimeCode = (DWORD)-1;
        m_seqInfo.fPictureRate  = 1.0;
    };
    BOOL CurrentTime(CSTC& stc);
    virtual HRESULT GetMediaType(CMediaType *cmt, BOOL bPayload);
    HRESULT ProcessType(AM_MEDIA_TYPE const *pmt);
    virtual BOOL ParseBytes(PBYTE pData,
                            LONG lLen,
                            LONGLONG llPos,
                            BOOL bHasPts,
                            CSTC stc);
    void Discontinuity()
    {
        m_nBytes = 0;
        m_bDiscontinuity = TRUE;
    };

protected:
    void Init();

private:
    /*  Check if transition is complete */
    void CheckComplete(BOOL bForce);

    /*  Complete wrapper */
    void Complete(BOOL bSuccess, LONGLONG llPos, CSTC stc);

    /*  Examine a sequence header */
    BOOL ParseSequenceHeader();
    BOOL ParseGroup();
    BOOL ParsePicture();

    /*  Frame sequence handling */
    virtual void NewFrame(int fType, int iSequence, BOOL bSTC, CSTC stc);

public:
    /*  Current frame position */
    DWORD    m_dwFramePosition;

    /*  Format info */
    SEQHDR_INFO m_seqInfo;

    /*  First frame may not be start */
    int         m_iFirstSequence;

private:
    /*  Parsing stuff */
    int  m_nBytes;
    int  m_nLengthRequired;
    BYTE m_bData[MAX_SIZE_MPEG1_SEQUENCE_INFO];

    /*  Persistent state */
    BOOL m_bGotSequenceHeader;


    /*  Timing stuff */
    BOOL  m_bFrameHasPTS;
    CSTC  m_stcFrame;

    /*  Set when we're just marking time until we've got a whole picture */
    BOOL  m_bWaitingForPictureEnd;

    /*  Position */
    LONGLONG m_llPos;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\util.cpp ===
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.

/*  MPEG utility functions */
#include <objbase.h>
#include <streams.h>
#include <wxdebug.h>
#include <mmreg.h>
#include <seqhdr.h>

/******************************Public*Routine******************************\
* SkipToPacketData
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LPBYTE
SkipToPacketData(
    LPBYTE pSrc,
    long &LenLeftInPacket
    )
{
    LPBYTE  lpPacketStart;
    DWORD   bData;
    long    Length;


    //
    // Skip the stream ID and extract the packet length
    //
    pSrc += 4;
    bData = *pSrc++;
    Length = (long)((bData << 8) + *pSrc++);
    DbgLog((LOG_TRACE, 3, TEXT("Packet length %ld"), Length ));


    //
    // Record position of first byte after packet length
    //
    lpPacketStart = pSrc;


    //
    // Remove stuffing bytes
    //
    for (; ; ) {
        bData = *pSrc++;
        if (!(bData & 0x80)) {
            break;
        }
    }

    if ((bData & 0xC0) == 0x40) {
        pSrc++;
        bData = *pSrc++;
    }

    switch (bData & 0xF1) {

    case 0x21:
        pSrc += 4;
        break;

    case 0x31:
        pSrc += 9;
        break;

    default:
        if (bData != 0x0F) {
            DbgLog((LOG_TRACE, 2, TEXT("Invalid packet - 0x%2.2X\n"), bData));
            return NULL;
        }
    }

    //
    // The length left in the packet is the original length of the packet
    // less those bytes that we have just skipped over.
    //
    LenLeftInPacket = Length - (LONG)(pSrc - lpPacketStart);
    return pSrc;
}

//
//  Find the first (potential) audio frame in a buffer
//
DWORD MPEG1AudioFrameOffset(PBYTE pbData, DWORD dwLen)
{
    DWORD dwOffset = 0;
    if (dwLen == 0) {
        return (DWORD)-1;
    }
    for (;;) {
        ASSERT(dwOffset < dwLen);
        PBYTE pbFound = (PBYTE)memchrInternal((PVOID)(pbData + dwOffset), 0xFF, dwLen);
        if (pbFound == NULL) {
            return (DWORD)-1;
        }
        dwOffset = (DWORD)(pbFound - pbData);

        //  Check sync bits, id bit and layer if we can see the second byte
        if (dwOffset < (dwLen - 1) &&
            ((pbFound[1] & 0xF8) != 0xF8 ||
             (pbFound[1] & 0x06) == 0)) {

            //  Keep going
            dwOffset++;
        } else {
            return dwOffset;
        }
    }
}

//  Adjust for drop frame
DWORD FrameDropAdjust(DWORD dwGOPTimeCode)
{
    /*  Do drop frames - 2 for every minute not divisible by 10
        Note that (dwMinutes + 9) / 10 increments every time
        dwMinutes % 10 == 1 - ie we don't subtract frames for
        the first minute of each 10
    */
    DWORD dwMinutes = TimeCodeMinutes(dwGOPTimeCode);
    DWORD dwAdjust = (dwMinutes - (dwMinutes + 10 - 1) / 10) * 2;

    /*  Adjust this minute */
    if (dwMinutes % 10 != 0) {

        /*  Just ASSUME that we drop the first frame the count straight
            away and the last one at the end of the minute since this
            would keep the most faithful adherence to the frame rate
        */
        if (TimeCodeSeconds(dwGOPTimeCode) != 0) {
            dwAdjust += 2;
        }
        /*  Don't adjust the frame count - if there are frames the're
            really there !
        */
    }
    return dwAdjust;
}

//
//  Compute frame numbers
//
DWORD FrameOffset(DWORD dwGOPTimeCode, SEQHDR_INFO const *pInfo)
{
    DWORD dwRateType = pInfo->RawHeader[7] & 0x0F;

    /*  Remove the Sigma hackery */
    if (dwRateType > 8) {
        dwRateType &= 0x07;
    }

    /*  Computation depends on frame type */

    /*  For exact frames per second just compute the seconds and
        add on the frames */

#if 0
    /*  What are we supposed to do with these ? */
    if (dwRateType == 1) {
    } else
    if (dwRateType == 7) {
    } else
#endif
    {
        /*  Exact rate per second */
        static const double FramesPerSecond[] =
        { 0, 24, 24, 25, 30, 30, 50, 59.94, 60 };
        double dFramesPerSecond = FramesPerSecond[dwRateType];
        ASSERT(dFramesPerSecond != 0);
        DWORD dwFramesGOP = (DWORD)(TimeCodeSeconds(dwGOPTimeCode) *
                                    dFramesPerSecond) +
                            TimeCodeFrames(dwGOPTimeCode);
        DWORD dwFramesStart = (DWORD)(TimeCodeSeconds(pInfo->dwStartTimeCode) *
                                                      dFramesPerSecond) +
                              TimeCodeFrames(pInfo->dwStartTimeCode);
        DWORD dwFrames = dwFramesGOP - dwFramesStart;

        /*  23.976 rate drops 1 frame in 1000 */
        if (dwRateType == 1) {
            dwFrames -= (dwFramesGOP / 1000) - (dwFramesStart / 1000);
        }
        if (TimeCodeDrop(dwGOPTimeCode)) {
            dwFrames = dwFrames +
                       FrameDropAdjust(pInfo->dwStartTimeCode) -
                       FrameDropAdjust(dwGOPTimeCode);
        }
        return dwFrames;
    }

}
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\mpeg1\statepse\native.cpp ===
/******************************Module*Header*******************************\
* Module Name: Native.cpp
*
* Mpeg codec native streams definitions
*
* Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
*
* Notes:
*
*   If a video file is < 2 megabytes in length the we deduce its length by
*   counting the picture start codes.  This bypasses the problem that
*   some video files have a variable bitrate because the only tests we have
*   like this are < 2 megabytes long.
*
*   Seeking is particularly crude for video and basically fails if there
*   aren't enough Groups of Pictures on the file.
*
\**************************************************************************/

#include <streams.h>
#include <limits.h>
#include <mimeole.h> /* for CP_USASCII */
#include <malloc.h>  /* _alloca */
#include <mmreg.h>
#include <mpgtime.h>
#include <mpegprse.h>          // Parsing
#include <videocd.h>           // Video CD special parsing
#include <seqhdr.h>
#include "resource.h"          // IDS_COPYRIGHT
#include <id3.h>
#include <native.h>
#include <mpegdef.h>
#include "audio.h"

/*************************************************************************\

    CNativeVideoParse

\*************************************************************************/

HRESULT CNativeVideoParse::GetMediaType(CMediaType *cmt, int iPosition)
{
    ASSERT(m_dwFlags & FLAGS_VALID);
    if (iPosition != 0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    return GetVideoMediaType(cmt, TRUE, &m_Info);
}


/*  Format support */
HRESULT CNativeVideoParse::IsFormatSupported(const GUID *pTimeFormat)
{
    if (*pTimeFormat == TIME_FORMAT_FRAME) {
        return S_OK;
    } else {
        return CBasicParse::IsFormatSupported(pTimeFormat);
    }
}

//  Return the duration in the current time format
HRESULT CNativeParse::GetDuration(
    LONGLONG *pllDuration,
    const GUID *pTimeFormat
)    // How long is the stream?
{
    if (pTimeFormat == &TIME_FORMAT_MEDIA_TIME) {
        *pllDuration = m_Duration;
    } else {
        ASSERT(pTimeFormat == &TIME_FORMAT_FRAME);
        *pllDuration = m_dwFrames;
    }
    return S_OK;
};


// Convert times between formats
LONGLONG CNativeVideoParse::Convert(LONGLONG llOld,
                 const GUID *OldFormat,
                 const GUID *NewFormat)
{
    if (OldFormat == NewFormat) {
        return llOld;
    }

    //  Round up to time and down to frames
    if (NewFormat == &TIME_FORMAT_MEDIA_TIME) {
        ASSERT(OldFormat == &TIME_FORMAT_FRAME);
        return llMulDiv(llOld, m_Duration, m_dwFrames, m_dwFrames - 1);
    } else {
        ASSERT(NewFormat == &TIME_FORMAT_FRAME &&
               OldFormat == &TIME_FORMAT_MEDIA_TIME);
        return llMulDiv(llOld, m_dwFrames, m_Duration, 0);
    }
}

HRESULT CNativeVideoParse::Seek(LONGLONG llSeekTo,
                                REFERENCE_TIME *prtStart,
                                const GUID *pTimeFormat)
{
    DbgLog((LOG_TRACE, 2, TEXT("CNativeVideoParse::Seek(%s)"),
            (LPCTSTR)CDisp(CRefTime(llSeekTo))));

    llSeekTo = Convert(llSeekTo,
                       TimeFormat(),
                       &TIME_FORMAT_MEDIA_TIME);

    /*  Set the seek time position */
    *prtStart = llSeekTo;

    /*  Compute current */
    LONGLONG llSeek;
    if (m_bOneGOP) {

        /*  If there's only one GOP in the file we have no choice but
            to start from the beginning!
        */
        DbgLog((LOG_ERROR, 2,
                TEXT("MPEG Native stream - only 1 GOP - seeking to start!")));
        llSeek = 0;
    } else {

        /*  Seek to 1 and 1/3 seconds early and hope we get a GOP in time! */
        llSeek = llMulDiv(m_llTotalSize,
                          llSeekTo,
                          m_Duration,
                          0) -
                 (LONGLONG)(m_Info.dwBitRate / 6);
        if (llSeek < 0) {
            llSeek = 0;
        }
    }

    DbgLog((LOG_TRACE, 2, TEXT("CNativeVideoParse::Seek - seeking to byte position %s"),
            (LPCTSTR)CDisp(llSeek, CDISP_DEC)));

    /*  Do the seek immediately */
    m_llSeek = llSeekTo;
    m_pNotify->SeekTo(llSeek);

    return S_OK;
}

//  Hack because of so much badly authored content.  If the stop
//  time is at the end make it infinite.
//  This value is only used in NewSegment and in this file to
//  determine if we're at the end yet
REFERENCE_TIME CNativeVideoParse::GetStopTime()
{
    REFERENCE_TIME rtStop = CBasicParse::GetStopTime();
    if (rtStop >= m_Duration) {
        rtStop = _I64_MAX / 2;
    }
    return rtStop;
}

void CNativeVideoParse::SetSeekState()
{
    /*  This is a discontinuity */
    Discontinuity();

    DbgLog((LOG_TRACE, 2, TEXT("CNativeVideoParse::SetSeekState(%s)"),
            (LPCTSTR)CDisp(CRefTime(m_llSeek))));

    /*  Save start position and set state*/
    m_Start = m_llSeek;

    /*  Don't do any special processing for Seek
    */
    m_pNotify->Complete(TRUE, 0, 0);

}

/*  Initialization */
HRESULT CNativeVideoParse::Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt)
{
    /*  Initialize base class */
    CBasicParse::Init(llSize, bSeekable, pmt);

    /*  Initialize GOP time code */
    m_Info.dwStartTimeCode = (DWORD)-1;
    m_dwFlags = 0;
    m_nFrames = 0;
    m_nTotalFrames = 0;
    m_bBadGOP = FALSE;
    m_bOneGOP = TRUE;
    m_iMaxSequence = 0;
    m_uStreamId = (BYTE)VIDEO_STREAM;
    return S_OK;
}

/*  Check the stream for being a valid stream and determine:

    The media type by decoding a video sequence header

    If seeking is supported :
    1.  Length in bytes
    2.  Length
*/

LONG CNativeVideoParse::ParseBytes(LONGLONG llPos,
                                   PBYTE pbDataStart,
                                   LONG  lData,
                                   DWORD dwBufferFlags)
{
    /*  Note that we haven't had a picture start code yet in this buffer */
    m_rtBufferStart = (REFERENCE_TIME)-1;

    /*  To determine the media type and validate the file type we
        need to find a valid sequence header.

        Abscence of one does not prove the stream is invalid but we can't
        do anything useful unless we find one
    */
    PBYTE pbData = pbDataStart;
    LONG lDataToSend = lData;

#define SEQUENCE_HEADER_SIZE MAX_SIZE_MPEG1_SEQUENCE_INFO
    LONG lLeft = lData;
    while (lLeft >= SEQUENCE_HEADER_SIZE) {
        PBYTE pbFound = (PBYTE)memchrInternal((PVOID)pbData, 0,
                                      lLeft - (SEQUENCE_HEADER_SIZE - 1));
        if (pbFound == NULL) {

            lLeft = SEQUENCE_HEADER_SIZE - 1;
            break;
        }
        lLeft -= (LONG)(pbFound - pbData);
        pbData = pbFound;

        ASSERT(lLeft >= SEQUENCE_HEADER_SIZE);

        /*  Check if it's a valid start code */
        if ((*(UNALIGNED DWORD *)pbData & 0xFFFFFF) != 0x010000) {
            pbData++;
            lLeft--;
            continue;
        }
        DWORD dwCode = *(UNALIGNED DWORD *)pbData;
        dwCode = DWORD_SWAP(dwCode);
        if (VALID_SYSTEM_START_CODE(dwCode) && m_State == State_Initializing) {

            /*  Video should NOT contain any valid system stream start code */
            DbgLog((LOG_ERROR, 2, TEXT("Invalid system start code in video stream!")));
            m_pNotify->Complete(FALSE, 0, 0);
            return 0;
        }

        /*  Sequence header extension means MPEG-2 - this is only made
            clear in the MPEG-2 spec and is left ambiguous in the
            MPEG-1 spec
        */
        if (dwCode == EXTENSION_START_CODE) {
            DbgLog((LOG_TRACE, 2, TEXT("Sequence Header Extension ==> MPEG2")));
            m_pNotify->Complete(FALSE, 0, 0);
            return 0;
        }

        /*  If it's a sequence header code then this is it! */
        if (dwCode ==  SEQUENCE_HEADER_CODE) {
            if (!(m_dwFlags & FLAGS_GOTSEQHDR)) {
                int size = SequenceHeaderSize(pbData);

                /*  Check the sequence header and allow for quantization matrices */
                if (ParseSequenceHeader(pbData, size, &m_Info)) {

                    m_dwFlags |= FLAGS_GOTSEQHDR;

                    /*  Hack the rate for bad content (eg RedsNightMare.mpg) */
                    if (m_Info.dwBitRate == 0x3FFF * 400) {
                        if (m_Info.lWidth <= 352 && m_Info.lHeight <= 288) {
                            m_Info.dwBitRate = 0;
                        }
                    }

                    /*  just carry on so we scan at least one buffer - that
                        way we may find stray system stream codes or
                        something
                    */
                    lLeft -= size;
                    pbData += size;
                    continue;

                } else {
                    /*  Not valid */
                    m_pNotify->Complete(FALSE, 0, 0);
                    return 0;
                }
            }
        } else if (dwCode == GROUP_START_CODE) {
            if (m_dwFlags & FLAGS_GOTSEQHDR) {

                DWORD dwTimeCode = GroupTimeCode(pbData);

                DbgLog((LOG_TRACE, 3, TEXT("CNativeVideoParse - found GOP(%d:%d:%d:%d hmsf)"),
                        (dwTimeCode >> 19) & 0x1F,
                        (dwTimeCode >> 13) & 0x3F,
                        (dwTimeCode >> 6) & 0x3F,
                        dwTimeCode & 0x3F));


                /*  First time we got a GOP in this scan ? */
                if (m_dwCurrentTimeCode == (DWORD)-1) {

                    /*  Make sure we get a decent buffer for the first one */
                    if (lLeft < 2000 &&
                        pbData != pbDataStart &&
                        !(dwBufferFlags & Flags_EOS))
                    {
                        return (LONG)(pbData - pbDataStart);
                    } else {
                        lDataToSend -= (LONG)(pbData - pbDataStart);
                        pbDataStart = pbData;
                    }

                    m_dwCurrentTimeCode = dwTimeCode;

                } else {

                    /*  OK - so there's > 1 GOP */
                    m_bOneGOP = FALSE;

                    /*  Allow for bad files with all GOPs 0 or ones
                        that don't match the frame position
                    */
                    REFERENCE_TIME rtDiff =
                        ConvertTimeCode(dwTimeCode) -
                        ConvertTimeCode(m_dwCurrentTimeCode);
                    LONG rtPictures = (LONG)m_Info.tPictureTime * m_nFrames;

                    if (!m_bBadGOP &&
                        dwTimeCode != 0 &&
                        (LONG)rtDiff > rtPictures - (LONG)m_Info.tPictureTime &&
                        (LONG)rtDiff < rtPictures + (LONG)m_Info.tPictureTime
                        ) {
                        /*  If we had a previous group going we can now
                            decode its last frame
                        */
                        ComputeCurrent();

                        /*  Save latest time code */
                        m_dwCurrentTimeCode = dwTimeCode;
                    } else {
                        DbgLog((LOG_ERROR, 1, TEXT("Native MPEG video GOPs bad")));
                        m_bBadGOP = TRUE;
                    }
                }


                /*  Track stuff during initialization */
                if (m_State == State_Initializing) {
                    m_dwFlags |= FLAGS_VALID;

                    /*  We scan the whole length of 'small' files
                        counting pictures because they're full of bugs

                        However, we can't do this if we're coming off
                        the internet

                        Otherwise we just scan the end of the file hoping
                        for a Group Of Pictures to tell us where we are.
                    */
                    if (m_Info.dwStartTimeCode == (DWORD)-1) {
                        m_Info.dwStartTimeCode = m_dwCurrentTimeCode;
                        if (m_Info.dwBitRate != 0 || m_nFrames != 0) {
                            SetDurationAndBitRate(FALSE, llPos + lData - lLeft);
                            m_pNotify->Complete(TRUE, 0, 0);
                            return lData - lLeft;
                        }
                    }
                }
#if 0 // Unfortunately lots of native streams have bad time codes
                /*  Check marker bits */
                if (!(m_Info.dwCurrentTimeCode & 0x1000)) {
                    m_pNotify->Complete(FALSE, 0, 0);
                    return 0;
                }
#endif
                /*  Reset frame count */
                if (!m_bBadGOP) {
                    m_nFrames = 0;
                }

                /*  Is this GOP different from the first one we found? */
                if (m_Info.dwStartTimeCode != m_dwCurrentTimeCode) {
                    /*  OK - so there's > 1 GOP */
                    m_bOneGOP = FALSE;
                }
                lLeft -= 8;
                pbData += 8;
                continue;
            }

        /*  Only look at picture start codes if we've processed a GOP in this
            sequence
        */
        } else if (dwCode == PICTURE_START_CODE) {

            /*  Remember max sequence number for length guess algorithm
                number 3!
            */
            int iSeqNo = ((int)pbData[4] << 2) + (int)(pbData[5] >> 6);
            m_iMaxSequence = max(iSeqNo, m_iMaxSequence);

            if (m_dwCurrentTimeCode != (DWORD)-1) {
                /*  Are we scanning at the start */
                if (m_State == State_Initializing) {
                    ASSERT(m_Info.dwBitRate == 0);
                    if (m_nTotalFrames >= m_Info.fPictureRate) {
                        SetDurationAndBitRate(FALSE, llPos + lData - lLeft);
                        m_pNotify->Complete(TRUE, 0, 0);
                        return lData - lLeft;
                    }
                }
                /*  Do some computations on where we are up to
                    based on the fact that we have at least enough to
                    decode the previous picture
                */
                if (m_State == State_Run) {
                    REFERENCE_TIME tStop = GetStopTime();
                    if (m_rtCurrent > tStop) {
                        if (m_rtCurrent > tStop + m_Info.tPictureTime / 2 &&
                            m_bIFound) {
                            m_pNotify->Complete(TRUE, 0, 0);
                        }
                    }
                }

                /*  Update stats for this next picture */
                if (!m_bIFound) {
                    int iType = (pbData[5] >> 3) & 7;
                    if (iType == I_Frame || iType == D_Frame) {
                        m_bIFound = TRUE;
                    }
                }

                /*  The timestamp we want to use is the time stamp for
                    the first picture whose start code commences in this
                    buffer.

                    That time stamp is computed from the group of pictures
                    time stamp plus the sequence number of the picture
                    multiplied by the inter-frame time

                    Some files are incorrectly authored as I-Frame only
                    with the first frame having a sequence number of 1
                */
                if (m_rtBufferStart == (REFERENCE_TIME)-1) {
                    m_rtBufferStart = CurrentTime(iSeqNo);
                }

                /*  We can now decode the last frame so update our
                    count
                */
                ComputeCurrent();
                m_nFrames++;
                if (m_nTotalFrames == 0) {
                    m_lFirstFrameOffset = (LONG)llPos + lData - lLeft;
                }
                m_nTotalFrames++;
            }
        }
        lLeft  -= 3;
        pbData += 3;
    }

    /*  Completed scan of data */

    /*  If we're at the end of data process it all anyway */
    LONG lProcessed = (dwBufferFlags & Flags_EOS) ?
                          lData :
                          lData - lLeft;

    /*  Pass on data in running state */
    if (m_State == State_Run) {
        /*  Send the data on */
        if (!(dwBufferFlags & Flags_EOS)) {
            lDataToSend -= lLeft;
        }
        if (!SendData(pbDataStart, lDataToSend, llPos)) {
            return 0;
        }
    } else
    if (m_State == State_Initializing ||
        m_State == State_FindEnd) {
            if (m_State == State_Initializing) {
            /*  See if we've failed to find anything useful in our initial scan */
            if (llPos + lData > 150000 &&
                !(m_dwFlags & FLAGS_VALID)) {

                m_pNotify->Complete(FALSE, 0, 0);
                return 0;
            }
        }
        /*  If we reached the end of the file cache our results */
        if (dwBufferFlags & Flags_EOS) {
            if (m_dwFlags & FLAGS_VALID) {
                /*  Set the length etc */
                SetDurationAndBitRate(TRUE, llPos + lData - lLeft);

                /*  Do the last frame */
                if (m_dwCurrentTimeCode != (DWORD)-1) {
                    ComputeCurrent();
                }
            }
        }
    }
    return lProcessed;
}

/*  Return the preferred buffer size - 1 second */
LONG CNativeVideoParse::GetBufferSize()
{
    LONG lSize = m_Info.dwBitRate / 8;
    if (lSize < 128 * 1024) {
        lSize = 128 * 1024;
    }
    return lSize;
}

/*  Compute the size and bit rate based on the position reached */
void CNativeVideoParse::SetDurationAndBitRate(BOOL bAtEnd, LONGLONG llPos)
{
    REFERENCE_TIME rtBitRateDuration;
    if (m_Info.dwBitRate != 0) {
        rtBitRateDuration  = (REFERENCE_TIME)llMulDiv(m_llTotalSize,
                                                      (LONG)UNITS * 8,
                                                      m_Info.dwBitRate,
                                                      0);
    }
    if (m_dwCurrentTimeCode != (DWORD)-1 && bAtEnd && !m_bBadGOP && !m_bOneGOP) {
        m_Duration = m_rtCurrent;
        /*  Also set a pseudo bit-rate */
        if (m_Info.dwBitRate == 0) {
            m_Info.dwBitRate = (DWORD)llMulDiv(m_llTotalSize,
                                               UNITS * 8,
                                               m_Duration,
                                               0);
        } else {
            /*  Believe the bit rate - pick up GOPs */
            if (m_Duration < rtBitRateDuration / 2 ||
                m_Duration > rtBitRateDuration * 2) {
                m_Duration = rtBitRateDuration;
                m_bBadGOP = TRUE;
            }
        }
    } else {
        /*  HOPE (!) that we found a reasonable bit rate */
        if (m_Info.dwBitRate == 0) {
            /*  Maybe we can guess by the biggest sequence number
                we got (!)
            */
            if (bAtEnd && m_bOneGOP) {
                m_Duration = m_Info.tPictureTime * m_iMaxSequence;
            } else {
                /*  Guess the bitrate based on the bit rate near the start */
                m_Duration = llMulDiv(m_llTotalSize,
                                      m_nTotalFrames * (LONG)m_Info.tPictureTime,
                                      (LONG)llPos - m_lFirstFrameOffset,
                                      0);
            }
        } else {
            m_Duration = rtBitRateDuration;
        }
    }

    /*  Initialize stop time */
    m_Stop = m_Duration;

    /*  Set the frame size */
    m_dwFrames = (DWORD)((m_Duration + ((LONG)m_Info.tPictureTime - 1)) /
                         (LONG)m_Info.tPictureTime);
}

/*  Convert a time code to a reference time */
REFERENCE_TIME CNativeVideoParse::ConvertTimeCode(DWORD dwCode)
{
    REFERENCE_TIME t;
    DWORD dwSecs = TimeCodeSeconds(dwCode);

    t = UInt32x32To64(dwSecs, UNITS) +
        UInt32x32To64((DWORD)m_Info.tPictureTime, TimeCodeFrames(dwCode));
    return t;
}

/*  Compute the stream time for a group of pictures time code */
REFERENCE_TIME CNativeVideoParse::ComputeTime(DWORD dwTimeCode)
{
    return ConvertTimeCode(dwTimeCode) - ConvertTimeCode(m_Info.dwStartTimeCode);
}

/*  Send a video chunk to our output */
BOOL CNativeVideoParse::SendData(PBYTE pbData, LONG lSize, LONGLONG llPos)
{
    /*  Don't send anything before the first GOP */
    if (m_dwCurrentTimeCode == (DWORD)-1) {
        /*  Not reached a GOP yet - don't pass anything on */
        ASSERT(m_rtBufferStart == (REFERENCE_TIME)-1);
        return TRUE;
    }

    REFERENCE_TIME rtBuffer = m_rtBufferStart;

    /*  If there are bad GOPs only put a timestamp at the start */
    if (m_bBadGOP || m_bOneGOP) {
        if (m_bDiscontinuity) {
            //  Make a guess about where we are since we can't rely
            //  on the GOPs
            rtBuffer = m_bOneGOP ?
                           -m_Start :
                           (REFERENCE_TIME)llMulDiv(llPos,
                                                    m_Duration,
                                                    m_llTotalSize,
                                                    0) -
                           m_Start;
        } else {
            rtBuffer = (REFERENCE_TIME)-1;
        }
    } else {
        if (rtBuffer != (REFERENCE_TIME)-1) {
            rtBuffer -= m_Start;
        }
    }
    if (m_Rate != 1.0 && rtBuffer != (REFERENCE_TIME)-1) {
        if (m_Rate == 0.0) {
            //  Never play anything
            rtBuffer = (REFERENCE_TIME)-1;
        } else {
            rtBuffer = (REFERENCE_TIME)(rtBuffer / m_Rate);
        }
    }

    /*  Send packets on */

    while (lSize > 0) {
#define MAX_VIDEO_SIZE 50000
        LONG lData = lSize;
        if (lData > MAX_VIDEO_SIZE) {
            lData = (MAX_VIDEO_SIZE * 4) / 5;
        }

        /*  Calling this will clear m_bDiscontinuity */
        ASSERT(!m_bDiscontinuity || rtBuffer != (REFERENCE_TIME)-1 ||
               m_Rate == 0.0);
        HRESULT hr =
            m_pNotify->QueuePacket(m_uStreamId,
                                   pbData,
                                   lData,
                                   rtBuffer,
                                   m_bDiscontinuity);
        if (S_OK != hr) {
            m_pNotify->Complete(TRUE, 0, 0);
            return FALSE;
        }
        rtBuffer = (REFERENCE_TIME)-1;
        lSize -= lData;
        pbData += lData;
    }

    m_rtBufferStart = (REFERENCE_TIME)-1;
    return TRUE;
}

/*  Compute where we're up to.

    This is called each time we decode a frame or a group of
    pictures or end of sequence.

    The first frame of each group of pictures (m_nFrames == 0) is
    ignored and counted in at the end of the group.

    If m_nFrames is 1 we're effectively up to the first frame
    in this group so we re-origin to the current group.
*/
void CNativeVideoParse::ComputeCurrent()
{
    ASSERT(m_dwCurrentTimeCode != (DWORD)-1);
    if (m_nFrames != 0) {
        if (m_nFrames == 1) {
            /*  Group start time not yet included */
            m_rtCurrent = ComputeTime(m_dwCurrentTimeCode);
        } else {

            /*  We can compute one more frame */
            m_rtCurrent += m_Info.tPictureTime;
        }
    }
}

/*************************************************************************\

    CNativeAudioParse

\*************************************************************************/

HRESULT CNativeAudioParse::Init(LONGLONG llSize, BOOL bSeekable, CMediaType const *pmt)
{
    /*  Initialize base class */
    CBasicParse::Init(llSize, bSeekable, pmt);

    ASSERT(m_pbID3 == NULL);

    m_uStreamId = (BYTE)AUDIO_STREAM;
    return S_OK;
}

/*  Get audio type */
HRESULT CNativeAudioParse::GetMediaType(CMediaType *cmt, int iPosition)
{
    ASSERT(m_dwFlags & FLAGS_VALID);
    if (iPosition == 0 || iPosition == 1) {
        cmt->SetFormat((PBYTE)&m_Info, sizeof(m_Info));
        cmt->subtype = iPosition == 1 ?
            MEDIASUBTYPE_MPEG1Payload :
            MEDIASUBTYPE_MPEG1AudioPayload;
    } else if (iPosition == 2) {
        if (m_Info.fwHeadLayer != ACM_MPEG_LAYER3) {
            return VFW_S_NO_MORE_ITEMS;
        }
        MPEGLAYER3WAVEFORMAT wfx;
        ConvertLayer3Format(&m_Info, &wfx);
        cmt->SetFormat((PBYTE)&wfx, sizeof(wfx));
        cmt->subtype = FOURCCMap(wfx.wfx.wFormatTag);

    } else {
        return VFW_S_NO_MORE_ITEMS;
    }
    cmt->majortype = MEDIATYPE_Audio;
    cmt->SetFormatType(&FORMAT_WaveFormatEx);
    return S_OK;
}

/*  Seek Audio to given position */
HRESULT CNativeAudioParse::Seek(LONGLONG llSeek,
                                REFERENCE_TIME *prtStart,
                                const GUID *pTimeFormat)
{
    /*  Set the seek time position */
    *prtStart = llSeek;

    ASSERT(pTimeFormat == &TIME_FORMAT_MEDIA_TIME);
    /*  Seek to 1/30 second early */
    REFERENCE_TIME rtSeek = llMulDiv(m_llTotalSize,
                                     llSeek,
                                     m_Duration,
                                     0) -
                            (REFERENCE_TIME)(m_Info.dwHeadBitrate / (30 * 8));
    if (rtSeek < 0) {
        rtSeek = 0;
    }
    m_llSeek = llSeek;

    m_pNotify->SeekTo(rtSeek);

    return S_OK;
}

/*  Set seeking state */
void CNativeAudioParse::SetSeekState()
{
    m_Start = m_llSeek;
    Discontinuity();

    m_pNotify->Complete(TRUE, 0, 0);
}

HRESULT CNativeAudioParse::SetStop(LONGLONG tStop)
{
    /*  Set to 1/80s late */
    LONGLONG llSeek = llMulDiv(m_llTotalSize,
                               tStop,
                               m_Duration,
                               0) +
                      (LONGLONG)(m_Info.dwHeadBitrate / (80 * 8));
    if (llSeek > m_llTotalSize) {
        llSeek = m_llTotalSize;
    }
    m_llStop = llSeek;
    return CBasicParse::SetStop(tStop);
}

/*  Check up to 2000 bytes for a valid start code with 3
    consecutive following frames

    Also skip any ID3v2 tag at the start

    Returns >0 - position of first valid frame
            -1 for 'not enough bytes to tell'
            -2 for 'no valid frame sequence found in first 2000 bytes'

*/
LONG CNativeAudioParse::CheckMPEGAudio(PBYTE pbData, LONG lData)
{
    const nFramesToFind = 5;

    for (int bID3 = 1; bID3 >= 0; bID3--) {
        LONG lPos = 0;
        LONG lID3;
        if (bID3) {
            /*  Skip ID3 */
            if (lData < 10) {
                return -1;
            }
            if (CID3Parse::IsV2(pbData)) {
                lPos = lID3 = CID3Parse::TotalLength(pbData);
            } else {
                //  Not ID3
                continue;
            }
        }

        LONG lFrameSearch = 2000 + lPos;

        /*  Search the first 2000 bytes for a sequence of 5 frame starts */
        for ( ; lPos < lFrameSearch; lPos++) {
            LONG lFramePosition = lPos;

            /*  Look for 5 frames in a row */
            for (int i = 0; i < nFramesToFind; i++) {

                /*  Wait for more data if we can't see the whole header */
                if (lFramePosition + 4 > lData) {
                    return -1;
                }

                /*  Get the header length - 0 means invalid header */
                DWORD dwLength = MPEGAudioFrameLength(pbData + lFramePosition);

                /*  Not a valid frame - move on to the next byte */
                if (dwLength == 0) {
                    break;
                }
                if (i == nFramesToFind - 1) {

                    /*  Save ID3 header for ID3V2.3.0 and above */
                    if (bID3) {
                        /*  Save the ID3 header */
                        m_pbID3 = new BYTE [lID3];
                        CID3Parse::DeUnSynchronize(pbData, m_pbID3);
                    } else {
                        BOOL bID3V1 = FALSE;
                        /*  see if it's ID3V1 */
                        m_pbID3 = new BYTE[128];
                        if (NULL != m_pbID3) {
                            if (S_OK == m_pNotify->Read(-128, 128, m_pbID3)) {
                                if (m_pbID3[0] == 'T' &&
                                    m_pbID3[1] == 'A' &&
                                    m_pbID3[2] == 'G') {
                                    bID3V1 = TRUE;
                                }
                            }
                            if (!bID3V1) {
                                delete [] m_pbID3;
                                m_pbID3 = NULL;
                            }
                        }
                    }
                    return lPos;
                }
                lFramePosition += dwLength;
            }
        }
    }

    /*  Failed */
    return -2;
}

/*  Parse MPEG bytes */
LONG CNativeAudioParse::ParseBytes(LONGLONG llPosition,
                                   PBYTE pbData,
                                   LONG  lData,
                                   DWORD dwBufferFlags)
{
    if (m_State == State_Initializing) {
        /*  Scan for sync word but avoid system bit streams (!!) */
        LONG lLeft = lData;
        if (lLeft >= 4) {
            PBYTE pbFound = pbData;

            /*  If we find 3 compatible frame starts in a row it's a 'go'
                in which case we start at the offset of the first
                frame in.

                We allow a random number of bytes (500) before
                giving up
            */
            LONG lPosition = CheckMPEGAudio(pbData, lData);

            if (lPosition >= 0) {
                /*  Check if this is a valid audio header.  Unfortunately
                    it doesn't have to be!
                */
                if (ParseAudioHeader(pbData + lPosition, &m_Info)) {
                    /*  Compute the duration */
                    m_Duration = ComputeTime(m_llTotalSize);
                    m_Stop = m_Duration;
                    m_llStop = m_llTotalSize;
                    m_dwFlags = FLAGS_VALID;
                    m_pNotify->Complete(TRUE, 0, 0);
                    return 0;
                }
            } else {
                if (lPosition < -1) {
                    m_pNotify->Complete(FALSE, 0, 0);
                }
                return 0;
            }
        }
        return lData - lLeft;
    } else {
        ASSERT(m_State == State_Run);
        /*  Send it on - setting a timestamp on the first packet */
        REFERENCE_TIME rtBufferStart;
        if (m_bDiscontinuity) {
            /*  Look for a frame start code and discard this section */
            LONG lPos = 0;
            for (;;) {
                if (lPos + 4 >= lData) {
                    break;
                }
                if (CheckAudioHeader(pbData + lPos)) {
                    break;
                }
                lPos++;
            }
            if (lPos != 0) {
                return lPos;
            }
            rtBufferStart = ComputeTime(llPosition) - m_Start;
        } else {
            rtBufferStart = 0;
        }

        /*  Truncate to stop position */
        if (llPosition + lData > m_llStop) {
            if (llPosition < m_llStop) {
                lData = (LONG)(m_llStop - llPosition);
            } else {
                lData = 0;
            }

            /*  Tell caller this is the last one */
            m_pNotify->Complete(TRUE, 0, 0);
        }
        LONG lSize = lData;
        while (lSize > 0) {
#define MAX_AUDIO_SIZE 10000
            LONG lToSend = lSize;
            if (lToSend > MAX_AUDIO_SIZE) {
                lToSend = (MAX_AUDIO_SIZE * 4) / 5;
            }
            HRESULT hr =
                m_pNotify->QueuePacket(m_uStreamId,
                                       pbData,
                                       lToSend,
                                       rtBufferStart,
                                       m_bDiscontinuity); // On TS on first

            if (S_OK != hr) {
                m_pNotify->Complete(TRUE, 0, 0);
                return 0;
            }
            lSize -= lToSend;
            pbData += lToSend;
        }
        return lData;
    }
}

/*  Compute time given file offset */
REFERENCE_TIME CNativeAudioParse::ComputeTime(LONGLONG llPosition)
{
    REFERENCE_TIME t;
    t = llMulDiv(llPosition,
                 8 * UNITS,
                 (LONGLONG)m_Info.dwHeadBitrate,
                 0);
    return t;
}

/*  Return the preferred buffer size - 1 second */
LONG CNativeAudioParse::GetBufferSize()
{
    return m_Info.dwHeadBitrate / 8;
}

/*  Get a media content field */
HRESULT CNativeAudioParse::GetContentField(CBasicParse::Field dwFieldId, LPOLESTR *str)
{
    if (m_pbID3 == NULL) {
        return E_NOTIMPL;
    }
    return CID3Parse::GetField(m_pbID3, dwFieldId, str);
}

/*  Content stuff */

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\audpropi\res.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define PROPPAGE_HEIGHT                 100
#define PROPPAGE_WIDTH                  240
#define IDC_MIXER_FILTER_ENABLE         3000
#define IDC_MIXER_FILTER_TREBLE_LEVEL   3001
#define IDC_MIXER_FILTER_BASS_LEVEL     3002
#define IDC_MIXER_PIN_MUTE              3003
#define IDC_MIXER_FILTER_LOUDNESS       3004
#define IDC_MIXER_FILTER_MONO           3005
#define IDC_MIXER_PIN_TREBLE_LEVEL      3006
#define IDC_MIXER_PIN_BASS_LEVEL        3007
#define IDC_MIXER_PIN_LOUDNESS          3008
#define IDC_MIXER_PIN_MONO              3009
#define IDC_MIXER_PIN_ENABLE            3012
#define IDC_MIXER_PIN_BALANCE           3013
#define IDC_MIXER_PIN_VOLUME            3014
#define IDC_MIXER_FILTER_BALANCE        3015
#define IDC_MIXER_FILTER_VOLUME         3016
#define IDC_MIXER_PIN_SELECT            3017
#define IDD_AUDIOINPUTMIXER             3050
#define IDS_AIM_PAGE_TITLE              3051
#define IDS_AIM_WINDOW_TITLE            3052
//#define IDC_STATIC                    -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\audpropi\audpropi.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#define MAX_INPUT_LINES     30
#define MIN_VOLUME_RANGE    0
#define MAX_VOLUME_RANGE    100
#define MAX_VOLUME_RANGEF   100
#define TONE_SCALE_FACTOR   10   // scale for better tone slider resolution


class CAudioInputMixerProperties;

class CAudioInputMixerProperties : public CBasePropertyPage
{

public:

    static CUnknown *WINAPI CreateInstance(LPUNKNOWN lpUnk,HRESULT *phr);
    DECLARE_IUNKNOWN;

private:

    CAudioInputMixerProperties(LPUNKNOWN pUnk,HRESULT *phr);
    ~CAudioInputMixerProperties();

    // IPropertyPage
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnDeactivate();
    HRESULT OnApplyChanges();

    // IAMAudioInputMixer dialog & data helpers
    HRESULT InitAIMDlg(HWND hwndParent);
    void    OnAIMSliderNotification(WPARAM wParam, LPARAM lParam);
    void    UpdateAIMPinControls( void );
    void    UpdateAIMFilterControls( void );
    void    SetAIMCurPinId( int iPinId ) { m_iAIMCurPinId = iPinId; }
    void    InitPinLinesAndLBContents( void );
    void    DeinitPinLines( void );
    DWORD   LinBalToKnobBal( LONG lBal );
    DWORD   LinVolToKnobVol( DWORD dwVol, DWORD dwMaxVolume );
    DWORD   KnobVolToLinVol( DWORD dwKnobVol, DWORD dwMaxVolume );
    LONG    KnobBalToLinBal( DWORD dwKnobBal );
    double  KnobLevelToToneLevel( DWORD dwKnobLevel, double dMaxLevel );
    DWORD   ToneLevelToKnobLevel( double dLevel, double dMaxLevel ); 

    double  ScaleToneLevel( double dLevel )
    {
        return dLevel * TONE_SCALE_FACTOR;
    }
    double   UnscaleToneLevel( double dScaledLevel )
    {
        return dScaledLevel/TONE_SCALE_FACTOR;
    }

    IBaseFilter * m_pFilter;

    // controls
    HWND    m_hwndAIMFilterVolSlider;
    HWND    m_hwndAIMFilterBalSlider;
    HWND    m_hwndAIMFilterBassSlider;
    HWND    m_hwndAIMFilterTrebleSlider;
    HWND    m_hwndAIMFilterEnable;
    HWND    m_hwndAIMFilterLoudness;
    HWND    m_hwndAIMFilterMono;
    HWND    m_hwndAIMPinVolSlider;
    HWND    m_hwndAIMPinBalSlider;
    HWND    m_hwndAIMPinBassSlider;
    HWND    m_hwndAIMPinTrebleSlider;
    HWND    m_hwndAIMPinEnable;
    HWND    m_hwndAIMPinLoudness;
    HWND    m_hwndAIMPinMono;
    HWND    m_hwndAIMPinSelect;

    int     m_iAIMCurPinId;             // current default input pin for dlg display

    // Filter & Pin IAMAudioInputMixer pointers
    IAMAudioInputMixer * m_pAIMFilter;
    IAMAudioInputMixer * m_apAIMPin[MAX_INPUT_LINES];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\audpropi\audpropi.cpp ===
// Copyright (c) Microsoft Corporation 1998. All Rights Reserved
 // DirectShow Input Audio Filter Property Pages, Michael Savage, August 1998

#include <streams.h>
#include <commctrl.h>
#include <tchar.h>
#include "audpropi.h"
#include "res.h"

#define AIM_CALL_TRACE_LEVEL 20 

// IAMAudioInputMixer page

// Constructor

CAudioInputMixerProperties::CAudioInputMixerProperties(LPUNKNOWN pUnk,HRESULT *phr) :
    CBasePropertyPage(NAME("Audio Input Mixer Page"),pUnk,IDD_AUDIOINPUTMIXER,IDS_AIM_PAGE_TITLE),
    m_pFilter( NULL ),
    m_pAIMFilter( NULL ),
    //filter controls
    m_hwndAIMFilterVolSlider( 0 ),    
    m_hwndAIMFilterBalSlider( 0 ),
    m_hwndAIMFilterTrebleSlider( 0 ),
    m_hwndAIMFilterBassSlider( 0 ),
    m_hwndAIMFilterEnable( 0 ),
    m_hwndAIMFilterLoudness( 0 ),
    m_hwndAIMFilterMono( 0 ),
    // pin controls
    m_hwndAIMPinVolSlider( 0 ),
    m_hwndAIMPinBalSlider( 0 ),  
    m_hwndAIMPinTrebleSlider( 0 ),
    m_hwndAIMPinBassSlider( 0 ),
    m_hwndAIMPinEnable( 0 ),
    m_hwndAIMPinLoudness( 0 ), 
    m_hwndAIMPinMono( 0 ),
    m_hwndAIMPinSelect( 0 ),
    m_iAIMCurPinId( -1 )
{
    ASSERT(phr);
    ZeroMemory( &m_apAIMPin[0], sizeof( IAMAudioInputMixer* ) * MAX_INPUT_LINES );
}

CAudioInputMixerProperties::~CAudioInputMixerProperties( void )
{
    ASSERT( !m_pFilter );
    ASSERT( !m_pAIMFilter );
}

// Create a properties object

CUnknown *WINAPI CAudioInputMixerProperties::CreateInstance(LPUNKNOWN lpUnk,HRESULT *phr)
{
    return new CAudioInputMixerProperties(lpUnk, phr);
}


// PropertyPage methods
  
// Handles the messages for our property window

INT_PTR CAudioInputMixerProperties::OnReceiveMessage(HWND hwnd,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam)
{
    HRESULT hr = S_OK;
    LRESULT iState;
    
    switch (uMsg) {

        case WM_INITDIALOG:

            InitAIMDlg( hwnd );
            UpdateAIMFilterControls();
            InitPinLinesAndLBContents();
            UpdateAIMPinControls();
            return TRUE;

        case WM_VSCROLL:
            OnAIMSliderNotification(wParam, lParam);
            return TRUE;

        case WM_HSCROLL:
            OnAIMSliderNotification(wParam, lParam);
            return TRUE;

        case WM_COMMAND:

            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                // default pin changed
                int iIndex = (int)SendMessage (m_hwndAIMPinSelect, CB_GETCURSEL, 0, 0) ;
                
                SetAIMCurPinId( iIndex );
                UpdateAIMPinControls();

                return TRUE;
            }
            else
            {
                switch (LOWORD (wParam))
                {
                    case IDC_MIXER_PIN_ENABLE: //BN_CLICKED

                        iState = SendMessage (m_hwndAIMPinEnable, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Enable( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Enable succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Enable not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 

                        return TRUE;
                        
                    case IDC_MIXER_FILTER_ENABLE:
                    
                        iState = SendMessage (m_hwndAIMFilterEnable, BM_GETCHECK, 0, 0) ;

                        m_pAIMFilter->put_Enable( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Enable succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Enable not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        
                        return TRUE;
                        
                    case IDC_MIXER_PIN_LOUDNESS: 

                        iState = SendMessage (m_hwndAIMPinLoudness, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Loudness( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Loudness succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Loudness not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                    case IDC_MIXER_FILTER_LOUDNESS:
                    
                        iState = SendMessage (m_hwndAIMFilterLoudness, BM_GETCHECK, 0, 0) ;

                        hr = m_pAIMFilter->put_Loudness( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Loudness succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Loudness not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                                        
                        return TRUE;
                        
                    case IDC_MIXER_PIN_MONO: 

                        iState = SendMessage (m_hwndAIMPinMono, BM_GETCHECK, 0, 0) ;

                        hr = m_apAIMPin[m_iAIMCurPinId]->put_Mono( iState == BST_CHECKED ? TRUE : FALSE );
                        if( FAILED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Mono succeeded")
                                        , m_iAIMCurPinId)); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (pin #%d) put_Mono not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                    case IDC_MIXER_FILTER_MONO:
                    
                        iState = SendMessage (m_hwndAIMFilterMono, BM_GETCHECK, 0, 0) ;

                        hr = m_pAIMFilter->put_Mono( iState == BST_CHECKED ? TRUE : FALSE );
                        if( SUCCEEDED( hr ) )
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Mono succeeded"))); 
                        else
                            DbgLog( (LOG_TRACE
                                  , AIM_CALL_TRACE_LEVEL
                                  , TEXT("AudioInputMixer Properties (filter) put_Mono not supported (0x%08lx)")
                                        , m_iAIMCurPinId
                                        , hr)); 
                        return TRUE;
                        
                }
            }
            return (LRESULT) 1;
    }
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}

// Tells us the object that should be informed of the property changes

HRESULT CAudioInputMixerProperties::OnConnect(IUnknown *pUnknown)
{
    ASSERT( !m_pFilter );
    ASSERT( !m_pAIMFilter );

    HRESULT hr = pUnknown->QueryInterface(IID_IBaseFilter,(void **) &m_pFilter);
    if (FAILED(hr)) {
        return E_FAIL;
    }
    
    // Make sure at least the filter supports IAMAudioInputMixer

    hr = m_pFilter->QueryInterface(IID_IAMAudioInputMixer,(void **) &m_pAIMFilter);
    if (FAILED(hr)) {
        m_pFilter->Release();
        m_pFilter = NULL;
        return E_NOINTERFACE;
    }
    ASSERT(m_pAIMFilter);
    return NOERROR;
}

HRESULT CAudioInputMixerProperties::OnDisconnect()
{
    if( m_pAIMFilter )
    {
        m_pAIMFilter->Release();
        m_pAIMFilter = NULL;
    }
    if( m_pFilter )
    {
        m_pFilter->Release();
        m_pFilter = NULL;
    }
    DeinitPinLines();
    
    return NOERROR;
}


// Create the window we will use to edit properties
HRESULT CAudioInputMixerProperties::OnActivate()
{
    return NOERROR;
}

HRESULT CAudioInputMixerProperties::OnDeactivate()
{
    DeinitPinLines();
    return NOERROR;
}


// Apply any changes so far made

HRESULT CAudioInputMixerProperties::OnApplyChanges()
{
    return S_OK;
}

//------End of IPropertyPage methods--------//


//---------Control Data Handlers------------//

//
// OnSliderNotification
//
// Handle the notification messages for the slider controls
//
void CAudioInputMixerProperties::OnAIMSliderNotification(WPARAM wParam, LPARAM lParam)
{
    int     iVPos;
    int     iBPos;
    DWORD   dwVol = 0;
    DWORD   cbData = 0;
    HRESULT hr;
    long    lLinearValue;
    long    lLogVol;    
    long    lLogBal;    
    double  Level;
    
    switch (wParam)
    {
        case TB_BOTTOM:

            break;

        case TB_TOP:

            break;

        case TB_PAGEDOWN:
        case TB_PAGEUP:

            break;

        case TB_THUMBPOSITION:
        case TB_ENDTRACK:

            // set the corresponding filter slider level
            if (lParam == (LPARAM)m_hwndAIMFilterVolSlider)
            {
                iVPos = (int) SendMessage(m_hwndAIMFilterVolSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobVolToLinVol( iVPos, MAX_VOLUME_RANGE );
            
                Level = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_pAIMFilter->put_MixLevel( Level );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_MixLevel %s succeeded"), CDisp(Level))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_MixLevel %s failed (0x%08lx)")
                                , CDisp(Level)
                                    , hr)); 
            }    
            else if( lParam == (LPARAM)m_hwndAIMFilterBalSlider)
            {
                iBPos = (int) SendMessage(m_hwndAIMFilterBalSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobBalToLinBal( iBPos );

                double Pan = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_pAIMFilter->put_Pan( Pan );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE                                
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_Pan %s succeeded"), CDisp(Pan))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) put_Pan %s not supported (0x%08lx)")
                                , CDisp(Pan)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMFilterTrebleSlider )
            {
                // first get range
                double dTrebleRange = 0;
                hr = m_pAIMFilter->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) get_TrebleRange returned %s")
                                , CDisp(dTrebleRange))); 
                
                    iVPos = (int) SendMessage(m_hwndAIMFilterTrebleSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dTrebleRange );
                    hr = m_pAIMFilter->put_Treble( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Treble %s succeeded"), CDisp(dToneLevel))); 
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Treble %s not supported (0x%08lx)")
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (filter) get_TrebleRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMFilterBassSlider )
            {
                // first get range
                double dBassRange = 0;
                hr = m_pAIMFilter->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (filter) get_BassRange returned %s")
                                , CDisp(dBassRange))); 
                                
                    iVPos = (int) SendMessage(m_hwndAIMFilterBassSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dBassRange );
                    hr = m_pAIMFilter->put_Bass( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Bass %s succeeded"), CDisp(dToneLevel))); 
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (filter) put_Bass %s not supported (0x%08lx)")
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (filter) get_BassRange not supported (0x%08lx)"), hr)); 
            }
            // Pin sliders
            else if( lParam == (LPARAM)m_hwndAIMPinVolSlider )
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                iVPos = (int) SendMessage(m_hwndAIMPinVolSlider, TBM_GETPOS, 0, 0L);
            
                lLinearValue = KnobVolToLinVol( iVPos, MAX_VOLUME_RANGE );
            
                Level = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_apAIMPin[m_iAIMCurPinId]->put_MixLevel( Level );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_MixLevel %s succeeded")
                                , m_iAIMCurPinId
                                , CDisp(Level))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_MixLevel %s failed (0x%08lx)")
                                , m_iAIMCurPinId
                                , CDisp(Level)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinBalSlider)
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                iBPos = (int) SendMessage(m_hwndAIMPinBalSlider, TBM_GETPOS, 0, 0L);
    
                lLinearValue = KnobBalToLinBal( iBPos );
            
                double Pan = (double)lLinearValue/MAX_VOLUME_RANGEF;
                hr = m_apAIMPin[m_iAIMCurPinId]->put_Pan( Pan );
                if( SUCCEEDED( hr ) )
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_Pan %s succeeded")
                                , m_iAIMCurPinId
                                , CDisp(Pan))); 
                else
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) put_Pan %s failed (0x%08lx)")
                                , m_iAIMCurPinId
                                , CDisp(Pan)
                                , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinTrebleSlider)
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                double dTrebleRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dTrebleRange))); 
                    iVPos = (int) SendMessage(m_hwndAIMPinTrebleSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dTrebleRange );
                    hr = m_apAIMPin[m_iAIMCurPinId]->put_Treble( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Treble %s succeeded")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)));
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Treble %s failed (0x%08lx)")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }
            else if( lParam == (LPARAM)m_hwndAIMPinBassSlider )
            {
                ASSERT( m_apAIMPin[m_iAIMCurPinId] );
                // first get range
                double dBassRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dBassRange))); 
                    iVPos = (int) SendMessage(m_hwndAIMPinBassSlider, TBM_GETPOS, 0, 0L);
                    
                    double dToneLevel = KnobLevelToToneLevel( iVPos, dBassRange );
                    hr = m_apAIMPin[m_iAIMCurPinId]->put_Bass( dToneLevel );
                    if( SUCCEEDED( hr ) )
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Bass %s succeeded")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)));
                    else
                        DbgLog( (LOG_TRACE
                              , AIM_CALL_TRACE_LEVEL
                              , TEXT("AudioInputMixer Properties (pin # %d) put_Bass %s failed (0x%08lx)")
                                    , m_iAIMCurPinId
                                    , CDisp(dToneLevel)
                                    , hr)); 
                }
                else
                    DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange not supported (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            }                                
            
            
            break;

        case TB_THUMBTRACK: // default handling of these messages is ok.
        case TB_LINEDOWN:
        case TB_LINEUP:

            break;
    }

} // OnSliderNotification



//
// InitAIMDlg
//
// load hwnds for all dlg controls
//
HRESULT CAudioInputMixerProperties::InitAIMDlg(HWND hwndParent)
{
    HRESULT  hr;
    
    ASSERT( m_pAIMFilter );

    // initialize control hwnds...
    // for filter
    m_hwndAIMFilterVolSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_VOLUME);
    m_hwndAIMFilterBalSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_BALANCE);
    m_hwndAIMFilterTrebleSlider =   ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_TREBLE_LEVEL);
    m_hwndAIMFilterBassSlider =     ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_BASS_LEVEL);
    m_hwndAIMFilterEnable =         ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_ENABLE);
    m_hwndAIMFilterLoudness =       ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_LOUDNESS);
    m_hwndAIMFilterMono =           ::GetDlgItem(hwndParent, IDC_MIXER_FILTER_MONO);

    // for pin
    m_hwndAIMPinVolSlider =         ::GetDlgItem(hwndParent, IDC_MIXER_PIN_VOLUME);
    m_hwndAIMPinBalSlider =         ::GetDlgItem(hwndParent, IDC_MIXER_PIN_BALANCE);
    m_hwndAIMPinTrebleSlider =      ::GetDlgItem(hwndParent, IDC_MIXER_PIN_TREBLE_LEVEL);
    m_hwndAIMPinBassSlider =        ::GetDlgItem(hwndParent, IDC_MIXER_PIN_BASS_LEVEL);
    m_hwndAIMPinEnable =            ::GetDlgItem(hwndParent, IDC_MIXER_PIN_ENABLE);
    m_hwndAIMPinLoudness =          ::GetDlgItem(hwndParent, IDC_MIXER_PIN_LOUDNESS);
    m_hwndAIMPinMono =              ::GetDlgItem(hwndParent, IDC_MIXER_PIN_MONO);
    m_hwndAIMPinSelect =            ::GetDlgItem(hwndParent, IDC_MIXER_PIN_SELECT);

    // initialize slider ranges we know
    SendMessage(m_hwndAIMFilterVolSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMFilterBalSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMPinVolSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));
    SendMessage(m_hwndAIMPinBalSlider, TBM_SETRANGE, TRUE, MAKELONG(0, MAX_VOLUME_RANGE));

    return S_OK;

}  // InitAIMDlg

//
// InitPinLinesLBContents
//
// Query filter pins for support of IAMAudioInputMixer and load list box contents
// with pins names that support the interface
//
void CAudioInputMixerProperties::InitPinLinesAndLBContents( void )
{
    ASSERT( !m_apAIMPin[0] );
    
    //
    // query the input pins for interface support
    //
    int wextent = 0 ;
    SIZE extent ;

    IEnumPins * pEnum;    
    int iInputLines = 0; 

    //
    // get a dc for the pin combo box control. need this to get the extent of the strings
    // that we put in the list box (so that we can get a horiz scroll bar).
    //
    ASSERT( m_hwndAIMPinSelect );
    HDC hdc = GetDC (m_hwndAIMPinSelect) ;
    if( NULL == hdc )
    {
        return;
    }        
    
    HRESULT hr = m_pFilter->EnumPins( &pEnum );
    ASSERT( SUCCEEDED( hr ) );
    if( SUCCEEDED( hr ) )
    {
        IPin * pPin;
        ULONG  ul;
        //
        // we use i in the loop below just to count the total input pins on the filter 
        // for help debugging, whereas iInputLines is the current count of input pins 
        // which also support IAMAudioInputMixer
        //
        for( int i = 0 ; iInputLines < MAX_INPUT_LINES; )
        {
            ASSERT( MAX_INPUT_LINES > iInputLines );
            
            hr = pEnum->Next(1,  &pPin, &ul );
            ASSERT( SUCCEEDED( hr ) );
            if( S_OK != hr )
                break;
            else if( SUCCEEDED( hr ) )
            {
                PIN_DIRECTION dir;
                hr = pPin->QueryDirection( &dir );
                if( SUCCEEDED( hr ) && PINDIR_INPUT == dir)
                {
                    // query all input pins for the interface
                    hr = pPin->QueryInterface(IID_IAMAudioInputMixer, (void **)&m_apAIMPin[iInputLines]);
                    if( FAILED( hr ) )
                    {
                        DbgLog((LOG_TRACE, AIM_CALL_TRACE_LEVEL, TEXT("Input pin %d doesn't support IAMAudioInputMixer (0x%08lx)"),i,hr));    
                    }
                    else
                    {
                        PIN_INFO pinfo;
                        
                        hr = pPin->QueryPinInfo( &pinfo );
                        if( SUCCEEDED( hr ) )
                        {
                            TCHAR szPinName[MAX_PATH];
#ifdef UNICODE
                            lstrcpy(szPinName, pinfo.achName);
#else
            	            WideCharToMultiByte( CP_ACP, 0, pinfo.achName, -1, szPinName, sizeof(szPinName), 0, 0 );
#endif
                            //
                            // get the extent of the string and save the max extent
                            //
                            GetTextExtentPoint32 (hdc, szPinName, _tcslen(szPinName), &extent) ;
                            if (extent.cx > wextent)
                                wextent = extent.cx ;
                            //
                            // add the string to the list box.
                            //
                            LRESULT ix;
                            ix = SendMessage (m_hwndAIMPinSelect, CB_INSERTSTRING, iInputLines, (LPARAM)(LPCTSTR)szPinName) ;
                            ASSERT (CB_ERR != ix);
                            
                            pinfo.pFilter->Release();
                            iInputLines++;
                        }
                    }
                    i++; // use to count total input pins
                }
                pPin->Release();
            }            
        }
        if( iInputLines )
        {
            SendMessage (m_hwndAIMPinSelect, CB_SETHORIZONTALEXTENT, wextent, 0) ;
            
            // select a default input pin line
            if( -1 == m_iAIMCurPinId || m_iAIMCurPinId >= iInputLines )
            {
                // if we don't already have one due to reactivation than pick the 1st
                m_iAIMCurPinId = 0;
            }

            // init default in,put pin to fill details in on
            SendMessage (m_hwndAIMPinSelect, CB_SETCURSEL, m_iAIMCurPinId, 0) ;
        }
        pEnum->Release();
    }
    ReleaseDC( m_hwndAIMPinSelect, hdc );    
}

//
// DeinitPinLines
//
// release IAMAudioInputMixer interface on pins
//
void CAudioInputMixerProperties::DeinitPinLines( void )
{
    // leave current m_iAIMCurPinId as is, in case we come back to the page
    for( int i = 0 ; i < MAX_INPUT_LINES && m_apAIMPin[i]; i ++)
    {
        m_apAIMPin[i]->Release();
        m_apAIMPin[i] = NULL;
    }
}

//
// UpdateAIMFilterControls
//
// Update control details for the current filter line
//
void CAudioInputMixerProperties::UpdateAIMFilterControls( void )
{
    HRESULT hr = S_OK;
    
    ASSERT( m_pAIMFilter );
    if( !m_pAIMFilter )
        return;
    
    // initialize filter control data
    double Level;
    hr = m_pAIMFilter->get_MixLevel( &Level );
    EnableWindow (m_hwndAIMFilterVolSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_MixLevel returned %s"), CDisp(Level))); 

        DWORD dwScaledLinVol = LinVolToKnobVol( (DWORD) (Level * MAX_VOLUME_RANGE)
                                              , MAX_VOLUME_RANGE );
        SendMessage(m_hwndAIMFilterVolSlider, TBM_SETPOS, TRUE, (int)(dwScaledLinVol));            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_MixLevel failed (0x%08lx)"), hr)); 
    

    double Pan;
    hr = m_pAIMFilter->get_Pan( &Pan );
    EnableWindow (m_hwndAIMFilterBalSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Pan returned %s"), CDisp(Pan))); 

        long lLinPan = (DWORD) (Pan * MAX_VOLUME_RANGEF);
        DWORD dwKnobBal = LinBalToKnobBal (lLinPan);

        SendMessage(m_hwndAIMFilterBalSlider, TBM_SETPOS, TRUE, dwKnobBal);            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Pan failed (0x%08lx)"), hr)); 

    BOOL bEnable;
    hr = m_pAIMFilter->get_Enable( &bEnable );
    EnableWindow (m_hwndAIMFilterEnable, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Enable returned %d"), bEnable)); 

        Button_SetCheck(m_hwndAIMFilterEnable, bEnable);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Enable failed (0x%08lx)"), hr)); 
    
    BOOL bMono;
    hr = m_pAIMFilter->get_Mono( &bMono );
    EnableWindow (m_hwndAIMFilterMono, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Mono returned %d"), bMono)); 
        Button_SetCheck(m_hwndAIMFilterMono, bMono);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Mono failed (0x%08lx)"), hr)); 
    
    BOOL bLoudness;
    hr = m_pAIMFilter->get_Loudness( &bLoudness );
    EnableWindow (m_hwndAIMFilterLoudness, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_LoudnessEnable returned %d"), bLoudness)); 
        Button_SetCheck(m_hwndAIMFilterLoudness, bLoudness);
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Loudness failed (0x%08lx)"), hr)); 
    
    double dTreble;
    hr = m_pAIMFilter->get_Treble( &dTreble );
    EnableWindow (m_hwndAIMFilterTrebleSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Treble returned %s"), CDisp(dTreble))); 
        
        double dTrebleRange = 0;
        hr = m_pAIMFilter->get_TrebleRange( &dTrebleRange );
        if( SUCCEEDED( hr ) )
        {
            DbgLog( (LOG_TRACE
                  , AIM_CALL_TRACE_LEVEL
                  , TEXT("AudioInputMixer Properties (filter) get_TrebleRange returned %s")
                        , CDisp(dTrebleRange))); 
        
            SendMessage( m_hwndAIMFilterTrebleSlider
                       , TBM_SETRANGE
                       , TRUE
                       , MAKELONG(0, ScaleToneLevel(dTrebleRange) ) ); // allow for + and - levels
            DWORD dwKnobLevel = ToneLevelToKnobLevel( dTreble, dTrebleRange );
            SendMessage(m_hwndAIMFilterTrebleSlider, TBM_SETPOS, TRUE, dwKnobLevel);
        }
        else
            ASSERT( FALSE ); // better not happen!
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Treble failed (0x%08lx)"), hr)); 
    
    double dBass;
    hr = m_pAIMFilter->get_Bass( &dBass );
    EnableWindow (m_hwndAIMFilterBassSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
    if( SUCCEEDED( hr ) )
    {
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Bass returned %s"), CDisp(dBass))); 
        
        double dBassRange = 0;
        hr = m_pAIMFilter->get_BassRange( &dBassRange );
        if( SUCCEEDED( hr ) )
        {
            DbgLog( (LOG_TRACE
                  , AIM_CALL_TRACE_LEVEL
                  , TEXT("AudioInputMixer Properties (filter) get_BassRange returned %s")
                        , CDisp(dBassRange))); 
            
            // assume linear for now
            SendMessage( m_hwndAIMFilterBassSlider
                       , TBM_SETRANGE
                       , TRUE
                       , MAKELONG(0, ScaleToneLevel(dBassRange) ) ); // allow for + and - levels
            DWORD dwKnobLevel = ToneLevelToKnobLevel( dBass, dBassRange );
            SendMessage(m_hwndAIMFilterBassSlider, TBM_SETPOS, TRUE, dwKnobLevel);
        }
        else
            ASSERT( FALSE ); // better not happen!            
    }
    else
        DbgLog( (LOG_TRACE
              , AIM_CALL_TRACE_LEVEL
              , TEXT("AudioInputMixer Properties (filter) get_Bass failed (0x%08lx)"), hr)); 
}

//
// UpdateAIMPinControls
//
// Fill in control details for the current pin lines
//
void CAudioInputMixerProperties::UpdateAIMPinControls( void )
{
    HRESULT hr = S_OK;
    
    // now create controls for the pin lines
    if( -1 != m_iAIMCurPinId )
    {
        // initialize the current pin line's settings
        if( m_apAIMPin[m_iAIMCurPinId] )
        {
            double Level;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_MixLevel( &Level );
            EnableWindow (m_hwndAIMPinVolSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_MixLevel returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 
                  
                DWORD dwScaledLinVol = LinVolToKnobVol( (DWORD) (Level * MAX_VOLUME_RANGE)
                                                      , MAX_VOLUME_RANGE );
                SendMessage(m_hwndAIMPinVolSlider, TBM_SETPOS, TRUE, (int)(dwScaledLinVol)); 
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_MixLevel failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
                
            double Pan;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Pan( &Pan );
            EnableWindow (m_hwndAIMPinBalSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Pan returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Pan))); 

                long lLinPan = (DWORD) (Pan * MAX_VOLUME_RANGE);
                DWORD dwKnobBal = LinBalToKnobBal (lLinPan);

                SendMessage(m_hwndAIMPinBalSlider, TBM_SETPOS, TRUE, (DWORD)(dwKnobBal));            
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Pan failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            BOOL bEnable;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Enable( &bEnable );
            EnableWindow (m_hwndAIMPinEnable, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Enable returned %d")
                            , m_iAIMCurPinId
                            , bEnable)); 
                Button_SetCheck(m_hwndAIMPinEnable, bEnable);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Enable failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            BOOL bMono;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Mono( &bMono );
            EnableWindow (m_hwndAIMPinMono, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Mono returned %d")
                            , m_iAIMCurPinId
                            , bMono)); 
                Button_SetCheck(m_hwndAIMPinMono, bMono);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Mono failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 

            BOOL bLoudness;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Loudness( &bLoudness );
            EnableWindow (m_hwndAIMPinLoudness, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Loudness returned %d")
                            , m_iAIMCurPinId
                            , bLoudness)); 
                Button_SetCheck(m_hwndAIMPinLoudness, bLoudness);
            }
            else
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Loudness failed (0x%08lx)")
                            , m_iAIMCurPinId
                            , hr)); 
            
            double dTreble;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Treble( &dTreble );
            EnableWindow (m_hwndAIMPinTrebleSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Treble returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 
                
                double dTrebleRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_TrebleRange( &dTrebleRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_TrebleRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dTrebleRange))); 
                
                    // assume linear for now
                    SendMessage( m_hwndAIMPinTrebleSlider
                               , TBM_SETRANGE
                               , TRUE
                               , MAKELONG(0, ScaleToneLevel(dTrebleRange) ) ); // allow for + and - levels
                    DWORD dwKnobLevel = ToneLevelToKnobLevel( dTreble, dTrebleRange );
                    SendMessage(m_hwndAIMPinTrebleSlider, TBM_SETPOS, TRUE, dwKnobLevel);
                }
                else
                    ASSERT( FALSE ); // better not happen!
            }
        
            double dBass;
            hr = m_apAIMPin[m_iAIMCurPinId]->get_Bass( &dBass );
            EnableWindow (m_hwndAIMPinBassSlider, SUCCEEDED( hr ) ? TRUE : FALSE);
            if( SUCCEEDED( hr ) )
            {
                DbgLog( (LOG_TRACE
                      , AIM_CALL_TRACE_LEVEL
                      , TEXT("AudioInputMixer Properties (pin # %d) get_Bass returned %s")
                            , m_iAIMCurPinId
                            , CDisp(Level))); 

                double dBassRange = 0;
                hr = m_apAIMPin[m_iAIMCurPinId]->get_BassRange( &dBassRange );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( (LOG_TRACE
                          , AIM_CALL_TRACE_LEVEL
                          , TEXT("AudioInputMixer Properties (pin # %d) get_BassRange returned %s")
                                , m_iAIMCurPinId
                                , CDisp(dBassRange))); 
                    
                    // assume linear for now
                    SendMessage( m_hwndAIMPinBassSlider
                               , TBM_SETRANGE
                               , TRUE
                               , MAKELONG(0, ScaleToneLevel(dBassRange) ) ); // allow for + and - levels
                    DWORD dwKnobLevel = ToneLevelToKnobLevel( dBass, dBassRange );
                    SendMessage(m_hwndAIMPinBassSlider, TBM_SETPOS, TRUE, dwKnobLevel);
                }
                else
                    ASSERT( FALSE ); // better not happen!    
            }
        } else {
            ASSERT(FALSE);
        }
    }
    else
    {
        // else no pins support intf, so disable all pin controls
        EnableWindow (m_hwndAIMPinVolSlider, FALSE);
        EnableWindow (m_hwndAIMPinBalSlider, FALSE);
        EnableWindow (m_hwndAIMPinEnable, FALSE);
        EnableWindow (m_hwndAIMPinMono, FALSE);
        EnableWindow (m_hwndAIMPinLoudness, FALSE);
        EnableWindow (m_hwndAIMPinTrebleSlider, FALSE);
        EnableWindow (m_hwndAIMPinBassSlider, FALSE);
    }    
}

//
// LinBalToKnobBal
//
// convert a signed linear balance value between +/- MAX_VOLUME_RANGE to an 
// unsigned dialog slider position
//
DWORD CAudioInputMixerProperties::LinBalToKnobBal( LONG lBal )
{
    DWORD dwKnobBal;
    
    if( lBal > 0 )
    {
    	dwKnobBal = (lBal - MIN_VOLUME_RANGE) / 2
        	     + (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2;
    }
    else 
    {
    	dwKnobBal = (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2
                   - (MIN_VOLUME_RANGE - lBal) / 2;
    }
    return dwKnobBal;
}

//
// LinVolToKnobVol
//
// convert a linear volume value between 0 and MaxVolume range to the 
// corresponding dialog vertical slider position.
//
DWORD CAudioInputMixerProperties::LinVolToKnobVol( DWORD dwVol, DWORD dwMaxVolume )
{
    DWORD dwKnobVol = dwMaxVolume - dwVol;

    return dwKnobVol;
}


//
// KnobBalToLinBal
//
// convert a dialog slider position to a signed linear balance value 
// between +/- MAX_VOLUME_RANGE
//
LONG CAudioInputMixerProperties::KnobBalToLinBal( DWORD dwKnobBal )
{
    LONG lLinBal;

    // In which half is the pan value?
    if( dwKnobBal > (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) {
        lLinBal = -(LONG)((MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) -
                        dwKnobBal - (MIN_VOLUME_RANGE + MAX_VOLUME_RANGE) / 2) * 2 +  
                        MIN_VOLUME_RANGE;
    }
    else
    {
        lLinBal = (dwKnobBal - (MAX_VOLUME_RANGE - MIN_VOLUME_RANGE) / 2) * 2 + 
                       MIN_VOLUME_RANGE;
    }
    return lLinBal;
}


//
// KnobVolToLinVol
//
// convert a dialog vertical slider position to a linear volume value 
// between 0 and MaxVolume
//
DWORD CAudioInputMixerProperties::KnobVolToLinVol( DWORD dwKnobVol, DWORD dwMaxVolume )
{
    DWORD dwLinVol = dwMaxVolume - dwKnobVol;

    return dwLinVol;
}

//
// KnobLevelToToneLevel
//
// convert a tone slider position to a signed db level between +/- dMaxLevel 
// just assume linear for now
//
double CAudioInputMixerProperties::KnobLevelToToneLevel( DWORD dwKnobLevel, double dMaxLevel )
{
    double dLevel;
    double dMaxKnobLevel = ScaleToneLevel(dMaxLevel); // convert to max knob level

    // In which half is the value?
    if( dwKnobLevel > dMaxKnobLevel / 2) {
        dLevel = -(dMaxKnobLevel - dwKnobLevel - dMaxKnobLevel / 2) * 2;
    }
    else
    {
        dLevel = (dwKnobLevel - dMaxKnobLevel / 2) * 2;
    }
    
    return UnscaleToneLevel(dLevel); // remove the scale factor before returning
}

//
// ToneLevelToKnobLevel
//
// convert a signed db level between +/- dMaxLevel to a tone slider positon
// just assign linear for now
//
DWORD CAudioInputMixerProperties::ToneLevelToKnobLevel( double dLevel, double dMaxLevel )
{
    DWORD dwKnobLevel;
    
    // not that we scale the levels for better slider resolution    
    if( dLevel > 0 )
    {
    	dwKnobLevel = (DWORD) ( ScaleToneLevel(dLevel) / 2 + 
                                ScaleToneLevel(dMaxLevel) / 2);
    }
    else 
    {
    	dwKnobLevel = (DWORD) ( ScaleToneLevel(dMaxLevel) / 2 - 
                              (-ScaleToneLevel(dLevel) / 2 ) );
    }
    return dwKnobLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\wavein\wavein.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

/*  Implements a digital audio source using waveInXXX apis */
/*            David Maymudes          */
/*              January 1995            */


extern const AMOVIESETUP_FILTER sudwaveInFilter ;

struct AUDIO_FORMAT_INFO  
{   
    DWORD dwType;
    WORD  wBitsPerSample;
    WORD  nChannels;
    DWORD nSamplesPerSec;
};

// This is the default list of formats types (in quality order) that we'll offer
// in GetMediaType. We use 2 arrays to build this list:
//      1) An array of defined formats in mmsystem.h that use waveInGetDevsCaps
//         info to build the list. 
//      2) An array of extra formats that aren't explicitly defined in mmsystem.h 
//         (so far we only do this for 8kHz types). We query the device directly for 
//         support of these types.

#define NO_CAPS_FLAG_FORMAT 0 

static const AUDIO_FORMAT_INFO g_afiFormats[] = 
{ 
    // let's assume 44.1k should be the default format
    {  WAVE_FORMAT_4S16,    16,  2,  44100 },
    {  WAVE_FORMAT_4M16,    16,  1,  44100 },
    {  NO_CAPS_FLAG_FORMAT, 16,  2,  32000 },
    {  NO_CAPS_FLAG_FORMAT, 16,  1,  32000 },
    {  WAVE_FORMAT_2S16,    16,  2,  22050 },
    {  WAVE_FORMAT_2M16,    16,  1,  22050 },
    {  WAVE_FORMAT_1S16,    16,  2,  11025 },
    {  WAVE_FORMAT_1M16,    16,  1,  11025 },
    {  NO_CAPS_FLAG_FORMAT, 16,  2,   8000 },
    {  NO_CAPS_FLAG_FORMAT, 16,  1,   8000 },
    {  WAVE_FORMAT_4S08,    8,   2,  44100 },
    {  WAVE_FORMAT_4M08,    8,   1,  44100 },
    {  WAVE_FORMAT_2S08,    8,   2,  22050 },
    {  WAVE_FORMAT_2M08,    8,   1,  22050 },
    {  WAVE_FORMAT_1S08,    8,   2,  11025 },
    {  WAVE_FORMAT_1M08,    8,   1,  11025 },
    {  NO_CAPS_FLAG_FORMAT, 8,   2,   8000 },
    {  NO_CAPS_FLAG_FORMAT, 8,   1,   8000 },
    //
    // now a few formats for those digital pro cards that can be set to only accept 1 type
    //
    // note that caps flags were added for 48kHz and 96kHz in Whistler, but
    // in order to be backwards compatible we can't depend on those
    //
    //{  WAVE_FORMAT_48S16,   16,  2,  48000 },
    //{  WAVE_FORMAT_48M16,   16,  1,  48000 },
    //{  WAVE_FORMAT_96S16,   16,  2,  96000 },
    //{  WAVE_FORMAT_96M16,   16,  1,  96000 }
    {  NO_CAPS_FLAG_FORMAT,   16,  2,  48000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  1,  48000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  2,  96000 },
    {  NO_CAPS_FLAG_FORMAT,   16,  1,  96000 }
};

// initialize to number of types in above array
static const DWORD g_cMaxFormats = 
                        sizeof(g_afiFormats)/sizeof(g_afiFormats[0]); 

// store the maximum types we could have. this include the format array, plus one for
// the default type.
static const DWORD g_cMaxPossibleTypes = g_cMaxFormats + 1;

// CNBQueue
//
// Non blocking version of active movie queue class
// 

template <class T> class CNBQueue {
private:
    HANDLE          hSemPut;        // Semaphore controlling queue "putting"
    HANDLE          hSemGet;        // Semaphore controlling queue "getting"
    CRITICAL_SECTION CritSect;      // Thread seriallization
    int             nMax;           // Max objects allowed in queue
    int             iNextPut;       // Array index of next "PutMsg"
    int             iNextGet;       // Array index of next "GetMsg"
    T             **QueueObjects;   // Array of objects (ptr's to void)

    HRESULT Initialize(int n) {
        iNextPut = iNextGet = 0;
        nMax = n;
        InitializeCriticalSection(&CritSect);
        hSemPut = CreateSemaphore(NULL, n, n, NULL);
        hSemGet = CreateSemaphore(NULL, 0, n, NULL);

        QueueObjects = new T*[n];
        if( NULL == hSemPut || NULL == hSemGet || NULL == QueueObjects )
        {
            return E_OUTOFMEMORY;
        }
        return S_OK;
    }


public:
    CNBQueue(int n, HRESULT *phr) {
        *phr = Initialize(n);
    }

    CNBQueue( HRESULT *phr ) {
        *phr = Initialize(DEFAULT_QUEUESIZE);
    }

    ~CNBQueue() {
        delete [] QueueObjects;
        DeleteCriticalSection(&CritSect);
        CloseHandle(hSemPut);
        CloseHandle(hSemGet);
    }

    T *GetQueueObject(BOOL fBlock = TRUE) {
        int iSlot;
        T *pObject;
        LONG lPrevious;

        if (fBlock) {
            WaitForSingleObject(hSemGet, INFINITE);
        } else {
            //
            // Check for something on the queue but don't wait.  If there
            //  is nothing in the queue then we'll let the caller deal with
            //  it.
            //
            DWORD dwr = WaitForSingleObject(hSemGet, 0);
            if (dwr == WAIT_TIMEOUT) {
                return NULL;
            }
        }

        EnterCriticalSection(&CritSect);
        iSlot = iNextGet;
        iNextGet = (iNextGet + 1) % nMax;
        pObject = QueueObjects[iSlot];
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to put an object onto our queue as there
        // is now space available in the queue.
        //
        ReleaseSemaphore(hSemPut, 1L, &lPrevious);
        return pObject;
    }

    void PutQueueObject(T *pObject) {
        int iSlot;
        LONG lPrevious;

        // Wait for someone to get something from our queue, returns straight
        // away is there is already an empty slot on the queue.
        //
        WaitForSingleObject(hSemPut, INFINITE);

        EnterCriticalSection(&CritSect);
        iSlot = iNextPut;
        iNextPut = (iNextPut + 1) % nMax;
        QueueObjects[iSlot] = pObject;
        LeaveCriticalSection(&CritSect);

        // Release anyone waiting to remove an object from our queue as there
        // is now an object available to be removed.
        //
        ReleaseSemaphore(hSemGet, 1L, &lPrevious);
    }
};


class CWaveInSample : public CMediaSample
{
public:
   CWaveInSample(
       IMemAllocator *pAllocator,
       HRESULT *phr,
       LPWAVEHDR pwh)
       :
       m_pwh(pwh),
       CMediaSample(NAME("WaveIn Sample"),
                    (CBaseAllocator *)pAllocator,
                    phr,
                    (LPBYTE)pwh->lpData,
                    (LONG)pwh->dwBufferLength)
       {
       };

   LPWAVEHDR GetWaveInHeader() {return m_pwh;};

private:
   const LPWAVEHDR m_pwh;
};


/* This is an allocator based on the abstract CBaseAllocator class
   that allocates sample buffers  */

class CWaveInAllocator : public CBaseAllocator
{
    LPWAVEFORMATEX	m_lpwfxA;
    BOOL		m_fBuffersLocked;
    HWAVE		m_hw;
    DWORD               m_dwAdvise;
    CNBQueue<CWaveInSample> *m_pQueue;
    CNBQueue<CWaveInSample> *m_pDownQueue;

protected:
    CCritSec m_csDownQueue;	// to protect dicking with the down queue

private:
    // override this to free the memory when we are inactive
    void Free(void);

    // override this to allocate and prepare memory when we become active
    HRESULT Alloc(void);
    STDMETHODIMP Commit(void);

    // called by CMediaSample to return it to the free list and
    // block any pending GetSample call.
    STDMETHODIMP ReleaseBuffer(IMediaSample * pSample);

    // to avoid wave driver bugs
    BOOL m_fAddBufferDangerous;

public:

    /* Constructors and destructors */

    CWaveInAllocator(
        TCHAR *pName,
        LPWAVEFORMATEX lpwfx,
        HRESULT *phr);
    ~CWaveInAllocator();

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest,
        ALLOCATOR_PROPERTIES* pActual
    );

    HRESULT LockBuffers(BOOL fLock = TRUE);
    HRESULT SetWaveHandle(HWAVE hw = NULL);

    friend class CWaveInFilter;
    friend class CWaveInWorker;
    friend class CWaveInOutputPin;
};


class CWaveInFilter;
class CWaveInOutputPin;

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and IMediaFilter and has a single input stream (pin)

   It will also (soon!) support IDispatch to allow it to expose some
   simple properties....

*/


// worker thread object
class CWaveInWorker : public CAMThread
{

    CWaveInOutputPin * m_pPin;

    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    void DoRunLoop(void);

public:
    CWaveInWorker();

    BOOL Create(CWaveInOutputPin * pPin);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};



/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CWaveInOutputPin : public CBaseOutputPin, public IAMStreamConfig,
			 public IAMBufferNegotiation, public CBaseStreamControl,
			 public IKsPropertySet, public IAMPushSource
{
    friend class CWaveInFilter;
    friend class CWaveInWorker;

private:

    CWaveInFilter *m_pFilter;         // The renderer that owns us

    CWaveInAllocator   *m_pOurAllocator;
    BOOL	    	m_fUsingOurAllocator;
    CWaveInWorker  	m_Worker;
    BOOL		m_fLastSampleDiscarded;
    REFERENCE_TIME	m_rtLastTimeSent;

    // for IAMBufferNegotiation
    ALLOCATOR_PROPERTIES m_propSuggested;

public:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    CWaveInOutputPin(
	CWaveInFilter *pWaveInFilter,
	HRESULT *phr,
	LPCWSTR pPinName);

    ~CWaveInOutputPin();

    // IKsPropertySet stuff
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
		DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
		DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID,
		DWORD *pTypeSupport);

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    // helper function for GetStreamCaps
    STDMETHODIMP InitWaveCaps(BOOL *pfDoesStereo, BOOL *pfDoes96, BOOL *pfDoes48, 
                              BOOL *pfDoes44,     BOOL *pfDoes22, BOOL *pfDoes16);

    HRESULT InitMediaTypes(void);

    /* IAMBufferNegotiation methods */
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *prop);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop);

    // IAMPushSource
    STDMETHODIMP SetPushSourceFlags(ULONG Flags);
    STDMETHODIMP GetPushSourceFlags(ULONG *pFlags);
    STDMETHODIMP GetLatency( REFERENCE_TIME  *prtLatency );
    STDMETHODIMP SetStreamOffset( REFERENCE_TIME  rtOffset );
    STDMETHODIMP GetStreamOffset( REFERENCE_TIME  *prtOffset );
    STDMETHODIMP GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset );
    STDMETHODIMP SetMaxStreamOffset( REFERENCE_TIME  rtMaxOffset );

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    // enumerate supported input types
    HRESULT GetMediaType(int iPosition,CMediaType *pmt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType *pmt);

    // start using this mediatype
    HRESULT SetMediaType(const CMediaType *pmt);

    // negotiate the allocator and its buffer size/count
    // calls DecideBufferSize to call SetCountAndSize
    HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);

    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking
    HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

    void Reconnect();

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // for IAMStreamControl
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    // for IAMStreamOffset
    REFERENCE_TIME m_rtLatency;
    REFERENCE_TIME m_rtStreamOffset;
    REFERENCE_TIME m_rtMaxStreamOffset;

};


class CWaveInInputPin : public CBaseInputPin, public IAMAudioInputMixer
{
public:
    CWaveInInputPin(
        TCHAR *pObjectName,
        CWaveInFilter *pFilter,
	DWORD	dwLineID,
	DWORD dwMuxIndex,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CWaveInInputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT GetMediaType(int iPosition, CMediaType*pmt);

    // IAMAudioInputMixer methods
    STDMETHODIMP put_Enable(BOOL fEnable);
    STDMETHODIMP get_Enable(BOOL *pfEnable);
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

private:
    HRESULT GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc, DWORD dWLineID = 0xffffffff);
    // different version for BPC hack
    HRESULT GetMixerControlBPC(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc);

    CWaveInFilter * m_pFilter;  // parent
    DWORD	m_dwLineID;	// which input this pin controls
    double	m_Pan;		// the last value set by put_Pan
    
    DWORD	m_dwMuxIndex;
};


class CWaveInFilter : public CBaseFilter, public CCritSec,
		      public IAMAudioInputMixer,
                      public IPersistPropertyBag,
                      public CPersistStream,
                      public IAMResourceControl,
                      public ISpecifyPropertyPages,
                      public IAMFilterMiscFlags
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
	
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    // for IAMStreamControl
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName);

    // IAMAudioInputMixer methods
    STDMETHODIMP put_Enable(BOOL fEnable) { return E_NOTIMPL;};
    STDMETHODIMP get_Enable(BOOL *pfEnable) { return E_NOTIMPL;};
    STDMETHODIMP put_Mono(BOOL fMono);
    STDMETHODIMP get_Mono(BOOL *pfMono);
    STDMETHODIMP put_Loudness(BOOL fLoudness);
    STDMETHODIMP get_Loudness(BOOL *pfLoudness);
    STDMETHODIMP put_MixLevel(double Level);
    STDMETHODIMP get_MixLevel(double FAR* pLevel);
    STDMETHODIMP put_Pan(double Pan);
    STDMETHODIMP get_Pan(double FAR* pPan);
    STDMETHODIMP put_Treble(double Treble);
    STDMETHODIMP get_Treble(double FAR* pTreble);
    STDMETHODIMP get_TrebleRange(double FAR* pRange);
    STDMETHODIMP put_Bass(double Bass);
    STDMETHODIMP get_Bass(double FAR* pBass);
    STDMETHODIMP get_BassRange(double FAR* pRange);

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    HRESULT CreatePinsOnLoad();
    HRESULT LoadDefaultType();

    // IAMResourceControl
    STDMETHODIMP Reserve(
        /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
        /*[in]*/ PVOID pvReserved        //  Must be NULL
    );

    ULONG STDMETHODCALLTYPE GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_SOURCE; }

private:
    HRESULT GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
					int *pcChannels, MIXERCONTROL *pmc);
public:

    CWaveInFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr);

    virtual ~CWaveInFilter();

    /* Return the pins that we support */

    int GetPinCount();
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // open the wave device if not already open
    // called by the wave allocator at Commit time
    HRESULT OpenWaveDevice( WAVEFORMATEX *pwfx = NULL );
    void CloseWaveDevice();

    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);

private:

    void MakeSomeInputPins(int id, HRESULT *phr);

    /* The nested classes may access our private state */

    friend class CWaveInOutputPin;
    friend class CWaveInWorker;

    /* Member variables */
    CWaveInOutputPin *m_pOutputPin;      /* IPin interface */

    CRefTime	m_rtCurrent;
    BOOL	    m_fStopping;
    DWORD       m_ulPushSourceFlags;

    LONGLONG	m_llCurSample;	// which sample number is at beginning of buffer
    REFERENCE_TIME m_llBufferTime; // clock time for 1st sample in buffer
    int		m_nLatency;	// hack for latency

    DWORD	m_dwDstLineID;	// "recording controls" line
    HWAVEIN	m_hwi;
    struct
    {
        int devnum;             // which wave card to use?
        BOOL fSet;              // set through Load?
    } m_WaveDeviceToUse;

    // BPC
    BOOL m_fUseMixer;

    int 	m_cInputPins;				// how many?
    double	m_Pan;		// the last value set by put_Pan

    int     m_cTypes;                             // number of supported types
    LPWAVEFORMATEX m_lpwfxArray[g_cMaxPossibleTypes]; // the max size needed for our
                                                      // array of supported types (including 
                                                      // 1 extra for the default type)

public:
    DWORD m_dwLockCount;                 // For IAMResourceLock

private:
// !!! better be enough
#define MAX_INPUT_PINS 25
    CWaveInInputPin *m_pInputPin[MAX_INPUT_PINS];	// our input pins

    //IReferenceClock *m_pReferenceClock;     // Our reference clock
                                            // ??? Highly dubious.
                                            // our own, or external?

    static void WaveInCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
					DWORD_PTR dw1, DWORD_PTR dw2);

    friend class CWaveInInputPin;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\wavein\wavein.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Digital audio renderer, David Maymudes, January 1995

#include <streams.h>
#include <mmsystem.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */
#include "wavein.h"
#include "audpropi.h"

// setup now done by the class manager
#if 0

const AMOVIESETUP_MEDIATYPE
sudwaveInFilterType = { &MEDIATYPE_Audio         // clsMajorType
                        , &MEDIASUBTYPE_NULL };  // clsMinorType

const AMOVIESETUP_PIN
psudwaveInFilterPins[] =  { L"Output"       // strName
                     , FALSE                // bRendered
                     , TRUE                 // bOutput
                     , FALSE                // bZero
                     , FALSE                // bMany
                     , &CLSID_NULL          // clsConnectsToFilter
                     , L"Input"             // strConnectsToPin
                     , 1                    // nTypes
                     , &sudwaveInFilterType };// lpTypes

const AMOVIESETUP_FILTER
sudwaveInFilter  = { &CLSID_AudioRecord     // clsID
                 , L"Audio Capture Filter"  // strName
                 , MERIT_DO_NOT_USE         // dwMerit
                 , 1                        // nPins
                 , psudwaveInFilterPins };  // lpPin

#endif


#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"Audio Capture Filter", &CLSID_AudioRecord, CWaveInFilter::CreateInstance },
    { L"Audio Input Properties", &CLSID_AudioInputMixerProperties, CAudioInputMixerProperties::CreateInstance }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif /* FILTER_DLL */

#define ALIGNUP(dw,align) ((LONG_PTR)(((LONG_PTR)(dw)+(align)-1) / (align)) * (align))

// CWaveInAllocator

/* Constructor must initialise the base allocator */

CWaveInAllocator::CWaveInAllocator(
    TCHAR *pName,
    LPWAVEFORMATEX waveFormat,
    HRESULT *phr)
    : CBaseAllocator(pName, NULL, phr)
    , m_fBuffersLocked(FALSE)
    , m_hw(0)
    , m_dwAdvise(0)
    , m_fAddBufferDangerous(FALSE)
{
    if (!FAILED(*phr)) {
        DbgLog((LOG_TRACE,1,TEXT("CWaveInAllocator:: constructor")));

	// Keep a copy of the format

        int cbSize = sizeof(WAVEFORMATEX);
	int cbCopy;

	// We always allocate at least sizeof(WAVEFORMATEX) to ensure
	// that we can address waveFormat->cbSize even if the user passes us
	// a WAVEFORMAT.  In this latter case we only try and copy
	// sizeof(WAVEFORMAT).

        if (waveFormat->wFormatTag != WAVE_FORMAT_PCM) {
            cbCopy = cbSize += waveFormat->cbSize;
        } else {
	    cbCopy = sizeof(WAVEFORMAT);
	}

        if (m_lpwfxA = (LPWAVEFORMATEX) new BYTE[cbSize]) {
            ZeroMemory((PVOID)m_lpwfxA, cbSize);
            CopyMemory(m_lpwfxA, waveFormat, cbCopy);
	} else {
	    *phr = E_OUTOFMEMORY;
	}
    }
}

// Called from destructor and also from base class

// all buffers have been returned to the free list and it is now time to
// go to inactive state. Unprepare all buffers and then free them.
void CWaveInAllocator::Free(void)
{
    int i;

    // unprepare the buffers
    LockBuffers(FALSE);

    CWaveInSample *pSample;      // Pointer to next sample to delete
    WAVEHDR *pwh;                // Used to retrieve the WAVEHDR

    /* Should never be deleting this unless all buffers are freed */

    ASSERT(!m_fBuffersLocked);

    DbgLog((LOG_TRACE,1,TEXT("Waveallocator: Destroying %u buffers"),
                                m_lAllocated));

    /* Free up all the CWaveInSamples */

    for (i = 0; i < m_lAllocated; i ++) {

        /* Delete the CWaveInSample object but firstly get the WAVEHDR
           structure from it so that we can clean up it's resources */

        // A blocking Get would hang if the driver was buggy and didn't return
        // all the buffers it had been given.  Well, we've seen alot of buggy
        // drivers so lets be nice and avoid hanging by using a non-blocking
        // Get.  Also, we have a down queue with the samples that we've given
        // to the driver, so we can tell which buffers never came back.
        pSample = m_pQueue->GetQueueObject(FALSE);
        if (pSample == NULL && i < m_lAllocated) {
            pSample = m_pDownQueue->GetQueueObject(FALSE);

            //
            // If the sample wasn't in the processing queue and it wasn't
            // in the down queue I'm not sure where it's gone.
            //
            ASSERT(pSample != NULL);

            // If the audio driver holds onto buffers, we just give up and
            // do not free the resources.  We do not try to release them
            // because leaking memory is always preferable to hanging or crashing
            // the system.  The Winnov driver holds onto buffers after
            // waveInReset() is called.
            break;
        }
        pwh = pSample->GetWaveInHeader();

        // delete the actual memory buffer
        delete[] (BYTE *) (pwh);

        // delete the CWaveInSample object
        delete pSample;
    }

    /* Empty the lists themselves */

    m_lAllocated = 0;

    delete m_pQueue;
    delete m_pDownQueue;

}

// the commit and decommit handle preparing and unpreparing of
// the buffers. The filter calls this to tell us the wave handle just
// after opening and just before closing the device. It is the filter's
// responsibility to ensure that Commit or Decommit calls are called in
// the right order (Commit after this, Decommit before this).
HRESULT CWaveInAllocator::SetWaveHandle(HWAVE hw)
{
    m_hw = hw;

    return NOERROR;
}

HRESULT CWaveInAllocator::LockBuffers(BOOL fLock)
{
    int i;

    if (m_fBuffersLocked == fLock)
    return NOERROR;

    if (!m_hw)
    return NOERROR;

    if (m_lAllocated == 0)
    return NOERROR;

    /* Should never be doing this unless all buffers are freed */

    DbgLog((LOG_TRACE,2,TEXT("Calling waveIn%hsrepare on %u buffers"),
        fLock ? "P" : "Unp", m_lAllocated));

    /* Prepare/unprepare up all the CWaveInSamples */

#if 1
typedef MMRESULT (WINAPI *WAVEFN)(HANDLE, LPWAVEHDR, UINT);

    WAVEFN waveFn;
    waveFn = (fLock ? (WAVEFN)waveInPrepareHeader : (WAVEFN)waveInUnprepareHeader);
#endif

    for (i = 0; i < m_lAllocated; i ++) {
        CWaveInSample *pSample = (CWaveInSample *)m_pQueue->GetQueueObject();

        WAVEHDR *pwh = pSample->GetWaveInHeader();

    UINT err;
#if 1
    err = waveFn(m_hw, pwh, sizeof(WAVEHDR));
#else
    err = (fLock ? waveInPrepareHeader : waveInUnprepareHeader)
                    ((HWAVEIN) m_hw, pwh,
                    sizeof(WAVEHDR));
#endif
        if (err > 0) {
            DbgLog((LOG_ERROR,0,TEXT("Error in waveIn%hsrepare: %u"),
                            fLock ? "P" : "Unp", err));

            // !!! Need to unprepare everything....
            ASSERT(FALSE);
                m_pQueue->PutQueueObject(pSample);
            return E_FAIL; // !!!!
        }

        m_pQueue->PutQueueObject(pSample);
    }

    m_fBuffersLocked = fLock;

    return NOERROR;
}


/* The destructor ensures the shared memory DIBs are deleted */

CWaveInAllocator::~CWaveInAllocator()
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInAllocator:: destructor")));

    delete[] (BYTE *) m_lpwfxA;
}


// Agree the number and size of buffers to be used. No memory
// is allocated until the Commit call.
STDMETHODIMP CWaveInAllocator::SetProperties(
            ALLOCATOR_PROPERTIES* pRequest,
            ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest,E_POINTER);
    CheckPointer(pActual,E_POINTER);

    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    // round the buffer size down to the requested alignment
    // !!! How important is this?  It might be undone by the next line
    Adjusted.cbBuffer -= (Adjusted.cbBuffer % m_lpwfxA->nBlockAlign);

    // round the buffer and prefix size up to the requested alignment
    Adjusted.cbBuffer = (DWORD)ALIGNUP(Adjusted.cbBuffer + Adjusted.cbPrefix,
                    Adjusted.cbAlign) - Adjusted.cbPrefix;

    if (Adjusted.cbBuffer <= 0) {
        return E_INVALIDARG;
    }

    // Don't call the base class ::SetProperties, it rejects anything
    // without align == 1! We need to connect to AVIMux, align=4, prefix=8

    /* Can't do this if already committed, there is an argument that says we
       should not reject the SetProperties call if there are buffers still
       active. However this is called by the source filter, which is the same
       person who is holding the samples. Therefore it is not unreasonable
       for them to free all their samples before changing the requirements */

    if (m_bCommitted) {
    return VFW_E_ALREADY_COMMITTED;
    }

    /* Must be no outstanding buffers */

    // !!! CQueue has no GetCount - how do we tell this?
    //if (m_lAllocated != m_lFree.GetCount())
    //    return VFW_E_BUFFERS_OUTSTANDING;

    /* There isn't any real need to check the parameters as they
       will just be rejected when the user finally calls Commit */

    pActual->cbBuffer = m_lSize = Adjusted.cbBuffer;
    pActual->cBuffers = m_lCount = Adjusted.cBuffers;
    pActual->cbAlign = m_lAlignment = Adjusted.cbAlign;
    pActual->cbPrefix = m_lPrefix = Adjusted.cbPrefix;

    DbgLog((LOG_TRACE,2,TEXT("Using: cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
                m_lCount, m_lSize, m_lAlignment, m_lPrefix));
    m_bChanged = TRUE;
    return NOERROR;
}


// allocate and prepare the buffers

STDMETHODIMP CWaveInAllocator::Commit(void) {

    // !!! I can't commit until the wave device is open.
    if (m_hw == NULL)
        return S_OK;

    return CBaseAllocator::Commit();
}


// called from base class to alloc memory when moving to commit state.
// object locked by base class
HRESULT
CWaveInAllocator::Alloc(void)
{
    int i;

    /* Check the base class says it's ok to continue */

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    // our FIFO stack of samples that are ready to deliver
    m_pQueue = new CNBQueue<CWaveInSample>(m_lCount, &hr );
    if( NULL == m_pQueue || FAILED( hr ) )
    {
        delete m_pQueue;
        m_pQueue = NULL;
        return E_OUTOFMEMORY;
    }

    m_pDownQueue = new CNBQueue<CWaveInSample>(m_lCount, &hr );
    if( NULL == m_pDownQueue || FAILED( hr ) )
    {
        delete m_pDownQueue;
        delete m_pQueue;
        m_pQueue = NULL;
        m_pDownQueue = NULL;
        return E_OUTOFMEMORY;
    }

    CWaveInSample *pSample;      // Pointer to the new sample

    // Be careful.  We are allocating memory which will look like this:
    // WAVEHDR | align bytes | prefix | memory
    // The Sample will be given "memory".  WAVEHDR.lpData will be given "memory"

    DbgLog((LOG_TRACE,1,TEXT("Allocating %d wave buffers, %d bytes each"), m_lCount, m_lSize));

    ASSERT(m_lAllocated == 0);
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
        /* Create and initialise a buffer */
        BYTE * lpMem = new BYTE[m_lSize + m_lPrefix + m_lAlignment +
                                sizeof(WAVEHDR)];
        WAVEHDR * pwh = (WAVEHDR *) lpMem;
        LPBYTE lpData = (LPBYTE)ALIGNUP(lpMem + sizeof(WAVEHDR), m_lAlignment) +
                                m_lPrefix;

        if (lpMem == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Ack! Ran out of memory for buffers!")));
            hr = E_OUTOFMEMORY;
            break;
        }

        pwh->lpData = (LPSTR)lpData;
        pwh->dwBufferLength = m_lSize;
        pwh->dwFlags = 0;

        // Give our WaveInSample the start of the wavehdr.  It knows enough to
        // look at pwh->lpData as the spot to find it's data, and to
        // pwh->dwBufferLength for the size, but it will remember pwh so we
        // can get that back again

        pSample = new CWaveInSample(this, &hr, pwh);

        pwh->dwUser = (DWORD_PTR) pSample;

        /* Clean up the resources if we couldn't create the object */

        if (FAILED(hr) || pSample == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Ack! Couldn't make a new sample!")));
            delete[] lpMem;
            break;
        }

        /* Add the completed sample to the available list */

        m_pQueue->PutQueueObject(pSample);
    }

    // !!! Ack what if we ran out of memory and don't have enough buffers?

    LockBuffers(TRUE);

    /* Put all the media samples we have just created also onto the free list
       so they can be allocated. They all have a reference count of zero */

    for (i = 0; i < m_lAllocated; i++) {
        // for recording, this will actually add the buffers to the device's
        // queue....
        CWaveInSample *pSample = (CWaveInSample *)m_pQueue->GetQueueObject();

        // This is a hacky way of triggering the release code to call
        // waveInAddBuffer
        pSample->AddRef();
        pSample->Release();
    }

    return NOERROR;
}


// called by CWaveInSample to return it to the free list and
// block any pending GetSample call.
STDMETHODIMP
CWaveInAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    if (m_hw && !m_bDecommitInProgress) {
        LPWAVEHDR pwh = ((CWaveInSample *)pSample)->GetWaveInHeader();

        // set to full size of buffer
        pwh->dwBufferLength = pSample->GetSize();

        if (!m_fAddBufferDangerous) {
            DbgLog((LOG_TRACE,4, TEXT("ReleaseBuffer: Calling WaveInAddBuffer: sample %X, %u byte buffer"),
                				    pSample, pwh->dwBufferLength));

 	    // Assume the add buffer will succeed, and put this buffer on our list
	    // of stuff given to the driver.  If it DOESN'T succeed, take it off
	    // the down Q, protected by the critical section for the Q, since
	    // we're playing around with it alot.  Do not hold the CS around
	    // AddBuffer, or the wave driver will hang because we sometimes
	    // take the CS in the wave callback, and the driver seems to not like
	    // that.
            m_pDownQueue->PutQueueObject((CWaveInSample*)pSample);
            UINT err = waveInAddBuffer((HWAVEIN) m_hw, pwh, sizeof(WAVEHDR));

            if (err > 0) {
                DbgLog((LOG_ERROR,1,TEXT("Error from waveInAddBuffer: %d"),
                                        err));
                // if the wave driver doesn't own it, we better put it back
                // on the queue ourselves, or we'll hang with an empty queue
                // make it empty so our thread will know something's wrong and
                // not try to Deliver it!
                pSample->SetActualDataLength(0);
                m_pQueue->PutQueueObject((CWaveInSample *)pSample);
                // !!! hr = E_FAIL;

	        // OOps.  Take it off the down Q
	        m_csDownQueue.Lock();
                CWaveInSample *pSearchSamp;
                int iSamp = m_lCount;
                while ((pSearchSamp = m_pDownQueue->GetQueueObject(FALSE)) != NULL
                					    && iSamp-- > 0) {
                    if (pSearchSamp == pSample) { break; }
                    m_pDownQueue->PutQueueObject(pSearchSamp);
	        }
                ASSERT(pSearchSamp == pSample);	// what happened to it?
	        m_csDownQueue.Unlock();

            } else {
                DbgLog((LOG_TRACE, 4, TEXT("ReleaseBuffer: Putting buffer %X in down queue"),
                    pSample));
            }
        } else {
            // !!! Most wave drivers I've seen have a bug where, if you send
            // them a buffer after calling waveInStop, they might never give
            // it back!  Well, that will hang the system, so if I'm in a paused
            // state now and was last in a running state, that means I'm in
            // that situation so I'm not giving the buffer to the driver.
            DbgLog((LOG_TRACE,1,TEXT("************************")));
            DbgLog((LOG_TRACE,1,TEXT("*** AVOIDING HANGING ***")));
            DbgLog((LOG_TRACE,1,TEXT("************************")));
            pSample->SetActualDataLength(0);
            m_pQueue->PutQueueObject((CWaveInSample *)pSample);
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("ReleaseBuffer: Putting back on QUEUE")));
        m_pQueue->PutQueueObject((CWaveInSample *)pSample);
    }

    return NOERROR;
}


/* This goes in the factory template table to create new instances */

CUnknown *CWaveInFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CWaveInFilter(pUnk, phr);  // need cast here?
}

#pragma warning(disable:4355)
/* Constructor - initialise the base class */

CWaveInFilter::CWaveInFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(NAME("WaveInFilter"), pUnk, (CCritSec *) this, CLSID_AudioRecord)
    , CPersistStream(pUnk, phr)
    , m_fStopping(FALSE)
    , m_llCurSample(0)
    , m_llBufferTime(0)
    , m_cInputPins(0)
    , m_hwi(NULL)
    , m_pOutputPin(0)
    , m_dwLockCount(0)
    , m_cTypes(0)
    , m_ulPushSourceFlags( 0 )
    , m_dwDstLineID(0xffffffff)
{
    m_WaveDeviceToUse.fSet = FALSE;
    ZeroMemory( m_lpwfxArray, sizeof(DWORD) * g_cMaxPossibleTypes );
    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter:: constructor")));
}


#pragma warning(default:4355)

/* Destructor */

CWaveInFilter::~CWaveInFilter()
{

    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter:: destructor")));


    CloseWaveDevice();

    delete m_pOutputPin;

    int i;
    for (i = 0; i < m_cInputPins; i++)
    delete m_pInputPin[i];

    // our cached formats we can offer through GetMediaType
    while (m_cTypes-- > 0)
	    QzTaskMemFree(m_lpwfxArray[m_cTypes]);


}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveInFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IAMAudioInputMixer) {
    return GetInterface((LPUNKNOWN)(IAMAudioInputMixer *)this, ppv);
    } else if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag*)this, ppv);
    } else if(riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *) this, ppv);
    } else  if (riid == IID_IAMResourceControl) {
        return GetInterface((IAMResourceControl *)this, ppv);
    } else if (riid == IID_ISpecifyPropertyPages) {
        return GetInterface((ISpecifyPropertyPages*)(this), ppv);
    } else if (riid == IID_IAMFilterMiscFlags) {
        return GetInterface((IAMFilterMiscFlags*)(this), ppv);
    }


    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// IBaseFilter stuff

CBasePin *CWaveInFilter::GetPin(int n)
{
    //  Note if m_pOutputPin is NULL this works by returning NULL
    //  for the first pin which is consistent with having 0 pins
    if (n == 0)
        return m_pOutputPin;
    else
    return m_pInputPin[n-1];
}


// tell the Stream control stuff what's going on
STDMETHODIMP CWaveInFilter::SetSyncSource(IReferenceClock *pClock)
{
    if (m_pOutputPin)
        m_pOutputPin->SetSyncSource(pClock);
    return CBaseFilter::SetSyncSource(pClock);
}


// tell the Stream control stuff what's going on
STDMETHODIMP CWaveInFilter::JoinFilterGraph(IFilterGraph * pGraph, LPCWSTR pName)
{
    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);
    if (hr == S_OK && m_pOutputPin)
        m_pOutputPin->SetFilterGraph(m_pSink);
    return hr;
}


HRESULT CWaveInFilter::CreatePinsOnLoad()
{
    // !!! mixer barfs if we pick WAVE_MAPPER

    ASSERT(m_WaveDeviceToUse.fSet);

    // !!! NO LATENCY for capture pins
    //m_nLatency = GetProfileInt("wavein", "Latency", 666666);
    m_nLatency = 0;
    m_cTypes = 0; // we're initialized with no types

    HRESULT hr = S_OK;
    m_pOutputPin = new CWaveInOutputPin(this,        // Owning filter
                                        &hr,         // Result code
                                        L"Capture"); // Pin name
    if(m_pOutputPin == 0)
        return E_OUTOFMEMORY;
    if(SUCCEEDED(hr))
    {
        ASSERT(m_pOutputPin);

        // one for each input that can be mixed
        MakeSomeInputPins(m_WaveDeviceToUse.devnum, &hr);

        // !!! TEST ONLY
#if 0
        int f;
        double d;
        put_Enable(FALSE);
        get_Enable(&f);
        put_Mono(TRUE);
        get_Mono(&f);
        get_TrebleRange(&d);
        put_MixLevel(1.);
        put_Pan(-.5);
#endif

    }

    return hr;
}

// load a default format
HRESULT CWaveInFilter::LoadDefaultType()
{
    ASSERT( 0 == m_cTypes ); // should only be called once

    // initialize a default format to record in - could be variable size later
    m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(sizeof(WAVEFORMATEX));
    if (m_lpwfxArray[0] == NULL) {
        return E_OUTOFMEMORY;
    }
    MMRESULT mmrQueryOpen            = MMSYSERR_ERROR;

    m_lpwfxArray[0]->wFormatTag      = WAVE_FORMAT_PCM;
#if 0 // for TESTING ONLY!!
    m_lpwfxArray[0]->nSamplesPerSec  = GetProfileIntA("wavein", "Frequency", g_afiFormats[0].nSamplesPerSec);
    m_lpwfxArray[0]->nChannels       = (WORD)GetProfileIntA("wavein", "Channels", g_afiFormats[0].nChannels);
    m_lpwfxArray[0]->wBitsPerSample  = (WORD)GetProfileIntA("wavein", "BitsPerSample", g_afiFormats[0].wBitsPerSample);
    m_lpwfxArray[0]->nBlockAlign     = m_lpwfxArray[0]->nChannels * ((m_lpwfxArray[0]->wBitsPerSample + 7) / 8);
    m_lpwfxArray[0]->nAvgBytesPerSec = m_lpwfxArray[0]->nSamplesPerSec * m_lpwfxArray[0]->nBlockAlign;
    m_lpwfxArray[0]->cbSize          = 0;
    mmrQueryOpen = waveInOpen(NULL, m_WaveDeviceToUse.devnum, m_lpwfxArray[0], 0, 0, WAVE_FORMAT_QUERY );
#endif

    if (mmrQueryOpen != 0)
    {
        // find a type to make the default
        for (int i = 0; i < (g_cMaxFormats) && 0 != mmrQueryOpen ; i ++)
        {
            m_lpwfxArray[0]->wBitsPerSample  = g_afiFormats[i].wBitsPerSample;
            m_lpwfxArray[0]->nChannels       = g_afiFormats[i].nChannels;
            m_lpwfxArray[0]->nSamplesPerSec  = g_afiFormats[i].nSamplesPerSec;
            m_lpwfxArray[0]->nBlockAlign     = g_afiFormats[i].nChannels *
                                                          ((g_afiFormats[i].wBitsPerSample + 7)/8);
            m_lpwfxArray[0]->nAvgBytesPerSec = g_afiFormats[i].nSamplesPerSec *
                                                          m_lpwfxArray[0]->nBlockAlign;
            m_lpwfxArray[0]->cbSize          = 0;

            mmrQueryOpen = waveInOpen( NULL
                            , m_WaveDeviceToUse.devnum
                            , m_lpwfxArray[0]
                            , 0
                            , 0
                            , WAVE_FORMAT_QUERY );
        }
    }
    if (mmrQueryOpen != 0)
    {
        // ACK!  This device is useless! BAIL or not? !!!
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Query, mmrQueryOpen );

        DbgLog((LOG_ERROR,1,TEXT("*** Useless device can't record!")));
        DbgLog((LOG_ERROR,1,TEXT("Error in waveInOpen: %u"), mmrQueryOpen));

        QzTaskMemFree(m_lpwfxArray[0]);
        return E_FAIL;
    }
    m_cTypes = 1; // this means we've been successfully created with a default type

    return NOERROR;
}


// override GetState to report that we don't send any data when paused, so
// renderers won't starve expecting that
//
STDMETHODIMP CWaveInFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


// switch the filter into stopped mode.
STDMETHODIMP CWaveInFilter::Stop()
{
    CAutoLock lock(this);

    // Shame on the base classes!
    if (m_State == State_Running) {
        HRESULT hr = Pause();
        if (FAILED(hr)) {
            return hr;
        }
    }

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Stopped, 0);

    // next time we stream, start the sample count back at 0
    m_llCurSample = 0;

    return CBaseFilter::Stop();
}


STDMETHODIMP CWaveInFilter::Pause()
{
    CAutoLock lock(this);

    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter::Pause")));

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Paused, 0);

    HRESULT hr = NOERROR;

    // don't do anything if we don't have a device to use or we aren't
    // connected up
    if(m_WaveDeviceToUse.fSet && m_pOutputPin->IsConnected())
    {
        /* Check we can PAUSE given our current state */

        if (m_State == State_Running) {
            ASSERT(m_hwi);

            DbgLog((LOG_TRACE,1,TEXT("Wavein: Running->Paused")));

            // hack for buggy wave drivers
            m_pOutputPin->m_pOurAllocator->m_fAddBufferDangerous = TRUE;
            MMRESULT mmr = waveInStop(m_hwi);
            if (mmr > 0)
            {
                NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, mmr );
                DbgLog((LOG_ERROR,0,TEXT( "Error in waveInStop: %u" ), mmr ) );
            }
        } else {
            if (m_State == State_Stopped) {
                DbgLog((LOG_TRACE,1,TEXT("Wavein: Inactive->Paused")));

                // open the wave device. We keep it open until the
                // last buffer using it is released and the allocator
                // goes into Decommit mode.
                hr = OpenWaveDevice();
                if (FAILED(hr)) {
                    return hr;
                }
            }
        }
    }

    // tell the pin to go inactive and change state
    return CBaseFilter::Pause();
}


STDMETHODIMP CWaveInFilter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInFilter::Run at %d"),
                    (LONG)((CRefTime)tStart).Millisecs()));

    CAutoLock lock(this);

    HRESULT hr = NOERROR;
    DWORD dw;

    if (m_pOutputPin)
        m_pOutputPin->NotifyFilterState(State_Running, tStart);

    FILTER_STATE fsOld = m_State;

    // this will call Pause if currently stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    // don't do anything if we're not connected
    if (fsOld != State_Running && m_WaveDeviceToUse.fSet && m_pOutputPin->IsConnected()) {

        DbgLog((LOG_TRACE,1,TEXT("Paused->Running")));

        ASSERT( m_pOutputPin->m_Worker.ThreadExists() );

        //
        // First ensure the worker processing thread isn't running when we
        // unset the m_fAddBufferDangerous flag (otherwise we could deadlock
        // on the call to m_Worker.Run() if the worker thread blocks waiting
        // to get a sample off the queue after a Run->Pause->Run transition).
        //
        hr = m_pOutputPin->m_Worker.Stop();
        if (FAILED(hr)) {
            return hr;
        }

        // hack for buggy wave drivers
        m_pOutputPin->m_pOurAllocator->m_fAddBufferDangerous = FALSE;

        // Start the run loop
        m_pOutputPin->m_Worker.Run();

        dw = waveInStart(m_hwi);
        if (dw != 0)
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Start, dw );
            DbgLog((LOG_ERROR,1,TEXT("***Error %d from waveInStart"), dw));
        }

        // !!! assume the 1st sample in the 1st buffer will be captured now
        if (m_pClock)
            m_pClock->GetTime(&m_llBufferTime);
    }

    return NOERROR;
}

// open the wave device if not already open
// called by the wave allocator at Commit time
HRESULT
CWaveInFilter::OpenWaveDevice( WAVEFORMATEX *pwfx )
{
    //  If application has forced acquisition of resources just return
    if (m_dwLockCount != 0) {
        ASSERT(m_hwi);
        return S_OK;
    }

    if( !pwfx )
    {
        // use default type
        pwfx = (WAVEFORMATEX *) m_pOutputPin->m_mt.Format();
    }

    ASSERT(m_WaveDeviceToUse.fSet);

    DbgLog((LOG_TRACE,1,TEXT("Opening wave device....")));

    UINT err = waveInOpen(&m_hwi,
                           m_WaveDeviceToUse.devnum,
                           pwfx,
                           (DWORD_PTR) &CWaveInFilter::WaveInCallback,
                           (DWORD_PTR) this,
                           CALLBACK_FUNCTION);

    // Reset time to zero

    m_rtCurrent = 0;

    if (err != 0) {
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Open, err );
        DbgLog((LOG_ERROR,1,TEXT("Error opening wave device: %u"), err));
        return E_FAIL; // !!! resource management?
    }
    if( m_pOutputPin && m_pOutputPin->m_pOurAllocator )
    {
        // if we're opening the device in response to a SetFormat call, we rightly won't have an allocator
        m_pOutputPin->m_pOurAllocator->SetWaveHandle((HWAVE) m_hwi);
    }

    err = waveInStop(m_hwi);
    if (err != 0)
    {
        NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Stop, err );
        DbgLog((LOG_ERROR,1,TEXT("waveInStop returned error: %u"), err));
    }

    return NOERROR;

// !!! we don't report error properly!  We should throw exception!
}

//  Tidy up function
void CWaveInFilter::CloseWaveDevice( )
{
    if (m_hwi) {
        MMRESULT mmr = waveInClose((HWAVEIN)m_hwi);
        if (mmr != 0)
        {
            NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Close, mmr );
            DbgLog((LOG_ERROR,1,TEXT("waveInClose returned error: %u"), mmr));
        }
        m_hwi = NULL;
        if( m_pOutputPin && m_pOutputPin->m_pOurAllocator )
        {
            // if we're opening the device in response to a SetFormat call, we rightly won't have an allocator
            m_pOutputPin->m_pOurAllocator->SetWaveHandle((HWAVE) NULL);
        }
    }
}


/* ----- Implements the CWaveInWorker class ------------------------------ */


CWaveInWorker::CWaveInWorker()
{
    m_pPin = NULL;
}

BOOL
CWaveInWorker::Create(CWaveInOutputPin * pPin)
{
    CAutoLock lock(&m_AccessLock);

    if (m_pPin || pPin == NULL) {
    return FALSE;
    }
    m_pPin = pPin;
    m_pPin->m_fLastSampleDiscarded = FALSE;
    return CAMThread::Create();
}


HRESULT
CWaveInWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CWaveInWorker::Stop()
{
    return CallWorker(CMD_STOP);
}


HRESULT
CWaveInWorker::Exit()
{
    CAutoLock lock(&m_AccessLock);

    HRESULT hr = CallWorker(CMD_EXIT);
    if (FAILED(hr)) {
    return hr;
    }

    // wait for thread completion and then close
    // handle (and clear so we can start another later)
    Close();

    m_pPin = NULL;
    return NOERROR;
}


// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CWaveInWorker::ThreadProc()
{
    DbgLog((LOG_TRACE,2,TEXT("Starting wave input background thread")));

    BOOL bExit = FALSE;
    while (!bExit) {

    Command cmd = GetRequest();

    switch (cmd) {

    case CMD_EXIT:
            bExit = TRUE;
            Reply(NOERROR);
            break;

    case CMD_RUN:
            Reply(NOERROR);
            DoRunLoop();
            break;

    case CMD_STOP:
            Reply(NOERROR);
            break;

        default:
            Reply(E_NOTIMPL);
            break;
        }
    }
    return NOERROR;
}


void
CWaveInWorker::DoRunLoop(void)
{
    // general strategy:
    // wait for data to come in, then send it.
    // when it comes back, put it back on the chain.

    HRESULT hr;
    DbgLog((LOG_TRACE,2,TEXT("Starting wave input background loop")));
    CWaveInSample *pSample;
    REFERENCE_TIME rtNoOffsetStart, rtNoOffsetEnd;
    while (1) {

// this tries to fix a problem that might not exist
#if 0
        // we'll hang if we try to get a queue object on an empty queue
        // that will never get anything on it.
        // This is the equivalent of GetBuffer failing if things are un
        // committed
        if (!m_pPin->m_pOurAllocator->m_bCommitted) {
            DbgLog((LOG_TRACE,1,TEXT("No allocator - can't get buffer")));
            break;
        }
#endif

        // get a buffer - this blocks!
        DbgLog((LOG_TRACE,4,TEXT("Calling GetQueueObject")));
        pSample = m_pPin->m_pOurAllocator->m_pQueue->GetQueueObject();
        DbgLog((LOG_TRACE,4,TEXT("GetQueueObject returned sample %X"),pSample));

        // we're supposed to stop - we shouldn't have gotten that sample
        // or, this buffer was never filled due to an error somewhere
        if (!m_pPin->m_pOurAllocator->m_bCommitted ||
             ( ( m_pPin->m_pOurAllocator->m_bDecommitInProgress ||
                 m_pPin->m_pOurAllocator->m_fAddBufferDangerous ) &&
               0 == pSample->GetActualDataLength() ) )
        {
            // put it back!
            DbgLog((LOG_TRACE,1,TEXT("EMPTY BUFFER - not delivering")));
            m_pPin->m_pOurAllocator->m_pQueue->PutQueueObject(pSample);
            break;
        }

        // The guy we deliver the sample to might not addref it if he doesn't
        // want it, but we have to make sure the sample gets ReleaseBuffer'd,
        // which only happens on a Release, so do this hack
        pSample->AddRef();

        // don't deliver 0-length samples since we don't timestamp them
        // (but remember that we still need to go through the AddRef and Release
        // exercise on the sample in order to reuse the buffer)
        if( 0 != pSample->GetActualDataLength() )
        {
             REFERENCE_TIME rtStart, rtEnd;
             BOOL bResetTime = FALSE;
             if (0 < m_pPin->m_rtStreamOffset &&
                 pSample->GetTime(&rtStart, &rtEnd) == NOERROR)
             {
                // If we're using an offset for timestamps:
                // for stream control to work (not block) we need to
                // give it sample times that don't use an offset

                rtNoOffsetStart = rtStart - m_pPin->m_rtStreamOffset;
                rtNoOffsetEnd   = rtEnd   - m_pPin->m_rtStreamOffset;
                pSample->SetTime( &rtNoOffsetStart, &rtNoOffsetEnd );
                bResetTime = TRUE;
             }

             int iState = m_pPin->CheckStreamState(pSample);

             if( bResetTime )
             {
                // now timestamp with the correct timestamps
                // (if we're using an offset for timestamps)!
                pSample->SetTime( &rtStart, &rtEnd );
             }

             // it's against the law to send a time stamp backwards in time from
             // the one sent last time.  This could happen if the graph was run,
             // paused, then run again
             if (pSample->GetTime(&rtStart, &rtEnd) == NOERROR) {
                 if (rtStart < m_pPin->m_rtLastTimeSent) {
                     DbgLog((LOG_TRACE,3,TEXT("Discarding back-in-time sample")));
                     iState = m_pPin->STREAM_DISCARDING;
                 }
             } else {
                 ASSERT(FALSE);    // shouldn't happen
                 rtStart = m_pPin->m_rtLastTimeSent;
             }

             if (iState == m_pPin->STREAM_FLOWING) {
                 DbgLog((LOG_TRACE,4,TEXT("Flowing samples...")));

                 CRefTime rt;
                 HRESULT hr = m_pPin->m_pFilter->StreamTime(rt);
                 DbgLog((LOG_TRACE, 8, TEXT("wavein: Stream time just before Deliver: %dms"), (LONG)(rt / 10000) ) );

                 if (m_pPin->m_fLastSampleDiscarded)
                     pSample->SetDiscontinuity(TRUE);

                 m_pPin->m_fLastSampleDiscarded = FALSE;
             } else {
                 DbgLog((LOG_TRACE,4,TEXT("Discarding samples...")));
                 m_pPin->m_fLastSampleDiscarded = TRUE;
             }

             // we INSIST on our own allocator
             ASSERT(m_pPin->m_fUsingOurAllocator);

             // check for loop exit here???
             if (iState == m_pPin->STREAM_FLOWING) {
                 // got a buffer back from the device, now send it to our friend
                 DbgLog((LOG_TRACE,4,TEXT("Delivering sample %X"), pSample));
                 hr = m_pPin->Deliver(pSample);
                 m_pPin->m_rtLastTimeSent = rtStart;    // remember last time sent

                 if (hr != S_OK) {
                     // stop the presses.
                     pSample->Release();
                     DbgLog((LOG_ERROR,1,TEXT("Error from Deliver: %lx"), hr));
                     break;
                 }
             }
        }

        // The guy we deliver the sample to might not addref it if he doesn't
        // want it, but we have to make sure the sample gets ReleaseBuffer'd,
        // which only happens on a Release, so do this hack
        pSample->Release();

        // any other requests ?
        Command com;
        if (CheckRequest(&com)) {

            // if it's a run command, then we're already running, so
            // eat it now.
            if (com == CMD_RUN) {
                GetRequest();
                Reply(NOERROR);
            } else {
                break;
            }
        }
    }
    DbgLog((LOG_TRACE,2,TEXT("Leaving wave input background loop")));
}

void
CALLBACK CWaveInFilter::WaveInCallback(HDRVR waveHeader, UINT callBackMessage,
    DWORD_PTR userData, DWORD_PTR dw1, DWORD_PTR dw2)
{
// really need a second worker thread here, because
// one shouldn't do this much in a wave callback.
// !!! is this why we are dropping samples????
//     just how expensive/(blocking?) are the quartz calls?

    CWaveInFilter *pFilter = (CWaveInFilter *) userData;

    switch (callBackMessage) {
    case WIM_DATA:
    {
        if( NULL == pFilter->m_pOutputPin || NULL == pFilter->m_pOutputPin->m_pOurAllocator )
        {
            ASSERT( pFilter->m_pOutputPin );
            ASSERT( pFilter->m_pOutputPin->m_pOurAllocator );

            // shouldn't happen, but get out of here if it does!
            return;
        }

        LPWAVEHDR waveBufferHeader = (LPWAVEHDR) dw1; // !!! verify?
        CWaveInSample *pSample = (CWaveInSample *) waveBufferHeader->dwUser;

        //
        // Walk through the down queue and look for our sample.  In
        //  the mean time if we come across buffers that aren't the one
        //  were looking for just push them back on the end.  Also
        //  just in case the driver fires a callback with some random
        //  address make sure we don't get in an infinite loop.
        //
        DbgLog((LOG_TRACE,4,TEXT("WIM_DATA: %x"), pSample));
        CWaveInSample *pSearchSamp;
        int iSamp = pFilter->m_pOutputPin->m_pOurAllocator->m_lCount;

	// we're going through the whole down queue.  Keep out!
	pFilter->m_pOutputPin->m_pOurAllocator->m_csDownQueue.Lock();

        while ((pSearchSamp = pFilter->m_pOutputPin->m_pOurAllocator->
                    m_pDownQueue->GetQueueObject(FALSE)) != NULL
                && iSamp-- > 0) {

            if (pSearchSamp == pSample) { break; }
            DbgLog((LOG_TRACE,4,TEXT("Found %x: back on queue"), pSearchSamp));
            pFilter->m_pOutputPin->m_pOurAllocator->m_pDownQueue->PutQueueObject(pSearchSamp);

        }

	pFilter->m_pOutputPin->m_pOurAllocator->m_csDownQueue.Unlock();
        ASSERT(pSearchSamp == pSample);

        HRESULT hr =
           pSample->SetActualDataLength(waveBufferHeader->dwBytesRecorded);
        ASSERT(SUCCEEDED(hr));
        CRefTime rtStart, rtEnd;

        // !!! something better if no clock?
        // we have no clock - stamp each buffer assuming starting at zero
        // and using the audio clock
        if (!pFilter->m_pClock) {
            // increment time by amount recorded
            rtStart = pFilter->m_rtCurrent;
            pFilter->m_rtCurrent +=
            CRefTime((LONG)(waveBufferHeader->dwBytesRecorded * 1000 /
             ((WAVEFORMATEX *) pFilter->m_pOutputPin->m_mt.Format())->nAvgBytesPerSec));
            pSample->SetTime((REFERENCE_TIME *) &rtStart,
                             (REFERENCE_TIME *) &pFilter->m_rtCurrent);

        // we have a clock.  see what time it thinks it was when the first
        // sample was captured.
        // !!! BAD HACK! This assumes the clock runs at the same rate as
        // the audio clock during the filling of the buffer, and it doesn't
        // take into account the random delay before getting the callback!!
        } else {
        CRefTime curtime;
        // what time is it now (at the end of the buffer)?
        pFilter->m_pClock->GetTime((REFERENCE_TIME *)&curtime);
        // what time was it at the beginning of the buffer?
        CRefTime rtBegin = pFilter->m_llBufferTime;
        // !!! assume 1st sample of next buffer is being captured NOW
        pFilter->m_llBufferTime = curtime;
        // make a stream time by subtracting the time we were run at
        rtStart = rtBegin - pFilter->m_tStart +
                        (LONGLONG)pFilter->m_nLatency +
                        pFilter->m_pOutputPin->m_rtStreamOffset;

        // calculate the end stream time of this block of samples
        rtEnd = curtime - pFilter->m_tStart +
                        (LONGLONG)pFilter->m_nLatency +
                        pFilter->m_pOutputPin->m_rtStreamOffset;

            pSample->SetTime((REFERENCE_TIME *)&rtStart,
                             (REFERENCE_TIME *)&rtEnd);
#ifdef DEBUG
            CRefTime rt;
            HRESULT hr = pFilter->StreamTime(rt);
            DbgLog((LOG_TRACE, 8, TEXT("wavein: Stream time in wavein callback: %dms"), (LONG)(rt / 10000) ) );
#endif
        }
        WAVEFORMATEX *lpwf = ((WAVEFORMATEX *)pFilter->
                        m_pOutputPin->m_mt.Format());
        LONGLONG llNext = pFilter->m_llCurSample + waveBufferHeader->
            dwBytesRecorded / (lpwf->wBitsPerSample *
            lpwf->nChannels / 8);
        pSample->SetMediaTime((LONGLONG *)&pFilter->m_llCurSample,
                             (LONGLONG *)&llNext);
        DbgLog((LOG_TRACE,3,
            TEXT("Stamps: Time(%d,%d) MediaTime(%d,%d)"),
            (LONG)rtStart.Millisecs(), (LONG)rtEnd.Millisecs(),
            (LONG)pFilter->m_llCurSample, (LONG)llNext));
        DbgLog((LOG_TRACE,4, TEXT("WIM_DATA (%x): Putting back on queue"),
                                pSample));
        pFilter->m_llCurSample = llNext;

        pFilter->m_pOutputPin->m_pOurAllocator->m_pQueue->PutQueueObject(
                                pSample);
    }
        break;

    case WIM_OPEN:
    case WIM_CLOSE:
        break;

    default:
        DbgLog((LOG_ERROR,1,TEXT("Unexpected wave callback message %d"),
           callBackMessage));
        break;
    }
}


// how many pins do we have?
//
int CWaveInFilter::GetPinCount()
{
    DbgLog((LOG_TRACE,5,TEXT("CWaveInFilter::GetPinCount")));

    // 1 outpin pin, maybe some input pins
    return m_pOutputPin ? 1 + m_cInputPins : 0;
}


/* Constructor */

CWaveInOutputPin::CWaveInOutputPin(
    CWaveInFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(NAME("WaveIn Output Pin"), pFilter, pFilter, phr, pPinName)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin:: constructor")));

    m_pFilter = pFilter;
    m_pOurAllocator = NULL;
    m_fUsingOurAllocator = FALSE;

    // no suggestion yet
    m_propSuggested.cBuffers = -1;
    m_propSuggested.cbBuffer = -1;
    m_propSuggested.cbAlign = -1;
    m_propSuggested.cbPrefix = -1;

    m_rtLatency = 0;
    m_rtStreamOffset = 0;
    m_rtMaxStreamOffset = 0;

// !!! TEST ONLY
#if 0
    ALLOCATOR_PROPERTIES prop;
    IAMBufferNegotiation *pBN;
    prop.cBuffers = GetProfileInt("wavein", "cBuffers", 4);
    prop.cbBuffer = GetProfileInt("wavein", "cbBuffer", 65536);
    prop.cbAlign = GetProfileInt("wavein", "cbAlign", 4);
    prop.cbPrefix = GetProfileInt("wavein", "cbPrefix", 0);
    HRESULT hr = QueryInterface(IID_IAMBufferNegotiation, (void **)&pBN);
    if (hr == NOERROR) {
    pBN->SuggestAllocatorProperties(&prop);
     pBN->Release();
    }
#endif

// !!! TEST ONLY
#if 0
    AUDIO_STREAM_CONFIG_CAPS ascc;
    int i, j;
    AM_MEDIA_TYPE *pmt;
    GetNumberOfCapabilities(&i, &j);
    DbgLog((LOG_TRACE,1,TEXT("%d capabilitie(s) supported"), i));
    GetStreamCaps(0, &pmt, (BYTE *) &ascc);
    DbgLog((LOG_TRACE,1,TEXT("Media type is format %d"),
                ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag));
    DbgLog((LOG_TRACE,1,TEXT("ch: %d %d  samp: %d %d (%d)  bits: %d %d (%d)"),
                                ascc.MinimumChannels,
                                ascc.MaximumChannels,
                                ascc.ChannelsGranularity,
                                ascc.MinimumSampleFrequency,
                                ascc.MaximumSampleFrequency,
                                ascc.SampleFrequencyGranularity,
                                ascc.MinimumBitsPerSample,
                                ascc.MaximumBitsPerSample,
                                ascc.BitsPerSampleGranularity));
    GetFormat(&pmt);
    DbgLog((LOG_TRACE,1,TEXT("GetFormat is %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec = 22050;
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels = 2;
    ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample = 16;
    SetFormat(pmt);
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nBlockAlign = 2 * ((16 + 7) / 8);
    ((LPWAVEFORMATEX)(pmt->pbFormat))->nAvgBytesPerSec = 22050*2*((16 + 7) /8);
    SetFormat(pmt);
    GetFormat(&pmt);
    DbgLog((LOG_TRACE,1,TEXT("GetFormat is %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));
    DeleteMediaType(pmt);
#endif
}

CWaveInOutputPin::~CWaveInOutputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin:: destructor")));

    /* Release our allocator if we made one */

    if (m_pOurAllocator) {
        m_pOurAllocator->Release();
        m_pOurAllocator = NULL;
    }
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveInOutputPin::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IAMStreamConfig) {
    return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    } else if (riid == IID_IAMBufferNegotiation) {
    return GetInterface((LPUNKNOWN)(IAMBufferNegotiation *)this, ppv);
    } else if (riid == IID_IAMStreamControl) {
    return GetInterface((LPUNKNOWN)(IAMStreamControl *)this, ppv);
    } else if (riid == IID_IAMPushSource) {
    return GetInterface((LPUNKNOWN)(IAMPushSource *)this, ppv);
    } else if (riid == IID_IKsPropertySet) {
    return GetInterface((LPUNKNOWN)(IKsPropertySet *)this, ppv);
    }

    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}


// tell the stream control stuff we're flushing
HRESULT CWaveInOutputPin::BeginFlush()
{
    Flushing(TRUE);
    return CBaseOutputPin::BeginFlush();
}


// tell the stream control stuff we're flushing
HRESULT CWaveInOutputPin::EndFlush()
{
    Flushing(FALSE);
    return CBaseOutputPin::EndFlush();
}


/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CWaveInOutputPin::BreakConnect()
{
    /* Set the CLSIDs of the connected media type */

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    return CBaseOutputPin::BreakConnect();
}



HRESULT
CWaveInOutputPin::Active(void)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::Active")));

    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }

    // make sure the first sample sent has a higher time than this
    m_rtLastTimeSent = -1000000;    // -100ms

    // commit and prepare our allocator. Needs to be done
    // if he is not using our allocator, and in any case needs to be done
    // before we complete our close of the wave device.

    HRESULT hr = m_pOurAllocator->Commit();
    if( FAILED( hr ) )
        return hr;

    if (m_pOurAllocator->m_hw == NULL)
        return E_UNEXPECTED;

    // start the thread
    if (!m_Worker.ThreadExists()) {
        if (!m_Worker.Create(this)) {
            return E_FAIL;
        }
    }

    return hr;
}

HRESULT
CWaveInOutputPin::Inactive(void)
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::Inactive")));

    if (m_pOurAllocator == NULL) {
        return E_FAIL;
    }

    // hack: downstream guy decommited us, so when the last callback happens
    // we hang decommiting again because of waveoutUnprepare and the last
    // callback not return
    // !!! why can't I remove this? Try full duplex wavein-->waveout?
    // m_pOurAllocator->Commit();

    // decommit the buffers - normally done by the output
    // pin, but we need to do it here ourselves, before we close
    // the device, and in any case if he is not using our allocator.
    // the output pin will also decommit the allocator if he
    // is using ours, but that's not a problem
    // !!! The base classes will set DecommitInProgress and leave it set (since
    // I never called CMemAllocator::Alloc to put anything on the free list)
    // and I'm counting on that!
    HRESULT hr = m_pOurAllocator->Decommit();

    // Call all the buffers back AFTER decomitting so none will get sent again
    if (m_pFilter->m_hwi)
    {
        MMRESULT mmr = waveInReset(m_pFilter->m_hwi);
        if (mmr != 0)
        {
            m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_Reset, mmr );
            DbgLog((LOG_ERROR,1,TEXT("waveInReset returned error: %u"), mmr));
        }
    }

    // hack for buggy wave drivers
    m_pOurAllocator->m_fAddBufferDangerous = FALSE;

    // now that we've reset the device, wait for the thread to stop using the
    // queue before we destroy it below!
    if (m_Worker.ThreadExists()) {
        hr = m_Worker.Stop();

        if (FAILED(hr)) {
            return hr;
        }

    hr = m_Worker.Exit();
    }

    // we don't use the base allocator's free list, so the allocator is not
    // freed automatically... let's do it now
    // !!! ouch
    m_pOurAllocator->Free();
    if (m_pFilter->m_dwLockCount == 0) {
        m_pFilter->CloseWaveDevice();
    }
    m_pOurAllocator->m_bDecommitInProgress = FALSE;
    m_pOurAllocator->Release();

    return hr;
}


// negotiate the allocator and its buffer size/count
// calls DecideBufferSize to call SetCountAndSize

HRESULT
CWaveInOutputPin::DecideAllocator(IMemInputPin * pPin, IMemAllocator ** ppAlloc)
{
    HRESULT hr;
    *ppAlloc = NULL;

    DbgLog((LOG_TRACE,1,TEXT("CWaveInOutputPin::DecideAllocator")));

    if (!m_pOurAllocator) {
    ASSERT(m_mt.Format());

    hr = S_OK;
    m_pOurAllocator = new CWaveInAllocator(
                    NAME("Wave Input Allocator"),
                                    (WAVEFORMATEX *) m_mt.Format(),
                    &hr);

    if (FAILED(hr) || !m_pOurAllocator) {
        DbgLog((LOG_ERROR,1,TEXT("Failed to create new allocator!")));
        if (m_pOurAllocator) {
        delete m_pOurAllocator;
        m_pOurAllocator = NULL;
        }
        return hr;
    }

    m_pOurAllocator->AddRef();
    }

    /* Get a reference counted IID_IMemAllocator interface */
    m_pOurAllocator->QueryInterface(IID_IMemAllocator,(void **)ppAlloc);
    if (*ppAlloc == NULL) {
    DbgLog((LOG_ERROR,1,TEXT("Couldn't get IMemAllocator from our allocator???")));
        return E_FAIL;
    }

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once

    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    hr = DecideBufferSize(*ppAlloc,&prop);
    if (FAILED(hr)) {
    DbgLog((LOG_ERROR,1,TEXT("Couldn't get set buffer size with our own allocator???")));
    (*ppAlloc)->Release();
        *ppAlloc = NULL;
        return E_FAIL;
    }

    // See if they like our allocator....
    m_fUsingOurAllocator = TRUE;

    // !!! We are not marking our buffers read only - somebody could hurt them
    hr = pPin->NotifyAllocator(*ppAlloc,FALSE);

    // if they don't, fall back to the default procedure.
    if (FAILED(hr)) {
    (*ppAlloc)->Release();
        *ppAlloc = NULL;

    m_fUsingOurAllocator = FALSE;

    // We don't work if we can't use our own allocator
    ASSERT(FALSE);
    //hr = CBaseOutputPin::DecideAllocator(pPin, ppAlloc);
    }

    return hr;
}


// !!! need code here to enumerate possible allowed types....
// but if SetFormat has been called, that's still the only one we enumerate

// return default media type & format
HRESULT
CWaveInOutputPin::GetMediaType(int iPosition, CMediaType* pt)
{
    DbgLog((LOG_TRACE,1,TEXT("GetMediaType")));

    // check it is the single type they want
    if (iPosition<0) {
        return E_INVALIDARG;
    }

    // build a complete list of media types to offer (if we haven't done it already)
    HRESULT hr = InitMediaTypes();
    if (FAILED (hr))
        return hr;

    if (iPosition >= m_pFilter->m_cTypes) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if( 0 == iPosition && IsConnected() )
    {
        // if we're connected offer the connected type first.
        // this way GetFormat will return the connected type, regardless
        // of our default type
        *pt = m_mt;
    }
    else
    {

        hr = CreateAudioMediaType(m_pFilter->m_lpwfxArray[iPosition], pt, TRUE);
    }
    return hr;
}


// set the new media type
//
HRESULT CWaveInOutputPin::SetMediaType(const CMediaType* pmt)
{
    DbgLog((LOG_TRACE,1,TEXT("SetMediaType %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    ASSERT(m_pFilter->m_State == State_Stopped);

    // We assume this format has been checked out already and is OK

    return CBasePin::SetMediaType(pmt);
}


// check if the pin can support this specific proposed type&format
HRESULT
CWaveInOutputPin::CheckMediaType(const CMediaType* pmt)
{
    WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt->Format();

    DbgLog((LOG_TRACE,1,TEXT("CheckMediaType")));
    //DisplayType("wave format in CWaveOut::CheckMediaType", pmt);

    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio ||
        pmt->formattype != FORMAT_WaveFormatEx) {
    return VFW_E_INVALIDMEDIATYPE;
    }

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    UINT err = waveInOpen(NULL,
               m_pFilter->m_WaveDeviceToUse.devnum,
               pwfx,
               0,
               0,
               WAVE_FORMAT_QUERY);

    if (err != 0) {
    DbgLog((LOG_ERROR,1,TEXT("Error checking wave format: %u"), err));
    return VFW_E_TYPE_NOT_ACCEPTED;
    }

    return NOERROR;
}


// override this to set the buffer size and count. Return an error
// if the size/count is not to your liking
HRESULT
CWaveInOutputPin::DecideBufferSize(IMemAllocator * pAlloc,
                                   ALLOCATOR_PROPERTIES *pProperties)
{
    // the user wants a certain sized buffer
    if (m_propSuggested.cbBuffer > 0) {
        pProperties->cbBuffer = m_propSuggested.cbBuffer;
    } else {
        pProperties->cbBuffer = (LONG)(((LPWAVEFORMATEX)(m_mt.Format()))->
        nAvgBytesPerSec * GetProfileIntA("wavein", "BufferMS", 500) /
        1000.);
    }

    // the user wants a certain number of buffers
    if (m_propSuggested.cBuffers > 0) {
        pProperties->cBuffers = m_propSuggested.cBuffers;
    } else {
        pProperties->cBuffers = GetProfileIntA("wavein", "NumBuffers", 4);
    }

    // the user wants a certain prefix
    if (m_propSuggested.cbPrefix >= 0)
        pProperties->cbPrefix = m_propSuggested.cbPrefix;

    // the user wants a certain alignment
    if (m_propSuggested.cbAlign > 0)
        pProperties->cbAlign = m_propSuggested.cbAlign;

    // don't blow up
    if (pProperties->cbAlign == 0)
        pProperties->cbAlign = 1;

    m_rtLatency = ( pProperties->cbBuffer * UNITS ) /
                    (((LPWAVEFORMATEX)(m_mt.Format()))->nAvgBytesPerSec);
    m_rtMaxStreamOffset = m_rtLatency * pProperties->cBuffers;

    ALLOCATOR_PROPERTIES Actual;
    return pAlloc->SetProperties(pProperties,&Actual);
}


// Reconnect our output pin if necessary
//
void CWaveInOutputPin::Reconnect()
{
    if (IsConnected()) {
        DbgLog((LOG_TRACE,1,TEXT("Need to reconnect our output pin")));
        CMediaType cmt;
    GetMediaType(0, &cmt);
    if (S_OK == GetConnected()->QueryAccept(&cmt)) {
        m_pFilter->m_pGraph->Reconnect(this);
    } else {
        // we were promised this would work
        ASSERT(FALSE);
    }
    }
}


////////////////////////////////
// IAMStreamConfig stuff //
////////////////////////////////


HRESULT CWaveInOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;

    if (pmt == NULL)
        return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(m_pFilter);

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    if (m_pFilter->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // even if the format is the current format we should continue on, since there's no
    // guarantee that we've verified we can open the device for real with this format

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) {
        DbgLog((LOG_TRACE,2,TEXT("IAMVideoStreamConfig::SetFormat rejected")));
        return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
            return VFW_E_INVALIDMEDIATYPE;
    }

    LPWAVEFORMATEX lpwfx = (LPWAVEFORMATEX)pmt->pbFormat;

    // verify we can open the device for real with this format
    hr = m_pFilter->OpenWaveDevice( lpwfx );
    if( SUCCEEDED( hr ) )
    {
        m_pFilter->CloseWaveDevice( );

        // OK, we're using it
        hr = SetMediaType((CMediaType *)pmt);

        // make this the default format to offer from now on
        if (lpwfx->cbSize > 0 || 0 == m_pFilter->m_cTypes)
        {
            if (m_pFilter->m_lpwfxArray[0])
                QzTaskMemFree(m_pFilter->m_lpwfxArray[0]);
            m_pFilter->m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                            sizeof(WAVEFORMATEX) + lpwfx->cbSize);
            if (m_pFilter->m_lpwfxArray[0] == NULL)
                return E_OUTOFMEMORY;
        }
        CopyMemory(m_pFilter->m_lpwfxArray[0], lpwfx, sizeof(WAVEFORMATEX) + lpwfx->cbSize);

        if (m_pFilter->m_cTypes == 0) {
            m_pFilter->m_cTypes = 1;
        }

        // Changing the format means reconnecting if necessary
        if (hr == NOERROR)
            Reconnect();
    }
    return hr;
}


HRESULT CWaveInOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
    return E_POINTER;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
    return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
    CoTaskMemFree(*ppmt);
    *ppmt = NULL;
    return hr;
    }
    return NOERROR;
}


HRESULT CWaveInOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    if (piCount == NULL || piSize == NULL)
    return E_POINTER;

    HRESULT hr = InitMediaTypes();
    if (FAILED(hr))
        return hr;

    *piCount = m_pFilter->m_cTypes;
    *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);

    return NOERROR;
}


HRESULT CWaveInOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    BOOL fDoesStereo, fDoes96, fDoes48, fDoes44, fDoes22, fDoes16;
    AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    if (i < 0)
        return E_INVALIDARG;
    if (pSCC == NULL || ppmt == NULL)
        return E_POINTER;

    if (i >= m_pFilter->m_cTypes)
        return S_FALSE;


    HRESULT hr = InitWaveCaps(&fDoesStereo, &fDoes96, &fDoes48, &fDoes44, &fDoes22, &fDoes16);
    if (FAILED(hr))
        return hr;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    hr = GetMediaType(i, (CMediaType *) *ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }

    // !!! We might support more than this, and I won't admit to it
    // !!! We could be more accurate if we wanted

    pASCC->guid = MEDIATYPE_Audio;
    pASCC->MinimumChannels = 1;
    pASCC->MaximumChannels = fDoesStereo ? 2 : 1;
    pASCC->ChannelsGranularity = 1;
    pASCC->MinimumSampleFrequency = 11025;
    pASCC->MaximumSampleFrequency = fDoes44 ? 44100 : (fDoes22 ? 22050 : 11025);
    pASCC->SampleFrequencyGranularity = 11025; // bogus, really...
    pASCC->MinimumBitsPerSample = 8;
    pASCC->MaximumBitsPerSample = fDoes16 ? 16 : 8;
    pASCC->BitsPerSampleGranularity = 8;

    return NOERROR;
}


HRESULT CWaveInOutputPin::InitMediaTypes(void)
{
    DWORD dw;
    WAVEINCAPS caps;

    HRESULT hr = S_OK;
    if ( 1 < m_pFilter->m_cTypes )
    {
        return NOERROR;         // our type list is already initialized
    }
    else if( 0 == m_pFilter->m_cTypes )
    {
        // we haven't been initialized with a default type yet, do this first
        hr = m_pFilter->LoadDefaultType();
        if( FAILED( hr ) )
            return hr;
    }
    ASSERT (1 == m_pFilter->m_cTypes); // should have just the single default type

    // build the type list
    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    dw = waveInGetDevCaps(m_pFilter->m_WaveDeviceToUse.devnum, &caps,
                            sizeof(caps));
    if (dw != 0)
    {
        m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_GetCaps, dw );
        DbgLog((LOG_ERROR,1,TEXT("waveInGetDevCaps returned error: %u"), dw));
        return E_FAIL;
    }

    // Now build our type list, but note that we always offer our default type
    // first (element 0).
    for (int i = 0; i < g_cMaxFormats; i ++)
    {
        if (caps.dwFormats & g_afiFormats[i].dwType)
        {
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = (LPWAVEFORMATEX) QzTaskMemAlloc(
                                                            sizeof (WAVEFORMATEX));
            if (!m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes])
                return E_OUTOFMEMORY;

            ZeroMemory(m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes], sizeof (WAVEFORMATEX));

            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->wFormatTag      = WAVE_FORMAT_PCM;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->wBitsPerSample  = g_afiFormats[i].wBitsPerSample;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nChannels       = g_afiFormats[i].nChannels;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nSamplesPerSec  = g_afiFormats[i].nSamplesPerSec;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nBlockAlign     = g_afiFormats[i].nChannels *
                                                                            ((g_afiFormats[i].wBitsPerSample + 7)/8);
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nAvgBytesPerSec = g_afiFormats[i].nSamplesPerSec *
                                                                            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->nBlockAlign;
            m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes]->cbSize          = 0;

            m_pFilter->m_cTypes++;
        }
        else if (NO_CAPS_FLAG_FORMAT == g_afiFormats[i].dwType)
        {
            // we must query for this one directly
            WAVEFORMATEX wfx;
            wfx.wFormatTag          = WAVE_FORMAT_PCM;
            wfx.nSamplesPerSec      = g_afiFormats[i].nSamplesPerSec;
            wfx.nChannels           = g_afiFormats[i].nChannels;
            wfx.wBitsPerSample      = g_afiFormats[i].wBitsPerSample;
            wfx.nBlockAlign         = g_afiFormats[i].nChannels *
                                      ((g_afiFormats[i].wBitsPerSample + 7)/8);
            wfx.nAvgBytesPerSec     = g_afiFormats[i].nSamplesPerSec * wfx.nBlockAlign;
            wfx.cbSize              = 0;

            MMRESULT mmr = waveInOpen( NULL
                                     , m_pFilter->m_WaveDeviceToUse.devnum
                                     , &wfx
                                     , 0
                                     , 0
                                     , WAVE_FORMAT_QUERY );
            if( MMSYSERR_NOERROR == mmr )
            {
                // type is supported, so add to our list
                m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = (LPWAVEFORMATEX) QzTaskMemAlloc(
                                                                sizeof (WAVEFORMATEX));
                if (!m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes])
                    return E_OUTOFMEMORY;

                ZeroMemory(m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes], sizeof (WAVEFORMATEX));

                *m_pFilter->m_lpwfxArray[m_pFilter->m_cTypes] = wfx;
                m_pFilter->m_cTypes++;
            }
        }
    }

    return NOERROR;
}


HRESULT CWaveInOutputPin::InitWaveCaps(BOOL *pfDoesStereo, BOOL *pfDoes96, BOOL *pfDoes48,
                        BOOL *pfDoes44, BOOL *pfDoes22, BOOL *pfDoes16)
{
    DWORD dw;
    WAVEINCAPS caps;

    if (pfDoesStereo == NULL || pfDoes44 == NULL || pfDoes22 == NULL ||
        pfDoes48 == NULL || pfDoes96 == NULL || pfDoes16 == NULL)
    return E_POINTER;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    dw = waveInGetDevCaps(m_pFilter->m_WaveDeviceToUse.devnum, &caps,
                            sizeof(caps));
    if (dw != 0)
    {
        m_pFilter->NotifyEvent( EC_SNDDEV_IN_ERROR, SNDDEV_ERROR_GetCaps, dw );
        DbgLog((LOG_ERROR,1,TEXT("waveInGetDevCaps returned error: %u"), dw));

        return E_FAIL;
    }

    *pfDoesStereo = (caps.wChannels > 1);

    //
    // note that the 96 and 48kHz format flags were added in Whistler
    // so the reported freq range may be incomplete on legacy platforms
    //
    *pfDoes96 = (caps.dwFormats & WAVE_FORMAT_96S16 ||
                caps.dwFormats & WAVE_FORMAT_96M16);

    *pfDoes48 = (caps.dwFormats & WAVE_FORMAT_48S16 ||
                caps.dwFormats & WAVE_FORMAT_48M16);

    *pfDoes44 = (caps.dwFormats & WAVE_FORMAT_4M08 ||
                caps.dwFormats & WAVE_FORMAT_4S08 ||
                    caps.dwFormats & WAVE_FORMAT_4M16 ||
                caps.dwFormats & WAVE_FORMAT_4S16);
    *pfDoes22 = (caps.dwFormats & WAVE_FORMAT_2M08 ||
                caps.dwFormats & WAVE_FORMAT_2S08 ||
                    caps.dwFormats & WAVE_FORMAT_2M16 ||
                caps.dwFormats & WAVE_FORMAT_2S16);
    *pfDoes16 = (caps.dwFormats & WAVE_FORMAT_1M16 ||
                caps.dwFormats & WAVE_FORMAT_1S16 ||
                    caps.dwFormats & WAVE_FORMAT_2M16 ||
                caps.dwFormats & WAVE_FORMAT_2S16 ||
                    caps.dwFormats & WAVE_FORMAT_4M16 ||
                caps.dwFormats & WAVE_FORMAT_4S16);
    return NOERROR;
}



///////////////////////////////
// IAMBufferNegotiation methods
///////////////////////////////

HRESULT CWaveInOutputPin::SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("SuggestAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pFilter);

    if (pprop == NULL)
	return E_POINTER;

    // sorry, too late
    if (IsConnected())
        return VFW_E_ALREADY_CONNECTED;

    m_propSuggested = *pprop;

    DbgLog((LOG_TRACE,2,TEXT("cBuffers-%d  cbBuffer-%d  cbAlign-%d  cbPrefix-%d"),
        pprop->cBuffers, pprop->cbBuffer, pprop->cbAlign, pprop->cbPrefix));

    return NOERROR;
}


HRESULT CWaveInOutputPin::GetAllocatorProperties(ALLOCATOR_PROPERTIES *pprop)
{
    DbgLog((LOG_TRACE,2,TEXT("GetAllocatorProperties")));

    // to make sure we're not in the middle of connecting
    CAutoLock cObjectLock(m_pFilter);

    if (!IsConnected())
    return VFW_E_NOT_CONNECTED;

    if (pprop == NULL)
    return E_POINTER;

    if (m_fUsingOurAllocator) {
        pprop->cbBuffer = m_pOurAllocator->m_lSize;
        pprop->cBuffers = m_pOurAllocator->m_lCount;
        pprop->cbAlign = m_pOurAllocator->m_lAlignment;
        pprop->cbPrefix = m_pOurAllocator->m_lPrefix;
    } else {
    ASSERT(FALSE);
    return E_FAIL;    // won't happen
    }

    return NOERROR;
}

//-----------------------------------------------------------------------------
//                  IAMPushSource implementation
//-----------------------------------------------------------------------------

HRESULT CWaveInOutputPin::SetPushSourceFlags(ULONG Flags)
{
    m_pFilter->m_ulPushSourceFlags = Flags;
    return S_OK;

} // SetPushSourceFlags

HRESULT CWaveInOutputPin::GetPushSourceFlags(ULONG *pFlags)
{
    *pFlags = m_pFilter->m_ulPushSourceFlags;
    return S_OK;

} // GetPushSourceFlags

HRESULT CWaveInOutputPin::GetLatency( REFERENCE_TIME  *prtLatency )
{
    *prtLatency = m_rtLatency;
    return S_OK;
}

HRESULT CWaveInOutputPin::SetStreamOffset( REFERENCE_TIME  rtOffset )
{
    HRESULT hr = S_OK;
    //
    // if someone attempts to set an offset larger then our max assert
    // in debug for the moment...
    //
    // it may be ok to set a larger offset than we know we can handle, if
    // there's sufficient downstream buffering. but we'll return S_FALSE
    // in that case to warn the user in that case that they need to handle
    // this themselves.
    //
    ASSERT( rtOffset <= m_rtMaxStreamOffset );
    if( rtOffset > m_rtMaxStreamOffset )
    {
        DbgLog( ( LOG_TRACE
              , 1
              , TEXT("CWaveInOutputPin::SetStreamOffset trying to set offset of %dms when limit is %dms")
              , rtOffset
              , m_rtMaxStreamOffset ) );
        hr = S_FALSE;
        // but set it anyway
    }
    m_rtStreamOffset = rtOffset;

    return hr;
}

HRESULT CWaveInOutputPin::GetStreamOffset( REFERENCE_TIME  *prtOffset )
{
    *prtOffset = m_rtStreamOffset;
    return S_OK;
}

HRESULT CWaveInOutputPin::GetMaxStreamOffset( REFERENCE_TIME  *prtMaxOffset )
{
    *prtMaxOffset = m_rtMaxStreamOffset;
    return S_OK;
}

HRESULT CWaveInOutputPin::SetMaxStreamOffset( REFERENCE_TIME  rtMaxOffset )
{
    m_rtMaxStreamOffset = rtMaxOffset; // we don't really care about this at this point
    return S_OK;
}


//////////////////////////////////////////////////////////////////////////


void CWaveInFilter::MakeSomeInputPins(int waveID, HRESULT *phr)
{
    // this doesn't appear to work for wave mapper. oh uh.
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    HMIXEROBJ ID;
    UINT IDtmp;
    DWORD dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("ERROR getting mixer ID")));
	return;
    }
    ID = (HMIXEROBJ)UIntToPtr(IDtmp);

    // find out how many sources we can mix (that's how many pins we need)
    MIXERLINE mixerline;
    mixerline.cbStruct = sizeof(MIXERLINE);
    mixerline.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
    dw = mixerGetLineInfo(ID, &mixerline,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for WAVE INPUT dst")));
	*phr = E_FAIL;
	return;
    }
    int iPinCount = mixerline.cConnections;
    DWORD dwDestination = mixerline.dwDestination;
    DbgLog((LOG_TRACE,1,TEXT("Destination %d has %d sources"), dwDestination,
                                iPinCount));
    if (iPinCount > MAX_INPUT_PINS) {
        DbgLog((LOG_ERROR,1,TEXT("ACK!! Too many input lines!")));
	iPinCount = MAX_INPUT_PINS;
    }

    m_dwDstLineID = mixerline.dwLineID;

    // see if this device supports a Mux control on its input lines
    MIXERCONTROLDETAILS_LISTTEXT *pmxcd_lt = NULL;
    int cChannels;
    MIXERCONTROL mc;
    MIXERCONTROLDETAILS mixerdetails;
    DWORD dwMuxDetails = -1;

    dw = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels, &mc);

    if (dw == NOERROR) {

        // yes, it does, so we'll use this info when we create our input pins
        pmxcd_lt = new MIXERCONTROLDETAILS_LISTTEXT[mc.cMultipleItems];

        if (pmxcd_lt) {
            mixerdetails.cbStruct = sizeof(mixerdetails);
            mixerdetails.dwControlID = mc.dwControlID;
            mixerdetails.cChannels = 1;
            mixerdetails.cMultipleItems = mc.cMultipleItems;
            mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_LISTTEXT);
            mixerdetails.paDetails = pmxcd_lt;

            dwMuxDetails = mixerGetControlDetails(ID, &mixerdetails, MIXER_GETCONTROLDETAILSF_LISTTEXT);
        }
    }

    // Now make that many pins
    int i;
    for (i = 0; i < iPinCount; i++) {
        WCHAR wszPinName[MIXER_LONG_NAME_CHARS];

        // what is this input line's name in UNICODE?
        ZeroMemory(&mixerline, sizeof(mixerline));
        mixerline.cbStruct = sizeof(mixerline);
        mixerline.dwDestination = dwDestination;
        mixerline.dwSource = i;
        dw = mixerGetLineInfo(ID, &mixerline, MIXER_GETLINEINFOF_SOURCE);
        if (dw == 0) {
#ifdef UNICODE
            lstrcpyW(wszPinName, mixerline.szName);
#else
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, mixerline.szName,
                    -1, wszPinName, MIXER_LONG_NAME_CHARS);
#endif
        } else {
            DbgLog((LOG_ERROR,1,TEXT("Can't get pin#%d's name - %d"), i, dw));
            lstrcpyW(wszPinName, L"Unknown");
        }

        DWORD dwMuxIndex = 0xffffffff;
        if (pmxcd_lt && ( 0 == dwMuxDetails ) ) {
            // then this device supports a mux control so see if one of the mux inputs matches
            // the current line. if so, use this info when we create the pin.
            for (DWORD dwMux = 0; dwMux < mixerdetails.cMultipleItems; dwMux++) {
                if (!lstrcmp(mixerline.szName,pmxcd_lt[dwMux].szName)) {
                    dwMuxIndex = dwMux;
                    break;
                }
            }
        }
        DbgLog((LOG_TRACE, 1, TEXT("Pin %d: mux index %d"), i, dwMuxIndex));
	
        m_pInputPin[i] = new CWaveInInputPin(NAME("WaveIn Input Line"), this, mixerline.dwLineID,
                        dwMuxIndex, phr, wszPinName);
        if (!m_pInputPin[i])
            *phr = E_OUTOFMEMORY;

        if (FAILED(*phr)) {
            DbgLog((LOG_ERROR,1,TEXT("ACK!! Can't create all inputs!")));
            break;
        }
        m_cInputPins++;
    }

    // delete any memory we may have allocated for a Mux control
    delete[] pmxcd_lt;

    return;
}

#define MAX_TREBLE 6.0        // !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!
#define MAX_BASS   6.0        // !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!


//============================================================================

/////////////////////
// IAMAudioInputMixer
/////////////////////


// Get info about a control for this pin... eg. volume, mute, etc.
// Also get a handle for calling further mixer APIs
// Also get the number of channels for this pin (mono vs. stereo input)
//
HRESULT CWaveInFilter::GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
                int *pcChannels, MIXERCONTROL *pmc)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    if(!m_WaveDeviceToUse.fSet)
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("CWaveInFilter:GetMixerControl called before Load")));
        return E_UNEXPECTED;
    }

    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    UINT IDtmp;
    dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }
    ID = (HMIXEROBJ)UIntToPtr(IDtmp);

    *pID = ID;

    // get info about the overall WAVE INPUT destination channel
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_DST_WAVEIN;
    dw = mixerGetLineInfo(ID, &mixerinfo,
                    MIXER_GETLINEINFOF_COMPONENTTYPE);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for WAVE INPUT dst")));
	return E_FAIL;
    }

    // make sure this destination supports some controls
    if( 0 == mixerinfo.cControls )
    {
        DbgLog((LOG_TRACE,2,TEXT("This mixer destination line supports no controls")));
        return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

#if 1
    MIXERCONTROL mxc;

    DbgLog((LOG_TRACE,1,TEXT("Trying to get line control"), dwControlType));
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.dwControlID = dwControlType;
    mixercontrol.cControls = 1;
    mixercontrol.pamxctrl = &mxc;
    mixercontrol.cbmxctrl = sizeof(mxc);

    mxc.cbStruct = sizeof(mxc);

    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ONEBYTYPE);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
    } else {
	*pmc = mxc;
	
	return NOERROR;
    }
#else
    // Get info about ALL the controls on this destination.. stuff that is
    // filter-wide
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
                            sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
// !!! TEST ONLY
#if 0
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"),
                mixercontrol.pamxctrl[i].dwControlType,
                mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"),
                mixercontrol.pamxctrl[i].Bounds.dwMinimum,
                mixercontrol.pamxctrl[i].Bounds.dwMaximum,
                mixercontrol.pamxctrl[i].Metrics.cSteps));
#endif
    if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"),
                mixercontrol.pamxctrl[i].dwControlType,
                mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"),
                mixercontrol.pamxctrl[i].Bounds.dwMinimum,
                mixercontrol.pamxctrl[i].Bounds.dwMaximum,
                mixercontrol.pamxctrl[i].Metrics.cSteps));
        CopyMemory(pmc, &mixercontrol.pamxctrl[i],
                    mixercontrol.pamxctrl[i].cbStruct);
            QzTaskMemFree(mixercontrol.pamxctrl);
            return NOERROR;
    }
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
#endif
    return E_NOTIMPL;    // ???
}


HRESULT CWaveInFilter::put_Mono(BOOL fMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Mono %d"), fMono));

    // Get the Mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
    return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fMono;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting mono control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInFilter::get_Mono(BOOL *pfMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Mono")));

    if (pfMono == NULL)
	return E_POINTER;

    // Get the mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mono control"), dw));
	return E_FAIL;
    }
    *pfMono = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Mono = %d"), *pfMono));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Loudness(BOOL fLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Loudness %d"), fLoudness));

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fLoudness;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting loudness control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInFilter::get_Loudness(BOOL *pfLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Loudness")));

    if (pfLoudness == NULL)
	return E_POINTER;

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting loudness"), dw));
	return E_FAIL;
    }
    *pfLoudness = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Loudness = %d"), *pfLoudness));
    return NOERROR;
}


HRESULT CWaveInFilter::put_MixLevel(double Level)
{
    HMIXEROBJ ID;
    DWORD dw, volume;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROL mc;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;
    double Pan;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_MixLevel to %d"),(int)(Level * 10.)));

    // !!! make this work - double/int problem
    if (Level == AMF_AUTOMATICGAIN)
	return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
	return E_INVALIDARG;

    // Get the volume control
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    volume = (DWORD)(Level * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting volume to %d"), volume));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    // if it's not stereo, I don't understand how to pan, so the mix level
    // is simply the value of the volume control
    if (cChannels != 2) {
        DbgLog((LOG_TRACE,1,TEXT("Not stereo - treat as mono")));
        mixerdetails.cChannels = 1;    // sets all channels to same value
        mixerdetails.cbDetails = sizeof(mu.muL);
        mixerdetails.paDetails = &mu.muL;
        mu.muL.dwValue = volume;
        dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    // Stereo.  If we're panned, the channel favoured gets the value we're
    // setting, and the other channel is attenuated
    } else {
	hr = get_Pan(&Pan);
	// I don't know how to pan, so looks like we pretend we're mono
	if (hr != NOERROR || Pan == 0.) {
            DbgLog((LOG_TRACE,1,TEXT("Centre pan - treat as mono")));
            mixerdetails.cChannels = 1;    // sets all channels to same value
            mixerdetails.cbDetails = sizeof(mu.muL);
            mixerdetails.paDetails = &mu.muL;
            mu.muL.dwValue = volume;
            dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	} else {
	    if (Pan < 0.) {
                DbgLog((LOG_TRACE,1,TEXT("panned left")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = volume;
                mu.muR.dwValue = (DWORD)(volume * (1. - (Pan * -1.)));
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    } else {
                DbgLog((LOG_TRACE,1,TEXT("panned right")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = (DWORD)(volume * (1. - Pan));
                mu.muR.dwValue = volume;
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    }
	}
    }

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_MixLevel(double FAR* pLevel)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_MixLevel")));

    // !!! detect if we're using AGC?

    if (pLevel == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, pretend it's mono
    if (cChannels != 2)
	cChannels = 1;

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = cChannels;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // what I consider the current volume is the highest of the channels
    // (pan may attenuate one channel)
    dw = mu.muL.dwValue;
    if (cChannels == 2 && mu.muR.dwValue > dw)
	dw = mu.muR.dwValue;
    *pLevel = (double)dw / mc.Bounds.dwMaximum;
    DbgLog((LOG_TRACE,1,TEXT("Volume: %dL %dR is %d"), mu.muL.dwValue,
                        mu.muR.dwValue, dw));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Pan(double Pan)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Pan %d"), (int)(Pan * 10.)));

    if (Pan < -1. || Pan > 1.)
	return E_INVALIDARG;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // To pan, the favoured side gets the highest of the 2 current values and
    // the other is attenuated
    dw = max(mu.muL.dwValue, mu.muR.dwValue);
    if (Pan == 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = dw;
    } else if (Pan < 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = (DWORD)(dw * (1. - (Pan * -1.)));
    } else {
	mu.muL.dwValue = (DWORD)(dw * (1. - Pan));
	mu.muR.dwValue = dw;
    }
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }
    m_Pan = Pan;    // remember it
    return NOERROR;
}


HRESULT CWaveInFilter::get_Pan(double FAR* pPan)
{
    HMIXEROBJ ID;
    DWORD dw, dwHigh, dwLow;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Pan")));

    if (pPan == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // The pan is the ratio of the lowest channel to highest channel
    dwHigh = max(mu.muL.dwValue, mu.muR.dwValue);
    dwLow = min(mu.muL.dwValue, mu.muR.dwValue);
    if (dwHigh == dwLow && dwLow == 0) {    // !!! dwMinimum?
	if (m_Pan != 64.)
	    *pPan = m_Pan;    // !!! try to be clever when both are zero?
	else
	    *pPan = 0.;
    } else {
    *pPan = 1. - ((double)dwLow / dwHigh);
    // negative means favouring left channel
    if (dwHigh == mu.muL.dwValue && dwLow != dwHigh)
        *pPan *= -1.;
    }
    DbgLog((LOG_TRACE,1,TEXT("Pan: %dL %dR is %d"), mu.muL.dwValue,
                    mu.muR.dwValue, (int)(*pPan * 10.)));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Treble(double Treble)
{
    HMIXEROBJ ID;
    DWORD dw, treble;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Treble to %d"), (int)(Treble * 10.)));

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
	return E_INVALIDARG;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    treble = (DWORD)(Treble / MAX_TREBLE * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting treble to %d"), treble));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;    // sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = treble;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting treble"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_Treble(double FAR* pTreble)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Treble")));

    if (pTreble == NULL)
	return E_POINTER;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;    // treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting treble"), dw));
	return E_FAIL;
    }
    *pTreble = (mu.dwValue / mc.Bounds.dwMaximum * MAX_TREBLE);
    DbgLog((LOG_TRACE,1,TEXT("treble is %d"), (int)*pTreble));

    return NOERROR;
}


HRESULT CWaveInFilter::get_TrebleRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_TrebleRange")));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a treble control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if(FAILED(hr))
        return hr;

    *pRange = MAX_TREBLE;
    DbgLog((LOG_TRACE,1,TEXT("Treble range is %d.  I'M LYING !"),
                                (int)*pRange));
    return NOERROR;
}


HRESULT CWaveInFilter::put_Bass(double Bass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;
    DWORD bass;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: put_Bass to %d"), (int)(Bass * 10.)));

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
	return E_INVALIDARG;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    bass = (DWORD)(Bass / MAX_BASS * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting Bass to %d"), bass));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;    // sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = bass;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting Bass"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInFilter::get_Bass(double FAR* pBass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_Bass")));

    if (pBass == NULL)
	return E_POINTER;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;    // treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting Bass"), dw));
	return E_FAIL;
    }
    *pBass = mu.dwValue / mc.Bounds.dwMaximum * MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass is %d"), (int)*pBass));

    return NOERROR;
}


HRESULT CWaveInFilter::get_BassRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("FILTER: get_BassRange")));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a bass control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if(FAILED(hr))
        return hr;

    *pRange = MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass range is %d.  I'M LYING !"),
                                (int)*pRange));
    return NOERROR;
}

STDMETHODIMP CWaveInFilter::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(this);
    if(m_State != State_Stopped)
    {
        return VFW_E_WRONG_STATE;
    }
    if (m_pOutputPin)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    HRESULT hr = S_OK;

    if(pPropBag == 0)
    {
        DbgLog((LOG_TRACE,2,TEXT("wavein::Load: defaulting to 0")));
        m_WaveDeviceToUse.devnum = 0;
        m_WaveDeviceToUse.fSet = TRUE;
        hr = CreatePinsOnLoad();
        if (FAILED(hr)) {
            m_WaveDeviceToUse.fSet = FALSE;
        }
    }
    else
    {

        VARIANT var;
        var.vt = VT_I4;
        hr = pPropBag->Read(L"WaveInId", &var, 0);
        if(SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE,2,TEXT("wavein::Load: %d"),
                    var.lVal));
            m_WaveDeviceToUse.devnum = var.lVal;
            m_WaveDeviceToUse.fSet = TRUE;
            hr = CreatePinsOnLoad();
            if (FAILED(hr)) {
                m_WaveDeviceToUse.fSet = FALSE;
            }
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

	// BPC hack for SeanMcD - talk to the mixer APIs differently
        var.vt = VT_I4;
	// don't mess with hr
        HRESULT hrT = pPropBag->Read(L"UseMixer", &var, 0);
        if(SUCCEEDED(hrT))
	    m_fUseMixer = TRUE;
	else
	    m_fUseMixer = FALSE;

    }
    return hr;
}

STDMETHODIMP CWaveInFilter::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CWaveInFilter::InitNew()
{
   if(m_pOutputPin)
   {
       return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
   }
   else
   {
       return S_OK;
   }
}

STDMETHODIMP CWaveInFilter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;
}

struct WaveInPersist
{
    DWORD dwSize;
    DWORD dwWavDevice;
};

HRESULT CWaveInFilter::WriteToStream(IStream *pStream)
{
    WaveInPersist wip;
    wip.dwSize = sizeof(wip);
    wip.dwWavDevice = m_WaveDeviceToUse.devnum;
    return pStream->Write(&wip, sizeof(wip), 0);
}



HRESULT CWaveInFilter::ReadFromStream(IStream *pStream)
{
    if (m_pOutputPin)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }
    ASSERT(!m_WaveDeviceToUse.fSet);

    WaveInPersist wip;
    HRESULT hr = pStream->Read(&wip, sizeof(wip), 0);
    if(FAILED(hr))
        return hr;

    if(wip.dwSize != sizeof(wip))
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    m_WaveDeviceToUse.devnum = wip.dwWavDevice;
    m_WaveDeviceToUse.fSet = TRUE;

    hr = CreatePinsOnLoad();
    if (FAILED(hr)) {
        m_WaveDeviceToUse.fSet = FALSE;
    }
    return hr;
}

int CWaveInFilter::SizeMax()
{
    return sizeof(WaveInPersist);
}

STDMETHODIMP CWaveInFilter::Reserve(
    /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
    /*[in]*/ PVOID pvReserved        //  Must be NULL
)
{
    if (pvReserved != NULL || (dwFlags & ~AMRESCTL_RESERVEFLAGS_UNRESERVE)) {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    CAutoLock lck(this);
    if (dwFlags & AMRESCTL_RESERVEFLAGS_UNRESERVE) {
        if (m_dwLockCount == 0) {
            DbgBreak("Invalid unlock of audio device");
            hr =  E_UNEXPECTED;
        } else {
            m_dwLockCount--;
            if (m_dwLockCount == 0 && m_State == State_Stopped) {
                ASSERT(m_hwi);
                CloseWaveDevice();
            }
        }
    } else  {
        if (m_dwLockCount != 0 || m_hwi) {
        } else {
            hr = OpenWaveDevice();
        }
        if (SUCCEEDED(hr)) {
            m_dwLockCount++;
        }
    }
    return hr;
}

//-----------------------------------------------------------------------------
//                  ISpecifyPropertyPages implementation
//-----------------------------------------------------------------------------


//
// GetPages
//
// Returns the clsid's of the property pages we support
//
STDMETHODIMP CWaveInFilter::GetPages(CAUUID *pPages) {

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_AudioInputMixerProperties;

    return NOERROR;

} // GetPages




//
// PIN CATEGORIES - let the world know that we are a CAPTURE pin
//

HRESULT CWaveInOutputPin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
{
    return E_NOTIMPL;
}

// To get a property, the caller allocates a buffer which the called
// function fills in.  To determine necessary buffer size, call Get with
// pPropData=NULL and cbPropData=0.
HRESULT CWaveInOutputPin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    if (guidPropSet != AMPROPSETID_Pin)
    return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
    return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL && pcbReturned == NULL)
    return E_POINTER;

    if (pcbReturned)
    *pcbReturned = sizeof(GUID);

    if (pPropData == NULL)
    return S_OK;

    if (cbPropData < sizeof(GUID))
    return E_UNEXPECTED;

    *(GUID *)pPropData = PIN_CATEGORY_CAPTURE;
    return S_OK;
}


// QuerySupported must either return E_NOTIMPL or correctly indicate
// if getting or setting the property set and property is supported.
// S_OK indicates the property set and property ID combination is
HRESULT CWaveInOutputPin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    if (guidPropSet != AMPROPSETID_Pin)
    return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AMPROPERTY_PIN_CATEGORY)
    return E_PROP_ID_UNSUPPORTED;

    if (pTypeSupport)
    *pTypeSupport = KSPROPERTY_SUPPORT_GET;
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\audprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// AudProp.cpp
//

#include <streams.h>

#include "waveout.h"
#include "audprop.h"

// *
// * CAudioRendererProperties
// *

//
// CreateInstance
//
//
CUnknown *CAudioRendererProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CAudioRendererProperties(lpunk, phr);
    if (NULL == punk) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
} // Createinstance


//
// CAudioRendererProperties::Constructor
//
// initialise a CAudioRendererProperties object.

CAudioRendererProperties::CAudioRendererProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage( NAME("Audio Renderer Page")
                       , lpunk, IDD_AUDIOPROP, IDS_AUDIORENDERNAME)
    , m_pFilter(0)
{
    ASSERT(phr);
}


CAudioRendererProperties::~CAudioRendererProperties()
{
    CAudioRendererProperties::OnDisconnect();
};

INT_PTR CAudioRendererProperties::OnReceiveMessage
                            (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (uMsg)
    {
	case WM_INITDIALOG:
	    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);
	    break;

#if 0
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
		// This code should handle the buttons (if any)
		// in the dialog
            }
            SetDirty();
	    break;
#endif

        default:
	    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);

    }
    return FALSE;

} // OnReceiveMessage

#ifdef DEBUG
#include <mmreg.h>
TCHAR* WhatFormatTag(int wFormatTag)
{
    switch (wFormatTag) {
        case  WAVE_FORMAT_PCM        : return TEXT("PCM");   /*  Microsoft Corporation  */
        case  WAVE_FORMAT_ADPCM      : return TEXT("ADPCM");   /*  Microsoft Corporation  */
        case  WAVE_FORMAT_IBM_CVSD   : return TEXT("IBM_CVSD");  /*  IBM Corporation  */
        case  WAVE_FORMAT_ALAW       : return TEXT("ALAW");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_MULAW      : return TEXT("MULAW");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_OKI_ADPCM  : return TEXT("OKI_ADPCM");  /*  OKI  */
        case  WAVE_FORMAT_DVI_ADPCM  : return TEXT("DVI_ADPCM"); /*  Intel Corporation  */
//        case  WAVE_FORMAT_IMA_ADPCM  (WAVE_FORMAT_DVI_ADPCM) /*  Intel Corporation  */
        case  WAVE_FORMAT_MEDIASPACE_ADPCM   : return TEXT("MEDIASPACE_ADPCM");  /*  Videologic  */
        case  WAVE_FORMAT_SIERRA_ADPCM       : return TEXT("SIERRA_ADPCM");  /*  Sierra Semiconductor Corp  */
        case  WAVE_FORMAT_G723_ADPCM : return TEXT("G723_ADPCM");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_DIGISTD    : return TEXT("DIGISTD");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIGIFIX    : return TEXT("DIGIFIX");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIALOGIC_OKI_ADPCM : return TEXT("DIALOGIC_OKI_ADPCM");  /*  Dialogic Corporation  */
        case  WAVE_FORMAT_YAMAHA_ADPCM       : return TEXT("YAMAHA_ADPCM");  /*  Yamaha Corporation of America  */
        case  WAVE_FORMAT_SONARC     : return TEXT("SONARC"); /*  Speech Compression  */
        case  WAVE_FORMAT_DSPGROUP_TRUESPEECH        : return TEXT("DSPGROUP_TRUESPEECH");  /*  DSP Group, Inc  */
        case  WAVE_FORMAT_ECHOSC1    : return TEXT("ECHOSC1");  /*  Echo Speech Corporation  */
        case  WAVE_FORMAT_AUDIOFILE_AF36     : return TEXT("AUDIOFILE_AF36");  /*    */
        case  WAVE_FORMAT_APTX       : return TEXT("APTX");  /*  Audio Processing Technology  */
        case  WAVE_FORMAT_AUDIOFILE_AF10     : return TEXT("AUDIOFILE_AF10");  /*    */
        case  WAVE_FORMAT_DOLBY_AC2  : return TEXT("DOLBY_AC2");  /*  Dolby Laboratories  */
        case  WAVE_FORMAT_GSM610     : return TEXT("GSM610");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_ANTEX_ADPCME       : return TEXT("ANTEX_ADPCME");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_CONTROL_RES_VQLPC  : return TEXT("CONTROL_RES_VQLPC"); /*  Control Resources Limited  */
        case  WAVE_FORMAT_DIGIREAL   : return TEXT("DIGIREAL");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_DIGIADPCM  : return TEXT("DIGIADPCM");  /*  DSP Solutions, Inc.  */
        case  WAVE_FORMAT_CONTROL_RES_CR10   : return TEXT("CONTROL_RES_CR10");  /*  Control Resources Limited  */
        case  WAVE_FORMAT_NMS_VBXADPCM       : return TEXT("NMS_VBXADPCM");  /*  Natural MicroSystems  */
        case  WAVE_FORMAT_CS_IMAADPCM : return TEXT("CS_IMAADPCM"); /* Crystal Semiconductor IMA ADPCM */
        case  WAVE_FORMAT_G721_ADPCM : return TEXT("G721_ADPCM");  /*  Antex Electronics Corporation  */
        case  WAVE_FORMAT_MPEG       : return TEXT("MPEG");  /*  Microsoft Corporation  */
        case  WAVE_FORMAT_CREATIVE_ADPCM     : return TEXT("CREATIVE_ADPCM");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_CREATIVE_FASTSPEECH8       : return TEXT("CREATIVE_FASTSPEECH8");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_CREATIVE_FASTSPEECH10      : return TEXT("CREATIVE_FASTSPEECH10");  /*  Creative Labs, Inc  */
        case  WAVE_FORMAT_FM_TOWNS_SND       : return TEXT("FM_TOWNS_SND");  /*  Fujitsu Corp.  */
        case  WAVE_FORMAT_OLIGSM     : return TEXT("OLIGSM");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLIADPCM   : return TEXT("OLIADPCM");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLICELP    : return TEXT("OLICELP");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLISBC     : return TEXT("OLISBC");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_OLIOPR     : return TEXT("OLIOPR");  /*  Ing C. Olivetti & C., S.p.A.  */
        case  WAVE_FORMAT_EXTENSIBLE : return TEXT("EXTENSIBLE");  /*  Microsoft Coroporation  */
        case  WAVE_FORMAT_IEEE_FLOAT : return TEXT("IEEE_FLOAT");  /*  Microsoft Coroporation  */
#ifdef WAVE_FORMAT_DRM        
        case  WAVE_FORMAT_DRM        : return TEXT("DRM");  /*  Microsoft Corporation  */
#endif        
	default:
        /*    WAVE_FORMAT_UNKNOWN : */ return NULL;  // display the number
    }
}
#endif

//
// Fill in the property page details
//

HRESULT CAudioRendererProperties::OnActivate()
{

    if (m_pFilter->IsConnected()) {
        WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
        TCHAR buffer[50];

#ifdef DEBUG
	TCHAR * pString =
	WhatFormatTag(pwfx->wFormatTag);
	if (pString) {
	    SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) pString);
	} else
#endif
	{
        wsprintf(buffer,TEXT("%d"), pwfx->wFormatTag);
        SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
	}
        wsprintf(buffer,TEXT("%d"), pwfx->nChannels);
        SendDlgItemMessage(m_Dlg, IDD_NCHANNELS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nSamplesPerSec);
        SendDlgItemMessage(m_Dlg, IDD_NSAMPLESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nAvgBytesPerSec);
        SendDlgItemMessage(m_Dlg, IDD_NAVGBYTESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        wsprintf(buffer,TEXT("%d"), pwfx->nBlockAlign);
        SendDlgItemMessage(m_Dlg, IDD_NBLOCKALIGN, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);

	DWORD avgbytespersec = (static_cast<CWaveOutInputPin*>(m_pFilter->GetPin(0)))->GetBytesPerSec() * 1000;
	ASSERT(pwfx->nAvgBytesPerSec);
	avgbytespersec /= pwfx->nAvgBytesPerSec;
        wsprintf(buffer,TEXT("%d.%2.2d"), avgbytespersec/1000, (avgbytespersec/10)%100);

        SendDlgItemMessage(m_Dlg, IDD_NWAVERATE,   WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    } else {
        const TCHAR szZero[] = TEXT("0");
        SendDlgItemMessage(m_Dlg, IDD_WTAG, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NCHANNELS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NSAMPLESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NAVGBYTESPERSEC, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NBLOCKALIGN, WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
        SendDlgItemMessage(m_Dlg, IDD_NWAVERATE,   WM_SETTEXT, 0, (LPARAM) (LPSTR) szZero);
    }
    return NOERROR;
}

//
// OnConnect
//
HRESULT CAudioRendererProperties::OnConnect(IUnknown * punk)
{
    CheckPointer( punk, E_POINTER );
    CAudioRendererProperties::OnDisconnect();
    IBaseFilter * pIFilter;
    const HRESULT hr = punk->QueryInterface(IID_IBaseFilter, (void **) &pIFilter);
    m_pFilter = static_cast<CWaveOutFilter*>(pIFilter);
    return hr;
} // OnConnect


//
// OnDisconnect
//
HRESULT CAudioRendererProperties::OnDisconnect()
{
    if (m_pFilter)
    {
        m_pFilter->Release();
        m_pFilter = 0;
    }
    return(NOERROR);
} // OnDisconnect



#if 0
    // This is where we should make changes due to user action.
    // As the user cannot change anything in the property dialog
    // we have nothing to do.  Leave the skeleton here as a placeholder.

HRESULT CAudioRendererProperties::OnApplyChanges()
{
    return NOERROR;
}

#endif


// 
// CAudioRendererAdvancedProperties 
// 
// Property page for audio renderer detailed information. This includes
// slaving details and general buffer processing information.
// 

//
// CreateInstance
//
//
CUnknown *CAudioRendererAdvancedProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    CUnknown *punk = new CAudioRendererAdvancedProperties(lpunk, phr);
    if (NULL == punk) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
} // Createinstance


//
// CAudioRendererAdvancedProperties::Constructor
//
// initialise a CAudioRendererAdvancedProperties object.

CAudioRendererAdvancedProperties::CAudioRendererAdvancedProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CBasePropertyPage( NAME("Audio Renderer Advanced Properties")
                       , lpunk, IDD_AUDIOPROP_ADVANCED, IDS_AUDIORENDERER_ADVANCED)
    , m_pStats(0)
{
    ASSERT(phr);
}


CAudioRendererAdvancedProperties::~CAudioRendererAdvancedProperties()
{
    CAudioRendererAdvancedProperties::OnDisconnect();
};

INT_PTR CAudioRendererAdvancedProperties::OnReceiveMessage
                            (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UNREFERENCED_PARAMETER(lParam);
    switch (uMsg)
    {
        case WM_INITDIALOG:
    
// Important - perhaps we should allow a way to disable/enable this dynamic
//             refreshing of the property page
            SetTimer(m_Dlg, 1, 100, NULL);
	    
            return (LRESULT) 1;

        case WM_DESTROY:
        {
	        KillTimer(m_hwnd, 1);
	    
            return (LRESULT) 1;
        }

        case WM_TIMER:
            UpdateSettings();

    }
    return CBasePropertyPage::OnReceiveMessage(hwnd, uMsg, wParam, lParam);

} // OnReceiveMessage


TCHAR* WhatSlaveMode(DWORD dwSlaveMode)
{
    if( 0 == dwSlaveMode )
    {    
        return TEXT(" - ");
    }        
    else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA )
    {
        if( dwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
            return TEXT("Live Fullness");
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_TIMESTAMPS )
            return TEXT("Live Timestamps");        
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
            return TEXT("Live Graph Clock");        
        else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_STREAM_CLOCK )
            return TEXT("Live Stream Clock");
        else
            return TEXT("Unknown Live Mode");
    }
    else if( dwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
    {
        return TEXT("Graph Clock");
    }        
    else
    {    
        return TEXT("Unknown");
    }
}


void CAudioRendererAdvancedProperties::UpdateSettings()
{

    DWORD dwParam, dwParam2, dwSlaveMode;
    HRESULT hr;
    TCHAR buffer[50];
    const TCHAR szNA[] = TEXT(" - ");

    // not slaving-specific
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_DISCONTINUITIES
                               , &dwParam
                               , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DISCONTINUITIES, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DISCONTINUITIES, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    
    // slaving-specific
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_MODE
                                    , &dwSlaveMode
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
    	TCHAR * pString = WhatSlaveMode(dwSlaveMode);
    	ASSERT( pString );
	    SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVEMODE, WM_SETTEXT, 0, (LPARAM) (LPSTR) pString);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVEMODE, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    
	hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_RATE
                               , &dwParam
    	                       , 0 );
	if( SUCCEEDED( hr ) )
    {
    	wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVERATE, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVERATE, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR
                               , &dwParam
                               , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_HIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_HIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR
                                    , &dwParam
                                    , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTHIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTLOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTHIGHERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTLOWERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }
    
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_ACCUMERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_ACCUMERROR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR
                                    , &dwParam
                                    , &dwParam2 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DROPPEDDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
        wsprintf(buffer,TEXT("%d"), dwParam2);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVESILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
        
    }
    else
    {    
        SendDlgItemMessage(m_Dlg, IDD_EDIT_DROPPEDDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SLAVESILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
    }

    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTBUFFERDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_LASTBUFFERDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
#if 0
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_JITTER
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_JITTER, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_JITTER, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);
#endif
    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_BREAK_COUNT
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_NUMBREAKS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_NUMBREAKS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);


    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_BUFFERFULLNESS
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_FULLNESS, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_FULLNESS, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);



    hr = m_pStats->GetStatParam( AM_AUDREND_STAT_PARAM_SILENCE_DUR
                                    , &dwParam
                                    , 0 );
    if( SUCCEEDED( hr ) )
    {
        wsprintf(buffer,TEXT("%d"), dwParam);
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) buffer);
    }
    else
        SendDlgItemMessage(m_Dlg, IDD_EDIT_SILENCEDUR, WM_SETTEXT, 0, (LPARAM) (LPSTR) szNA);

}

//
// Fill in the property page details
//

HRESULT CAudioRendererAdvancedProperties::OnActivate()
{
    UpdateSettings();
    return NOERROR;
}

//
// OnConnect
//
HRESULT CAudioRendererAdvancedProperties::OnConnect(IUnknown * punk)
{
    CheckPointer( punk, E_POINTER );
    CAudioRendererAdvancedProperties::OnDisconnect();

    const HRESULT hr = punk->QueryInterface(IID_IAMAudioRendererStats, (void **) &m_pStats);

    return hr;
} // OnConnect


//
// OnDisconnect
//
HRESULT CAudioRendererAdvancedProperties::OnDisconnect()
{
    if (m_pStats)
    {
        m_pStats->Release();
        m_pStats = 0;
    }
    return(NOERROR);
} // OnDisconnect

#pragma warning(disable: 4514) // "unreferenced inline function has been removed"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\wavein\pins.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
// Digital audio capture filter, Danny Miller, February 1997

#include <streams.h>
#include <mmsystem.h>
#include "wavein.h"

#define MAX_TREBLE 6.0		// !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!
#define MAX_BASS   6.0		// !!! I HAVE NO IDEA HOW MANY dB THE RANGE IS!

// CWaveInInputPin constructor
//
CWaveInInputPin::CWaveInInputPin(TCHAR *pObjectName, CWaveInFilter *pFilter,
	DWORD dwLineID, DWORD dwMuxIndex, HRESULT * phr, LPCWSTR pName)
   :
   CBaseInputPin(pObjectName, pFilter, pFilter, phr, pName),
   m_pFilter(pFilter),
   m_dwLineID(dwLineID),
   m_dwMuxIndex(dwMuxIndex),
   m_Pan(64.)	// no idea yet
{
    DbgLog((LOG_TRACE,1,TEXT("CWaveInInputPin constructor for line %08x"),
								dwLineID));
    ASSERT(pFilter);

// !!! TEST ONLY
#if 0
    int f;
    double d;
    put_Enable(FALSE);
    get_Enable(&f);
    put_Mono(TRUE);
    get_Mono(&f);
    get_TrebleRange(&d);
    put_MixLevel(1.);
    put_Pan(-.5);
#endif
}


CWaveInInputPin::~CWaveInInputPin()
{
    DbgLog((LOG_TRACE,1,TEXT("*Destroying an input pin")));
};


STDMETHODIMP CWaveInInputPin::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IAMAudioInputMixer) {
	return GetInterface((LPUNKNOWN)(IAMAudioInputMixer *)this, ppv);
    }

   return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
}


// we only connect our input pins using major type MEDIATYPE_AnalogAudio
//
HRESULT CWaveInInputPin::CheckMediaType(const CMediaType *pmt)
{
    // reject if not analog audio
    if (pmt->majortype != MEDIATYPE_AnalogAudio) {
	return E_INVALIDARG;
    }
    return S_OK; 
}


// We offer MEDIATYPE_AnalogAudio for BPC
//
HRESULT CWaveInInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    if (iPosition != 0)
	return VFW_S_NO_MORE_ITEMS;

    pmt->SetType(&MEDIATYPE_AnalogAudio);
    pmt->SetSubtype(&MEDIASUBTYPE_None);
    pmt->SetFormatType(&FORMAT_None);
    return S_OK; 
}


//============================================================================

/////////////////////
// IAMAudioInputMixer
/////////////////////


// Get info about a control for this pin... eg. volume, mute, etc.
// Also get a handle for calling further mixer APIs
// Also get the number of channels for this pin (mono vs. stereo input)
//
HRESULT CWaveInInputPin::GetMixerControl(DWORD dwControlType, HMIXEROBJ *pID,
				int *pcChannels, MIXERCONTROL *pmc, DWORD dwLineID)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_pFilter->m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // get an ID to talk to the Mixer APIs.  They are BROKEN if we don't do
    // it this way!
    UINT IDtmp;
    dw = mixerGetID((HMIXEROBJ)IntToPtr(waveID), &IDtmp, MIXER_OBJECTF_WAVEIN);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }

    ID = (HMIXEROBJ)UIntToPtr(IDtmp);
    *pID = ID;

    // get info about the input channel our pin represents
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwLineID = dwLineID != 0xffffffff ? dwLineID : m_dwLineID;
    // mixerinfo.dwLineID = m_dwLineID;
    dw = mixerGetLineInfo(ID, &mixerinfo, MIXER_GETLINEINFOF_LINEID);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for LineID %d"),
								m_dwLineID));
	return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

    // Get info about ALL the controls this channel has
#if 1
    MIXERCONTROL mxc;
    
    DbgLog((LOG_TRACE,1,TEXT("Trying to get line control"), dwControlType));
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.dwControlID = dwControlType;
    mixercontrol.cControls = 1;
    mixercontrol.pamxctrl = &mxc;
    mixercontrol.cbmxctrl = sizeof(mxc);
    
    mxc.cbStruct = sizeof(mxc);
    
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ONEBYTYPE);
    
    if (dw != 0) {
	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
    } else {
	*pmc = mxc;
	
	return NOERROR;
    }
#else
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = m_dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
							sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"), 
				mixercontrol.pamxctrl[i].dwControlType,
				mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"), 
				mixercontrol.pamxctrl[i].Bounds.dwMinimum,
				mixercontrol.pamxctrl[i].Bounds.dwMaximum,
				mixercontrol.pamxctrl[i].Metrics.cSteps));
	    CopyMemory(pmc, &mixercontrol.pamxctrl[i],
					mixercontrol.pamxctrl[i].cbStruct);
    	    QzTaskMemFree(mixercontrol.pamxctrl);
    	    return NOERROR;
	}
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
#endif
    return E_NOTIMPL;	// ???
}


// This is a special version of GetMixerControl for the BPC guys to workaround
// driver bugs exposed by GetMixerControl.  There's a switch they can throw
// to cause this code to execute.
// CAUTION: the caller must close the mixer device
//
HRESULT CWaveInInputPin::GetMixerControlBPC(DWORD dwControlType, HMIXEROBJ *pID,
				int *pcChannels, MIXERCONTROL *pmc)
{
    int i, waveID;
    HMIXEROBJ ID;
    DWORD dw;
    MIXERLINE mixerinfo;
    MIXERLINECONTROLS mixercontrol;

    if (pID == NULL || pmc == NULL || pcChannels == NULL)
	return E_POINTER;

    if (m_pFilter->m_fUseMixer == FALSE)
	return E_UNEXPECTED;

    ASSERT(m_pFilter->m_WaveDeviceToUse.fSet);
    // !!! this doesn't appear to work for wave mapper. oh uh.
    waveID = m_pFilter->m_WaveDeviceToUse.devnum;
    ASSERT(waveID != WAVE_MAPPER);

    // The fUseMixer flag is for BPC... we talk talk to the mixer APIs using
    // a different method that worksaround some driver bugs for them
    dw = mixerOpen((HMIXER *)&ID, m_pFilter->m_WaveDeviceToUse.devnum, 0, 0,
							MIXER_OBJECTF_MIXER);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*ERROR getting mixer ID")));
	return E_FAIL;
    }
    //DbgLog((LOG_TRACE,2,TEXT("mixerGetID returns ID=%d"), ID));

    *pID = ID;

    // get info about the input channel our pin represents
    mixerinfo.cbStruct = sizeof(mixerinfo);
    mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY;
    dw = mixerGetLineInfo(ID, &mixerinfo, MIXER_GETLINEINFOF_COMPONENTTYPE |
			MIXER_OBJECTF_HMIXER);
    if (dw != 0) {
        mixerinfo.dwComponentType = MIXERLINE_COMPONENTTYPE_SRC_LINE;
        dw = mixerGetLineInfo(ID, &mixerinfo,
		MIXER_GETLINEINFOF_COMPONENTTYPE | MIXER_OBJECTF_HMIXER);
    }
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot get info for LineID %d"),
								m_dwLineID));
	mixerClose((HMIXER)ID);
	return E_FAIL;
    }

    *pcChannels = mixerinfo.cChannels;

    // Get info about ALL the controls this channel has
    mixercontrol.cbStruct = sizeof(mixercontrol);
    mixercontrol.dwLineID = mixerinfo.dwLineID;
    mixercontrol.cControls = mixerinfo.cControls;
    mixercontrol.pamxctrl = (MIXERCONTROL *)QzTaskMemAlloc(mixerinfo.cControls *
							sizeof(MIXERCONTROL));
    if (mixercontrol.pamxctrl == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*Cannot allocate control array")));
	mixerClose((HMIXER)ID);
	return E_OUTOFMEMORY;
    }
    mixercontrol.cbmxctrl = sizeof(MIXERCONTROL);
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	mixercontrol.pamxctrl[i].cbStruct = sizeof(MIXERCONTROL);
    }
    dw = mixerGetLineControls(ID, &mixercontrol, MIXER_GETLINECONTROLSF_ALL |
						MIXER_OBJECTF_HMIXER);
    if (dw != 0) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %d getting line controls"), dw));
	QzTaskMemFree(mixercontrol.pamxctrl);
	mixerClose((HMIXER)ID);
	return E_FAIL;
    }

    // Now find the control they are interested in and return it
    for (i = 0; i < (int)mixerinfo.cControls; i++) {
	if (mixercontrol.pamxctrl[i].dwControlType == dwControlType) {
            DbgLog((LOG_TRACE,1,TEXT("Found %x '%s' control"), 
				mixercontrol.pamxctrl[i].dwControlType,
				mixercontrol.pamxctrl[i].szName));
            DbgLog((LOG_TRACE,1,TEXT("Range %d-%d by %d"), 
				mixercontrol.pamxctrl[i].Bounds.dwMinimum,
				mixercontrol.pamxctrl[i].Bounds.dwMaximum,
				mixercontrol.pamxctrl[i].Metrics.cSteps));
	    CopyMemory(pmc, &mixercontrol.pamxctrl[i],
					mixercontrol.pamxctrl[i].cbStruct);
    	    QzTaskMemFree(mixercontrol.pamxctrl);
	    // caller must close the mixer handle
    	    return NOERROR;
	}
    }
    QzTaskMemFree(mixercontrol.pamxctrl);
    mixerClose((HMIXER)ID);
    return E_NOTIMPL;	// ???
}


HRESULT CWaveInInputPin::put_Enable(BOOL fEnable)
{
    HMIXEROBJ ID;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Enable %d"), m_dwLineID, fEnable));

    // Get the mute switch control
    MIXERCONTROL mc;
    if (m_pFilter->m_fUseMixer) {
        hr = GetMixerControlBPC(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels,
								&mc);
    } else {
        hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels,
								&mc);
    }

    if (hr != NOERROR && fEnable) {
	hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels,
			     &mc, m_pFilter->m_dwDstLineID);
	DbgLog((LOG_TRACE, 1, TEXT("using CONTROLTYPE_MIXER returned %x"), hr));
	
	if (hr == NOERROR && m_dwMuxIndex != 0xffffffff) {
	    MIXERCONTROLDETAILS_BOOLEAN *pmxcd_b;
	    
	    pmxcd_b = new MIXERCONTROLDETAILS_BOOLEAN[mc.cMultipleItems];
	    if (!pmxcd_b)
		return E_OUTOFMEMORY;
	    
	    mixerdetails.cbStruct = sizeof(mixerdetails);
	    mixerdetails.dwControlID = mc.dwControlID;
	    mixerdetails.cChannels = 1;
	    mixerdetails.cMultipleItems = mc.cMultipleItems;
	    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
	    mixerdetails.paDetails = pmxcd_b;
	    
	    for (DWORD dw = 0; dw < mc.cMultipleItems; dw++) {
		pmxcd_b[dw].fValue = (dw == m_dwMuxIndex);
	    }
	    
	    dw = mixerSetControlDetails(ID, &mixerdetails, MIXER_SETCONTROLDETAILSF_VALUE);
	    
	    delete[] pmxcd_b;
	    if (dw != 0) {
		DbgLog((LOG_ERROR,1,TEXT("*Error %d turning on/off mute"), dw));
		return E_FAIL;
	    }
	    
	    return NOERROR;
	    
	}
    }
    
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mute control"), hr));
	return hr;
    }

    // !!! If that didn't work, I might be able to enable/disable the channel
    // through a mixer on the destination line, you know

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fEnable ? FALSE : TRUE;
    DWORD dw = mixerSetControlDetails(ID, &mixerdetails, 
			m_pFilter->m_fUseMixer ? MIXER_OBJECTF_HMIXER : 0);
    if (m_pFilter->m_fUseMixer)
	mixerClose((HMIXER)ID);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d turning on/off mute"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Enable(BOOL *pfEnable)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Enable"), m_dwLineID));

    if (pfEnable == NULL)
	return E_POINTER;

    // Get the mute switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUTE, &ID, &cChannels, &mc);

    if (hr != NOERROR && m_dwMuxIndex != 0xffffffff) {
	hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MUX, &ID, &cChannels,
			     &mc, m_pFilter->m_dwDstLineID);
	DbgLog((LOG_TRACE, 1, TEXT("using CONTROLTYPE_MIXER returned %x"), hr));

	if (hr == NOERROR) {
	    MIXERCONTROLDETAILS_BOOLEAN *pmxcd_b;

	    pmxcd_b = new MIXERCONTROLDETAILS_BOOLEAN[mc.cMultipleItems];
	    if (!pmxcd_b)
		return E_OUTOFMEMORY;

	    mixerdetails.cbStruct = sizeof(mixerdetails);
	    mixerdetails.dwControlID = mc.dwControlID;
	    mixerdetails.cChannels = 1;
	    mixerdetails.cMultipleItems = mc.cMultipleItems;
	    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
	    mixerdetails.paDetails = pmxcd_b;

	    dw = mixerGetControlDetails(ID, &mixerdetails, MIXER_GETCONTROLDETAILSF_VALUE);

	    if (dw != 0) {
		DbgLog((LOG_ERROR,1,TEXT("*Error %d reading enabled from mixer"), dw));
		delete[] pmxcd_b;
		return E_FAIL;
	    }

	    ASSERT(m_dwMuxIndex < mc.cMultipleItems);
	    *pfEnable = pmxcd_b[m_dwMuxIndex].fValue ? TRUE : FALSE;

	    delete[] pmxcd_b;

	    return NOERROR;

	}
    }

    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mute control"), hr));
	return hr;
    }

    // !!! If that didn't work, I might be able to enable/disable the channel
    // through a mixer on the destination line, you know

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mute"), dw));
	return E_FAIL;
    }
    *pfEnable = mixerbool.fValue ? FALSE : TRUE;
    DbgLog((LOG_TRACE,1,TEXT("Enable = %d"), *pfEnable));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Mono(BOOL fMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Mono %d"), m_dwLineID, fMono));

    // Get the Mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fMono;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting mono control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Mono(BOOL *pfMono)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Mono"), m_dwLineID));

    if (pfMono == NULL)
	return E_POINTER;

    // Get the mono switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_MONO, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting mono control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting mono control"), dw));
	return E_FAIL;
    }
    *pfMono = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Mono = %d"), *pfMono));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Loudness(BOOL fLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Loudness %d"), m_dwLineID, fLoudness));

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    mixerbool.fValue = fLoudness;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting loudness control"), dw));
	return E_FAIL;
    }
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Loudness(BOOL *pfLoudness)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_BOOLEAN mixerbool;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Loudness"), m_dwLineID));

    if (pfLoudness == NULL)
	return E_POINTER;

    // Get the loudness switch control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_LOUDNESS,&ID,&cChannels,&mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting loudness control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 1;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(MIXERCONTROLDETAILS_BOOLEAN);
    mixerdetails.paDetails = &mixerbool;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting loudness"), dw));
	return E_FAIL;
    }
    *pfLoudness = mixerbool.fValue;
    DbgLog((LOG_TRACE,1,TEXT("Loudness = %d"), *pfLoudness));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_MixLevel(double Level)
{
    HMIXEROBJ ID;
    DWORD dw, volume;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROL mc;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;
    double Pan;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_MixLevel to %d"), m_dwLineID,
							(int)(Level * 10.)));

    // !!! double/int problem?
    // !!! actually use AGC? (BOOLEAN or BUTTON or ONOFF)
    if (Level == AMF_AUTOMATICGAIN)
	return E_NOTIMPL;

    if (Level < 0. || Level > 1.)
	return E_INVALIDARG;

    // Get the volume control
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    volume = (DWORD)(Level * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting volume to %d"), volume));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    // if it's not stereo, I don't understand how to pan, so the mix level
    // is simply the value of the volume control
    if (cChannels != 2) {
        DbgLog((LOG_TRACE,1,TEXT("Not stereo - treat as mono")));
        mixerdetails.cChannels = 1;	// sets all channels to same value
        mixerdetails.cbDetails = sizeof(mu.muL);
        mixerdetails.paDetails = &mu.muL;
        mu.muL.dwValue = volume;
        dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    // Stereo.  If we're panned, the channel favoured gets the value we're
    // setting, and the other channel is attenuated
    } else {
	hr = get_Pan(&Pan);
	// I don't know how to pan, so looks like we pretend we're mono
	if (hr != NOERROR || Pan == 0.) {
            DbgLog((LOG_TRACE,1,TEXT("Centre pan - treat as mono")));
            mixerdetails.cChannels = 1;	// sets all channels to same value
            mixerdetails.cbDetails = sizeof(mu.muL);
            mixerdetails.paDetails = &mu.muL;
            mu.muL.dwValue = volume;
            dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	} else {
	    if (Pan < 0.) {
                DbgLog((LOG_TRACE,1,TEXT("panned left")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = volume;
                mu.muR.dwValue = (DWORD)(volume * (1. - (Pan * -1.)));
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    } else {
                DbgLog((LOG_TRACE,1,TEXT("panned right")));
                mixerdetails.cChannels = 2;
                mixerdetails.cbDetails = sizeof(mu.muL);
                mixerdetails.paDetails = &mu;
                mu.muL.dwValue = (DWORD)(volume * (1. - Pan));
                mu.muR.dwValue = volume;
                dw = mixerSetControlDetails(ID, &mixerdetails, 0);
	    }
	}
    }

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_MixLevel(double FAR* pLevel)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_MixLevel"), m_dwLineID));

    // !!! detect if we're using AGC? (BOOLEAN or BUTTON or ONOFF)

    if (pLevel == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, pretend it's mono
    if (cChannels != 2)
	cChannels = 1;

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = cChannels;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // what I consider the current volume is the highest of the channels
    // (pan may attenuate one channel)
    dw = mu.muL.dwValue;
    if (cChannels == 2 && mu.muR.dwValue > dw)
	dw = mu.muR.dwValue;
    *pLevel = (double)dw / mc.Bounds.dwMaximum;
    DbgLog((LOG_TRACE,1,TEXT("Volume: %dL %dR is %d"), mu.muL.dwValue,
						mu.muR.dwValue, dw));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Pan(double Pan)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    // !!! What if they actually support a pan control? SNDVOL32 doesn't care...

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Pan %d"), m_dwLineID, (int)(Pan * 10.)));

    if (Pan < -1. || Pan > 1.)
	return E_INVALIDARG;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // To pan, the favoured side gets the highest of the 2 current values and
    // the other is attenuated
    dw = max(mu.muL.dwValue, mu.muR.dwValue);
    if (Pan == 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = dw;
    } else if (Pan < 0.) {
	mu.muL.dwValue = dw;
	mu.muR.dwValue = (DWORD)(dw * (1. - (Pan * -1.)));
    } else {
	mu.muL.dwValue = (DWORD)(dw * (1. - Pan));
	mu.muR.dwValue = dw;
    }
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting volume"), dw));
	return E_FAIL;
    }
    m_Pan = Pan;	// remember it
    return NOERROR;
}


HRESULT CWaveInInputPin::get_Pan(double FAR* pPan)
{
    HMIXEROBJ ID;
    DWORD dw, dwHigh, dwLow;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    struct _mu {
	MIXERCONTROLDETAILS_UNSIGNED muL;
	MIXERCONTROLDETAILS_UNSIGNED muR;
    } mu;
    HRESULT hr;

    // !!! What if they actually support a pan control? SNDVOL32 doesn't care...

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Pan"), m_dwLineID));

    if (pPan == NULL)
	return E_POINTER;

    // Get the volume control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_VOLUME, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting volume control"), hr));
	return hr;
    }

    // if this isn't a stereo control, we can't pan
    if (cChannels != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*Can't pan: not stereo!")));
	return E_NOTIMPL;
    }

    // get the current volume levels
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cChannels = 2;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cbDetails = sizeof(mu.muL);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting volume"), dw));
	return E_FAIL;
    }

    // The pan is the ratio of the lowest channel to highest channel
    dwHigh = max(mu.muL.dwValue, mu.muR.dwValue);
    dwLow = min(mu.muL.dwValue, mu.muR.dwValue);
    if (dwHigh == dwLow && dwLow == 0) {	// !!! dwMinimum?
	if (m_Pan != 64.)
	    *pPan = m_Pan;	// !!! try to be clever when both are zero?
	else
	    *pPan = 0.;
    } else {
	*pPan = 1. - ((double)dwLow / dwHigh);
	// negative means favouring left channel
	if (dwHigh == mu.muL.dwValue && dwLow != dwHigh)
	    *pPan *= -1.;
    }
    DbgLog((LOG_TRACE,1,TEXT("Pan: %dL %dR is %d"), mu.muL.dwValue,
					mu.muR.dwValue, (int)(*pPan * 10.)));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Treble(double Treble)
{
    HMIXEROBJ ID;
    DWORD dw, treble;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Treble to %d"), m_dwLineID,
							(int)(Treble * 10.)));

    if (Treble < MAX_TREBLE * -1. || Treble > MAX_TREBLE)
	return E_INVALIDARG;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    treble = (DWORD)(Treble / MAX_TREBLE * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting treble to %d"), treble));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;	// sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = treble;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting treble"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Treble(double FAR* pTreble)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Treble"), m_dwLineID));

    if (pTreble == NULL)
	return E_POINTER;

    // Get the treble control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting treble control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;	// treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting treble"), dw));
	return E_FAIL;
    }
    *pTreble = (mu.dwValue / mc.Bounds.dwMaximum * MAX_TREBLE);
    DbgLog((LOG_TRACE,1,TEXT("treble is %d"), (int)*pTreble));

    return NOERROR;
}


HRESULT CWaveInInputPin::get_TrebleRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_TrebleRange"), m_dwLineID));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a treble control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_TREBLE, &ID, &cChannels, &mc);
    if (hr != NOERROR)
	return E_NOTIMPL;

    *pRange = MAX_TREBLE;
    DbgLog((LOG_TRACE,1,TEXT("Treble range is %d.  I'M LYING !!!"),
								(int)*pRange));
    return NOERROR;
}


HRESULT CWaveInInputPin::put_Bass(double Bass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;
    DWORD bass;

    DbgLog((LOG_TRACE,1,TEXT("(%x) put_Bass to %d"), m_dwLineID,
							(int)(Bass * 10.)));

    if (Bass < MAX_BASS * -1. || Bass > MAX_BASS)
	return E_INVALIDARG;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    bass = (DWORD)(Bass / MAX_BASS * mc.Bounds.dwMaximum);
    DbgLog((LOG_TRACE,1,TEXT("Setting Bass to %d"), bass));
    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;

    mixerdetails.cChannels = 1;	// sets all channels to same value
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    mu.dwValue = bass;
    dw = mixerSetControlDetails(ID, &mixerdetails, 0);

    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d setting Bass"), dw));
	return E_FAIL;
    }

    return NOERROR;
}


HRESULT CWaveInInputPin::get_Bass(double FAR* pBass)
{
    HMIXEROBJ ID;
    DWORD dw;
    int cChannels;
    MIXERCONTROLDETAILS mixerdetails;
    MIXERCONTROLDETAILS_UNSIGNED mu;
    HRESULT hr;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_Bass"), m_dwLineID));

    if (pBass == NULL)
	return E_POINTER;

    // Get the Bass control
    MIXERCONTROL mc;
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("*Error %x getting Bass control"), hr));
	return hr;
    }

    mixerdetails.cbStruct = sizeof(mixerdetails);
    mixerdetails.dwControlID = mc.dwControlID;
    mixerdetails.cMultipleItems = 0;
    mixerdetails.cChannels = 1;	// treat as mono
    mixerdetails.cbDetails = sizeof(mu);
    mixerdetails.paDetails = &mu;
    dw = mixerGetControlDetails(ID, &mixerdetails, 0);
    if (dw != 0) {
       	DbgLog((LOG_ERROR,1,TEXT("*Error %d getting Bass"), dw));
	return E_FAIL;
    }
    *pBass = mu.dwValue / mc.Bounds.dwMaximum * MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass is %d"), (int)*pBass));

    return NOERROR;
}


HRESULT CWaveInInputPin::get_BassRange(double FAR* pRange)
{
    HRESULT hr;
    MIXERCONTROL mc;
    HMIXEROBJ ID;
    int cChannels;

    DbgLog((LOG_TRACE,1,TEXT("(%x) get_BassRange"), m_dwLineID));

    if (pRange == NULL)
	return E_POINTER;

    // Do we even have a bass control?
    hr = GetMixerControl(MIXERCONTROL_CONTROLTYPE_BASS, &ID, &cChannels, &mc);
    if (hr != NOERROR)
	return E_NOTIMPL;

    *pRange = MAX_BASS;
    DbgLog((LOG_TRACE,1,TEXT("Bass range is %d.  I'M LYING !!!"),
								(int)*pRange));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\basicaud.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
// Implements audio control interface

#ifndef __AUDCTL__
#define __AUDCTL__

// OLE Automation has different ideas of TRUE and FALSE

#define OATRUE (-1)
#define OAFALSE (0)

// This class implements the IBasicAudio interface

#define QZ_MIN_VOLUME 0		// mute
#define QZ_MAX_VOLUME 0xFFFF	// full on

class CBasicAudioControl : public CBasicAudio
{
    CWaveOutFilter *m_pAudioRenderer;         // The renderer that owns us

public:

    CBasicAudioControl(TCHAR *pName,               // Object description
                  LPUNKNOWN pUnk,             // Normal COM ownership
                  HRESULT *phr,               // OLE failure return code
                  CWaveOutFilter *pAudioRenderer); // our owner

    // These are the properties we support

    STDMETHODIMP get_Volume(long *plVolume);
    STDMETHODIMP put_Volume(long lVolume);

    STDMETHODIMP get_Balance(long *plBalance);
    STDMETHODIMP put_Balance(long lBalance);

    // And these are the methods for our friend classes - no parameter validation
    friend class CWaveOutFilter;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

    // volume is in the range -10000 to 0 (100th DB units)
    LONG        m_lVolume;
};

#endif // __AUDCTL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\audprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// Audio Renderer properties page
//
// This file is entirely concerned with the implementation of the
// properties page.

#include "audprop.rc"
class CWaveOutFilter;

class CAudioRendererProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown * punk);
    HRESULT OnDisconnect();

    // This is where we should make changes due to user action.
    // As the user cannot change anything in the property dialog
    // we have nothing to do.  Leave the skeleton here as a placeholder.
    //HRESULT OnApplyChanges();
    HRESULT OnActivate();

    CAudioRendererProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CAudioRendererProperties();

private:
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    CWaveOutFilter * m_pFilter;

#if 0
    // while the property page is read only we do not need this
    // if the property page ever becomes read/write the member
    // variable will have to be initialised
    BOOL m_bInitialized;
    void SetDirty()
    {
        ASSERT(m_pPageSite);
        if (m_bInitialized)
        {
           m_bDirty = TRUE;
           m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    }
#endif

};


class CAudioRendererAdvancedProperties : public CBasePropertyPage
{

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    HRESULT OnConnect(IUnknown * punk);
    HRESULT OnDisconnect();
    HRESULT OnActivate();

    CAudioRendererAdvancedProperties(LPUNKNOWN lpunk, HRESULT *phr);
    ~CAudioRendererAdvancedProperties();

private:
    INT_PTR OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    IAMAudioRendererStats * m_pStats;

    void UpdateSettings(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\basicaud.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// Implements audio control interface

#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include <mmsystem.h>
#include "waveout.h"

// This class implements the IBasicAudio control functions (dual interface).
// We support some methods that duplicate the properties but provide a
// more direct mechanism.

CBasicAudioControl::CBasicAudioControl(TCHAR *pName,           // Object description
                             LPUNKNOWN pUnk,         // Normal COM ownership
                             HRESULT *phr,           // OLE failure code
                             CWaveOutFilter *pAudioRenderer) : // Main renderer object
      CBasicAudio(pName,pUnk)
    , m_pAudioRenderer(pAudioRenderer)


{
    ASSERT(pUnk);
    ASSERT(m_pAudioRenderer);
}

//
// This returns the current Audio volume. We remember that we have been called
// and therefore we should set the volume in future.
//
// The structure has a public dual interface method which will lock and
// validate the parameter.  This calls a private method shared with the
// waveout filter to talk to the device.

STDMETHODIMP CBasicAudioControl::get_Volume(long *plVolume)
{
    CheckPointer(plVolume,E_POINTER);
    ValidateReadWritePtr(plVolume,sizeof(long *));

    CAutoLock cInterfaceLock(m_pAudioRenderer);

    HRESULT hr = GetVolume () ;     // gets and sets internal variable
    *plVolume = m_lVolume ;
    if ((S_OK == hr) && (m_pAudioRenderer->m_hwo))
	m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
    return hr ;
}

HRESULT CBasicAudioControl::GetVolume()
{
    return m_pAudioRenderer->m_pSoundDevice->amsndOutGetVolume(&m_lVolume);
}

//
// Set the volume.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// volume setting and we will set it later
//

STDMETHODIMP
CBasicAudioControl::put_Volume(long lVolume)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if ((AX_MAX_VOLUME < lVolume) || (AX_MIN_VOLUME > lVolume)) {
	hr = E_INVALIDARG;
    }
    else {
	m_lVolume = lVolume ;
	hr = PutVolume () ;
	if (S_OK == hr) {
	    m_pAudioRenderer->m_fVolumeSet = TRUE;
	}
    }
    return hr;
}

HRESULT CBasicAudioControl::PutVolume()
{
    return m_pAudioRenderer->m_pSoundDevice->amsndOutSetVolume(m_lVolume);
}

STDMETHODIMP CBasicAudioControl::get_Balance(long *plBalance)
{
    CheckPointer(plBalance,E_POINTER);
    ValidateReadWritePtr(plBalance,sizeof(long *));

    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if (!(m_pAudioRenderer->m_fHasVolume & (WAVECAPS_LRVOLUME))) {
        // mono cards: cannot support balance
        hr = VFW_E_MONO_AUDIO_HW;
    } else {
	hr = m_pAudioRenderer->m_pSoundDevice->amsndOutGetBalance(plBalance);
	if ((S_OK == hr) && (m_pAudioRenderer->m_hwo))
	    m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
    }
    return hr;
}


//
// Set the Balance.  This is a public method so we should validate
// the input parameter.  If the device is not connected, remember the
// Balance setting and we will set it later
//

STDMETHODIMP
CBasicAudioControl::put_Balance(long lBalance)
{
    CAutoLock cInterfaceLock(m_pAudioRenderer);
    HRESULT hr;

    if (!(m_pAudioRenderer->m_fHasVolume & (WAVECAPS_LRVOLUME))) {
        // mono cards: cannot support balance
        hr = VFW_E_MONO_AUDIO_HW;
    }
    else if ((AX_BALANCE_RIGHT < lBalance) || (AX_BALANCE_LEFT > lBalance)) {
	    return E_INVALIDARG;
    }
    else {
	hr = m_pAudioRenderer->m_pSoundDevice->amsndOutSetBalance(lBalance);
	if (S_OK == hr) {
	    m_pAudioRenderer->m_fVolumeSet = TRUE; // in future set the volume
	}
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\dsr.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _AUDIO_DSR_H_
#define _AUDIO_DSR_H_

extern AMOVIESETUP_FILTER dsFilter;

#define DXMPERF

#ifdef DEBUG
    void  DbgLogWaveFormat(DWORD Level, WAVEFORMATEX *pwfx);
#endif

//-----------------------------------------------------------------------------
// Implements the CDSoundDevice class based on DSound.
//-----------------------------------------------------------------------------

typedef void (CALLBACK *PWAVEOUTCALLBACK) (HWAVEOUT hwo, UINT uMsg,
		DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2) ;

typedef HRESULT  (WINAPI *PDSOUNDCREATE) (GUID FAR * lpGUID, LPDIRECTSOUND * ppDS,
		    IUnknown FAR *pUnkOuter );


//-----------------------------------------------------------------------------
// a class to deal with circular buffer.
//
// This assumes the following:
//
// a) Nothing is more than one iteration away.
// b) size of the buffer would be same for all tuples.
//-----------------------------------------------------------------------------
class Tuple
{

    public:

    Tuple () {
        m_itr = 0 ;
        m_offset = 0 ;
        m_size = 0 ; }

    // t1 = t2 ;
    Tuple& operator = (const Tuple &t)
    {
        ASSERT (t.m_size) ;

        m_itr = t.m_itr ;
        m_offset = t.m_offset ;
        m_size = t.m_size ;
        return *this ;
    }

    // t1 == t2 ;
    BOOL operator == (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;
        return ((m_itr == t.m_itr) && (m_offset == t.m_offset)) ;
    }

    // t1 += length ;
    // Assuming that length would never be more than size of buffer.
    Tuple& operator += (DWORD offset)
    {
        ASSERT (m_size) ;
        m_offset += offset ;
        if (m_offset >= m_size)
        {
            m_offset -= m_size ;
            ASSERT (m_offset < m_size) ;
            m_itr++ ;
        } ;
        return *this ;
    }

    // length = t1 - t2 ;
    // Assuming that t1 is known to be logically greater than t2
    DWORD operator - (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

#if 0
        if (m_itr == t.m_itr)
        {
            ASSERT (m_offset >= t.m_offset) ;
            return (m_offset - t.m_offset) ;
        }
        else
        {
            ASSERT (m_itr == (t.m_itr + 1)) ;
            return (m_offset + m_size - t.m_offset) ;
        } ;
#else
        return m_size * (m_itr - t.m_itr) + (LONG)(m_offset - t.m_offset);
#endif
    }

    // t1 > t2
    BOOL operator > (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

        return ((m_itr > t.m_itr)
                || ((m_itr == t.m_itr) && (m_offset > t.m_offset))) ;
    }

    // t1 < t2
    BOOL operator < (const Tuple& t) const
    {
        ASSERT (m_size) ;
        ASSERT (m_size == t.m_size) ;

        return ((m_itr < t.m_itr)
                || ((m_itr == t.m_itr) && (m_offset < t.m_offset))) ;
    }

    // t1 >= t2
    BOOL operator >= (const Tuple& t) const
    {
        return ( (*this > t) || (*this == t)) ;
    }

    // t1 <= t2
    BOOL operator <= (const Tuple& t) const
    {
        return ( (*this < t) || (*this == t)) ;
    }

    // Makes a tuple current based on a offset
    void MakeCurrent (DWORD offset)
    {
        ASSERT (m_size) ;
        if (offset < m_offset)
            m_itr++ ;
        m_offset = offset ;
    }

    // Makes a tuple current based on another tuples offset. Overloaded.
    void MakeCurrent (Tuple& t, DWORD offset)
    {
        ASSERT (m_size) ;

        if (offset < t.m_offset)
            m_itr = (t.m_itr + 1) ;
        else
            m_itr = t.m_itr ;
        m_offset = offset ;
    }

    // Linear length of a tuple
    DWORDLONG LinearLength ()
    {
        ASSERT (m_size) ;
        return UInt32x32To64 (m_itr,m_size) + m_offset ;
    }

    // Initializes a tuple
    void Init (DWORD itr, DWORD offset, DWORD size)
    {
        m_itr = itr ;
        m_offset = offset ;
        m_size = size ;
    }

    // data. Defined to be public for direct access.

    DWORD m_itr ;               // 0 based iteration number
    DWORD m_offset ;            // 0 based offset in above iteration.
    DWORD m_size ;              // size of the buffer.

} ;


class CDSoundDevice : public CSoundDevice
{

    friend class CWaveOutFilter;
    friend class CWaveOutFilter::CDS3D;
    friend class CWaveOutFilter::CDS3DB;

public:
    // define the public functions that this class exposes. These are all
    // modeled on the waveOut APIs. Only the APIs that are used by the
    // Quartz wave renderer are declared and defined. We may have to
    // progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // called at quartz.dll load/unload time
    static void InitClass(BOOL, const CLSID *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
			   double dRate, DWORD *pnAvgBytesPerSec,
			   DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () ; 
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

#if 0
    HRESULT  amsndGetDirectSoundInterface(LPDIRECTSOUND *lplpds);
    HRESULT  amsndGetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    HRESULT  amsndGetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
#endif
    HRESULT  amsndSetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff) ;
    HRESULT  amsndGetFocusWindow (HWND * phwnd, BOOL * pbMixingOnOrOff) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();

    CDSoundDevice () ;
    ~CDSoundDevice () ;

    HRESULT  SetRate(DOUBLE dRate, DWORD nSamplesPerSec, LPDIRECTSOUNDBUFFER pBuffer = NULL);
    void     CleanUp (BOOL bBuffersOnly = FALSE) ;
    HRESULT  RecreateDSoundBuffers(double dRate = -1.0);

    // ?? don't see how to get around making this public, since CWaveOutFilter
    // can't access it otherwise, even though the classes are friends
    LONGLONG m_llSilencePlayed;             // total amount of silence played
    LONGLONG            m_llAdjBytesPrevPlayed;

    // make public to expose to waveout filter for unmarked gap detection
    REFERENCE_TIME m_rtLastSampleEnd;

private:
    PWAVEOUTCALLBACK    m_pWaveOutProc ;        // call back for waveOut
    DWORD_PTR           m_dwCallBackInstance ;  // call back instance.
    CWaveOutFilter *    m_pWaveOutFilter;
    HWND                m_hFocusWindow ;        // the focus windows
    bool                m_fAppSetFocusWindow ;  // app has set the focus window
    bool                m_fMixing;              // global focus is on
    bool                m_bBufferLost;
    bool                m_bIsTSAudio;           // Are we a terminal server client and remoting audio? 
                                                // If so, use a larger buffer size to avoid skipping/looping.
    //BOOL              m_fEmulationMode;       // we're using DSOUND in emulation mode
    DWORD               m_dwEmulationLatencyPad;// used for emulation mode clock latency compensation
    DWORD               m_dwMinOptSampleSize;

    //=====================  Thread support  =========================

    DWORD_PTR    m_callbackAdvise;          // token associated with callback object
    typedef enum
    {
        WAVE_CLOSED,
        WAVE_PLAYING,
        WAVE_PAUSED,
    }   WaveState ;
    WaveState   m_WaveState;                // State of the wave device
    bool        m_bDSBPlayStarted ;         // play start on buffer or not
    HRESULT     m_hrLastDSoundError ;

    HRESULT StartCallingCallback();
    bool IsCallingCallback();
    void StopCallingCallback();

    void    ZeroLockedSegment (LPBYTE lpWrite, DWORD dwLength );
    DWORD   FillSoundBuffer( LPBYTE lpWrite, DWORD dwLength, DWORD dwPlayPos );
    HRESULT StreamData( BOOL bFromWrite, BOOL bUseLatencyPad = FALSE );
    void    StreamHandler( void );
    void    FlushSamples () ;
    LONGLONG GetPlayPosition (BOOL bUseAdjustedPos = FALSE) ;
    HRESULT CreateDSound(BOOL bQueryOnly = FALSE);
    HRESULT CreateDSoundBuffers(double dRate = -1.0);
    HRESULT GetDSBPosition () ;
    void    AddAudioBreak (Tuple& t1, Tuple& t2) ;
    void    RefreshAudioBreaks (Tuple& t) ;
    BOOL    RestoreBufferIfLost(BOOL bRestore);
    HRESULT SetPrimaryFormat( LPWAVEFORMATEX pwfx, BOOL bRetryOnFailure = FALSE);

    HRESULT SetFocusWindow(HWND hwnd);
    HRESULT SetMixing(BOOL bMixingOnOrOff);
    DWORD   GetCreateFlagsSecondary( WAVEFORMATEX * pwfx );
    HRESULT SetBufferVolume( LPDIRECTSOUNDBUFFER lpDSB, WAVEFORMATEX * pwfx );
    HRESULT SetSRCQuality( DWORD dwQuality );
    HRESULT GetSRCQuality( DWORD *pdwQuality );


    static  void __stdcall StreamingThreadCallback( DWORD_PTR lpvThreadParm );
    CCritSec  m_cDSBPosition ;              // locks access to StreamData

    //====================  DirectSound access ======================

#define THREAD_WAKEUP_INT_MS 100            // wakeup every 100ms.
#define OUR_HANDLE (HWAVEOUT) 0x9999        // dummy handle value that we use.

    HINSTANCE           m_hDSoundInstance;  // instance handle to dsound.dll
protected:
    LPDIRECTSOUND       m_lpDS;             // DirectSound object
    LPDIRECTSOUNDBUFFER m_lpDSBPrimary;     // DirectSoundBuffer primary buffer
    LPDIRECTSOUNDBUFFER m_lpDSB;            // DirectSoundBuffer looping buffer

    IDirectSound3DListener *m_lp3d;	    // used for 3D calls
    IDirectSound3DBuffer   *m_lp3dB;	    // used for 3D calls

private:
#if 0
    DWORD   m_dwFillThreshold;              // how empty our buffer must be before we attempt to write
#endif
    DWORD   m_dwBufferSize;                 // length of m_lpDSB in bytes
    DWORD   m_dwBitsPerSample;              // sample size
    DWORD   m_nAvgBytesPerSec;

    //  helper
    DWORD   AdjustedBytesPerSec() const
    {
        return m_dRate == 1.0 ? m_nAvgBytesPerSec : (DWORD)(m_nAvgBytesPerSec * m_dRate);
    }
    DWORD   m_dwRipeListPosition;           // bytes position for nodes in ripe list

    GUID    m_guidDSoundDev;                // guid of selected dsound device

    double  m_dRate;                        // the requested playback rate

    class CRipe
    //  These don't need to be objects in retail because their lifetime
    //  is controlled by the filter
#ifdef DEBUG
    : CBaseObject
#endif
    {
        friend class CDSoundDevice ;
        CRipe(TCHAR *pName)
#ifdef DEBUG
        : CBaseObject(pName)
#endif
        {};

        DWORD           dwLength;           // Bytes left in lpBuffer
        DWORD           dwPosition;         // The end byte position for this stream
        LPBYTE          lpBuffer;           // Data bytes
        DWORD_PTR       dwSample;               // passed in CMediaSample*
        BOOL            bCopied;            // copied to DSB or not.
        DWORD           dwBytesToStuff;     // Total bytes when started
#ifdef DXMPERF
        BOOL                    bFresh;                         // true = no data has been copied out
        REFERENCE_TIME  rtStart;                        // reference time from the original IMediaSample
#endif // DXMPERF
    };



#ifdef DEBUG
    DWORD   m_NumSamples ;                  // number of samples
    DWORD   m_NumCallBacks ;                // number of callbacks
    DWORD   m_NumCopied ;                   // number of samples copied
    DWORD   m_cbStreamDataPass ;            // Number of times thru StreamData
#endif

    class CAudBreak
    //  These don't need to be objects in retail because their lifetime
    //  is controlled by the filter
#ifdef DEBUG
    : CBaseObject
#endif
    {
        friend class CDSoundDevice ;
        CAudBreak (TCHAR *pName)
#ifdef DEBUG
        : CBaseObject(pName)
#endif
        {};

        Tuple           t1 ;                // break starts here
        Tuple           t2 ;                // break ends here
    };


    Tuple   m_tupPlay ;                     // play cursor
    Tuple   m_tupWrite ;                    // write cursor
    Tuple   m_tupNextWrite ;                // next write position.

    long     m_lStatFullness;
    long     m_lStatBreaks;                 // Audio breaks
    long     m_lPercentFullness;            // keep track of sound buffer fullness


#ifdef DEBUG
    DWORD   m_lastThWakeupTime ;            // last time thread woke up.
    DWORD   m_NumBreaksPlayed ;             // number of breaks played
    DWORD   m_dwTotalWritten ;              // total number of bytes written
#endif
    DWORD   m_NumAudBreaks ;                // number of Audio Breaks


#ifdef PERF
    //====================  Perf loggig  ============================
    int     m_idDSBWrite ;                  // MSR_id for writing to DSB memory
    int     m_idThreadWakeup ;              // MSR_id for thread wake up times.
    int     m_idGetCurrentPosition ;        // MSR_id for GetCurrentPosition times
    int     m_idWaveOutGetNumDevs ;         // MSR_id for waveOutGetNumDevs
#endif

    //====================  Ripe buffer list  ======================
    CCritSec  m_cRipeListLock ;             // serializes access to Ripe List

    // Typed advise holder list derived from the generic list template

    typedef CGenericList<CRipe> CRipeList;
    CRipeList m_ListRipe;                   // List of ripe buffers

    //====================  Audio Break list  ======================
    //  Serialized with m_cDSBPosition

    // Typed advise holder list derived from the generic list template

    typedef CGenericList<CAudBreak> CAudBreakList;
    CAudBreakList m_ListAudBreak;           // List of audio breaks

    //====================  Volume/Balance  ======================

    LONG m_lBalance;        // last set balance -10,000 to 10,000
    LONG m_lVolume; // last set volume -10,000 to 0

    //==================== Error Recovery ========================

#ifdef ENABLE_10X_FIX
    void Reset10x();

    UCHAR   m_ucConsecutiveStalls;  // The number of consecutive times we receive a zero-lock size from DSOUND
    BOOL    m_fRestartOnPause;              // TRUE => shutdown all DSOUND buffers on next pause (force restart on pause)
#endif // 10x


    //==================== Handle gaps ============================
    DWORD          m_dwSilenceWrittenSinceLastWrite;

#ifdef PERF
    int     m_idAudioBreak;
#endif
};

typedef CDSoundDevice *PDSOUNDDEV;

inline bool CDSoundDevice::IsCallingCallback()
{
    // m_callbackAdvise only equals 0 if the callback function
    // has not been started.
    return (0 != m_callbackAdvise);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\midif.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD		dwDivision;
    DWORD		dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\midiout.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CMidiOutDevice class based on midiOut APIs
//-----------------------------------------------------------------------------

extern const AMOVIESETUP_FILTER midiFilter;

class CMidiOutDevice : public CSoundDevice
{

public:
    // define the public functions that this class exposes. These are all
    // straight calls to the corresponding waveOut APIs. Only the APIs that are
    // used by the Quartz wave renderer are declared and defined. We may have
    // to progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
                           double dRate, DWORD *pnAvgBytesPerSec,
                           DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () { return NOERROR; };
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    void     amsndOutGetFormat (CMediaType *pmt)
    {
        pmt->SetType(&MEDIATYPE_Midi);
    }
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();
    bool     amsndOutCanDynaReconnect() { return false; } // MIDI renderer doesn't support dynamic reconnection

    CMidiOutDevice () ;
    ~CMidiOutDevice () ;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume ();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

	// Get the current balance from right/left amp factors
	void GetBalance();

	class CVolumeControl : CBaseObject
	{
	    friend class CMidiOutDevice ;
		CVolumeControl(TCHAR *pName) : CBaseObject(pName) {};

		DWORD dwMixerID;
		DWORD dwControlID;
		DWORD dwChannels;
	};

    // volume is in the range -10000 to 0 (100th DB units)
    // amplitude and Balance are cumulative
    LONG	m_lVolume;
    LONG	m_lBalance;

    WORD	m_wLeft;		// Left channel volume
    WORD	m_wRight;		// Right channel volume
    DWORD	m_dwWaveVolume;
    BOOL	m_fHasVolume;		// wave device can set the volume

    HMIDISTRM	m_hmidi;		// remember the handle of the open device

	UINT	m_iMidiOutId;		// output device to open

    BOOL	m_fDiscontinuity;

    DWORD	m_dwDivision;
    DWORD_PTR   m_dwCallBack;
    DWORD_PTR   m_dwCallBackInstance;

	BOOL		    m_fBalanceSet;				// remember if the balance was explictly set at least once

	typedef CGenericList<CVolumeControl> CVolumeControlList;
	CVolumeControlList m_ListVolumeControl;

	MMRESULT		DoDetectVolumeControl();		// enumerate over all mixers, lines, and line controls, looking for line supporting MIDI balance
	MMRESULT		DoSetVolumeControl(CVolumeControl *pControl, DWORD dwLeft, DWORD dwRight);  	// set a balance control
	MMRESULT		DoGetVolumeControl(CVolumeControl *pControl, WORD *pwLeft, WORD *pwRight); // get a balance control
    	MMRESULT		DoOpen();

    static void MIDICallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
					DWORD_PTR dw1, DWORD_PTR dw2);

	WCHAR	m_wszResourceName[100]; // for resource manager
	void	SetResourceName();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\dsr.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CDSoundDevice class based on DSound.
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#include <dsound.h>
#include <mmreg.h>
#include <malloc.h>
#ifndef FILTER_DLL
#include <stats.h>
#endif
#include "waveout.h"
#include "dsr.h"
#include <limits.h>
#include <measure.h>        // Used for time critical log functions
#include <ks.h>
#include <ksmedia.h>

#ifdef DXMPERF
#include <dxmperf.h>
#endif // DXMPERF

#define _AMOVIE_DB_
#include "decibels.h"

#ifdef DETERMINE_DSOUND_LATENCY
extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);
#else
#ifdef DXMPERF
extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);
#endif // DXMPERF
#endif // DETERMIN_DSHOW_LATENCY

#ifdef PERF
#define AUDRENDPERF(x) x
#else
#define AUDRENDPERF(x)
#endif

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its direct sound guise.
// Note: waveOutOpPin is common to direct sound and waveout renderers.
//

AMOVIESETUP_FILTER dsFilter = { &CLSID_DSoundRender     // filter class id
                    , L"DSound Audio Renderer"  // filter name
                    , MERIT_PREFERRED-1         // dwMerit
                    , 1
                    , &waveOutOpPin };


// formerly DSBCAPS_CNTRLDEFAULT
const DWORD gdwDSBCAPS_CTRL_PAN_VOL_FREQ = DSBCAPS_CTRLPAN | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY;

const MAJOR_ERROR = 5 ;
const MINOR_ERROR = 10 ;
const TRACE_THREAD_STATUS = 100 ;
const TRACE_TIME_REPORTS = 100;
const TRACE_FOCUS = 100 ;
const TRACE_FORMAT_INFO = 15 ;
const TRACE_SYSTEM_INFO = 10 ;
const TRACE_STATE_INFO = 10 ;
const TRACE_CALL_STACK = 10 ;
const TRACE_CALL_TIMING = 1 ;
const TRACE_SAMPLE_INFO = 20 ;
const TRACE_STREAM_DATA = 5 ;
const TRACE_BREAK_DATA = 5 ;
const TRACE_THREAD_LATENCY = 5 ;
const TRACE_CLEANUP = 100 ;
const TRACE_BUFFER_LOSS = 3 ;

const DWORD EMULATION_LATENCY_DIVISOR = 8;    // Emulation mode clock latency may be as
                                              // great as 80ms. We'll pick 1/8sec to be safe.

const DWORD MIN_SAMPLE_DUR_REQ_FOR_OPT = 50;  // Only use buffer optimization if sample duration
                                              // is greater than this millisec value.
const DWORD OPTIMIZATION_FREQ_LIMIT = 1000 / MIN_SAMPLE_DUR_REQ_FOR_OPT; // our divisor to find buffer size for opt

//  Helpers to round dsound buffer sizes etc
DWORD BufferSize(const WAVEFORMATEX *pwfx, BOOL bUseLargeBuffer)
{
    if (pwfx->nBlockAlign == 0) {
        return pwfx->nAvgBytesPerSec;
    }
    DWORD dw = pwfx->nAvgBytesPerSec + pwfx->nBlockAlign - 1;
    DWORD dwSize = dw - (dw % pwfx->nBlockAlign); 
    if(bUseLargeBuffer)
    {
        dwSize *= 3; // use 3 second buffer in these cases
    }
    return dwSize;
}

bool IsNativelySupported( PWAVEFORMATEX pwfx );
bool CanWriteSilence( PWAVEFORMATEX pwfx );


//-----------------------------------------------------------------------------
// CreateInstance for the DSoundDevice. This will create a new DSoundDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CDSoundDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
#ifdef PERF
    int m_idWaveOutGetNumDevs   = MSR_REGISTER("waveOutGetNumDevs");
#endif

    // make sure that there is at least one audio card in the system. Fail
    // the create instance if not.
    DbgLog((LOG_TRACE, 2, TEXT("Calling waveOutGetNumDevs")));
    AUDRENDPERF(MSR_START(m_idWaveOutGetNumDevs));
    MMRESULT mmr = waveOutGetNumDevs();
    AUDRENDPERF(MSR_STOP(m_idWaveOutGetNumDevs));
    if (0 == mmr)
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }
    DbgLog((LOG_TRACE, 2, TEXT("Called waveOutGetNumDevs")));

    return CreateRendererInstance<CDSoundDevice>(pUnk, &dsFilter, phr);
}

//-----------------------------------------------------------------------------
// CDSoundDevice constructor.
//
// This simply gets the default window for later use and intialized some
// variable. It also saves the passed in values for the filtergraph and filter
//-----------------------------------------------------------------------------
CDSoundDevice::CDSoundDevice ()
  : m_ListRipe(NAME("CDSoundFilter ripe list"))
  , m_ListAudBreak (NAME("CDSoundFilter Audio Break list"))
  , m_WaveState ( WAVE_CLOSED )
  , m_lpDS ( NULL )
  , m_lpDSBPrimary ( NULL )
  , m_lpDSB ( NULL )
  , m_lp3d ( NULL )
  , m_lp3dB ( NULL )
  , m_hDSoundInstance ( NULL )
  , m_pWaveOutFilter ( NULL )
  , m_callbackAdvise ( 0 )
  , m_hFocusWindow (NULL)
  , m_fAppSetFocusWindow (FALSE)
  , m_fMixing (TRUE)
  , m_lBalance (AX_BALANCE_NEUTRAL)
  , m_lVolume (AX_MAX_VOLUME)
  , m_guidDSoundDev (GUID_NULL)
  , m_dRate(1.0)
  , m_bBufferLost(FALSE)
  , m_pWaveOutProc(NULL)
  , m_bDSBPlayStarted(FALSE)
#ifndef FILTER_DLL
  , m_lStatFullness(g_Stats.Find(L"Sound buffer percent fullness", true))
  , m_lStatBreaks(g_Stats.Find(L"Audio Breaks", true))
#endif
//  , m_fEmulationMode(FALSE)  //removing after discovering WDM latency
  , m_dwSilenceWrittenSinceLastWrite(0)
  , m_NumAudBreaks( 0 )
  , m_lPercentFullness( 0 )
  , m_hrLastDSoundError( S_OK )
  , m_bIsTSAudio( FALSE )
{
#ifdef ENABLE_10X_FIX
    Reset10x();
#endif

#ifdef PERF
    m_idDSBWrite            = MSR_REGISTER("Write to DSB");
    m_idThreadWakeup        = MSR_REGISTER("Thread wake up time");
    m_idAudioBreak          = MSR_REGISTER("Audio break (ms)");
    m_idGetCurrentPosition  = MSR_REGISTER("GetCurrentPosition");
#endif

    if( GetSystemMetrics( SM_REMOTESESSION ) ) // flag supported on NT4 sp4 and later, should just fail otherwise
    {
        DbgLog((LOG_TRACE, 2, TEXT("** Using remote audio **")) );
        m_bIsTSAudio = TRUE;
    }
}

//-----------------------------------------------------------------------------
// CDSoundDevice destructor.
//
// Just makes sure that the DSound device has been closed. It also frees the
// ripe list
//-----------------------------------------------------------------------------

CDSoundDevice::~CDSoundDevice ()
{
    // the DirectSound object itself may have lived around till this point
    // because we may have just called QUERY_FORMAT and then dismantled the
    // graph. If it is still around, get rid of it now.
    if (m_lpDS)
    {
        HRESULT hr = m_lpDS->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("~CDSoundDevice: Release of lpDS failed: %u"), hr & 0x0ffff));
        }
        m_lpDS = NULL;
    }

    ASSERT (m_lpDSBPrimary == NULL) ;
    ASSERT (m_lpDSB == NULL) ;
    ASSERT (m_ListRipe.GetCount () == 0) ;
    ASSERT (m_ListAudBreak.GetCount () == 0) ;

}

//-----------------------------------------------------------------------------
// amsndOutClose.
//
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutClose ()
{
    // if the wave device is still playing, return error
    if (m_WaveState == WAVE_PLAYING)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutClose called when device is playing")));

#ifdef BUFFERLOST_FIX
        if (!RestoreBufferIfLost(FALSE))
        {
            // if we've lost the buffer allow cleanup to continue
            DbgLog((LOG_TRACE,TRACE_BUFFER_LOSS,TEXT("amsndOutClose: We've lost the dsound buffer, but we'll cleanup anyway")));
        }
        else
        {
#endif BUFFERLOST_FIX
            DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutClose called when device is playing")));
            return WAVERR_STILLPLAYING ;
#ifdef BUFFERLOST_FIX
        }
#endif BUFFERLOST_FIX
    }

    StopCallingCallback();

     // clean up all the DSound objets.
    CleanUp();

#ifdef ENABLE_10X_FIX
    Reset10x();
#endif

    // make the WOM_CLOSE call back

    if (m_pWaveOutProc)
        (* m_pWaveOutProc) (OUR_HANDLE, WOM_CLOSE, m_dwCallBackInstance, 0, 0) ;
    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CDSoundDevice::amsndOutGetResourceName ()
{
    return NULL;
}

//-----------------------------------------------------------------------------
// waveGetDevCaps
//
// Currently this is being used in the waveRenderer to simply figure out whether
// the device will support volume setting.
//
// As we create the secondary buffer to have CTRLVOLUME and CTRLPAN. These will
// always be there. So we will not even call DSound on this call.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
    // if not enough memory has been returned to set the dwSupport field (which
    // also happens to be the last field in the structure) return error.
    // This is a bit of a difference from the actual waveOut APIs. However,
    // as I said, this is specific to what the waveRenderer needs.

    if (cbwoc != sizeof (WAVEOUTCAPS))
    {
        DbgLog((LOG_ERROR, MINOR_ERROR,TEXT("waveGetDevCaps called with not enough return buffer")));
        return MMSYSERR_NOMEM ;
    }

    pwoc->dwSupport |= (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME) ;

    return MMSYSERR_NOERROR ;
}

#ifdef DEBUG
char errText[] = "DirectSound error: no additional information";
#endif

//-----------------------------------------------------------------------------
// amsndOutGetErrorText
//
// This code currently does not do any thing. A reasonable thing to do would
// be to keep track of all the errors that this file returns and to return
// those via strings in the .RC file. Since this is currently being used in
// DEBUG only code in the waveRenderer, I have not bothered to do this extra
// bit of work.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
#ifdef DEBUG
    memcpy(pszText, errText, min(cchText, sizeof(errText)) * sizeof(TCHAR));
#else
    *pszText = 0;
#endif
    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutGetPosition
//
// This function will ALWAYS return the position as a BYTE offset from the
// beginning of the stream. It will not bother to check the requested format
// for this information (we are legitimately allowed to do so.)
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amsndOutGetPosition called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    if (cbmmt < sizeof (MMTIME))
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amsndOutGetPosition called with small time buffer")));
        return MMSYSERR_NOMEM ;
    }

    // we will always return time as bytes.
    pmmt->wType = TIME_BYTES ;

    *(UNALIGNED LONGLONG *)&pmmt->u.cb = GetPlayPosition(bUseUnadjustedPos);

    DbgLog((LOG_TRACE, TRACE_TIME_REPORTS, TEXT("Reported Time = %u"), pmmt->u.cb));
    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MINOR_ERROR,TEXT("amsndOutGetPosition called when lpDSB is NULL")));
        *plBalance = m_lBalance;

        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->GetPan (plBalance) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutGetBalance: GetPan failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lBalance = *plBalance;
    }
    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("amGetVolume called when lpDSB is NULL")));
        *plVolume = m_lVolume;
        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->GetVolume (plVolume) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutGetVolume: GetVolume failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lVolume = *plVolume;
    }
    return hr ;
}


HRESULT CDSoundDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::amsndOutCheckFormat")));

    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio) {
        return E_INVALIDARG;
    }

    // if it's MPEG audio, we want it without packet headers.
    if (pmt->subtype == MEDIASUBTYPE_MPEG1Packet) {
        return E_INVALIDARG;
    }

    if (pmt->formattype != FORMAT_WaveFormatEx &&
        pmt->formattype != GUID_NULL) {
        return E_INVALIDARG;
    }

    //
    // it would always be safer to explicitly check for those formats
    // we support rather than tossing out the ones we know are not
    // supported.  Otherwise, if a new format comes along we could
    // accept it here but barf later.
    //

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT))
        return E_INVALIDARG;

    {
        // if filter's running prevent it from getting stopped in the middle of this
        CAutoLock lock(m_pWaveOutFilter);

        UINT err = amsndOutOpen(NULL,
                                (WAVEFORMATEX *) pmt->Format(),
                                dRate,
                                0,   // pnAvgBytesPerSec
                                0,
                                0,
                                WAVE_FORMAT_QUERY);

        if (err != 0) {
#ifdef DEBUG
            TCHAR message[100];
            waveOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
            DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("Error checking wave format: %u : %s"), err, message));
#endif
            if (WAVERR_BADFORMAT == err) {
                return VFW_E_UNSUPPORTED_AUDIO;
            } else {
                return VFW_E_NO_AUDIO_HARDWARE;
            }
        }
    }
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::amsndOutCheckFormat")));

    return S_OK;
}


HRESULT CDSoundDevice::CreateDSound(BOOL bQueryOnly)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::CreateDSound")));

    HRESULT hr = S_OK;
    
    // already open
    if (m_lpDS)
        goto set_coop ;         // set the cooperative level and return
        
    // create the DSound object now.  We LoadLibrary DSOUND and use
    // GetProcAddress instead of static linking so that our dll will
    // still load on platforms that do not have DSound yet.
    if(!m_hDSoundInstance)
    {
        DbgLog((LOG_TRACE, 2, TEXT("Loading DSound.DLL")));
        m_hDSoundInstance = LoadLibrary (TEXT("DSOUND.DLL")) ;
        DbgLog((LOG_TRACE, 2, TEXT("Loaded DSound.DLL")));
        if (m_hDSoundInstance == NULL) {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("DSOUND.DLL not in the system!")));
            return MMSYSERR_NODRIVER ;
        }
    }
    PDSOUNDCREATE       pDSoundCreate;    // ptr to DirectSoundCreate
    DbgLog((LOG_TRACE, 2, TEXT("Calling DirectSoundCreate")));
    pDSoundCreate = (PDSOUNDCREATE) GetProcAddress (m_hDSoundInstance,
                        "DirectSoundCreate") ;
    DbgLog((LOG_TRACE, 2, TEXT("Called DirectSoundCreate")));
    if (pDSoundCreate == NULL) {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("DirectSoundCreate not exported by DSOUND.DLL!")));
        return MMSYSERR_NODRIVER ;
    }

    hr = (*pDSoundCreate)( m_guidDSoundDev == GUID_NULL ? 0 : &m_guidDSoundDev, &m_lpDS, NULL );
    if( hr != DS_OK ) {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** DirectSoundCreate failed! %u"), hr & 0x0ffff));

        // If the create failed because the device is allocated, return
        // the corresponding MMSYSERR message, else the generic message
        if (hr == DSERR_ALLOCATED)
            return MMSYSERR_ALLOCATED ;
        else
            return MMSYSERR_NODRIVER ;
    }
    
    // after this point m_lpDS is valid and we will not try and
    // load DSound again
    ASSERT(m_lpDS);

set_coop:

    if (!bQueryOnly)
    {
        // If the application has set a focus windows, use that, or else
        // we will just pick the foreground window and do global focus.
        HWND hFocusWnd ;
        if (m_hFocusWindow)
            hFocusWnd = m_hFocusWindow ;
        else
            hFocusWnd = GetForegroundWindow () ;
        if (hFocusWnd == NULL)
            hFocusWnd = GetDesktopWindow () ;

        // Set the cooperative level
        DbgLog((LOG_TRACE, TRACE_FOCUS, TEXT(" hWnd for SetCooperativeLevel = %x"), hFocusWnd));
        hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** Warning: SetCooperativeLevel failed 1st attempt! %u"), hr & 0x0ffff));
            if (!m_fAppSetFocusWindow)
            {
                //
                // only do when we weren't explicitly given an hwnd
                //
                // It's possible that we got the wrong window on the GetForegroundWindow
                // call (and even worse, we got some other window that's been destroyed),
                // so if this failed we will try the
                // GetForegroundWindow()/SetCooperativeLevel() pair of calls a few more
                // times in hopes of getting a valid hwnd.
                //
                const int MAX_ATTEMPTS_AT_VALID_HWND = 10;
                int cRetry = 0;

                while (cRetry < MAX_ATTEMPTS_AT_VALID_HWND)
                {
                    hFocusWnd = GetForegroundWindow () ;
                    if (!hFocusWnd)
                        hFocusWnd = GetDesktopWindow () ;

                    hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
                    if ( DS_OK == hr )
                        break;

                    cRetry++;
                }
                if ( DS_OK != hr )
                {
                    DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** SetCooperativeLevel failed after multiple attempts! %u"), hr & 0x0ffff));
                }
            }
        }
    }            
   
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::CreateDSound")));

    return NOERROR;
}

HRESULT CDSoundDevice::CreateDSoundBuffers(double dRate)
{

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::CreateDSoundBuffers")));

    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();
    DSBUFFERDESC dsbd;
    HRESULT hr = S_OK;
    
    // already made
    if (m_lpDSBPrimary)
        return NOERROR;

    // can't do this until somebody calls CreateDSound
    if (m_lpDS == NULL)
        return E_FAIL;

    memset( &dsbd, 0, sizeof(dsbd) );
    dsbd.dwSize  = sizeof(dsbd);
    // Just in case we want to do neat 3D stuff
    //
    dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER;

    // If we want to use 3D, we need to create a special primary buffer, and
    // make sure it's stereo
    if (m_pWaveOutFilter->m_fWant3D) {
        DbgLog((LOG_TRACE,3,TEXT("*** Making 3D primary")));
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }
    hr = m_lpDS->CreateSoundBuffer( &dsbd, &m_lpDSBPrimary, NULL );

    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Primary buffer can't be created: %u"), hr &0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    // set the format. This is a hint and may fail. DSound will do the right
    // thing if this fails.
    // and do a retry with a smart rate if it fails?
    hr = SetPrimaryFormat( pwfx, TRUE );
    if (DS_OK != hr)
    {
        CleanUp();
        return hr;
    }

    // if it fails, we won't use it
    if (m_pWaveOutFilter->m_fWant3D) {
        hr = m_lpDSBPrimary->QueryInterface(IID_IDirectSound3DListener,
                        (void **)&m_lp3d);
        if (hr == DS_OK)
            DbgLog((LOG_TRACE,3,TEXT("*** got LISTENER interface")));
        else
            DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no LISTENER interface")));
    }
    
    memset( &dsbd, 0, sizeof(dsbd) );
    dsbd.dwSize        = sizeof(dsbd);
    dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
    dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio);  // one second buffer size
    dsbd.lpwfxFormat   = pwfx;                            // format information

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" DSB Size = %u" ), BufferSize(pwfx, m_bIsTSAudio)));

    // Dump the contents of the WAVEFORMATEX type-specific format structure
    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Creating Secondary buffer for the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    hr = m_lpDS->CreateSoundBuffer( &dsbd, &m_lpDSB, NULL );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Secondary buffer can't be created: %u"), hr &0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }
    m_bBufferLost = FALSE;
    m_llAdjBytesPrevPlayed = 0;

    // if we're slaving we need to use the lower quality SRC to have finer frequency change granularity
    if( m_pWaveOutFilter->m_fFilterClock == WAVE_OTHERCLOCK )
    {
        // if we fail just keep going (call will log result)
        HRESULT hrTmp = SetSRCQuality( KSAUDIO_QUALITY_PC );
    }    
    
#ifdef DEBUG
    //
    // if we switch from a slaved graph to one where we're the master clock we really
    // should switch back to the OS/user default SRC, but we're going to punt that to later...
    //
    //
    // call this for debug logging of the current SRC setting
    DWORD dwSRCQuality = 0;
    GetSRCQuality( &dwSRCQuality );
#endif

    hr = SetRate((dRate == -1.0 ? m_dRate : dRate), pwfx->nSamplesPerSec, m_lpDSB);
    if(hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFrequency failed: %u"), hr &0x0ffff));
        CleanUp();
        return hr;
    }
               
    // set the current position to be at 0
    hr = m_lpDSB->SetCurrentPosition( 0) ;
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    // if it fails, we won't use it
    if (m_pWaveOutFilter->m_fWant3D) {
        hr = m_lpDSB->QueryInterface(IID_IDirectSound3DBuffer,
                            (void **)&m_lp3dB);
        if (hr == DS_OK)
            DbgLog((LOG_TRACE,3,TEXT("*** got 3DBUFFER interface")));
        else
            DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no 3DBUFFER interface")));
    }

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::CreateDSoundBuffers")));
    return NOERROR;
}

//-----------------------------------------------------------------------------
// RecreateDSoundBuffers
//
// Used to perform dynamic changes. The steps we take here are:
//
// a) Reset the current primary buffer format to the new.
// b) Prepare a new secondary buffer with the new format.
// c) Lock the DSBPosition critical section and reset our circular buffer
//    sizes and other buffer data.
// d) If we were previously playing:
//          1) Flush the current buffers
//          2) Add the current byte offset to any previous value.
//          3) Start playing the new secondary buffer.
//          4) Stop playing the old secondary buffer.
// e) Set our current secondary buffer to the new one.
// f) Unlock the critical section.
// g) Release the old buffer.
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::RecreateDSoundBuffers(double dRate)
{
    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Entering CDSoundDevice::RecreateDSoundBuffers")));

    HRESULT hr = S_OK;

    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();

    // already made
    if (!m_lpDSBPrimary)
    {
        DbgLog((LOG_TRACE,4,TEXT("RecreateDSoundBuffers: No primary buffer was created")));
        return NOERROR;
    }

    // can't do this until somebody calls CreateDSound
    if (m_lpDS == NULL)
    {
        DbgLog((LOG_TRACE,4,TEXT("RecreateDSoundBuffers: m_lpDS was NULL")));
        return E_FAIL;
    }

    // Reset the primary format
    hr = SetPrimaryFormat( pwfx, TRUE ); // and do a retry with a smart rate if it fails
    if (DS_OK != hr)
    {
        CleanUp();
        return hr;
    }

    ASSERT (m_lpDSB);
    if( !m_lpDSB )
        return E_FAIL;

    DSBUFFERDESC dsbd;
    memset( &dsbd, 0, sizeof(dsbd) );
    dsbd.dwSize        = sizeof(dsbd);
    dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
    dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio); // one second buffer size
    dsbd.lpwfxFormat   = pwfx;                           // format information

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" DSB Size = %u" ), BufferSize(pwfx, m_bIsTSAudio)));

    // Dump the contents of the WAVEFORMATEX type-specific format structure
    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Creating Secondary buffer for the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    // create a new secondary buffer
    LPDIRECTSOUNDBUFFER lpDSB2 = NULL;

    hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB2, NULL );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: Secondary buffer can't be created: %u"), hr &0x0ffff));
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    hr = SetRate((dRate == -1.0 ? m_dRate : dRate), pwfx->nSamplesPerSec, lpDSB2);
    if(hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFrequency failed: %u"), hr &0x0ffff));
        if (lpDSB2) // do tidier cleanup of new buffer!!
            lpDSB2->Release();
        CleanUp();
        return hr;
    }
    // set the current position to be at 0
    hr = lpDSB2->SetCurrentPosition( 0) ; // we should be more careful here
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
        if (lpDSB2) // again do tidier cleanup of new buffer
            lpDSB2->Release();
        CleanUp () ;
        return MMSYSERR_ALLOCATED ;
    }

    LPDIRECTSOUNDBUFFER lpPrevDSB = m_lpDSB; // prepare to switch buffers
    {
        CAutoLock lock(&m_cDSBPosition);

        hr = SetBufferVolume( lpDSB2, pwfx );
        if( NOERROR != hr )
        {
            return hr;
        }
        
        // The secondary buffer was created using the pwfx, since that hasn't
        // changed since we were connected

        DWORD dwPrevBufferSize = m_dwBufferSize;

        // Update our buffer information for the new format
        m_dwBufferSize    = BufferSize(pwfx, m_bIsTSAudio);

        m_dwMinOptSampleSize = m_dwBufferSize / OPTIMIZATION_FREQ_LIMIT; //byte size
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOpen - m_dwMinOptSampleSize = %u"), m_dwMinOptSampleSize));

        m_dwEmulationLatencyPad = m_dwBufferSize / EMULATION_LATENCY_DIVISOR;


#ifdef ENABLE_10X_FIX
        Reset10x();
#endif 

        m_dwRipeListPosition = 0;
        //m_llSilencePlayed = 0; // reset rather than adjust
        m_dwBitsPerSample = (DWORD)pwfx->wBitsPerSample;
        m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;

#ifdef DEBUG
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
        m_NumSamples = 0 ;          // number of samples received
        m_NumCallBacks = 0 ;        // number of call back's done.
        m_NumCopied = 0 ;           // number of samples copied to DSB memory
        m_NumBreaksPlayed = 0 ;     // number of audio breaks played
        //m_dwTotalWritten = 0 ;      // Total number of data bytes written
#endif
        m_NumAudBreaks = 0 ;        // number of audio breaks logged

        if (m_bDSBPlayStarted)
        {
            // Since we reset our position buffers save the current byte position
            // and add this to our position reporting.
            // Note that we make the NextWrite position our new current position
            // since this should be contiguous with the next sample data we receive.
            ASSERT (dwPrevBufferSize);

            m_llAdjBytesPrevPlayed = llMulDiv (m_tupNextWrite.LinearLength() -
                                                   m_llSilencePlayed +
                                                   m_llAdjBytesPrevPlayed,
                                               m_dwBufferSize,
                                               dwPrevBufferSize,
                                               0);

            m_llSilencePlayed = llMulDiv (m_llSilencePlayed,
                                          m_dwBufferSize,
                                          dwPrevBufferSize,
                                          0);

            // amsndOutReset will reinitialize the tuples
            // to 0 offset and new buffer size
            amsndOutReset ();

            // start playing new secondary buffer
            hr = lpDSB2->Play( 0, 0, DSBPLAY_LOOPING );
            if( DS_OK == hr )
            {
                m_WaveState = WAVE_PLAYING ;    // state is now playing.
            }
            else
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_lpDSB->Play failed!(0x%08lx)"), hr ));

                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFERLOST, since that can
                // happen when coming out of hibernation?
                // at this point our main goal here is to be sure we abort in response to a NODRIVER error
                //
                m_hrLastDSoundError = hr;
                if( DSERR_BUFFERLOST != hr )
                {
                    m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                }
            }

            // stop the currently playing secondary buffer
            hr = m_lpDSB->Stop();
            if (DS_OK != hr)
            {
                DbgLog((LOG_ERROR, 1, TEXT("m_lpDSB->Stop failed!")));
            }
        }
        else
        {
            m_tupPlay.Init (0, 0, m_dwBufferSize) ;
            m_tupWrite.Init (0, 0, m_dwBufferSize) ;
            m_tupNextWrite.Init (0, 0, m_dwBufferSize) ;
        }
        m_lpDSB = lpDSB2;               // make the new buffer the current one
    }
    lpPrevDSB->Release();

    // if it fails, we won't use it
    if (m_pWaveOutFilter->m_fWant3D) {
        hr = m_lpDSB->QueryInterface(IID_IDirectSound3DBuffer,
							(void **)&m_lp3dB);
        if (hr == DS_OK)
    	    DbgLog((LOG_TRACE,3,TEXT("*** got 3DBUFFER interface")));
        else
    	    DbgLog((LOG_TRACE,3,TEXT("*** ERROR: no 3DBUFFER interface")));
    }

    DbgLog((LOG_TRACE,TRACE_CALL_STACK,TEXT("Exiting CDSoundDevice::RecreateDSoundBuffers")));
    return NOERROR;
}

//-----------------------------------------------------------------------------
// SetPrimaryFormat
//
// Used to call SetFormat on the primary buffer. If bRetryOnFailure is TRUE an
// additional SetFormat call will be tried made if the first fails, using a
// sample rate more likely to succeed and as close as we can get to the stream's
// native format (to reduce resampling artifacts).
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::SetPrimaryFormat ( LPWAVEFORMATEX pwfx, BOOL bRetryOnFailure )
{
    HRESULT hr;

    ASSERT (m_lpDSBPrimary);
    ASSERT (pwfx);

    if (!m_lpDSBPrimary || !pwfx )
        return E_FAIL;

    DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Primary format being set to the following format ..." )));
#ifdef DEBUG
    DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

    // We need a stereo primary for 3D to work
    if (m_pWaveOutFilter->m_fWant3D && pwfx->wFormatTag == WAVE_FORMAT_PCM &&
                                                pwfx->nChannels == 1) {
        WAVEFORMATEX wfx = *pwfx;       // !!! only works for PCM!
        wfx.nChannels = 2;
        wfx.nAvgBytesPerSec *= 2;
        wfx.nBlockAlign *= 2;
        hr = m_lpDSBPrimary->SetFormat(&wfx);
        DbgLog((LOG_TRACE,3,TEXT("*** Making stereo primary for 3D")));
        if (hr != DS_OK) {
            DbgLog((LOG_ERROR,1,TEXT("*** ERROR! no stereo primary for 3D")));
            hr = m_lpDSBPrimary->SetFormat(pwfx);
        }
    } else {
        hr = m_lpDSBPrimary->SetFormat(pwfx);
    }

    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CreateDSoundBuffers: SetFormat failed: %u"), hr &0x0ffff));

        if (bRetryOnFailure)
        {
            // try once more to set the primary buffer to a frequency likely to be
            // supported and as close as we can get to this stream's frequency rate,
            // in attempt to lessen sloppy resampling artifacts, otherwise it'll
            // just get set to DSound's 22k, 8 bit, mono default.
            LPWAVEFORMATEX pwfx2 = (LPWAVEFORMATEX) CoTaskMemAlloc(sizeof(WAVEFORMATEX));
            if (pwfx2 && pwfx->nSamplesPerSec > 11025)
            {
                memcpy( pwfx2, pwfx, sizeof (WAVEFORMATEX) );

                if ( (pwfx->nSamplesPerSec % 11025) || (pwfx->nSamplesPerSec > 44100) )
                {
                    DWORD nNewFreq = min( ((pwfx->nSamplesPerSec / 11025) * 11025), 44100 ) ; // round to multiple of 11025

                    DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: SetFormat failed, but trying once more with frequency: %u"), nNewFreq));

                    pwfx2->nSamplesPerSec = nNewFreq;
                    pwfx2->nAvgBytesPerSec = pwfx2->nSamplesPerSec *
                                                 pwfx2->nChannels *
                                                 pwfx2->wBitsPerSample/8 ;
                    hr = m_lpDSBPrimary->SetFormat( pwfx2 );
                    if( hr != DS_OK )
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: 2nd SetFormat attempt failed: %u"), hr &0x0ffff));
                    }
                    else
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("CreateDSoundBuffers: 2nd SetFormat attempt succeeded (freq=%d)"), pwfx2->nSamplesPerSec));
                    }
                }
            }
            CoTaskMemFree(pwfx2);
        }
    }
    return hr;
}


//-----------------------------------------------------------------------------
// amsndOutOpen
//
// Once again, based on how the Quartz wave renderer works today, this code
// currently supports only two possible uses:
//
// a) when fdwOpen is CALLBACK_FUNCTION we actually create DSound buffers and
//    objects and get the secoundary buffer going.
//
// b) when fdwOpen is WAVE_FORMAT_QUERY we create temporary DSound objects to
//    figure out if the waveformat passed in is accepted or not.
//
// When the device is actually opened, we actually start the primary buffer
// playing. It will actually play silence. Doing this makes it really cheap
// to stop/play the secondary buffer.
//-----------------------------------------------------------------------------

MMRESULT CDSoundDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
              double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
              DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{

    if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
    {
        if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_PCM &&
            ((PWAVEFORMATIEEEFLOATEX)pwfx)->SubFormat != MEDIASUBTYPE_IEEE_FLOAT &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_DOLBY_AC3_SPDIF &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_RAW_SPORT &&
            ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  != MEDIASUBTYPE_SPDIF_TAG_241h )
        {
            // only allow uncompressed and float extensible formats. oh, and ac3 over s/pdif
            return WAVERR_BADFORMAT;
        }
    }
    else if( WAVE_FORMAT_PCM != pwfx->wFormatTag &&
#ifdef WAVE_FORMAT_DRM
             WAVE_FORMAT_DRM != pwfx->wFormatTag &&
#endif
             WAVE_FORMAT_IEEE_FLOAT != pwfx->wFormatTag &&
             //
             // from the Non-pcm audio white paper:
             // "Wave format tags 0x0092, 0x0240 and 0x0241 are identically defined as 
             // AC3-over-S/PDIF (these tags are treated completely identically by many 
             // DVD applications)."
             //
             WAVE_FORMAT_DOLBY_AC3_SPDIF != pwfx->wFormatTag &&
             WAVE_FORMAT_RAW_SPORT != pwfx->wFormatTag &&
             0x241 != pwfx->wFormatTag ) 
    {
        return WAVERR_BADFORMAT;
    }

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {

        *pnAvgBytesPerSec = (dRate != 0.0 && dRate != 1.0) ?
            (DWORD)(pwfx->nAvgBytesPerSec * dRate) :
            pwfx->nAvgBytesPerSec;
    }

    //  Reset sample stuffing info
    m_rtLastSampleEnd = 0;
    m_dwSilenceWrittenSinceLastWrite = 0;

    HRESULT hr = S_OK;

    // separate out the two uses of fdwOpen flags.
    if (fdwOpen & WAVE_FORMAT_QUERY)
    {   
        hr = CreateDSound(TRUE);    // create the DSOUND object for query only
        if (hr != NOERROR)
            return hr;

        // Are we in emulation mode ? For now just log this information.

        //DSCAPS  dsCaps ;
        //memset( &dsCaps, 0, sizeof(DSCAPS) );
        //dsCaps.dwSize = sizeof(DSCAPS);

        //hr = m_lpDS->GetCaps ( &dsCaps) ;
        //if( hr != DS_OK )
        //{
        //   DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** waveOutOpen : DSound fails to return caps, %u"), hr & 0x0ffff));
        //}
        //if (dsCaps.dwFlags & DSCAPS_EMULDRIVER)
        //{
        //    m_fEmulationMode = TRUE;
        //    DbgLog((LOG_TRACE,TRACE_SYSTEM_INFO,TEXT("*** waveOutOpen : DSound in emulation mode.")));
        //}

        // Dump the contents of the WAVEFORMATEX type-specific format structure
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT(" Quering for the following format ..." )));
#ifdef DEBUG
        DbgLogWaveFormat( TRACE_FORMAT_INFO, pwfx );
#endif

        // now call DSOUND to see if it will accept the format
        {
            HRESULT             hr;
            DSBUFFERDESC        dsbd;
            LPDIRECTSOUNDBUFFER lpDSB = NULL;

            // first check to see if we can create a primary with this format, if we fail, we will rely on acmwrapper do to format conversions
            memset( &dsbd, 0, sizeof(dsbd) );
            dsbd.dwSize  = sizeof(dsbd);

            if( IsNativelySupported( pwfx ) )
            {     
                // explicity check that we can create a buffer for these formats
             
                dsbd.dwFlags = DSBCAPS_PRIMARYBUFFER;
                hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB, NULL );
                if(FAILED(hr))
                {
                    DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on primary buffer creation, %u"), hr & 0x0ffff));
                    return MMSYSERR_ALLOCATED;
                }
            }
            //
            // Since calling DSound's SetFormat (and also SetCooperativeLevel)
            // causes an audible break (pop) in any other audio currently playing
            // through DSound at a different format, we'll refrain from doing this
            // on the graph building. We still make the SetFormat call on the
            // actual open, but there the effects are much less noticeable. DSound
            // should still do the right thing if the SetFormat fails.
            //
            //    hr = lpDSB->SetFormat( pwfx );
            //    if(FAILED(hr))
            //    {
            //        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on primary buffer set format, %u"), hr & 0x0ffff));
            //        lpDSB->Release();
            //        return WAVERR_BADFORMAT ;
            //    }
            if( lpDSB )
            {            
                lpDSB->Release();
            }
                
            // now check to see if we can create a secondary with this format
            memset( &dsbd, 0, sizeof(dsbd) );
            dsbd.dwSize        = sizeof(dsbd);
            dsbd.dwFlags       = GetCreateFlagsSecondary( pwfx );
            dsbd.dwBufferBytes = BufferSize(pwfx, m_bIsTSAudio); // one second buffer size
            dsbd.lpwfxFormat   = pwfx;                           // format information

            hr = m_lpDS->CreateSoundBuffer( &dsbd, &lpDSB, NULL );

            if( hr != DS_OK )
            {
                DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("*** amsndOutOpen : CreateSoundBuffer failed on secondary buffer creation, %u"), hr & 0x0ffff));
                return WAVERR_BADFORMAT ;
            }

            hr = SetRate(dRate, pwfx->nSamplesPerSec);  // check to see if we support this rate
            lpDSB->Release();

            if(hr != DS_OK)
            {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutOpen: SetFrequency failed: %u"), hr &0x0ffff));
                return WAVERR_BADFORMAT;
            }
            return MMSYSERR_NOERROR ;
        }
    }
    else if (fdwOpen == CALLBACK_FUNCTION)
    {
        hr = CreateDSound();    // create the DSOUND object
        if (hr != NOERROR)
            return hr;

        // if we are already open, return error
        ASSERT (m_WaveState == WAVE_CLOSED) ;
        if (m_WaveState != WAVE_CLOSED)
        {
            return MMSYSERR_ALLOCATED ;
        }

        // we may have already created this by QI for the buffers
#if 0
        if( m_lpDSB )
        {
            // !!! Should this fail or should this succeed ?
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutOpen called when already open")));
            return MMSYSERR_ALLOCATED ;
        }
#endif

        hr = CreateDSoundBuffers(dRate);
        if (hr != NOERROR)
            return hr;
        
        hr = SetBufferVolume( m_lpDSB, pwfx );
        if( NOERROR != hr )
        {
            CleanUp ();
            return hr;
        }
        
        // The secondary buffer was created using the pwfx, since that hasn't
        // changed since we were connected

        m_dwBufferSize    = BufferSize(pwfx, m_bIsTSAudio);

        m_dwMinOptSampleSize = m_dwBufferSize / OPTIMIZATION_FREQ_LIMIT; //byte size
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOpen - m_dwMinOptSampleSize = %u"), m_dwMinOptSampleSize));

        //if (m_fEmulationMode)
            m_dwEmulationLatencyPad = m_dwBufferSize / EMULATION_LATENCY_DIVISOR;

#define FRACTIONAL_BUFFER_SIZE  4 // performance tuning parameter
        // a measure of how empty our buffer must be before we attempt to copy anything to it
        //m_dwFillThreshold = DWORD(m_dwBufferSize / FRACTIONAL_BUFFER_SIZE);
        m_tupPlay.Init (0,0,m_dwBufferSize) ;
        m_tupWrite.Init (0,0,m_dwBufferSize) ;
        m_tupNextWrite.Init (0,0,m_dwBufferSize) ;

#ifdef ENABLE_10X_FIX
        Reset10x();
#endif

        m_dwRipeListPosition = 0;
        m_llSilencePlayed = 0;
        m_dwBitsPerSample = (DWORD)pwfx->wBitsPerSample;
        m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
        m_bDSBPlayStarted   = FALSE ;

#ifdef DEBUG
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
        m_NumSamples = 0 ;          // number of samples received
        m_NumCallBacks = 0 ;        // number of call back's done.
        m_NumCopied = 0 ;           // number of samples copied to DSB memory
        m_NumBreaksPlayed = 0 ;     // number of audio breaks played
        m_dwTotalWritten = 0 ;      // Total number of data bytes written
#endif
        m_NumAudBreaks = 0 ;        // number of audio breaks logged

        // never used, and blows up when no clock
#if 0
        IReferenceClock * pClock;
        hr = m_pWaveOutFilter->GetSyncSource(&pClock);
        ASSERT(pClock);
        LONGLONG rtNow;
        pClock->GetTime(&rtNow);
        pClock->Release() ;
#endif

        hr = StartCallingCallback();
        if (hr != NOERROR) {
            CleanUp () ;
            return hr;
        }

        // now set the Primary buffer into play. This will play silence unless
        // the secondary buffer is set playing. However, this will also make
        // play and stop of the secondary buffers really cheap.

        DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("PLAYING the PRIMARY buffer")));
        hr = m_lpDSBPrimary->Play( 0, 0, DSBPLAY_LOOPING );
        if( hr != DS_OK )
        {
            m_hrLastDSoundError = hr;
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSBPrimary->Play! hr = %u"), hr & 0x0ffff));
            StopCallingCallback();
            CleanUp () ;
            return MMSYSERR_ALLOCATED ;
        }
        
        m_WaveState = WAVE_PAUSED ;
        *phwo = OUR_HANDLE ;
        m_pWaveOutProc = (PWAVEOUTCALLBACK) dwCallBack ;
        m_dwCallBackInstance = dwCallBackInstance ;


        // make the WOM_OPEN call back now.
        // !!! is it legit to call back right away ?
        if (m_pWaveOutProc)
            (* m_pWaveOutProc) (OUR_HANDLE, WOM_OPEN, m_dwCallBackInstance,
                        0, 0) ;

        return MMSYSERR_NOERROR ;
    }
    else
    {
        // some other form of call that is not supported yet.
        DbgBreak ("CDSoundDevice: Unsupported Open call.") ;
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutOpen: unsupported call = %u"), fdwOpen));
        return MMSYSERR_ALLOCATED ;
    }
}


//-----------------------------------------------------------------------------
// amsndOutPause
//
// This simply stops the secondary buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutPause ()
{
#ifdef ENABLE_10X_FIX
    if(m_fRestartOnPause
#ifdef BUFFERLOST_FIX
        // Note: only do this if we've got a valid dsound buffer! Also
        // note this can block for 1 second
        && RestoreBufferIfLost(TRUE)
#endif
    )
    {
        FlushSamples();  // flush everything

        // shock the dsound driver, by shutting it down.....
        CleanUp();
        
        // and then reinitializing it
         
        CreateDSound();
        CreateDSoundBuffers();
        
        if( m_lpDSB )
        {
            // since on a restart we don't check that the CreateDSoundBuffers succeeded,
            // we need to verify we have one before calling SetBufferVolume()!!
            HRESULT hrTmp = SetBufferVolume( m_lpDSB, m_pWaveOutFilter->WaveFormat() ); // ignore any error since we never even set volume here previously
            if( NOERROR != hrTmp )
            {
                DbgLog((LOG_TRACE,2,TEXT("CDSoundDevice::SetBufferVolume failed on buffer restart!( 0x%08lx )"), hrTmp ));
            }        
        }            
    }
#endif

#ifdef ENABLE_10X_FIX
    // always reset 10x counter on a pause, since we could artificially accumulate stalls doing 
    // quick play->pause->play transitions, if device takes too long to get moving
    Reset10x();
#endif

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amsndOutPause called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    if (m_WaveState == WAVE_PAUSED)
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutPause called when already paused")));
        return MMSYSERR_NOERROR ;
    }

    // stop the play of the secondary buffer.
    HRESULT hr = m_lpDSB->Stop();

#ifdef BUFFERLOST_FIX
    if( hr != DS_OK && hr != DSERR_BUFFERLOST)
#else
    if( hr != DS_OK )
#endif
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutPause: Stop of lpDSB failed: %u"), hr & 0x0ffff));
        return MMSYSERR_NOTSUPPORTED ;
    }

    m_bDSBPlayStarted = FALSE ;

    // reset last sample end time on a pause, since on a restart 
    // Run already blocks until its time to start
    // (Actually it only blocks if there's no data queued)
    m_rtLastSampleEnd = 0;

    m_WaveState = WAVE_PAUSED ;         // state is now paused.

    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutPrepareHeader
//
// This funtion really does nothing. Most of the action is initiated in
// amsndOutWrite. For consistency sake we will do handle validation.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amPrepareHeader called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutReset
//
// calls pause to stop the secondary buffer and sets the current position to 0
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutReset ()
{
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutReset called")));

    m_rtLastSampleEnd = 0;

    // If we get flushed while we're running stream time does not get
    // reset to 0 so we have to track from NOW - ie where we flushed to
    // Flushing while running is very unusual generally but DVD does it
    // all the time
    if (m_WaveState == WAVE_PLAYING) {
        CRefTime rt;
        m_pWaveOutFilter->StreamTime(rt);
        m_rtLastSampleEnd = rt;
    }
    // Flush all the queued up samples.
    FlushSamples () ;

    if (NULL != m_lpDSB) {
        // set the current position to be at 0
        HRESULT hr = m_lpDSB->SetCurrentPosition( 0) ;
        if (hr != DS_OK)
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("amsndOutReset: error in lpDSB->SetCurrentPosition! hr = %u"), hr & 0x0ffff));
            return MMSYSERR_ALLOCATED ;
        }
    }

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutReset done")));

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// waveOutBreak
//
// The waveout from end code calls this function when there is an audio break.
// For the waveout rendere, this function calls waveOutReset. However, in the
// Dsound case, just calling xxxReset is not enough. We also call xxxRestart
// so that a subsequent xxxoutWrite will know to start the play of the sound
// buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutBreak ()
{
    amsndOutReset () ;
    return amsndOutRestart () ;
}

//-----------------------------------------------------------------------------
// amsndOutRestart
//
// Sets the state of the background thread to Stream_Playing. The StreamData
// funtion will actually 'Play' the secondary buffer after it has ensured
// that there is some data in the buffer.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutRestart ()
{
    HWND hwndFocus;

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutRestart called")));

    HRESULT hr ;
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amOutRestart called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    // we automatically figure out what window to use as the focus window
    // until the app tells us which one to use, then we always use that
    if (!m_fAppSetFocusWindow) {
        hwndFocus = GetForegroundWindow();
        if (hwndFocus) {
            SetFocusWindow(hwndFocus);
            m_fAppSetFocusWindow = FALSE;   // will have been set above
            // but we aren't the app
        }
    }

    m_WaveState = WAVE_PLAYING ;         // state is now paused.

    // if there is data in the buffer then start the secondary buffer playing
    // and transition to the next state. Else continue in this state.

    ASSERT (!m_bDSBPlayStarted) ;

    if (m_tupNextWrite > m_tupPlay)
    {
        DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("StreamHandler: Stream_Starting->Stream_Playing")));

        // DWORD dwTime = timeGetTime () ;
        // DbgLog((LOG_TRACE, TRACE_CALL_TIMING, TEXT("DSound Play being called at: %u"), dwTime));


        // pre-emptive attempt to restore buffer. buffer loss seen
        // here occasionally in WinME hibernation/standby (but not
        // NT/win98se). note this can take upto 1 second.
        if(RestoreBufferIfLost(TRUE))
        {
            hr = m_lpDSB-> Play( 0, 0, DSBPLAY_LOOPING );
        }
        else
        {
            hr = DSERR_BUFFERLOST;
        }

        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("error in lpDSB->Play! hr = %u"), hr & 0x0ffff ));

            m_hrLastDSoundError = hr;
            if( DSERR_BUFFERLOST != hr )
            {
                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFERLOST, since that can
                // happen when coming out of hibernation?
                //
                m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
            }

#ifdef ENABLE_10X_FIX
            m_WaveState = WAVE_CLOSED;
            return E_FAIL;
#endif
        }
        m_bDSBPlayStarted = TRUE ;

    }
    else
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("waveOutRestart called yet no data")));
    }

    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutRestart done")));

    return MMSYSERR_NOERROR ;
}
//-----------------------------------------------------------------------------
// amsndOutSetBalance
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutSetBalance (LONG lBalance)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MAJOR_ERROR,TEXT("amSetBalance called when lpDSB is NULL")));
        m_lBalance = lBalance;

        return MMSYSERR_NOERROR ;
    }

    HRESULT hr = m_lpDSB->SetPan (lBalance) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutSetBalance: SetPan failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lBalance = lBalance;
    }
#ifdef DEBUG
    {
        LONG lBalance1 ;
        HRESULT hr = m_lpDSB->GetPan (&lBalance1) ;
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("waveOutGetBalance: GetPan failed %u"), hr & 0x0ffff));
        }
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("waveOutSetBalance log: desired = %d, actual = %d"),
            lBalance, lBalance1));
    }
#endif


    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutSetVolume
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::amsndOutSetVolume (LONG lVolume)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amSetVolume called when lpDSB is NULL")));
        m_lVolume = lVolume;

        return MMSYSERR_NOERROR;
    }

    HRESULT hr = m_lpDSB->SetVolume (lVolume) ;
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("amsndOutSetVolume: SetVolume failed %u"), hr & 0x0ffff));
    }
    else
    {
        m_lVolume = lVolume;
    }
    return hr ;
}
//-----------------------------------------------------------------------------
// amsndOutUnprepareHeader
//
// This funtion really does nothing. Most of the action is initiated in
// amsndOutWrite. For consistency sake we will do handle validation.
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutUnprepareHeader called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    return MMSYSERR_NOERROR ;
}

//-----------------------------------------------------------------------------
// amsndOutWrite
//
// Queues up the data and lets the background thread write it out to the
// sound buffer.
//
//-----------------------------------------------------------------------------
MMRESULT CDSoundDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pTimeStamp, BOOL bIsDiscontinuity)
{
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutWrite called")));

    // some validation.
    if (m_lpDSB == NULL)
    {
        DbgLog((LOG_ERROR,MINOR_ERROR,TEXT("amsndOutWrite called when lpDSB is NULL")));
        return MMSYSERR_NODRIVER ;
    }

    {
#ifdef DEBUG
        m_NumSamples ++ ;
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Sample # %u"), m_NumSamples));
#endif
        CRipe     *pRipe;
        CAutoLock lock(&m_cRipeListLock);        // lock the list

        pRipe = new CRipe(NAME("CDSoundDevice ripe buffer"));
        if( !pRipe )
        {
            DbgLog((LOG_ERROR,MINOR_ERROR, TEXT("amsndOutWrite: new CRipe failed!")));
            return MMSYSERR_NOMEM ;
        }
        pRipe->dwLength = pwh->dwBufferLength ;

        pRipe->dwBytesToStuff = 0;
        
        // Keep track of timestamp gaps in case we need to stuff silence.
        // But don't stuff silence for 'live' or compressed data.
        if( pTimeStamp &&
            0 == ( AM_AUDREND_SLAVEMODE_LIVE_DATA & m_pWaveOutFilter->m_pInputPin->m_Slave.m_fdwSlaveMode ) &&
            CanWriteSilence( (PWAVEFORMATEX) m_pWaveOutFilter->WaveFormat() ) )
        {
            //  Don't stuff for the first timestamp after 'run' because
            //  we already block until it's time to play
            if( 0 != m_rtLastSampleEnd )
            {
                //  See if this is a discontinuity and there's a gap > 20ms
                //  Also, don't stuff if we just chose to drop late audio.
                if( bIsDiscontinuity && 
                    !m_pWaveOutFilter->m_pInputPin->m_bTrimmedLateAudio &&
                    ( *pTimeStamp - m_rtLastSampleEnd > 20 * (UNITS / MILLISECONDS) ) )
                {
                    pRipe->dwBytesToStuff = (DWORD)llMulDiv(
                                                   AdjustedBytesPerSec(),
                                                   *pTimeStamp - m_rtLastSampleEnd,
                                                   UNITS,
                                                   0);
                                           
                    //  Round down to nearest nBlockAlignment
                    WAVEFORMATEX *pwfx = m_pWaveOutFilter->WaveFormat();
                    pRipe->dwBytesToStuff -= pRipe->dwBytesToStuff % pwfx->nBlockAlign;
                
                    DbgLog((LOG_TRACE, 2, TEXT("Discontinuity of %dms detected - adding %d to stuff(%d per sec)"),
                           (LONG)((*pTimeStamp - m_rtLastSampleEnd) / 10000),
                           pRipe->dwBytesToStuff, AdjustedBytesPerSec()));
                
                    //  Adjust for stuffing already written
                    CAutoLock lck(&m_cDSBPosition);
                    if (m_dwSilenceWrittenSinceLastWrite >= pRipe->dwBytesToStuff) {
                        pRipe->dwBytesToStuff = 0;
                    } else {
                        pRipe->dwBytesToStuff -= m_dwSilenceWrittenSinceLastWrite;
                    }
                    m_dwSilenceWrittenSinceLastWrite = 0;

                    //  Adjust so that it looks like this time is
                    //  included in our current position for the timestamp
                    //  of this buffer
                    DbgLog((LOG_TRACE, 8, TEXT("Stuffing silence - m_llSilencePlayed was %d"),
                            (DWORD) m_llSilencePlayed));
                    m_llSilencePlayed += pRipe->dwBytesToStuff;
                    DbgLog((LOG_TRACE, 8, TEXT("Stuffing silence - m_llSilencePlayed is now %d"),
                            (DWORD) m_llSilencePlayed));
                }
            }
            
            // now update the last sample end time that we use to keep track of gaps.
            // We update this on discontinuities and if this is the first sample since we were run.
            if( bIsDiscontinuity || 0 == m_rtLastSampleEnd )
            {
                m_rtLastSampleEnd = *pTimeStamp;        
            }
        }
        
        //  Work out the end time of this sample - note we accumulate
        //  errors a little here which we could avoid
        m_rtLastSampleEnd += MulDiv(pRipe->dwLength, UNITS, AdjustedBytesPerSec());
        DbgLog((LOG_TRACE, 8, TEXT("amsndOutWrite - m_rtLastSampleEnd(adjusted) = %dms"),
                        (LONG) (m_rtLastSampleEnd / 10000 )));
        pRipe->lpBuffer = (LPBYTE) pwh->lpData ;
        pRipe->dwSample = (m_pWaveOutFilter->m_fUsingWaveHdr) ?
               (DWORD_PTR)pwh :  // a wavehdr has been allocated on our allocator, so cache it
               pwh->dwUser;  // no wavehdr has been allocated on our allocator, so cache the supplied CSample*
        // add in length to m_dwRipeListPosition to calculate where in the
        // stream (in bytes) this sample end

        // if this buffer is discontiguous from the last m_dwSilenceNeeded
        // will be non-0 and the value in time UNITS of how much silence to
        // be played.


        m_dwRipeListPosition += pwh->dwBufferLength ;
        pRipe->dwPosition = m_dwRipeListPosition ;    // end of the sample in bytes
        DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Sample = %u, Position = %u"), pwh, pRipe->dwPosition));
        pRipe->bCopied = FALSE ;                    // data has not been copied

#ifdef DXMPERF
		pRipe->bFresh  = TRUE;
		pRipe->rtStart = m_pWaveOutFilter->m_llLastPos;
#endif // DXMPERF

        m_ListRipe.AddTail( pRipe );             // Add to ripe list
    }

    // call StreamData to write out data to the circular buffer. This will
    // make sure that we will have data when we get to starting the play
    // on the sound buffer.
    //
    //
    // But first check the duration of audio data in this sample, and if it's
    // especially small ( <= ~50ms) then we'll need to use latency pad
    // in optimization code.
    //
    if (pwh->dwBufferLength > m_dwMinOptSampleSize)
    {
        StreamData ( TRUE ) ;    // will force data to get into the buffer
    }
    else
    {
        // use latency padding in the short buffer duration case
        StreamData ( TRUE, TRUE );
    }

    // It is possible that amsndoutRestart was called before amsndOutWrite
    // is called. In this case, we need to start play on the dsound buffer here.
    // However, it is also possible to get NULL buffers delivered so we may
    // have to wait till another amsndoutWrite.

    if (!m_bDSBPlayStarted && (m_WaveState == WAVE_PLAYING))
    {
        if (m_tupNextWrite > m_tupPlay)
        {
            DbgLog((LOG_TRACE, TRACE_STATE_INFO, TEXT("Starting play from amsndOutWrite")));

            // DWORD dwTime = timeGetTime () ;
            // DbgLog((LOG_TRACE, TRACE_CALL_TIMING, TEXT("DSound Play being called at: %u"), dwTime));


            HRESULT hr = m_lpDSB->Play( 0, 0, DSBPLAY_LOOPING );
            if( hr == DS_OK )
            {
                m_bDSBPlayStarted = TRUE ;
            }
            else
            {
                DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("error in lpDSB->Play! from amsndOutWrite. hr = %u"), hr & 0x0ffff));

                //
                // if play failed we should signal abort
                // should we only do this if the error isn't BUFFER_LOST, since that can
                // happen when coming out of hibernation?
                //
                m_hrLastDSoundError = hr;
                if( DSERR_BUFFERLOST != hr )
                {
                    m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
                }
                // we are ignoring the propagation back of the error
            }

        }
    }

    return NOERROR;
    DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("amsndOutWrite done")));

}

HRESULT CDSoundDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    // caller makes sure we're not running

    if(m_lpDS)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    DbgLog((LOG_TRACE, 2, TEXT("DSR::Load enter")));

    VARIANT var;
    var.vt = VT_BSTR;
    HRESULT hr = pPropBag->Read(L"DSGuid", &var, 0);
    if(SUCCEEDED(hr))
    {
        CLSID clsidDsDev;
        hr = CLSIDFromString(var.bstrVal, &clsidDsDev);
        if(SUCCEEDED(hr))
        {
            m_guidDSoundDev = clsidDsDev;
        }

        SysFreeString(var.bstrVal);
    } else {
        hr = S_OK;
        m_guidDSoundDev = GUID_NULL;
    }

    DbgLog((LOG_TRACE, 2, TEXT("DSR::Load exit")));
    return hr;
}

HRESULT  CDSoundDevice::amsndOutWriteToStream(IStream *pStream)
{
    return pStream->Write(&m_guidDSoundDev, sizeof(m_guidDSoundDev), 0);
}

HRESULT  CDSoundDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_lpDS)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running
    return pStream->Read(&m_guidDSoundDev, sizeof(m_guidDSoundDev), 0);
}

int CDSoundDevice::amsndOutSizeMax()
{
    return sizeof(m_guidDSoundDev);
}

//-----------------------------------------------------------------------------
//
// FillSoundBuffer()
//
// Fills the lpWrite buffer with as much data it will take or is ripe and
// returns the amount written.
//
// Code is pretty piggy with all those += dwWrite, but the compiler
// usually does a good job at minimizing redundancies.
//
// Also as it goes through the list it will see which ripe buffers that were
// already copied, have also been played completely and will delete those (and
// do the WOM_DONE call back. For this purpose, the passed in dwPlayPos is
// used.
//
// Additional Note: For buffers which are copied we try to make the callbacks
// even if they have not been played provided that the buffer is not the
// last one we have received. This way we can let the flow of buffers coming
// in to continue. To figure out the last received buffer we use the
// m_dwRipeListPosition variable.
//-----------------------------------------------------------------------------
DWORD CDSoundDevice::FillSoundBuffer( LPBYTE lpWrite, DWORD dwLength, DWORD dwPlayPos )
{
    DWORD dwWritten, dwWrite;
    CAutoLock lock(&m_cRipeListLock);         // lock the list

    // dwPlayPos is the amount that has been played so far. This will be used
    // to free nodes that were already copied.

    dwWritten = 0;

    POSITION pos, posThis;
    CRipe    *pRipe;

    pos = m_ListRipe.GetHeadPosition();     // Get head entry
    while (pos && dwLength > 0)
    {
        posThis = pos ;                     // remember current pos, if we delete
        pRipe = m_ListRipe.GetNext(pos);    // Get list entry

        // if this node has been already copied, see if we can free it
        if (pRipe->bCopied)
        {
            // is the play position past the position marked for this sample ?
            // do signed math to take care of overflows. Also include the
            // buffers which are not the last one.
            if (((LONG)(dwPlayPos - pRipe->dwPosition) >= 0) ||
            ((LONG)((m_dwRipeListPosition) - pRipe->dwPosition) > 0))
            {
#ifdef DEBUG
                m_NumCallBacks ++ ;
                DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: CallBack # %u"), m_NumCallBacks));
#endif

                DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("Callback: Sample = %u, Position = %u, Time = %u"), pRipe->dwSample, pRipe->dwPosition, dwPlayPos));

                if (m_pWaveOutProc)
                    (* m_pWaveOutProc ) (OUR_HANDLE, WOM_DONE, m_dwCallBackInstance, pRipe->dwSample, 0) ;
                // yes, this ripe node is done. Do the WOM_DONE call back for it and release it. Then move on.


                m_ListRipe.Remove( posThis );       // Remove entry from ripe list
                delete pRipe;                       // Free entry
            }
            continue ;                              // skip this node.
        }
        //  See if there are bytes to stuff
        if (pRipe->dwBytesToStuff) {
            //??pRipe->dwBytesToStuff -= m_dwSilenceWrittenSinceLastWrite;
            dwWrite = min(pRipe->dwBytesToStuff, dwLength);
            DbgLog((LOG_TRACE, 2, TEXT("Stuffing %d bytes"), dwWrite));
            FillMemory( lpWrite+dwWritten,
                        dwWrite,
                        m_dwBitsPerSample == 8 ? 0x80 : 0);

            pRipe->dwBytesToStuff -= dwWrite;             //
        } else {
            dwWrite=min(pRipe->dwLength,dwLength);  // Figure out how much to copy

#ifdef DXMPERF
			if (pRipe->bFresh) {
				__int64	i64CurrClock = m_pWaveOutFilter->m_pRefClock ? m_pWaveOutFilter->m_pRefClock->GetLastDeviceClock() : 0;
				__int64	i64ByteDur = BufferDuration( m_nAvgBytesPerSec, dwWrite );
				PERFLOG_AUDIOREND( i64CurrClock, pRipe->rtStart, m_pWaveOutFilter->m_fUsingWaveHdr ? NULL : pRipe->dwSample, i64ByteDur, dwWrite );
				pRipe->bFresh = FALSE;
			}
#endif // DXMPERF

            CopyMemory( lpWrite+dwWritten,          // Move bits
                        pRipe->lpBuffer,            //
                        dwWrite );                  //
            pRipe->dwLength -= dwWrite;             //
            pRipe->lpBuffer += dwWrite;             // Advance buffer
        }
        m_dwSilenceWrittenSinceLastWrite = 0;
        if( pRipe->dwLength == 0 && pRipe->dwBytesToStuff == 0)  // If done with buffer
        {
#ifdef DEBUG
            m_NumCopied ++ ;
            DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("amsndOutWrite: Copied # %u"), m_NumCopied));
#endif

            // simply mark it as done. It will get freed on a later pass
            // when we know that it has been played.
            pRipe->bCopied = TRUE ;

            DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("Callback: Done copying. Sample = %u"), pRipe->dwSample));
            if(!m_pWaveOutFilter->m_fUsingWaveHdr)
            {
                IMediaSample *pSample = (IMediaSample *)pRipe->dwSample;
                pSample->Release();
                pRipe->dwSample  = NULL;
            }
        }

        dwWritten += dwWrite;                   // Accumulate total written
        dwLength  -= dwWrite;                   // Adjust write buffer length
    }

    return dwWritten;
}
//-----------------------------------------------------------------------------
// StreamData()
//
//  Gets current sound buffer cursors, locks the buffer, and fills in
//  as much queued data as possible. If no data was available, it will
//  fill the entire available space with silence.
//
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::StreamData( BOOL bFromRun, BOOL bUseLatencyPad )
{
    // The caller must hold the filter lock because this function uses
    // variables which are protected by the filter lock.  Also,
    // StopCallingCallback() does not work correctly if the caller does 
    // not hold the filter lock.
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    CAutoLock lock(&m_cDSBPosition);           // lock access to function

    HRESULT hr;
    DWORD   dwPlayPos;
    DWORD   dwLockSize;

    LPBYTE  lpWrite1, lpWrite2;
    DWORD   dwLength1, dwLength1Done, dwLength2, dwLength2Done;

#ifdef DEBUG
    m_cbStreamDataPass++ ;
    DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("StreamData Pass # %u"),
            m_cbStreamDataPass));
#endif


    if( !m_lpDSB )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("  no m_lpDSB or buffers to stream")));
        return E_FAIL;
    }

//  This is broken because the logic says we only start filling the buffer when
//  it's got down to being 1 / FRACTIONAL_BUFFER_SIZE full.
//  The 'savings' were most likely because we actually looped the buffer
//  sometimes effectively slowing the clock
#if 1
    // check to see if the dsound buffer is empty enough to warrant the high overhead involved with filling it.
    // the idea here is that we want to minimize the number of times we call fillsoundbuffer(), but when we do call
    // it, we want to maximize the amount of copying done each time.  this holds for zerolockedsegment(), as well.
    // profiling has verified that this results in significant saving. however, we must be extremely paranoid about
    // when we apply it
    if(
        bFromRun
    )
    {
        // dwLength1 = dsound play cursor, we ignore the write cursor here
        // dwLength1 = dsound write cursor, we ignore the play cursor here
        hr = m_lpDSB->GetCurrentPosition(&dwLength1, &dwLength2);

#ifdef DETERMINE_DSOUND_LATENCY
#ifdef DEBUG
        LONG lDelta = (LONG) ( dwLength2 - dwLength1 );
        if( dwLength2 < dwLength1 )
            lDelta +=  m_dwBufferSize;

        REFERENCE_TIME rtDelta = BufferDuration( m_nAvgBytesPerSec, lDelta );

        // just log this to see the latency between p/w cursors
        DbgLog((LOG_TRACE, 10, TEXT("dsr:GetCurrentPosition p/w delta = %dms (Play = %ld, Write = %ld)"),
                (LONG) (rtDelta/10000), dwLength1, dwLength2 ) ) ;
#endif
#endif
        //if (m_fEmulationMode)
        if (bUseLatencyPad)
        {
            // instead if our buffers are small...
            // dwLength1 = dsound write cursor, we ignore the play cursor here
            //
            // Note: This should also be the case always, but we're taking
            // the low risk (and more tested) path and only doing this
            // in the exceptional case.
            dwLength1 = dwLength2;
        }
        if(FAILED(hr))
        {
            return hr;
        }
        // dwLength2 is the difference between our last valid write position and the dsound play cursor
        dwLength2 = m_tupNextWrite.m_offset >= dwLength1 ?
                    m_tupNextWrite.m_offset - dwLength1 :
                    m_tupNextWrite.m_offset + m_dwBufferSize - dwLength1;

            // is the delta between the cursors to large to warrant copying ?
        if(dwLength2 > (m_dwBufferSize / 4 + (bUseLatencyPad ? m_dwEmulationLatencyPad : 0)))
        {
            DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("dsr:StreamData - Skipping buffer write (delta = %ld)"), dwLength2)) ;
            return S_OK;  // no, so do not work this time around
        }
    }
#endif  // #if 0

    // get the current playposition. Thsi will also update the m_tupPlay,
    // m_tupWrite and m_tupNextWrite tuples.
    //
    // Caution: Make sure that No one else calls GetDSBPosition or GetPlayPosition
    // while we are in StreamData because these functions update the tuples
    // as does StreamData. The functions are protected by the same critical
    // section that StreamData uses so the above two functions will be
    // protected from being called from another thread. Thus in StreamData
    // we will call GetPlayPosition at the begining and then make sure
    // that we do not call these functions anymore while we are adjusting
    // the tuples.

    // get the current playposition so that we can pass it to FillSoundBuffer.
    // Also this function will internally call GetDBPosition which will update
    // our tuples.

    dwPlayPos = (DWORD)GetPlayPosition () ;    // get position in DSB


    // figure out the amount of space in the buffer that we can lock. This
    // really corresponds to the logical interval [dwWritePos to dwPlay] in
    // the circular buffer.


    // make certain that pointers are consistent. The next write pointer
    // should be ahead of the play cursor, but should not lap it.
    ASSERT (m_tupNextWrite >= m_tupPlay) ;
    ASSERT ((m_tupNextWrite - m_tupPlay) <= m_dwBufferSize) ;


    // figure out the amount of space available to write. It would be
    // the complete buffer if we have not written anything yet.
    const dwFullness =  m_tupNextWrite - m_tupPlay;
    dwLockSize = m_dwBufferSize - dwFullness ;
    m_lPercentFullness = (LONG)MulDiv(dwFullness, 100, m_dwBufferSize );
#ifdef ENABLE_10X_FIX

    if(m_bDSBPlayStarted)
    {
#ifndef FILTER_DLL
        //  Log buffer fullness
        g_Stats.NewValue(m_lStatFullness, (LONGLONG)m_lPercentFullness);
#endif
#ifdef ENABLE_10X_TEST_RESTART

        // we're testing to see if EC_NEED_RESTART affects audio/video synchronization, this is not the typical case
#define CURSOR_STALL_THRESHOLD  254
        m_ucConsecutiveStalls = m_ucConsecutiveStalls < 255 ? ++m_ucConsecutiveStalls : 0;
#else

        // we're counting the number of zero locks which occur consecutively, a sign that DSOUND has stalled and is no longer consuming samples
#define CURSOR_STALL_THRESHOLD  100
        m_ucConsecutiveStalls = dwLockSize == 0 ? ++m_ucConsecutiveStalls : 0;
#endif  // ENABLE_10X_TEST_RESTART

        if(m_ucConsecutiveStalls)
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("Consecutive Stalls = %u"), m_ucConsecutiveStalls));

            if(m_ucConsecutiveStalls > CURSOR_STALL_THRESHOLD)
            {
                DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("StreamData: EC_NEED_RESTART")));
                m_pWaveOutFilter->NotifyEvent(EC_NEED_RESTART, 0, 0);   // signal restart

                m_fRestartOnPause = TRUE;  // reinitialize dsound on the next pause

                return E_FAIL;
            }
        }
    }
#endif  // ENABLE_10X_FIX

    if( dwLockSize == 0 )
        return DS_OK;                       // Return if none available


    ASSERT (dwLockSize <= m_dwBufferSize) ;


    // lock down all the unused space in the buffer.

    DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("calling lpDSB->Lock: m_offset = %u:%u, dwLockSize = %u "),
           m_tupNextWrite.m_itr, m_tupNextWrite.m_offset,
           dwLockSize));

    hr = m_lpDSB->Lock( m_tupNextWrite.m_offset, dwLockSize, (PVOID *) &lpWrite1, &dwLength1, (PVOID *) &lpWrite2, &dwLength2, 0 );
    if (hr != DS_OK)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSB->Lock! hr = %u"), hr & 0x0ffff));
        return hr ;
    }

    // Fill in as much of actual data as we can, upto the sizes being
    // passed in. dwLength1Done and dwLength2Done return the amount written.

    dwLength1Done = FillSoundBuffer( lpWrite1, dwLength1, dwPlayPos ); // Fill first part
    ASSERT (dwLength1Done <= dwLength1) ;

    // Try to write in wrapped part only if 1st part was fully written
    if (dwLength1Done == dwLength1)
    {
        dwLength2Done = FillSoundBuffer( lpWrite2, dwLength2, dwPlayPos ); // Fill wrapped part
        ASSERT (dwLength2Done <= dwLength2) ;
    }
    else
        dwLength2Done = 0 ;


    DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("data at = %u:%u, length = %u, lock = %u"),
            m_tupNextWrite.m_itr, m_tupNextWrite.m_offset,
            (dwLength1Done+dwLength2Done), dwLockSize));

    m_tupNextWrite += (dwLength1Done + dwLength2Done) ;

    ASSERT ((m_tupNextWrite - m_tupPlay) <= m_dwBufferSize) ;

#ifdef DEBUG
    m_dwTotalWritten += (dwLength1Done + dwLength2Done) ;
    if ((dwLength1Done) > 0)
    {
        DbgLog((LOG_TRACE, TRACE_STREAM_DATA, TEXT("Total Data written = %u"),
                m_dwTotalWritten));
    }
#endif

    // fill silence if no data written. We do not write silence if even a bit
    // of data was written. Maybe we can add some heuristics here.
    if (dwLength1Done == 0)
    {
        ZeroLockedSegment (lpWrite1, dwLength1) ;
        ZeroLockedSegment (lpWrite2, dwLength2) ;
        dwLength1Done = dwLength1 ;
        dwLength2Done = dwLength2 ;
    }


    // unlock the buffer.
    m_lpDSB->Unlock( lpWrite1, dwLength1Done, lpWrite2, dwLength2Done );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("error in lpDSB->Unlock! hr = %u"), hr & 0x0ffff));
        hr = DS_OK;  // note the problem, continue without error???
    }


    return hr;
}


//-----------------------------------------------------------------------------
//
// ZeroLockedSegment ()
//
// Fills silence in a locked segment of the dsound buffer.
//-----------------------------------------------------------------------------
void CDSoundDevice::ZeroLockedSegment ( LPBYTE lpWrite, DWORD dwLength )
{
    if (dwLength != 0 && lpWrite != NULL)
    {
        if( m_dwBitsPerSample == 8 )
            FillMemory( lpWrite, dwLength, 0x080 );
        else
            ZeroMemory( lpWrite, dwLength );
    }
}
//-----------------------------------------------------------------------------
//
// StreamingThread()
//
//   Critical buffer scheduling thread. It wakes up periodically
//     to stream more data to the directsoundbuffer. It sleeps on an
//     event with a timeout so that others can wake it.
//
//-----------------------------------------------------------------------------

void __stdcall CDSoundDevice::StreamingThreadCallback( DWORD_PTR lpvThreadParm )
{
    //DbgLog((LOG_TRACE, TRACE_CALL_STACK, TEXT("CDSoundDevice::StreamingThreadSetup")));

    CDSoundDevice    *pDevice;
    pDevice = (CDSoundDevice *)lpvThreadParm;

#ifdef DEBUG
    DWORD dwt = timeGetTime () ;
    if (pDevice->m_lastThWakeupTime != 0)
    {
        DWORD dwtdiff = dwt - pDevice->m_lastThWakeupTime ;
        DbgLog((LOG_TRACE, TRACE_THREAD_LATENCY, TEXT("Thread wakes up after %u ms"), dwtdiff));
        if (dwtdiff > THREAD_WAKEUP_INT_MS * 5)
        {
            DbgLog((LOG_TRACE,TRACE_THREAD_LATENCY, TEXT("Lookey! Thread waking up late. actual = %u, need = %u"),
              dwtdiff, THREAD_WAKEUP_INT_MS));
        }
    }
    pDevice->m_lastThWakeupTime = dwt ;
#endif

    pDevice->StreamData ( FALSE );
}

HRESULT CDSoundDevice::StartCallingCallback()
{
    // The caller must hold the filter lock because it protects
    // m_callbackAdvise and m_lastThWakeupTime.
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    DbgLog((LOG_TRACE, TRACE_THREAD_STATUS, TEXT("Setting the ADVISE for the thread")));

#ifdef DEBUG
    m_lastThWakeupTime = 0 ;
#endif

    if (IsCallingCallback()) {
        return S_OK;
    }

    CCallbackThread* pCallbackThreadObject = m_pWaveOutFilter->GetCallbackThreadObject();

    HRESULT hr = pCallbackThreadObject->AdvisePeriodicWithEvent(
                                                        CDSoundDevice::StreamingThreadCallback,  // callback function
                                                        (DWORD_PTR) this,   // user token passed to callback
                                                        THREAD_WAKEUP_INT_MS * (UNITS / MILLISECONDS),
                                                        NULL,
                                                        &m_callbackAdvise);
    if (hr != NOERROR)
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("ADVISE FAILED! hr=%x"), hr));
        return hr;
    }

    // 0 is not a valid advise token.
    ASSERT(0 != m_callbackAdvise);

    return S_OK;
}

void CDSoundDevice::StopCallingCallback()
{
    // The caller must hold the filter lock because this function uses
    // m_lastThWakeupTime and m_callbackAdvise.  The caller must
    // also hold the filter lock because the filter lock synchronizes 
    // access to the callback thread.  The callback thread will not call 
    // CDSoundDevice::StreamingThreadCallback() while another thread holds
    // the filter lock.  The callback thread will not call 
    // StreamingThreadCallback() because the callback object 
    // (CWaveOutFilter::m_callback) holds the filter lock when it decides 
    // whether it should call the callback function and when it actually 
    // calls the callback function.  We can safely cancel the callback advise
    // because the callback object will not call StreamingThreadCallback() 
    // while we are holding the filter lock.  We do not want to cancel the 
    // callback advise while StreamingThreadCallback() is being called 
    // because StreamingThreadCallback() might use the CDSoundDevice object 
    // after we delete it.  See bug 298993 in the Windows Bugs database for 
    // more information.  Bug 298993's title is "STRESS: DSHOW: The Direct 
    // Sound Renderer crashes if the CDSoundDevice object is destroyed before 
    // the callback thread terminates".
    ASSERT(CritCheckIn(m_pWaveOutFilter));

    // Cancel the advise only if we have an advise to cancel.
    if  (IsCallingCallback()) {
        CCallbackThread* pCallbackThreadObject = m_pWaveOutFilter->GetCallbackThreadObject();

        HRESULT hr = pCallbackThreadObject->Cancel(m_callbackAdvise);

        // Cancel() always succeeds if m_callbackAdvise is a valid advise
        // token.
        ASSERT(SUCCEEDED(hr));

        m_callbackAdvise = 0;

        #ifdef DEBUG
        m_lastThWakeupTime = 0;
        #endif
    }
}

//-----------------------------------------------------------------------------
// BOOL RestoreBufferIfLost(BOOL bRestore)
//
// Checks the status code for dsound to see if it's DSBTATUS_BUFFERLOST.
// If so and if bRestore is TRUE, it attempts to Restore the buffer.
// Returns TRUE if buffer is valid at exit, else FALSE.
//
// keeps retrying for upto 1 second because we see long delays on
// WinME when resuming from standby/hibernation
//-----------------------------------------------------------------------------
BOOL CDSoundDevice::RestoreBufferIfLost(BOOL bRestore)
{
    if (m_lpDSB)
    {
        DWORD dwStatus = 0;
        HRESULT hr = m_lpDSB->GetStatus (&dwStatus);
        if (SUCCEEDED(hr))
        {
            if ((DSBSTATUS_BUFFERLOST & dwStatus) == 0)
            {
                return TRUE;
            }

#ifdef DEBUG
            if (!m_bBufferLost)
            {
                DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS,TEXT("DSoundBuffer was lost...")));
            }
            m_bBufferLost = TRUE;
#endif

            if (bRestore)
            {
                hr = m_lpDSB->Restore();
                for(int i = 0; hr == DSERR_BUFFERLOST && i < 30; i++)
                {
                    Sleep(30);
                    hr = m_lpDSB->Restore();
                }
                DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS,
                        TEXT("DSound buffer restore %08x, %d iterations"), hr, i));
                if (DS_OK == hr)
                {
#ifdef DEBUG
                    m_bBufferLost = FALSE;
#endif
                    return TRUE;
                }
            }
        }
        else
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR,TEXT("lpDSB->GetStatus returned 0x%08lx"),hr));
        }
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
//
// FlushSamples ()
//
// Flushes all the samples from the Ripe list. Called during BeginFlush
// or from Inactive
//
//-----------------------------------------------------------------------------
void CDSoundDevice::FlushSamples ()
{
    DbgLog((LOG_TRACE, TRACE_SAMPLE_INFO, TEXT("  Flushing pending samples")));
    // flush the queued up samples
    {
        CRipe    *pRipe;

        CAutoLock lock(&m_cRipeListLock);        // lock list

        while(1)
        {
            pRipe = m_ListRipe.RemoveHead();       // Get head entry
            if( pRipe == NULL ) break;              // Exit if no more

#ifdef DEBUG
            m_NumCallBacks ++ ;
            DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("waveOutWrite: Flush CallBack # %u"), m_NumCallBacks));
#endif
            // make the WOM_DONE call back here
                if (m_pWaveOutProc)
            (* m_pWaveOutProc) (OUR_HANDLE, WOM_DONE, m_dwCallBackInstance, pRipe->dwSample, 0) ;
            delete pRipe;                          // Free entry
        }
    }

    // flush the queued up audio breaks
    {
        CAudBreak    *pAB;

        CAutoLock lock(&m_cDSBPosition);        // lock list

        while(1)
        {
            pAB = m_ListAudBreak.RemoveHead();       // Get head entry
            if( pAB == NULL ) break;                 // Exit if no more

#ifdef DEBUG
            m_NumBreaksPlayed ++ ;
            DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("Flushing Audio Break Node %u"), m_NumBreaksPlayed));
#endif
            delete pAB;                          // Free entry
        }
    }

    {
        // Initialize all variables
        CAutoLock lock(&m_cDSBPosition);           // lock access to function

#ifdef DEBUG
        DbgLog((LOG_TRACE,TRACE_SAMPLE_INFO, TEXT("Clearing audio break stats")));
        m_NumBreaksPlayed =  0 ;
        m_NumSamples = 0 ;
        m_NumCallBacks = 0 ;
        m_cbStreamDataPass = 0 ;    // number of times thru StreamData
#endif

        m_NumAudBreaks = 0;


        // initilize variables
        m_tupPlay.Init (0,0,m_dwBufferSize) ;   // set to start
        m_tupWrite.Init (0,0,m_dwBufferSize);   // set to start
        m_tupNextWrite.Init (0,0,m_dwBufferSize) ; // set to start
        m_dwRipeListPosition = 0 ;
        m_llSilencePlayed = 0 ;

        //  Reset sample stuffing info
        m_dwSilenceWrittenSinceLastWrite = 0;

#ifdef ENABLE_10X_FIX
        Reset10x();
#endif

#ifdef DEBUG
        m_dwTotalWritten = 0 ;
#endif
    }
}
//-----------------------------------------------------------------------------
// GetPlayPosition.
//
// Returns the current position based on the amount of data that has been played
// so far.
//-----------------------------------------------------------------------------
LONGLONG CDSoundDevice::GetPlayPosition (BOOL bUseUnadjustedPos)
{
    LONGLONG llTime = 0 ;

    HRESULT hr = GetDSBPosition () ;   // get position in DSb
    if( hr == DS_OK )
    {
        // Refresh the audio break list to account for any silence that has
        // been played.

        RefreshAudioBreaks (m_tupPlay) ;

        if( bUseUnadjustedPos )
        {
            llTime = m_tupPlay.LinearLength() + m_llAdjBytesPrevPlayed;
        }
        else
        {
            // Time is based on current position, number of iterations through the
            // buffer and the amount of silence played.

            llTime = (m_tupPlay.LinearLength() - m_llSilencePlayed) + m_llAdjBytesPrevPlayed;

            //  NOTE llTime can be negative in the case that we stuffed a lot
            //  of silence.
        }

    }
    else if (DSERR_BUFFERLOST == hr)
    {
#ifdef DEBUG
        if (!m_bBufferLost)
        {
            DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS, TEXT("waveOutGetPlayPosition: DSound buffer lost")));
        }
        m_bBufferLost = TRUE;
#endif

        // if we've lost the dsound buffer, attempt to restore it
        hr = m_lpDSB->Restore();
#ifdef DEBUG
        if (DS_OK == hr)
        {
            DbgLog((LOG_TRACE, TRACE_BUFFER_LOSS, TEXT("waveOutGetPosition: DSound buffer restored")));
            m_bBufferLost = FALSE;
        }
#endif
    }
    else
    {
        // abort if we hit any other error
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("waveOutGetPosition: error from GetDSBPosition! hr = %u"), hr & 0x0ffff));
        m_pWaveOutFilter->NotifyEvent(EC_ERRORABORT, hr, 0);
    }
    DbgLog((LOG_TRACE, TRACE_TIME_REPORTS, TEXT("Reported Time = %u"), (LONG)llTime)) ;
    return llTime ;
}
//-----------------------------------------------------------------------------
// AddAudioBreak
//
// Adds another one or two nodes to the audio break list.
//-----------------------------------------------------------------------------
void CDSoundDevice::AddAudioBreak (Tuple& t1, Tuple& t2)
{
    CAutoLock lock(&m_cDSBPosition);     // lock the list

    // Test for null node & ignore.
    if (t1 == t2)
        return ;

    ASSERT (t1 < t2) ;

    CAudBreak    *pAB;
    pAB = new CAudBreak(NAME("CDSoundDevice Audio Break Node"));
    if( !pAB )
    {
        // too bad. There is not much we can do, this audio break will not
        // get registered.
        DbgLog((LOG_ERROR,MINOR_ERROR, TEXT("AddAudioBreak: new CAudBreak failed!")));
        return ;
    }

    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Adding audio break node: %u:%u to %u:%u"),
       t1.m_itr, t1.m_offset, t2.m_itr, t2.m_offset));

    pAB->t1 = t1 ;
    pAB->t2 = t2 ;

#ifdef DXMPERF
	PERFLOG_AUDIOBREAK( t1.LinearLength(), t2.LinearLength(), MulDiv( (DWORD) (t2 - t1), 1000, m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec ) );
#endif // DXMPERF

    m_NumAudBreaks ++ ;
#ifndef FILTER_DLL
    g_Stats.NewValue(m_lStatBreaks, (LONGLONG)m_NumAudBreaks);
#endif
    m_ListAudBreak.AddTail( pAB );           // Add to Audio Break

#ifdef PERF
    MSR_INTEGER(m_idAudioBreak,
                MulDiv((DWORD)(t2 - t1), 1000,
                       m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec));
#endif


#ifdef DEBUG

    // dump the list of nodes.
    POSITION pos ;
    int i = 1 ;

    Tuple t ;
    t.Init (0,0,m_dwBufferSize) ;


    pos = m_ListAudBreak.GetHeadPosition();      // Get head entry
    while (pos)
    {
        pAB = m_ListAudBreak.GetNext(pos);      // Get list entry

        DbgLog((LOG_TRACE,TRACE_BREAK_DATA, TEXT("Break #%u %u:%u to %u:%u"),
           i, pAB->t1.m_itr, pAB->t1.m_offset,
           pAB->t2.m_itr, pAB->t2.m_offset));
        i++ ;

        // make sure nodes don't overlap.
        ASSERT (pAB->t1 >=  t) ;
        t = pAB->t2 ;
    }

#endif
    return ;

}
//-----------------------------------------------------------------------------
// RefreshAudioBreaks
//
// This function, given the current play position, walks through the audio break
// list and figure out which breaks we have already played and if we are playing
// one currently. It updates the m_llSilencePlayed field based on this. It
// deletes nodes that have already been played. If it is currently playing
// a break, it will account for the amount played and adjust the node to
// account for the unplayed portion.
//-----------------------------------------------------------------------------
void CDSoundDevice::RefreshAudioBreaks (Tuple& t)
{
    CAutoLock lock(&m_cDSBPosition);         // lock the list

    POSITION pos, posThis;
    CAudBreak    *pAB;

    pos = m_ListAudBreak.GetHeadPosition();      // Get head entry
    while (pos)
    {
        posThis = pos ;                         // remember current pos, if we delete
        pAB = m_ListAudBreak.GetNext(pos);      // Get list entry

        // see if we are past this break.
        if (pAB->t2 <= t)
        {
            // we must have played this node completely. Accumulate its
            // length and get rid of it.
            ASSERT (pAB->t2 > pAB->t1) ;
            m_llSilencePlayed += (pAB->t2 - pAB->t1) ;
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Played = %u"), m_llSilencePlayed));

#ifdef DEBUG
            m_NumBreaksPlayed ++ ;
#endif
            m_ListAudBreak.Remove( posThis );       // Remove entry from AudBreak list
            delete pAB;                             // Free entry
            continue ;
        }

        // see if we are actually playing silence
        if ((pAB->t1 < t) && (pAB->t2 > t))
        {
            // we are part way through this node. Accumulate the portion
            // that we have played and alter the node to account for the
            // unplayed portion.


            m_llSilencePlayed += (t - pAB->t1) ;
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Played = %u"), m_llSilencePlayed));
            DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Breaking up unplayed audio node")));
            pAB->t1 = t ;

            DbgLog((LOG_TRACE,TRACE_BREAK_DATA, TEXT("Changing  audio break node: %u:%u to %u:%u"),
            pAB->t1.m_itr, pAB->t1.m_offset,
            pAB->t2.m_itr, pAB->t2.m_offset));

        }

        // no need to go through further nodes.
        break ;
    }

#ifdef DEBUG
    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Breaks Logged = %u, Breaks Played = = %u"),
       m_NumAudBreaks, m_NumBreaksPlayed));
#endif

    return ;
}
//-----------------------------------------------------------------------------
// GetDSBPosition
//
// Gets current position in the DSB and updates the iteration that we are on
// in the play buffer. We maintain separate iteration indices for the play
// and write cursors.
//-----------------------------------------------------------------------------
HRESULT CDSoundDevice::GetDSBPosition ()
{
    CAutoLock lock(&m_cDSBPosition);           // lock access to function
    DWORD dwPlay, dwWrite ;

    AUDRENDPERF(MSR_INTEGER(m_idAudioBreak,
                  MulDiv((DWORD)(t2 - t1), 1000,
                         m_pWaveOutFilter->WaveFormat()->nAvgBytesPerSec)));

    AUDRENDPERF(MSR_START(m_idGetCurrentPosition));
    HRESULT hr = m_lpDSB->GetCurrentPosition( &dwPlay, &dwWrite );
    AUDRENDPERF(MSR_STOP(m_idGetCurrentPosition));
    if (FAILED (hr))
    {
        m_hrLastDSoundError = hr;
        return hr ;
    }
    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("GetDSB: GetCurrentPos.  p  = %u, n = %u"), dwPlay, dwWrite));

#ifdef ENABLE_10X_FIX

    if(m_bDSBPlayStarted)
    {
        // check to see if DSOUND has reported bogus play/write positions.  if so, DSOUND is now in an unstable (likely frozen) state.
        if((dwWrite > m_dwBufferSize) || (dwPlay > m_dwBufferSize))
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("GetDSB:  Out of Bounds Write = %u, Play = %u, BufferSize = %u"), dwWrite, dwPlay, m_dwBufferSize));

            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("GetDSB: EC_NEED_RESTART")));
            m_pWaveOutFilter->NotifyEvent(EC_NEED_RESTART, 0, 0);   // signal a restart

            m_fRestartOnPause = TRUE;  // restart dsound on the next pause

            return E_FAIL;
        }
    }

#endif  // if 10x

    // Make sure that the play tuple is updated 1st as the write tuple
    // will be uodated based on the play tuple.
    m_tupPlay.MakeCurrent (dwPlay) ;
    m_tupWrite.MakeCurrent (m_tupPlay, dwWrite) ;

    ASSERT (m_tupWrite >= m_tupPlay) ;

    // check for ovverun and add silence node if we get one.
    if (m_tupWrite > m_tupNextWrite)
    {
        DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("Silence Node.  p = %u:%u, w = %u:%u,  n = %u:%u "),
                m_tupPlay.m_itr, m_tupPlay.m_offset,
                m_tupWrite.m_itr, m_tupWrite.m_offset,
                m_tupNextWrite.m_itr, m_tupNextWrite.m_offset));

        AddAudioBreak (m_tupNextWrite, m_tupWrite) ;

        // go past the audio break (that will happen) ;
        m_dwSilenceWrittenSinceLastWrite += m_tupWrite - m_tupNextWrite;
        m_tupNextWrite = m_tupWrite ;
    }

    DbgLog((LOG_TRACE,TRACE_STREAM_DATA, TEXT("GetDSB: p = %u:%u, w = %u:%u, n = %u:%u"),
            m_tupPlay.m_itr, m_tupPlay.m_offset,
            m_tupWrite.m_itr, m_tupWrite.m_offset,
            m_tupNextWrite.m_itr, m_tupNextWrite.m_offset));

    return S_OK ;
}
//-----------------------------------------------------------------------------
// DSCleanUp.
//
// Cleans up all the DSound objects. Called from amsndOutClose or when wavOutOpen
// fails.
//-----------------------------------------------------------------------------
void CDSoundDevice::CleanUp (BOOL bBuffersOnly)
{
    HRESULT hr ;

    // clean up the secondary buffer.

    if( m_lpDSB )
    {
        DbgLog((LOG_TRACE, TRACE_CLEANUP, TEXT("  cleaning up lpDSB")));
        if (m_lp3dB)
	    m_lp3dB->Release();
	m_lp3dB = NULL;
        hr = m_lpDSB->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MINOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release failed: %u"), hr & 0x0ffff));
        }
        m_lpDSB = NULL;
    }

    // stop and clean up the primary buffer
    if( m_lpDSBPrimary )
    {
        DbgLog((LOG_TRACE, TRACE_CLEANUP, TEXT("  cleaning up lpDSBPrimary")));
        hr = m_lpDSBPrimary->Stop();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Stop of lpDSBPrimary failed: %u"), hr & 0x0ffff));
        }

        if (m_lp3d)
	    m_lp3d->Release();
	m_lp3d = NULL;
        hr = m_lpDSBPrimary->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release of lpDSBPrimary failed: %u"), hr & 0x0ffff));
        }

        m_lpDSBPrimary = NULL;
    }

    // clean up the DSound object itself.
    if (m_lpDS && !bBuffersOnly)
    {
        hr = m_lpDS->Release();
        if( hr != DS_OK )
        {
            DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("CDSoundDevice::Cleanup: Release of lpDS failed: %u"), hr & 0x0ffff));
        }
        m_lpDS = NULL;
    }

    // Set state back
    m_WaveState = WAVE_CLOSED;
}

//
// CDSoundDevice::SetBufferVolume()
//
// Wraps the initial volume and pan setting done after we create a buffer
//
HRESULT CDSoundDevice::SetBufferVolume( LPDIRECTSOUNDBUFFER lpDSB, WAVEFORMATEX * pwfx )
{
    ASSERT( lpDSB );
    if( !IsNativelySupported( pwfx ) )
    {        
        // don't set a start volume for non-native formats
        return S_OK;
    }            
        
    // set to current volume and balance settings
    HRESULT hr = lpDSB->SetVolume(m_lVolume);
    if( S_OK == NOERROR )
    {    
        hr = lpDSB->SetPan(m_lBalance);
    }
    return hr;
}

// 
// SetSRCQuality 
//
// When slaving we need to assure that frequency changes will be subtle and currently we get
// finer granularity when kmixer's using the lower quality SRC, so we make a SNR sacrifice.
//
// kernel mixer SRC quality levels are: 
//      KSAUDIO_QUALITY_WORST
//      KSAUDIO_QUALITY_PC
//      KSAUDIO_QUALITY_BASIC
//      KSAUDIO_QUALITY_ADVANCED
//
HRESULT CDSoundDevice::SetSRCQuality( DWORD dwQuality )
{
    ASSERT( m_lpDSB ); // should only be called when paused or running
        
    // avoid ks/dsound IKsPropertySet mismatch
    IDSPropertySet *pKsProperty;
    HRESULT hr = m_lpDSB->QueryInterface( IID_IKsPropertySet, (void **) &pKsProperty );
    if( SUCCEEDED( hr ) )
    {
        hr = pKsProperty->Set( KSPROPSETID_Audio
                             , KSPROPERTY_AUDIO_QUALITY
                             , (PVOID) &dwQuality
                             , sizeof( dwQuality )
                             , (PVOID) &dwQuality
                             , sizeof( dwQuality ) );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2, TEXT( "ERROR SetSRCQuality: IKsPropertySet->Set() KSPROPERTY_AUDIO_QUALITY returned 0x%08X" ), hr ));
        }            
        pKsProperty->Release();
    }        
    return hr;
}    

// 
// GetSRCQuality 
//
// Get current SRC quality
//
HRESULT CDSoundDevice::GetSRCQuality( DWORD *pdwQuality )
{
    ASSERT( pdwQuality );
    ASSERT( m_lpDSB ); // should only be called when paused or running
        
    // avoid ks/dsound IKsPropertySet mismatch
    IDSPropertySet *pKsProperty;
    HRESULT hr = m_lpDSB->QueryInterface( IID_IKsPropertySet, (void **) &pKsProperty );
    if( SUCCEEDED( hr ) )
    {
        ULONG   cbSize = sizeof( DWORD );
    
        hr = pKsProperty->Get( KSPROPSETID_Audio
                             , KSPROPERTY_AUDIO_QUALITY
                             , (PVOID) pdwQuality
                             , sizeof( DWORD )
                             , (PVOID) pdwQuality
                             , sizeof( DWORD ) 
                             , &cbSize );
        if( FAILED( hr ) )
        {
            DbgLog(( LOG_TRACE, 2, TEXT( "ERROR! GetSRCQuality: IKsPropertySet->Get() KSPROPERTY_AUDIO_QUALITY returned 0x%08X" ), hr ));
        }
        else
        {
            DbgLog(( LOG_TRACE, 3, TEXT( "** SRC Quality setting is %hs **" ), 
                     *pdwQuality == KSAUDIO_QUALITY_WORST ? "KSAUDIO_QUALITY_WORST" :
                     ( *pdwQuality == KSAUDIO_QUALITY_PC    ? "KSAUDIO_QUALITY_PC" :
                      ( *pdwQuality == KSAUDIO_QUALITY_BASIC  ? "KSAUDIO_QUALITY_BASIC" :
                       ( *pdwQuality == KSAUDIO_QUALITY_ADVANCED ? "KSAUDIO_QUALITY_ADVANCED" :
                          "Unknown KMixer Quality!" ) ) ) ));
        }        
        pKsProperty->Release();
    }        
    return hr;
}    

// If you want to do 3D sound, you should use the IDirectSound3DListener
// and IDirectSound3DBuffer interfaces.  IAMDirectSound never worked, so I
// am removing support for it. - DannyMi 5/6/98

#if 0
// Give the IDirectSound interface to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetDirectSoundInterface(LPDIRECTSOUND *lplpds)

{
    // If we don't have the object around yet, make it
    if (m_lpDS == NULL)
    CreateDSound();

    if (lplpds && m_lpDS) {
        HRESULT hr = m_lpDS->AddRef();
        *lplpds = m_lpDS;
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the IDirectSound object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


// Give the IDirectSoundBuffer interface of the primary to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{

    // If we don't have the objects around yet, make them
    if (m_lpDSBPrimary == NULL) {
        CreateDSound();
        CreateDSoundBuffers();
    }

    if (lplpdsb && m_lpDSBPrimary) {
        m_lpDSBPrimary->AddRef();
        *lplpdsb = m_lpDSBPrimary;
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the primary IDirectSoundBuffer object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}


// Give the IDirectSoundBuffer interface of the secondary to anyone who wants it
//
HRESULT CDSoundDevice::amsndGetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    // If we don't have the objects around yet, make them
    if (m_lpDSB == NULL) {
        CreateDSound();
        CreateDSoundBuffers();
    }

    if (lplpdsb && m_lpDSB) {
        WAVEFORMATEX wfx;
        DWORD dw;
        m_lpDSB->AddRef();
        *lplpdsb = m_lpDSB;
        m_lpDSBPrimary->GetFormat(&wfx, sizeof(wfx), &dw);
        // This will slow performance down!  The app will have to do this
#if 0
        if (wfx.nChannels == 1) {
            // Right now we're using mono sound, and if the app wants
            // to be able to use 3D effects, we need to have a stereo primary.
            // We either trust the app to do it itself, or do it for them.
            wfx.nChannels = 2;
            wfx.nBlockAlign *= 2;
            wfx.nAvgBytesPerSec *= 2;
            m_lpDSBPrimary->SetFormat(&wfx);
                DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Changing to stereo PRIMARY for 3D effects")));
        }
#endif
        DbgLog((LOG_TRACE,MAJOR_ERROR,TEXT("Giving/AddRef'ing the secondary IDirectSoundBuffer object")));
        return NOERROR;
    } else {
        return E_FAIL;
    }
}
#endif

// helper function, set the focus window
HRESULT CDSoundDevice::SetFocusWindow(HWND hwnd)
{
    HRESULT hr = S_OK;

    // save the passed in hwnd, we will use it when the device is
    // opened.

    m_hFocusWindow = hwnd ;
    DbgLog((LOG_TRACE,TRACE_FOCUS,TEXT("Focus set to %x"), hwnd));

    // now change the focus window
    HWND hFocusWnd ;
    if (m_hFocusWindow) {
        hFocusWnd = m_hFocusWindow ;
        m_fAppSetFocusWindow = TRUE;
    } else {
        hFocusWnd = GetForegroundWindow () ;
        if (!hFocusWnd)
            hFocusWnd = GetDesktopWindow () ;
        m_fAppSetFocusWindow = FALSE;
    }

    // we don't have a dsound object yet, so we'll set the cooperative level
    // later, as soon as we make one
    if (!m_lpDS)
        return S_OK;

    // Set the cooperative level
    DbgLog((LOG_TRACE, TRACE_FOCUS, TEXT(" hWnd for SetCooperativeLevel = %x"), hFocusWnd));
    hr = m_lpDS->SetCooperativeLevel( hFocusWnd, DSSCL_PRIORITY );
    if( hr != DS_OK )
    {
        DbgLog((LOG_ERROR, MAJOR_ERROR, TEXT("*** SetCooperativeLevel failed! %u"), hr & 0x0ffff));
    }

    return hr;
}

// helper function, turn GLOBAL_FOCUS on or off
HRESULT CDSoundDevice::SetMixing(BOOL bMixingOnOrOff)
{
    HRESULT hr = S_OK;

    BOOL fMixPolicyChanged = ( (BOOL)m_fMixing != bMixingOnOrOff );
    m_fMixing = !!bMixingOnOrOff;

    DbgLog((LOG_TRACE,TRACE_FOCUS,TEXT("Mixing set to %x"), bMixingOnOrOff));

    // we'll do this work later
    if(!m_lpDSB || (m_WaveState == WAVE_PLAYING))
        return hr;

    // set the focus now only if the mixing policy changed, and we have a valid secondary (otherwise, one will be created later)
    if(fMixPolicyChanged)
    {
        //  Save wave state because Cleanup sets it to WAVE_CLOSED
        const WaveState WaveStateSave = m_WaveState;
        // release all our buffers (technically, we should need to only release the secondary, but this is insurance against DSOUND flakiness)
        CleanUp(TRUE);  // TRUE => release only our primary and secondary, not the dsound object

        // now recreate our buffers with the GLOBAL_FOCUS on or off
        hr = CreateDSoundBuffers();

    	// This function assumes that a non-zero value returned by 
        // CreateDSoundBuffers() is an error because the function
        // returns MMRESULTs and HRESULTs.  All failure MMRESULTs 
        // are greater than 0 and all failure HRESULTs are less than
        // 0.
        if (S_OK == hr) {
            m_WaveState = WaveStateSave;
        } else {
            hr = E_FAIL;
        }	
    }

    return hr;
}


// Set the focus window and mixing policy for the dsound renderer.
HRESULT CDSoundDevice::amsndSetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff)
{
    HRESULT hr;
    hr = SetFocusWindow(hwnd);
    if(FAILED(hr))
        return hr;
    hr = SetMixing(bMixingOnOrOff);
    return hr;
}

// Get the focus window for the dsound renderer.
HRESULT CDSoundDevice::amsndGetFocusWindow (HWND *phwnd, BOOL *pbMixingOnOrOff)
{
   if (phwnd == NULL || pbMixingOnOrOff == NULL)
       return E_POINTER ;
   if (m_fAppSetFocusWindow)
       *phwnd = m_hFocusWindow ;
   else
       *phwnd = NULL ;
    *pbMixingOnOrOff = m_fMixing;
   return S_OK ;
}

#ifdef ENABLE_10X_FIX
// reset all statistics gathering for 10x bug
void CDSoundDevice::Reset10x()
{
    m_fRestartOnPause = FALSE;
    m_ucConsecutiveStalls = 0;
}

#endif // 10x

// set the playback rate (may be called dynamically)
HRESULT CDSoundDevice::SetRate(DOUBLE dRate, DWORD nSamplesPerSec, LPDIRECTSOUNDBUFFER pBuffer)
{
    const DWORD dwNewSamplesPerSec = (DWORD)(nSamplesPerSec * dRate);  // truncate
    if(dwNewSamplesPerSec < 100 || dwNewSamplesPerSec > 100000)
    {
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: Bad Rate specified %d at %d samples per sec"),
            (int)dRate, dwNewSamplesPerSec ));
        return WAVERR_BADFORMAT;
    }

    HRESULT hr = S_OK;

    if(!pBuffer)
        pBuffer = m_lpDSB; // we should be able to make this assumption in the case
                           // where we weren't explicitly passed a buffer (slaving case)

    if(pBuffer)
    {
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: Playing at %d%% of normal speed"), (int)(dRate * 100) ));
        hr = pBuffer->SetFrequency( dwNewSamplesPerSec );
        DbgLog((LOG_TRACE,TRACE_FORMAT_INFO,TEXT("SetRate: SetFrequency on Secondary buffer, %d samples per sec"), dwNewSamplesPerSec));

        if(hr == S_OK)
            m_dRate = dRate;  // update rate only if we succeed in changing it
        else
            DbgLog((LOG_TRACE,3,TEXT("SetRate: SetFrequency failed with hr = 0x%lx"), hr));
    }
    
    if( FAILED( hr ) && !IsNativelySupported( m_pWaveOutFilter->WaveFormat() ) )
    {
        return S_OK;
    }
    else        
        return hr;
}

void CDSoundDevice::InitClass(BOOL fLoad, const CLSID *pClsid)
{
    if(fLoad)
    {
        // see if 1.0 setup removed some keys we care about: dsr
        // renderer (and the midi renderer)
        HKEY hkdsr;
        if(RegOpenKey(HKEY_CLASSES_ROOT,
                  TEXT("CLSID\\{79376820-07D0-11CF-A24D-0020AFD79767}"),
                  &hkdsr) ==
           ERROR_SUCCESS)
        {
            EXECUTE_ASSERT(RegCloseKey(hkdsr) == ERROR_SUCCESS);
        }
        else
        {
            // were we registered at all (check for CLSID_FilterGraph)
            HKEY hkfg;
            if(RegOpenKey(HKEY_CLASSES_ROOT,
                  TEXT("CLSID\\{e436ebb3-524f-11ce-9f53-0020af0ba770}"),
                  &hkfg) ==
               ERROR_SUCCESS)
            {
                EXECUTE_ASSERT(RegCloseKey(hkfg) == ERROR_SUCCESS);

                // just re-register everything! should we check for
                // another key in case this breaks something?
                DbgLog((LOG_ERROR, 0,
                    TEXT("quartz.dll noticed that 1.0 runtime removed some stuff")
                    TEXT("from the registry; re-registering quartz")));
                EXECUTE_ASSERT(AMovieDllRegisterServer2(TRUE) == S_OK);
            }
        }
    }
}

DWORD CDSoundDevice::GetCreateFlagsSecondary( WAVEFORMATEX *pwfx)
{
    ASSERT( pwfx );
    DWORD dwFlags   = m_fMixing ?
                DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_GLOBALFOCUS :
                DSBCAPS_GETCURRENTPOSITION2 | DSBCAPS_STICKYFOCUS ;
                
    // compressed formats don't support volume control
    if( IsNativelySupported( pwfx ) )
    {
        dwFlags |= gdwDSBCAPS_CTRL_PAN_VOL_FREQ;
        
        if( m_pWaveOutFilter->m_fFilterClock == WAVE_OTHERCLOCK )
        {
            //
            // Use s/w buffers when slaving to avoid inconsistencies with allowing 
            // h/w to do rate changes. Assumption is that compressed formats like AC3-S/PDIF 
            // won't work with s/w buffers, but natively supported formats like DRM will.
            //
            DbgLog((LOG_TRACE,5,TEXT("*** specifying software dsound secondary buffer (slaving)")));
            dwFlags |= DSBCAPS_LOCSOFTWARE;
        }
    }
    
    if (m_pWaveOutFilter->m_fWant3D) {
    	DbgLog((LOG_TRACE,3,TEXT("*** making 3D secondary")));
        dwFlags |= DSBCAPS_CTRL3D;
    }
    
    return dwFlags;
}    

#ifdef DEBUG
void DbgLogWaveFormat( DWORD Level, WAVEFORMATEX * pwfx )
{
    ASSERT( pwfx );
    DbgLog((LOG_TRACE,Level,TEXT("  wFormatTag           %u" ), pwfx->wFormatTag));
    DbgLog((LOG_TRACE,Level,TEXT("  nChannels            %u" ), pwfx->nChannels));
    DbgLog((LOG_TRACE,Level,TEXT("  nSamplesPerSec       %lu"), pwfx->nSamplesPerSec));
    DbgLog((LOG_TRACE,Level,TEXT("  nAvgBytesPerSec      %lu"), pwfx->nAvgBytesPerSec));
    DbgLog((LOG_TRACE,Level,TEXT("  nBlockAlign          %u" ), pwfx->nBlockAlign));
    DbgLog((LOG_TRACE,Level,TEXT("  wBitsPerSample       %u" ), pwfx->wBitsPerSample));
    if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
    {
        DbgLog((LOG_TRACE,Level,TEXT("  dwChannelMask        %08lx" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->dwChannelMask));
        if( pwfx->wBitsPerSample )
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wValidBitsPerSample  %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wValidBitsPerSample));
        }
        else if( ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wSamplesPerBlock )
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wSamplesPerBlock     %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wSamplesPerBlock));
        }
        else
        {
            DbgLog((LOG_TRACE,Level,TEXT("  wReserved            %u" ), ((PWAVEFORMATEXTENSIBLE)pwfx)->Samples.wReserved));
        }
        OLECHAR strSubFormat[CHARS_IN_GUID];
        ASSERT( StringFromGUID2(((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat
              , strSubFormat
              , CHARS_IN_GUID) == CHARS_IN_GUID);
        DbgLog((LOG_TRACE,Level,TEXT("  SubFormat %ls" ), strSubFormat));
    }
}
#endif

bool IsNativelySupported( PWAVEFORMATEX pwfx )
{
    // formats not natively supported by kmixer require us to actually query the driver
    if( pwfx )
    {
        // of course these are natively supported on wdm only, but this is how this has been done up to now
        if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
        {
            if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  == MEDIASUBTYPE_PCM ||
                ((PWAVEFORMATIEEEFLOATEX)pwfx)->SubFormat == MEDIASUBTYPE_IEEE_FLOAT ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat  == MEDIASUBTYPE_DRM_Audio )
            {
                return true;
            }
        }
        else if( WAVE_FORMAT_PCM == pwfx->wFormatTag ||
                 WAVE_FORMAT_DRM == pwfx->wFormatTag ||
                 WAVE_FORMAT_IEEE_FLOAT == pwfx->wFormatTag )
        {
            return true;
        }
    }
            
    // so far, WAVE_FORMAT_DOLBY_AC3_SPDIF (and it's equivalents) is the only one that we 
    // allow through that isn't natively supported by kmixer
    return false;
}

//
// CanWriteSilence - do we know how to write silence for this format?
// 
bool CanWriteSilence( PWAVEFORMATEX pwfx )
{
    if( pwfx )
    {
        if( WAVE_FORMAT_EXTENSIBLE == pwfx->wFormatTag )
        {
            //
            // from the Non-pcm audio white paper:
            // "Wave format tags 0x0092, 0x0240 and 0x0241 are identically defined as 
            // AC3-over-S/PDIF (these tags are treated completely identically by many 
            // DVD applications)."
            //
            if( ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_PCM ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_DOLBY_AC3_SPDIF ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_RAW_SPORT ||
                ((PWAVEFORMATEXTENSIBLE)pwfx)->SubFormat == MEDIASUBTYPE_SPDIF_TAG_241h )
            {
                return true;
            }
        }
        else if( WAVE_FORMAT_PCM == pwfx->wFormatTag ||
                 WAVE_FORMAT_DOLBY_AC3_SPDIF == pwfx->wFormatTag ||
                 WAVE_FORMAT_RAW_SPORT == pwfx->wFormatTag ||
                 0x241 == pwfx->wFormatTag )
        {
            return true;
        }
    }        
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\midiout.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CMidiOutDevice class based on midiOut APIs.
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include "waveout.h"
#include "midiout.h"
#include "midif.h"

#define IntToPtr_(T, i) ((T)IntToPtr(i))

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its midiOut guise.
//

const AMOVIESETUP_MEDIATYPE
midiOpPinTypes = { &MEDIATYPE_Midi, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
midiOutOpPin = { L"Input"
               , TRUE    	   // bRendered
               , FALSE		   // bOutput
               , FALSE		   // bZero
               , FALSE		   // bMany
               , &CLSID_NULL	   // clsConnectToFilter
               , NULL	           // strConnectsToPin
               , 1	           // nMediaTypes
               , &midiOpPinTypes }; // lpMediaTypes

const AMOVIESETUP_FILTER midiFilter = { &CLSID_AVIMIDIRender	// filter class id
                                     , L"Midi Renderer"		// filter name
                                     , MERIT_DO_NOT_USE  		// dwMerit
                                     , 1
                                     , &midiOutOpPin };


//-----------------------------------------------------------------------------
// CreateInstance for the MidiOutDevice. This will create a new MidiOutDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CMidiOutDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    // make sure that there is at least one midiOut device in the system. Fail
    // the create instance if not.
    if (0 == midiOutGetNumDevs ())
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }

    return CreateRendererInstance<CMidiOutDevice>(pUnk, &midiFilter, phr);
}

//-----------------------------------------------------------------------------
// CMidiOutDevice constructor.
//-----------------------------------------------------------------------------
CMidiOutDevice::CMidiOutDevice ()
    : m_lVolume ( 0 )
    , m_lBalance ( 0 )
    , m_wLeft ( 0xFFFF )
    , m_wRight ( 0xFFFF )
    , m_dwWaveVolume ( 0 )
    , m_fHasVolume ( 0 )
    , m_hmidi ( 0 )
    , m_fDiscontinuity( TRUE )
	, m_fBalanceSet (FALSE)
	, m_ListVolumeControl(NAME("CMidiOutFilter volume control list"))
	, m_iMidiOutId( MIDI_MAPPER )

{
    
}

//-----------------------------------------------------------------------------
// CMidiOutDevice destructor.
//
//-----------------------------------------------------------------------------
CMidiOutDevice::~CMidiOutDevice ()
{
   	CVolumeControl *pVolume;
	while(pVolume = m_ListVolumeControl.RemoveHead())
		delete pVolume;

	ASSERT(m_ListVolumeControl.GetCount() == 0);

}

//-----------------------------------------------------------------------------
// midiOutClose.
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutClose ()
{
    // some validation.

    if (m_hmidi == 0)
    {
        DbgBreak("Called to close when not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutClose - device is not open")));
        return MMSYSERR_ERROR ;
    }

    MMRESULT mmr = ::midiStreamClose (m_hmidi) ;
    m_hmidi = 0;
    return mmr;
}

//-----------------------------------------------------------------------------
// midiOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CMidiOutDevice::amsndOutGetResourceName ()
{
    return m_wszResourceName;
}

//-----------------------------------------------------------------------------
// waveGetDevCaps
//
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
	if(!pwoc)
		return MMSYSERR_INVALPARAM;
	pwoc->dwSupport = 0;

   	MMRESULT mmr;
	
	if(m_ListVolumeControl.GetCount())
	{
		pwoc->dwSupport = m_fHasVolume & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
		return MMSYSERR_NOERROR;
	}

	// do our mixer line detection
	if((mmr = DoDetectVolumeControl()) == MMSYSERR_NOERROR) // we won't succeed unless there is a valid balance control
	{
		if(!m_ListVolumeControl.GetCount())
			return mmr;

		pwoc->dwSupport |= WAVECAPS_VOLUME;
		
		POSITION pos = m_ListVolumeControl.GetHeadPosition();
		while(pos)
		{
			CVolumeControl *pVolume = m_ListVolumeControl.GetNext(pos);
			if(pVolume->dwChannels == 2)
			{
				pwoc->dwSupport |= WAVECAPS_LRVOLUME;
				break;
			}
		}

		//save volume capabilities
		m_fHasVolume = pwoc->dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
	}

	return mmr;
}

//-----------------------------------------------------------------------------
// midiOutGetErrorText
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
    return ::midiOutGetErrorText (mmrE, pszText, cchText) ;
}

//-----------------------------------------------------------------------------
// midiOutGetPosition
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{
    pmmt->wType = TIME_MS;

    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetPosition - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    const MMRESULT mmr = ::midiStreamPosition (m_hmidi, pmmt, cbmmt) ;
    if (MMSYSERR_NOERROR != mmr) {
        DbgLog((LOG_ERROR,0,TEXT("midiOutGetPosition - FAILED")));
        DbgBreak("Failed to get the device position.");
    }
    return mmr;
}

//-----------------------------------------------------------------------------
// midiOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
#if 0 // use the mixer
    if (m_hmidi == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetBalance - device is not open")));
	*plBalance = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutgetVolume: GetVolume failed %u"), hr & 0x0ffff));
	}
    *plBalance = m_lBalance;
    return hr ;
}

//-----------------------------------------------------------------------------
// midiOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
#if 0 // use the mixer
    if (m_hmidi == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("midiOutGetVolume - device is not open")));
	*plVolume = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutgetVolume: GetVolume failed %u"), hr & 0x0ffff));
	}
    *plVolume = m_lVolume;
    return hr ;
}


HRESULT CMidiOutDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    if (pmt->majortype != MEDIATYPE_Midi) {
	return E_INVALIDARG;
    }

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT)) {
        return E_INVALIDARG;
    }

    // somewhere between 20 and 98 we overflow and play really slowly
    if (dRate < 0.01 || dRate > 20) {
        return VFW_E_UNSUPPORTED_AUDIO;
    }


    return S_OK;
}



MMRESULT CMidiOutDevice::DoOpen()
{

    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamOpen")));
    UINT err = midiStreamOpen(&m_hmidi,
                           &m_iMidiOutId,
                           1,
                           m_dwCallBack,
                           m_dwCallBackInstance,
                           CALLBACK_FUNCTION);

    if (err != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error %u in midiStreamOpen"), err));
	m_hmidi = NULL;
        return E_FAIL;
    }

    // The format of a MIDI stream is just the time division (the tempo).
    // Set the proper tempo.
    MIDIPROPTIMEDIV mptd;
    mptd.cbStruct  = sizeof(mptd);
    mptd.dwTimeDiv = m_dwDivision;
    DbgLog((LOG_TRACE,1,TEXT("Setting time division to %ld"),mptd.dwTimeDiv));
    if (midiStreamProperty(m_hmidi, (LPBYTE)&mptd,
			MIDIPROP_SET|MIDIPROP_TIMEDIV) != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error setting time division, closing device")));
	midiStreamClose(m_hmidi);
	m_hmidi = NULL;
	return E_FAIL;
    }

	GetVolume();
	GetBalance();

    return err;
}
//-----------------------------------------------------------------------------
// midiOutOpen
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
				       double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				       DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{
    // some validation.  If the device is already open we have an error,
    // with the exception that QUERY calls are permitted.

    if (fdwOpen & WAVE_FORMAT_QUERY) {
	return MMSYSERR_NOERROR;
    }

    else if (m_hmidi != 0)
    {
        DbgBreak("Invalid - device ALREADY open - logic error");
        DbgLog((LOG_ERROR,1,TEXT("midiOutOpen - device is already open")));
        return MMSYSERR_ERROR ;
    }

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }

    MIDIFORMAT *pmf = (MIDIFORMAT *) pwfx;
    m_dwDivision = (DWORD) (pmf->dwDivision * dRate);
    m_dwCallBack = dwCallBack;
    m_dwCallBackInstance = dwCallBackInstance;

    DWORD err =  DoOpen();

    if (MMSYSERR_NOERROR == err && phwo && !(fdwOpen & WAVE_FORMAT_QUERY)) {
        *phwo = (HWAVEOUT) m_hmidi;
    }

    return err;
}
//-----------------------------------------------------------------------------
// midiOutPause
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutPause ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutPause - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiStreamPause (m_hmidi) ;
}

//-----------------------------------------------------------------------------
// midiOutPrepareHeader
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutPrepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiOutPrepareHeader ((HMIDIOUT) m_hmidi, (LPMIDIHDR) pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// midiOutReset
//
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutReset ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutReset - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    m_fDiscontinuity = TRUE;

    //return ::midiOutReset ((HMIDIOUT) m_hmidi) ;
    MMRESULT err = ::midiOutReset((HMIDIOUT) m_hmidi);

    // !!! work around midiStreamOut bug in Win95 and NT3, need to re-open
    // device, otherwise playing n seconds of a MIDI file, and seeking will
    // result in n seconds of silence before playback resumes.
    // This kills performance, so only do this if necessary
    BOOL fNeedHack = (g_amPlatform == VER_PLATFORM_WIN32_WINDOWS &&
	(g_osInfo.dwMajorVersion < 4 || (g_osInfo.dwMajorVersion == 4 &&
	 g_osInfo.dwMinorVersion < 10))) ||
    	(g_amPlatform == VER_PLATFORM_WIN32_NT && g_osInfo.dwMajorVersion < 4);

    if (fNeedHack) {
        //DbgLog((LOG_ERROR,0,TEXT("*** NEED RESTART HACK")));
        amsndOutClose();
        DoOpen();
    }

    return err;
}

//-----------------------------------------------------------------------------
// midiOutRestart
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutRestart ()
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutRestart - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    DbgLog((LOG_TRACE, 3, "calling midistreamrestart"));
    return ::midiStreamRestart (m_hmidi) ;
}
//-----------------------------------------------------------------------------
// midiOutSetBalance
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutSetBalance (LONG lBalance)
{
	HRESULT hr = S_OK;

	m_lBalance = lBalance;
	m_fBalanceSet = TRUE;

	// go and calculate the channel attenuation
	SetBalance();
	hr = PutVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutSetBalance: PutVolume failed %u"), hr & 0x0ffff));
	}
	return hr;
}
//-----------------------------------------------------------------------------
// midiOutSetVolume
//
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::amsndOutSetVolume (LONG lVolume)
{
	HRESULT hr = S_OK;

	// map volume onto decibel range
	DWORD dwAmp = DBToAmpFactor( lVolume );
	m_lVolume = lVolume;

    // now that the absolute volume has been set we should adjust
    // the balance to maintain the same DB separation
    SetBalance ();
	hr = PutVolume();
	if(FAILED(hr))
	{
        DbgLog((LOG_ERROR, 2, TEXT("amsndOutSetVolume: PutVolume failed %u"), hr & 0x0ffff));
	}
	return hr;

}
//-----------------------------------------------------------------------------
// midiOutUnprepareHeader
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutUnprepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::midiOutUnprepareHeader((HMIDIOUT) m_hmidi, (LPMIDIHDR) pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// midiOutWrite
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, const REFERENCE_TIME *pStart, BOOL bIsDiscontinuity)
{
    // some validation.
    if (m_hmidi == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("midiOutWrite - device is not open")));
        return MMSYSERR_NODRIVER ;
    }


    // !!! need to hack midi data into shape.

    MIDIHDR *pmh = (MIDIHDR *) pwh->lpData;

    DWORD dwCopy = pmh->dwBufferLength;

    pmh = (MIDIHDR *) (pwh->lpData + sizeof(MIDIHDR) + dwCopy);

    if (m_fDiscontinuity) {
	m_fDiscontinuity = FALSE;

	memmoveInternal(pwh->lpData, pwh->lpData + sizeof(MIDIHDR), dwCopy);
    } else {
	dwCopy = 0;
    }

    pwh->dwBufferLength = pmh->dwBufferLength + dwCopy;
    pwh->dwBytesRecorded = pmh->dwBufferLength + dwCopy;

    memmoveInternal(pwh->lpData + dwCopy, (pmh + 1), pmh->dwBufferLength);

    DWORD err = ::midiStreamOut(m_hmidi, (LPMIDIHDR) pwh, cbwh) ;

    return err;
}

//-----------------------------------------------------------------------------
// Internal function to get volume.
//-----------------------------------------------------------------------------

HRESULT CMidiOutDevice::GetVolume()
{
    // Write out the current Audio volume
    // ...query the device
    // assumes the device is connected...
    // if not we will query the volume from the mixer (probably)

    DWORD 		amp = 0;
    HMIDIOUT 	hDevice;

	MMRESULT err = MMSYSERR_NOERROR;

	if(!m_ListVolumeControl.GetCount())
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  no volume controls available")));
		return E_FAIL;
	}

	// for now, simply return the first volume control setting
	err = DoGetVolumeControl(
				m_ListVolumeControl.Get(m_ListVolumeControl.GetHeadPosition()),
				&m_wLeft,
				&m_wRight);

	if(err != MMSYSERR_NOERROR)
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  DoGetVolumControl failed")));
		return E_FAIL;
	}

	amp  = m_wLeft;
	amp |= m_wRight << 16;

	if(!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
    {
	    // for mono cards map Left to Right
#ifdef DEBUG
	    // assert that the volume we want is in the low word
	    if (amp)
        {
			ASSERT(m_wLeft);
	    }
#endif
	    m_wRight = m_wLeft;
	}
    m_dwWaveVolume = amp;
	
	// map volume onto decibel range
	DWORD dwAmp = max(m_wLeft, m_wRight);
	m_lVolume = AmpFactorToDB( dwAmp );

	// remember to adjust the Balance value...
	if(m_fBalanceSet)
		SetBalance();
	else
		GetBalance();

	return err == MMSYSERR_NOERROR ? S_OK : S_FALSE;

}

//-----------------------------------------------------------------------------
// Internal routine to set the volume.  No parameter checking...
//-----------------------------------------------------------------------------
HRESULT CMidiOutDevice::PutVolume ()
{
	if(!m_ListVolumeControl.GetCount())
	{
		DbgLog((LOG_ERROR, 1, TEXT("CMidiDevice::GetVolume:  no volume controls available")));
		return E_FAIL;
		
	}
	MMRESULT mmr = 0;
	POSITION pos = m_ListVolumeControl.GetHeadPosition();
	while(pos)
	{
		mmr |= DoSetVolumeControl( m_ListVolumeControl.GetNext(pos), m_wLeft, m_wRight );

	}
	return mmr == MMSYSERR_NOERROR ? S_OK : E_FAIL;

}
//-----------------------------------------------------------------------------
// Internal routine to set the Balance.
//-----------------------------------------------------------------------------
void CMidiOutDevice::SetBalance ()
{
    //
    // Calculate scaling factors for midiOut API
    //
    LONG lTotalLeftDB, lTotalRightDB ;

    if (m_lBalance >= 0)
    {
	// left is attenuated
	lTotalLeftDB	= m_lVolume - m_lBalance ;
	lTotalRightDB	= m_lVolume;
    }
    else
    {
	// right is attenuated
	lTotalLeftDB	= m_lVolume;
	lTotalRightDB	= m_lVolume - (-m_lBalance);
    }

    DWORD dwLeftAmpFactor, dwRightAmpFactor;
    dwLeftAmpFactor   = DBToAmpFactor(lTotalLeftDB);
    dwRightAmpFactor  = DBToAmpFactor(lTotalRightDB);

    if (m_fHasVolume & (WAVECAPS_LRVOLUME))
    {
	// Set stereo volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume |= dwRightAmpFactor << 16;
    }
    else
    {
	// Average the volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume += dwRightAmpFactor;
	m_dwWaveVolume /= 2;
    }
    m_wLeft = WORD(dwLeftAmpFactor);
    m_wRight = WORD(dwRightAmpFactor);
}

//-----------------------------------------------------------------------------
// Internal routine to compute the Balance given right/left amp factors
//-----------------------------------------------------------------------------
void CMidiOutDevice::GetBalance()
{
	if (m_wLeft == m_wRight)
    {
	    m_lBalance = 0;
	}
    else
    {
	    // map Balance onto decibel range
	    LONG lLDecibel = AmpFactorToDB( m_wLeft );
		LONG lRDecibel = AmpFactorToDB( m_wRight );

	    // note: m_lBalance < 0:  right is quieter
	    //       m_lBalance > 0:  left is quieter
	    m_lBalance = lRDecibel - lLDecibel;
	}
}

//-----------------------------------------------------------------------------
// Internal routine used to get a mixer line balance control value
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::DoGetVolumeControl(CVolumeControl *pControl, WORD *pwLeft, WORD *pwRight)
{
	if(!pControl || !pwLeft || !pwRight)
	{
		DbgLog((LOG_ERROR,1,TEXT("DoGetVolumeControl::invalid parameter: pControl=%u, dwLeft=%u, dwRight=%u"),
			pControl, pwLeft, pwRight));
		return MMSYSERR_INVALPARAM;
	}

	MMRESULT mmr;

	DWORD adwVolume[2];
	adwVolume[0] = 0;
	adwVolume[1] = 0;

   	MIXERCONTROLDETAILS mxcd;

	mxcd.cbStruct = sizeof(mxcd);
	mxcd.dwControlID = pControl->dwControlID;
	mxcd.cChannels = pControl->dwChannels;
	mxcd.cMultipleItems = 0;
	mxcd.cbDetails = sizeof(2 * sizeof(DWORD));
	mxcd.paDetails = (LPVOID)adwVolume;

	mmr = mixerGetControlDetails(IntToPtr_(HMIXEROBJ, pControl->dwMixerID), &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

	*pwLeft = (WORD)adwVolume[0];
	*pwRight = (WORD)adwVolume[1];

    DbgLog((LOG_TRACE,1,TEXT("DoGetVolumeControl::mixerGetControlDetails: err=%u, midiOutMixerID=%u, midiOutVolControlID=%u, left=%u, right=%u"),
		mmr, pControl->dwMixerID, pControl->dwControlID, *pwLeft, *pwRight));

	return mmr;
}

//-----------------------------------------------------------------------------
// Internal routine used to set a mixer line balance control
//-----------------------------------------------------------------------------

MMRESULT CMidiOutDevice::DoSetVolumeControl(CVolumeControl *pControl, DWORD dwLeft, DWORD dwRight)
{
	if(dwLeft > 65536 || dwRight > 65536 || !pControl)
	{
		DbgLog((LOG_ERROR,1,TEXT("DoSetVolumeControl::invalid parameter: pControl=%u, dwLeft=%u, dwRight=%u"),
			pControl, dwLeft, dwRight));
		return MMSYSERR_INVALPARAM;
	}

	MMRESULT mmr;

	DWORD adwVolume[2];
	adwVolume[0] = dwLeft;
	adwVolume[1] = dwRight;

   	MIXERCONTROLDETAILS mxcd;

	mxcd.cbStruct = sizeof(mxcd);
	mxcd.dwControlID = pControl->dwControlID;
	mxcd.cChannels = pControl->dwChannels;
	mxcd.cMultipleItems = 0;
	mxcd.cbDetails = sizeof(2 * sizeof(DWORD));
	mxcd.paDetails = (LPVOID)adwVolume;

	mmr = mixerSetControlDetails(IntToPtr_(HMIXEROBJ,pControl->dwMixerID), &mxcd, MIXER_GETCONTROLDETAILSF_VALUE);

    DbgLog((LOG_TRACE,1,TEXT("DoSetVolumeControl::mixerSetControlDetails: err=%u, midiOutMixerID=%u, midiOutVolControlID=%u, left=%u, right=%u"),
		mmr, pControl->dwMixerID, pControl->dwControlID, dwLeft, dwRight));

	return mmr;
}

//-----------------------------------------------------------------------------
// Internal routine used to initialize all mixer line balance controls
//-----------------------------------------------------------------------------
MMRESULT CMidiOutDevice::DoDetectVolumeControl()
{
	MMRESULT mmr = MMSYSERR_NOERROR;

	if(m_ListVolumeControl.GetCount())
		return m_fHasVolume & WAVECAPS_VOLUME ?  MMSYSERR_NOERROR : MMSYSERR_NOTSUPPORTED;

    DbgLog((LOG_TRACE,1,TEXT("CMidiOutDevice::DoDetectVolume: Scanning for line controls..........")));

	UINT cMixers = ::mixerGetNumDevs();
	if(cMixers == 0)
		return MMSYSERR_NOTSUPPORTED;

	MIXERCAPS *pmxcaps;
	pmxcaps = new MIXERCAPS[ cMixers * sizeof(MIXERCAPS) ];
	if(!pmxcaps)
		return MMSYSERR_NOMEM;

	// loop over each mixer
	for(UINT iMixer = 0; iMixer < cMixers; iMixer++)
	{
		mmr = mixerGetDevCaps(iMixer, &(pmxcaps[iMixer]), sizeof(MIXERCAPS));

        DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetDevCaps: err=%u, mixerId=%ul, mixerName=%s"), mmr, iMixer, pmxcaps->szPname));

		if(mmr != MMSYSERR_NOERROR)
			continue;
					
    	MIXERLINE   mlDest;

		// loop over each mixer output looking for the one connected to the speaker jack
		for(UINT iDest = 0; iDest < pmxcaps[iMixer].cDestinations; iDest++)
		{
    		ZeroMemory(&mlDest, sizeof(mlDest));
    		mlDest.cbStruct = sizeof(mlDest);
   			mlDest.dwDestination = iDest;

    		mmr = mixerGetLineInfo(IntToPtr_(HMIXEROBJ, iMixer), &mlDest, MIXER_GETLINEINFOF_DESTINATION);

            DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineInfo(DESTINATION): err=%u, lineName=%s, componentType=%u"),
        				mmr, mlDest.szName, mlDest.dwComponentType));

			if(mmr != MMSYSERR_NOERROR)
				continue;

			// we've found the mixer connected to the speaker jack
			if(mlDest.dwComponentType == MIXERLINE_COMPONENTTYPE_DST_SPEAKERS)	
 			{
				MIXERLINE mlSrc;

				for(UINT iSrc = 0; iSrc < mlDest.cConnections; iSrc++)
				{
					ZeroMemory(&mlSrc, sizeof(mlSrc));
        			mlSrc.cbStruct = sizeof(mlSrc);
        			mlSrc.dwDestination = iDest;
        			mlSrc.dwSource = iSrc;

        			mmr = mixerGetLineInfo(IntToPtr_(HMIXEROBJ,iMixer), &mlSrc, MIXER_GETLINEINFOF_SOURCE);

	          		DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineInfo(SOURCE): err=%u, lineName=%s, componentType=%u"),
        				mmr, mlSrc.szName, mlSrc.dwLineID, mlSrc.dwComponentType ));

					if(mmr != MMSYSERR_NOERROR)
						continue;

					if(mlSrc.dwComponentType == MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER)
					{
						MIXERLINECONTROLS   mxlc;
						MIXERCONTROL		mxc;
						CVolumeControl		*pControl;

    					mxlc.cbStruct       = sizeof(mxlc);
    					mxlc.dwLineID       = mlSrc.dwLineID;
    					mxlc.dwControlType  = MIXERCONTROL_CONTROLTYPE_VOLUME;
    					mxlc.cControls      = 1;
    					mxlc.cbmxctrl       = sizeof(mxc);
    					mxlc.pamxctrl       = &mxc;	 // the control description

						mmr = mixerGetLineControls(IntToPtr_(HMIXEROBJ,iMixer), &mxlc, MIXER_GETLINECONTROLSF_ONEBYTYPE);
						if(mmr != MMSYSERR_NOERROR)
							continue;

    					DbgLog((LOG_TRACE,1,TEXT("DoDetectVolumeControl::mixerGetLineControl: err=%u, midiOutLineID=%u, midiOutVolControlID=%u, midiOutVolControlName=%s, midiOutChannels=%u, midiOutVolControlMinBounds=%u, midiOutVolControlMaxBounds=%u"),
    						mmr, mlSrc.dwLineID, mxlc.pamxctrl->dwControlID, mxlc.pamxctrl->szName, mlSrc.cChannels, mxlc.pamxctrl->Bounds.dwMinimum, mxlc.pamxctrl->Bounds.dwMaximum));
		
						pControl = new CVolumeControl(NAME("CMidiDevice volume control"));
						if(!pControl)
						{
							if(pmxcaps) delete pmxcaps;
							return MMSYSERR_NOMEM;
						}
						pControl->dwMixerID = iMixer;
						pControl->dwControlID = mxlc.pamxctrl->dwControlID;
						pControl->dwChannels = mlSrc.cChannels;

						m_ListVolumeControl.AddTail(pControl);

					} // MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER
				
				} // iSrc
				
			} // MIXERLINE_COMPONENTTYPE_DST_SPEAKERS

	  	} // iDest

	} // iMixer

	if(pmxcaps)
		delete pmxcaps;

	return mmr;

}

//-----------------------------------------------------------------------------

HRESULT CMidiOutDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    if(m_hmidi != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"MidiOutId", &var, 0);
    if(SUCCEEDED(hr))
    {
        m_iMidiOutId = var.lVal;
        SetResourceName();
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return hr;
}

// use a version number instead of size to reduce chances of picking
// an invalid device from a 1.0 grf file
struct MidiOutPersist
{
    DWORD dwVersion;
    LONG iMidiOutId;
};


HRESULT  CMidiOutDevice::amsndOutWriteToStream(IStream *pStream)
{
    MidiOutPersist mop;
    mop.dwVersion = 200;
    mop.iMidiOutId = m_iMidiOutId;
    return pStream->Write(&mop, sizeof(mop), 0);
}

HRESULT  CMidiOutDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_hmidi != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // on any error, default to the wave mapper because we may have
    // found the old audio renderer which has the same guid
    m_iMidiOutId = MIDI_MAPPER;

    // caller makes sure we're not running
    MidiOutPersist mop;
    HRESULT hr = pStream->Read(&mop, sizeof(mop), 0);
    if(SUCCEEDED(hr))
    {
        if(mop.dwVersion == 200)
        {
            m_iMidiOutId = mop.iMidiOutId;
        }
    }

    hr = S_OK;
    SetResourceName();

    return hr;
}

int CMidiOutDevice::amsndOutSizeMax()
{
    return sizeof(MidiOutPersist);
}

void CMidiOutDevice::SetResourceName()
{
    wsprintfW(m_wszResourceName, L".\\MidiOut\\%08x", m_iMidiOutId);
}

#if 0
// LEGACY, we don't need to send notes off messages, as the streaming API already keeps track of active notes
// under the covers.  keeping code in place for now.
typedef struct
{
    BYTE    status;
    BYTE    byte2;
    BYTE    byte3;
    BYTE    time;
} FOURBYTEEVENT;

typedef union
{
    DWORD         wordMsg;
    FOURBYTEEVENT byteMsg;
} SHORTEVENT;

MMRESULT CMidiOutDevice::DoAllNotesOff()
{
    ASSERT(m_hmidi != 0);

    SHORTEVENT shortMidiEvent;
    UINT uiChannel;
    UINT uiKey;

    for(uiChannel = 0; uiChannel < 16; uiChannel++)
    {
        // sustain pedal off for all uiChannels
        shortMidiEvent.byteMsg.status= (BYTE) (0xB0 + uiChannel);
        shortMidiEvent.byteMsg.byte2 = (BYTE) 0x40;
        shortMidiEvent.byteMsg.byte3 = 0x0;
        ::midiOutShortMsg(HMIDIOUT(m_hmidi), shortMidiEvent.wordMsg);

        // now do note offs
        shortMidiEvent.byteMsg.status= (BYTE) (0x80 + uiChannel);
        shortMidiEvent.byteMsg.byte3 = 0x40;  // release velocity
        for(uiKey = 0; uiKey < 128; uiKey++)
        {
            shortMidiEvent.byteMsg.byte2 = (BYTE) uiKey;
            // turn it off
            ::midiOutShortMsg(HMIDIOUT(m_hmidi), shortMidiEvent.wordMsg);
        }
    }
    return MMSYSERR_NOERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\passthru.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

//-----------------------------------------------------------------------------
// declares a CPosPassThru object specific to the audio renderer that
// adds the ability to monitor the rate being set
//-----------------------------------------------------------------------------

#ifndef _CARPOSPASSTHRU_H_
#define _CARPOSPASSTHRU_H_

class CWaveOutInputPin;

// Adds the ability to monitor rate setting

class CARPosPassThru : public CPosPassThru
{
private:
    typedef CPosPassThru inherited;

    CWaveOutFilter      *const m_pFilter;
    CWaveOutInputPin    *const m_pPin;

public:

    CARPosPassThru( CWaveOutFilter *pWaveOutFilter, HRESULT*phr, CWaveOutInputPin *pPin);

    // we override rate handling so that our filter can verify what is
    // going on

    // From IMediaSeeking
    STDMETHODIMP SetRate( double dRate );

    // From IMediaPosition
    STDMETHODIMP put_Rate( double dRate );

};

#endif // _CARPOSPASSTHRU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\passthru.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

//-----------------------------------------------------------------------------
// Implements a CPosPassThru object specific to the audio renderer that
// adds the ability to monitor the rate being set
//-----------------------------------------------------------------------------

#include <streams.h>
#include "waveout.h"

CARPosPassThru::CARPosPassThru( CWaveOutFilter *pWaveOutFilter, HRESULT*phr, CWaveOutInputPin *pPin )
    : CPosPassThru (NAME("Audio Render CPosPassThru"),
		    pWaveOutFilter->GetOwner(), phr, pPin)
    , m_pFilter (pWaveOutFilter)
    , m_pPin    (pPin)
{};

STDMETHODIMP CARPosPassThru::SetRate( double dRate )
{
    // if our filter accepts the rate, then call the base class
    // otherwise return the error from the filter.

    HRESULT hr = m_pPin->SetRate(dRate);
    if( S_FALSE == hr )
    {
        //
        // S_FALSE means that the audio renderer input pin doesn't
        // think its rate needs to be changed. Make sure the inherited 
        // class (the upstream filter), since the renderer might not be handling 
        // the rate change (i.e. for MIDI the parser will handle the change)
        //
        double dInheritedRate;
        hr = inherited::GetRate( &dInheritedRate );
        if( ( S_OK == hr ) && ( dInheritedRate == dRate ) )
        {
            // change hr to S_OK to force the upcoming SetRate call
            hr = S_OK;         
        }        
    }    
    
    if (S_OK == hr) {
        //
        // this will cause the upstream filter to notify us via NewSegment
        // of the rate change
        //
	hr = inherited::SetRate(dRate);
    } else if (S_FALSE == hr) {
	// ?? Should we return S_FALSE or change it to S_OK ??
	hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CARPosPassThru::put_Rate( double dRate )
{
    // if our filter accepts the rate, then call the base class
    // otherwise return the error from the filter.

    HRESULT hr = m_pPin->SetRate(dRate);
    if (S_OK == hr) {
	hr = inherited::put_Rate(dRate);
    } else if (S_FALSE == hr) {
	// ?? Should we return S_FALSE or change it to S_OK ??
	hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\slave.cpp ===
// Copyright (c) Microsoft Corporation 1999. All Rights Reserved
// Slaving class for DirectShow audio renderer

#include <streams.h>

#include "waveout.h"
#include "dsr.h"

// ks headers only needed for KSAUDFNAME_WAVE_OUT_MIX hack for Brooktree
#include <ks.h>                
#include <ksmedia.h>                

//#pragma message (REMIND("Turn down clock slave debug level!!"))

#ifdef DEBUG
const DWORD DBG_LEVEL_CLOCK_SYNC_DETAILS     = 8;
const DWORD DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS = 4;
#endif

extern LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData);

// allow tuning via registry while best settings are being ironed out
const TCHAR g_szhkSlaveSettings[] =                   TEXT( "Software\\Microsoft\\DirectShow\\ClockSlave");
const TCHAR g_szSlaveSettings_ThresholdMS[] =         TEXT( "ThresholdMS" );
const TCHAR g_szSlaveSettings_PercentErrorDecay[] =   TEXT( "PercentErrorDecay" );
const TCHAR g_szSlaveSettings_ClockAdjustLimit[] =    TEXT( "MaxClockAdjustDivisor" );
const TCHAR g_szSlaveSettings_ClockAdjustStepSize[] = TEXT( "ClockAdjustStepSize" );
const TCHAR g_szSlaveSettings_woLatencyThresholdMS[] = TEXT( "woLatencyThresholdMS" );



//-----------------------------------------------------------------------------
//
// Audio Renderer Slaving class
//
//-----------------------------------------------------------------------------

// default frequency adjustment constants
#define MIN_MAX_CLOCK_DIVISOR    80      // (1/160) * 2 = .00625*2 = .0125 (1.25%)
#define CLOCK_ADJUST_RESOLUTION  (160*2*2) // use a 1/720th granularity
                                         // (Eventually will be determined via an API or property set)
                                         // kmixer's resolution for high quality SRC is 160th of the sample rate.
                                         // For "PC" quality SRC, it's 1/1096 the native sample rate.
                                         // For minimizing pitch change we force the PC SRC and  a 1/(160*4) step size.
#define ERROR_DECAY_FACTOR       .99     // used to bring the last max or min error which
                                         // initiated a freq adjustment back down

#define SLAVE_ADJUST_THRESHOLD          200000  // 20ms tolerance
#define WAVEOUT_SLAVE_LATENCY_THRESHOLD 800000  // latency goal for waveOut slaving, for non-WDM devices
                                                // seems like we need to use ~80ms


//-----------------------------------------------------------------------------
//
// CWaveSlave
//
// Constructor 
//
//-----------------------------------------------------------------------------
CWaveSlave::CWaveSlave
(
    CWaveOutFilter *pWaveOutFilter,
    CWaveOutInputPin *pWaveOutInputPin
) :
    m_pFilter(pWaveOutFilter),
    m_pPin(pWaveOutInputPin),
    m_rtAdjustThreshold( SLAVE_ADJUST_THRESHOLD ),
    m_fltAdjustStepFactor( (float) 1.0 / CLOCK_ADJUST_RESOLUTION ), 
    m_fltMaxAdjustFactor( (float) 1.0 / MIN_MAX_CLOCK_DIVISOR ),
    m_fltErrorDecayFactor( (float) ERROR_DECAY_FACTOR ),
    m_rtWaveOutLatencyThreshold( WAVEOUT_SLAVE_LATENCY_THRESHOLD )
{
    ASSERT(pWaveOutFilter != NULL);
    ASSERT(pWaveOutInputPin != NULL);

    // allow for the ability to tweak some of the params from the registry
    HKEY hkSlaveParams;
    LONG lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        g_szhkSlaveSettings,
        0,                      
        KEY_READ,
        &hkSlaveParams);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD dwType, dwVal, dwcb;
        
        // error decay
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_PercentErrorDecay,
            0,               
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            ASSERT( 0 < dwVal && 100 > dwVal );
            if( 0 < dwVal && 100 > dwVal )
            {
                m_fltErrorDecayFactor = dwVal / (float)100.;
            }
        }
        
        // threshold for when to adjust frequency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ThresholdMS,
            0,                
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_rtAdjustThreshold = ( dwVal * ( UNITS / MILLISECONDS ) );
            }
        }
        
        // frequency adjustment step size
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ClockAdjustStepSize,
            0,                
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_fltAdjustStepFactor = (float)1.0 / dwVal;
            }
        }

        // limit on frequency adjustments
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_ClockAdjustLimit,
            0,              
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_fltMaxAdjustFactor = (float) 1.0 / dwVal;
            }
        }
      
        // maximum waveOut device latency
        dwcb = sizeof(DWORD);
        lResult = RegQueryValueEx(
            hkSlaveParams,
            g_szSlaveSettings_woLatencyThresholdMS,
            0,              
            &dwType,
            (BYTE *) &dwVal,
            &dwcb);
        if( ERROR_SUCCESS == lResult )
        {
            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_DWORD : TRUE);
            if( 0 < dwVal )
            {
                m_rtWaveOutLatencyThreshold = ( dwVal * ( UNITS / MILLISECONDS ) );
            }
        }
                            
        EXECUTE_ASSERT(RegCloseKey(hkSlaveParams) == ERROR_SUCCESS);
    }
    
    DbgLog((LOG_TRACE, 4, TEXT("wo:Slaving - Clock slave parameters:") ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Error threshold - %dms"), m_rtAdjustThreshold/10000 ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Clock adjustment step - %s"), CDisp(m_fltAdjustStepFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Clock adjustment limit - %s"), CDisp(m_fltMaxAdjustFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Percent Error Decay - %s"), CDisp(m_fltErrorDecayFactor) ) );
    DbgLog((LOG_TRACE, 4, TEXT("     Latency threshold for WaveOut slaving - %dms"), m_rtWaveOutLatencyThreshold/10000 ) );

    ResumeSlaving( TRUE ); // reset all params
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::GetMasterClockTime
//
// Get the current master clock time by using the slave mode to determine how to read
// this time.
//
//-----------------------------------------------------------------------------
REFERENCE_TIME CWaveSlave::GetMasterClockTime
(
    REFERENCE_TIME rtStart, 
    BOOL bReset
)
{
    REFERENCE_TIME rtMasterClockTime = 0;
    if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
    {
        // slave to buffer fullness
        
        // start time for this sample, based on bytes delivered and default rate
        if( bReset )
            rtMasterClockTime = 0;
        else                
            rtMasterClockTime = m_rtLastMasterClockTime + m_pPin->m_Stats.m_rtLastBufferDur;
            
        m_rtLastMasterClockTime = rtMasterClockTime; // remember this, is this already saved somewhere else??
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to buffer fullness") ) );
    }                
    else if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_TIMESTAMPS )
    {
        // slave to incoming timestamps
   
        // start time for this sample
        rtMasterClockTime = rtStart;
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to input timestamps") ) );
    }
    else if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK )
    {
        // slave to external clock times
        HRESULT hr = m_pFilter->m_pClock->GetTime(&rtMasterClockTime);
        rtMasterClockTime -= m_pFilter->m_tStart;
        ASSERT(SUCCEEDED(hr));
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slaving to external clock times") ) );
    }
    else
        ASSERT( FALSE );
        
    return rtMasterClockTime;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::GetSlaveClockTime
//
// Get the current slave clock time by using the slave mode to determine how to read
// this time. 
//
//  slave mode                  slave time                  1st slave time
//  ---------------------------------------------------------------------------------
//  LIVEFULLNESS                wave device position        current device position
//                              including silence written   including silence
//
//  EXTERNALCLOCK_LIVE          same as LIVEFULLNESS
//                              (problems arise handling 
//                              silence gaps when using 
//                              audio clock generated from
//                              timestamps)
//                                      
//  EXTERNALCLOCK               audio clock generated from  timestamp of current
//                              timestamps                  sample to be played
//
//  LIVETIMESTAMPS              ?later
//  
//-----------------------------------------------------------------------------
REFERENCE_TIME CWaveSlave::GetSlaveClockTime
(
    REFERENCE_TIME rtStart, 
    BOOL bReset
)
{
    REFERENCE_TIME rtSlaveClockTime = 0;
    if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS )
    {
        // use bytes played as device clock position
        rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( TRUE );
        if( bReset )
        {   
            m_rtInitSlaveClockTime = rtSlaveClockTime;
            rtSlaveClockTime = 0;
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset, slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
        }            
        else
        {
            rtSlaveClockTime -= m_rtInitSlaveClockTime;
        }            
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects bytes played (including silence)") ) );
    }                
    else if( ( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_GRAPH_CLOCK ) &&
             ( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA   ) )
    {
        //
        // use bytes played as well in this case, since capture timestamps
        // tend to fluctuate enough to make using a clock generated from
        // timestamps less accurate. Also there are problems when silence gets
        // inserted into the stream (we notice silence added because of starvation, but
        // we don't notice when we're playing too fast).
        //
        // we're keeping this case separate from the buffer fullness case
        // (which is handled the same way), because we may want to reconsider whether 
        // to the clock generated from timestamps at a later time
        //
        if( bReset )
        {       
            m_bLiveButDataPrequeued = FALSE; // reset
        
            // make sure device position reflects any data already queued
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
            if ( ( 0 == m_pFilter->m_lBuffers ) && ( rtSlaveClockTime == 0 ) )
            {            
                //
                // Expected case for live data - i.e., no data was prequeued
                //
                // use this sample's rtStart as the starting device position
                //
                m_rtInitSlaveClockTime = rtSlaveClockTime - rtStart;
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset1, slave clock time %dms, InitSlaveClockTime %dms"),
                        (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
            }
            else
            {
                //
                // The abnormal case! Where an upstream filter marked itself as live (by
                // supporting IAMPushSource) but then went and delivered data in pause mode.
                // Unfortunately the wmp source filter does this and we'll try to work with it.
                //
                // So in this case rtSlaveClockTime reflects the starting time of any pre-Run data
                //
                m_rtInitSlaveClockTime = rtSlaveClockTime; 
                m_bLiveButDataPrequeued = TRUE;
            
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Reset2, slave clock time %dms, InitSlaveClockTime %dms"),
                        (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
                
            }                        
        }
        else if( !m_bLiveButDataPrequeued )
        {        
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( TRUE );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
            rtSlaveClockTime -= m_rtInitSlaveClockTime;
        }            
        else
        {
            //
            // Again, the exceptional case, where a live source sent data in pause (wmp)
            //
            rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock time %dms, InitSlaveClockTime %dms"),
                    (LONG)( rtSlaveClockTime / 10000 ), (LONG)( m_rtInitSlaveClockTime / 10000 ) ) );
        }        
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects bytes played (including silence)") ) );
    }
    else if( m_fdwSlaveMode & ( AM_AUDREND_SLAVEMODE_GRAPH_CLOCK | AM_AUDREND_SLAVEMODE_TIMESTAMPS ) )
    {
        // use the clock that we generate based on incoming timestamps
        
        // make sure device position reflects any data already queued
        rtSlaveClockTime = m_pFilter->m_pRefClock->ReadDevicePosition( );
        if( bReset && 
            ( 0 == m_pFilter->m_lBuffers ) && 
            ( rtSlaveClockTime == 0 ) )
        {            
            // if no data has been queued at all then use this tStart as 
            // the starting device position, since we haven't yet updated our
            // generated clock with this timestamp
            rtSlaveClockTime = rtStart; 
        }
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - slave clock reflects timestamp generated clock") ) );
    }
    else
        ASSERT( FALSE );
        
    return rtSlaveClockTime;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::AdjustSlaveClock
//
// Check the device clock progress against the master clock and determine if any
// adjustment is required. For the dsound renderer this attempts to match the
// device clock's rate to the master clock rate by varying the audio playback
// rate. In the waveOut renderer case, if the device gets too far behind we drop 
// samples to try to keep up.
// 
// Details about the frequency slaving algorithm, taken from the DirectShow PushClk spec:
//
// At a given time t we have 2 clocks:
//
// S(t) - the source clock
// R(t) - the renderer clock.
//
// For simplification of notation the time the clock shows is just the clock name.  
// We can use the differential operator to describe the current clock rate - eg D(R)(t).
// 
// The current algorithm applies a rate correction when the accumulated clock difference 
// reaches an adaptive threshold. The rate change is a fixed increment irrespective of 
// the relative clock rates:
// 
// Cumulative clock difference:  C(t) = (R(t) - S(t)) - (R(0) - S(0))
// High threshold:  H(t) (>= 0)
// Low threshold: L(t) (<= 0)
// Rate of R - D(R)
// If  C(t) < L(t) - adjustthreshold 
// then D(R) -= adjuststep, L(t) = C(t) 
// else L(t) *= errordecay
// Else if C(t) > H(t) + adjustthreshold 
// then D(R) += adjuststep, H(t) = C(t)
// else H(t) *= errordecay
//
// Example values are:
// adjustthreshold = .002 seconds
// adjuststep = 1/1000
// errordecay = .99
// L(0) = H(0) = 0
// 
// Note how the thresholds are adjusted to try and pull in the error over time but 
// relaxed when we step outside the current thresholds to avoid too rapid frequency 
// switching.
//
// Parameters:
//      const REFERENCE_TIME& tStart  - start time for current sample
//      LONG  *pcbData,               - size of current buffer, UPDATED to amount of
//                                      of buffer data to use (when data is to be 
//                                      dropped)
//      BOOL  bDiscontinuity          - does current sample have discontinuity bit set?
//  
// 
// Returns:
//      S_OK    - if no error. Note that pcbData may be updated if data is to be dropped.
//      S_FALSE - if entire buffer is to be dropped
//
//      error code, otherwise
//
// Arguments:
//    tStart
//    *pcbData, 
//    bDiscontinuity
//
//-----------------------------------------------------------------------------

HRESULT CWaveSlave::AdjustSlaveClock
( 
    const REFERENCE_TIME& tStart, 
    LONG  *pcbData,               
    BOOL  bDiscontinuity          
)
{
    ASSERT( m_fdwSlaveMode & ( AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS |
                               AM_AUDREND_SLAVEMODE_GRAPH_CLOCK    |
                               AM_AUDREND_SLAVEMODE_TIMESTAMPS ) );

    ASSERT( pcbData );
    
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    HRESULT hr = S_OK;
    
#ifdef DEBUG    
    if (m_pFilter->m_fDSound)
    {
        REFERENCE_TIME rtSilence = 0;
        // convert silence bytes to time
        if( 0 < (LONG) PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llSilencePlayed )
            rtSilence = BufferDuration( m_pPin->m_nAvgBytesPerSec, (DWORD) PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llSilencePlayed );
    
        DbgLog( (LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - Total silence written = %dms")
              , (LONG) (rtSilence/10000) ) );
    }              
#endif  
    if( bDiscontinuity )
    {   
        ResumeSlaving( FALSE );
        DbgLog( ( LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_DETAILS, TEXT("wo:Slaving - discontinuity seen") ) );
    }
    
    // get current slave clock time
    REFERENCE_TIME rtSlaveClockTime = GetSlaveClockTime( tStart, bDiscontinuity || m_bResumeSlaving );
     
    // get current master clock time        
    REFERENCE_TIME rtMasterClockTime = GetMasterClockTime( tStart, bDiscontinuity || m_bResumeSlaving );
    DbgLog( ( LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - master clock time %dms, slave time %dms")
          , (LONG)(rtMasterClockTime / 10000)
          , (LONG)(rtSlaveClockTime   / 10000) ) );
          
    if( rtSlaveClockTime < ( 1000 * ( UNITS / MILLISECONDS ) ) || 
        bDiscontinuity || 
        m_bResumeSlaving )
    {
        // initialize slaving parameters until the device makes some progress
        // 'some progress' is defined here as one seconds worth of data
        if( m_bResumeSlaving )
        {   
            // only initialize rate params if we're resuming or beginning
            // note that it may be better to not re-initialize the slave rate
            // on a resume, since we may have already locked in on a better one
            m_dwCurrentRate = pwfx->nSamplesPerSec;
            DWORD dwAdj = (DWORD)( m_dwCurrentRate * m_fltMaxAdjustFactor );
            m_dwMaxClockRate = m_dwCurrentRate + dwAdj ;
            m_dwMinClockRate = m_dwCurrentRate - dwAdj;

            // compute the step size to be used for frequency adjustments (Hz)
            m_dwClockStep = (DWORD)( m_dwCurrentRate * m_fltAdjustStepFactor );
            DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - Slave step size = %d Hz. ")
                  , m_dwClockStep ) );
        }
        
#ifdef CALCULATE_AUDBUFF_JITTER
        RecordBufferLateness( 0 );
#endif        
        m_bResumeSlaving = FALSE; // we're ready to go, turn off resume flag now
                                  // to slave on next sample

        m_rtLastMasterClockTime = rtMasterClockTime;
            
        // don't start adjusting until either the device has made some progress 
        // or we've finished preparing to resume slaving
        return S_OK;
    }     
    
#ifdef LOG_CLOCK_DELTAS
    // compute clock deltas since last buffer, useful for debugging
    REFERENCE_TIME rtMasterClockDelta = rtMasterClockTime - m_rtLastMasterClockTime;
    REFERENCE_TIME rtSlaveClockDelta = rtSlaveClockTime - m_rtLastSlaveClockTime; 
    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - Slave Clock change = %dms, Master Clock change = %dms"), 
        (LONG)(rtSlaveClockDelta / 10000),
        (LONG)(rtMasterClockDelta/10000) ) );
        
    m_rtLastSlaveClockTime = rtSlaveClockTime;
#endif

    // now get the difference between the 2 clocks
    m_rtErrorAccum = rtMasterClockTime - rtSlaveClockTime;
    if( !m_pFilter->m_fDSound )
    { 
        // if this is waveOut and we're slaving via dropping then advance 
        // the slave clock by the amount of audio we've dropped
        m_rtErrorAccum -= m_rtDroppedBufferDuration;
    }   
    
    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - m_llAccumError = %dms, High Error = %dms, Low Error = %dms"), 
        (LONG)(m_rtErrorAccum / 10000), 
        (LONG)(m_rtLastHighErrorSeen / 10000),
        (LONG)(m_rtLastLowErrorSeen / 10000) ) );
    
#ifdef CALCULATE_AUDBUFF_JITTER 
    // warning: we may need this, so don't throw away just yet
    hr = RecordBufferLateness( rtMasterClockDelta );
    if( S_FALSE == hr )
    {
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
              , TEXT( "wo:Slaving - buffer is too late or early to use for adjustments" ) ) );
    
        hr = S_OK; // don't act on this buffer, it's way too early or late to use
    }
    else 
#endif    

    if( m_pFilter->m_fDSound )
    {
        // For DSound renderer slave via rate matching
        if( m_rtLastLowErrorSeen - m_rtErrorAccum >= m_rtAdjustThreshold )
        {
            m_rtLastLowErrorSeen = m_rtErrorAccum;
            if( m_rtLastLowErrorSeen < m_rtLowestErrorSeen )
                m_rtLowestErrorSeen = m_rtLastLowErrorSeen;

            m_rtLastHighErrorSeen = 0;
        
            // device is ahead of external clock, slow it down
            if( m_dwCurrentRate > m_dwMinClockRate )
            {
                m_dwCurrentRate -= (LONG) m_dwClockStep;
                        
                DbgLog((LOG_TRACE, 2, TEXT("wo:Slaving - Error is %dms. Decreasing clock rate to = %d")
                      , (LONG)(m_rtErrorAccum / 10000)
                      , (LONG)(m_dwCurrentRate) ) );
              
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(1, m_dwCurrentRate);
            }      
            else
            {
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - clock rate already at minimum of %d, but error is %d!")
                      , (LONG)(m_dwCurrentRate)
                      , (LONG)(m_rtErrorAccum / 10000) ) );
            } 
        }      
        else if( m_rtErrorAccum - m_rtLastHighErrorSeen >= m_rtAdjustThreshold )
        {
            m_rtLastHighErrorSeen = m_rtErrorAccum;
            if( m_rtLastHighErrorSeen > m_rtHighestErrorSeen )
                m_rtHighestErrorSeen = m_rtLastHighErrorSeen;

            m_rtLastLowErrorSeen = 0;
        
            // the device is behind, speed it up
            if( m_dwCurrentRate < m_dwMaxClockRate )
            {
                m_dwCurrentRate += (LONG) m_dwClockStep;
            
                DbgLog((LOG_TRACE, 2, TEXT("wo:Slaving - Error is %d ms. Increasing clock rate to = %d")
                      , (LONG)(m_rtErrorAccum / 10000)
                      , (LONG)(m_dwCurrentRate) ) );
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(1, m_dwCurrentRate);
            }            
            else
            {
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving - clock rate already at maximum of %d, but error is %d")
                      , (LONG)(m_dwCurrentRate)
                      , (LONG)(m_rtErrorAccum / 10000) ) );
            }            
        }
        else if( m_rtLastHighErrorSeen > 0 )
        {
            m_rtLastHighErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastHighErrorSeen );
        }
        else if( m_rtLastLowErrorSeen < 0 )
        {
            m_rtLastLowErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastLowErrorSeen );
        }       
    } // end dsound slaving path
    else 
    {
        ASSERT( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA );
        //
        // Note: waveOut slaving is only supported for live graphs.
        //
        // For waveOut we only attempt to handle the case where we're running too slowly relative to the
        // graph clock, since in the worst case, sync will drift 'out' to the maximum bufferring used. That's 
        // a problem for live graphs that need low latency. The opposite problem of sync drifting too far 'in'
        // is not a big problem for live graphs, unless a large latency is desired (which is rarely the case
        // for live graphs).
        //
        // One problem is that in some scenarios the case where we're running too FAST relative to the graph
        // clock can look a lot like the case where we're too slow, since we don't try to account for silence 
        // gaps. To avoid falling into our data dropping path when we're really running too quickly we add an 
        // additional check to make sure we really have written more actual bytes to the device then we've played. 
        // The additional complication is that I've noticed when we're being sourced by some legacy capture devices 
        // our playback clock position doesn't match the bytes that we've queued, EVEN though we're running way too 
        // fast. So the m_rtWaveOutLatencyThreshold check was added to avoid dropping data when we shouldn't be.
        // Note that I didn't notice this problem when the source was a WDM capture device (??).
        //
        
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_DETAILS
              , TEXT( "wo:Slaving : m_rtDroppedBufferDuration: %dms" )
              , (LONG) ( m_rtDroppedBufferDuration / 10000 ) ) );
        
        LONGLONG llTruncBufferDur = BufferDuration(m_pPin->m_nAvgBytesPerSec, *pcbData);
        m_rtDroppedBufferDuration += ( m_pPin->m_Stats.m_rtLastBufferDur - llTruncBufferDur );
        
        //
        // use time since last buffer to determine how much of the last buffer queued to the device
        // we should expect the device to have played
        //
        REFERENCE_TIME rtSinceLastBuffer = rtMasterClockTime - m_rtLastMasterClockTime;
        
        //
        // GetBytesPlayed() gives us the amount of data written to the device before we wrote
        // the previous buffer. GetBytesInLastWrite() tells us how big that last buffer was.
        //
        LONGLONG llPredictedBytesPlayed  = m_pFilter->m_pRefClock->GetBytesProcessed() + 
                                           min( (LONGLONG) m_pFilter->m_pRefClock->GetBytesInLastWrite(), 
                                                (LONGLONG) ( m_pPin->m_nAvgBytesPerSec * rtSinceLastBuffer ) / UNITS );
        LONGLONG llActualBytesPlayed     = m_pFilter->m_pRefClock->GetBytesPlayed();
        
        //        
        // this is how many written bytes we've yet to play        
        //
        REFERENCE_TIME rtBytesWrittenNotPlayed = BufferDuration( m_pPin->m_nAvgBytesPerSec,
                                                                 (LONG) (llPredictedBytesPlayed - llActualBytesPlayed ) );
    
        DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, TEXT("wo:Slaving : rtBytesWrittenNotPlayed = %dms")
              , (LONG)( rtBytesWrittenNotPlayed / 10000 ) ) );
    
        // 
        // now use the 2 thresholds to decide if we need to drop any data
        //    
        if( ( m_rtErrorAccum > m_rtAdjustThreshold ) &&
            ( rtBytesWrittenNotPlayed > m_rtWaveOutLatencyThreshold ) )
        {
            m_rtLastHighErrorSeen = m_rtErrorAccum;
            if( m_rtLastHighErrorSeen > m_rtHighestErrorSeen )
                m_rtHighestErrorSeen = m_rtLastHighErrorSeen;

            m_rtLastLowErrorSeen = 0;
            
            DbgLog( ( LOG_TRACE
                  , DBG_LEVEL_CLOCK_SYNC_DETAILS
                  , "Too far behind. Need to truncate or drop...") );
        
            if( m_rtErrorAccum >= m_pPin->m_Stats.m_rtLastBufferDur )
            {
                // drop the whole buffer
                m_rtDroppedBufferDuration += m_pPin->m_Stats.m_rtLastBufferDur;
                DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, "***WAY behind...Dropping the whole buffer"));
                *pcbData = 0;
            }
            else
            {
                // else consider truncating...
                // first convert to bytes and gauge if this makes sense
                LONG lTruncBytes = (LONG) ( ( (m_rtErrorAccum/10000) * m_pPin->m_nAvgBytesPerSec ) /1000 ) ; 

                //  round up to block align boundary
                LONG lRoundedUpTruncBytes = lTruncBytes;
                if (pwfx->nBlockAlign > 1) {
                    lRoundedUpTruncBytes += pwfx->nBlockAlign - 1;
                    lRoundedUpTruncBytes -= lRoundedUpTruncBytes % pwfx->nBlockAlign;
                }
            
                if( lRoundedUpTruncBytes < *pcbData )
                {
                    // lets truncate
#ifdef DEBUG                        
                    LONG lOriginalLength = *pcbData;
#endif                    
                    *pcbData -= lRoundedUpTruncBytes ;
                    DbgLog( (LOG_TRACE
                          , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
                          , TEXT( "***Truncating %ld bytes of %ld byte buffer (%ld left)" )
                          , lRoundedUpTruncBytes
                          , lOriginalLength
                          , *pcbData ) );
                  
                    LONGLONG llTruncBufferDur = BufferDuration(m_pPin->m_nAvgBytesPerSec, *pcbData);
                    m_rtDroppedBufferDuration += ( m_pPin->m_Stats.m_rtLastBufferDur - llTruncBufferDur );
                }
                else
                {
                    m_rtDroppedBufferDuration += m_pPin->m_Stats.m_rtLastBufferDur;
                    DbgLog((LOG_TRACE, DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS, "***Considered truncating but dropping the whole buffer"));
                    *pcbData = 0;
                }                                                            
            }
        }
        else if( m_rtErrorAccum < -m_rtAdjustThreshold )
        {
            m_rtLastLowErrorSeen = m_rtErrorAccum;
            if( m_rtLastLowErrorSeen < m_rtLowestErrorSeen )
                m_rtLowestErrorSeen = m_rtLastLowErrorSeen;

            m_rtLastHighErrorSeen = 0;
            
            DbgLog( ( LOG_TRACE
                  , DBG_LEVEL_CLOCK_SYNC_DETAILS
                  , "waveOut clock is running fast relative to graph clock...") );
        }   
        else if( m_rtLastHighErrorSeen > 0 )
        {
            m_rtLastHighErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastHighErrorSeen );
        }
        else if( m_rtLastLowErrorSeen < 0 )
        {
            m_rtLastLowErrorSeen = (LONGLONG)( m_fltErrorDecayFactor * m_rtLastLowErrorSeen );
        }       
             
    } // end waveOut slaving path   

    // save the current time
    m_rtLastMasterClockTime = rtMasterClockTime;
     
    return hr;
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::ResumeSlaving
//
// Reset slaving parameters
// Prepare to pick up slaving where we left off, not necessarily from a clean start,
// so save running results.
// Combine this with Reset instead?? keeping separate for now, for clarity
//
// Parameters:
//      BOOL bReset - If TRUE then all parameters will be reset. Used when initializing
//                    the slave structure and when transitioning to Pause from a Stopped 
//                    state.
//
//                    If FALSE then it is assumed that we're picking up slaving from 
//                    an already Running state, in which case we'd like to save slaving 
//                    parameters that we may have already zeroed in on, like the slave 
//                    rate. FALSE is used when:
//                          resuming slaving after seeing a discontinuity
//                          resuming slaving after dropping silence in live stream
// 
//-----------------------------------------------------------------------------
void CWaveSlave::ResumeSlaving( BOOL bReset )
{
    // first reset paramaters that apply to either a full reset 
    // or a slaving resume
    m_rtLastMasterClockTime = 0;
    m_rtErrorAccum = 0;
    m_rtLastHighErrorSeen = 0;
    m_rtLastLowErrorSeen = 0;
    
    // reset dropped buffer duration for the waveOut slaving case
    m_rtDroppedBufferDuration = 0;
    
    if( bReset )
    {    
        m_bLiveButDataPrequeued = FALSE;
        
        
        m_bResumeSlaving = TRUE;
        
        // we're starting from scratch so reset everything else as well
        m_rtDroppedBufferDuration  = 0;  
        m_dwMinClockRate = 0;
        m_dwMaxClockRate = 0;
        m_dwClockStep = 0; 

        m_dwCurrentRate = 0;
        m_fdwSlaveMode = 0;
        m_rtHighestErrorSeen = 0;
        m_rtLowestErrorSeen = 0;

        m_bRefreshMode   = TRUE;

#ifdef LOG_CLOCK_DELTAS
        m_rtLastSlaveClockTime = 0;
#endif
        
#ifdef CALCULATE_AUDBUFF_JITTER
        // for jitter calc
        m_cBuffersReceived = 0;
        m_iTotAcc = 0;
        m_iSumSqAcc = 0;
        m_rtLastSysTimeBufferTime = 0;
#endif
    }
}

//-----------------------------------------------------------------------------
//
// CWaveSlave::RefreshModeOnNextSample
//
// Set flag to indicate that we need to update our slaving mode on reception
// of next sample. This will require a rescan on the upstream filter chain
// for an IAMPushSource filter.
//
//-----------------------------------------------------------------------------
void CWaveSlave::RefreshModeOnNextSample( BOOL bRefresh )
{
    m_bRefreshMode = bRefresh;
}


//-----------------------------------------------------------------------------
//
// CWaveSlave::UpdateSlaveMode - determine if we've entered a new slaving mode 
//                               returns TRUE if we're slaving, FALSE if not
//
//-----------------------------------------------------------------------------
BOOL CWaveSlave::UpdateSlaveMode( BOOL bSync )
{
    // only slave when we're running with a clock
    if( m_pFilter->m_fFilterClock == WAVE_NOCLOCK )
        return FALSE;
        
    BOOL bSlaving = FALSE;    
    if( m_bRefreshMode )
    {
        ULONG ulPushSourceFlags = 0 ;
        RefreshModeOnNextSample( FALSE );
        
        m_fdwSlaveMode = 0;
        //
        // Determine if we're being sourced by a 'live' data source
        // To do this we check if there's an upstream source filter which supports IAMPushSource
        //
        ASSERT( m_pFilter->m_pGraph );
        ASSERT( m_pFilter->m_pGraphStreams );
        
        if( m_pFilter->m_pGraphStreams )
        {        
            IAMPushSource *pPushSource = NULL;
            HRESULT hr = m_pFilter->m_pGraphStreams->FindUpstreamInterface( m_pPin
                                               , IID_IAMPushSource
                                               , (void **) &pPushSource
                                               , AM_INTF_SEARCH_OUTPUT_PIN ); 
            if( SUCCEEDED( hr ) )
            {
            
                hr = pPushSource->GetPushSourceFlags(&ulPushSourceFlags);
                ASSERT( SUCCEEDED( hr ) );
                if( SUCCEEDED( hr ) )
                {
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found push source (ulPushSourceFlags = 0x%08lx)")
                          , ulPushSourceFlags ) );
                    if( 0 == ( AM_PUSHSOURCECAPS_NOT_LIVE & ulPushSourceFlags ) )
                    {
                        // yes, this is live data so turn on the bit
                        m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_LIVE_DATA;
                    }                    
                }
                pPushSource->Release();         
            }
            else
            {
                // workaround for live graphs where the audio capture pin doesn't yet
                // support IAMPushSource
                IKsPropertySet * pKs;
                hr = m_pFilter->m_pGraphStreams->FindUpstreamInterface( m_pPin
                                               , IID_IKsPropertySet
                                               , (void **) &pKs
                                               , AM_INTF_SEARCH_OUTPUT_PIN ); // search output pins
                // this will only find the first one so beware!!
                if( SUCCEEDED( hr ) )             
                {   
                    GUID guidCategory;
                    DWORD dw;
                    hr = pKs->Get( AMPROPSETID_Pin
                                 , AMPROPERTY_PIN_CATEGORY
                                 , NULL
                                 , 0
                                 , &guidCategory
                                 , sizeof(GUID)
                                 , &dw );
                    if( SUCCEEDED( hr ) )                         
                    {
                        DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found IKsPropertySet pin. Checking pin category...")
                              , ulPushSourceFlags ) );
                        if( guidCategory == PIN_CATEGORY_CAPTURE )
                        {
                        
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Found capture pin even though no IAMPushSource support") ) );

                            // live data, turn on the bit
                            m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_LIVE_DATA;
                        } 
                        else
                        {
                            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - not a capture filter")
                                  , ulPushSourceFlags ) );
                        }                       
                    }                    
                    pKs->Release();
                }                
            }
        }            
        
#ifdef TEST_MODE
        // use to test various sources
        ulPushSourceFlags = (BOOL) GetProfileIntA("PushSource", "Flags", ulPushSourceFlags);
#endif        
        //
        // Finish setting our internal slave mode state, using push source, timestamp,
        // and clock information.
        //
        if( AM_PUSHSOURCECAPS_INTERNAL_RM & ulPushSourceFlags )
        {
            // source does its own rate matching so don't try to slave to it
            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Source provides its own rate matching support. Slaving disabled.") ) );
        }
        else if( AM_AUDREND_SLAVEMODE_LIVE_DATA & m_fdwSlaveMode )
        {        
            if( ( AM_PUSHSOURCECAPS_PRIVATE_CLOCK & ulPushSourceFlags ) && bSync )
            {
                //
                // source data is timestamped to a internal clock that
                // we don't have access to, so the best we can do is to
                // slave to the input timestamps. we do this regardless of
                // who the clock is.
                //
                DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer slaving to timestamps of live source with its own clock") ) );
                m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_TIMESTAMPS;
                bSlaving = TRUE;
            }                
            else if( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK ) 
            {
                // we're not the not clock, now decide what to slave to
                if( AM_PUSHSOURCEREQS_USE_STREAM_CLOCK & ulPushSourceFlags ) // does bSync state matter?
                {
                    // 
                    // here we'd query the push source for it's clock via GetSyncSource
                    // and slave to that
                    //
                    //
                    // LATER...
                    //                    
                    ASSERT( FALSE );
                }
                else if( bSync )
                {                    
                    // live graph and slave to graph clock
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to graph clock with live source") ) );
                    m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_GRAPH_CLOCK;
                    bSlaving = TRUE;
        
                }        
                else 
                {
                    // no timestamps so slave to buffer fullness
                    DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to buffer fullness of live source") ) );
                    m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS;
                    bSlaving = TRUE;
                }
            }                                
            else 
            {
                // else data is live and we're the clock, so we're forced to slave to buffer fullness
                DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer is slaving to buffer fullness of live source") ) );
                m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS;
                bSlaving = TRUE;
            }
        }                    
        else if( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK && m_pFilter->m_fDSound )
        {
            //
            // slave to graph clock (source data isn't 'live')
            //
            // non-live slaving is NOT supported for the waveOut path
            //
            DbgLog( ( LOG_TRACE, 3, TEXT("wo:Slaving - Audio renderer slaving to external clock") ) );
            m_fdwSlaveMode |= AM_AUDREND_SLAVEMODE_GRAPH_CLOCK;
            bSlaving = TRUE;
        }
        // else we're not slaving 
        
    } // end refresh slaving settings
    else 
        bSlaving = ( 0 == m_fdwSlaveMode ) ? FALSE : TRUE;
        
    return bSlaving;
}


#ifdef CALCULATE_AUDBUFF_JITTER

extern int isqrt(int x); // defined in renbase.cpp

// if buffer is earlier or later than this, don't use it for clock adjustments
// !NOTE: Make this a value proportional to the buffer duration, i.e. like .8 * duration?
static const LONGLONG  BUFFER_TIMELINESS_TOLERANCE = (40 * (UNITS / MILLISECONDS));

//-----------------------------------------------------------------------------
//
// CWaveSlave::RecordBufferLateness
//
// update stats on how timely buffers arrive, use it to calculate the jitter 
//
// update the statistics:
// m_iTotAcc, m_iSumSqAcc, m_iSumSq (buffer time), m_cBuffersReceived
//
//-----------------------------------------------------------------------------
HRESULT CWaveSlave::RecordBufferLateness(REFERENCE_TIME rtBufferDiff)
{
    HRESULT hr = S_OK;
    int trLate = 0;
    
    // Record how timely input buffers arrive and update jitter calculation
    REFERENCE_TIME rtCurrent = (REFERENCE_TIME)10000 * timeGetTime();
    if( !m_bResumeSlaving )
    {
        REFERENCE_TIME rtSysTimeBufferDiff = rtCurrent - m_rtLastSysTimeBufferTime;
        REFERENCE_TIME rtBufferLateness = rtBufferDiff - rtSysTimeBufferDiff;
    
        DbgLog( (LOG_TRACE
              , DBG_LEVEL_CLOCK_SYNC_DETAILS
              , TEXT( "wo:Slaving - timeGetTime buffer diff: %dms, BufferLateness: %dms" )
              , (LONG)(rtSysTimeBufferDiff/10000)
              , (LONG)(rtBufferLateness/10000) ) );
    
        trLate = (int) (rtBufferLateness/10000);
        
        // ignore 1st buffer 
        if ( m_cBuffersReceived>1 ) 
        {
        	m_iTotAcc += trLate;
	        m_iSumSqAcc += (trLate*trLate);
            
            // when slaving to buffer fullness don't try to slave to
            // buffers which are delivered unreasonably late or early.            
            if( m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS &&
                ( rtBufferLateness > BUFFER_TIMELINESS_TOLERANCE ||
                rtBufferLateness < -BUFFER_TIMELINESS_TOLERANCE ) )
            {
                DbgLog( (LOG_TRACE
                      , DBG_LEVEL_CLOCK_SYNC_ADJUSTMENTS
                      , TEXT( "wo:Slaving - Ignoring too late or early buffer" )
                      , (LONG)(rtSysTimeBufferDiff/10000)
                      , (LONG)(rtBufferLateness/10000) ) );
                hr = S_FALSE;
            }           
        }            
    }
    m_rtLastSysTimeBufferTime = rtCurrent;
    ++m_cBuffersReceived;
    
    return hr;
    
} // RecordBufferLateness

//-----------------------------------------------------------------------------
//
//  Do estimates for standard deviations for per-buffer
//  statistics. Code taken from renbase.cpp.
//
//-----------------------------------------------------------------------------
HRESULT GetStdDev(
    int nBuffers,
    int *piResult,
    LONGLONG llSumSq,
    LONGLONG iTot
)
{
    CheckPointer(piResult,E_POINTER);

    // If S is the Sum of the Squares of observations and
    //    T the Total (i.e. sum) of the observations and there were
    //    N observations, then an estimate of the standard deviation is
    //      sqrt( (S - T**2/N) / (N-1) )

    if (nBuffers<=1) {
	*piResult = 0;
    } else {
	LONGLONG x;
	// First frames have bogus stamps, so we get no stats for them
	// So we need 2 frames to get 1 datum, so N is cFramesDrawn-1

	// so we use m_cFramesDrawn-1 here
	x = llSumSq - llMulDiv(iTot, iTot, nBuffers, 0);
	x = x / (nBuffers-1);
	ASSERT(x>=0);
	*piResult = isqrt((LONG)x);
    }
    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\sounddev.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// declars a virtual CSoundDevice class that will abstract the sound device.
// The actual implementation will be based on CWaveOutDevice or CDSoundDevice
//-----------------------------------------------------------------------------

#ifndef _CSOUNDDEVICE_H_
#define _CSOUNDDEVICE_H_

class AM_NOVTABLE CSoundDevice
{

public:
    virtual MMRESULT amsndOutClose () PURE ;
    virtual MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) PURE ;
    virtual MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) PURE ;
    virtual MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos) PURE ;

    // pnAvgBytesPerSec: can be null. should be filled with the actual
    // # of bytes per second at which data is consumed otherwise (see
    // amsndOutGetPosition) .
    virtual MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx ,
				   double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				   DWORD_PTR dwCallBackInstance, DWORD fdwOpen) PURE ;
    virtual MMRESULT amsndOutPause () PURE ;
    virtual MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) PURE ;
    virtual MMRESULT amsndOutReset () PURE ;
    virtual MMRESULT amsndOutBreak () PURE ;
    virtual MMRESULT amsndOutRestart () PURE ;
    virtual MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) PURE ;
    virtual MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) PURE ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    virtual HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate) PURE;
    virtual void     amsndOutGetFormat (CMediaType *pmt)
    {
        pmt->SetType(&MEDIATYPE_Audio);
    }
    virtual LPCWSTR  amsndOutGetResourceName () PURE ;
    virtual HRESULT  amsndOutGetBalance (LPLONG plBalance) PURE ;
    virtual HRESULT  amsndOutGetVolume (LPLONG plVolume) PURE ;
    virtual HRESULT  amsndOutSetBalance (LONG lVolume) PURE ;
    virtual HRESULT  amsndOutSetVolume (LONG lVolume) PURE ;

    virtual HRESULT  amsndOutLoad (IPropertyBag *pPropBag) { return S_OK; }

    virtual HRESULT amsndOutWriteToStream(IStream *pStream) { return E_NOTIMPL; }
    virtual HRESULT amsndOutReadFromStream(IStream *pStream)  { return E_NOTIMPL; }
    virtual int     amsndOutSizeMax()  { return E_NOTIMPL; }
    virtual bool    amsndOutCanDynaReconnect() { return true ; }

    // Let the underlying device stuff silence if it can
    // It is given the length of time it should insert silence.
    // This silence may be deferred by the device until the next amsndOutWrite
    // The device is allowed to NOT support silence stuffing
    //
    // Return: S_OK - I have written the silence
    //		S_FALSE - I cannot, you must
    // virtual HRESULT  amsndOutSilence   (LONGLONG llTime) { return S_FALSE; };
    // NOT YET

    virtual ~CSoundDevice () {} ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\wave.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CWaveOutDevice class based on waveOut APIs.
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// Includes.
//-----------------------------------------------------------------------------
#include <streams.h>
#define _AMOVIE_DB_
#include <decibels.h>
#include "waveout.h"
#include "wave.h"
#include <limits.h>
#include <mmreg.h>

//
// Define the dynamic setup structure for filter registration.  This is
// passed when instantiating an audio renderer in its waveout guise.
// Note: waveOutOpPin is common to direct sound and waveout renderers.
//

// marked MERIT_DO_NOT_USE because we don't want RenderFile to try
// this filter in an upgrade over AM 1.0; we want it to use the audio
// renderer category.
AMOVIESETUP_FILTER wavFilter = { &CLSID_AudioRender	// filter class id
                                 , L"Audio Renderer"	// filter name
                                 , MERIT_DO_NOT_USE  	// dwMerit
                                 , 1
                                 , &waveOutOpPin };


//-----------------------------------------------------------------------------
// CreateInstance for the WaveOutDevice. This will create a new WaveOutDevice
// and a new CWaveOutFilter, passing it the sound device.
//-----------------------------------------------------------------------------
CUnknown *CWaveOutDevice::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    // make sure that there is at least one audio card in the system. Fail
    // the create instance if not.
    if (0 == waveOutGetNumDevs ())
    {
        *phr = VFW_E_NO_AUDIO_HARDWARE ;
        return NULL ;
    }

    return CreateRendererInstance<CWaveOutDevice>(pUnk, &wavFilter, phr);
}

//-----------------------------------------------------------------------------
// CWaveOutDevice constructor.
//-----------------------------------------------------------------------------
CWaveOutDevice::CWaveOutDevice ()
    : m_lVolume ( 0 )
    , m_lBalance ( 0 )
    , m_wLeft ( 0xFFFF )
    , m_wRight ( 0xFFFF )
    , m_dwWaveVolume ( 0 )
    , m_fHasVolume ( 0 )
    , m_hWaveDevice ( 0 )
	, m_fBalanceSet ( FALSE )
    , m_iWaveOutId ( WAVE_MAPPER )
{
    SetResourceName();
}

//-----------------------------------------------------------------------------
// CWaveOutDevice destructor.
//
//-----------------------------------------------------------------------------
CWaveOutDevice::~CWaveOutDevice ()
{
}

//-----------------------------------------------------------------------------
// waveOutClose.
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutClose ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Called to close when not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveOutClose - device is not open")));
        return MMSYSERR_ERROR ;
    }

    MMRESULT mmr = ::waveOutClose (m_hWaveDevice) ;
    m_hWaveDevice = 0;
    return mmr;
}
//-----------------------------------------------------------------------------
// waveOutDoesRSMgmt.
//-----------------------------------------------------------------------------
LPCWSTR CWaveOutDevice::amsndOutGetResourceName ()
{
    return m_wszResourceName;
}
//-----------------------------------------------------------------------------
// waveGetDevCaps
//
//-----------------------------------------------------------------------------

BOOL fGetCaps = TRUE;
WAVEOUTCAPS caps1;
WAVEOUTCAPS caps2;

MMRESULT CWaveOutDevice::amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc)
{
    if (fGetCaps) {
	fGetCaps = FALSE;
	::waveOutGetDevCaps (m_iWaveOutId, &caps1, sizeof(caps1)) ;
	::waveOutGetDevCaps (0, &caps2, sizeof(caps2)) ;
    }
    MMRESULT mmr = ::waveOutGetDevCaps (m_iWaveOutId, pwoc, cbwoc) ;
    if (0 == mmr )
    {
        //save volume capabilities
        m_fHasVolume = pwoc->dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
    }
    return mmr ;
}

//-----------------------------------------------------------------------------
// waveOutGetErrorText
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText)
{
    return ::waveOutGetErrorText (mmrE, pszText, cchText) ;
}

//-----------------------------------------------------------------------------
// waveOutGetPosition
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseUnadjustedPos)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetPosition - device is not open")));
        return MMSYSERR_NODRIVER ;
    }

    const MMRESULT mmr = ::waveOutGetPosition (m_hWaveDevice, pmmt, cbmmt) ;
    if (MMSYSERR_NOERROR != mmr) {
        DbgLog((LOG_ERROR,0,TEXT("waveoutGetPosition - FAILED")));
        DbgBreak("Failed to get the device position.");
    }
    return mmr;
}

//-----------------------------------------------------------------------------
// waveOutGetBalance
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutGetBalance (LPLONG plBalance)
{
    // some validation.
#if 0 // use the mixer
    if (m_hWaveDevice == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetBalance - device is not open")));
	*plBalance = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
    *plBalance = m_lBalance;
    return hr ;
}

//-----------------------------------------------------------------------------
// waveOutGetVolume
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutGetVolume (LPLONG plVolume)
{
    // some validation.
#if 0 // use the mixer
    if (m_hWaveDevice == 0)
    {
        DbgLog((LOG_ERROR,2,TEXT("waveoutGetVolume - device is not open")));
	*plVolume = 0;
        return MMSYSERR_NODRIVER ;
    }
#endif
    HRESULT hr = GetVolume();
    *plVolume = m_lVolume;
    return hr ;
}

HRESULT CWaveOutDevice::amsndOutCheckFormat(const CMediaType *pmt, double dRate)
{
    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Audio) {
	return E_INVALIDARG;
    }

    // if it's MPEG audio, we want it without packet headers.
    if (pmt->subtype == MEDIASUBTYPE_MPEG1Packet) {
	return E_INVALIDARG;
    }

    if (pmt->formattype != FORMAT_WaveFormatEx &&
        pmt->formattype != GUID_NULL) {
        return E_INVALIDARG;
    }

    //
    // it would always be safer to explicitly check for those formats
    // we support rather than tossing out the ones we know are not
    // supported.  Otherwise, if a new format comes along we could
    // accept it here but barf later.
    //

    if (pmt->FormatLength() < sizeof(PCMWAVEFORMAT))
	return E_INVALIDARG;

    // adjust based on rate that has been chosen, or don't bother?
    UINT err = amsndOutOpen(
        NULL,
        (WAVEFORMATEX *) pmt->Format(),
        dRate,
        0,                      // pnAvgBytesPerSec
        0,                      // dwCallback
        0,                      // dwCallBackInstance
        WAVE_FORMAT_QUERY);

    if (err != 0) {
#ifdef DEBUG
	TCHAR message[100];
	waveOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
	DbgLog((LOG_ERROR,1,TEXT("Error checking wave format: %u : %s"), err, message));
#endif
	if (WAVERR_BADFORMAT == err) {
	    return VFW_E_UNSUPPORTED_AUDIO;
	} else {
	    return VFW_E_NO_AUDIO_HARDWARE;
	}

    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// waveOutOpen
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
				       double dRate, DWORD *pnAvgBytesPerSec, DWORD_PTR dwCallBack,
				       DWORD_PTR dwCallBackInstance, DWORD fdwOpen)
{
    WAVEFORMATEX wfxPCM;
    
#ifdef TEST_SLOWFAST_WAVEOUT_RATES
    // for testing only
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }

    double dAdjust = GetProfileIntA("wave", "Percent", 0) / 100.;
    if( 1 == GetProfileIntA("wave", "Slower", 0) )
        dAdjust *= -1;
        
    dRate = 1.0 + dAdjust;
#endif
    
    if (dRate != 1.0)
    {
	if (!(pwfx->wFormatTag == WAVE_FORMAT_PCM || 
	      pwfx->wFormatTag == WAVE_FORMAT_MULAW || 
	      pwfx->wFormatTag == WAVE_FORMAT_ALAW)) 
		return WAVERR_BADFORMAT;

	DbgLog((LOG_TRACE,1,TEXT("Waveout: Playing at %d%% of normal speed"), (int) (dRate * 100) ));
	wfxPCM = *pwfx;
	pwfx = &wfxPCM;

	const double dSamplesPerSecond = wfxPCM.nSamplesPerSec * dRate;
	if (dSamplesPerSecond / wfxPCM.nBlockAlign > ULONG_MAX - 1) return WAVERR_BADFORMAT;
	wfxPCM.nSamplesPerSec = (DWORD) dSamplesPerSecond;
	//  Make sure it's exactly right for PCM or it won't work
	wfxPCM.nAvgBytesPerSec = wfxPCM.nSamplesPerSec * wfxPCM.nBlockAlign;
    }
    
#ifndef TEST_SLOWFAST_WAVEOUT_RATES
    // always do this except when testing with different rates

    // report adjusted nAvgBytesPerSec
    if(pnAvgBytesPerSec) {
        *pnAvgBytesPerSec = pwfx->nAvgBytesPerSec;
    }
#endif    

    // some validation.  If the device is already open we have an error,
    // with the exception that QUERY calls are permitted.

#if 0
!! We do not use WAVE_FORMAT_DIRECT at present.  More work is required.
!! The problem manifests itself with 8 bit sound cards, and uncompressed
!! 16 bit PCM data.  The ACM wrapper gets inserted but does NOT get around
!! to proposing an 8 bit format.

	// use WAVE_FORMAT_DIRECT to make use of the ACM mapper explicit
	// if we are on a level of the OS that supports that flag
        if (g_osInfo.dwMajorVersion >= 4) {
            fdwOpen |= WAVE_FORMAT_DIRECT;
        }
#endif
    
    if (!(fdwOpen & WAVE_FORMAT_QUERY) && (m_hWaveDevice != 0))
    {
        DbgBreak("Invalid - device ALREADY open - logic error");
        DbgLog((LOG_ERROR,1,TEXT("waveoutOpen - device is already open")));
        return MMSYSERR_ERROR ;
    }


    MMRESULT mmr =
           ::waveOutOpen (phwo, m_iWaveOutId, pwfx, dwCallBack, dwCallBackInstance, fdwOpen) ;

    if (MMSYSERR_NOERROR == mmr && phwo && !(fdwOpen & WAVE_FORMAT_QUERY)) {
        m_hWaveDevice = *phwo;
    }

    return mmr;
}
//-----------------------------------------------------------------------------
// waveOutPause
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutPause ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutPause - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutPause (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutPrepareHeader
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutPrepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutPrepareHeader (m_hWaveDevice, pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// waveOutReset
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutReset ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutReset - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutReset (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutBreak
//
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutBreak ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutBreak - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutReset (m_hWaveDevice) ;
}

//-----------------------------------------------------------------------------
// waveOutRestart
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutRestart ()
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutRestart - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutRestart (m_hWaveDevice) ;
}
//-----------------------------------------------------------------------------
// waveOutSetBalance
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutSetBalance (LONG lBalance)
{
    HRESULT hr ;
    if (lBalance == m_lBalance)
    {
	hr = NOERROR;  // no change
    }
    else
    {
	// Save the new setting
	m_lBalance = lBalance;
	m_fBalanceSet = TRUE;
	// go and calculate the channel attenuation
	SetBalance();
	hr = PutVolume(); // Talks to the device... if it is open
    }
    return hr;
}
//-----------------------------------------------------------------------------
// waveOutSetVolume
//
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::amsndOutSetVolume (LONG lVolume)
{
    // map volume onto decibel range
    DWORD dwAmp = DBToAmpFactor( lVolume );
    m_lVolume = lVolume;

    // now that the absolute volume has been set we should adjust
    // the balance to maintain the same DB separation
    SetBalance ();
    return PutVolume (); // Talks to the device... if it is open
}
//-----------------------------------------------------------------------------
// waveOutUnprepareHeader
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutUnprepareHeader - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutUnprepareHeader (m_hWaveDevice, pwh, cbwh) ;
}

//-----------------------------------------------------------------------------
// waveOutWrite
//-----------------------------------------------------------------------------
MMRESULT CWaveOutDevice::amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity)
{
    // some validation.
    if (m_hWaveDevice == 0)
    {
        DbgBreak("Invalid - device not open - logic error");
        DbgLog((LOG_ERROR,2,TEXT("waveoutWrite - device is not open")));
        return MMSYSERR_NODRIVER ;
    }
    return ::waveOutWrite (m_hWaveDevice, pwh, cbwh) ;
}

HRESULT CWaveOutDevice::amsndOutLoad(IPropertyBag *pPropBag)
{
    if(m_hWaveDevice != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // caller makes sure we're not running
    
    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"WaveOutId", &var, 0);
    if(SUCCEEDED(hr))
    {
        m_iWaveOutId = var.lVal;
        SetResourceName();
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return hr;
}

// use a version number instead of size to reduce chances of picking
// an invalid device from a 1.0 grf file
struct WaveOutPersist
{
    DWORD dwVersion;
    LONG iWaveOutId;
};


HRESULT  CWaveOutDevice::amsndOutWriteToStream(IStream *pStream)
{
    WaveOutPersist wop;
    wop.dwVersion = 200;
    wop.iWaveOutId = m_iWaveOutId;
    return pStream->Write(&wop, sizeof(wop), 0);
}

HRESULT  CWaveOutDevice::amsndOutReadFromStream(IStream *pStream)
{
    if(m_hWaveDevice != 0)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    // on any error, default to the wave mapper because we may have
    // found the old audio renderer which has the same guid
    m_iWaveOutId = WAVE_MAPPER;

    // caller makes sure we're not running
    WaveOutPersist wop;
    HRESULT hr = pStream->Read(&wop, sizeof(wop), 0);
    if(SUCCEEDED(hr))
    {
        if(wop.dwVersion == 200)
        {
            m_iWaveOutId = wop.iWaveOutId;
        }
    }

    hr = S_OK;
    SetResourceName();

    return hr;
}

int CWaveOutDevice::amsndOutSizeMax()
{
    return sizeof(WaveOutPersist);
}


//-----------------------------------------------------------------------------
// Internal function to get volume.
//-----------------------------------------------------------------------------

HRESULT CWaveOutDevice::GetVolume()
{
    // Write out the current Audio volume
    // ...query the device
    // assumes the device is connected...
    // if not we will query the volume from the mixer (probably)

    HRESULT hr ;
    DWORD amp = 0;
    HWAVEOUT hWaveDevice ;

    // if the wave device has not been opened yet, we should use the WAVE_MAPPER
    // as the handle instead of 0.

    hWaveDevice = (m_hWaveDevice) ? m_hWaveDevice : ((HWAVEOUT)IntToPtr(m_iWaveOutId)) ;
    DWORD err = ::waveOutGetVolume(hWaveDevice, (LPDWORD)&amp);

    // if we are on NT 3.51 and the device is not open we get an error
    // when using an ID == WAVE_MAPPER to read the volume.  Retry with
    // device 0
    if (err == MMSYSERR_NOTSUPPORTED && !m_hWaveDevice) {
	err = ::waveOutGetVolume(0, (LPDWORD)&amp);
    }

    DbgLog((LOG_TRACE, 5, TEXT("waveOutGetVolume: vol = %lx"), amp));

    if (MMSYSERR_NOERROR == err)
    {
        hr = NOERROR ;
	m_wLeft = LOWORD(amp);
	m_wRight = HIWORD(amp);
	if (!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
        {
	    // for mono cards map Left to Right
#ifdef DEBUG
	    // assert that the volume we want is in the low word
	    if (amp)
            {
		ASSERT(m_wLeft);
	    }
#endif
	    m_wRight = m_wLeft;
	}
	m_dwWaveVolume = amp;
	
	// map volume onto decibel range
	DWORD dwAmp = max(m_wLeft, m_wRight);
	m_lVolume = AmpFactorToDB( dwAmp );

	// remember to adjust the Balance value...
	if(m_fBalanceSet)
		SetBalance();
	else
		GetBalance();

    }
    else
    {
	DbgLog((LOG_ERROR, 5, "Error %d from waveoutGetVolume", err));
        hr = E_FAIL ;
    }
    return hr ;
}

//-----------------------------------------------------------------------------
// Internal routine to set the volume.  No parameter checking...
//-----------------------------------------------------------------------------
HRESULT CWaveOutDevice::PutVolume ()
{
    if (m_hWaveDevice)
    {
	DWORD Volume = MAKELONG(m_wLeft, m_wRight);
	if (!(m_fHasVolume & (WAVECAPS_LRVOLUME)))
        {
	    // mono cards: LEFT volume only - HIWORD might be ignored... but
	    Volume = m_wLeft;
	}

        DbgLog((LOG_TRACE, 5, TEXT("waveOutSetVolume: vol = %lx"), Volume));

        MMRESULT mmr = ::waveOutSetVolume(m_hWaveDevice, Volume);
        if (mmr == MMSYSERR_NOERROR)
            return NOERROR ;
        else
            return E_FAIL ;
    }
    else
    {
	// no current wave device.  We have remembered the volume values
	return(NOERROR);
    }
}

//-----------------------------------------------------------------------------
// Internal routine to get the Balance given right/left amp factors
//-----------------------------------------------------------------------------
void CWaveOutDevice::GetBalance()
{
	if (m_wLeft == m_wRight)
    {
	    m_lBalance = 0;
	}
    else
    {
	    // map Balance onto decibel range
	    LONG lLDecibel = AmpFactorToDB( m_wLeft );    
		LONG lRDecibel = AmpFactorToDB( m_wRight );

	    // note: m_lBalance < 0:  right is quieter
	    //       m_lBalance > 0:  left is quieter
	    m_lBalance = lRDecibel - lLDecibel;
	}
}

//-----------------------------------------------------------------------------
// Internal routine to set the Balance.
//-----------------------------------------------------------------------------
void CWaveOutDevice::SetBalance ()
{
    //
    // Calculate scaling factors for waveout API
    //
    LONG lTotalLeftDB, lTotalRightDB ;

    if (m_lBalance >= 0)
    {
	// left is attenuated
	lTotalLeftDB	= m_lVolume - m_lBalance ;
	lTotalRightDB	= m_lVolume;
    }
    else
    {
	// right is attenuated
	lTotalLeftDB	= m_lVolume;
	lTotalRightDB	= m_lVolume - (-m_lBalance);
    }

    DWORD dwLeftAmpFactor, dwRightAmpFactor;
    dwLeftAmpFactor   = DBToAmpFactor(lTotalLeftDB);
    dwRightAmpFactor  = DBToAmpFactor(lTotalRightDB);

    if (m_fHasVolume & (WAVECAPS_LRVOLUME))
    {
	// Set stereo volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume |= dwRightAmpFactor << 16;
    }
    else
    {
	// Average the volume
	m_dwWaveVolume = dwLeftAmpFactor;
	m_dwWaveVolume += dwRightAmpFactor;
	m_dwWaveVolume /= 2;
    }
    m_wLeft = WORD(dwLeftAmpFactor);
    m_wRight = WORD(dwRightAmpFactor);
}

//-----------------------------------------------------------------------------

void CWaveOutDevice::SetResourceName()
{
    wsprintfW(m_wszResourceName, L".\\WaveOut\\%08x", m_iWaveOutId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\wave.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// Implements the CWaveOutDevice class based on waveOut APIs
//-----------------------------------------------------------------------------

extern AMOVIESETUP_FILTER wavFilter;

class CWaveOutDevice :
    public CSoundDevice
{

public:
    // define the public functions that this class exposes. These are all
    // straight calls to the corresponding waveOut APIs. Only the APIs that are
    // used by the Quartz wave renderer are declared and defined. We may have
    // to progressively add to this list.

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    MMRESULT amsndOutClose () ;
    MMRESULT amsndOutGetDevCaps (LPWAVEOUTCAPS pwoc, UINT cbwoc) ;
    MMRESULT amsndOutGetErrorText (MMRESULT mmrE, LPTSTR pszText, UINT cchText) ;
    MMRESULT amsndOutGetPosition (LPMMTIME pmmt, UINT cbmmt, BOOL bUseAdjustedPos) ;
    MMRESULT amsndOutOpen (LPHWAVEOUT phwo, LPWAVEFORMATEX pwfx,
                           double dRate, DWORD *pnAvgBytesPerSec,
                           DWORD_PTR dwCallBack, DWORD_PTR dwCallBackInstance, DWORD fdwOpen) ;
    MMRESULT amsndOutPause () ;
    MMRESULT amsndOutPrepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutReset () ;
    MMRESULT amsndOutBreak () ;
    MMRESULT amsndOutRestart () ;
    MMRESULT amsndOutUnprepareHeader (LPWAVEHDR pwh, UINT cbwh) ;
    MMRESULT amsndOutWrite (LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity) ;

    // Routines required for initialisation and volume/balance handling
    // These are not part of the Win32 waveOutXxxx api set
    HRESULT  amsndOutCheckFormat (const CMediaType *pmt, double dRate);
    LPCWSTR  amsndOutGetResourceName () ;
    HRESULT  amsndOutGetBalance (LPLONG plBalance) ;
    HRESULT  amsndOutGetVolume (LPLONG plVolume) ;
    HRESULT  amsndOutSetBalance (LONG lVolume) ;
    HRESULT  amsndOutSetVolume (LONG lVolume) ;

    HRESULT  amsndOutLoad(IPropertyBag *pPropBag) ;

    HRESULT  amsndOutWriteToStream(IStream *pStream);
    HRESULT  amsndOutReadFromStream(IStream *pStream);
    int      amsndOutSizeMax();
    
    bool     amsndOutCanDynaReconnect() { return false; } // The wave out filter does not support dynamic reconnection

    CWaveOutDevice () ;
    ~CWaveOutDevice () ;

private:
    // Get current settings from the hardware and set member variables
    HRESULT GetVolume ();

    // Put current settings to the hardware using member variables
    HRESULT PutVolume();

    // Set up right/left amp factors
    void SetBalance();

	// Get the current balance from right/left amp factors
	void GetBalance();

    // volume is in the range -10000 to 0 (100th DB units)
    // amplitude and Balance are cumulative
    LONG        m_lVolume;
    LONG        m_lBalance;

    WORD	m_wLeft;		// Left channel volume
    WORD	m_wRight;		// Right channel volume
    DWORD   m_dwWaveVolume;
    BOOL	m_fHasVolume;		// wave device can set the volume
	BOOL	m_fBalanceSet;	// remember if the balance was explicitly set at least once

    HWAVEOUT    m_hWaveDevice;		// remember the handle of the open device

    UINT        m_iWaveOutId;           // output device to open

    WCHAR       m_wszResourceName[100]; // for resource manager
    void        SetResourceName();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\slave.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//
// CWaveSlave - audio renderer slaving class
//
//
// CWaveSlave 
//
// Class which supports slaving for an input stream to the audio renderer
//

#ifdef CALCULATE_AUDBUFF_JITTER
HRESULT GetStdDev( int nBuffers, int *piResult, LONGLONG llSumSq, LONGLONG iTot );
#endif

class CWaveSlave
{
    friend class CWaveOutFilter;
    friend class CWaveOutInputPin;	
    friend class CWaveOutClock;	
    friend class CDSoundDevice;

public:

    CWaveSlave( 
        CWaveOutFilter *pWaveOutFilter, 
        CWaveOutInputPin *pWaveOutInputPin );

    ~CWaveSlave() {}

protected:

    // Returns: S_OK - carry on; any necessary adjustments were made successfully 
    //		    S_FALSE - drop this buffer; we are too far behind
    HRESULT AdjustSlaveClock(
        const REFERENCE_TIME &tStart, 
        LONG * pcbData, 
        BOOL bDiscontinuity);

    void ResumeSlaving( BOOL bReset );    // prepare to resume or reset slaving
    void RefreshModeOnNextSample( BOOL bRefresh ); // prepare to resume slaving for the current playback
    BOOL UpdateSlaveMode( BOOL bSync );

    REFERENCE_TIME GetMasterClockTime
    (
        REFERENCE_TIME rtStart, 
        BOOL           bReset
    );

    REFERENCE_TIME GetSlaveClockTime
    (
        REFERENCE_TIME rtStart, 
        BOOL           bReset
    );

    HRESULT RecordBufferLateness(REFERENCE_TIME rtBufferDiff);
    
private:
    DWORD    m_dwConsecutiveBuffersNotDropped;

    CWaveOutInputPin *m_pPin;           // The renderer input pin that owns us
    CWaveOutFilter *m_pFilter;	        // The renderer that owns the input pin that owns us


    REFERENCE_TIME m_rtAdjustThreshold;
    REFERENCE_TIME m_rtWaveOutLatencyThreshold;
    FLOAT          m_fltAdjustStepFactor; 
    FLOAT          m_fltMaxAdjustFactor;
    FLOAT          m_fltErrorDecayFactor;   // probably can be global, but for the moment this allows different
                                            // different values on separate renderer instances running at the same time


    REFERENCE_TIME m_rtLastMasterClockTime; // last master master clock time (100ns)
    REFERENCE_TIME m_rtInitSlaveClockTime;  // used to reset slave time in some slaving modes
    REFERENCE_TIME m_rtErrorAccum;          // accumulated error between clock differences (100ns)
                                            //   + values => faster master clock 
                                            //   - values => faster device clock
    REFERENCE_TIME m_rtLastHighErrorSeen;   // last high error which triggered upward device rate adjustment (100ns)
    REFERENCE_TIME m_rtLastLowErrorSeen;    // last low error which triggered downward device rate adjustment (100ns)
    REFERENCE_TIME m_rtHighestErrorSeen;    // highest error seen since starting playback (100ns)
    REFERENCE_TIME m_rtLowestErrorSeen;     // lowest error seen since starting playback (100ns)

    DWORD    m_dwCurrentRate;               // current device clock frequency (Hz)
    DWORD    m_dwMinClockRate;              // lower limit on clock rate adjustments (Hz)
    DWORD    m_dwMaxClockRate;              // upper limit on clock rate adjustments (Hz)
    DWORD    m_fdwSlaveMode;                // slave mode
    DWORD    m_dwClockStep;                 // clock step size in Hz (calculated based on stream frequency)

    REFERENCE_TIME m_rtDroppedBufferDuration; // total duration of buffers dropped for clock slaving

    BOOL    m_bResumeSlaving;           // set when the graph is paused from run
                                        // to signal the slaving code to ignore
                                        // the first sample sent if the graph is
                                        // re-run directly from pause (i.e. no stop called).
    BOOL    m_bRefreshMode;             // refresh slaving mode on next sample if TRUE

    BOOL    m_bLiveButDataPrequeued;


#ifdef LOG_CLOCK_DELTAS
    REFERENCE_TIME m_rtLastSlaveClockTime;  // last slave clock time measurement (100ns)
#endif


#ifdef CALCULATE_AUDBUFF_JITTER

    // buffer jitter measurement parameters
    DWORD           m_cBuffersReceived;     // total buffers received
    int             m_iTotAcc;              // total accumulated buffer lateness error
    DWORD           m_iSumSqAcc;            // sum of squared buffer latenesses
#endif    
    REFERENCE_TIME  m_rtLastSysTimeBufferTime; // clock time of last buffer (100ns)
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\waveclk.cpp ===
// Copyright (c) 1995 - 2000  Microsoft Corporation.  All Rights Reserved.
// Digital wave clock, Steve Davies, January 1996

#include <streams.h>
#include "waveout.h"
#include <mmreg.h>
#include <seqhdr.h>  // MPEG stuff

/* Constructor */

CWaveOutClock::CWaveOutClock(
    CWaveOutFilter *pFilter,
    LPUNKNOWN pUnk,
    HRESULT *phr,
    CAMSchedule * pShed)
    : CBaseReferenceClock(NAME("WaveOut device clock"), pUnk, phr, pShed)
    , m_pFilter(pFilter)
    , m_fAudioStarted(FALSE)
{
    // Compute perf counter difference
#ifdef USE_PERF_COUNTER_TO_SYNC
    LARGE_INTEGER liFreq;
    QueryPerformanceFrequency(&liFreq);

    // Set Threshold to 0.5ms
    m_llSyncClockThreshold = liFreq.QuadPart / (LONGLONG)2000;
    // this is the time within which we need to read both the device and
    // system clock in order to believe the two times are in sync
#else

    // Set Threshold to 1 ms (a single clock tick)
    m_llSyncClockThreshold = (UNITS / MILLISECONDS);

#endif
}

/* Called on RUN.  The wave device will be in a paused state with
 * buffers queued.  We query the wave position and add that to the
 * start time in order to get a system time position
 */
void CWaveOutClock::AudioStarting(REFERENCE_TIME tStart)
{
    if (m_pFilter->m_fFilterClock != WAVE_OURCLOCK &&
        m_pFilter->m_fFilterClock != WAVE_OTHERCLOCK ) {
    	return;
    }
    
    // !!! lock
    CAutoLock lck(this);
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    ASSERT(pwfx != NULL);
    m_rtRunStart = tStart;

    // get the audio position from the device
    // if tStart == -1 we are restarting the audio after a break
    // in which case we want to take the current audio position
    // and adjust its timing to match the current system clock value.
    // If the audio sample is far too late... we should have dropped it
    // which is bad news....
        
    //ASSERT(!m_fAudioStarted);
    m_fAudioStarted = TRUE;  // I would prefer this next to waveOutRestart.

    //  Make sure the clock is now in sync
    AdjustClock();

#ifdef DEBUG
    REFERENCE_TIME rtCurrentRefTime;
    GetTime(&rtCurrentRefTime);

    DbgLog((LOG_TIMING, 1, TEXT("Audio starting, requested at time %s, now %s (diff %d)"),
        (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(rtCurrentRefTime, CDISP_DEC),
        (LONG)(rtCurrentRefTime-tStart)));
#endif

}

/* Called on filter PAUSE and from the wavecallback if no more
 * data is queued.
 */
void CWaveOutClock::AudioStopping()
{
    if (m_pFilter->m_fFilterClock != WAVE_OURCLOCK &&
        m_pFilter->m_fFilterClock != WAVE_OTHERCLOCK ) {
    	return;
    }

    // only if we are started do we stop, otherwise do nothing
    if (InterlockedExchange((PLONG)&m_fAudioStarted,0)) {
	CAutoLock lck(this);
	// we use the lock to synchronise stopping with starting
#ifdef DEBUG
        REFERENCE_TIME m_CurrentRefTime;
        GetTime(&m_CurrentRefTime);

	DbgLog((LOG_TIMING, 1, TEXT("Audio stopping, time now %s"), (LPCTSTR)CDisp(m_CurrentRefTime, CDISP_DEC)));
#endif
	// by using the lock we guarantee that when we return everything
	// has been done to stop the audio
    }
}


//
//  Set the clock adjustment when we're running
//
void CWaveOutClock::AdjustClock()
{
    LONGLONG sysTime, devTime;

    ReadClockTimes(&sysTime, &devTime);

    /*  Now work out what the current time ought to be
        m_rtRunStart is ONLY valid when m_fAudioStarted is TRUE
    */
    ASSERT(m_fAudioStarted);

    /*  Basically validate the equation that

        (Reference Time) == (Stream Time) + (The tStart parameter passed to Run())
    */
#ifdef DEBUG
    LONG lTimeDelta = (LONG)((devTime + m_rtRunStart - sysTime) / (UNITS / MILLISECONDS));
    DbgLog((LOG_TRACE, 8, TEXT("devTime = %s, m_rtRunStart = %s, sysTime = %s"), 
            (LPCTSTR)CDisp(devTime, CDISP_DEC),
            (LPCTSTR)CDisp(m_rtRunStart, CDISP_DEC),
            (LPCTSTR)CDisp(sysTime, CDISP_DEC)
            ));
    if (lTimeDelta) {
	DbgLog((LOG_TRACE, 3, TEXT("Setting time delta %ldms"), (LONG) (lTimeDelta / 10000)));
    }
#endif

    REFERENCE_TIME rt =  devTime + m_rtRunStart - sysTime ;
    SetTimeDelta( rt);

}

void CWaveOutClock::UpdateBytePositionData(DWORD nPrevAvgBytesPerSec, DWORD nCurAvgBytesPerSec)
{
    DbgLog((LOG_TRACE, 8, TEXT("CWaveOutClock::UpdateBytePositionData")));
    DbgLog((LOG_TRACE, 8, TEXT("m_llBytesInLast was %s, m_llBytesProcessed was %s"), 
            (LPCTSTR)CDisp(m_llBytesInLast, CDISP_DEC),
            (LPCTSTR)CDisp(m_llBytesProcessed, CDISP_DEC) ));
            
    DbgLog((LOG_TRACE, 8, TEXT("nPrevAveBytesPerSec: %d, nNewAveBytesPerSec: %d"), 
            nPrevAvgBytesPerSec,
            nCurAvgBytesPerSec));
                
    m_llBytesInLast = llMulDiv((LONG)m_llBytesInLast,
                             nCurAvgBytesPerSec,
                             nPrevAvgBytesPerSec,
                             0);

    m_llBytesProcessed = llMulDiv((LONG)m_llBytesProcessed,
                             nCurAvgBytesPerSec,
                             nPrevAvgBytesPerSec,
                             0);

    DbgLog((LOG_TRACE, 8, TEXT("New m_llBytesInLast: %s, New m_llBytesProcessed: %s"), 
            (LPCTSTR)CDisp(m_llBytesInLast, CDISP_DEC),
            (LPCTSTR)CDisp(m_llBytesProcessed, CDISP_DEC) ));

}


//  Reset the buffer statistics
//  If bResetToZero is false assume the next buffer starts after these,
//  otherwise assume it starts at 0
void CWaveOutClock::ResetPosition(BOOL bResetToZero) {

    ASSERT(CritCheckIn(m_pFilter));
    if (!bResetToZero) {
        m_stBufferStartTime =
            m_stBufferStartTime +
            MulDiv((LONG)m_llBytesInLast,
                   (LONG)UNITS,
                   m_pFilter->m_pInputPin->m_nAvgBytesPerSec);
    } else {
        m_stBufferStartTime = 0;
        m_llBytesPlayed = 0;
    }
#ifdef DEBUG    
    m_llEstDevRateStartTime  = 0;
    m_llEstDevRateStartBytes = 0;
#endif    
    m_llBytesInLast          = 0;
    m_llBytesProcessed       = 0;
}

#ifdef DEBUG

const DWORD DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR = 5;

DWORD CWaveOutClock::EstimateDevClockRate
(
    const LONGLONG llTime, 
    BOOL           bInit
) 
{
    DWORD nAvgBytesPerSec = 0;
    
    if( bInit )
    {
        // initialize start time and byte count
        m_llEstDevRateStartTime = llTime;
        m_llEstDevRateStartBytes = m_llBytesPlayed;
    }        
    else
    {
        LONGLONG llBytesConsumed      = m_pFilter->m_pRefClock->m_llBytesPlayed - 
                                        m_llEstDevRateStartBytes +
                                        DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR * m_pFilter->m_pInputPin->m_nAvgBytesPerSec; 
        LONGLONG llTimeSpentConsuming = llTime - m_llEstDevRateStartTime +
                                        DEVICE_RATE_ESTIMATE_WEIGHT_FACTOR * UNITS; 
        DbgLog((LOG_TRACE
              , 8
              , TEXT("llTimeSpentConsuming = %dms, llBytesConsumed = %d")
              , (LONG)(llTimeSpentConsuming / 10000)
              , (LONG)(llBytesConsumed) ) );
              
        nAvgBytesPerSec = (LONG) llMulDiv( llBytesConsumed
                                         , UNITS
                                         , llTimeSpentConsuming
                                         , 0 );
        DbgLog( (LOG_TRACE
              , 5
              , TEXT("*** Estimated device clock rate: = %ld bytes per sec")
              , nAvgBytesPerSec ) );
              
    }    

    return nAvgBytesPerSec;            
}
#endif

//  Process timing information in a wave header
//  return the time when the data would all be played
//
LONGLONG CWaveOutClock::NextHdr(
    PBYTE pbData,
    DWORD cbData,
    BOOL bSync,
    IMediaSample *pSample
)
{
    CAutoLock lck(this);
    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();
    ASSERT(pwfx != NULL);

    // use the rate at which the wave device is consuming data
    // which may be different from the rate in the format block
    DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;
    if (bSync) {

        //  Do something a bit different for MPEG because the time stamp
        //  refers to the first frame
        if ((pwfx->wFormatTag == WAVE_FORMAT_MPEG) &&
            (((MPEG1WAVEFORMAT *)pwfx)->fwHeadFlags & ACM_MPEG_ID_MPEG1)) {
            DWORD dwFrameOffset = MPEG1AudioFrameOffset(
                                      pbData,
                                      cbData);
            if (dwFrameOffset != (DWORD)-1) {
                ASSERT(dwFrameOffset < cbData);
                m_llBytesProcessed += m_llBytesInLast + dwFrameOffset;
                m_llBytesInLast = cbData - dwFrameOffset;
            } else {
                m_llBytesInLast += cbData;
		DbgLog((LOG_ERROR, 0, TEXT("Bad Mpeg timing data")));
		return m_stBufferStartTime + (((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec);
            }
        } else {

            //  Upgrade the number of bytes processed now and the bytes in the
            //  'next' block.  The data is contiguous
#ifdef CHECK_TIMESTAMPS
            {
                REFERENCE_TIME tStart, tStop;
                pSample->GetTime(&tStart, &tStop);
                REFERENCE_TIME rtPredicted =
                    m_rtBufferStartTime +
                    MulDiv((LONG)m_llBytesInLast, UNITS, pwfx->nAvgBytesPerSec);
                LONG lDiff = (LONG)(rtPredicted - tStart) / 10000;
                if (abs(lDiff) > 3) {
                    DbgLog((LOG_TRACE, 0,
                            TEXT("Sample start discrepancy > 3 ms - expected %d, actual %d"),
                            (LONG)(rtPredicted / 10000),
                            (LONG)(tStart / 10000)));

                }
            }
#endif
            m_llBytesProcessed += m_llBytesInLast;
            m_llBytesInLast     = cbData;
        }


        //  Get the start & stop times of the next buffer
        pSample->GetTime(&m_stBufferStartTime, &m_stBufferStopTime);

#ifdef DEBUG
	//LONGLONG rtLengthLastBuffer = ((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec;
	//LONGLONG overlap = m_stBufferStopTime - m_stBufferStartTime + rtLengthLastBuffer;
	//ASSERT( overlap < (1 * (UNITS/MILLISECONDS)));
#endif
	// If we are running bring the system and wave clocks closer together
        // NB: it would be invalid to do this if m_fAudioStarted was false
	// if we are using an external clock then m_fAudioStarted will ALWAYS be FALSE
	// this prevents us from having to check if we are using OUR clock
	if (State_Running == m_pFilter->m_State && m_fAudioStarted) AdjustClock();

    } else {
        m_llBytesInLast += cbData;
    }


    // !!! MIDI HACK
    if (nAvgBytesPerSec == 0)
	return m_stBufferStopTime;

    // we can calculate the "end" of the queue of data written to the
    // device by taking m_stBufferStartTime and adding m_llBytesInLast
    // (converted to time obviously).  This will be an approximation for
    // compressed audio

    return m_stBufferStartTime + (((LONGLONG)m_llBytesInLast * UNITS) / nAvgBytesPerSec);
}


// !!! the following two functions are almost identical, could they be combined?

// return the time at which the device is currently playing
LONGLONG CWaveOutClock::ReadDevicePosition(BOOL bAbsoluteDevTime)
{
    MMTIME	mmtime;
    LONGLONG rt;

    // we should be holding the device lock at this point
    ASSERT(CritCheckIn(m_pFilter));

    // Get the average rate at which the device is consuming data
    DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;

    mmtime.wType = TIME_BYTES;
    m_pFilter->m_pSoundDevice->amsndOutGetPosition(&mmtime, sizeof(mmtime), bAbsoluteDevTime);
    if (mmtime.wType == TIME_MS) {
	// !!! MIDI HACK, return milliseconds without converting
	if (nAvgBytesPerSec == 0)
	    return (mmtime.u.ms * UNITS / MILLISECONDS);
	
        //  Convert to bytes - we have to do this so we can
        //  rebase on the time stamps and byte count.
        mmtime.u.cb = MulDiv(mmtime.u.ms, nAvgBytesPerSec, 1000);

    } else {
        ASSERT(mmtime.wType == TIME_BYTES);

	ASSERT(nAvgBytesPerSec != 0);
    }

    // update and cache the device position
    DbgLog( ( LOG_TRACE
          , 15
          , TEXT("mmtime.u.cb indicates the waveout device has played %ld bytes (%ld since last read)")
          , (LONG)(mmtime.u.cb)
          , (LONG)(mmtime.u.cb - (DWORD)m_llBytesPlayed) ) );
    m_llBytesPlayed += (LONGLONG) ((DWORD)(mmtime.u.cb - m_llBytesPlayed)); 

    if( bAbsoluteDevTime )
    {
        // return the zero based time (independent of stream time)
        // that the device has played to
        rt = llMulDiv( m_llBytesPlayed, UNITS, nAvgBytesPerSec, 0 );
    }
    else
    {        
        //  First work out how many bytes have been processed since
        //  the start of this buffer
        //
    
        LONG lProcessed = (LONG)(mmtime.u.cb - (DWORD)m_llBytesProcessed);

        //  Use this as an offset from the start of the buffer (stream time)
        //
        rt = m_stBufferStartTime +
             (((LONGLONG)lProcessed * UNITS) / nAvgBytesPerSec);
             
    }
    return(rt);
}

LONGLONG CWaveOutClock::ReadDeviceClock()
{
    // We should only be called if we are active

    // lock device to prevent losing wave device
    ASSERT(CritCheckIn(m_pFilter));

    if (m_pFilter->m_bHaveWaveDevice && m_fAudioStarted) {
        ASSERT(m_pFilter->m_hwo);

	MMTIME	mmtime;
        LONGLONG rt;

	// Get the average rate at which the device is consuming data
	DWORD nAvgBytesPerSec = m_pFilter->m_pInputPin->m_nAvgBytesPerSec;

	mmtime.wType = TIME_BYTES;
        //  Clear out high DWORD so we can interpret the amswer as signed
        //  and at least DSOUND can return the proper result
        *((DWORD *)&mmtime.u.cb + 1) = 0;

	m_pFilter->m_pSoundDevice->amsndOutGetPosition(&mmtime, sizeof(mmtime), FALSE);

        if (mmtime.wType == TIME_MS) {
	
	    // !!! MIDI HACK, return milliseconds without converting
	    if (nAvgBytesPerSec == 0)
		return (mmtime.u.ms * UNITS / MILLISECONDS);
	
            //  Convert to bytes - we have to do this so we can
            //  rebase on the time stamps and byte count.
            mmtime.u.cb = MulDiv(mmtime.u.ms, nAvgBytesPerSec, 1000);
        } else {
	    ASSERT(mmtime.wType == TIME_BYTES);

	    ASSERT(nAvgBytesPerSec != 0);
        }

        //  First work out how many bytes have been processed since
        //  the start of this buffer
        //
        LONGLONG llProcessed;
        if( m_pFilter->m_fDSound )
        {
            // only dsr reports LONGLONG position
            llProcessed = *(UNALIGNED LONGLONG *)&mmtime.u.cb - m_llBytesProcessed;
        }
        else
        {
            llProcessed = (LONGLONG) (LONG)(mmtime.u.cb - (DWORD)m_llBytesProcessed);
        }
        
        //  Use this as an offset from the start of the buffer (stream time)
        //
        rt = m_stBufferStartTime +
             llMulDiv(llProcessed, UNITS, nAvgBytesPerSec, 0);

        m_llLastDeviceClock = rt;
    }
    return m_llLastDeviceClock;  // if the audio is stopped the device clock is 0
}

// ReadClockTimes:
//
// The problem with having two clocks running is keeping them in sync.  This
// is what ReadClockTimes does.
//
// Both the system and device clocks are read within a "short" space of time.
// In an ideal world a short space of time is such that the fastest incrementing
// clock does not update.  We assume the system clock is very fast to query
// and bracket a call to the device clock with 2 calls to the system clock.
// If the two system clock calls show no difference we know that the time
// returned by the device clock can be mapped to system time.  On slow
// machines, and with some devices, it may take a significant piece of time
// to read the device clock.  We make ourselves slightly adaptive and
// use a variable to judge "short space".  The alternative is that we spin
// for ever trying to sync up the two clocks and make no progress at all.
//
//
void CWaveOutClock::ReadClockTimes(LONGLONG *pllSystem, LONGLONG *pllDeviceTime)
{
    DWORD dwCurrentPriority = GetThreadPriority(GetCurrentThread());
    if (dwCurrentPriority != THREAD_PRIORITY_TIME_CRITICAL) {
        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);
    }

    // If we cannot sync both clocks within 50 cycles give up.  This is
    // highly unlikely on fast machines, but is possible on slower
    // machines when, for example, reading the wave device position might
    // be relatively slow.
    int i = 50;

    // Get times from both clocks.  Ensure we read both clocks within
    // the same system tick.  However if it looks like we are taking
    // forever to do this... give up.  We can resync more closely at
    // a later attempt.

#ifdef USE_PERF_COUNTER_TO_SYNC
    while (i--) {
        LARGE_INTEGER liStart, liStop;
        QueryPerformanceCounter(&liStart);
        *pllDeviceTime = ReadDeviceClock();
        *pllSystem = CSystemClock::GetTimeInternal();
        QueryPerformanceCounter(&liStop);
        if (liStop.QuadPart - liStart.QuadPart < m_llSyncClockThreshold) {
            break;
        }
    }
#else
    // We assume that reading the system clock is FAST and
    // spin until the system clock time before and after
    // reading the device clock is unchanged (or little changed).
    while (i--) {
        REFERENCE_TIME liStart;
        liStart = GetPrivateTime();
        *pllDeviceTime = ReadDeviceClock();
        *pllSystem = GetPrivateTime();

	// Are we within a 0.5 ms threshold?
	// note: with the current implementation of the system
	// clock (using timeGetTime) this means "Did the two
	// reads of the system clock return the same value
        if (*pllSystem - liStart <= m_llSyncClockThreshold) {
            break;
        }
    }
#endif
    if (i<=0) {
	// we ran through the whole loop... try not to do so again
	m_llSyncClockThreshold *= 2;
	DbgLog((LOG_TRACE, 5, TEXT("Increasing clock synchronization threshold to %d"), m_llSyncClockThreshold));
    } else {		
	DbgLog((LOG_TRACE, 5, TEXT("Clock synchronized after %d iterations"), 50-i));
    }

    if (dwCurrentPriority != THREAD_PRIORITY_TIME_CRITICAL) {
        SetThreadPriority(GetCurrentThread(), dwCurrentPriority);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\waveout.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Digital audio renderer, David Maymudes, January 1995

#include <streams.h>
#include <mmreg.h>
#include <math.h>

#ifdef DSRENDER
#include <initguid.h>
#else
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#endif

#include "waveout.h"
#include "wave.h"
#include "dsr.h"
#include "midiout.h"
#include "audprop.h"

#ifndef DSRENDER
#ifndef FILTER_DLL
#include <initguid.h>
#endif
#endif

#ifdef DEBUG
#include <stdio.h>
static int g_WaveOutFilterTraceLevel = 2;

const DWORD DBG_LEVEL_LOG_SNDDEV_ERRS        = 5;
#endif

//  Compensate for Windows NT wave mapper bug
//  The WHDR_INQUEUE bit can get left set so turn it off
inline void FixUpWaveHeader(LPWAVEHDR lpwh)
{
    //  If it accidentally got left on the DONE bit will also be set
    ASSERT(!(lpwh->dwFlags & WHDR_INQUEUE) || (lpwh->dwFlags & WHDR_DONE));
    lpwh->dwFlags &= ~WHDR_INQUEUE;
}

#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"", &CLSID_DSoundRender, CDSoundDevice::CreateInstance},
    {L"", &CLSID_AudioRender, CWaveOutDevice::CreateInstance},
    {L"", &CLSID_AVIMIDIRender, CMidiOutDevice::CreateInstance},
    {L"Audio Renderer Property Page", &CLSID_AudioProperties, CAudioRendererProperties::CreateInstance},
    {L"Audio Renderer Advanced Properties", &CLSID_AudioRendererAdvancedProperties, CAudioRendererAdvancedProperties::CreateInstance},
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

#endif

// If the following is defined, we pretend that the wave device plays at this fraction of
// the requested rate, to test our synchronization code....
// #define SIMULATEBROKENDEVICE 0.80

// setup data to allow our filter to be self registering

const AMOVIESETUP_MEDIATYPE
wavOpPinTypes = { &MEDIATYPE_Audio, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
waveOutOpPin = { L"Input"
               , TRUE          // bRendered
               , FALSE         // bOutput
               , FALSE         // bZero
               , FALSE         // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , 1             // nMediaTypes
               , &wavOpPinTypes }; // lpMediaTypes

// IBaseFilter stuff

/* Return our single input pin - not addrefed */

CBasePin *CWaveOutFilter::GetPin(int n)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: GetPin, %d"), n));
    /* We only support one input pin and it is numbered zero */
    return n==0 ? m_pInputPin : NULL;
}


// switch the filter into stopped mode.
STDMETHODIMP CWaveOutFilter::Stop()
{
    HRESULT hr = NOERROR;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: STOP")));

    // limit the scope of the critical section as
    // we may need to call into the resource manager in which case
    // we must NOT hold our critical section
    BOOL bCancel = FALSE;
    BOOL bNotify = FALSE;
    {
        CAutoLock lock(this);

        if (m_State == State_Stopped) return NOERROR;

        DbgLog((LOG_TRACE, 4, "wo: STOPping"));

        // transitions to STOP from RUN must go through PAUSE
        // pause the device if we were running
        if (m_State == State_Running) {
            hr = Pause();
        }

        // reset the EC_COMPLETE flag as we will need to send another if
        // we re-enter run mode.
        m_bHaveEOS = FALSE;
        m_eSentEOS = EOS_NOTSENT;
        DbgLog((LOG_TRACE, 4, "Clearing EOS flags in STOP"));

        // If we paused the system then carry on and STOP
        if (!FAILED(hr)) {

            DbgLog((LOG_TRACE,1,TEXT("Waveout: Stopping....")));

            // need to make sure that no more buffers appear in the queue
            // during or after the reset process below or the buffer
            // count may get messed up - currently Receive holds the
            // filter-wide critsec to ensure this

            // force end-of-stream clear
            // this means that if any buffers complete the callback will
            // not signal EOS
            InterlockedIncrement(&m_lBuffers);

            if (m_hwo) {
                // Remember the volume when we Stop.  We do not do this when we
                // release the wave device as CWaveAllocator does not have
                // access to our variables.  And rather than linking the two
                // classes any more closely we check on the closing volume now.

                // See if we are setting the volume on this stream.  If so,
                // grab the current volume so we can reset it when we regain
                // the wave device.
                if (m_fVolumeSet) {
                    m_BasicAudioControl.GetVolume();
                }
                amsndOutReset();
                DbgLog((LOG_TRACE, 4, "Resetting the wave device in STOP, filter is %8x", this));
            }

            // now force the buffer count back to the normal (non-eos) 0.
            // at this point, we are sure there are no more buffers coming in
            // and no more buffers waiting for callbacks.
            ASSERT(m_lBuffers >= 0);
            m_lBuffers = 0;

            // base class changes state and tells pin to go to inactive
            // the pin Inactive method will decommit our allocator, which we
            // need to do before closing the device.
            hr =  CBaseFilter::Stop();

            // Make sure Inactive() is called.  CBaseFilter::Stop() does not call Inactive() if the
            // input pin is not connected.
            hr = m_pInputPin->Inactive();

        } else {
            DbgLog((LOG_ERROR, 1, "FAILED to Pause waveout when trying to STOP"));
        }


        // call the allocator and see if it has finished with the device
        if (!m_hwo) {
            bCancel = TRUE;

            ASSERT(!m_bHaveWaveDevice);
#if 0
        } else if (m_cDirectSoundRef || m_cPrimaryBufferRef ||
                            m_cSecondaryBufferRef) {
            DbgLog((LOG_TRACE, 2, "Stop - can't release wave device yet!"));
            DbgLog((LOG_TRACE, 2, "Some app has a reference count on DSound"));
            // Sorry, we can't give up the wave device yet, some app has a
            // reference count on DirectSound
#endif
        } else if (m_dwLockCount == 0) /* ZoltanS fix 1-20-98 */ {
            // stop using the wave device
            m_bHaveWaveDevice = FALSE;

            if(m_pInputPin->m_pOurAllocator)
                hr = m_pInputPin->m_pOurAllocator->ReleaseResource();

            // this returns S_OK if the allocator has finished with the
            // device already, or otherwise it will call back to our
            // OnReleaseComplete when the last buffer is freed
            if (S_OK == hr) {
                // release done - close device
                CloseWaveDevice();

                // notify the resource manager -- outside the critsec
                bNotify = TRUE;
            }
        } // end if (!m_hwo)

        // We have now completed our transition into "paused" state
        // (i.e. we don't need to wait for any more data, we're gonna stop instead)
        m_evPauseComplete.Set();
    } // end of autolock scope

    ASSERT(CritCheckOut(this));
    if (m_pResourceManager) {
         if (bCancel) {
             // we're no longer waiting for the device
             m_pResourceManager->CancelRequest(
                         m_idResource,
                         (IResourceConsumer*)this);
         } else if (bNotify) {
             // we've finished with the device now
             m_pResourceManager->NotifyRelease(
                         m_idResource,
                         (IResourceConsumer*)this,
                         FALSE);
         }
    }

    return hr;
}

STDMETHODIMP CWaveOutFilter::Pause()
{
    {
        CAutoLock lck(&m_csComplete);
        m_bSendEOSOK = false;
    }

    /*  Do the main function and see what happens */
    HRESULT hr;
    {
        CAutoLock lck(this);
        hr = DoPause();
    }
    if (FAILED(hr)) {

        /*  Fool stop into doing something */
        m_State = State_Paused;
        Stop();
    }
    return hr;
}

HRESULT CWaveOutFilter::DoPause()
{
    HRESULT hr = S_OK;
    HRESULT hrIncomplete = S_OK;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: PAUSE")));

    // cancel any outstanding EOS callback
    CancelEOSCallback();

    m_pInputPin->m_Slave.ResumeSlaving( FALSE );
    m_pInputPin->m_bPrerollDiscontinuity = FALSE;

    /* Check we can PAUSE given our current state */

    if (m_State == State_Running) {
        DbgLog((LOG_TRACE,2,TEXT("Waveout: Running->Paused")));
        m_evPauseComplete.Set();   // We have end of stream - transition is complete
        DbgLog((LOG_TRACE, 3, "Completing transition to Pause from RUN"));

        if (m_hwo) {

            // If we have a pending callback to restart the wave device
            // then blow it away.  Using m_dwAdviseCookie is reasonable as this
            // value is only set if we get a deferred wave start.

            // must hold dev critsec to close window between him testing
            // and him setting this or he could read it before we reset it
            // and then restart after we pause.

            DWORD_PTR dwCookie;

            { // scope for lock
                ASSERT(CritCheckIn(this));
                dwCookie = m_dwAdviseCookie;
                m_dwAdviseCookie = 0;
            }

            // Clean up if necessary to prevent the (unusual?) case of
            // the next RUN command arriving before the existing callback
            // fires.
            if (dwCookie) {
                // There was a pending callback waiting just a moment ago...
                // Clear it now.  Note: if the unadvise fires at any time
                // the call back routine will do nothing as we have cleared
                // m_dwAdviseCookie.  We call Unadvise now to prevent any
                // such callback from here on.
                // We can call Unadvise as we hold no relevant locks

                // we know we have a clock otherwise the cookie would
                // not have been set
                DbgLog((LOG_TRACE, 3, "Cancelling callback in ::Pause"));
                m_callback.Cancel(dwCookie);
                // we cannot hold the device lock while calling UnAdvise,
                // but by setting m_dwAdviseCookie to 0 above IF the
                // call back fires it will be benign.
            }


            // we will enter here with the device when we are doing
            // a restart to regain the audio. In this case, we did not
            // start the wave clock, and hence should not stop it.
            if (m_pRefClock) {
                m_pRefClock->AudioStopping();
            }
            amsndOutPause();
            SetWaveDeviceState(WD_PAUSED);

            // IF there are no buffers queued, i.e. everything has been
            // played, AND we have had an EOS then we reset the EOS flag
            // so that the next time we enter RUN we will send EOS
            // immediately.  If there are still buffers queued, then
            // we do not want to reset the state of the EOS flag.
            // We rely on the fact that the callback code will set
            // m_eSentEOS to EOS_SENT from EOS_PENDING once it gets the
            // last buffer.
            // We also rely on the amsndOutPause being synchronous.
            if (m_eSentEOS == EOS_SENT) {
                // we have, or had, an EOS in the queue.
                m_eSentEOS = EOS_NOTSENT;
            } else {
                // if we have received EOS the state should be EOS_PENDING
                // if we have not received EOS the state should be NOTSENT
                ASSERT(!m_bHaveEOS || m_eSentEOS == EOS_PENDING);
            }

        } else {
            // Next time we enter RUN we want to send EOS again... if the
            // data has run out, so remember that we have left RUNNING state.
            m_eSentEOS = EOS_NOTSENT;
        }
    }
    else if (m_State == State_Stopped)
    {
        // Any EOS received while stopped are thrown away.
        // Upstream filters must EOS us again if / when required.
        m_bHaveEOS = FALSE;
        // don't open the wave device if no connection
        if (m_pInputPin->IsConnected())
        {
            DbgLog((LOG_TRACE,2,TEXT("Waveout: Stopped->Paused")));
            m_evPauseComplete.Reset();   // We have no data
            hrIncomplete = S_FALSE;
            // or we have already received End Of Stream


            // open the wave device. We keep it open until the
            // last buffer using it is released and the allocator
            // goes into Decommit mode (unless the resource
            // manager calls ReleaseResource).
            // We will not close it as long as an app has a reference on the
            // DirectSound interface
            // We may already have it open if an app has asked us for the
            // DirectSound interfaces, and that's OK
            if (!m_bHaveWaveDevice) AcquireWaveDevice();
            hr = S_OK;

            // failing to get the wave device is not an error - we still
            // continue to work, but with no sound (ie we need to do the
            // CBaseFilter::Pause below).

            if (m_pRefClock) m_pRefClock->ResetPosition();

            // reset slaving and other stat parameters when making a transition from stop to pause
            m_pInputPin->m_Slave.ResumeSlaving( TRUE ); // reset everything
            m_pInputPin->m_Stats.Reset();

        } else {
            // not connected.  Set the event so that we do not
            // wait around in GetState()
            DbgLog((LOG_TRACE,2,TEXT("Waveout: Inactive->Paused, not connected")));
            m_evPauseComplete.Set();   // We do not need data
        }
    } else {
        ASSERT(m_State == State_Paused);
    }

    // tell the pin to go inactive and change state
    if (SUCCEEDED(hr) && SUCCEEDED(hr = CBaseFilter::Pause())) {

        // we complete the transition when we get data or EOS
        // (this might already be so if we get 2 pause commands)
        // OR we are not connected.
        hr = hrIncomplete;
    }

    return hr;
}


STDMETHODIMP CWaveOutFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: RUN")));

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;  // changed by CBaseFilter::Run

    // this will call Pause if currently Stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    MSR_START(m_idStartRunning);

    if (fsOld != State_Running) {

        // If m_eSentEOS is set it means that data is/was queued
        // up.  We still need to run to push the data through the wave
        // device.

        DbgLog((LOG_TRACE,2,TEXT("Waveout: Paused->Running")));

        LONG buffercount;
        {
            CAutoLock lck(&m_csComplete);
            m_bSendEOSOK = true;

            // we should not open the device if we have no input connection
            if (!m_pInputPin->IsConnected()) {
                ASSERT(!m_bHaveWaveDevice);
                SendComplete(FALSE);
                MSR_STOP(m_idStartRunning);
                return S_OK;
            }

            // If we have been sent EOS then we will not get any more data.
            // But we have transitioned to RUN and therefore need to send
            // another EC_COMPLETE.
            if (m_bHaveEOS && !m_eSentEOS) {
                SendComplete(FALSE);
                DbgLog((LOG_TRACE, 3, "Sending EOS in RUN as no more data will arrive"));
                MSR_STOP(m_idStartRunning);
                return S_OK;
            }

            // the queued data might be just an end of
            // stream - in which case, signal it here
            // since we are not running, we know there are no wave
            // callbacks happening, so we are safe to check this value

            // if we are not connected, then we will never get any data
            // so in this case too, don't start the wave device and
            // signal EC_COMPLETE - but succeed the Run command
            //
            // ** Done in paragraph above.  From here on we ARE connected
            //
            // if we have no wave device, then we process EOS in the
            // receive call when we reject it. This is based on the assumption
            // that we must get either a Receive or a EndofStream call (until
            // we have rejected a Receive the upstream filter has no way of knowing
            // anything is different).
            buffercount = m_lBuffers;
        }

        if (buffercount < 0) {

            // do an EC_COMPLETE right now

            //  This is where an EC_COMPLETE scheduled when were were
            //  in State_Paused state gets picked up

            SendComplete(buffercount < 0);

        } else if (!m_bHaveWaveDevice) {

            // try and get the wave device again... as we are about to run
            // our priority will have increased, except we cannot request
            // the resource while we have the filter locked.

#if 0
            hr = m_pResourceManager->RequestResource(
                        m_idResource,
                        GetOwner(),
                        (IResourceConsumer*)this);
            if (S_OK == hr) {
                // we can get it immediately...
                hr = AcquireResource(m_idResource);
            }

            if (S_OK != hr) QueueEOS();
#else
            // schedule a delayed EOS if we have no wave device --
            // but not if we are not connected since in that case we have no
            // idea about the segment length
            // delayed EC_COMPLETE
            QueueEOS();
#endif
        } else if (buffercount == 0 && !m_bHaveEOS) {
            // do nothing?

            DbgLog((LOG_TRACE, 1, "Run with no buffers present, doing nothing."));

        } else {

            // we're about to Run, so set the Slave class to recheck on reception
            // of the next sample whether we're being sourced by a push source in
            // case we need to slave to live data.
            m_pInputPin->m_Slave.RefreshModeOnNextSample( TRUE );

            // The restart is postponed until the correct start time.
            // If there is less than 5ms until the start we go
            // immediately, otherwise we get the clock to call us back
            // and start the wave device (more or less) on time.

            MSR_START(m_idRestartWave);

            // tell our reference clock that we're playing now....
            // the filter graph might be using someone else's clock
            // hence calls to get the time should be against the FILTER
            // clock (which is given to us by the filter graph)
            if (m_pRefClock && m_pClock) {

                // If there is still a significant portion of time
                // that should run before we start playing, get the
                // clock to call us back.  Otherwise restart the
                // wave device now.
                // we can only do this by using our own clock

                REFERENCE_TIME now;
                m_pClock->GetTime(&now);

                DbgLog((LOG_TIMING, 2, "Asked to run at %s.  Time now %s",
                    (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(now, CDISP_DEC)));

                // Take account of non-zero start times on the first received buffer.
                // Remove our lock for a while and hope the transition to pause completes.
                {
    #if 0           // We need extra checks if we're going to unlock
                    Unlock();
                    ASSERT( CritCheckOut(this) );
                    // Can't wait too long here....  If we don't get data, we'll just
                    // end up with GetFirstBufferStartTime == 0;
                    m_evPauseComplete.Wait(200);
                    Lock();
    #endif
                    // If the wait timed out, GetFirstBufferStartTime will be zero.  Well, we tried....
                    tStart += m_pInputPin->GetFirstBufferStartTime();
                }
                // If we need to wait more than 5ms do the wait, otherwise
                // start immediately.

                const LONGLONG rtWait = tStart - now - (5* (UNITS/MILLISECONDS));

                // Do we need to wait ?
                if (rtWait > 0) {

                    { // scope for lock

                        // have to ensure that AdviseCallback is atomic
                        // or the callback could happen before
                        // m_dwAdviseCookie is set

                        ASSERT(CritCheckIn(this));
                        ASSERT(0 == m_dwAdviseCookie);

                        // Set up a new advise callback
                        DbgLog((LOG_TRACE, 2, TEXT("Scheduling RestartWave for %dms from now"), (LONG) (rtWait/10000) ));
                        HRESULT hr = m_callback.Advise(
                            RestartWave,    // callback function
                            (DWORD_PTR) this,   // user token passed to callback
                            now+rtWait,
                            &m_dwAdviseCookie);
                        ASSERT( SUCCEEDED( hr ) );
                        ASSERT(m_dwAdviseCookie);

                        // if for some reason we failed to set up the
                        // advise we must start the device running now
                        if (!m_dwAdviseCookie) {
                            if (MMSYSERR_NOERROR == amsndOutRestart()) {
                                SetWaveDeviceState(WD_RUNNING);
                            } else {
                                SetWaveDeviceState(WD_ERROR_ON_RESTART);
                            }
                        }
                    }
                } else {
                    // we can startaudio now... the time interval is small
                    m_pRefClock->AudioStarting(m_tStart);
                    DWORD mmr = amsndOutRestart();
                    ASSERT(MMSYSERR_NOERROR == mmr);
                    SetWaveDeviceState(WD_RUNNING);
                    if (mmr) {
                        SetWaveDeviceState(WD_ERROR_ON_RESTARTA);
                    }
                }
            } else {
                // no clock... simply restart the wave device
                // we have not created our clock
                // naughty...
                DWORD mmr = amsndOutRestart();
                SetWaveDeviceState(WD_RUNNING);
                ASSERT(MMSYSERR_NOERROR == mmr);
                if (mmr) {
                    SetWaveDeviceState(WD_ERROR_ON_RESTARTB);
                }
            }
            MSR_STOP(m_idRestartWave);
        }
    }
    MSR_STOP(m_idStartRunning);

    return S_OK;
}

// We were asked to run in advance of the real start time.  Hence we set
// up an Advise on the m_callback CCallbackThread object.  All we
// need to do is start the wave device rolling.  NOTE: IF some
// event means that ::Stop has been called we do not want to restart
// the wave device.  Indeed, we may not have a wave device...
void CALLBACK CWaveOutFilter::RestartWave(DWORD_PTR thispointer)
{
    CWaveOutFilter* pFilter = (CWaveOutFilter *) thispointer;
    ASSERT(pFilter);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: RESTARTWAVE")));

    // The pFilter lock will (should!) have been taken by the CCallbackThread before it called us.
    ASSERT(CritCheckIn(pFilter));

    if (pFilter->m_dwAdviseCookie) {

        // have we lost the device ?
        pFilter->RestartWave();
    }
}


void CWaveOutFilter::RestartWave()
{
    if (m_bHaveWaveDevice) {
        // This callback should only be called if the filter is running and it
        // is not being flushed.  The filter can prevent the callback from being 
        // called by canceling the advise associated with m_dwAdviseCookie.  The
        // advise should be canceled if the filter's input pin is going to be flushed
        // and if the filter's run-pause-stop state is being changed.
        ASSERT((m_State == State_Running) && !m_pInputPin->IsFlushing());
        ASSERT(m_pRefClock);
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wave advise callback fired for filter %8x"), this));
        m_dwAdviseCookie = 0;
        m_pRefClock->AudioStarting(m_tStart);
        MSR_START(m_idRestartWave);
        DWORD mmr = amsndOutRestart();
        ASSERT(MMSYSERR_NOERROR == mmr);
        SetWaveDeviceState(mmr ? WD_ERROR_ON_RESTARTC : WD_RUNNING);
        MSR_STOP(m_idRestartWave);
    }
}

//
// We only complete the transition to pause if we have data
// and we are expecting data (i.e. connected)
//

HRESULT CWaveOutFilter::GetState(DWORD dwMSecs,FILTER_STATE *State)
{
    CheckPointer(State,E_POINTER);
    HRESULT hr = NOERROR;
    if (State_Paused == m_State)
    {
        // if we are waiting for data we return VFW_S_STATE_INTERMEDIATE
        // if we have had EOS we are not in an intermediate state

        if (m_evPauseComplete.Wait(dwMSecs) == FALSE) {
            // no data queued (the event is not set)

            // the normal case is that no buffers have been queued
            // (otherwise the event would have been triggered) but as
            // we have no interlock we cannot check that there are no
            // queued buffers.  We CAN check that we are connected.
            ASSERT(m_pInputPin->IsConnected());
            hr = VFW_S_STATE_INTERMEDIATE;
        }
    }
    *State = m_State;

    return hr;
}


// attempt to acquire the wave device. Returns S_FALSE if it is busy.
HRESULT
CWaveOutFilter::AcquireWaveDevice(void)
{
    // have we registered the device?
    HRESULT hr;

    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: AcquireWaveDevice")));
    // this is the one location when we can have the filter locked
    // while calling the resource manager.  even this is a bit iffy...
    ASSERT(CritCheckIn(this));

    if (m_pResourceManager) {
        if (m_idResource == 0) {
            hr = m_pResourceManager->Register(m_pSoundDevice->amsndOutGetResourceName(),
                              1, &m_idResource);
            if (FAILED(hr)) {
                return hr;
            }
        }

        ASSERT(!m_bHaveWaveDevice);
        ASSERT(!m_hwo);

        // attempt to acquire the resource - focus object is the
        // outer unknown for this filter.
        hr = m_pResourceManager->RequestResource(
                    m_idResource,
                    GetOwner(),
                    (IResourceConsumer*)this);
        if (S_OK != hr) {
            return S_FALSE;
        }
    }
    // else if no resource manager, carry on anyway

    // returns S_OK or an error
    hr = OpenWaveDevice();

    // tell the resource manager if we succeeded or failed (but not if
    // we postponed it)
    if (S_FALSE != hr) {

        if (m_pResourceManager) {
            m_pResourceManager->NotifyAcquire(
                        m_idResource,
                        (IResourceConsumer*) this,
                        hr);
        }
    }

    return hr;
}


inline HRESULT CWaveOutFilter::CheckRate(double dRate)
{
    ASSERT(CritCheckIn(this));      // must be in the filter critical section
    ASSERT(dRate > 0.0);

    // safe to do even if we're not connected
    return m_pSoundDevice->amsndOutCheckFormat(&m_pInputPin->m_mt, dRate);
}


//
// CWaveOutFilter::ReOpenWaveDevice - reopen the wave the device using a new format
//
// Here's how we deal with this:
//
// 1. If we're using WaveOut...
//
//      i.  If the graph is not stopped...
//              a. Reset the waveout device to release any queued buffers.
//              b. Unprepare all wave buffers.
//
//      ii. Close the wave device.
//
// 2. Set the new media type.
//
// 3.If we're using DSound...
//
//      i.   Save the current wave state.
//      ii.  Call RecreateDSoundBuffers() to create a new secondary buffer and
//              update the primary format.
//      iii. Update the wave clock's byte position data so that offsets are
//              adjusted for the new rate.
//      iv.  Set the current wave state back to the original.
//
//   Else if we're using waveout...
//
//      i. Open the waveout device with the new format.
//
// 4. Reprepare the allocator's buffers.
//
HRESULT CWaveOutFilter::ReOpenWaveDevice(CMediaType *pNewFormat)
{
    HRESULT hr = S_OK;
    waveDeviceState  wavestate = m_wavestate; // save the current wavestate

    if( !m_fDSound )
    {
        if (m_State != State_Stopped)
        {
            // we're going to stay in this state and reopen the waveout device
            // we need to make sure that no more buffers appear in the queue
            // during or after the reset process below or the buffer
            // count may get messed up - currently Receive holds the
            // filter-wide critsec to ensure this

            InterlockedIncrement(&m_lBuffers);

            if (m_hwo)
            {
                DbgLog((LOG_TRACE, 4, "Resetting the wave device in ReOpenWaveDevice, filter is %8x", this));

                amsndOutReset();
            }

            // now force the buffer count back to the normal (non-eos) 0.
            // at this point, we are sure there are no more buffers coming in
            // and no more buffers waiting for callbacks.
            ASSERT(m_lBuffers >= 0);
            m_lBuffers = 0;

            if(m_pInputPin->m_pOurAllocator)
                hr = m_pInputPin->m_pOurAllocator->ReleaseResource();

        }
        EXECUTE_ASSERT(MMSYSERR_NOERROR == amsndOutClose());
        SetWaveDeviceState(WD_CLOSED);

        m_hwo = 0;        // no longer have a wave device
    }

    if(FAILED(hr))
        return hr;

    // save the previous rate before setting the new
    DWORD dwPrevAvgBytesPerSec = m_pInputPin->m_nAvgBytesPerSec;

    m_pInputPin->SetMediaType(pNewFormat);  // set the new media type

    if (m_bHaveWaveDevice)
    {
        if (m_fDSound)
        {
            ASSERT(m_State != State_Stopped);
            ((CDSoundDevice *) m_pSoundDevice)->RecreateDSoundBuffers();

            if (m_pRefClock) {
                m_pRefClock->UpdateBytePositionData(
                                        dwPrevAvgBytesPerSec,
                                        WaveFormat()->nAvgBytesPerSec);
            }
            // Is this needed? Check.
            m_pInputPin->m_nAvgBytesPerSec = WaveFormat()->nAvgBytesPerSec;

            SetWaveDeviceState (wavestate);
        }
        else
        {
            hr = DoOpenWaveDevice();
            if (!m_hwo)
            {

                // Failed to get the device... use the resource manager
                // to try and recover?  Probably not feasible as no-one
                // within quartz would have been allowed to pick up the
                // device without the OK of the resource manager.
                DbgLog((LOG_ERROR, 1, "ReOpenWaveDevice: Failed to open device with new format"));
                return hr;
             }
             else
             {
                // if Paused we need to Pause the wave device
                if (m_State == State_Paused)
                {
                    amsndOutPause();
                    SetWaveDeviceState(WD_PAUSED);
                } else
                {
                    ASSERT(m_State == State_Running);
                    //DbgLog((LOG_TRACE, 2, "ReOpenWaveDevice: Change of format while running"));
                    SetWaveDeviceState (wavestate);
                }

            }
        }

        if( SUCCEEDED( hr ) )
        {
            //
            // reset slaving parameters after a dynamic format change!
            // in dv capture graphs, for instance, we may get dynamic format changes
            // while we're slaving
            //
            m_pInputPin->m_Slave.ResumeSlaving( TRUE ); // (TRUE = reset all slave params)
        }

        // If we do this for DSound we need to correctly release too!
        if(m_pInputPin->m_pOurAllocator)
            // reprepare our allocator's buffers
            hr = m_pInputPin->m_pOurAllocator->OnAcquire((HWAVE) m_hwo);

    }

    return hr;
}


//
// get the wave device if not already open, taking account of
// playback rate
//

HRESULT CWaveOutFilter::DoOpenWaveDevice(void)
{
    WAVEFORMATEX *pwfx = WaveFormat();
    UINT err;

    // m_pInputPin->m_dRate (and the m_dRate it shadows) are set in
    // NewSegment independent of m_dRate. if we can't open the wave
    // device at a particular rate they are different. Receive will
    // eventually fail in this case
    //
    // ASSERT( m_pInputPin->CurrentRate() == m_dRate ); // paranoia

    if (!pwfx)
    {
        DbgLog((LOG_ERROR, 0, TEXT("CWaveOutFilter::DoOpenWaveDevice !pwfx")));
        return (S_FALSE);  // not properly connected.  Ignore this non existent wave data
    }

    // !!! adjust based on speed?
    // !!! for the moment, only for PCM!!!
    double dRate = 1.0;
    if (m_pImplPosition) {
        // First use IMediaSeeking
        HRESULT hr = m_pImplPosition->GetRate(&dRate);
        if (FAILED(hr)) {
            // if that fails, try IMediaPosition
            hr = m_pImplPosition->get_Rate(&dRate);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("Waveout: Failed to get playback rate")));
                ASSERT(dRate == 1.0);
            }
        }
    }

#ifdef SIMULATEBROKENDEVICE
    dRate *= SIMULATEBROKENDEVICE;
#endif

    DWORD nAvgBytesPerSecAdjusted;

    ASSERT(CritCheckIn(this));       // must be in the filter critical section
    ASSERT(!m_hwo);
    err = amsndOutOpen(
        &m_hwo,
        pwfx,
        dRate,
        &nAvgBytesPerSecAdjusted,
        (DWORD_PTR) &CWaveOutFilter::WaveOutCallback,
        (DWORD_PTR) this,
        CALLBACK_FUNCTION);

    // !!! if we can't open the wave device, should we do a
    // sndPlaySound(NULL) and try again? -- now done by MMSYSTEM!

    if (MMSYSERR_NOERROR != err) {
#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText(err, message, sizeof(message)/sizeof(TCHAR));
        DbgLog((LOG_ERROR,0,TEXT("Error opening wave device: %u : %s"), err, message));
#endif
        m_hwo = NULL;
        SetWaveDeviceState(WD_ERROR_ON_OPEN);
        m_lastWaveError = err;
        if(m_fDSound)
            return E_FAIL;
        else
            return err == MMSYSERR_ALLOCATED ? S_FALSE : E_FAIL;
    }

    if(dRate == 1.0)
    {
        ASSERT(nAvgBytesPerSecAdjusted == (DWORD)(pwfx->nAvgBytesPerSec));
    }

    //  Cache the bytes per second we set for the clock to use
    SetWaveDeviceState(WD_OPEN);
    m_pInputPin->m_nAvgBytesPerSec = nAvgBytesPerSecAdjusted;

    m_dRate = dRate;

    ASSERT(m_hwo);
    DbgLog((LOG_TRACE,1,TEXT("Have wave out device: %u"), m_hwo));
    if (m_pRefClock) m_pRefClock->ResetPosition();
        return S_OK;
}


// open the wave device if not already open
// called by the wave allocator at Commit time
// returns S_OK if opened successfully, or an error if not.
HRESULT
CWaveOutFilter::OpenWaveDevice(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice")));
    ASSERT(!m_hwo);

#ifdef LATER  // bug 26045 - potential reason
    if (m_hwo) {
        // the most likely cause for the device still being open is that we
        // lost the device (via ReleaseResource) and were then told to
        // reacquire the device before actually releasing it.
        m_bHaveWaveDevice = TRUE;   // we will still need to restart
        return S_FALSE;
    }
#endif

    //  If application has forced acquisition of resources just return
    if (m_dwLockCount != 0) {
        ASSERT(m_hwo);
        return S_OK;
    }

    HRESULT hr = DoOpenWaveDevice();
    if (S_OK != hr) {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice: DoOpenWaveDevice returned 0x%08X"), hr));
        return hr;
    }
    // pause the device even if we decide to postpone the rest of the open
    amsndOutPause();
    SetWaveDeviceState(WD_PAUSED);

    if (m_fVolumeSet) {
        m_BasicAudioControl.PutVolume();
    }

    // tell the allocator to PrepareHeader its buffers
    if(m_pInputPin->m_pOurAllocator) {
        hr = m_pInputPin->m_pOurAllocator->OnAcquire((HWAVE) m_hwo);
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OpenWaveDevice: OnAcquire returned 0x%08X"), hr));

        if (FAILED(hr)) {
            amsndOutClose();
            SetWaveDeviceState(WD_CLOSED);
            m_hwo = 0;
            ASSERT(!m_bHaveWaveDevice);
            return hr;
        } else {
            ASSERT(S_OK == hr);
        }
    }

    // now we can accept receives
    m_bHaveWaveDevice = TRUE;

    return S_OK;
}

// close the wave device
//
// should only be called when wave device is open
HRESULT
CWaveOutFilter::CloseWaveDevice(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CloseWaveDevice")));
    ASSERT(m_hwo);
    if (m_hwo && m_dwLockCount == 0) {
#ifdef THROTTLE
        // turn off video throttling
        SendForHelp(m_nMaxAudioQueue);
#endif // THROTTLE
        EXECUTE_ASSERT(MMSYSERR_NOERROR == amsndOutClose());
        SetWaveDeviceState(WD_CLOSED);
        m_hwo = NULL;
    }

    return NOERROR;
}

// Send EC_COMPLETE to the filter graph if we haven't already done so
//
// bRunning is TRUE if we've actually got a wave device we're sending
// data to
void CWaveOutFilter::SendComplete(BOOL bRunning, BOOL bAbort)
{
    CAutoLock lck(&m_csComplete);

    if (bAbort)
    {
        // In this case signal an abort (but we still send EC_COMPLETE
        // in case some app doesn't handle the abort).
        NotifyEvent(EC_ERRORABORT, VFW_E_NO_AUDIO_HARDWARE, 0);
    }

    if (bRunning) {
        EXECUTE_ASSERT(InterlockedIncrement(&m_lBuffers) == 0);
    }

    if (m_bSendEOSOK) {
        //  Balance count
        ASSERT(m_State == State_Running);
        m_eSentEOS = EOS_SENT;
        NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
    }
}

//
//  Schedule a 'complete' and send it if suitable
//
HRESULT CWaveOutFilter::ScheduleComplete(BOOL bAbort)
{
    //
    //  Can only be called when we're synchronized
    //
    ASSERT(CritCheckIn(this));

    HRESULT hr = m_pInputPin->CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    //
    //  Check we didn't do it already
    //
    if (m_eSentEOS) {
        return VFW_E_SAMPLE_REJECTED_EOS;
    }

    //
    //  Don't allow any more.  Set it now in case decrementing the buffer
    //  count causes the callback code to send EOS
    //
    m_eSentEOS = EOS_PENDING;

    // The EC_COMPLETE WILL now be sent.  Either immediately if we have
    // no data queued, or when the last buffer completes its callback.
    // We will NOT get any more data.

    //
    //  Tell the wave device to do it
    //
    if (InterlockedDecrement(&m_lBuffers) < 0 && m_State == State_Running) {
        // no buffers queued, and we are running, so send it now

        SendComplete(TRUE, bAbort);

    }
    return S_OK;
}

#ifdef THROTTLE

// Send quality notification to m_piqcSink when we run short of buffers
// n is the number of buffers left
HRESULT CWaveOutFilter::SendForHelp(int n)
{
    if (m_eSentEOS) {

        // we expect to run out of data at EOS, but we have to send
        // a quality message to stop whatever throttling is going on
        // Thus, if we had previously sent a message, send another now
        // to undo the throttling

        if (m_nLastSent && m_nLastSent<m_nMaxAudioQueue) {
            n=m_nMaxAudioQueue;
        } else {
            return NOERROR; // we expect to run out of data at EOS
        }

    }

    // This is heuristricky

#if 0
// don't look at the allocator.  We maintain the maximum size the
// queue gets to, which means that if a source only sends us a few
// buffers we do not think we are starving.
    ALLOCATOR_PROPERTIES AlProps;
    HRESULT hr = m_pInputPin->m_pOurAllocator->GetProperties(&AlProps);
    int nMaxBuffers = AlProps.cBuffers;    // number of buffers in a full queue
#endif

    // No "Mark Twain".
    // Don't bother shouting the same number continuously.
    // If we are equal or only one worse than last thing sent, and we're not getting
    // too near the bottom (last 1/4), just go home.
    // We expect continual +/-1 fluctuation anyway.

    if (  (n==m_nLastSent)
       || ((n==m_nLastSent-1) &&  (4*n > m_nMaxAudioQueue))
       )
    {
        return NOERROR;
    }

    Quality q;
    q.Type = Famine;
    q.TimeStamp = 0;               // ??? a lie
    q.Late = 0;                // ??? a lie

    m_nLastSent = n;
    ASSERT(m_nMaxAudioQueue);
    q.Proportion = (n>=m_nMaxAudioQueue-1 ? 1100 : (1000*n)/m_nMaxAudioQueue);

    if (m_piqcSink) {
        DbgLog((LOG_TRACE, 0, TEXT("Sending for help n=%d, max = %d"),
                n, m_nMaxAudioQueue));
        // By the way - IsEqualObject(m_pGraph, m_piqSink) can be quite expensive.
        // and simple equality does not hack it.
        m_piqcSink->Notify(this, q);
    }
    return NOERROR;
}

#endif // THROTTLE



// If you want to do 3D sound, you should use the IDirectSound3DListener
// and IDirectSound3DBuffer interfaces.  IAMDirectSound never worked, so I
// am removing support for it. - DannyMi 5/6/98

// Give the IDirectSound interface to anyone who wants it
//
HRESULT CWaveOutFilter::GetDirectSoundInterface(LPDIRECTSOUND *lplpds)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpds) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetDirectSoundInterface(lplpds);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** GotDirectSoundInterface")));
            m_cDirectSoundRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide DirectSound interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// Give the IDirectSoundBuffer interface of the primary to anyone who wants it
//
HRESULT CWaveOutFilter::GetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpdsb) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetPrimaryBufferInterface(lplpdsb);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** Got PrimaryBufferInterface")));
            m_cPrimaryBufferRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide primary buffer interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// Give the IDirectSoundBuffer interface of the secondary to anyone who wants it
//
HRESULT CWaveOutFilter::GetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb)
{
    return E_NOTIMPL;

#if 0
    // only for DSound
    if (!m_fDSound) {
        return E_NOTIMPL;
        // should probably create a new error message
    }

    // We have to be connected first to know our format
    if (!m_pInputPin->IsConnected())
        return E_UNEXPECTED;

// we can't open the wave device until pause - bad things happen
// Don't worry, the device will handle this
#if 0
    // They are asking for the direct sound interface before we've opened
    // DirectSound.  Better open it now.
    if (!m_bHaveWaveDevice) {
        CAutoLock lock(this);   // doing something real... better take critsect
    if (AcquireWaveDevice() != S_OK)
        return E_FAIL;
    }
#endif

    if (lplpdsb) {
        // See if the sound device we're using can give us the interface
        HRESULT hr = ((CDSoundDevice*)m_pSoundDevice)->amsndGetSecondaryBufferInterface(lplpdsb);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE,1,TEXT("*** Got SecondaryBufferInterface")));
            m_cSecondaryBufferRef++;
        } else {
            DbgLog((LOG_ERROR,1,TEXT("*** Sound device can't provide secondary buffer interface")));
        }
        return hr;
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSound interface
//
HRESULT CWaveOutFilter::ReleaseDirectSoundInterface(LPDIRECTSOUND lpds)
{
    return E_NOTIMPL;

#if 0
    if (lpds) {
        if (m_cDirectSoundRef <= 0) {
            DbgLog((LOG_ERROR,1,TEXT("Releasing DirectSound too many times!")));
            return E_FAIL;
        } else {
            lpds->Release();
            m_cDirectSoundRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSoundBuffer interface of the primary
//
HRESULT CWaveOutFilter::ReleasePrimaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb)
{
    return E_NOTIMPL;

#if 0
    if (lpdsb) {
        if (m_cPrimaryBufferRef <= 0) {
                DbgLog((LOG_ERROR,1,TEXT("Releasing Primary Buffer too many times!")));
            return E_FAIL;
        } else {
            lpdsb->Release();
            m_cPrimaryBufferRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}


// App wants to release the IDirectSoundBuffer interface of the secondary
//
HRESULT CWaveOutFilter::ReleaseSecondaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb)
{
    return E_NOTIMPL;

#if 0
    if (lpdsb) {
        if (m_cSecondaryBufferRef <= 0) {
                DbgLog((LOG_ERROR,1,TEXT("Releasing Secondary Buffer too many times!")));
            return E_FAIL;
        } else {
            lpdsb->Release();
            m_cSecondaryBufferRef--;
            return NOERROR;
        }
    }
    return E_INVALIDARG;
#endif
}

// App wants to set the focus window for the DSound based renderer
//
HRESULT CWaveOutFilter::SetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff)
{
   CAutoLock lock(this);
   // handle the call only if DSound is the renderer we are using
   if (m_fDSound)
       return ((CDSoundDevice*)m_pSoundDevice)->amsndSetFocusWindow (hwnd, bMixingOnOrOff);
   else
       return E_FAIL ;
}

// App wants to get the focus window for the DSound based renderer
//
HRESULT CWaveOutFilter::GetFocusWindow (HWND * phwnd, BOOL * pbMixingOnOrOff)
{
   // handle the call only if dsound is the renderer we are using
   if (m_fDSound)
       return ((CDSoundDevice*)m_pSoundDevice)->amsndGetFocusWindow (phwnd, pbMixingOnOrOff);
   else
       return E_FAIL ;
}


/* Constructor */

#pragma warning(disable:4355)
CWaveOutFilter::CWaveOutFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr,
    const AMOVIESETUP_FILTER* pSetupFilter,
    CSoundDevice *pDevice)
    : CBaseFilter(NAME("WaveOut Filter"), pUnk, (CCritSec *) this, *(pSetupFilter->clsID))
    , m_DS3D(this, phr)
    , m_DS3DB(this, phr)
    , m_fWant3D(FALSE)
    , m_BasicAudioControl(NAME("Audio properties"), GetOwner(), phr, this)
    , m_pImplPosition(NULL)
    , m_lBuffers(0)
    , m_hwo(NULL)
    , m_fVolumeSet(FALSE)
    , m_fHasVolume(FALSE)
    , m_dwAdviseCookie(0)
    , m_pResourceManager(NULL)
    , m_idResource(0)
    , m_bHaveWaveDevice(FALSE)
    , m_bActive(FALSE)
    , m_evPauseComplete(TRUE)    // Manual reset
    , m_eSentEOS(EOS_NOTSENT)
    , m_bHaveEOS(FALSE)
    , m_bSendEOSOK(false)
    , m_fFilterClock(WAVE_NOCLOCK)
    , m_pRefClock(NULL)     // we start off without a clock
    , m_llLastPos(0)
    , m_pSoundDevice (pDevice)
    , m_callback((CCritSec *) this)
    , m_dwEOSToken(0)
#ifdef THROTTLE
    , m_piqcSink(NULL)
    , m_nLastSent(0)
    , m_nMaxAudioQueue(0)
#endif
    , m_pSetupFilter(pSetupFilter)
    , m_dRate(1.0)
    , m_wavestate( WD_UNOWNED )
    , m_fDSound( FALSE )
#if 0
    , m_cDirectSoundRef( 0 )
    , m_cPrimaryBufferRef( 0 )
    , m_cSecondaryBufferRef( 0 )
#endif
    , m_dwScheduleCookie(0)
    , CPersistStream(pUnk, phr)
    , m_fUsingWaveHdr( FALSE )
    , m_dwLockCount( 0 )
    , m_pGraphStreams( NULL )
    , m_pInputPin(NULL)
    , m_lastWaveError(MMSYSERR_NOERROR)
{
     if (!FAILED(*phr)) {
#ifdef PERF
        m_idStartRunning  = MSR_REGISTER("WaveOut device transition to run");
        m_idRestartWave   = MSR_REGISTER("Restart Wave device");
        m_idReleaseSample = MSR_REGISTER("Release wave sample");
#endif
        if (pDevice) {

            // Needs to be updated if we add a new MidiRenderer filter!
            if (IsEqualCLSID(*pSetupFilter->clsID, CLSID_AVIMIDIRender))
            {
                m_lHeaderSize = sizeof(MIDIHDR);
            }
            else
            {
                // Now that we've found one device which fails if WAVEHDR size
                // not explicitly set (as opposed to using a MIDIHDR size as we
                // were doing)
                m_lHeaderSize = sizeof(WAVEHDR);
            }

            if (IsEqualCLSID(*pSetupFilter->clsID, CLSID_DSoundRender))
            {
                /* Create the single input pin */
                m_fDSound = TRUE;
                CDSoundDevice* pDSoundDevice = static_cast<CDSoundDevice*>( pDevice );
                pDSoundDevice->m_pWaveOutFilter = this;
            }

            m_pInputPin = new CWaveOutInputPin(
                    this,           // Owning filter
                    phr);           // Result code

            ASSERT(m_pInputPin);
            if (!m_pInputPin)
                *phr = E_OUTOFMEMORY;
            else {
                // this should be delayed until we need it
                // except... we need to know how many bytes are outstanding
                // in the device queue
                m_pRefClock = new CWaveOutClock( this, GetOwner(), phr, new CAMSchedule(CreateEvent(NULL, FALSE, FALSE, NULL)) );
                // what should we do if we fail to create a clock


                // even on systems where symbols are haphazard
                // give ourselves a fighting chance of locating
                // the wave device variables
                m_debugflag = FLAG('hwo>');
                m_debugflag2 = FLAG('eos>');

            }
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("No device instantiated when creating waveout filter")));
            *phr = E_OUTOFMEMORY;
        }
    }
}

#pragma warning(default:4355)

/* Destructor */

CWaveOutFilter::~CWaveOutFilter()
{
    ASSERT((m_hwo == NULL) == (m_dwLockCount == 0));

    if (m_dwLockCount != 0) {
        m_dwLockCount = 1;
        Reserve(AMRESCTL_RESERVEFLAGS_UNRESERVE, NULL);
    }
    ASSERT(m_hwo == NULL);
    ASSERT( m_pGraphStreams == NULL );

    /* Release our reference clock if we have one */

    SetSyncSource(NULL);
    // This would be done in the base class, but we should get
    // rid of it in case it is us.
    // I think we can assert that m_pClock (the base member) IS null

    if (m_pRefClock) {
        CAMSchedule *const pSched = m_pRefClock->GetSchedule();
        delete m_pRefClock;
        EXECUTE_ASSERT(
            CloseHandle(pSched->GetEvent())
        );
        delete pSched;
        m_pRefClock = NULL;
    }
    // The clock in the base filter class will be destroyed with the base class
    // It had better not be pointing to us...
    
    // CancelAllAdvises() must be called before m_pSoundDevice is deleted.  The 
    // Direct Sound Renderer can crash if the advises are canceled after
    // m_pSoundDevice is destroyed.  For more information, see bug 270592 
    // "The (MMSYSERR_NOERROR == amsndOutClose()) ASSERT fired in 
    // CWaveOutFilter::CloseWaveDevice()".  This bug is in the Windows Bugs
    // database.
    m_callback.CancelAllAdvises();

    /* Delete the contained interfaces */

    delete m_pInputPin;

    delete m_pImplPosition;

    delete m_pSoundDevice;

#ifdef THROTTLE
    if (m_piqcSink) {
        m_piqcSink->Release();
    }
#endif // THROTTLE
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CWaveOutFilter::NonDelegatingQueryInterface(REFIID riid,
                            void ** ppv)
{
    CheckPointer(ppv,E_POINTER);
    if (IID_IReferenceClock == riid) {

        // !!! need to check here that we have a good wave device....
        // !!! unfortunately, they'll ask for a clock before we can
        // check our wave device!
        //...should not be necessary.  If we do not have a good wave device
        //we will revert to using system time.

        if (!m_pRefClock) {
            DbgLog((LOG_TRACE, 2, TEXT("Waveout: Creating reference clock...")));
            HRESULT hr = S_OK;
            m_pRefClock = new CWaveOutClock( this, GetOwner(), &hr, new CAMSchedule(CreateEvent(NULL, FALSE, FALSE, NULL)) );

            if (m_pRefClock == NULL) {
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                delete m_pRefClock;
                m_pRefClock = NULL;
                return hr;
            }
            // now... should we also SetSyncSource?
        }
        return m_pRefClock->NonDelegatingQueryInterface(riid, ppv);
    }

    else if (IID_IMediaPosition == riid || riid == IID_IMediaSeeking) {
    if (!m_pImplPosition) {
        HRESULT hr = S_OK;
        m_pImplPosition = new CARPosPassThru(
                    this,
                    &hr,
                    m_pInputPin);
        if (!m_pImplPosition || (FAILED(hr))) {
            if (m_pImplPosition) {
                delete m_pImplPosition;
                m_pImplPosition = NULL;
            } else {
                if (!(FAILED(hr))) {
                hr = E_OUTOFMEMORY;
                }
            }
            return hr;
        }
    }
    return m_pImplPosition->NonDelegatingQueryInterface(riid, ppv);

    } else if (IID_IBasicAudio == riid) {
        return m_BasicAudioControl.NonDelegatingQueryInterface(riid, ppv);

    } else if (IID_IQualityControl == riid) {
        return GetInterface((IQualityControl*)this, ppv);

    } else if (IID_IAMDirectSound == riid) {
        DbgLog((LOG_TRACE, 3, TEXT("*** QI CWaveOutDevice for IAMDirectSound")));
        return GetInterface((IAMDirectSound*)this, ppv);

    } else if (IID_IDirectSound3DListener == riid) {
        DbgLog((LOG_TRACE,3,TEXT("*** QI for IDirectSound3DListener")));
    m_fWant3D = TRUE;    // they asked for it!
        return GetInterface((IDirectSound3DListener *)&(this->m_DS3D), ppv);

    } else if (IID_IDirectSound3DBuffer == riid) {
        DbgLog((LOG_TRACE,3,TEXT("*** QI for IDirectSound3DBuffer")));
    m_fWant3D = TRUE;    // they asked for it!
        return GetInterface((IDirectSound3DBuffer *)&(this->m_DS3DB), ppv);

    } else if ((*m_pInputPin->m_mt.FormatType() == FORMAT_WaveFormatEx) &&
           (riid == IID_ISpecifyPropertyPages) ) {
    return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);

    } else  if (riid == IID_IPersistPropertyBag) {
        return GetInterface((IPersistPropertyBag *)this, ppv);

    } else  if (riid == IID_IPersistStream) {
        return GetInterface((IPersistStream *)this, ppv);

    } else  if (riid == IID_IAMResourceControl) {
        return GetInterface((IAMResourceControl *)this, ppv);

    } else if (riid == IID_IAMAudioRendererStats) {
        return GetInterface((IAMAudioRendererStats *)this, ppv);

    } else if (riid == IID_IAMClockSlave) {
        return GetInterface((IAMClockSlave *)(this), ppv);

    } else {
    
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

#ifdef COMMENTARY

How to run with external clocks:

All the discussion below assumes that WAVE_OTHERCLOCK is in effect.

Setup:

The wave device remembers how much data it has played (see NextHdr()).

It does this by storing m_stBufferStart - the stream time of a buffer
passed to the audio device - and remembering how much data has been
played.  From this the device can be queried for its position, and the
current stream time calculated.

We assume that the external clock is running at approximately the
same rate as wall clock time, which approximately matches the rate
of the audio device itself.  On this basis adjustments should be
fairly small.

When a buffer is received in Pause we simply add it to the device
queue.  At this point the device is static and we have no timing
information.  The longer this queue the more inexact any adjustment
will be.

When a buffer is received while running we have 3 possibilities
1.  write it to the device - it will be played contiguously
2.  drop it
3.  write silence

If the buffer is not a sync point (does not have valid time
stamps) we always take option 1.

Otherwise, to decide which option we take we:

A:  get the time from the current clock
B:  get the current wave position
C:  subtract from the "last" written position to get an estimate of
    how much data is left in the device queue, and thus the
    approximate time at which sound would stop playing

D:  calculate the overlap/underlap.  If it is not significant
    take option 1, ELSE

E:  IF there is a gap (the time for this buffer is later than the
    current end point) we write silence by pausing the device
F:  ELSE we drop this buffer

#endif

STDMETHODIMP CWaveOutFilter::SetSyncSource(IReferenceClock *pClock)
{
    // if there is really no change, ignore...

    DbgLog((LOG_TRACE, 3, "wo: SetSyncSource to clock %8x", pClock));

    if (pClock == m_pClock) {
        return S_OK;
    }

    // Previously we only allowed dynamic clock changes if we weren't the clock,
    // but this causes problems if a slaving and non-slaving renderer are in the
    // same graph, so only allow clock changes while we're stopped.
    if ( State_Stopped != m_State ) {
        return VFW_E_NOT_STOPPED;
    }
    //    
    // Remember that when we're using dsound AND slaving we need to explicitly set 
    // dsound to use software buffers, so if the clock is ever allowed to be changed 
    // dynamically the dsound buffer will need to be recreated if the clock change 
    // moves to/from slaving.
    //

    HRESULT hr;

    { // scope for autolock
        CAutoLock serialize(this);

        if (!pClock) {
            // no clock...
            m_fFilterClock = WAVE_NOCLOCK;
            if (m_dwScheduleCookie)
            {
                m_callback.Cancel( m_dwScheduleCookie );
                m_dwScheduleCookie = 0;
            }
        } else {

            m_fFilterClock = WAVE_OTHERCLOCK;     // assume not our clock
            if (m_pRefClock) {
                // we have a clock... is this now the filter clock?
                DbgLog((LOG_TRACE, 2, "wo: SetSyncSource to clock %8x (%8x)",
                        pClock, m_pRefClock));
                if (IsEqualObject(pClock, (IReferenceClock *)m_pRefClock)) 
                {
                    m_fFilterClock = WAVE_OURCLOCK;
                }
                else if (m_dwScheduleCookie)
                {
                    m_callback.Cancel( m_dwScheduleCookie );
                    m_dwScheduleCookie = 0;
                }

                //
                // Need to run even when not we're not the clock, in case the app 
                // wants to use our clock for slaving video to audio, independent of 
                // who is the graph clock (wmp8 slaves this way for network content?). 
                //
                EXECUTE_ASSERT(SUCCEEDED(
                    m_callback.ServiceClockSchedule( m_pRefClock,
                        m_pRefClock->GetSchedule(), &m_dwScheduleCookie )
                ));
            }
        }

        hr = CBaseFilter::SetSyncSource(pClock);

        // if we have an existing advise with the callback object we cannot
        // cancel it while holding the filter lock.  because if the callback
        // fires it will attempt to grab the filter lock in its processing.
        // setting a new clock will reset the advise time

    }    // end of autolock scope

    m_callback.SetSyncSource(pClock);
    return hr;
}

// you may acquire the resource specified.
// return values:
//  S_OK    -- I have successfully acquired it
//  S_FALSE -- I will acquire it and call NotifyAcquire afterwards
//  VFW_S_NOT_NEEDED: I no longer need the resource
//  FAILED(hr)-I tried to acquire it and failed.

STDMETHODIMP
CWaveOutFilter::AcquireResource(LONG idResource)
{
    HRESULT hr;
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: AcquireResource")));

    // if stopped, or actually stopping now, then don't need it
    // or if we have cancelled our request we no longer want it
    if ((m_State == State_Stopped) ||
    (!m_bActive))
    {
        hr = VFW_S_RESOURCE_NOT_NEEDED;
    } else {

        if (m_bHaveWaveDevice) {
            // actually we have it thanks
            hr = S_OK;
        } else {
            ASSERT(!m_hwo);

            // it is possible that we lost the device, rejected a sample
            // and so will not get any more data until we restart.  BUT
            // before the last sample was freed we have been told that we
            // should get the device again.  So... we still have the actual
            // device open, but still need to restart the graph in order
            // to push data again.  This will be indicated if OpenWaveDevice
            // returns S_FALSE

            hr = OpenWaveDevice();

            if (S_OK == hr) {

            // the wave device is left in PAUSED state

            // need to restart pushing on this stream
            NotifyEvent(EC_NEED_RESTART, 0, 0);

            // if we have not yet rejected a sample we do not need
            // to restart the graph.  This is an optimisation that
            // we can add

            } else {
            DbgLog((LOG_ERROR, 1, "Error from OpenWaveDevice"));
            }
        }
    }

    return hr;
}

// Please release the resource.
// return values:
//  S_OK    -- I have released it (and want it again when available)
//  S_FALSE -- I will call NotifyRelease when I have released it
//  other   something went wrong.
STDMETHODIMP
CWaveOutFilter::ReleaseResource(LONG idResource)
{
    // force a release of the wave device
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: ReleaseResource")));
    HRESULT hr;

    if ((idResource != m_idResource) ||
        (m_hwo == NULL)) {

        // that's not the one we've got - done with it
        // -- we may have validly just released it
        hr = S_OK;
#if 0
    } else if (m_cDirectSoundRef || m_cPrimaryBufferRef ||
                            m_cSecondaryBufferRef) {
        // This will never happen.  Resource manager is not used when
        // using the DSound renderer
        DbgBreak("*** THIS SHOULD NEVER HAPPEN ***");
        DbgLog((LOG_TRACE, 2, "Told to release wave device - but I can't!"));
        DbgLog((LOG_TRACE, 2, "Some app has a reference count on DSound"));
        // Sorry, we can't give up the wave device yet, some app has a reference
        // count on DirectSound
        hr = S_FALSE;
#endif
    } else if (m_dwLockCount == 0) {
        DbgLog((LOG_TRACE, 2, "Told to release wave device"));

        // block receives
        m_bHaveWaveDevice = FALSE;
        // no more wave data will be accepted

        // prevent anyone using the wave clock
        if (m_pRefClock) {
            m_pRefClock->AudioStopping();
        }

        // if there was a callback pending to restart the wave device
        // remove it now
        if (m_dwAdviseCookie) {
            m_callback.Cancel(m_dwAdviseCookie);
            m_dwAdviseCookie = 0;
        }

        //  This will send EC_COMPLETE if we have received EndOfStream
        //  Otherwise we may not be in running state
        //  Might as well make sure we get an EC_COMPLETE anyway
        //  provided we're running
        if (m_State != State_Running) {
            InterlockedIncrement(&m_lBuffers);
        }
        amsndOutReset();
        if (m_State != State_Running) {
            InterlockedDecrement(&m_lBuffers);
        }
        DbgLog((LOG_TRACE, 3, "Resetting the wave device in RELEASE RESOURCE, filter is %8x", this));

        if(m_pInputPin->m_pOurAllocator) {
            hr = m_pInputPin->m_pOurAllocator->ReleaseResource();
        } else {
            hr = S_OK;
        }
        if (S_OK == hr) {
            // release done - close device
            CloseWaveDevice();
        }
    } else {
        //  Locked
        ASSERT(m_hwo);
        hr = S_FALSE;
    }
    return hr;
}

// if our AcquireResource method is called when there are unlocked samples
// still outstanding, we will get S_FALSE from the allocator's OnAcquire.
// When all buffers are then freed, it will complete the acquire and then
// call back here for us to finish the AcquireResource job.
HRESULT
CWaveOutFilter::CompleteAcquire(HRESULT hr)
{
    CAutoLock lock(this);
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CompleteAcquire")));

    ASSERT(!m_bHaveWaveDevice);

    // since we released the allocator critsec a moment ago, the state
    // may have been changed by a stop, in which case the device will have been
    // closed
    if (!m_hwo) {
        return S_FALSE;
    }

    if (S_OK == hr) {
        amsndOutPause();
        SetWaveDeviceState(WD_PAUSED);

        // now we can accept receives
        m_bHaveWaveDevice = TRUE;

        // need to restart pushing on this stream
        NotifyEvent(EC_NEED_RESTART, 0, 0);
    } else {
        if (FAILED(hr)) {
            ASSERT(!m_bHaveWaveDevice);
            CloseWaveDevice();
        }
    }

    if (m_pResourceManager) {
        m_pResourceManager->NotifyAcquire(
                    m_idResource,
                    (IResourceConsumer*) this,
                    hr);
    }
    return S_OK;
}

//
// override JoinFilterGraph method to allow us to get an IResourceManager
// interface
STDMETHODIMP
CWaveOutFilter::JoinFilterGraph(
    IFilterGraph* pGraph,
    LPCWSTR pName)
{
    CAutoLock lock(this);

    // if the sound device does its own resource management, do not try to
    // do our own. DSound based device will do its own.

    HRESULT hr = CBaseFilter::JoinFilterGraph(pGraph, pName);

    // cache the IAMGraphStreams interface on the way in
    if( SUCCEEDED( hr ) )
    {
        if( pGraph )
        {
            HRESULT hrInt = pGraph->QueryInterface( IID_IAMGraphStreams, (void **) &m_pGraphStreams );
            ASSERT( SUCCEEDED( hrInt ) ); // shouldn't ever fail
            if( SUCCEEDED( hrInt ) )
            {
                // don't hold a refcount or it will be circular. we will
                // be called JoinFilterGraph(NULL) before it goes away
                m_pGraphStreams->Release();
            }
        }
        else
        {
            m_pGraphStreams = NULL;
        }
    }

    if (m_pSoundDevice->amsndOutGetResourceName() == NULL)
        return hr ;

    if (SUCCEEDED(hr)) {
        if (pGraph) {
            HRESULT hr1 = pGraph->QueryInterface(
                        IID_IResourceManager,
                        (void**) &m_pResourceManager);
            if (SUCCEEDED(hr1)) {
                // don't hold a refcount or it will be circular. we will
                // be called JoinFilterGraph(NULL) before it goes away
                m_pResourceManager->Release();
            }
        } else {
            // leaving graph - interface not valid
            if (m_pResourceManager) {

                // we may not yet have cancelled the request - do it
                // now - but don't close the device since the
                // allocator is still using it.
                // it's safe to call this even if we have cancelled the
                // request.
                m_pResourceManager->CancelRequest(
                            m_idResource,
                            (IResourceConsumer*)this);
            }

            m_pResourceManager = NULL;
        }
    }
    return hr;
}

// called by CWaveAllocator when it has finished with the device
void
CWaveOutFilter::OnReleaseComplete(void)
{

    // remember whether to cancel or release
    BOOL bShouldRelease = FALSE;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: OnReleaseComplete")));

    {
        CAutoLock lock(this);

        // if this was not a forced-release, this will not have been set yet
        m_bHaveWaveDevice = FALSE;

        // we can close the device now
        if (m_hwo) {
            CloseWaveDevice();
            bShouldRelease = TRUE;
        } else {
            // if we're cancelling without the wave device we can't be active
            ASSERT(!m_bActive);
        }

        // must release the filter critsec before calling the resource
        // manager as he could be calling us with the mutex and filter lock
        // in the reverse order. Releasing here is safe because:

        // 1. if we have the device and are releasing it voluntarily, then
        // m_bActive must be false and hence if he calls back at this
        // moment our ReleaseResource will see we don't have it.

        // 2. if we are releasing involuntarily, the resource manager
        // will not call us back until we call NotifyRelease.

        // 3. if we don't have the device and are calling cancel, then we are not
        // active and hence our AcquireResource will report that
        // we don't want the device.

        // 4. releasing or cancelling on a resource we don't have (because
        // an intervening callback got a "don't want" return) is safe.

    }

    // tell the resource manager we've released it
    if (m_pResourceManager) {
        if (bShouldRelease) {
            // do we want it back when it becomes available?
            // - only if m_bActive

            m_pResourceManager->NotifyRelease(
                        m_idResource,
                        (IResourceConsumer*)this,
                        m_bActive);
        } else {
            m_pResourceManager->CancelRequest(
                        m_idResource,
                        (IResourceConsumer*)this);
        }
    }
}

#ifdef DEBUG
BOOL IsPreferredRendererWave(void)
{
    // read the registry to override the default ??
    extern const TCHAR * pBaseKey;
    TCHAR szInfo[50];
    HKEY hk;
    BOOL fReturn = FALSE;
    DWORD lReturn;
    /* Construct the global base key name */
    wsprintf(szInfo,TEXT("%s\\%s"),pBaseKey,TEXT("AudioRenderer"));

    /* Create or open the key for this module */
    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,   // Handle of an open key
                 szInfo,         // Address of subkey name
                 (DWORD) 0,      // Special options flags
                 KEY_READ,       // Desired security access
                 &hk);       // Opened handle buffer

    if (lReturn != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,1,TEXT("Could not access AudioRenderer key")));
        return FALSE;
    }

    DWORD dwType;
    BYTE  data[10];
    DWORD cbData = sizeof(data);
    lReturn = RegQueryValueEx(hk, TEXT("PreferWaveRenderer"), NULL, &dwType,
                data, &cbData);
    if (ERROR_SUCCESS == lReturn) {
        if (dwType == REG_DWORD) {
            fReturn = *(DWORD*)&data;
        } else if (dwType==REG_SZ) {
#ifdef UNICODE
            fReturn = atoiW((WCHAR*)data);
#else
            fReturn = atoi((char*)data);
#endif
        }
    }
    RegCloseKey(hk);
    return fReturn;
}

#endif

//
// GetPages
//

STDMETHODIMP CWaveOutFilter::GetPages(CAUUID * pPages)
{
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(2 * sizeof(GUID));
    if (pPages->pElems == NULL) {
    return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_AudioProperties;
    pPages->pElems[pPages->cElems++] = CLSID_AudioRendererAdvancedProperties;

    return NOERROR;

} // GetPages


// IAMAudioRendererStats
STDMETHODIMP CWaveOutFilter::GetStatParam( DWORD dwParam, DWORD *pdwParam1, DWORD *pdwParam2 )
{
    if( NULL == pdwParam1 )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    *pdwParam1 = 0;

    switch( dwParam )
    {
        case AM_AUDREND_STAT_PARAM_SLAVE_MODE:
            *pdwParam1 = m_pInputPin->m_Slave.m_fdwSlaveMode;
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_RATE:
            if( m_pInputPin->m_Slave.m_fdwSlaveMode && m_fDSound )
            {
                // only valid when we're slaving via rate adjustment
                *pdwParam1 = m_pInputPin->m_Slave.m_dwCurrentRate ;
                hr = S_OK;
            }
            break;
        case AM_AUDREND_STAT_PARAM_JITTER:
#ifdef CALCULATE_AUDBUFF_JITTER
            if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                hr = GetStdDev( m_pInputPin->m_Slave.m_cBuffersReceived
                              , (int *) pdwParam1
                              , m_pInputPin->m_Slave.m_iSumSqAcc
                              , m_pInputPin->m_Slave.m_iTotAcc );
            }
#else
            hr = E_NOTIMPL;
#endif
            break;

        case AM_AUDREND_STAT_PARAM_SILENCE_DUR:
            if( m_fDSound )
            {
                hr = S_OK;
                if( 0 == m_pInputPin->m_nAvgBytesPerSec )
                    *pdwParam1 = 0;
                else
                    *pdwParam1 = (DWORD) ( (PDSOUNDDEV(m_pSoundDevice)->m_llSilencePlayed * 1000) / m_pInputPin->m_nAvgBytesPerSec);
            }

            break;

        case AM_AUDREND_STAT_PARAM_BREAK_COUNT:
            if( m_fDSound )
            {
                *pdwParam1 = (LONG) (PDSOUNDDEV(m_pSoundDevice)->m_NumAudBreaks);
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_BUFFERFULLNESS:
            if( m_fDSound )
            {
                *pdwParam1 = (LONG) (PDSOUNDDEV(m_pSoundDevice)->m_lPercentFullness);
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_LAST_BUFFER_DUR:
            *pdwParam1 = (DWORD) ( m_pInputPin->m_Stats.m_rtLastBufferDur / 10000 );
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_DISCONTINUITIES:
            *pdwParam1 = m_pInputPin->m_Stats.m_dwDiscontinuities;
            hr = S_OK;
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_DROPWRITE_DUR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode && !m_fDSound )
            {
                // only valid for waveOut
                // dropped sample or paused duration
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtDroppedBufferDuration / 10000) ;
                *pdwParam2 = 0 ; // Silence writing not implemented currently
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_HIGHLOWERROR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtHighestErrorSeen / 10000) ;
                *pdwParam2 = (DWORD) (m_pInputPin->m_Slave.m_rtLowestErrorSeen / 10000) ;
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_ACCUMERROR:
            if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtErrorAccum / 10000) ;
                hr = S_OK;
            }
            break;

        case AM_AUDREND_STAT_PARAM_SLAVE_LASTHIGHLOWERROR:
            if( NULL == pdwParam2 )
            {
                return E_INVALIDARG;
            }
            else if( m_pInputPin->m_Slave.m_fdwSlaveMode )
            {
                *pdwParam1 = (DWORD) (m_pInputPin->m_Slave.m_rtLastHighErrorSeen / 10000) ;
                *pdwParam2 = (DWORD) (m_pInputPin->m_Slave.m_rtLastLowErrorSeen / 10000) ;
                hr = S_OK;
            }
            break;

        default:
            hr = E_INVALIDARG;
    }
    return hr;
}

// IAMClockSlave
STDMETHODIMP CWaveOutFilter::SetErrorTolerance( DWORD dwTolerance )
{
    ASSERT( m_pInputPin );
    if ( State_Stopped != m_State ) 
    {
        return VFW_E_NOT_STOPPED;
    }
    // allowed range is 1 to 1000ms
    if( 0 == dwTolerance || 1000 < dwTolerance )
    {
        DbgLog((LOG_TRACE, 2, TEXT("ERROR: CWaveOutFilter::SetErrorTolerance failed because app tried to set a value outside the 1 - 1000ms range!")));
        return E_FAIL;
    }    
    m_pInputPin->m_Slave.m_rtAdjustThreshold = dwTolerance * 10000;
    DbgLog((LOG_TRACE, 3, TEXT("*** New slaving tolerance set on audio renderer = %dms ***"),
            (LONG) (m_pInputPin->m_Slave.m_rtAdjustThreshold/10000) ) ) ;
    
    return S_OK;
}

STDMETHODIMP CWaveOutFilter::GetErrorTolerance( DWORD * pdwTolerance )
{
    ASSERT( m_pInputPin );
    if( NULL == pdwTolerance )
        return E_POINTER;

    *pdwTolerance = (DWORD) ( m_pInputPin->m_Slave.m_rtAdjustThreshold / 10000 );
    return S_OK;
}

#if 0

LPAMOVIESETUP_FILTER
CWaveOutFilter::GetSetupData()
{
#if 0
    if (g_amPlatform == VER_PLATFORM_WIN32_NT) {
    // On NT we make the wave renderer the preferred filter
    // if we are running on a system without Direct Sound
    if (g_osInfo.dwMajorVersion == 3
#ifdef DEBUG
        || IsPreferredRendererWave()
#endif
    ) {

        // change the default to have wave out preferred
        wavFilter.dwMerit = MERIT_PREFERRED;
        dsFilter.dwMerit  = MERIT_PREFERRED-1;

    }
    }
#endif
    return const_cast<LPAMOVIESETUP_FILTER>(m_pSetupFilter);
}

#endif


// this is the EOS function that m_callback will callback to.
// It is called back to deliver an EOS when we have no audio device.
// the param is the this pointer. It will deliver EOS
// to the input pin
void
CWaveOutFilter::EOSAdvise(DWORD_PTR dw)
{
    CWaveOutFilter* pThis = (CWaveOutFilter*)dw;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: EOSAdvise")));

    // make it clear there is no longer an outstanding callback
    pThis->m_dwEOSToken = 0;

    // deliver EOS to the input pin
    pThis->m_pInputPin->EndOfStream();
}

// queue an EOS for when the end of the current segment should appear.
// If we have no audio device we will fail receive and so the upstream filter
// will never send us an EOS. We can't send EOS now or we will terminate early
// when we might be about to get the device, so we have a thread (inside
// the m_callback object) that will be created to wait for when the
// current segment should terminate, and then call our EndOfStream method.
//
HRESULT
CWaveOutFilter::QueueEOS()
{
    //CAutoLock lock(this);
    ASSERT(CritCheckIn(this));
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: QueueEOS")));

    REFERENCE_TIME tStop;

    // stop time in reference time is end of segment plus stream time offset
    // End of segment in stream time is (stop - start) using the stop and start
    // times passed to the pin's NewSegment method
    tStop = (m_pInputPin->m_tStop - m_pInputPin->m_tStart);

    if (m_dwEOSToken) {
        if (tStop == m_tEOSStop) {
            // we already have a callback for this time
            return S_OK;
        }
        CancelEOSCallback();
    }

    // if no base time yet, wait until run
    if (m_State != State_Running) {
        return S_FALSE;
    }

    m_tEOSStop = tStop;

    // calculate the end time
    tStop += m_tStart;

#ifdef DEBUG
    // in the debug build there are occasions when Advise will FAIL because
    // the segment time has not yet been set and we end up requesting an
    // advise in the past (because tStop+m_tStart will wrap).  This causes
    // an assert in callback.cpp.  We deliberately - IN THE DEBUG BUILD
    // ONLY - avoid that here.  If NewSegment is called we will reset
    // the advise.
    if (tStop < m_tStart) {
        // error...
        DbgLog((LOG_TRACE, 2, "EOSAdvise being fired now as calculated stop time is in the past"));
        EOSAdvise( (DWORD_PTR) this);
        return S_OK;
    }
#endif


    // we set the advise for tStop (stream time of end of segment) plus
    // the stream time offset - this should give us the absolute reference
    // time when the end of stream should happen.

    DbgLog((LOG_TRACE, 2, "Setting advise in QueueEOS"));
    HRESULT hr = m_callback.Advise(
        EOSAdvise,  // callback function
        (DWORD_PTR) this,   // user token passed to callback
        tStop,
        &m_dwEOSToken);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("EOS Callback failed")));
        // we won't get a callback so do it now
        EOSAdvise( (DWORD_PTR) this);
    }
    return S_OK;
}



// cancel the EOS callback if there is one outstanding
HRESULT
CWaveOutFilter::CancelEOSCallback()
{
    ASSERT(CritCheckIn(this));
    HRESULT hr = S_FALSE;
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("wo: CancelEOScallback")));

    if (m_dwEOSToken) {
        DbgLog((LOG_TRACE, 3, "Cancelling callback in CancelEOScallback"));
        m_callback.Cancel(m_dwEOSToken);
        m_dwEOSToken = 0;
        hr = S_OK;
    }
    return hr;
}


// --- Pin Methods --------------------------------------------------------


/* Constructor */
#pragma warning(disable:4355)
CWaveOutInputPin::CWaveOutInputPin(
    CWaveOutFilter *pFilter,
    HRESULT *phr)
    : CBaseInputPin(NAME("WaveOut Pin"), pFilter, pFilter, phr, L"Audio Input pin (rendered)")
    , m_pFilter(pFilter)
    , m_pOurAllocator(NULL)
    , m_fUsingOurAllocator(FALSE)
    , m_llLastStreamTime(0)
    , m_nAvgBytesPerSec(0)
    , m_evSilenceComplete(TRUE)  // manual reset
    , m_bSampleRejected(FALSE)
    , m_hEndOfStream(0)
    , m_pmtPrevious(0)
    , m_Slave( pFilter, this )
    , m_bPrerollDiscontinuity( FALSE )
    , m_bReadOnly( FALSE )
    , m_bTrimmedLateAudio( FALSE )
#ifdef DEBUG
    , m_fExpectNewSegment (TRUE)
#endif
{
    SetReconnectWhenActive( m_pFilter->m_pSoundDevice->amsndOutCanDynaReconnect() );
    m_Stats.Reset();

#ifdef PERF
    m_idReceive       = MSR_REGISTER("WaveOut receive");
    m_idAudioBreak    = MSR_REGISTER("WaveOut audio break");
    m_idDeviceStart   = MSR_REGISTER("WaveOut device start time");
    m_idWaveQueueLength = MSR_REGISTER("WaveOut device queue length");
#endif
}
#pragma warning(default:4355)

CWaveOutInputPin::~CWaveOutInputPin()
{
    /* Release our allocator if we made one */

    if (m_pOurAllocator) {
        // tell him we're going away
        m_pOurAllocator->ReleaseFilter();

        m_pOurAllocator->Release();
        m_pOurAllocator = NULL;
    }

    DestroyPreviousType();
}

HRESULT CWaveOutInputPin::NonDelegatingQueryInterface(
    REFIID riid, void **ppv)
{
    if( riid == IID_IPinConnection && CanReconnectWhenActive() )
    {
        return GetInterface((IPinConnection *)this, ppv);
    }
    else
    {
        return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


//  Do you accept this type change in your current state?
STDMETHODIMP CWaveOutInputPin::DynamicQueryAccept(const AM_MEDIA_TYPE *pmt)
{
    // waveout filter can do dynamic format changes but not
    // seamlessly. ::QueryAccept will succeed
    return E_FAIL;
}

//  Set event when EndOfStream receive - do NOT pass it on
//  This condition is cancelled by a flush or Stop
STDMETHODIMP CWaveOutInputPin::NotifyEndOfStream(HANDLE hNotifyEvent)
{
    //  BUGBUG - what locking should we do?
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

//  Disconnect without freeing your resources - prepares
//  to reconnect
STDMETHODIMP CWaveOutInputPin::DynamicDisconnect()
{
    HRESULT hr =S_OK;
    CAutoLock cObjectLock(m_pLock);

    // not a valid assertion... we just want m_mt to be valid
    // ASSERT(m_Connected);
    if(!m_pFilter->IsStopped() && m_Connected)
    {
        DestroyPreviousType();
        m_pmtPrevious = CreateMediaType(&m_mt);
        if(!m_pmtPrevious) {
            hr =  E_OUTOFMEMORY;
        }
    }
    if(SUCCEEDED(hr)) {
        hr = CBaseInputPin::DisconnectInternal();
    }
    return hr;
}

//  Are you an 'end pin'
STDMETHODIMP CWaveOutInputPin::IsEndPin()
{
    //  BUGBUG - what locking should we do?
    return E_NOTIMPL;
}

//
// Create a wave out allocator using the input format type
//
HRESULT CWaveOutInputPin::CreateAllocator(LPWAVEFORMATEX lpwfx)
{
    HRESULT hr = S_OK;

    m_pOurAllocator = new CWaveAllocator(
                NAME("WaveOut allocator"),
                lpwfx,
                m_pFilter->m_pRefClock,
                m_pFilter,
                &hr);

    if (FAILED(hr) || !m_pOurAllocator) {
        DbgLog((LOG_ERROR,1,TEXT("Failed to create new wave out allocator!")));
        if (m_pOurAllocator) {
            // we got the memory, but some higher class must
            // have signalled an error
            delete m_pOurAllocator;
            m_pOurAllocator = NULL;
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        // ensure the thing has an extra refcount
        m_pOurAllocator->AddRef();
    }
    return hr;
}

// return the allocator interface that this input pin
// would like the output pin to use
STDMETHODIMP
CWaveOutInputPin::GetAllocator(
    IMemAllocator ** ppAllocator)
{
    HRESULT hr = NOERROR;

    *ppAllocator = NULL;

    if (m_pAllocator) {
        // we've already got an allocator....
        /* Get a reference counted IID_IMemAllocator interface */
        return m_pAllocator->QueryInterface(IID_IMemAllocator,
                                            (void **)ppAllocator);
    } else {
        if (!m_pOurAllocator) {

            if(m_pFilter->m_fDSound)
            {            
                return CBaseInputPin::GetAllocator(ppAllocator);
            }
            // !!! Check if format set?
            ASSERT(m_mt.Format());

            m_nAvgBytesPerSec = m_pFilter->WaveFormat()->nAvgBytesPerSec;
            DbgLog((LOG_MEMORY,1,TEXT("Creating new WaveOutAllocator...")));
            hr = CreateAllocator((WAVEFORMATEX *) m_mt.Format());
            if (FAILED(hr)) {
                return(hr);
            }
        }

        /* Get a reference counted IID_IMemAllocator interface */
        return m_pOurAllocator->QueryInterface(IID_IMemAllocator,
                                               (void **)ppAllocator);
    }
}


STDMETHODIMP CWaveOutInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly)
{
    HRESULT hr;         // General OLE return code

    // Make sure the renderer can change its'
    // allocator while the filter graph is running.
    ASSERT(CanReconnectWhenActive() || IsStopped());

    /* Make sure the base class gets a look */

    hr = CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);
    if (FAILED(hr)) {
        return hr;
    }

    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();

    /* See if the IUnknown pointers match */

    // remember if read-only, since pre-roll is only removed on read-writers buffers
    m_bReadOnly = bReadOnly;
    
    // !!! what if our allocator hasn't been created yet? !!!
    if(m_pFilter->m_fDSound)
    {
        // this is DSOUND, we should never use our own allocator;
        // however, it may have been previously created
        m_pFilter->m_fUsingWaveHdr  = FALSE;
        m_fUsingOurAllocator    = FALSE;
        if(m_pOurAllocator)
        {
            DbgLog((LOG_ERROR,1,TEXT("Waveout: NotifyAllocator: Releasing m_pOurAllocator for DSOUND")));

            m_pOurAllocator->Release();
            m_pOurAllocator = NULL;
        }
        return NOERROR;
    }
    if (!m_pOurAllocator) {
         ASSERT(pwfx);
         m_nAvgBytesPerSec = pwfx->nAvgBytesPerSec;
         hr = CreateAllocator(pwfx);
         if (FAILED(hr))
              return hr;
    }

    m_fUsingOurAllocator = ((IMemAllocator *)m_pOurAllocator == pAllocator);
    // m_fUsingWaveHdr == TRUE IFF someone has allocated a WaveHdr.  this is not true for the DSOUND renderer.
    m_pFilter->m_fUsingWaveHdr  = ! m_pFilter->m_fDSound || m_fUsingOurAllocator;

    DbgLog((LOG_TRACE,1,TEXT("Waveout: NotifyAllocator: UsingOurAllocator = %d"), m_fUsingOurAllocator));

    if (!m_fUsingOurAllocator) {

        // somebody else has provided an allocator, so we need to
        // make a few buffers of our own....
        // use the information from the other allocator

        ALLOCATOR_PROPERTIES Request,Actual;
        Request.cbBuffer = 4096;
        Request.cBuffers = 4;

        hr = pAllocator->GetProperties(&Request);
        // if this fails we carry on regardless...
        // we do not need a prefix when we copy to our code so
        // ignore that field, neither do we worry about alignment
        Request.cbAlign = 1;
        Request.cbPrefix = 0;

        //
        // Don't allocate too much (ie not > 10 seconds worth)
        //
        if ((pwfx->nAvgBytesPerSec > 0) &&
            ((DWORD)Request.cbBuffer * Request.cBuffers > pwfx->nAvgBytesPerSec * 10))
        {
            //  Do something sensible - 8 0.5 second buffers
            Request.cbBuffer = pwfx->nAvgBytesPerSec / 2;

            //  Round up a bit
            Request.cbBuffer = (Request.cbBuffer + 7) & ~7;
            if (pwfx->nBlockAlign > 1) {
                Request.cbBuffer += pwfx->nBlockAlign - 1;
                Request.cbBuffer -= Request.cbBuffer % pwfx->nBlockAlign;
            }
            Request.cBuffers = 8;
        }

        hr = m_pOurAllocator->SetProperties(&Request,&Actual);
        DbgLog((LOG_TRACE,1,
                TEXT("Allocated %d buffers of %d bytes from our allocator"),
                Actual.cBuffers, Actual.cbBuffer));
        if (FAILED(hr))
            return hr;
    }

    return NOERROR;
}


//
// Called when a buffer is received and we are already playing
// but the queue has expired.  We are given the start time
// of the sample.  We are only called for a sync point and only
// if we have a wave device.
//
HRESULT CWaveOutFilter::SetUpRestartWave(LONGLONG rtStart, LONGLONG rtEnd)
{
    // If there is still a significant portion of time
    // that should run before we start playing, get the
    // clock to call us back.  Otherwise restart the
    // wave device now.
    // we can only do this on our own clock

    REFERENCE_TIME now;
    if (m_pClock) {
        m_pClock->GetTime(&now);    // get the time from the filter clock
        rtStart -= now;     // difference from now
        
        DbgLog((LOG_TRACE, 5, TEXT("SetupRestartWave: rtStart is %dms from now"), (LONG) (rtStart/10000) ));
        
    }

    // Do we need to wait ?
    if (m_pClock && rtStart > (5* (UNITS/MILLISECONDS))) {

        // delay until we should start
        now += rtStart - (5 * (UNITS/MILLISECONDS));

        { // scope for lock
            ASSERT(CritCheckOut((CCritSec*)m_pRefClock));

            // have to ensure that AdviseCallback is atomic
            // or the callback could happen before
            // m_dwAdviseCookie is set

            // we can only do this if there is no current callback
            // pending.  For example if this is the first buffer
            // we may well have set up a RestartWave on ::Run, and
            // we do not want to override that callback.
            // BUT we cannot hold the device lock while we call
            // AdviseCallback.

            {
                ASSERT(CritCheckIn(this));
                if (m_dwAdviseCookie) {
                    // yes... let the first one fire
                    DbgLog((LOG_TRACE, 4, "advise in SetupRestartWave not needed - one already present"));
                    return S_OK;
                }
            }

            // Set up a new advise callback
            DbgLog((LOG_TRACE, 3, "Setting advise for %s in SetupRestartWave", CDisp(CRefTime(now))));
            HRESULT hr = m_callback.Advise(
                            RestartWave,    // callback function
                            (DWORD_PTR) this,   // user token passed to callback
                            now,
                            &m_dwAdviseCookie);
            ASSERT( SUCCEEDED( hr ) );
            {
                // Now check that the advise has been set up correctly
                ASSERT(CritCheckIn(this));
                if (m_dwAdviseCookie) {
                    // yes... we can pause the device
                    amsndOutPause();
                    SetWaveDeviceState(WD_PAUSED);
                }
            }
        }

    } else {
        DbgLog((LOG_TRACE, 5, "SetupRestartWave: starting immediately" ));
        RestartWave();
    }
    return(S_OK);
}

// *****
//
// Stuff we need out of dsprv.h
//
// *****

typedef enum
{
    DIRECTSOUNDDEVICE_TYPE_EMULATED,
    DIRECTSOUNDDEVICE_TYPE_VXD,
    DIRECTSOUNDDEVICE_TYPE_WDM
} DIRECTSOUNDDEVICE_TYPE;

typedef enum
{
    DIRECTSOUNDDEVICE_DATAFLOW_RENDER,
    DIRECTSOUNDDEVICE_DATAFLOW_CAPTURE
} DIRECTSOUNDDEVICE_DATAFLOW;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
{
    GUID                        DeviceId;               // DirectSound device id
    CHAR                        DescriptionA[0x100];    // Device description (ANSI)
    WCHAR                       DescriptionW[0x100];    // Device description (Unicode)
    CHAR                        ModuleA[MAX_PATH];      // Device driver module (ANSI)
    WCHAR                       ModuleW[MAX_PATH];      // Device driver module (Unicode)
    DIRECTSOUNDDEVICE_TYPE      Type;                   // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;               // Device dataflow
    ULONG                       WaveDeviceId;           // Wave device id
    ULONG                       Devnode;                // Devnode (or DevInst)
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPSTR                       Description;    // Device description
    LPSTR                       Module;         // Device driver module
    LPSTR                       Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA;

typedef struct _DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
{
    DIRECTSOUNDDEVICE_TYPE      Type;           // Device type
    DIRECTSOUNDDEVICE_DATAFLOW  DataFlow;       // Device dataflow
    GUID                        DeviceId;       // DirectSound device id
    LPWSTR                      Description;    // Device description
    LPWSTR                      Module;         // Device driver module
    LPWSTR                      Interface;      // Device interface
    ULONG                       WaveDeviceId;   // Wave device id
} DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA, *PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA;

#if DIRECTSOUND_VERSION >= 0x0700
#ifdef UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W_DATA
#else // UNICODE
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A_DATA
#endif // UNICODE
#else // DIRECTSOUND_VERSION >= 0x0700
#define DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#define PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA PDSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1_DATA
#endif // DIRECTSOUND_VERSION >= 0x0700

// DirectSound Private Component GUID {11AB3EC0-25EC-11d1-A4D8-00C04FC28ACA}
DEFINE_GUID(CLSID_DirectSoundPrivate, 0x11ab3ec0, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

//
// DirectSound Device Properties {84624F82-25EC-11d1-A4D8-00C04FC28ACA}
//

DEFINE_GUID(DSPROPSETID_DirectSoundDevice, 0x84624f82, 0x25ec, 0x11d1, 0xa4, 0xd8, 0x0, 0xc0, 0x4f, 0xc2, 0x8a, 0xca);

typedef enum
{
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_1,
    DSPROPERTY_DIRECTSOUNDDEVICE_WAVEDEVICEMAPPING_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_A,
    DSPROPERTY_DIRECTSOUNDDEVICE_ENUMERATE_W,
    DSPROPERTY_DIRECTSOUNDDEVICE_PRESENCE
} DSPROPERTY_DIRECTSOUNDDEVICE;

// *****

typedef HRESULT (WINAPI *GETCLASSOBJECTFUNC)( REFCLSID, REFIID, LPVOID * );

// we override this just for the dsound renderer case
HRESULT CWaveOutInputPin::CompleteConnect(IPin *pPin)
{
    if(m_pFilter->m_fDSound && !m_pmtPrevious)
    {
        // release the dsound object at this point, a non-dsound app
        // might be contending for the device. (only if we're not
        // doing a dynamic reconnect which is when m_pmtPrevious is
        // set.)
        CDSoundDevice *pDSDev = (CDSoundDevice *)m_pFilter->m_pSoundDevice;

        DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_DATA    description;
        // Set all fields of description to 0 (makes DeviceId == GUID_NULL).
        memset( (void *) &description, 0, sizeof( description ) );

        // Get handle to DSOUND.DLL
        // ***** This should be painless as we know that we have DSOUND.DLL loaded because we just checked
        // ***** m_pFilter->m_fDSound.  However, the handle to DSOUND.DLL in the CDSoundDevice is protected
        // ***** from us, so we'll get our own.  Initial perf. testing verified this.
        HINSTANCE hDSound = LoadLibrary( TEXT( "DSOUND.DLL" ) );
        if (NULL != hDSound) {
            // Get DllGetClassObject address w/GetProcAddress
            GETCLASSOBJECTFUNC DllGetClassObject = (GETCLASSOBJECTFUNC) GetProcAddress( hDSound, "DllGetClassObject" );

            if (NULL != DllGetClassObject) {
                // Get class factory w/DllGetClassObject
                HRESULT hr = S_OK;
                IClassFactory * pClassFactory;
                if (S_OK == (hr = (*DllGetClassObject)( CLSID_DirectSoundPrivate, IID_IClassFactory, (void **) &pClassFactory ))) {
                    // Create a DirectSoundPrivate object with the class factory
                    IDSPropertySet * pPropertySet;
                    if (S_OK == (hr = pClassFactory->CreateInstance( NULL, IID_IKsPropertySet, (void **) &pPropertySet ))) {
                        // Get information
                        HRESULT hr = 0;
                        ULONG   bytes = 0;
                        ULONG   support = 0;
#ifdef DEBUG
                        hr = pPropertySet->QuerySupport( DSPROPSETID_DirectSoundDevice,
                                                         DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
                                                         &support );
                        DbgLog(( LOG_TRACE, 1, TEXT( "IKsPropertySet->QuerySupport() returned 0x%08X, support = %d" ), hr, support ));
#endif // DEBUG
                        hr = pPropertySet->Get( DSPROPSETID_DirectSoundDevice,
                                                DSPROPERTY_DIRECTSOUNDDEVICE_DESCRIPTION_1,
                                                 (PVOID) &description,
                                                 sizeof( description ),
                                                 (PVOID) &description,
                                                 sizeof( description ),
                                                &bytes );
                        DbgLog(( LOG_TRACE, 1, TEXT( "IKsPropertySet->Get( DESCRIPTION ) returned 0x%08X, type = %d" ), hr, description.Type ));

                        // Release DirectSoundPrivate object
                        pPropertySet->Release();
                        } // if (S_OK == (hr = pClassFactory->CreateInstance( ... )))
                    else
                        DbgLog(( LOG_ERROR, 1, TEXT( "DirectSoundPrivate ClassFactory->CreateInstance( IKsPropertySet ) failed (0x%08X)." ), hr ));

                    // Release class factory
                    pClassFactory->Release();
                    } // if (S_OK == (hr = (*DllGetClassObject)( ... )))
                else
                    DbgLog(( LOG_ERROR, 1, TEXT( "DllGetClassObject( DirectSoundPrivate ) failed (0x%08X)."), hr ));
                } // if (NULL != DllGetClassObject)
            else
                DbgLog(( LOG_ERROR, 1, TEXT( "GetProcAddress( DllGetClassObject ) failed (0x%08X)."), GetLastError() ));

            // Cleanup DLL
            FreeLibrary( hDSound );
            } // if (NULL != (hDSound = LoadLibrary( ... )))
        else
            DbgLog(( LOG_ERROR, 1, TEXT( "LoadLibrary( DSOUND.DLL ) failed (0x%08X)."), GetLastError() ));

        if (DIRECTSOUNDDEVICE_TYPE_WDM != description.Type)
            pDSDev->CleanUp();
    }

    return S_OK;
}

/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CWaveOutInputPin::BreakConnect()
{
    if (m_pFilter->m_State != State_Stopped) {
        return CBaseInputPin::BreakConnect();
    }

    // an app had a reference on the DSound interfaces when we stopped, so
    // we haven't actually closed the wave device yet!  Do it now.
    // I'm assuming the app will release its references before breaking the
    // connections of this graph.
    if (m_pFilter->m_bHaveWaveDevice) {
        ASSERT(m_pFilter->m_hwo);

#if 0
        if (m_pFilter->m_cDirectSoundRef || m_pFilter->m_cPrimaryBufferRef ||
                    m_pFilter->m_cSecondaryBufferRef) {
            DbgLog((LOG_ERROR,0,TEXT("***STUPID APP did not release DirectSound stuff!")));
            ASSERT(FALSE);
        }
#endif

        DbgLog((LOG_TRACE, 1, TEXT("Wave device being closed in BreakConnect")));
        m_pFilter->m_bHaveWaveDevice = FALSE;
        HRESULT hr = S_OK;
        if(m_pOurAllocator)
            hr = m_pOurAllocator->ReleaseResource();

        // !!! I'm assuming that the allocator will be decommitted already!
        ASSERT(hr == S_OK);
        if (S_OK == hr) {
            // release done - close device
            m_pFilter->CloseWaveDevice();
            // This will always be NULL when using DSound renderer
            if (m_pFilter->m_pResourceManager) {
                // ZoltanS fix 1-28-98:
                // DbgBreak("*** THIS SHOULD NEVER HAPPEN ***");
                DbgLog((LOG_ERROR, 1,
                        TEXT("Warning: BreakConnect before reservation release; this may be broken!")));
                // we've finished with the device now
                m_pFilter->m_pResourceManager->NotifyRelease(
                                                            m_pFilter->m_idResource,
                                                            (IResourceConsumer*)m_pFilter,
                                                            FALSE);
            }
        } else {
            DbgLog((LOG_ERROR, 1, TEXT("Can't close wave device! Oh no!")));
        }
    }

    // !!! Should we check that all buffers have been freed?
    // --- should be done in the Decommit ?

    /* Set the CLSIDs of the connected media type */

    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    // no end of stream received or sent
    m_pFilter->m_eSentEOS = EOS_NOTSENT;

    return CBaseInputPin::BreakConnect();
}


/* Check that we can support a given proposed type */

HRESULT CWaveOutInputPin::CheckMediaType(const CMediaType *pmt)
{
    if (m_pmtPrevious) {
        return *pmt == *m_pmtPrevious ? S_OK : VFW_E_TYPE_NOT_ACCEPTED;
    }
    if ( m_pFilter->m_bActive &&
         m_pFilter->m_lBuffers != 0 &&
         pmt &&
         (pmt->majortype != MEDIATYPE_Audio) &&
         (pmt->formattype != FORMAT_WaveFormatEx) )
    {
        // only allow dynamic format changes for pcm right now
        DbgLog((LOG_TRACE,1,TEXT("*** CheckMediaType: dynamic change is only supported for pcm wave audio")));

        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    HRESULT hr = m_pFilter->m_pSoundDevice->amsndOutCheckFormat(pmt, m_dRate);

    if (FAILED(hr)) {
        return hr;
    }

    // we should now check whether we can set the volume or not
    WAVEOUTCAPS wc;
    memset(&wc,0,sizeof(wc));
    DWORD err = m_pFilter->amsndOutGetDevCaps(&wc, sizeof(wc));
    if (0 == err ) {
        //save volume capabilities
        m_pFilter->m_fHasVolume = wc.dwSupport & (WAVECAPS_VOLUME | WAVECAPS_LRVOLUME);
    }

    return NOERROR;
}



//
// Calculate how long this buffer should last (in 100NS units)
//
LONGLONG BufferDuration(DWORD nAvgBytesPerSec, LONG lData)
{
    if (nAvgBytesPerSec == 0) {
        // !!!!!!!!!! TEMP MIDI HACK, return 1 second.
        return UNITS; // !!!!!!!!!!!!!!!!!!!!!!!
    }

    return (((LONGLONG)lData * UNITS) / nAvgBytesPerSec);
}


/* Implements the remaining IMemInputPin virtual methods */

// Here's the next block of data from the stream
// We need to AddRef it if we hold onto it. This will then be
// released in the WaveOutCallback function.


#ifdef PERF
// Bracket code with calls to performance logger
HRESULT CWaveOutInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;

    // if stop time is before start time, forget this
    REFERENCE_TIME tStart, tStop;
    BOOL bSync = S_OK == pSample->GetTime(&tStart, &tStop);
    if (bSync && tStop <= tStart) {
        if (tStop<tStart) {
            DbgLog((LOG_ERROR, 1, TEXT("waveoutReceive: tStop < tStart")));
        } else {
            DbgLog((LOG_TRACE, 1, TEXT("waveoutReceive: tStop == tStart")));
        }
        // tStop==tStart is OK... that can mean the position thumb is
        // being dragged around
        return S_OK;
    }

    // MSR_START(m_idReceive);

    if (m_pFilter->m_State == State_Running && m_pFilter->m_lBuffers <= 0) {
        MSR_NOTE(m_idAudioBreak);
        // at this point we should resync the audio and system clocks
    }

    hr = SampleReceive(pSample);
    // MSR_STOP(m_idReceive);
    return(hr);

}

HRESULT CWaveOutInputPin::SampleReceive(IMediaSample * pSample)
{
    HRESULT hr;
    // in non PERF builds we have access to tStart and tStop
    // without querying the times again
    REFERENCE_TIME tStart, tStop;
    BOOL bSync = S_OK == pSample->GetTime((REFERENCE_TIME*)&tStart,
                                          (REFERENCE_TIME*)&tStop);
    BOOL bStop;
#else     // !PERF built version
HRESULT CWaveOutInputPin::Receive(IMediaSample * pSample)
{
    HRESULT hr;
    BOOL bSync, bStop;

#endif

    // From media sample, need to get back our WAVEOUTHEADER
    BYTE *pData;        // Pointer to image data
    LONG lData;
    WAVEFORMATEX *pwfx;

    {
        // lock this with the filter-wide lock
        CAutoLock lock(m_pFilter);

        // bump up the thread priority for smoother audio (especially for mp3 content)
        DWORD dwPriority = GetThreadPriority( GetCurrentThread() );
        if( dwPriority < THREAD_PRIORITY_ABOVE_NORMAL ) {
            SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL );
        }
        // we have received a data sample - complete Pause transition
        // do this within the lock so we know that the state cannot change
        // underneath us, and more importantly, that if a RUN command arrives
        // before we complete this Receive() that it will block.
        //
        // There is an argument that we should delay setting the Pause
        // complete event until just before the return from ::Receive().
        // That might make sense but leads to code bloat as we have
        // multiple return points. By grabbing the filter lock BEFORE setting
        // the event we at least serialise our activity.

        // If we have received a sample then we should not block
        // transitions to pause.  The order in which the commands get
        // distributed to filters in the graph is important here as we (a
        // renderer) get told to ::Pause before the source.  Until the
        // source sends us data we will not complete the Pause transition

        if (m_pFilter->m_State == State_Paused) {
            m_pFilter->m_evPauseComplete.Set();
            DbgLog((LOG_TRACE, 3, "Completing transition into Pause from Receive"));
        }

        if (m_pFilter->m_eSentEOS) {
            return VFW_E_SAMPLE_REJECTED_EOS;
        }


        // check all is well with the base class - do this before
        // checking for a wave device as we don't want to schedule an
        // EC_COMPLETE
        hr = CBaseInputPin::Receive(pSample);


        // S_FALSE means we are not accepting samples. Errors also mean
        // we reject this
        if (hr != S_OK)
            return hr;

        //  Handle dynamic format changes sometimes - actually we could
        //  do it always if we just waited for the pipe to empty and
        //  did the change then
        //  Note that the base class has already verified the type change
        //  m_lBuffers really is the number of buffers outstanding here
        //  because we won't get here if we've already had EndOfStream

        if ( (SampleProps()->dwSampleFlags & AM_SAMPLE_TYPECHANGED) )
        {
            ASSERT(SampleProps()->pMediaType->pbFormat != NULL);
            DbgLog((LOG_TRACE, 4, TEXT("Receive: Dynamic format change. First verifying that format is different...")));
            CMediaType *pmtSample = (CMediaType *)SampleProps()->pMediaType;

            WAVEFORMATEX *pwfxInput = m_pFilter->WaveFormat();
            if(pmtSample->cbFormat !=
                    sizeof(WAVEFORMATEX) + pwfxInput->cbSize ||
                0 != memcmp(pmtSample->pbFormat, pwfxInput, pmtSample->cbFormat))
            {
                DbgLog((LOG_TRACE, 1, TEXT("Receive: Dynamic format change")));

                hr = m_pFilter->ReOpenWaveDevice(pmtSample);
                if(hr != S_OK)
                    return hr;

            }
        }
        
        bSync = 0 != (SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID);
        bStop = 0 != (SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID);

        if( bSync && bStop )
        {    
            // check if there's any preroll to remove
            hr = RemovePreroll( pSample );     
            if ( m_bTrimmedLateAudio )
            {
                //
                // If we trimmed, mark the next sample we deliver (which may be this one
                // if we haven't dropped it all) as a discontinuity. This is required for 
                // the m_rtLastSampleEnd time in the dsound renderer to be correctly updated.
                //
                m_bPrerollDiscontinuity = TRUE;
            }
                            
            if( S_FALSE == hr )
            {
                // drop whole buffer, but check if we need to remember a discontinuity
                // (alternatively we could set this one to 0-length and continue?)
                if (S_OK == pSample->IsDiscontinuity())
                {
                    m_bPrerollDiscontinuity = TRUE;
                }                
                return S_OK;
            }
            else if( FAILED( hr ) )
            {
                return hr;
            }    
        }

        pData = SampleProps()->pbBuffer;
        lData = SampleProps()->lActual;

#ifdef DEBUG
        if (!bSync) {
            DbgLog((LOG_TRACE, 2, TEXT("Sample length %d with no timestamp"),
                    lData));
        }
#endif

#ifndef PERF
        REFERENCE_TIME tStart = SampleProps()->tStart;
        REFERENCE_TIME tStop = SampleProps()->tStop;
#else
        tStart = SampleProps()->tStart;
#endif
        // save local state of this before we update member var
        BOOL bPrerollDiscontinuity = m_bPrerollDiscontinuity; 
        
        // update m_Stats - discontinuities and last buffer duration
        if (S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity )
        {
            m_Stats.m_dwDiscontinuities++;
            m_bPrerollDiscontinuity = FALSE; // in case we get a real discontinuity after a drop
        }
        
        m_Stats.m_rtLastBufferDur = BufferDuration(m_nAvgBytesPerSec, lData);


#ifdef DEBUG
        if (bSync) 
        {
            if (m_pFilter->m_State == State_Running) 
            {
                CRefTime rt;
                HRESULT hr = m_pFilter->StreamTime(rt);
                if( bStop )
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample start time %dms, stop time %dms, Stream time %dms, discontinuity %d"), 
                            (LONG)(tStart / 10000),
                            (LONG)(tStop / 10000),
                            (LONG)(rt / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
                else
                {                
                    DbgLog((LOG_TRACE, 3, TEXT("Sample time %dms, Stream time %dms, discontinuity %d"), (LONG)(tStart / 10000),
                            (LONG)(tStart / 10000),
                            (LONG)(rt / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
            } 
            else 
            {
                if( bStop )
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample start time %dms, stop time %dms, discontinuity %d"), 
                            (LONG)(tStart / 10000),
                            (LONG)(tStop / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Sample time %dms, discontinuity %d"), (LONG)(tStart / 10000),
                            (LONG)(tStart / 10000),
                            S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity));
                }                
            }
        } 
        else 
        {
            if (S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity) 
            {
                DbgLog((LOG_TRACE, 3, TEXT("Sample with discontinuity and no timestamp")));
            }
        }
#endif
        ASSERT(pData != NULL);

        // have we got a wave device available?
        if (!m_pFilter->m_bHaveWaveDevice) {
            // no wave device, so we can't do much....
            m_pFilter->QueueEOS();

            // note: from this point on there is a small timing hole.
            // If we set m_bHaveWaveDevice==FALSE due to a ReleaseResource
            // call, but not have yet really closed the device because there
            // were outstanding buffers (probably the one we are just about
            // to reject) then we could be told to re-Acquire the device
            // before the buffer is released and before we really close
            // the device.  Yet there will be no EC_NEEDRESTART and nothing
            // to kick the source into sending us more data.
            // The hole is closed when the buffer is released.


            m_bSampleRejected = TRUE;
            return S_FALSE; // !!! after this we get no more data
        }

        ASSERT(m_pFilter->m_hwo);

        if (m_pFilter->m_lBuffers == 0)
        {
            if (bSync)
            {
                m_rtActualSegmentStartTime = tStart;
            }
            else if ( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK && ( pSample->IsDiscontinuity() != S_OK && !bPrerollDiscontinuity ))
            {
                m_rtActualSegmentStartTime = m_llLastStreamTime;
            }
            else m_rtActualSegmentStartTime = 0;
        }

        if ( m_pFilter->m_fFilterClock == WAVE_OTHERCLOCK ) {
            pwfx = m_pFilter->WaveFormat();
            ASSERT(pwfx);
            if (bSync) {
#ifdef DEBUG
                LONGLONG diff = m_llLastStreamTime + m_Stats.m_rtLastBufferDur - SampleProps()->tStop;
                if (diff < 0) {
                    diff = -diff;
                }
                if (diff > (2* (UNITS/MILLISECONDS))) {
                    DbgLog((LOG_TRACE, 3, "buffer end (bytes) and time stamp not in accord"));
                }
#endif
                m_llLastStreamTime = tStart + m_Stats.m_rtLastBufferDur;
            }
            else {
                m_llLastStreamTime += m_Stats.m_rtLastBufferDur;
                DbgLog((LOG_TRACE, 4, ".....non sync buffer, length %d", lData));
            }
        }

        BOOL bUnmarkedGapWhileSlaving = FALSE;
        if ( m_pFilter->m_State == State_Running &&
             m_pFilter->m_fFilterClock != WAVE_NOCLOCK &&
             !m_bTrimmedLateAudio ) // don't adjust if we've just dropped late audio (could lead to invalid err between clocks)
        {
            if( m_Slave.UpdateSlaveMode( bSync ) && 
                // for non-live slaving don't adjust if device isn't yet running!
                ( m_pFilter->m_wavestate == WD_RUNNING || m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) )
            {
                if( m_pFilter->m_fDSound && 
                    ( 0 == ( m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) ) &&
                    !( S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity ) )
                {                
                    // for non-live graphs if this isn't already a discontinuity check to see if it's an unmarked one
                    if( ( tStart > ( ( CDSoundDevice * ) m_pFilter->m_pSoundDevice )->m_rtLastSampleEnd ) &&
                        ( tStart - ( ( CDSoundDevice * ) m_pFilter->m_pSoundDevice )->m_rtLastSampleEnd  
                            > 30 * ( UNITS / MILLISECONDS ) ) )
                    {
                        DbgLog((LOG_TRACE,7, TEXT("Slaving DSound renderer detected unmarked discontinuity!") ) );
                        bUnmarkedGapWhileSlaving = TRUE;
                    }
                }   

                // yes, we are slaving so determine whether we need to make an adjustment
                hr = m_Slave.AdjustSlaveClock( ( REFERENCE_TIME ) tStart
                                             , &lData
                                             , S_OK == pSample->IsDiscontinuity() || bPrerollDiscontinuity 
                                               || bUnmarkedGapWhileSlaving );
                if (S_FALSE == hr)
                {
                    // dropping buffer
                    return S_OK;
                }
                else if( FAILED( hr ) )
                    return hr;
            }
        } // state_running

        if( m_fUsingOurAllocator || m_pFilter->m_fDSound ) {

            // addref pointer since we will keep it until the wave callback
            // - MUST do this before the callback releases it!
            pSample->AddRef();

            WAVEHDR *pwh;
            WAVEHDR wh;
            if(!m_pFilter->m_fUsingWaveHdr)
            {
                // we're not relying on a persistent waveHdr, nor has our sample allocated one, so we can simply cache it on the stack
                pwh = &wh;
                pwh->lpData = (LPSTR)pData;       // cache our buffer
                pwh->dwUser = (DWORD_PTR)pSample; // cache our CSample*
            }
            else
            {
                pwh = (LPWAVEHDR)(pData - m_pFilter->m_lHeaderSize);  // the waveHdr was part of the sample, legacy case
            }
            // need to adjust to actual bytes written
            pwh->dwBufferLength = lData;

            // note that we have added another buffer
            InterlockedIncrement(&m_pFilter->m_lBuffers);

// #ifdef PERF
#ifdef THROTTLE
            // there is a small timing hole here in that the callback
            // could decrement the count before we read it.  However
            // the trace should allow this anomaly to be identified.
            LONG buffercount = m_pFilter->m_lBuffers;
            // remember the maximum queue length reached.
            if (buffercount > m_pFilter->m_nMaxAudioQueue) {
                m_pFilter->m_nMaxAudioQueue = buffercount;
                DbgLog((LOG_TRACE, 0, TEXT("Max Audio queue = %d"), buffercount));
            }
#endif // THROTTLE
// #endif

            DbgLog((LOG_TRACE,5,
                    TEXT("SoundDeviceWrite: sample %X, %d bytes"),
                    pSample, pwh->dwBufferLength));

            // Compensate for Windows NT wave mapper bug (or should we
            // just use the ACM wrapper?).
            if(m_pFilter->m_fUsingWaveHdr)
                FixUpWaveHeader(pwh);

            UINT err = m_pFilter->amsndOutWrite(
                pwh,
                m_pFilter->m_lHeaderSize,
                (0 == (~SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID))? &tStart : NULL,
                0 == (~SampleProps()->dwSampleFlags & AM_SAMPLE_DATADISCONTINUITY) || bPrerollDiscontinuity
                || bUnmarkedGapWhileSlaving );
                
            //                
            // Don't unset this until after amsndOutWrite, to avoid incorrectly 
            // inserting silence due to dropping late audio (when slaving).
            // Used in dsound path only.
            //
            if( pwh->dwBufferLength > 0 )
            {            
                m_bTrimmedLateAudio = FALSE; 
            }                

            if (err > 0) {
                // device error: PCMCIA card removed?
                DbgLog((LOG_ERROR,1,TEXT("Error from amsndOutWrite: %d"), err));

                // release it here since the callback will never happen
                // and reduce the buffer count
                InterlockedDecrement(&m_pFilter->m_lBuffers);

                //  We now own the responsibility of scheduling end of
                //  stream because we're going to fail Receive
                if (MMSYSERR_NODRIVER == err)
                    m_pFilter->ScheduleComplete(TRUE);  // send EC_ERRORABORT also if dev was removed
                else
                    m_pFilter->ScheduleComplete();

                pSample->Release();

                // we do not bother with bytes in queue.  By returning an
                // error we are not going to receive any more data
                return E_FAIL;
            } else {
                CheckPaused();
            }

#ifdef THROTTLE

            m_pFilter->SendForHelp(buffercount);

            MSR_INTEGER(m_idWaveQueueLength, buffercount);
#endif // THROTTLE

            if (m_pFilter->m_pRefClock) {
                m_pFilter->m_llLastPos = m_pFilter->m_pRefClock->NextHdr(pData,
                                (DWORD)lData,
                                bSync,
                                pSample);
            }
            return NOERROR;
        }

        // NOT using our allocator

        if (m_pFilter->m_pRefClock) {
            m_pFilter->m_llLastPos = m_pFilter->m_pRefClock->NextHdr(pData,
                            (DWORD)lData,
                            bSync,
                            pSample);
        }
    }   // scope for autolock


    // When here we are not using our own allocator and
    // therefore need to copy the data

    // We have released the filter-wide lock so that GetBuffer will not
    // cause a deadlock when we go from Paused->Running or Paused->Playing

    IMediaSample * pBuffer;

    while( lData > 0 && hr == S_OK ){
        // note: this blocks!
        hr = m_pOurAllocator->GetBuffer(&pBuffer,NULL,NULL,0);

        { // scope for Autolock
            CAutoLock Lock( m_pFilter );

            if (FAILED(hr)) {
                m_pFilter->ScheduleComplete();
                break;  // return hr
            }

            // hold filter-wide critsec across CopyToOurSample
            // (more efficient than inside Copy method as there are multiple
            // return paths
            // this will addref sample if needed
            hr = CopyToOurSample(pBuffer, pData, lData);
        }

        // Copy will have addrefed sample if needed. We can release our
        // refcount *outside the critsec*
        pBuffer->Release();
    }

    /* Return the status code */
    return hr;
} // Receive

// use a preroll time between -10 and 0ms as the cutoff limit
#define PREROLL_CUTOFF_REFTIME ( -10 * ( UNITS/MILLISECONDS ) )

// don't attempt to trim tiny amounts
#define MINIMUM_TRIM_AMOUNT_REFTIME ( 5 * ( UNITS/MILLISECONDS ) )

// drop late audio when slaving if its really late
#define LATE_AUDIO_PAD_REFTIME ( 80 * ( UNITS/MILLISECONDS ) )

HRESULT CWaveOutInputPin::RemovePreroll( IMediaSample * pSample )
{
    if( m_mt.majortype != MEDIATYPE_Audio)
    {
        // no need to do this for MIDI at this point...
        return S_OK;
    }
    
    ASSERT( SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID  &&
            SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID );
    
    REFERENCE_TIME tStart = SampleProps()->tStart;
    REFERENCE_TIME tStop = SampleProps()->tStop;
    
    REFERENCE_TIME rtCutoff = PREROLL_CUTOFF_REFTIME;
    
    if( tStart >= PREROLL_CUTOFF_REFTIME )
    {
        //
        // no preroll to trim
        //
        // next check if we're slaving and this is really late audio
        //
        // *** Note ***
        // We'll only do this for non-live graphs, since filters like the waveIn audio capture
        // filter use a default 1/2 second buffer and so in effect deliver everything late.
        // 
        //
        if ( m_pFilter->m_State == State_Running && 
             m_Slave.UpdateSlaveMode( TRUE ) &&
             ( 0 == ( m_Slave.m_fdwSlaveMode & AM_AUDREND_SLAVEMODE_LIVE_DATA ) ) )
        {
            // yes, we are slaving and running, so drop any really late audio
            HRESULT hrTmp = m_pFilter->m_pClock->GetTime(&rtCutoff);
            ASSERT( SUCCEEDED( hrTmp ) );
            //
            // add in tolerance factor
            //
            rtCutoff -= ( m_pFilter->m_tStart + LATE_AUDIO_PAD_REFTIME );
            if( tStart >= rtCutoff )
            {
                // not late, drop nothing
                return S_OK;
            }
            else if( tStop < rtCutoff )
            {
                // completely late, drop it all 
                m_bTrimmedLateAudio = TRUE;
                
                DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Dropping Late Audio! (Sample start time %dms, sample stop time %dms)"), 
                        (LONG)(tStart / 10000),
                        (LONG)(tStop / 10000) ));
                return S_FALSE;
            }
            else 
            {                    
                // partially late, we may have to drop something...
                DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Considering trimming Late Audio! (Sample start time %dms, sample stop time %dms)"), 
                        (LONG)(tStart / 10000),
                        (LONG)(tStop / 10000) ));
            }
        }
        else
        {        
            // we're not slaving and there's no preroll to trim
            DbgLog((LOG_TRACE, 15, TEXT("CWaveOutInputPin::RemovePreroll: not preroll data") ));
            return S_OK;
        }            
    }        
    else if( tStop < PREROLL_CUTOFF_REFTIME )
    {
        m_bTrimmedLateAudio = TRUE; 
        
        // drop it all 
        DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Dropping Early Sample (Sample start time %dms, sample stop time %dms)"), 
                (LONG)(tStart / 10000),
                (LONG)(tStop / 10000) ));
        return S_FALSE;
    }   
                
    // we need to trim off something...
    
    DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Sample start time %dms, sample stop time %dms"), 
            (LONG)(tStart / 10000),
            (LONG)(tStop / 10000) ));
    
    if( m_bReadOnly )
    {
        // we won't do this for read-only buffers
        DbgLog((LOG_TRACE, 3, TEXT("CWaveOutInputPin::RemovePreroll: Uh-oh, it's a read-only buffer. Don't trim preroll!") ));
        return S_OK;
    }            
        
    //    
    // the assumption is, as long as we only operate on block aligned boundaries 
    // and remove data up front, we should be able trim any audio data we receive
    //
    ASSERT( rtCutoff > tStart );
    REFERENCE_TIME rtTrimAmount = rtCutoff - tStart;
    
#ifdef DEBUG    
    LONG lData = 0;
    
    // log original buffer length before removing pre-roll
    lData = pSample->GetActualDataLength();
    DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin::RemovePreroll: Original Preroll buffer length is %d"), lData ));
#endif    
    HRESULT hr = S_OK;
    
    // make sure it's worth trimming first    
    if( rtTrimAmount > MINIMUM_TRIM_AMOUNT_REFTIME )
    {
        hr = TrimBuffer( pSample, rtTrimAmount, rtCutoff, TRUE ); // trim from front

#ifdef DEBUG    
        if( SUCCEEDED( hr ) )
        {
            //
            // log updated buffer length
            // remember, we skip read-only buffers at this time
            //
            lData = pSample->GetActualDataLength();
            DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin:RemovePreroll: new buffer length is %d"), lData ));
        }        
#endif    
    }
#ifdef DEBUG
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("CWaveOutInputPin:RemovePreroll: Nevermind, not worth trimming...")));
    }
#endif        
    return hr;
}

//
// TrimBuffer - generic function to trim from front or back of audio buffer
//
HRESULT CWaveOutInputPin::TrimBuffer( IMediaSample * pSample, REFERENCE_TIME rtTrimAmount, REFERENCE_TIME rtCutoff, BOOL bTrimFromFront )
{
    ASSERT( bTrimFromFront ); // only support front end trimming right now
    ASSERT( !m_bReadOnly );
    
    DbgLog( (LOG_TRACE
          , 3
          , TEXT( "TrimBuffer preparing to trim %dms off %hs of buffer" )
          , (LONG) ( rtTrimAmount / 10000 ), bTrimFromFront ? "front" : "back" ) );
    
    // convert to bytes
    LONG lTruncBytes = (LONG) ( ( ( rtTrimAmount/10000) * m_nAvgBytesPerSec ) /1000 ) ; 

    WAVEFORMATEX *pwfx = m_pFilter->WaveFormat();

    //  round up to block align boundary
    LONG lRoundedUpTruncBytes = lTruncBytes;
    if (pwfx->nBlockAlign > 1) {
        lRoundedUpTruncBytes += pwfx->nBlockAlign - 1;
        lRoundedUpTruncBytes -= lRoundedUpTruncBytes % pwfx->nBlockAlign;
    }
        
    BYTE * pData = NULL;
    LONG cbBuffer = 0;
    
    HRESULT hr = pSample->GetPointer( &pData );
    ASSERT( SUCCEEDED( hr ) );
    
    cbBuffer = pSample->GetActualDataLength( );
    ASSERT( SUCCEEDED( hr ) );
    
    if( lRoundedUpTruncBytes >= cbBuffer )
    {
        // can't trim anything
        // so let's try rounding down then
        if( ( lRoundedUpTruncBytes -= pwfx->nBlockAlign ) <= 0 )
        {
            DbgLog( (LOG_TRACE, 3, TEXT( "TrimBuffer can't trim anything" ) ));
            return S_OK;
        }
        else if( lRoundedUpTruncBytes > cbBuffer )
        {
            //
            // If we wound up here then the possiblities are:
            //
            // a. We were passed a sample with bad timestamps (marked valid)
            //    Something external's broken, so just leave the buffer as is.
            // b. the buffer size is smaller than the absolute value of the preroll size
            //    Since we can't tell the difference between a. and b. (here) handle same as a.
            //
            return S_OK;
        }        
        else
        {
            DbgLog( (LOG_TRACE, 3, TEXT( "TrimBuffer rounding down instead to trim..." ) ));
        }        
    }
    
    //
    // so it still makes sense to trim rather than just drop 
    // TODO: might want to ensure we don't trim if amount is 
    //  a) too small or 
    //  b) too close to actual buffer size
    //
#ifdef DEBUG                        
    LONG lOriginalLength = cbBuffer;
#endif          
    // calculate new buffer size          
    cbBuffer -= lRoundedUpTruncBytes ;
    DbgLog( (LOG_TRACE
          , 3
          , TEXT( "***Truncating %ld bytes of %ld byte buffer (%ld left)" )
          , lRoundedUpTruncBytes
          , lOriginalLength
          , cbBuffer ) );
    
    ASSERT( cbBuffer > 0 );
        
    // shift out the preroll data    
    MoveMemory( pData, pData + lRoundedUpTruncBytes, cbBuffer );
    
    // need to adjust to actual bytes written
    hr = pSample->SetActualDataLength( cbBuffer );
    ASSERT( SUCCEEDED( hr ) );
    
    // update time stamp
    REFERENCE_TIME tStart = rtCutoff;
    REFERENCE_TIME tStop  = SampleProps()->tStop;

    hr = pSample->SetTime(
        (REFERENCE_TIME*)&tStart, 
        (REFERENCE_TIME*)&tStop);
    ASSERT( SUCCEEDED( hr ) );        
        
    // update SampleProps separately        
    SampleProps()->tStart    = rtCutoff;
    SampleProps()->lActual   = cbBuffer;
    
    m_bTrimmedLateAudio = TRUE; 
    
    return S_OK;    
}        

//  Helper to restart the device if necessary
void CWaveOutInputPin::CheckPaused()
{
    if (m_pFilter->m_wavestate == WD_PAUSED &&
        m_pFilter->m_State == State_Running) {
        // Restart the device

        REFERENCE_TIME rtStart = m_pFilter->m_tStart;
        REFERENCE_TIME rtStop = rtStart;
        if( SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID )
        {
            rtStart += SampleProps()->tStart;
            rtStop  = rtStart;
        }
        if( SampleProps()->dwSampleFlags & AM_SAMPLE_STOPVALID )
        {
            // although rtStop isn't even used by SetUpRestartWave, so this isn't necessary
            rtStop += SampleProps()->tStop;
        }
        m_pFilter->SetUpRestartWave( rtStart, rtStop );
    }
}


// incoming samples are not on our allocator, so copy the contents of this
// sample to our sample.
HRESULT
CWaveOutInputPin::CopyToOurSample(
    IMediaSample* pBuffer,
    BYTE* &pData,
    LONG &lData
    )
{
    if (m_pFilter->m_eSentEOS) {
        return VFW_E_SAMPLE_REJECTED_EOS;
    }

    HRESULT hr = CheckStreaming();
    if (S_OK != hr) {
        return hr;
    }

    if (!m_pFilter->m_bHaveWaveDevice) {
        // no wave device, so we can't do much....

        // tell the upstream filter that actually we don't want any
        // more data on this stream.
        m_pFilter->QueueEOS();
        return S_FALSE;
    }

    // addref the sample - we'll release it if we don't use it
    pBuffer->AddRef();


    BYTE * pBufferData;
    pBuffer->GetPointer(&pBufferData);
    LONG cbBuffer = min(lData, pBuffer->GetSize());

    DbgLog((LOG_TRACE,8,TEXT("Waveout: Copying %d bytes of data"), cbBuffer));

    CopyMemory(pBufferData, pData, cbBuffer);
    pBuffer->SetActualDataLength(cbBuffer);

    lData -= cbBuffer;
    pData += cbBuffer;

    LPWAVEHDR pwh = (LPWAVEHDR) (pBufferData - m_pFilter->m_lHeaderSize);

    // need to adjust to actual bytes written
    pwh->dwBufferLength = cbBuffer;

    // note that we have added another buffer.  We do it
    // here to guarantee that the callback sees the correct value
    // If we do it after the write the callback may have happened
    // which means that if the Write fails we must decrement
    InterlockedIncrement(&m_pFilter->m_lBuffers);
// #ifdef PERF
    // there is a small timing hole here in that the callback
    // could decrement the count before we read it.  However
    // the trace should allow this anomaly to be identified.
    LONG buffercount = m_pFilter->m_lBuffers;
// #endif

#ifdef THROTTLE
    // remember the maximum queue length reached.
    if (buffercount > m_pFilter->m_nMaxAudioQueue) {
        m_pFilter->m_nMaxAudioQueue = buffercount;
    }
#endif // THROTTLE

    UINT err = m_pFilter->amsndOutWrite(pwh, m_pFilter->m_lHeaderSize, NULL, NULL);
    if (err > 0) {
        // device error: PCMCIA card removed?
        DbgLog((LOG_ERROR,1,TEXT("Error from waveOutWrite: %d"), err));
        pBuffer->Release();

        // make the buffer count correct again
        InterlockedDecrement(&m_pFilter->m_lBuffers);

        m_pFilter->ScheduleComplete();
        // no more data will come.  ignore bytes in queue count
        return E_FAIL;
    } else {
        CheckPaused();
    }
#ifdef THROTTLE
    m_pFilter->SendForHelp(buffercount);
    MSR_INTEGER(m_idWaveQueueLength, buffercount);
#endif // THROTTLE

    return S_OK;
}


// no more data is coming. If we have samples queued, then store this for
// action in the last wave callback. If there are no samples, then action
// it now by notifying the filtergraph.
//
// we communicate with the wave callback using InterlockedDecrement on
// m_lBuffers. This is normally 0, and is incremented for each added buffer.
// At eos, we decrement this, so on the last buffer, the waveout callback
// will be decrementing it to -1 rather than 0 and can signal EC_COMPLETE.

STDMETHODIMP
CWaveOutInputPin::EndOfStream(void)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("CWaveOutInputPin::EndOfStream()")));
    // lock this with the filter-wide lock
    CAutoLock lock(m_pFilter);

    if (m_hEndOfStream) {
        EXECUTE_ASSERT(SetEvent(m_hEndOfStream));
        return S_OK;
    }

    HRESULT hr = CheckStreaming();
    if (S_OK == hr) {
        m_pFilter->m_bHaveEOS = TRUE;
        if (m_pFilter->m_State == State_Paused) {
            m_pFilter->m_evPauseComplete.Set();   // We have end of stream - transition is complete
            DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel + 1, "Completing transition into Pause due to EOS"));
        }
        hr = m_pFilter->ScheduleComplete();
    }
    return hr;
}


// enter flush state - block receives and free queued data
STDMETHODIMP
CWaveOutInputPin::BeginFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);
    DbgLog((LOG_TRACE, 2, "wo: BeginFlush, filter is %8x", m_pFilter));

    m_hEndOfStream = 0;

    // block receives
    HRESULT hr = CBaseInputPin::BeginFlush();
    if (!FAILED(hr)) {

        // discard queued data

        // force end-of-stream clear - this is to make sure
        // that a queued end-of-stream does not get delivered by
        // the wave callback when the buffers are released.
        InterlockedIncrement(&m_pFilter->m_lBuffers);

        // EOS cleared
        m_pFilter->m_eSentEOS    = EOS_NOTSENT;
        m_pFilter->m_bHaveEOS    = FALSE;

        // release all buffers from the wave driver

        if (m_pFilter->m_hwo) {

            ASSERT(CritCheckIn(m_pFilter));

            // amsndOutReset and ResetPosition are split in time
            // but consistency is guaranteed as we hold the filter
            // lock.

            m_pFilter->amsndOutReset();
            DbgLog((LOG_TRACE, 3, "Resetting the wave device in BEGIN FLUSH, state=%d, filter is %8x", m_pFilter->m_State, m_pFilter));

            if(m_pFilter->m_fDSound)
            {
                // for dsound renderer clear any adjustments needed for dynamic format changes
                // this is needed for seeks that may occur after or over format changes
                PDSOUNDDEV(m_pFilter->m_pSoundDevice)->m_llAdjBytesPrevPlayed = 0;
            }

            if (m_pFilter->m_State == State_Paused) {
                // and re-cue the device so that the next
                // write does not start playing immediately
                m_pFilter->amsndOutPause();
                m_pFilter->SetWaveDeviceState(WD_PAUSED);
            }

            // the wave clock tracks current position to base it's timing on.
            // we need to reset where it thinks it is through the data.
            if (m_pFilter->m_pRefClock) {
                m_pFilter->m_pRefClock->ResetPosition();
            }
        }

        // now force the buffer count back to the normal (non-eos) case.
        // at this point, we are sure there are no more buffers coming in
        // and no more buffers waiting for callbacks.
        m_pFilter->m_lBuffers = 0;

        // free anyone blocked on receive - not possibly in this filter

        // call downstream -- no downstream pins

    }
    return hr;
}

// leave flush state - ok to re-enable receives
STDMETHODIMP
CWaveOutInputPin::EndFlush(void)
{
    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

    // EOS cleared in BeginFlush
    ASSERT(m_pFilter->m_eSentEOS == EOS_NOTSENT &&
           m_pFilter->m_bHaveEOS == FALSE &&
           m_pFilter->m_lBuffers == 0);

    m_bSampleRejected = FALSE;
    DbgLog((LOG_TRACE, 3, "EndFlush - resetting EOS flags, filter=%8x",m_pFilter));

    // Assert that BeginFlush has been called?

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream
    // --- we did this in BeginFlush()

    // call EndFlush on downstream pins -- no downstream pins

    // unblock Receives
    return CBaseInputPin::EndFlush();
}


// NewSegment notifies of the start/stop/rate applying to the data
// about to be received. Default implementation records data and
// returns S_OK.
// We also reset any pending "callback advise"
STDMETHODIMP CWaveOutInputPin::NewSegment(
        REFERENCE_TIME tStart,
        REFERENCE_TIME tStop,
        double dRate)
{
    DbgLog((LOG_TRACE, 3, "Change of segment data: new Start %10.10s  new End %s", (LPCTSTR)CDisp(tStart, CDISP_DEC), (LPCTSTR)CDisp(tStop, CDISP_DEC)));
    DbgLog((LOG_TRACE, 3, "                        old Start %10.10s  old End %s", (LPCTSTR)CDisp(m_tStart, CDISP_DEC), (LPCTSTR)CDisp(m_tStop, CDISP_DEC)));
    DbgLog((LOG_TRACE, 3, "                        new Rate  %s       old Rate %s", (LPCTSTR)CDisp(dRate), (LPCTSTR)CDisp(m_dRate)));
    HRESULT hr;

    // lock this with the filter-wide lock - synchronize with starting
    CAutoLock lock(m_pFilter);

    // Change the rate in the base pin first so that the member variables
    // get set up correctly
    hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);
    if (S_OK == hr) {

        // if there is a pending EOS advise callback - reset it.
        if (m_pFilter->m_dwEOSToken) {
            DbgLog((LOG_TRACE, 2, "Resetting queued EOS"));
            m_pFilter->QueueEOS();
        }

#ifdef ENABLE_DYNAMIC_RATE_CHANGE
        // when the gremlins associated with dynamic rate changes have
        // been sorted out this line should be reinserted and ReOpenWaveDevice
        // reinspected.
        if (IsConnected()) {

            if(m_pFilter->m_fDSound)
            {
                hr = PDSOUNDDEV(m_pFilter->m_pSoundDevice)->SetRate(dRate);
            }
            else
            {
                hr = m_pFilter->ReOpenWaveDevice(dRate);
            }
        }
#endif

    }
    return hr;
}

//  Suggest a format
HRESULT CWaveOutInputPin::GetMediaType(
    int iPosition,
    CMediaType *pMediaType
)
#ifdef SUGGEST_FORMAT
{
    if (iPosition < 0 || iPosition >= 12) {
        return VFW_S_NO_MORE_ITEMS;
    }

    /*  Do 11, 22, 44 Khz, 8/16 bit mono/stereo */
    iPosition = 11 - iPosition;
    WAVEFORMATEX Format;
    Format.nSamplesPerSec = 11025 << (iPosition / 4);
    Format.nChannels = (iPosition % 4) / 2 + 1;
    Format.wBitsPerSample = ((iPosition % 2 + 1)) * 8;

    Format.nBlockAlign = Format.nChannels * Format.wBitsPerSample / 8;
    Format.nAvgBytesPerSec = Format.nSamplesPerSec *
                             Format.nBlockAlign;
    Format.wFormatTag = WAVE_FORMAT_PCM;
    Format.cbSize = 0;

    pMediaType->SetType(&MEDIATYPE_Audio);
    pMediaType->SetSubtype(&MEDIATYPE_NULL);
    pMediaType->SetFormatType(&FORMAT_WaveFormatEx);
    pMediaType->SetTemporalCompression(FALSE);
    pMediaType->SetSampleSize(Format.nBlockAlign);
    pMediaType->SetFormat((PBYTE)&Format, sizeof(Format));
    return S_OK;
}
#else
//  Just suggest audio - otherwise the filter graph searching is often
//  broken - all the types we support here are
{
    if (iPosition != 0) {
        return VFW_S_NO_MORE_ITEMS;
    }
    m_pFilter->m_pSoundDevice->amsndOutGetFormat(pMediaType);
    return S_OK;
}
#endif


STDMETHODIMP CWaveOutInputPin::SetRate(double dNewRate)
{
    CAutoLock Lock( m_pFilter );

    if( m_pFilter->m_dRate == m_dRate && m_dRate == dNewRate )
    {
        // no change
        return S_FALSE;
    }

    // If rate is negative, we rely on some upstream filter
    // to reverse the data, so just check abs(rate).
    const HRESULT hr = m_pFilter->CheckRate( fabs(dNewRate) );
    return hr;
}

HRESULT
CWaveOutInputPin::Active(void)
{
    m_bSampleRejected = FALSE;

    m_pFilter->m_bActive = TRUE;

    // Reset this.
    m_rtActualSegmentStartTime = 0;

    m_hEndOfStream = 0;

    if(!m_pOurAllocator)
        return S_OK;

    // commit and prepare our allocator. Needs to be done
    // if he is not using our allocator, and in any case needs to be done
    // before we complete our close of the wave device.
    return m_pOurAllocator->Commit();
}

HRESULT
CWaveOutInputPin::Inactive(void)
{
    m_pFilter->m_bActive = FALSE;
    m_bReadOnly = FALSE;

    DestroyPreviousType();

    if (m_pOurAllocator == NULL) {
        return S_OK;
    }
    // decommit the buffers - normally done by the output
    // pin, but we need to do it here ourselves, before we close
    // the device, and in any case if he is not using our allocator.
    // the output pin will also decommit the allocator if he
    // is using ours, but that's not a problem

    // once all buffers are freed (which may be immediately during the Decommit
    // call) the allocator will call back to OnReleaseComplete for us to close
    // the wave device.
    HRESULT hr = m_pOurAllocator->Decommit();

    return hr;
}

void
CWaveOutInputPin::DestroyPreviousType(void)
{
    if(m_pmtPrevious) {
        DeleteMediaType(m_pmtPrevious);
        m_pmtPrevious = 0;
    }
}

// dwUser parameter is the CWaveOutFilter pointer

void CALLBACK CWaveOutFilter::WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
                          DWORD_PTR dw1, DWORD_PTR dw2)
{
    switch (uMsg) {
    case WOM_DONE:
    case MOM_DONE:
      {

        // is this the end of stream?
        CWaveOutFilter* pFilter = (CWaveOutFilter *) dwUser;
        ASSERT(pFilter);

        CMediaSample *pSample;
        if(pFilter->m_fUsingWaveHdr)
        {
            // legacy case, or, we happen to be using an unfriendly parser, sample has been wrapped by the waveHdr
            LPWAVEHDR lpwh = (LPWAVEHDR)dw1;
            ASSERT(lpwh);
            pSample = (CMediaSample *)lpwh->dwUser;
        }
        else
        {
            // optimized case, we simply pass the sample on the stack
            pSample = (CMediaSample *)dw1;
        }

        DbgLog((LOG_TRACE,3, TEXT("WaveOutCallback: sample %X"), pSample));

        // note that we have finished with a buffer, and
        // look for eos
        LONG value = InterlockedDecrement(&pFilter->m_lBuffers);
        if (value <= 0) {

            // signal that we're done
            // either the audio has broken up or we have
            // naturally come to the end of the stream.

#ifdef THROTTLE
            MSR_INTEGER(pFilter->m_pInputPin->m_idWaveQueueLength, 0);
            pFilter->SendForHelp(0);
#endif // THROTTLE

            if (value < 0) {
                // EOS case - send EC_COMPLETE
                ASSERT(pFilter->m_eSentEOS == EOS_PENDING);

                //  This is where an EC_COMPLETE
                //  gets sent if we process it while we're running
                //
                //  warning, there's still a small timing hole here where
                //  the device could get paused just after we call into this...
                pFilter->SendComplete( pFilter->m_wavestate == WD_RUNNING );
            }

#ifdef THROTTLE
        } else {
#ifdef PERF
            LONG buffercount = pFilter->m_lBuffers;
            MSR_INTEGER(pFilter->m_pInputPin->m_idWaveQueueLength, buffercount);
#endif
            pFilter->SendForHelp(pFilter->m_lBuffers);
#endif // THROTTLE
        }

        if(pSample)
        {
            MSR_START(pFilter->m_idReleaseSample);
            pSample->Release(); // we're done with this buffer....
            MSR_STOP(pFilter->m_idReleaseSample);
        }
      }
        break;

    case WOM_OPEN:
    case WOM_CLOSE:
    case MOM_OPEN:
    case MOM_CLOSE:
        break;

    default:
        DbgLog((LOG_ERROR,2,TEXT("Unexpected wave callback message %d"), uMsg));
        break;
    }
}

STDMETHODIMP CWaveOutFilter::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock lock(this);
    if(IsStopped())
    {
        return m_pSoundDevice->amsndOutLoad(pPropBag);
    }
    else
    {
        return VFW_E_WRONG_STATE;
    }
}

STDMETHODIMP CWaveOutFilter::Save(
    LPPROPERTYBAG pPropBag, BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    // E_NOTIMPL is not a valid return code as any object implementing
    // this interface must support the entire functionality of the
    // interface. !!!
    return E_NOTIMPL;
}

STDMETHODIMP CWaveOutFilter::InitNew()
{
    return S_OK;
}

STDMETHODIMP CWaveOutFilter::GetClassID(CLSID *pClsid)
{
    return CBaseFilter::GetClassID(pClsid);;
}

HRESULT CWaveOutFilter::WriteToStream(IStream *pStream)
{
    return m_pSoundDevice->amsndOutWriteToStream(pStream);
}

HRESULT CWaveOutFilter::ReadFromStream(IStream *pStream)
{
    CAutoLock lock(this);
    if(IsStopped())
    {
        return m_pSoundDevice->amsndOutReadFromStream(pStream);
    }
    else
    {
        return VFW_E_WRONG_STATE;
    }
}

int CWaveOutFilter::SizeMax()
{
    return m_pSoundDevice->amsndOutSizeMax();
}


STDMETHODIMP CWaveOutFilter::Reserve(
    /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
    /*[in]*/ PVOID pvReserved        //  Must be NULL
)
{
    if (pvReserved != NULL || (dwFlags & ~AMRESCTL_RESERVEFLAGS_UNRESERVE)) {
        return E_INVALIDARG;
    }
    HRESULT hr = S_OK;
    CAutoLock lck(this);
    if (dwFlags & AMRESCTL_RESERVEFLAGS_UNRESERVE) {
        if (m_dwLockCount == 0) {
            DbgBreak("Invalid unlock of audio device");
            hr =  E_UNEXPECTED;
        } else {
            m_dwLockCount--;
            if (m_dwLockCount == 0 && m_State == State_Stopped) {
                ASSERT(m_hwo);

                // stop using the wave device
                m_bHaveWaveDevice = FALSE;

                HRESULT hr1 = S_OK;
                if(m_pInputPin->m_pOurAllocator) {
                    HRESULT hr1 = m_pInputPin->m_pOurAllocator->ReleaseResource();
                }

                if (SUCCEEDED(hr1)) {
                    CloseWaveDevice();
                }
                m_bHaveWaveDevice = FALSE;
            }
        }
    } else  {
        if (m_dwLockCount != 0 || m_hwo) {
        } else {
            hr = OpenWaveDevice();
        }
        if (hr == S_OK) { // ZoltanS fix 1-28-98
            m_dwLockCount++;
        }
    }
    return hr;
}

// --- Allocator Methods --------------------------------------------------------


// CWaveAllocator

/* Constructor must initialise the base allocator */

CWaveAllocator::CWaveAllocator(
    TCHAR *pName,
    LPWAVEFORMATEX lpwfx,
    IReferenceClock* pRefClock,
    CWaveOutFilter* pFilter,
    HRESULT *phr)
    : CBaseAllocator(pName, NULL, phr)
    , m_fBuffersLocked(FALSE)
    , m_hAudio(0)
    , m_pAllocRefClock(pRefClock)
    , m_dwAdvise(0)
    , m_pAFilter(pFilter)
#ifdef DEBUG
    , m_pAFilterLockCount(0)
#endif
    , m_nBlockAlign(lpwfx->nBlockAlign)
    , m_pHeaders(NULL)
{
    // !!! for MIDI, this will be zero, but it's only used to align buffer sizes,
    // so it's not a real problem.
    if (m_nBlockAlign < 1)
        m_nBlockAlign = 1;

    if (!FAILED(*phr)) {

        // IF we have a clock, we create an event to allow buffers
        // to be Release'd evenly.  If anything fails we will carry
        // on, but buffers might be released in a rush and disturb
        // the even running of the system.
        if (m_pAllocRefClock) {

            // DO NOT Addref the clock - we end up with a circular
            // reference with the clock (filter) and allocator
            // holding references on each other, and neither gets
            // deleted.
            // m_pAllocRefClock->AddRef();
        }
    }
}


// Called from destructor and also from base class

// all buffers have been returned to the free list and it is now time to
// go to inactive state. Unprepare all buffers and then free them.
void CWaveAllocator::Free(void)
{
    // lock held by base class CBaseAllocator

    // unprepare the buffers
    OnDeviceRelease();

    delete [] m_pHeaders;
    m_pHeaders = NULL;

    CMediaSample *pSample;  // Pointer to next sample to delete

    /* Should never be deleting this unless all buffers are freed */

    ASSERT(m_lAllocated == m_lFree.GetCount());
    ASSERT(!m_fBuffersLocked);

    DbgLog((LOG_MEMORY,1,TEXT("Waveallocator: Destroying %u buffers (%u free)"), m_lAllocated, m_lFree.GetCount()));

    /* Free up all the CMediaSamples */

    while (m_lFree.GetCount() != 0) {

        /* Delete the CMediaSample object but firstly get the WAVEHDR
           structure from it so that we can clean up it's resources */

        pSample = m_lFree.RemoveHead();

        BYTE *pBuf;
        pSample->GetPointer(&pBuf);

        pBuf -= m_pAFilter->m_lHeaderSize;

#ifdef DEBUG
        WAVEHDR wh;         // used to verify it is our object
        // !!! Is this really one of our objects?
        wh = *(WAVEHDR *) pBuf;
        // what should we look at?
#endif

        // delete the actual memory buffer
        delete[] pBuf;

        // delete the CMediaSample object
        delete pSample;
    }

    /* Empty the lists themselves */

    m_lAllocated = 0;

    // audio device is only ever released when we're told to by ReleaseResource
}


STDMETHODIMP CWaveAllocator::LockBuffers(BOOL fLock)
{
    DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::LockBuffers(BOOL fLock(%i))"), fLock));

    // All three of these "return NOERROR" _ARE_ used.

    if (m_fBuffersLocked == fLock) return NOERROR;
    ASSERT(m_pHeaders != NULL || m_lAllocated == 0);

    // do not set the lock flag unless we actually do the lock/unlock.
    // we can be called to lock buffers before the allocator has
    // been committed in which case there is no device and no buffers.
    // When we are set up this routine will be called again.

    if (!m_hAudio) return NOERROR;

    if (m_lAllocated == 0) return NOERROR;

    /* Should never be doing this unless all buffers are freed */
#ifdef DEBUG
    if (m_pAFilter->AreThereBuffersOutstanding()) {
        DbgLog((LOG_TRACE, 0, TEXT("filter = %8.8X, m_lBuffers = %d, EOS state = %d, m_bHaveEOS = %d"),
                m_pAFilter, m_pAFilter->m_lBuffers, m_pAFilter->m_eSentEOS, m_pAFilter->m_bHaveEOS));
        DebugBreak();
    }
#endif

    DbgLog((LOG_TRACE,2,TEXT("Calling wave%hs%hsrepare on %u buffers"), "Out" , fLock ? "P" : "Unp", m_lAllocated));
    UINT err;

    /* Prepare/unprepare all the CMediaSamples */

    for (int i = 0; i < m_lAllocated; i++) {

        LPWAVEHDR pwh = m_pHeaders[i];

        // need to ensure that buffer length is the same as the max size of
        // the sample. We will have reduced this length to actual data length
        // during running, but to un/prepare (eg on re-acquire of device) it
        // needs to be reset.

        if (fLock)
        {
            ASSERT(pwh->dwBufferLength == (DWORD)m_lSize);
            err = m_pAFilter->amsndOutPrepareHeader (pwh, m_pAFilter->m_lHeaderSize) ;
            if (err > 0) {
                DbgLog((LOG_TRACE, 0, TEXT("Prepare header failed code %d"),
                        err));
                for (int j = 0; j < i; j++) {
                    LPWAVEHDR pwh = m_pHeaders[j];
                    m_pAFilter->amsndOutUnprepareHeader(
                        pwh, m_pAFilter->m_lHeaderSize);
                }
            }
        }
        else
        {
            pwh->dwBufferLength = m_lSize;
            FixUpWaveHeader(pwh);
            err = m_pAFilter->amsndOutUnprepareHeader (pwh, m_pAFilter->m_lHeaderSize) ;

        }

        if (err > 0) {
            DbgLog((LOG_ERROR,1,TEXT("Error in wave%hs%hsrepare: %u"), "Out" , fLock ? "P" : "Unp", err));

            // !!! Need to unprepare everything....
            return E_FAIL; // !!!!
        }
    }

    m_fBuffersLocked = fLock;

    return NOERROR;
}


/* The destructor ensures the shared memory DIBs are deleted */

CWaveAllocator::~CWaveAllocator()
{
    // go to decommit state here. the base class can't do it in its
    // destructor since its too late by then - we've been destroyed.
    Decommit();

    if (m_pAllocRefClock)
    {
        if (m_dwAdvise) {
            m_pAllocRefClock->Unadvise(m_dwAdvise);
        }
        // See comments in wave allocator constructor as to why we do
        // not need to hold a reference count on the wave clock.
        // m_pAllocRefClock->Release();
    }
    ASSERT(m_pHeaders == NULL);
}


// Agree the number and size of buffers to be used. No memory
// is allocated until the Commit call.
STDMETHODIMP CWaveAllocator::SetProperties(
            ALLOCATOR_PROPERTIES* pRequest,
            ALLOCATOR_PROPERTIES* pActual)
{
    CheckPointer(pRequest,E_POINTER);
    CheckPointer(pActual,E_POINTER);

    //  Fix up different formats - note that this really needs adjusting
    //  for the rate too!

    // We really should rely on the source providing us with the right
    // buffering.  To avoid total disaster we insist on an 1/8 second.
    LONG MIN_BUFFER_SIZE = (m_pAFilter->m_pInputPin->m_nAvgBytesPerSec / 8);
    // this will be 11K at 44KHz, 16 bit stereo

    if (MIN_BUFFER_SIZE < 1024)
        MIN_BUFFER_SIZE = 1024;

    ALLOCATOR_PROPERTIES Adjusted = *pRequest;

    if (Adjusted.cbBuffer < MIN_BUFFER_SIZE)
        Adjusted.cbBuffer = MIN_BUFFER_SIZE;

    // waveout has trouble with 4 1/30th second buffers which is what
    // we end up with for certain files. if the buffers are really
    // small (less than 1/17th of a second), go for 8 buffers instead
    // of 4.
    if((LONG)m_pAFilter->m_pInputPin->m_nAvgBytesPerSec > pRequest->cbBuffer * 17)
    {
        Adjusted.cBuffers = max(8, Adjusted.cBuffers);
    }
    else if (Adjusted.cBuffers < 4) {
        Adjusted.cBuffers = 4;
    }

    // round the buffer size up to the requested alignment
    Adjusted.cbBuffer += m_nBlockAlign - 1;
    Adjusted.cbBuffer -= (Adjusted.cbBuffer % m_nBlockAlign);

    if (Adjusted.cbBuffer <= 0) {
        return E_INVALIDARG;
    }

    DbgLog((LOG_TRACE,5,TEXT("waveOut: Num = %u, Each = %u, Total buffer size = %u"),
    Adjusted.cBuffers, Adjusted.cbBuffer, (Adjusted.cBuffers * Adjusted.cbBuffer)));

    /* Pass the amended values on for final base class checking */
    return CBaseAllocator::SetProperties(&Adjusted,pActual);
}


// allocate and prepare the buffers

// called from base class to alloc memory when moving to commit state.
// object locked by base class
HRESULT
CWaveAllocator::Alloc(void)
{
    /* Check the base class says it's ok to continue */

    HRESULT hr = CBaseAllocator::Alloc();
    if (FAILED(hr)) {
        return hr;
    }

    CMediaSample *pSample;  // Pointer to the new sample

    /* We create a new memory block large enough to hold our WAVEHDR
       along with the actual wave data */

    DbgLog((LOG_MEMORY,1,TEXT("Allocating %d wave buffers, %d bytes each"), m_lCount, m_lSize));

    ASSERT(m_lAllocated == 0 && m_pHeaders == NULL);
    m_pHeaders = new LPWAVEHDR[m_lCount];
    if (m_pHeaders == NULL) {
        return E_OUTOFMEMORY;
    }
    for (; m_lAllocated < m_lCount; m_lAllocated++) {
        /* Create and initialise a buffer */
        BYTE * lpMem = new BYTE[m_lSize + m_pAFilter->m_lHeaderSize];
        WAVEHDR * pwh = (WAVEHDR *) lpMem;

        if (lpMem == NULL) {
            hr = E_OUTOFMEMORY;
            break;
        }

        /* The address we give the sample to look after is the actual address
           the audio data will start and so does not include the prefix.
           Similarly, the size is of the audio data only */

        pSample = new CMediaSample(NAME("Wave audio sample"), this, &hr, lpMem + m_pAFilter->m_lHeaderSize, m_lSize);

        pwh->lpData = (char *) (lpMem + m_pAFilter->m_lHeaderSize);
        pwh->dwBufferLength = m_lSize;
        pwh->dwFlags = 0;
        pwh->dwUser = (DWORD_PTR) pSample;
        m_pHeaders[m_lAllocated] = pwh;

        /* Clean up the resources if we couldn't create the object */

        if (FAILED(hr) || pSample == NULL) {
            delete[] lpMem;
            break;
        }

        /* Add the completed sample to the available list */

        m_lFree.Add(pSample);
    }

    if (SUCCEEDED(hr)) {
        hr = LockBuffers(TRUE);
    }


    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, TEXT("LockBuffers failed, hr=%x"), hr));
        Free();
        return hr;
    }

#ifdef DEBUG
    if (m_hAudio) {
        ASSERT(m_fBuffersLocked == TRUE);
    }
#endif

    return NOERROR;
}


// we have the wave device - prepare headers and start allowing GetBuffer
HRESULT
CWaveAllocator::OnAcquire(HWAVE hw)
{
    CAutoLock lock(this);

    // must not have the device
    ASSERT(!m_hAudio);

    // until we release the device we hold a reference count on the filter
    ASSERT(m_pAFilter);

    m_hAudio = hw;

    HRESULT hr;

    hr = LockBuffers(TRUE);

    if (SUCCEEDED(hr)) {
        // the reference count is kept while m_hAudio is valid
        m_pAFilter->AddRef();
#ifdef DEBUG
        m_pAFilterLockCount++;
#endif
    } else {
        m_hAudio = NULL;
    }

    return hr;
}

// please unprepare all samples  - return S_OK if this can be done
// straight away, or S_FALSE if needs to be done async. If async,
// will call CWaveOutFilter::OnReleaseComplete when done.
HRESULT
CWaveAllocator::ReleaseResource()
{
    CAutoLock lock(this);
    HRESULT hr = S_OK;

    if (m_hAudio) {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::ReleaseResource: m_hAudio is set.")));

        // can do it now and return S_OK (don't call OnReleaseComplete)

        // we may have done the decommit already - but won't have
        // released the device yet
        LockBuffers(FALSE);
        m_hAudio = NULL;

        // release the filter reference count
        ASSERT(m_pAFilter);
        m_pAFilter->Release();
#ifdef DEBUG
        ASSERT(m_pAFilterLockCount);
        --m_pAFilterLockCount;
#endif
    } else {
        DbgLog((LOG_TRACE, g_WaveOutFilterTraceLevel, TEXT("Allocator::ReleaseResource: Nothing to do.")));
        // don't have the device now
    }
    return hr;
}

// Called from Free to unlock buffers on last release. Don't call back to
// filter since we have the critsecs in the wrong order.
//
// Once the decommit is complete, the filter will call back on our
// ReleaseResource method to check that all buffers were freed and the device is
// released
HRESULT
CWaveAllocator::OnDeviceRelease(void)
{
    LockBuffers(FALSE);

    // device is actually released now only when we are told to via
    // a call to ReleaseResource

    return S_OK;
}


//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Wrappers for device control calls
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutOpen
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutOpen
(
    LPHWAVEOUT phwo,
    LPWAVEFORMATEX pwfx,
    double dRate,
    DWORD *pnAvgBytesPerSec,
    DWORD_PTR dwCallBack,
    DWORD_PTR dwCallBackInstance,
    DWORD fdwOpen,
    BOOL  bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutOpen( phwo
                                               , pwfx
                                               , dRate
                                               , pnAvgBytesPerSec
                                               , dwCallBack
                                               , dwCallBackInstance
                                               , fdwOpen );
    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Open, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutOpen failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOut
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutClose( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutClose();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Close, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutClose failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutGetDevCaps
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutGetDevCaps
(
    LPWAVEOUTCAPS pwoc,
    UINT cbwoc,
    BOOL bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutGetDevCaps( pwoc, cbwoc);

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_GetCaps, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutGetDevCaps failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutGetPosition
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutGetPosition ( LPMMTIME pmmt, UINT cbmmt, BOOL bUseAbsolutePos, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutGetPosition( pmmt, cbmmt, bUseAbsolutePos);

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_GetPosition, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutGetPosition failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutPause
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutPause( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutPause();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Pause, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutPause failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutPrepareHeader
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutPrepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutPrepareHeader( pwh, cbwh );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_PrepareHeader, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutPrepareHeader failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutUnprepareHeader
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutUnprepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutUnprepareHeader( pwh, cbwh );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_UnprepareHeader, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutUnprepareHeader failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutReset
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutReset( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutReset();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Reset, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutReset failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutRestart
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutRestart( BOOL bNotifyOnFailure )
{
    MMRESULT mmr = m_pSoundDevice->amsndOutRestart();

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Restart, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutRestart failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}

//--------------------------------------------------------------------------;
//
// CWaveOutFilter::amsndOutWrite
//
//--------------------------------------------------------------------------;
MMRESULT CWaveOutFilter::amsndOutWrite
(
    LPWAVEHDR pwh,
    UINT cbwh,
    REFERENCE_TIME const *pStart,
    BOOL bIsDiscontinuity,
    BOOL bNotifyOnFailure
)
{
    MMRESULT mmr = m_pSoundDevice->amsndOutWrite( pwh, cbwh, pStart, bIsDiscontinuity );

    if (MMSYSERR_NOERROR != mmr)
    {
        if( bNotifyOnFailure )
            NotifyEvent( EC_SNDDEV_OUT_ERROR, SNDDEV_ERROR_Write, mmr );

#ifdef DEBUG
        TCHAR message[100];
        m_pSoundDevice->amsndOutGetErrorText( mmr
                                            , message
                                            , sizeof(message)/sizeof(TCHAR) );
        DbgLog( ( LOG_ERROR
              , DBG_LEVEL_LOG_SNDDEV_ERRS
              , TEXT("amsndOutWrite failed: %u : %s")
              , mmr
              , message) );
#endif
    }

    return mmr;
}




//////////////
// 3D STUFF //
//////////////


HRESULT CWaveOutFilter::CDS3D::GetAllParameters(LPDS3DLISTENER lpds3d)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener *lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetAllParameters(lpds3d);
}

HRESULT CWaveOutFilter::CDS3D::GetDistanceFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetDistanceFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetDopplerFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetDopplerFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetOrientation(LPD3DVECTOR pv1, LPD3DVECTOR pv2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetOrientation(pv1, pv2);
}

HRESULT CWaveOutFilter::CDS3D::GetPosition(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetPosition(pv);
}

HRESULT CWaveOutFilter::CDS3D::GetRolloffFactor(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetRolloffFactor(pf);
}

HRESULT CWaveOutFilter::CDS3D::GetVelocity(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->GetVelocity(pv);
}

HRESULT CWaveOutFilter::CDS3D::SetAllParameters(LPCDS3DLISTENER lpds3d, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetAllParameters(lpds3d, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetDistanceFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetDistanceFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetDopplerFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetDopplerFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetOrientation(D3DVALUE x1, D3DVALUE y1, D3DVALUE z1, D3DVALUE x2, D3DVALUE y2, D3DVALUE z2, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetOrientation(x1, y1, z1, x2, y2, z2, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetPosition(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetRolloffFactor(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetRolloffFactor(f, dw);
}

HRESULT CWaveOutFilter::CDS3D::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->SetVelocity(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3D::CommitDeferredSettings()
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DListener * lp3d =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3d;
    if (!lp3d)
    return E_UNEXPECTED;
    return lp3d->CommitDeferredSettings();
}





HRESULT CWaveOutFilter::CDS3DB::GetAllParameters(LPDS3DBUFFER lpds3db)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetAllParameters(lpds3db);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeAngles(LPDWORD pdw1, LPDWORD pdw2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeAngles(pdw1, pdw2);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeOrientation(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeOrientation(pv);
}

HRESULT CWaveOutFilter::CDS3DB::GetConeOutsideVolume(LPLONG pl)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetConeOutsideVolume(pl);
}

HRESULT CWaveOutFilter::CDS3DB::GetMaxDistance(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMaxDistance(pf);
}

HRESULT CWaveOutFilter::CDS3DB::GetMinDistance(LPD3DVALUE pf)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMinDistance(pf);
}

HRESULT CWaveOutFilter::CDS3DB::GetMode(LPDWORD pdw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetMode(pdw);
}

HRESULT CWaveOutFilter::CDS3DB::GetPosition(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetPosition(pv);
}

HRESULT CWaveOutFilter::CDS3DB::GetVelocity(LPD3DVECTOR pv)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->GetVelocity(pv);
}

HRESULT CWaveOutFilter::CDS3DB::SetAllParameters(LPCDS3DBUFFER lpds3db, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetAllParameters(lpds3db, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeAngles(DWORD dw1, DWORD dw2, DWORD dw3)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeAngles(dw1, dw2, dw3);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeOrientation(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeOrientation(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetConeOutsideVolume(LONG l, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetConeOutsideVolume(l, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMaxDistance(D3DVALUE f, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMaxDistance(f, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMinDistance(D3DVALUE p, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMinDistance(p, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetMode(DWORD dw1, DWORD dw2)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetMode(dw1, dw2);
}

HRESULT CWaveOutFilter::CDS3DB::SetPosition(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetPosition(x, y, z, dw);
}

HRESULT CWaveOutFilter::CDS3DB::SetVelocity(D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dw)
{
    CAutoLock lock(m_pWaveOut);    // don't let the interface go away under us

    if (!m_pWaveOut->m_fDSound)
    return E_NOTIMPL;
    IDirectSound3DBuffer *lp3dB =
            ((CDSoundDevice *)m_pWaveOut->m_pSoundDevice)->m_lp3dB;
    if (!lp3dB)
    return E_UNEXPECTED;
    return lp3dB->SetVelocity(x, y, z, dw);
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\waveclk.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifdef	_MSC_VER
   #pragma warning(disable:4511) // disable C4511 - no copy constructor
   #pragma warning(disable:4512) // disable C4512 - no assignement operator
   #pragma warning(disable:4514) // disable C4514 -  "unreferenced inline function has been removed"
#endif	// MSC_VER

typedef void (PASCAL *CLOCKCALLBACK)(DWORD dwParm);

class CWaveOutClock : public CBaseReferenceClock
{
private:
    CWaveOutFilter *m_pFilter;

    // A copy of the reference time at which we should start to run
    LONGLONG    m_rtRunStart;

    /*  Sample time stamp tracking stuff */

    //  Bytes before last buffer that started playing which was
    //  a sync point
    LONGLONG    m_llBytesProcessed;

    //  bytes actually consumed by device (using GetPosition)
    LONGLONG    m_llBytesPlayed;

    //  Bytes in the pipe after that buffer (above)
    //
    LONGLONG    m_llBytesInLast;

    // Stream time of buffer starting
    // m_llBytesProcessed into the stream
    REFERENCE_TIME m_stBufferStartTime;
    REFERENCE_TIME m_stBufferStopTime;

    LONGLONG 	m_llLastDeviceClock;

#ifdef DEBUG
    LONGLONG    m_llEstDevRateStartTime;
    LONGLONG    m_llEstDevRateStartBytes;
#endif

public:
    BOOL	m_fAudioStarted;

    CWaveOutClock(
        CWaveOutFilter *pWaveOutFilter,
	LPUNKNOWN pUnk,
        HRESULT *phr,
	CAMSchedule * pShed
	);

    void AudioStarting(REFERENCE_TIME tStart);
    void AudioStopping();

    // update timing and position information.  returns the end of the
    // queue (the time when the data would finish playing)
    LONGLONG NextHdr(PBYTE pbData, DWORD cbData, BOOL bSync, IMediaSample *pSample);

    //  Reset the buffer statistics
    //  If bResetToZero is false assume the next buffer starts after these,
    //  otherwise assume it starts at 0
    void ResetPosition(BOOL bResetToZero = TRUE);

    void UpdateBytePositionData(DWORD nPrevAvgBytesPerSec, DWORD nCurAvgBytesPerSec);

    LONGLONG GetBytesProcessed( void ) { return m_llBytesProcessed ; }
    LONGLONG GetBytesInLastWrite( void ) { return m_llBytesInLast ; }
    LONGLONG GetBytesPlayed( void ) { return m_llBytesPlayed ; }
    LONGLONG GetLastDeviceClock( void ) { return m_llLastDeviceClock; }

    // Get the current position from the device
    // only used by the wave out filter
    // If bAbsoluteDevTime is true, return the total time played,
    // independent of stream or sample time.
    LONGLONG ReadDevicePosition(BOOL bAbsoluteDevTime = FALSE);
#ifdef DEBUG
    // estimate the actual rate at which the device is consuming data
    DWORD EstimateDevClockRate( const LONGLONG llTime, BOOL bInit = FALSE );
#endif

protected:
    // Base class virtual routines that we need to implement

    // Get the position (thus the time) from the wave device
    // This routine will only be called AFTER we have called PLAY
    // in the device clock class.  It will not be called after
    // we call STOP.
    LONGLONG ReadDeviceClock();

    // time within which to sync the system and device clocks
    LONGLONG m_llSyncClockThreshold;
    void ReadClockTimes(LONGLONG *pllSystem, LONGLONG *pllDevice);

    // Do the clock adjustment when we're running
    void AdjustClock();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\xmlgraph\qxmlhelp.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.

BSTR FindAttribute(IXMLElement *p, LPWSTR name);
DWORD ParseNum(LPWSTR p);
LONG ReadNumAttribute(IXMLElement *p, LPWSTR attrName, LONG lDefault = 0);
LONGLONG ParseTime(LPWSTR p);
LONGLONG ReadTimeAttribute(IXMLElement *p, LPWSTR attrName, LONGLONG llDefault = 0);
BOOL ReadBoolAttribute(IXMLElement *p, LPWSTR attrName, BOOL bDefault);

class CFakePropertyBag : public IPropertyBag, public CUnknown
{
public:
    DECLARE_IUNKNOWN

    CGenericList<WCHAR> m_listNames;
    CGenericList<WCHAR> m_listValues;

    CFakePropertyBag() :
	    CUnknown(NAME("property bag"), NULL),
	    m_listNames(NAME("names")), m_listValues(NAME("values"))
	    {  }

    ~CFakePropertyBag() { EmptyBag(); };
    
    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IPropertyBag) {
	    return GetInterface((IPropertyBag *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    };

    STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog* pErrorLog);
    STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);

    
    void EmptyBag() {
	// delete the stored strings....
	BSTR p;

	do {
	    p = m_listValues.RemoveHead();
	    if (p)
		SysFreeString(p);
	} while (p);
	
	do {
	    p = m_listNames.RemoveHead();
	    if (p)
		SysFreeString(p);
	} while (p);
    }
};


HRESULT HandleParamTags(IXMLElement *p, IUnknown *punk);
HRESULT GetFilterFromCategory(REFCLSID clsidCategory, WCHAR *lpwInstance, IBaseFilter **ppf);

#ifndef NO_QXMLHELP_IMPL
BSTR FindAttribute(IXMLElement *p, LPWSTR name)
{
    VARIANT v;

    VariantInit(&v);
    
    HRESULT hr = p->getAttribute(name, &v);

    if (FAILED(hr))
	return NULL;

    return V_BSTR(&v);

}

DWORD ParseNum(LPWSTR p)
{
    DWORD dwRet = 0;

    WCHAR c;
    while (((c = *p++) >= L'0') && (c <= L'9') )
	dwRet = (dwRet * 10) + (c - L'0');

    return dwRet;
}

LONG ReadNumAttribute(IXMLElement *p, LPWSTR attrName, LONG lDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONG lRet = lDefault;

    if (val) {
	lRet = ParseNum(val);

	SysFreeString(val);
    }

    return lRet;
}


LONGLONG ParseTime(LPWSTR p)
{
    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: parsing '%hs'"), p));
    
    WCHAR c = *p++;

    // !!! could handle SMPTE frames here?
    DWORD	dwSec = 0;
    DWORD	dwMin = 0;
    DWORD	dwFrac = 0;
    int		iFracPlaces = -1;
    while (c != L'\0') {
	if (c >= L'0' && c <= L'9') {
	    if (iFracPlaces >= 0) {
		++iFracPlaces;
		dwFrac = dwFrac * 10 + (c - L'0');
	    } else {
		dwSec = dwSec * 10 + (c - L'0');
            }
	} else if (iFracPlaces >= 0) {
            break;
        } else if (c == L':') {
	    dwMin = dwMin * 60 + dwSec;
	    dwSec = 0;
	} else if (c == L'.') {
	    iFracPlaces = 0;
	} else
	    break;	// !!! allow for skipping whitespace?

	c = *p++;
    }

    LONGLONG llRet = (LONGLONG) dwFrac * UNITS;
    while (iFracPlaces-- > 0) {
	llRet /= 10;
    }

    llRet += (LONGLONG) dwMin * 60 * UNITS + (LONGLONG) dwSec * UNITS;

    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: returning %d ms"), (DWORD) (llRet / 10000)));
    
    return llRet;
}

LONGLONG ReadTimeAttribute(IXMLElement *p, LPWSTR attrName, LONGLONG llDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONGLONG llRet = llDefault;

    if (val) {
	llRet = ParseTime(val);

	SysFreeString(val);
    }

    return llRet;
}

BOOL ReadBoolAttribute(IXMLElement *p, LPWSTR attrName, BOOL bDefault)
{
    BSTR val = FindAttribute(p, attrName);

    if (val) {
	WCHAR c = *val;
	if (c == L'y' || c == L'Y' || c == L't' || c == L'T' || c == L'1')
	    bDefault = TRUE;
	else if (c == L'n' || c == L'N' || c == L'f' || c == L'F' || c == L'0')
	    bDefault = FALSE;
	else {
	    DbgLog((LOG_ERROR, 1, TEXT("Looking for yes/no value, found '%ls'"), val));
	}

	SysFreeString(val);
    }

    return bDefault;
}



STDMETHODIMP CFakePropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar,
				    IErrorLog* pErrorLog)
{
    USES_CONVERSION;
    
    if(pvar && pvar->vt != VT_EMPTY && pvar->vt != VT_BSTR)
	return E_INVALIDARG;

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    POSITION pos1, pos2;
    for(pos1 = m_listNames.GetHeadPosition(),
	pos2 = m_listValues.GetHeadPosition();
	pos1;
	pos1 = m_listNames.Next(pos1),
	pos2 = m_listValues.Next(pos2))
    {
	WCHAR *pName = m_listNames.Get(pos1);

	if (lstrcmpW(pName, pszPropName) == 0)
	{
	    WCHAR *pValue = m_listValues.Get(pos2);
	    hr = S_OK;

	    if(pvar)
	    {
		V_VT(pvar) = VT_BSTR;

		V_BSTR(pvar) = ::SysAllocString(pValue);

		if (!V_BSTR(pvar))
		    hr = E_OUTOFMEMORY;

		return hr;
	    }
	}
    }

    if(pos1 == 0)
    {
	ASSERT(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }

    return hr;
};

STDMETHODIMP CFakePropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    // !!! look in list of values to see if it's already there?
    BSTR bstrName = SysAllocString(pszPropName);
    if (!bstrName)
        return E_OUTOFMEMORY;

    BSTR bstrValue;
    
    if (V_VT(pvar) == VT_BSTR) {
        bstrValue = SysAllocString(V_BSTR(pvar));
        if (!bstrValue)
            return E_OUTOFMEMORY;
    } else {
        VARIANT v;
        V_VT(&v) = VT_EMPTY;
        HRESULT hr = VariantChangeType(&v, pvar, 0, VT_BSTR);

        if (FAILED(hr))
            return hr;

        bstrValue = V_BSTR(&v);
    }

    m_listNames.AddTail(bstrName);
    m_listValues.AddTail(bstrValue);

    return S_OK;
}

HRESULT HandleParamTags(IXMLElement *p, IUnknown *punk)
{
    HRESULT hr = S_OK;

    CFakePropertyBag bag;

    IXMLElementCollection *pcoll;

    hr = p->get_children(&pcoll);

    if (hr == S_FALSE)
	return S_OK; // nothing to do
    
    long lChildren;
    hr = pcoll->get_length(&lChildren);

    int iParamsFound = 0;

    VARIANT var;

    var.vt = VT_I4;
    var.lVal = 0;                    
    
    for (SUCCEEDED(hr); var.lVal < lChildren; (var.lVal)++) {
	IDispatch *pDisp;
	hr = pcoll->item(var, var, &pDisp);

	if (SUCCEEDED(hr) && pDisp) {
	    IXMLElement *pelem;
	    hr = pDisp->QueryInterface(__uuidof(IXMLElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
                bool fAdded = false;
		BSTR bstrTagName;
		hr = pelem->get_tagName(&bstrTagName);

		if (SUCCEEDED(hr)) {
		    if (!lstrcmpiW(bstrTagName, L"param")) {
			BSTR bstrName = FindAttribute(pelem, L"name");

			if (bstrName) {
			    BSTR bstrValue = FindAttribute(pelem, L"value");

			    if (!bstrValue) {
				hr = pelem->get_text(&bstrValue);
			    }

			    if (bstrValue) {
				// add this name/value pair to bag
				if(bag.m_listNames.AddTail(bstrName))
                                {
                                    if(bag.m_listValues.AddTail(bstrValue)) {

                                        fAdded = true;
                                        ++iParamsFound;
                                    }
                                    else
                                    {
                                        bag.m_listNames.RemoveTail();
                                    }
                                }
                                if(!fAdded) {
                                    SysFreeString(bstrValue);
                                }
			    }

                            if(!fAdded) {
                                SysFreeString(bstrName);
                            }
			} else {
			    hr = VFW_E_INVALID_FILE_FORMAT;
			}

		    } else {
			// !!! unknown other subtag?

		    }

                    SysFreeString(bstrTagName);
		}
		pelem->Release();
	    }
	    pDisp->Release();
	}
    }

    pcoll->Release();


    if (SUCCEEDED(hr) && iParamsFound) {
	// load properties from the bag
	IPersistPropertyBag *pPPB;
        HRESULT hr2 = punk->QueryInterface(IID_IPersistPropertyBag,
						    (void **) &pPPB);

        if (SUCCEEDED(hr2)) {
            if (iParamsFound == 1 && !lstrcmpW(L"data", bag.m_listNames.GetHead())) {
		DbgLog((LOG_TRACE, 1, TEXT("Using IPersistStream instead of IPersistPropertyBag")));
                hr2 = E_NOINTERFACE;
            } else {
                hr2 = pPPB->Load(&bag, NULL);

                if (FAILED(hr2)) {
                    DbgLog((LOG_ERROR, 1, TEXT("Error %x loading parameters"), hr2));
                }
            }
            
	    pPPB->Release();
        }
        
	if (FAILED(hr2)) {
	    DbgLog((LOG_ERROR, 1, TEXT("Filter doesn't take parameters?")));

	    // !!! loop through properties handling special cases?
	    // if there's an "src" param, send it to IFileSource/Sink

	    VARIANT v;
	    v.vt = VT_BSTR;
	    hr2 = bag.Read(L"src", &v, NULL);

	    if (SUCCEEDED(hr2)) {
		IFileSourceFilter *pFSF;
		hr2 = punk->QueryInterface(IID_IFileSourceFilter,
						    (void **) &pFSF);

		if (SUCCEEDED(hr2)) {
		    hr = pFSF->Load(V_BSTR(&v), NULL);

		    pFSF->Release();
		} else {

		    IFileSinkFilter *pFSF;
		    hr2 = punk->QueryInterface(IID_IFileSinkFilter,
							(void **) &pFSF);

		    if (SUCCEEDED(hr2)) {
			hr = pFSF->SetFileName(V_BSTR(&v), NULL);

			pFSF->Release();
		    }

		}

		SysFreeString(V_BSTR(&v));
	    }

	    v.vt = VT_BSTR;
	    hr2 = bag.Read(L"data", &v, NULL);

	    if (SUCCEEDED(hr2)) {
		BSTR bstr = V_BSTR(&v);

		IPersistStream *pPS;

		hr2 = punk->QueryInterface(IID_IPersistStream,
						    (void **) &pPS);

		if (SUCCEEDED(hr2)) {
		    // convert hex data into an IStream....
		    UINT dwLen = SysStringLen(bstr);
		    HGLOBAL h = GlobalAlloc(GHND, dwLen + 1);

		    if (h) {
			LPBYTE p = (LPBYTE) GlobalLock(h);
			for (UINT i = 0; i < dwLen / 2; i++) {
			    WCHAR wch = bstr[i * 2];
			    if (wch >= L'0' && wch <= L'9')
				p[i] = (BYTE) (wch - L'0') * 16;
			    else if (wch >= L'A' && wch <= L'F')
				p[i] = (BYTE) (wch - L'A' + 10) * 16;

			    wch = bstr[i * 2 + 1];
			    if (wch >= L'0' && wch <= L'9')
				p[i] += (BYTE) (wch - L'0');
			    else if (wch >= L'A' && wch <= L'F')
				p[i] += (BYTE) (wch - L'A' + 10);
			}

			IStream *ps;
			hr2 = CreateStreamOnHGlobal(h, TRUE, &ps);
			if (SUCCEEDED(hr2)) {
			    hr2 = pPS->Load(ps);
			    ps->Release();
			}
		    }

		    pPS->Release();
		}
		SysFreeString(bstr);
	    }
	}
    }

    return hr;
}




HRESULT GetFilterFromCategory(REFCLSID clsidCategory, WCHAR *lpwInstance, IBaseFilter **ppf)
{
    ICreateDevEnum *pCreateDevEnum;
    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
				  IID_ICreateDevEnum, (void**)&pCreateDevEnum);
    if (hr != NOERROR)
	return hr;

    IEnumMoniker *pEm;
    hr = pCreateDevEnum->CreateClassEnumerator(clsidCategory, &pEm, 0);
    pCreateDevEnum->Release();
    if (hr != NOERROR)
	return hr;

    pEm->Reset(); // !!! needed?

    ULONG cFetched;
    IMoniker *pM;
    while(hr = pEm->Next(1, &pM, &cFetched), hr==S_OK)
    {
	if (lpwInstance) {
	    IPropertyBag *pBag;
	    hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
	    if(SUCCEEDED(hr)) {
		VARIANT var;
		var.vt = VT_BSTR;
		hr = pBag->Read(L"FriendlyName", &var, NULL);
		pBag->Release();
		if (hr == NOERROR) {
		    if (lstrcmpiW(var.bstrVal, lpwInstance) != 0) {				   
			SysFreeString(var.bstrVal);
			pM->Release();
			continue;
		    }
		    SysFreeString(var.bstrVal);
		} else
		    continue;
	    }
	}

	hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**)ppf);
	pM->Release();
	break;
    }
    pEm->Release();

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\wav\audio\waveout\waveout.h ===
// Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
/*  Implements a digital audio renderer using waveOutXXX apis */
/*            David Maymudes          */
/*              January 1995            */

#define FLAG(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                   (((DWORD)(ch4) & 0xFF00) << 8) |    \
                   (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                   (((DWORD)(ch4) & 0xFF000000) >> 24))

//
// forward declaration of the main Filter class.  Used in everything else below
//

class CWaveOutFilter;

#include <callback.h>

#include <dsound.h>

// Get the definition for our pass through class
#include "passthru.h"

// Get the AM sound interface defintion
#include "amaudio.h"

// Get the basic sound device definition
#include "sounddev.h"

// Declare the BasicAudio control properties/methods
#include "basicaud.h"

#include "waveclk.h"
#include "slave.h"
//
// Make visible the pin structure for dynamic filter registration.  This is
// common to both waveout and direct sound renderers and is used when they
// pass a AMOVIESETUP_FILTER* to the waveoutFilter constructor.

extern const AMOVIESETUP_PIN waveOutOpPin;

// Static function for calculating a rate adjusted wave format block.
// Includes an exception handler for over/under/flow errors.
// Returns 0 for success.
//
DWORD SetwfxPCM(WAVEFORMATEX& wfxPCM, double dRate);

// *****
//
// We need this private declaration of IKsPropertySet (renamed to IDSPropertySet)
// because of the inconsistency between the declarations in KSPROXY.H and DSOUND.H
//
// *****
struct IDSPropertySet;

#undef INTERFACE
#define INTERFACE IDSPropertySet

DECLARE_INTERFACE_(IDSPropertySet, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // IKsPropertySet methods
    STDMETHOD(Get)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG, PULONG) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID, ULONG, LPVOID, ULONG, LPVOID, ULONG) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID, ULONG, PULONG) PURE;
};

// This is an allocator based on the abstract CBaseAllocator class
// that allocates sample buffers. We have our own allocator so we can have
// WaveHdr's associated with every sample - the sample's data pointer points
// to just after the wave hdr.
//
// We need to use the wave device to prepare and unprepare buffers. We don't
// open it or close it. It is valid from OnAcquire until we call
// OnReleaseComplete() in the filter. It will be NULL at other times.
//
// On Unprepare, we wait until all samples are released.
// On last release to the allocator of a sample, we
// complete the unprepare operation.
//
// Similarly with prepare, we may need to wait until all buffers are back.
// This should not be problematic as the filter itself will reject them in
// Receive() if there is no wave device, so they will not get queued.
//
// Whether on demand or on Decommit, once we have unprepared all headers we
// call back to the filter for it to complete the close and notify the
// resource manager.
//
// We thus need a pointer to the filter, but we cannot hold a refcount since
// that would be circular. We are guaranteed that the filter will call us
// before exiting.
//
// The exception to this is when the audio device is active.  We need to
// call the filter to close the device, but the filter can be destroyed
// before the allocator.  Hence once the last wave buffer has been released
// we must know that the filter is active, otherwise it will be unsafe to
// call OnReleaseComplete().  While the wave device is active we keep a
// refcount on the filter.

class CWaveAllocator : public CBaseAllocator
{
    // wave device handle
    HWAVE               m_hAudio;

    // if non-null, pointer to creating filter
    // this will normally NOT be a reference counted pointer (see comments
    // at top) except a reference count is kept while m_hAudio is valid
    CWaveOutFilter*     m_pAFilter;
#ifdef DEBUG
    int                 m_pAFilterLockCount;
#endif

    DWORD               m_nBlockAlign;     // From wave format

    BOOL                m_fBuffersLocked;
    DWORD_PTR           m_dwAdvise;

    WAVEHDR           **m_pHeaders;

    IReferenceClock*    m_pAllocRefClock;

    // override this to free the memory when we are inactive
    void Free(void);

    // override this to allocate and prepare memory when we become active
    HRESULT Alloc(void);

    // Prepare/Unprepare wave headers for each sample
    // Needs to be called from ReopenWaveDevice
    STDMETHODIMP LockBuffers(BOOL fLock = TRUE);

    // finished with the wave device on last release of buffer
    HRESULT OnDeviceRelease(void);

public:

    /* Constructors and destructors */

    CWaveAllocator(
        TCHAR *pName,
        LPWAVEFORMATEX lpwfx,
        IReferenceClock* pRefClock,
        CWaveOutFilter* pFilter,
        HRESULT *phr);
    ~CWaveAllocator();

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest,
        ALLOCATOR_PROPERTIES* pActual
    );

    // please unprepare all samples  - return S_OK if this can be done
    // straight away, or S_FALSE if needs to be done async. If async,
    // will call CWaveOutFilter::OnReleaseComplete() when done.
    HRESULT ReleaseResource(void);

    // filter is going away - set pointer to null
    // this is called when the waveout input pin is destroyed.
    // we do NOT want to kill our pointer to the filter as we need
    // it when we are being destroyed
    void ReleaseFilter(void)
    {
        m_pAFilter = NULL;
        ASSERT(NULL == m_hAudio);
        DbgLog((LOG_TRACE, 1, "waveoutFilter input pin died"));
    }

    // we have the wave device - prepare headers.
    // -- Note that if some samples are outstanding, this will fail.
    HRESULT OnAcquire(HWAVE hw);

};

// WaveOutInputPin


/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CWaveOutInputPin :
    public CBaseInputPin,
    public IPinConnection
{
    typedef CBaseInputPin inherited;

    friend class CWaveOutFilter;
    friend class CWaveOutClock; 
    friend class CWaveAllocator;       // needs the input pin
    friend class CWaveSlave;
    friend class CDSoundDevice;

    DECLARE_IUNKNOWN;

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

private:

    CWaveOutFilter *m_pFilter;         // The renderer that owns us
    CAMEvent    m_evSilenceComplete;   // used to pause device for a "silence" period

    CWaveAllocator  * m_pOurAllocator;
    BOOL        m_fUsingOurAllocator;
    HRESULT     CreateAllocator(LPWAVEFORMATEX m_lpwfx);

    CWaveSlave      m_Slave;

    LONGLONG        m_llLastStreamTime;

    // This is the start time of the first received buffer after an audio break
    // (includes the one at the VERY beginning).  If the first received buffer is
    // not a sync'ed sample, this may be reset to zero.
    REFERENCE_TIME m_rtActualSegmentStartTime;

    // TRUE after returning S_FALSE in Receive, and until we are stopped
    // FALSE otherwise
    BOOL m_bSampleRejected;
    BOOL m_bPrerollDiscontinuity;   // remember discontinuity if we drop a pre-roll sample
    BOOL m_bReadOnly;               // we don't trim preroll if using read-only buffer
    BOOL m_bTrimmedLateAudio;       // set when we drop late audio when slaving, to avoid inserting silence


#ifdef PERF
    int m_idReceive;                   // MSR_id for time data received
    int m_idAudioBreak;
    int m_idDeviceStart;               // time to move the wave device to running
    int m_idWaveQueueLength;           // length of wave device queue
    STDMETHODIMP SampleReceive(IMediaSample *pSample);
#endif

    // incoming samples are not on our allocator, so copy the contents of this
    // sample to our sample.
    HRESULT CopyToOurSample(
                IMediaSample* pBuffer,
                BYTE* &pData,
                LONG &lData);

    DWORD       m_nAvgBytesPerSec;      // rate at which the device will consume our data

#ifdef DEBUG
    // we expect to see a rate change followed by a NewSegment call before
    // data restarts streaming
    BOOL        m_fExpectNewSegment;
#endif

    // statistics class for waveout renderer
    class CWaveOutStats
    {

    public:

        DWORD          m_dwDiscontinuities;
        REFERENCE_TIME m_rtLastBufferDur;

        void Reset() {
            m_dwDiscontinuities = 0;
            m_rtLastBufferDur = 0;
        }
    };

    friend class CWaveOutStats;

    CWaveOutStats m_Stats;

public:

    CWaveOutInputPin(
        CWaveOutFilter *pWaveOutFilter,
        HRESULT *phr);

    ~CWaveOutInputPin();

    // return the rate at which data is being consumed
    DWORD GetBytesPerSec()
    {
        return m_nAvgBytesPerSec;       // rate at which the device will consume our data
    }

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator,BOOL bReadOnly);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

        /* Let's us know when a connection is completed */
        HRESULT CompleteConnect(IPin *pPin);

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType *pmt);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

#ifdef LATER  // Need to fix toy.mpg first then this saves a thread
    /* We queue stuff up so we don't block */
    STDMETHODIMP ReceiveCanBlock()
    {
        return S_FALSE;
    }
#endif

    // no more data is coming
    STDMETHODIMP EndOfStream(void);

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // Override to handle quality messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {
        UNREFERENCED_PARAMETER(q);
        UNREFERENCED_PARAMETER(pSender);
        return E_NOTIMPL;             // We do NOT handle this
    }

    // flush our queued data
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);

    // NewSegment notifies of the start/stop/rate applying to the data
    // about to be received. Default implementation records data and
    // returns S_OK.  We potentially have to adjust our rate.
    // We may also have to reset our "callback advise"
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    //  Suggest a format
    //  We do this so that in situations where we are already in the graph
    //  the filter graph can determine what types we like so limiting
    //  searches that pull in lots of strange filters
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    REFERENCE_TIME GetFirstBufferStartTime(void);

    // Say when a buffer has been rejected - and hence if we need to
    // restart
    BOOL IsStreamTurnedOff()
    {
        return m_bSampleRejected;
    }

    // Check if the wave device needs restarting
    void CheckPaused();

    // RestartWave
    void RestartWave();

    // called to verify that a rate about to be set is actually valid.
    STDMETHODIMP SetRate(double dRate);

    //  IPinConnection stuff
    //  Do you accept this type chane in your current state?
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE *pmt);

    //  Set event when EndOfStream receive - do NOT pass it on
    //  This condition is cancelled by a flush or Stop
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);

    STDMETHODIMP DynamicDisconnect();

    //  Are you an 'end pin'
    STDMETHODIMP IsEndPin();

    void DestroyPreviousType(void);


    HRESULT RemovePreroll( IMediaSample * pSample ); // decides whether audio is preroll or very late when slaving
    HRESULT TrimBuffer( IMediaSample * pSample,      // trims this audio sample
                        REFERENCE_TIME rtTrimAmount, // amount to trim 
                        REFERENCE_TIME rtCutoff,     // new start time of the remaining data
                        BOOL bTrimFromFront = TRUE );// trim front front of buffer?


    HANDLE m_hEndOfStream;
    AM_MEDIA_TYPE *m_pmtPrevious;
};

//

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and has a single input stream (pin).

   The wave renderer implements IResourceConsumer which it will pass
   to some of the IResourceManager interface methods.

*/

//
// We remember whether we have no clock set for the filter,
// our clock, or someone else's clock.
//

enum waveClockState {
    WAVE_NOCLOCK = -1,
    WAVE_OURCLOCK,
    WAVE_OTHERCLOCK
};

enum waveDeviceState {
    WD_UNOWNED = 1,
    WD_OPEN,
    WD_PAUSED,
    WD_PENDING,   // waiting for final release of all buffers
    WD_CLOSED,
    WD_RUNNING,
    WD_ERROR_ON_OPEN,
    WD_ERROR_ON_PAUSE,
    WD_ERROR_ON_RESTART,
    WD_ERROR_ON_RESTARTA,
    WD_ERROR_ON_RESTARTB,
    WD_ERROR_ON_RESTARTC,
    WD_ERROR_ON_RESTARTD,
    WD_ERROR_ON_RESTARTE,
    WD_ERROR_ON_RESTARTF
};

// Define the states for our EOS sent flag.  This normally only
// makes sense if m_bHaveEOS == TRUE.
// EOS_NOTSENT - no EOS has been sent
// EOS_PENDING - will be sent when the wave callback completes
// EOS_SENT    - EOS has been sent
// Note that EOS_PENDING and EOS_SENT BOTH evaluate to TRUE (non-zero)

enum eosSentState {
    EOS_NOTSENT = 0,
    EOS_PENDING,
    EOS_SENT
};

enum _AM_AUDREND_SLAVEMODE_FLAGS {

    AM_AUDREND_SLAVEMODE_LIVE_DATA       = 0x00000001, // slave to live samples
    AM_AUDREND_SLAVEMODE_BUFFER_FULLNESS = 0x00000002, // slave to input buffer fullness
    AM_AUDREND_SLAVEMODE_GRAPH_CLOCK     = 0x00000004, // slave to graph clock
    AM_AUDREND_SLAVEMODE_STREAM_CLOCK    = 0x00000008, // slave to stream clock, which is
                                                       // necessarily the graph clock
    AM_AUDREND_SLAVEMODE_TIMESTAMPS      = 0x00000010  // slave to timestamps

};


class CWaveOutFilter
  : public CBaseFilter,
    public CCritSec,
    public IResourceConsumer,
    public ISpecifyPropertyPages,
#ifdef THROTTLE
    public IQualityControl,
#endif
    public IPersistPropertyBag,
    public IAMDirectSound,
    public CPersistStream,
    public IAMResourceControl,
    public IAMAudioRendererStats,
    public IAMClockSlave
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
#ifdef DEBUG
    STDMETHODIMP_(ULONG) NonDelegatingRelease()
    {
        return CBaseFilter::NonDelegatingRelease();
    }
    STDMETHODIMP_(ULONG) NonDelegatingAddRef()
    {
        return CBaseFilter::NonDelegatingAddRef();
    }
#endif

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    // override GetState so that we can return an intermediate code
    // until we have at least one audio buffer in the queue
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);

    // --- IResourceConsumer methods ---

    // Overrides for base Filter class methods

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

    //
    // you may acquire the resource specified.
    // return values:
    //      S_OK    -- I have successfully acquired it
    //      S_FALSE -- I will acquire it and call NotifyAcquire afterwards
    //      VFW_S_NOT_NEEDED: I no longer need the resource
    //      FAILED(hr)-I tried to acquire it and failed.

    STDMETHODIMP AcquireResource(LONG idResource);

    // Please release the resource.
    // return values:
    //      S_OK    -- I have released it (and want it again when available)
    //      S_FALSE -- I will call NotifyRelease when I have released it
    //      other   something went wrong.
    STDMETHODIMP ReleaseResource(LONG idResource);

    STDMETHODIMP IsConnected(void)
    {
        return m_pInputPin->IsConnected();
    };

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();
    // STDMETHODIMP GetClassID(CLSID *pClsid);

public:

    CWaveOutFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr,
        const AMOVIESETUP_FILTER* pSetupFilter, // contains filter class id
        CSoundDevice *pDevice);

    virtual ~CWaveOutFilter();

    /* Return the pins that we support */

    int GetPinCount() {return 1;};
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    // override JoinFilterGraph to obtain IResourceManager interface
    STDMETHODIMP JoinFilterGraph(IFilterGraph*, LPCWSTR);

#ifdef THROTTLE
    // Quality management stuff
    STDMETHODIMP SetSink(IQualityControl * piqc )
    {
        CAutoLock Lock(this);
        // This is a weak reference - no AddRef!
        if (piqc==NULL || IsEqualObject(piqc, m_pGraph)) {
            m_piqcSink = piqc;
            return NOERROR;
        } else {
            return E_NOTIMPL;
        }
    }

    // Override to implement a pure virtual
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
    {
        UNREFERENCED_PARAMETER(q);
        UNREFERENCED_PARAMETER(pSender);
        return E_NOTIMPL;             // We do NOT handle this
    }
#endif // THROTTLE

    //  Return a pointer to the format
    WAVEFORMATEX *WaveFormat() const
    {
        WAVEFORMATEX *pFormat = (WAVEFORMATEX *)m_pInputPin->m_mt.Format();
        return pFormat;
    };

private:
    // return the format tag of the current wave format block
    DWORD WaveFormatTag() {
        WAVEFORMATEX *pwfx = WaveFormat();

        if (!pwfx) return (0);

        return pwfx->wFormatTag;
    }

    // Pause helper for undo
    HRESULT DoPause();

public:

    // called by CWaveAllocator when it has finished with the device
    void OnReleaseComplete(void);

    // called by CWaveAllocator when it has completed a delayed OnAcquire
    HRESULT CompleteAcquire(HRESULT hr);

    // IPropertypage
    STDMETHODIMP GetPages(CAUUID * pPages);

#ifdef DSR_ENABLED
    // let the Direct Sound renderer share our callback thread
    CCallbackThread  * GetCallbackThreadObject()
    {
        return &m_callback;
    };
#endif // DSR_ENABLED

    // IPersistPropertyBag methods
    STDMETHOD(InitNew)(THIS);
    STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // IAMAudioRendererStats
    STDMETHODIMP GetStatParam( DWORD dwParam, DWORD *pdwParam1, DWORD *pdwParam2 );

    // IAMClockSlave
    STDMETHODIMP SetErrorTolerance( DWORD   dwTolerance );
    STDMETHODIMP GetErrorTolerance( DWORD * pdwTolerace );

    BOOL        m_fUsingWaveHdr;

    // in order to synchronise end-of-stream with the codec,
    // we have a long that counts the number of queued buffers, which we
    // access with InterlockedIncrement.  It is initialised to 0,
    // incremented whenever a buffer is added, and then decremented whenever
    // a buffer is completed. End-of-stream decrements it, so if the decrement
    // decrements it to -1, the wave callback knows it is EOS.  The wave callback
    // will then re-increment it back to 0 so it can detect future end of
    // streams.
    LONG        m_lBuffers;

    // See if there are actually any buffers waiting to be processed
    // by the device
    bool AreThereBuffersOutstanding() {
        return 0 == m_lBuffers + (m_eSentEOS == EOS_PENDING ? 1 : 0) ?
            false : true;
    }

private:

    // The actual rendering device (Direct Sound or Waveout)
    CSoundDevice    *m_pSoundDevice ;       // the sound device.

    LONG        m_lHeaderSize;
    BOOL    m_fDSound;

    const AMOVIESETUP_FILTER* m_pSetupFilter;

    // attempt to acquire the wave device. Returns S_FALSE if it is busy.
    HRESULT AcquireWaveDevice(void);

    // open the wave device - assumes we have the resource manager's
    // go-ahead to acquire it.
    HRESULT OpenWaveDevice(void);

    // subroutine to talk to the actual device and open it
    HRESULT DoOpenWaveDevice(void);

    // See if the device will support this rate/format combination
    inline HRESULT CheckRate(double dRate);

#ifdef DYNAMIC_RATE_CHANGE
    // reopen the wave device.  called on a rate change
    HRESULT ReOpenWaveDevice(double dRate);
#endif
    // reopen the wave device.  called on format change
    HRESULT ReOpenWaveDevice(CMediaType* pNewFormat);

    // actually close the wave handle
    HRESULT CloseWaveDevice(void);

    // cache the rate at which the audio device is running. this is
    // set from CARPosPassThru whenever we open the wave device. the
    // input pin has its own m_dRate recording NewSegment()'s
    // call. this is necessary because we don't handle dynamic rate
    // changes in NewSegment
    double m_dRate;

    // End of stream helper
    void SendComplete(BOOL bRunning, BOOL bAbort = FALSE);

    HRESULT ScheduleComplete(BOOL bAbort = FALSE);

    // device control call wrappers, used for EC_ notifications and failure logging
    MMRESULT amsndOutOpen
    (
        LPHWAVEOUT phwo,
        LPWAVEFORMATEX pwfx,
        double dRate,
        DWORD *pnAvgBytesPerSec,
        DWORD_PTR dwCallBack,
        DWORD_PTR dwCallBackInstance,
        DWORD fdwOpen,
        BOOL bNotifyOnFailure = TRUE
    );
    MMRESULT amsndOutClose( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutGetDevCaps( LPWAVEOUTCAPS pwoc, UINT cbwoc, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutGetPosition( LPMMTIME pmmt, UINT cbmmt, BOOL bUseAbsolutePos, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutPause( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutPrepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutUnprepareHeader( LPWAVEHDR pwh, UINT cbwh, BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutReset( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutRestart( BOOL bNotifyOnFailure = TRUE );
    MMRESULT amsndOutWrite ( LPWAVEHDR pwh, UINT cbwh, REFERENCE_TIME const *pStart, BOOL bIsDiscontinuity, BOOL bNotifyOnFailure = TRUE );

#ifdef THROTTLE
    // send quality notification to m_piqcSink when we run short of buffers
    // n is the number of buffers left, nMax is the total number we have
    // m_nLastSent is the last notified quality level
    // m_nMaxAudioQueue is the longest we have seen the queue grow to
    HRESULT SendForHelp(int n);
    int m_nLastSent;
    int m_nMaxAudioQueue;
#endif // THROTTLE

    /* The nested classes may access our private state */

    friend class CWaveOutInputPin;
    friend class CWaveOutClock;
    friend class CBasicAudioControl;   // needs the wave device handle
    friend class CWaveAllocator;       // needs the input pin
    friend class CWaveSlave;

    /* Member variables */
    CWaveOutInputPin *m_pInputPin;         /* IPin and IMemInputPin interfaces */

    CWaveOutClock *m_pRefClock;     // our internal ref clock

    // remember whose clock we are using.  This will have one of three
    // values: WAVE_OURCLOCK, WAVE_NOCLOCK, WAVE_OTHERCLOCK
    DWORD       m_fFilterClock;         // applies to m_pClock in the base class

    // Note: if we are working with an external clock then the behaviour
    // of the filter alters.  If an incoming sample would not play in time
    // then it is dropped.   If an incoming sample shows a significant gap
    // between its start and the end of the previous sample written to the
    // device queue then we pause the device for that time period.
    //
    // Note: we could stuff silence into the queue at this point and will
    // probably do so in future IF the silence stuffing can be handled by
    // the audio device itself (by returning S_OK to amaudioOutSilence).

    // !!! this is a broken concept.  DSound allows per-handle volume setting
    // but waveOut usually does not.  If we have per-handle volume control, this is
    // a good idea, because we need to re-set-up the volume every time we re-open the
    // device, but for waveOut or midiOut it's just annoying to the user.
    bool        m_fVolumeSet;           // need to set the volume
    BOOL        m_fHasVolume;           // wave device can set the volume

    DWORD       m_debugflag;

    HWAVEOUT    m_hwo;                  // handle to the wave device
    DWORD       m_lastWaveError;
    waveDeviceState  m_wavestate;
    DWORD_PTR   m_dwAdviseCookie;       // cookie used by advisecallback

    DWORD       m_dwScheduleCookie;     // cookie for clock dispatching

    void        SetWaveDeviceState(waveDeviceState wDS)
    {
        m_wavestate = wDS;
        // when we are finished trying to track down bug 26045 the above
        // line should be bracketed by #ifdef DEBUG/#endif
    };

    // handles IMediaPosition by passing upstream.
    // our override class will ask us to justify any new playback rate
    CARPosPassThru * m_pImplPosition;

    // handle setting/retrieving audio properties
    CBasicAudioControl m_BasicAudioControl;

    // Handle callbacks from the wave device which will occur when the
    // devices completes a wave buffer.  We will RELEASE the buffer which
    // will then be picked up and refilled.
    static void WaveOutCallback(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser,
                                        DWORD_PTR dw1, DWORD_PTR dw2);

    // Set up a routine that will handle callbacks from the clock.  It
    // would be good to not use a static routine, but then we get into a
    // mess trying to get the right THIS pointer.  It is simpler to get
    // the pointer passed back into the callback as a parameter.

    static void CALLBACK RestartWave(DWORD_PTR thispointer);

    // on an audio break we need to synchronise start of playing
    HRESULT SetUpRestartWave(LONGLONG rtStart, LONGLONG rtEnd);

    // Actually RestartWave
    void RestartWave();


    // Remember the time when the data in the wave device queue will
    // expire.  This value is reset by NextHdr().
    LONGLONG    m_llLastPos;

    CAMEvent    m_evPauseComplete; // set whenever transition to Pause is complete
    // note: the state of this event is only valid when m_State==State_Paused.
    // When we transition to Pause from Stopped we RESET the event.  The
    // event is SET on EOS or when data is written to the device queue.
    // GetState will be able to return VFW_S_STATE_INTERMEDIATE if we are
    // paused but do not have any data queued.

#ifdef PERF
    int m_idStartRunning;
    int m_idRestartWave;
    int m_idReleaseSample;
#endif

    // if there is an audio device, we register the resource strWaveName
    // and the id returned by the resource manager is stored here. We do
    // not unregister it (only the PnP removal could do that and it doesn't).
    LONG m_idResource;

    // hold a pointer to the filtergraph's resource manager interface,
    // if there is one. This is obtained in the JoinFilterGraph method.
    // Note that we don't hold a refcount on this (JoinFilterGraph(NULL) will
    // be called when we leave the filtergraph).
    IResourceManager* m_pResourceManager;

    // this interface is treated similarly to the IResourceManager, in that
    // we cache it in JoinFilterGraph, but don't hold a ref count on it
    IAMGraphStreams * m_pGraphStreams;

    DWORD       m_debugflag2;

    // TRUE if we have been told by the resource manager that we can have the
    // wave device.  FALSE if we can't have it, or have been told to give it
    // back.  We should only attempt to open the real wave device (and set
    // m_hwo) if this flag is TRUE.  However, this flag may be FALSE even
    // when m_hwo is set.  This condition indicates that we have been asked
    // to release the device, but have not yet completed the request.
    bool m_bHaveWaveDevice;

    // TRUE if we are currently running or paused and not in transition.
    // FALSE if stopped, or stopping. Can't use m_State because the
    // time that we need this (when calling NotifyRelease) is generally
    // during the shutdown process and the state changes too late.
    bool m_bActive;

    // Set TRUE in EndOfStream to say that EOS has been received
    // Set FALSE on filter creation and when moving to STOP, or connection broken
    bool m_bHaveEOS;            // EOS has been delivered

    // Send EOS OK - synced with m_csComplete
    bool m_bSendEOSOK;

    // TRUE if we have already sent EC_COMPLETE this activation (perhaps
    // because we have no device or lost the device). Will be reset on
    // a transition out of Run state.
    // This is a three-state flag as if we have data queued we send EOS
    // when the last buffer completes playing and is returned in the callback.
    // See eosSentState above for description.
    eosSentState m_eSentEOS;            // EOS has been (or is guaranteed to be) sent

#ifdef THROTTLE
    // NULL unless we have had SetSink called.
    // Non-null means send IQualityControl::Notify messages here
    IQualityControl * m_piqcSink;
#endif // THROTTLE


    // this object calls us back at a specified time - used for
    // EndOfStream processing when we don't have a wave device
    // and also for Direct Sound polling
    CCallbackThread m_callback;

    // this is the EOS function that it will callback to
    // the param is the this pointer. It will deliver EOS
    // to the input pin
    static void EOSAdvise(DWORD_PTR dw);

    // queue an EOS for when the end of the current segment should appear
    HRESULT QueueEOS();

    // callback advise token for EOS callback
    DWORD_PTR  m_dwEOSToken;

    // advise set for this stop time
    REFERENCE_TIME m_tEOSStop;

    // cancel the EOS callback if there is one outstanding
    HRESULT CancelEOSCallback();

    // IAMDirectSound stuff
    STDMETHODIMP GetDirectSoundInterface(LPDIRECTSOUND *lplpds);
    STDMETHODIMP GetPrimaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    STDMETHODIMP GetSecondaryBufferInterface(LPDIRECTSOUNDBUFFER *lplpdsb);
    STDMETHODIMP ReleaseDirectSoundInterface(LPDIRECTSOUND lpds);
    STDMETHODIMP ReleasePrimaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb);
    STDMETHODIMP ReleaseSecondaryBufferInterface(LPDIRECTSOUNDBUFFER lpdsb);
    STDMETHODIMP SetFocusWindow (HWND hwnd, BOOL bMixingOnOrOff) ;
    STDMETHODIMP GetFocusWindow (HWND *phwnd, BOOL *pbMixingOnOrOff) ;

#if 0
    // how many references has an app made to each of the above?
    int m_cDirectSoundRef, m_cPrimaryBufferRef, m_cSecondaryBufferRef;
#endif

    // We need to support IDirectSound3DListener and IDirectSound3DBuffer.
    // They have methods with the same name, so we need to nest and create
    // a separate object to support each one

    class CDS3D : public CUnknown, public IDirectSound3DListener
    {
        CWaveOutFilter * m_pWaveOut;

    public:
        // constructor
        //
        CDS3D (CWaveOutFilter * pWaveOut, HRESULT *phr) :
         CUnknown(NAME("DirectSound3DListener"), pWaveOut->GetOwner(), phr),
         m_pWaveOut(pWaveOut) { };

        DECLARE_IUNKNOWN

        // IDirectSound3DListener stuff
        STDMETHODIMP GetAllParameters(LPDS3DLISTENER);
        STDMETHODIMP GetDistanceFactor(LPD3DVALUE);
        STDMETHODIMP GetDopplerFactor(LPD3DVALUE);
        STDMETHODIMP GetOrientation(LPD3DVECTOR, LPD3DVECTOR);
        STDMETHODIMP GetPosition(LPD3DVECTOR);
        STDMETHODIMP GetRolloffFactor(LPD3DVALUE );
        STDMETHODIMP GetVelocity(LPD3DVECTOR);
        STDMETHODIMP SetAllParameters(LPCDS3DLISTENER, DWORD);
        STDMETHODIMP SetDistanceFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetDopplerFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetOrientation(D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetRolloffFactor(D3DVALUE, DWORD);
        STDMETHODIMP SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP CommitDeferredSettings();
    };

    class CDS3DB : public CUnknown, public IDirectSound3DBuffer
    {
        CWaveOutFilter * m_pWaveOut;

    public:
        // constructor
        //
        CDS3DB (CWaveOutFilter * pWaveOut, HRESULT *phr) :
         CUnknown(NAME("DirectSound3DBuffer"), pWaveOut->GetOwner(), phr),
         m_pWaveOut(pWaveOut) { };

        DECLARE_IUNKNOWN

        // IDirectSound3DBuffer stuff
        STDMETHODIMP GetAllParameters(LPDS3DBUFFER);
        STDMETHODIMP GetConeAngles(LPDWORD, LPDWORD);
        STDMETHODIMP GetConeOrientation(LPD3DVECTOR);
        STDMETHODIMP GetConeOutsideVolume(LPLONG);
        STDMETHODIMP GetMaxDistance(LPD3DVALUE);
        STDMETHODIMP GetMinDistance(LPD3DVALUE);
        STDMETHODIMP GetMode(LPDWORD);
        STDMETHODIMP GetPosition(LPD3DVECTOR);
        STDMETHODIMP GetVelocity(LPD3DVECTOR);
        STDMETHODIMP SetAllParameters(LPCDS3DBUFFER, DWORD);
        STDMETHODIMP SetConeAngles(DWORD, DWORD, DWORD);
        STDMETHODIMP SetConeOrientation(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetConeOutsideVolume(LONG, DWORD);
        STDMETHODIMP SetMaxDistance(D3DVALUE, DWORD);
        STDMETHODIMP SetMinDistance(D3DVALUE, DWORD);
        STDMETHODIMP SetMode(DWORD, DWORD);
        STDMETHODIMP SetPosition(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
        STDMETHODIMP SetVelocity(D3DVALUE, D3DVALUE, D3DVALUE, DWORD);
    };

    friend class CDS3D;
    friend class CDS3DB;
    friend class CDSoundDevice;

    CDS3D m_DS3D;
    CDS3DB m_DS3DB;

    // Have they QI'd for the 3D stuff?  Do they want to use it?
    // We have to make special buffers for 3D to work... but those special
    // buffers can only play in MONO!  So we really need to know if the app
    // wants 3D effects or not.  We'll decide that if they QI for it, they
    // will use it
    BOOL m_fWant3D;

    // IAMResourceControl
    STDMETHODIMP Reserve(
        /*[in]*/ DWORD dwFlags,          //  From _AMRESCTL_RESERVEFLAGS enum
        /*[in]*/ PVOID pvReserved        //  Must be NULL
    );
    DWORD m_dwLockCount;

    //  Control sending EC_COMPLETE over pause and run
    CCritSec    m_csComplete;

};


inline REFERENCE_TIME CWaveOutInputPin::GetFirstBufferStartTime()
{
    return m_rtActualSegmentStartTime;
}


// const int            HEADER_SIZE = (max(sizeof(WAVEHDR), sizeof(MIDIHDR)));
// !!! the above line should be right, but didn't compile correctly, who knows why.

template<class T> CUnknown* CreateRendererInstance(LPUNKNOWN pUnk, const AMOVIESETUP_FILTER* pamsf, HRESULT *phr)
{
    CSoundDevice *pDev = new T;
    if (pDev == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return NULL;
    }

    CUnknown* pAudioRenderer = new CWaveOutFilter(pUnk, phr, pamsf, pDev);
    if (pAudioRenderer == NULL)
    {
        delete pDev;
        *phr = E_OUTOFMEMORY;
        return NULL;
    }

    return pAudioRenderer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\xmlgraph\xmlgraph.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.


// Simple filter to build graphs from XML descriptions
//


// Tags supported now:
//
// <graph>			General enclosure
//
// <filter>
//	id="name"		(optional) name to use for filter
//	clsid="{...}"		specific filter to insert
//
//	instance="friendly name"
//				Note: we need a way to specify a non-default
//					member of a particular category
//				Note: filters/categories currently require full
//					CLSIDs, we could use the friendly name
//
// <connect>
//	src="name1"		first filter to connect
//	srcpin="pin_name1"	(optional) pin to connect,
//				otherwise use first avail output pin
//	dest="name2"
//	destpin="pin_name2"
//
//
// <param>			subtag of <filter>, allows setting properties
//	name="propname"
//	value="propval"		optional, if not supplied then contents of
//				the <param> tag are used as value
//
//				Possibly special case some parameters if
//				IPersistPropertyBag not implemented:
//				src="" could use IFileSourceFilter/IFileSinkFilter,
//				for instance
//

#include <streams.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "xmlgraph.h"
#include <atlbase.h>
#include <atlconv.h>

#include <msxml.h>

#include "qxmlhelp.h"
#include <qedit.h>
#include <qeditint.h>


//
// CEnumSomePins
//
// wrapper for IEnumPins
// Can enumerate all pins, or just one direction (input or output)
class CEnumSomePins {

public:

    enum DirType {PINDIR_INPUT, PINDIR_OUTPUT, All};

    CEnumSomePins(IBaseFilter *pFilter, DirType Type = All, bool fAllowConnected = false);
    ~CEnumSomePins();

    // the returned interface is addref'd
    IPin * operator() (void);

private:

    PIN_DIRECTION m_EnumDir;
    DirType       m_Type;
    bool	  m_fAllowConnected;

    IEnumPins	 *m_pEnum;
};




// *
// * CEnumSomePins
// *

// Enumerates a filter's pins.

//
// Constructor
//
// Set the type of pins to provide - PINDIR_INPUT, PINDIR_OUTPUT or all
CEnumSomePins::CEnumSomePins(
    IBaseFilter *pFilter,
    DirType Type,
    bool fAllowConnected
)
    : m_Type(Type), m_fAllowConnected(fAllowConnected)
{

    if (m_Type == PINDIR_INPUT) {

        m_EnumDir = ::PINDIR_INPUT;
    }
    else if (m_Type == PINDIR_OUTPUT) {

        m_EnumDir = ::PINDIR_OUTPUT;
    }

    ASSERT(pFilter);

    HRESULT hr = pFilter->EnumPins(&m_pEnum);
    if (FAILED(hr)) {
        // we just fail to return any pins now.
        DbgLog((LOG_ERROR, 0, TEXT("EnumPins constructor failed")));
        ASSERT(m_pEnum == 0);
    }
}


//
// CPinEnum::Destructor
//
CEnumSomePins::~CEnumSomePins(void) {

    if(m_pEnum) {
        m_pEnum->Release();
    }
}


//
// operator()
//
// return the next pin, of the requested type. return NULL if no more pins.
// NB it is addref'd
IPin *CEnumSomePins::operator() (void) {


    if(m_pEnum)
    {
        ULONG	ulActual;
        IPin	*aPin[1];

        for (;;) {

            HRESULT hr = m_pEnum->Next(1, aPin, &ulActual);
            if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more filters
                return NULL;
            }
            else if (hr == VFW_E_ENUM_OUT_OF_SYNC)
            {
                m_pEnum->Reset();

                continue;
            }
            else if (ulActual==0)
                return NULL;

            else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
                ASSERT(!"Pin enumerator broken - Continuation is possible");
                return NULL;
            }

            // if m_Type == All return the first pin we find
            // otherwise return the first of the correct sense

            PIN_DIRECTION pd;
            if (m_Type != All) {

                hr = aPin[0]->QueryDirection(&pd);

                if (FAILED(hr)) {
                    aPin[0]->Release();
                    ASSERT(!"Query pin broken - continuation is possible");
                    return NULL;
                }
            }

            if (m_Type == All || pd == m_EnumDir) {	// its the direction we want
		if (!m_fAllowConnected) {
		    IPin *ppin = NULL;
		    hr = aPin[0]->ConnectedTo(&ppin);

		    if (SUCCEEDED(hr)) {
			// it's connected, and we don't want a connected one,
			// so release both and try again
			ppin->Release();
			aPin[0]->Release();
			continue;
		    }
		}
                return aPin[0];
            }
	    else {		// it's not the dir we want, so release & try again
                aPin[0]->Release();
            }
        }
    }
    else                        // m_pEnum == 0
    {
        return 0;
    }
}



HRESULT FindThePin(IXMLElement *p, WCHAR *pinTag,
		IBaseFilter *pFilter, IPin **ppPin,
		PIN_DIRECTION pindir, WCHAR *szFilterName)
{
    HRESULT hr = S_OK;

    BSTR bstrPin = NULL;
    if (pinTag) bstrPin = FindAttribute(p, pinTag);

    if (bstrPin) {
	hr = (pFilter)->FindPin(bstrPin, ppPin);

	if (FAILED(hr)) {
#ifdef DEBUG
	    BSTR bstrName;
            hr = p->get_tagName(&bstrName);
            if (SUCCEEDED(hr)) {
                DbgLog((LOG_ERROR, 0,
                        TEXT("%ls couldn't find pin='%ls' on filter '%ls'"),
                        bstrName, bstrPin, szFilterName));
                SysFreeString(bstrName);
            }
#endif
	    hr = VFW_E_INVALID_FILE_FORMAT;
	}
	SysFreeString(bstrPin);	
    } else {
	CEnumSomePins Next(pFilter, (CEnumSomePins::DirType) pindir);

	*ppPin = Next();

	if (!*ppPin) {
#ifdef DEBUG
	    BSTR bstrName;
	    hr = p->get_tagName(&bstrName);
            if (SUCCEEDED(hr)) {
                DbgLog((LOG_ERROR, 0,
                        TEXT("%ls couldn't find an output pin on id='%ls'"),
                        bstrName, szFilterName));
                SysFreeString(bstrName);
            }
#endif
	    hr = VFW_E_INVALID_FILE_FORMAT;
	}
    }

    return hr;
}

class CXMLGraph : public CBaseFilter, public IFileSourceFilter, public IXMLGraphBuilder {
    public:
	CXMLGraph(LPUNKNOWN punk, HRESULT *phr);
	~CXMLGraph();
	
	int GetPinCount() { return 0; }

	CBasePin * GetPin(int n) { return NULL; }

	DECLARE_IUNKNOWN

	// override this to say what interfaces we support where
	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

	// -- IFileSourceFilter methods ---

	STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
	STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);

	// IXMLGraphBuilder methods
	STDMETHODIMP BuildFromXML(IGraphBuilder *pGraph, IXMLElement *pxml);
        STDMETHODIMP SaveToXML(IGraphBuilder *pGraph, BSTR *pbstrxml);
	STDMETHODIMP BuildFromXMLFile(IGraphBuilder *pGraph, WCHAR *wszXMLFile, WCHAR *wszBaseURL);

    private:
	HRESULT BuildFromXMLDocInternal(IXMLDocument *pxml);
	HRESULT BuildFromXMLInternal(IXMLElement *pxml);
	HRESULT BuildFromXMLFileInternal(WCHAR *wszXMLFile);

	HRESULT BuildChildren(IXMLElement *pxml);
    	HRESULT ReleaseNameTable();
	HRESULT BuildOneElement(IXMLElement *p);

	HRESULT FindFilterAndPin(IXMLElement *p, WCHAR *filTag, WCHAR *pinTag,
				 IBaseFilter **ppFilter, IPin **ppPin,
				 PIN_DIRECTION pindir);

	HRESULT FindNamedFilterAndPin(IXMLElement *p, WCHAR *wszFilterName, WCHAR *pinTag,
				      IBaseFilter **ppFilter, IPin **ppPin,
				      PIN_DIRECTION pindir);

	HRESULT AddFilter(IBaseFilter *pFilter, WCHAR *wszFilterName);
	

	WCHAR *m_pFileName;

	CCritSec m_csLock;

	IGraphBuilder *m_pGB;
};

CXMLGraph::CXMLGraph(LPUNKNOWN punk, HRESULT *phr) :
		       CBaseFilter(NAME("XML Graph Builder"), punk, &m_csLock, CLSID_XMLGraphBuilder),
		       m_pGB(NULL),
                       m_pFileName(NULL)
{
}

CXMLGraph::~CXMLGraph()
{
    delete[] m_pFileName;
}

STDMETHODIMP
CXMLGraph::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter*) this, ppv);
    } else if (riid == IID_IXMLGraphBuilder) {
	return GetInterface((IXMLGraphBuilder*) this, ppv);
    } else {
	return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

HRESULT
CXMLGraph::Load(LPCOLESTR lpwszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(lpwszFileName, E_POINTER);

    m_pFileName = new WCHAR[lstrlenW(lpwszFileName) + 1];
    if (m_pFileName!=NULL) {
	lstrcpyW(m_pFileName, lpwszFileName);
    } else
	return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (m_pGraph) {
	hr = m_pGraph->QueryInterface(IID_IGraphBuilder, (void **) &m_pGB);
	if (FAILED(hr))
	    return hr;

	hr = BuildFromXMLFileInternal((WCHAR *) lpwszFileName);

        ReleaseNameTable();

    } else {
	// m_fLoadLater = TRUE;
    }

    return hr;
}

// Modelled on IPersistFile::Load
// Caller needs to CoTaskMemFree or equivalent.

STDMETHODIMP
CXMLGraph::GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
}


HRESULT CXMLGraph::AddFilter(IBaseFilter *pFilter, WCHAR *pwszName)
{
    return m_pGB->AddFilter(pFilter, pwszName);
}

HRESULT CXMLGraph::FindFilterAndPin(IXMLElement *p, WCHAR *filTag, WCHAR *pinTag,
				  IBaseFilter **ppFilter, IPin **ppPin,
				  PIN_DIRECTION pindir)
{
    BSTR bstrFilter = FindAttribute(p, filTag);

    if (!bstrFilter) {
#ifdef DEBUG
	BSTR bstrName;
	p->get_tagName(&bstrName);
	DbgLog((LOG_ERROR, 0, TEXT("%ls needs filter id to be specified"),
		 bstrName));
	SysFreeString(bstrName);
#endif
	return VFW_E_INVALID_FILE_FORMAT;
    }

    HRESULT hr = FindNamedFilterAndPin(p, bstrFilter, pinTag, ppFilter, ppPin, pindir);
    SysFreeString(bstrFilter);

    return hr;
}

HRESULT CXMLGraph::FindNamedFilterAndPin(IXMLElement *p, WCHAR *wszFilterName, WCHAR *pinTag,
					 IBaseFilter **ppFilter, IPin **ppPin,
					 PIN_DIRECTION pindir)
{
    HRESULT hr = m_pGB->FindFilterByName(wszFilterName, ppFilter);

    if (FAILED(hr)) {
#ifdef DEBUG
	BSTR bstrName;
	p->get_tagName(&bstrName);
	DbgLog((LOG_ERROR, 0, TEXT("%hs couldn't find id='%ls'"),
		  bstrName, wszFilterName));
	SysFreeString(bstrName);
#endif
	return VFW_E_INVALID_FILE_FORMAT;
    }

    hr = FindThePin(p, pinTag, *ppFilter, ppPin, pindir, wszFilterName);

    return hr;
}




HRESULT CXMLGraph::BuildOneElement(IXMLElement *p)
{
    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = p->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    // do the appropriate thing based on the current tag
    if (!lstrcmpiW(bstrName, L"filter")) {
	BSTR bstrID = FindAttribute(p, L"id");
	BSTR bstrCLSID = FindAttribute(p, L"clsid");

	// !!! add prefix onto ID?
	
	IBaseFilter *pf = NULL;

	if (bstrCLSID) {
	    CLSID clsidFilter;
	    hr = CLSIDFromString(bstrCLSID, &clsidFilter);

	    if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 0, TEXT("FILTER with unparseable CLSID tag '%ls'"),
			 bstrCLSID));

		// !!! could enumerate filters looking for
		// string match

		hr = VFW_E_INVALID_FILE_FORMAT;
	    } else {
		hr = CoCreateInstance(clsidFilter, NULL, CLSCTX_INPROC,
				      IID_IBaseFilter, (void **) &pf);

		if (FAILED(hr)) {
		    DbgLog((LOG_ERROR, 0, TEXT("unable to create FILTER with CLSID tag '%ls'"),
			      bstrCLSID));
		}
	    }
	} else {
	    DbgLog((LOG_ERROR, 0, TEXT("FILTER with no CLSID or Category tag")));

	    // !!! someday, other ways to identify which filter?

	    hr = VFW_E_INVALID_FILE_FORMAT;
	}

	if (SUCCEEDED(hr)) {
	    hr = AddFilter(pf, bstrID);
	    if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 0, TEXT("failed to add new filter to graph???")));
	    }
	}

	if (SUCCEEDED(hr)) {
	    hr = HandleParamTags(p, pf);
	}

	// !!! if we're in a SEQUENCE block, automatically connect this to
	// the previous filter?

	if (pf)
	    pf->Release();

	if (bstrID)
	    SysFreeString(bstrID);
	if (bstrCLSID)
	    SysFreeString(bstrCLSID);

    } else if (!lstrcmpiW(bstrName, L"connect")) {
	// <connect src="f1" srcpin="out"  dest="f2"  destpin="in" direct="yes/no">
	// defaults:
	//    if srcpin not specified, find an unconnected output of first filter.
	//    if destpin not specified, find an unconnected input of second filter.
	// !!!!


	// !!! use name prefix?
	
	IBaseFilter *pf1 = NULL, *pf2 = NULL;
	IPin *ppin1 = NULL, *ppin2 = NULL;

	hr = FindFilterAndPin(p, L"src", L"srcpin", &pf1, &ppin1, PINDIR_OUTPUT);
	if (SUCCEEDED(hr))
	    hr = FindFilterAndPin(p, L"dest", L"destpin", &pf2, &ppin2, PINDIR_INPUT);

	if (SUCCEEDED(hr)) {
	    // okay, we finally have everything we need.

	    BOOL fDirect = ReadBoolAttribute(p, L"Direct", FALSE);

	    if (fDirect) {
		hr = m_pGB->ConnectDirect(ppin1, ppin2, NULL);

		DbgLog((LOG_TRACE, 1,
			  TEXT("CONNECT (direct) '%ls' to '%ls' returned %x"),
			  FindAttribute(p, L"src"), FindAttribute(p, L"dest"), hr));
	    }
	    else {
		hr = m_pGB->Connect(ppin1, ppin2);

		DbgLog((LOG_TRACE, 1,
			  TEXT("CONNECT (intelligent) '%ls' to '%ls' returned %x"),
			  FindAttribute(p, L"src"), FindAttribute(p, L"dest"), hr));
	    }
	}

	if (pf1)
	    pf1->Release();

	if (pf2)
	    pf2->Release();

	if (ppin1)
	    ppin1->Release();

	if (ppin2)
	    ppin2->Release();
    }  else {
	// !!! ignore unknown tags?

	DbgLog((LOG_ERROR, 1,
		  TEXT("unknown tag '%ls'???"),
		  bstrName));
	
    }


    SysFreeString(bstrName);

    return hr;
}

HRESULT CXMLGraph::ReleaseNameTable()
{
    if (m_pGB) {
	m_pGB->Release();
	m_pGB = NULL;
    }

    return S_OK;
}


STDMETHODIMP CXMLGraph::BuildFromXML(IGraphBuilder *pGraph, IXMLElement *pxml)
{
    m_pGB = pGraph;
    m_pGB->AddRef();

    HRESULT hr = BuildFromXMLInternal(pxml);

    ReleaseNameTable();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLInternal(IXMLElement *pxml)
{
    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = pxml->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    int i = lstrcmpiW(bstrName, L"graph");
    SysFreeString(bstrName);

    if (i != 0)
	return VFW_E_INVALID_FILE_FORMAT;

    hr = BuildChildren(pxml);
    return hr;
}

HRESULT CXMLGraph::BuildChildren(IXMLElement *pxml)
{
    IXMLElementCollection *pcoll;

    HRESULT hr = pxml->get_children(&pcoll);

    if (hr == S_FALSE)
	return S_OK; // nothing to do, is this an error?

    if (FAILED(hr))
        return hr;

    long lChildren;
    hr = pcoll->get_length(&lChildren);

    VARIANT var;

    var.vt = VT_I4;
    var.lVal = 0;

    for (SUCCEEDED(hr); var.lVal < lChildren; (var.lVal)++) {
	IDispatch *pDisp;
	hr = pcoll->item(var, var, &pDisp);

	if (SUCCEEDED(hr) && pDisp) {
	    IXMLElement *pelem;
	    hr = pDisp->QueryInterface(__uuidof(IXMLElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
                long lType;

                pelem->get_type(&lType);

                if (lType == XMLELEMTYPE_ELEMENT) {
                    hr = BuildOneElement(pelem);

                    pelem->Release();
                } else {
                    DbgLog((LOG_TRACE, 1, "XML element of type %d", lType));
                }
	    }
	    pDisp->Release();
	}

	if (FAILED(hr))
	    break;
    }

    pcoll->Release();

    return hr;
}	

HRESULT CXMLGraph::BuildFromXMLDocInternal(IXMLDocument *pxml)
{
    HRESULT hr = S_OK;

    IXMLElement *proot;

    hr = pxml->get_root(&proot);

    if (FAILED(hr))
	return hr;

    hr = BuildFromXMLInternal(proot);

    proot->Release();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLFile(IGraphBuilder *pGraph, WCHAR *wszXMLFile, WCHAR *wszBaseURL)
{
    m_pGB = pGraph;
    m_pGB->AddRef();

    HRESULT hr = BuildFromXMLFileInternal(wszXMLFile);

    ReleaseNameTable();

    return hr;
}

HRESULT CXMLGraph::BuildFromXMLFileInternal(WCHAR *wszXMLFile)
{
    IXMLDocument *pxml;
    HRESULT hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_INPROC_SERVER,
				  __uuidof(IXMLDocument), (void**)&pxml);

    if (SUCCEEDED(hr)) {
	hr = pxml->put_URL(wszXMLFile);

	// !!! async?

	if (SUCCEEDED(hr)) {
	    hr = BuildFromXMLDocInternal(pxml);
	}

	pxml->Release();
    }

    return hr;
}


//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CreateXMLGraphInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CXMLGraph(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Implements the CXMLGraphBuilder public member functions */


const int MAX_STRING_LEN=1024;  // wvsprintf limit

// WriteString
//
// Helper function to facilitate appending text to a string
//
BOOL WriteString(TCHAR * &ptsz, int &cbAlloc, LPCTSTR lptstr, ...)
{
    TCHAR atchBuffer[MAX_STRING_LEN];

    /* Format the variable length parameter list */

    va_list va;
    va_start(va, lptstr);

    wvsprintf(atchBuffer, lptstr, va);

    DWORD cToWrite=lstrlen(atchBuffer);

    DWORD cCurrent = lstrlen(ptsz);
    if ((int) (cCurrent + cToWrite) >= cbAlloc) {
        TCHAR *ptNew = new TCHAR[cbAlloc * 2];
        if (!ptNew)
            return FALSE;

        lstrcpy(ptNew, ptsz);
        cbAlloc = cbAlloc * 2;
        delete[] ptsz;
        ptsz = ptNew;
    }

    lstrcpy(ptsz + cCurrent, atchBuffer);

    return TRUE;
}

const int MAXFILTERS = 100;
typedef struct { //fit
    int iFilterCount;
    struct {
        DWORD dwUnconnectedInputPins;
        DWORD dwUnconnectedOutputPins;
        FILTER_INFO finfo;
        IBaseFilter * pFilter;
        bool IsSource;
    } Item[MAXFILTERS];
} FILTER_INFO_TABLE;


// GetNextOutFilter
//
// This function does a linear search and returns in iOutFilter the index of
// first filter in the filter information table  which has zero unconnected
// input pins and atleast one output pin  unconnected.
// Returns FALSE when there are none o.w. returns TRUE
//
BOOL GetNextOutFilter(FILTER_INFO_TABLE &fit, int *iOutFilter)
{
    for (int i=0; i < fit.iFilterCount; ++i) {
        if ((fit.Item[i].dwUnconnectedInputPins == 0) &&
                (fit.Item[i].dwUnconnectedOutputPins > 0)) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // then things with more outputs than inputs
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > fit.Item[i].dwUnconnectedInputPins) {
            *iOutFilter=i;
            return TRUE;
        }
    }

    // if that doesn't work, find one that at least has unconnected output pins....
    for (i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].dwUnconnectedOutputPins > 0) {
            *iOutFilter=i;
            return TRUE;
        }
    }
    return FALSE;
}

// LocateFilterInFIT
//
// Returns the index into the filter information table corresponding to
// the given IBaseFilter
//
int LocateFilterInFIT(FILTER_INFO_TABLE &fit, IBaseFilter *pFilter)
{
    int iFilter=-1;
    for (int i=0; i < fit.iFilterCount; ++i) {
        if (fit.Item[i].pFilter == pFilter)
            iFilter=i;
    }

    return iFilter;
}

// MakeScriptableFilterName
//
// Replace any spaces and minus signs in the filter name with an underscore.
// If it is a source filtername than it actually is a file path (with the
// possibility of some stuff added at the end for uniqueness), we create a good filter
// name for it here.
//
void MakeScriptableFilterName(WCHAR awch[], BOOL bSourceFilter, int& cSources)
{
    if (bSourceFilter) {
        WCHAR awchBuf[MAX_FILTER_NAME + 100];
        BOOL bExtPresentInName=FALSE;
        int iBuf=0;
        for (int i=0; awch[i] != L'\0';++i) {
            if (awch[i]==L'.' && awch[i+1]!=L')') {
                for (int j=1; j <=3; awchBuf[iBuf]=towupper(awch[i+j]),++j,++iBuf);
                awchBuf[iBuf++]=L'_';
                wcscpy(&(awchBuf[iBuf]), L"Source_");
                bExtPresentInName=TRUE;
                break;
            }
        }

        // If we have a filename with no extension than create a suitable name

        if (!bExtPresentInName) {
            wcscpy(awchBuf, L"Source_");
        }

        // make source filter name unique by appending digit always, we don't want to
        // bother to make it unique only if its another instance of the same source
        // filter
        WCHAR awchSrcFilterCnt[10];
        wcscpy(&(awchBuf[wcslen(awchBuf)]),
                _ltow(cSources++, awchSrcFilterCnt, 10));
        wcscpy(awch, awchBuf);
    } else {

        for (int i = 0; i < MAX_FILTER_NAME; i++) {
            if (awch[i] == L'\0')
                break;
            else if ((awch[i] == L' ') || (awch[i] == L'-'))
                awch[i] = L'_';
        }
    }
}

// PopulateFIT
//
// Scans through all the filters in the graph, storing the number of input and out
// put pins for each filter, and identifying the source filters in the filter
// inforamtion table. The object tag statements are also printed here
//
void PopulateFIT(TCHAR * &ptsz, int &cbAlloc, IFilterGraph *pGraph,
        FILTER_INFO_TABLE *pfit, int &cSources)
{
    HRESULT hr;
    IEnumFilters *penmFilters=NULL;
    if (FAILED(hr=pGraph->EnumFilters(&penmFilters))) {
        WriteString(ptsz, cbAlloc, TEXT("'Error[%x]:EnumFilters failed!\r\n"), hr);
    }

    IBaseFilter *pFilter;
    ULONG n;
    while (penmFilters && (penmFilters->Next(1, &pFilter, &n) == S_OK)) {
	pfit->Item[pfit->iFilterCount].pFilter = pFilter;
	
        // Get the input and output pin counts for this filter

        IEnumPins *penmPins=NULL;
        if (FAILED(hr=pFilter->EnumPins(&penmPins))) {
            WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: EnumPins for Filter Failed !\r\n"), hr);
        }

        IPin *ppin = NULL;
        while (penmPins && (penmPins->Next(1, &ppin, &n) == S_OK)) {
            PIN_DIRECTION pPinDir;
            if (SUCCEEDED(hr=ppin->QueryDirection(&pPinDir))) {
                if (pPinDir == PINDIR_INPUT)
                    pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins++;
                else
                    pfit->Item[pfit->iFilterCount].dwUnconnectedOutputPins++;
            } else {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
            }

            ppin->Release();
        }

        if (penmPins)
            penmPins->Release();

        // Mark the source filters, remember at this point any filters that have
        // all input pins connected (or don't have any input pins) must be sources

        if (pfit->Item[pfit->iFilterCount].dwUnconnectedInputPins==0)
            pfit->Item[pfit->iFilterCount].IsSource=TRUE;


	if (FAILED(hr=pFilter->QueryFilterInfo(&pfit->Item[pfit->iFilterCount].finfo))) {
	    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryFilterInfo Failed!\r\n"),hr);

	} else {
	    QueryFilterInfoReleaseGraph(pfit->Item[pfit->iFilterCount].finfo);

            MakeScriptableFilterName(pfit->Item[pfit->iFilterCount].finfo.achName,
                    pfit->Item[pfit->iFilterCount].IsSource, cSources);
	}

	if(pfit->iFilterCount++ >= NUMELMS(pfit->Item)) {
            DbgLog((LOG_ERROR, 0, TEXT("PopulateFIT: too many filters")));
            break;
        }
    }

    if (penmFilters)
        penmFilters->Release();
}


void PrintFiltersAsXML(TCHAR * &ptsz, int &cbAlloc, FILTER_INFO_TABLE *pfit)
{
    HRESULT hr;
	
    for (int i = 0; i < pfit->iFilterCount; i++) {
	LPWSTR lpwstrFile = NULL;
    	IBaseFilter *pFilter = pfit->Item[i].pFilter;

	IFileSourceFilter *pFileSourceFilter=NULL;
	if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IFileSourceFilter,
			                    reinterpret_cast<void **>(&pFileSourceFilter)))) {
            hr = pFileSourceFilter->GetCurFile(&lpwstrFile, NULL);
            pFileSourceFilter->Release();
        } else {
	    IFileSinkFilter *pFileSinkFilter=NULL;
	    if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IFileSinkFilter,
						reinterpret_cast<void **>(&pFileSinkFilter)))) {
		hr = pFileSinkFilter->GetCurFile(&lpwstrFile, NULL);
		pFileSinkFilter->Release();
	    }
	}


        IPersistPropertyBag *pPPB = NULL;

        if (SUCCEEDED(hr = pFilter->QueryInterface(IID_IPersistPropertyBag, (void **) &pPPB))) {
            CLSID clsid;
            if (SUCCEEDED(hr=pPPB->GetClassID(&clsid))) {
                WCHAR szGUID[100];
                StringFromGUID2(clsid, szGUID, 100);

                CFakePropertyBag bag;

                hr = pPPB->Save(&bag, FALSE, FALSE); // fClearDirty=FALSE, fSaveAll=FALSE

                if (SUCCEEDED(hr)) {
                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                pfit->Item[i].finfo.achName, szGUID);
                    POSITION pos1, pos2;
                    for(pos1 = bag.m_listNames.GetHeadPosition(),
                        pos2 = bag.m_listValues.GetHeadPosition();
                        pos1;
                        pos1 = bag.m_listNames.Next(pos1),
                        pos2 = bag.m_listValues.Next(pos2))
                    {
                        WCHAR *pName = bag.m_listNames.Get(pos1);
                        WCHAR *pValue = bag.m_listValues.Get(pos2);

                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"%ls\" value=\"%ls\"/>\r\n"),
                                    pName, pValue);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                pfit->Item[i].finfo.achName, szGUID, lpwstrFile);

                } else {
                    // we'll fall through and IPersistStream in this case!
                    // if it was E_NOTIMPL, it's a hacky filter that just supports IPersistPropertyBag to
                    // load from a category, don't report an error.
                    if (hr != E_NOTIMPL)
                        WriteString(ptsz, cbAlloc, TEXT("<!-- 'Error[%x]: IPersistPropertyBag failed! -->\r\n"), hr);
                }
            }

            pPPB->Release();
        }

        if (FAILED(hr)) {
            IPersistStream *pPS = NULL;
            IPersist *pP = NULL;
            if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersistStream, (void**) &pPS))) {
                CLSID clsid;

                if (SUCCEEDED(hr=pPS->GetClassID(&clsid))) {
                    WCHAR szGUID[100];
                    StringFromGUID2(clsid, szGUID, 100);

                    HGLOBAL h = GlobalAlloc(GHND, 0x010000); // !!! 64K, why?
                    IStream *pstr = NULL;
                    hr = CreateStreamOnHGlobal(h, TRUE, &pstr);

                    LARGE_INTEGER li;
                    ULARGE_INTEGER liCurrent, li2;
                    li.QuadPart = liCurrent.QuadPart = 0;
                    if (SUCCEEDED(hr)) {
                        hr = pPS->Save(pstr, FALSE);

                        if (SUCCEEDED(hr)) {
                            pstr->Seek(li, STREAM_SEEK_CUR, &liCurrent); // get length
                            pstr->Seek(li, STREAM_SEEK_SET, &li2); // seek to start
                        }
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID);
                    if (lpwstrFile) {
                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"src\" value=\"%ls\"/>\r\n"),
                                   lpwstrFile);
                    }

                    if (liCurrent.QuadPart > 0) {
                        // !!! Idea from SyonB: check if data is really just text and
                        // if so don't hex-encode it.  Obviously also needs support on
                        // the other end.

                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"data\" value=\""),
                                   lpwstrFile);

                        for (ULONGLONG i = 0; i < liCurrent.QuadPart; i++) {
                            BYTE b;
                            DWORD cbRead;
                            pstr->Read(&b, 1, &cbRead);

                            WriteString(ptsz, cbAlloc, TEXT("%02X"), b);
                        }

                        WriteString(ptsz, cbAlloc, TEXT("\"/>\r\n"),
                                   lpwstrFile);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID, lpwstrFile);
                } else {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: GetClassID for Filter Failed !\r\n"), hr);
                }

                pPS->Release();
            } else if (SUCCEEDED(hr=pFilter->QueryInterface(IID_IPersist, (void**) &pP))) {
                CLSID clsid;

                if (SUCCEEDED(hr=pP->GetClassID(&clsid))) {
                    WCHAR szGUID[100];
                    StringFromGUID2(clsid, szGUID, 100);
                    WriteString(ptsz, cbAlloc, TEXT("\t<FILTER ID=\"%ls\" clsid=\"%ls\">\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID);
                    if (lpwstrFile) {
                        WriteString(ptsz, cbAlloc, TEXT("\t\t<PARAM name=\"src\" value=\"%ls\"/>\r\n"),
                                   lpwstrFile);
                    }

                    WriteString(ptsz, cbAlloc, TEXT("\t</FILTER>\r\n"),
                                   pfit->Item[i].finfo.achName, szGUID, lpwstrFile);
                }
                pP->Release();
            } else {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: Filter doesn't support IID_IPersist!\r\n"), hr);
            }
        }

	if (lpwstrFile) {
	    CoTaskMemFree(lpwstrFile);
	    lpwstrFile = NULL;
	}
    }
}


HRESULT CXMLGraph::SaveToXML(IGraphBuilder *pGraph, BSTR *pbstrxml)
{
    HRESULT hr;
    ULONG n;
    FILTER_INFO_TABLE fit;
    ZeroMemory(&fit, sizeof(fit));

    int cbAlloc = 1024;
    TCHAR *ptsz = new TCHAR[cbAlloc];
    if (!ptsz)
        return E_OUTOFMEMORY;
    ptsz[0] = TEXT('\0');

    int cSources = 0;

    // write the initial header tags and instantiate the filter graph
    WriteString(ptsz, cbAlloc, TEXT("<GRAPH version=\"1.0\">\r\n"));

    // Fill up the Filter information table and also print the <OBJECT> tag
    // filter instantiations
    PopulateFIT(ptsz, cbAlloc, pGraph, &fit, cSources);

    PrintFiltersAsXML(ptsz, cbAlloc, &fit);

    // Find a filter with zero unconnected input pins and > 0 unconnected output pins
    // Connect the output pins and subtract the connections counts for that filter.
    // Quit when there is no such filter left
    for (int i=0; i< fit.iFilterCount; i++) {
        int iOutFilter=-1; // index into the fit
        if (!GetNextOutFilter(fit, &iOutFilter))
            break;
        ASSERT(iOutFilter !=-1);
        IEnumPins *penmPins=NULL;
        if (FAILED(hr=fit.Item[iOutFilter].pFilter->EnumPins(&penmPins))) {
            WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: EnumPins failed for Filter!\r\n"), hr);
        }
        IPin *ppinOut=NULL;
        while (penmPins && (penmPins->Next(1, &ppinOut, &n)==S_OK)) {
            PIN_DIRECTION pPinDir;
            if (FAILED(hr=ppinOut->QueryDirection(&pPinDir))) {
                WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryDirection Failed!\r\n"), hr);
                ppinOut->Release();
                continue;
            }
            if (pPinDir == PINDIR_OUTPUT) {
                LPWSTR pwstrOutPinID;
                LPWSTR pwstrInPinID;
                IPin *ppinIn=NULL;
                PIN_INFO pinfo;
                FILTER_INFO finfo;
                if (FAILED(hr=ppinOut->QueryId(&pwstrOutPinID))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinOut->ConnectedTo(&ppinIn))) {

                    // It is ok if a particular pin is not connected since we allow
                    // a pruned graph to be saved
                    if (hr == VFW_E_NOT_CONNECTED) {
                        fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                    } else {
                        WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: ConnectedTo Failed! \r\n"), hr);
                    }
                    ppinOut->Release();
                    continue;
                }
                if (FAILED(hr= ppinIn->QueryId(&pwstrInPinID))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryId Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                if (FAILED(hr=ppinIn->QueryPinInfo(&pinfo))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryPinInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    ppinIn->Release();
                    continue;
                }
                ppinIn->Release();
                QueryPinInfoReleaseFilter(pinfo)
                int iToFilter = LocateFilterInFIT(fit, pinfo.pFilter);
                ASSERT(iToFilter < fit.iFilterCount);
                if (FAILED(hr=pinfo.pFilter->QueryFilterInfo(&finfo))) {
                    WriteString(ptsz, cbAlloc, TEXT("'Error[%x]: QueryFilterInfo Failed! \r\n"), hr);
                    ppinOut->Release();
                    continue;
                }
                QueryFilterInfoReleaseGraph(finfo)
                MakeScriptableFilterName(finfo.achName, fit.Item[iToFilter].IsSource, cSources);
                WriteString(ptsz, cbAlloc, TEXT("\t<connect direct=\"yes\" ")
						TEXT("src=\"%ls\" srcpin=\"%ls\" ")
						TEXT("dest=\"%ls\" destpin=\"%ls\"/>\r\n"),
			 fit.Item[iOutFilter].finfo.achName,
			 pwstrOutPinID, finfo.achName, pwstrInPinID);

                QzTaskMemFree(pwstrOutPinID);
                QzTaskMemFree(pwstrInPinID);

                // decrement the count for the unconnected pins for these two filters
                fit.Item[iOutFilter].dwUnconnectedOutputPins--;
                fit.Item[iToFilter].dwUnconnectedInputPins--;
            }
            ppinOut->Release();
        }
        if (penmPins)
            penmPins->Release();
    }

    // Release all the filters in the fit
    for (i = 0; i < fit.iFilterCount; i++)
        fit.Item[i].pFilter->Release();

    WriteString(ptsz, cbAlloc, TEXT("</GRAPH>\r\n"));

    USES_CONVERSION;

    *pbstrxml = T2BSTR(ptsz);

    if (!pbstrxml)
        return E_OUTOFMEMORY;

    delete[] ptsz;

    return S_OK;
}



#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"XML Graphbuilder"
    , &CLSID_XMLGraphBuilder
    , CreateXMLGraphInstance
    , NULL
    , NULL }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#include <atlimpl.cpp>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    sources.inc

Abstract:

    Common makefile for ActiveMovie filters.

Revision History:

    06-Nov-1996 DonRyan
        Created.
    25-Nov-1996 TomOR
        Modified for Ks stuff.
    10-Oct-1999 Jaybo
	Added FILTER_DLL; define this in your environment to create separate
	DLLs instead of one massive ksproxy.ax.  This turns off the definition
	of FILTER_LIB in various sources files.

!ENDIF

###############################################################################
#                                                                             #
#  Private Definitions                                                        #
#                                                                             #
###############################################################################

!ifdef FILTER_LIB
TARGETTYPE=LIBRARY
#TARGETPATH=$(PROJECT_LIB_PATH) DOESN'T WORK HERE!  YOU GET i386\i386 TWICE!!!
C_DEFINES=$(C_DEFINES) -DFILTER_LIB
!else
TARGETTYPE=DYNLINK
TARGETEXT=ax
C_DEFINES=$(C_DEFINES) -DFILTER_DLL
!endif

###############################################################################
#                                                                             #
#  Debug Support                                                              #
#                                                                             #
###############################################################################

!IF ("$(NTDEBUG)" != "") && ("$(NTDEBUG)" != "ntsdnodbg") && ("$(NTDEBUG)" != "retail")
C_DEFINES=$(C_DEFINES) -DDEBUG
!ENDIF

###############################################################################
#                                                                             #
#  Profile Support                                                            #
#                                                                             #
###############################################################################

!IF "$(NTPROFILE)" == ""
STRM_PROFILE_FLAG=
STRM_PROFILE_LIB=
!ELSE
!    IF "$NTPROFILE)" == "cap"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\cap.lib
!    ELSE
!        IF "$(NTPROFILE)" == "wst"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\wst.lib
!        ELSE
!            error NTPROFILE macro can be either "", "cap", or "wst"
!        ENDIF
!    ENDIF
!ENDIF

###############################################################################
#                                                                             #
#  Global Definitions                                                         #
#                                                                             #
###############################################################################

DLLENTRY=DllEntryPoint
MSC_WARNING_LEVEL=/W3 /WX
NOT_LEAN_AND_MEAN=1
USE_CRTDLL=1
386_FLAGS=$(STRM_PROFILE_FLAG)

#Compatibility with Memphis
SUBSYSTEM_VERSION=4.00

###############################################################################
#                                                                             #
#  Includes                                                                   #
#                                                                             #
###############################################################################

INCLUDES=\
    $(SDK_PATH)\amovie\inc

###############################################################################
#                                                                             #
#  Link Libraries                                                             #
#                                                                             #
###############################################################################

!IFNDEF FILTER_LIB

STRMBASE_LIB=$(PROJECT_ROOT)\published\dxmdev\dshowdev\base\$(O)\strmbase.lib

LINKLIBS=\
    $(STRMBASE_LIB)

###############################################################################
#                                                                             #
#  Target Libraries                                                           #
#                                                                             #
###############################################################################

TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\vfw32.lib    \
    $(SDK_LIB_PATH)\winmm.lib    \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(STRM_PROFILE_LIB)

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters\xmlgraph\xmlgraph.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// {1BB05960-5FBF-11d2-A521-44DF07C10000}
DEFINE_GUID(IID_IXMLGraphBuilder, 
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
DEFINE_GUID(CLSID_XMLGraphBuilder, 
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

CUnknown *CreateXMLGraphInstance(LPUNKNOWN, HRESULT *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdaca.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaConditionalAccess::CBdaConditionalAccess (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "CBdaConditionalAccess"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaConditionalAccess: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaConditionalAccess::~CBdaConditionalAccess ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::put_TuneRequest (
    ITuneRequest *      pTuneRequest
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::put_Locator (
    ILocator *          pLocator
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::AddComponent (
    IComponent *        pComponent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::RemoveComponent (
    IComponent *        pComponent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaConditionalAccess::PutTableSection (
    PBDA_TABLE_SECTION  pBdaTableSection
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;

    DbgLog( ( LOG_TRACE,
              0,
              "CBdaConditionalAccess: Putting table section.\n")
          );

    if (m_pControlNode)
    {
        hrStatus = m_pControlNode->put_BdaNodeProperty(
                                KSPROPSETID_BdaTableSection,
                                KSPROPERTY_BDA_TABLE_SECTION,
                                (UCHAR *) pBdaTableSection,
                                sizeof( BDA_TABLE_SECTION) + pBdaTableSection->ulcbSectionLength + 3
                                );
    }
    else
    {
        hrStatus = E_NOINTERFACE;
    }

    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaConditionalAccess: Can't put table section (0x%08x).\n", hrStatus)
              );
    }

    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdademod.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaDigitalDemodulator::CBdaDigitalDemodulator (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_DigitalDemodulator"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaDigitalDemodulator: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaDigitalDemodulator::~CBdaDigitalDemodulator ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_ModulationType (
    ModulationType *    pModulationType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_MODULATION_TYPE,
                             pModulationType,
                             sizeof( ModulationType)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_ModulationType (
    ModulationType *    pModulationType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_InnerFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_INNER_FEC_TYPE,
                             pFECMethod,
                             sizeof( FECMethod)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_InnerFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_InnerFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_INNER_FEC_RATE,
                             pFECRate,
                             sizeof( BinaryConvolutionCodeRate)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_InnerFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_OuterFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_OUTER_FEC_TYPE,
                             pFECMethod,
                             sizeof( FECMethod)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_OuterFECMethod (
    FECMethod * pFECMethod
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_OuterFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_OUTER_FEC_RATE,
                             pFECRate,
                             sizeof( BinaryConvolutionCodeRate)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_OuterFECRate (
    BinaryConvolutionCodeRate * pFECRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_SymbolRate (
    ULONG * pSymbolRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SYMBOL_RATE,
                             pSymbolRate,
                             sizeof( ULONG)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_SymbolRate (
    ULONG * pSymbolRate
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_SpectralInversion (
    SpectralInversion * pSpectralInversion
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SPECTRAL_INVERSION,
                             pSpectralInversion,
                             sizeof( SpectralInversion)
                             );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_SpectralInversion (
    SpectralInversion * pSpectralInversion
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_DigitalDemodulator),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDigitalDemodulator::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_DigitalDemodulator),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdaca.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Conditional Access class
//
class CBdaConditionalAccess :
    public CUnknown,
    public IBDA_Mpeg2CA
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaConditionalAccess (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaConditionalAccess ( );


    STDMETHODIMP
    put_TuneRequest (
        ITuneRequest *      pTuneRequest
        );

    STDMETHODIMP
    put_Locator (
        ILocator *          pLocator
        );

    STDMETHODIMP
    AddComponent (
        IComponent *        pComponent
        );

    STDMETHODIMP
    RemoveComponent (
        IComponent *        pComponent
        );

    STDMETHODIMP
    PutTableSection (
        PBDA_TABLE_SECTION  pTableSection
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdafreq.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



///////////////////////////////////////////////////////////////////////////////
CBdaFrequencyFilter::CBdaFrequencyFilter (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_FrequencyFilter"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: No parent specified.\n")
              );

        return;
    }



    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}

///////////////////////////////////////////////////////////////////////////////
CBdaFrequencyFilter::~CBdaFrequencyFilter ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Autotune (
    ULONG       ulTransponder
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Autotune (
    ULONG *     pulTransponder
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Frequency (
    ULONG       ulFrequency
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY,
                             &ulFrequency,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner frequency (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Frequency (
    ULONG *     pulFrequency
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Polarity (
    Polarisation    Polarity
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_POLARITY,
                             &Polarity,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner polarity (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Polarity (
    Polarisation *  pPolarity
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Range (
    ULONG       ulRange
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_RANGE,
                             &ulRange,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner range / LNB power (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Range (
    ULONG *     pulRange
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_Bandwidth (
    ULONG       ulBandwidth
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,
                             &ulBandwidth,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put tuner bandwidth (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_Bandwidth (
    ULONG *         pulBandwidth
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_FrequencyMultiplier (
    ULONG       ulMultiplier
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;


    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_RF_TUNER_FREQUENCY_MULTIPLIER,
                             &ulMultiplier,
                             sizeof( LONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put frequency multiplier (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_FrequencyMultiplier (
    ULONG *     pulMultiplier
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_FrequencyFilter),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaFrequencyFilter::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_FrequencyFilter),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}




///////////////////////////////////////////////////////////////////////////////
CBdaLNBInfo::CBdaLNBInfo (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_LNBInfo"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaLNBInfo: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}


///////////////////////////////////////////////////////////////////////////////
CBdaLNBInfo::~CBdaLNBInfo ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_LocalOscilatorFrequencyLowBand (
        ULONG       ulLOFLow
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_LOF_LOW_BAND,
                             &ulLOFLow,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB Low Band Local Oscillator Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_LocalOscilatorFrequencyLowBand (
        ULONG *     pulLOFLow
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_LocalOscilatorFrequencyHighBand (
        ULONG       ulLOFHigh
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_LOF_HIGH_BAND,
                             &ulLOFHigh,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB High Band Local Oscillator Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_LocalOscilatorFrequencyHighBand (
        ULONG *     pulLOFHigh
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_HighLowSwitchFrequency (
        ULONG       ulSwitchFrequency
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_LNB_SWITCH_FREQUENCY,
                             &ulSwitchFrequency,
                             sizeof( ULONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaFrequencyFilter: Can't put LNB High/Low Switch Frequency(0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_HighLowSwitchFrequency (
        ULONG *     pulSwitchFrequency
        )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_LNBInfo),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaLNBInfo::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_LNBInfo),
                            dwPropID,
                            (UCHAR *)pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdaplgin.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: BdaPlgIn.cpp
//
//  Abstract:
//
//    Implements BDA Device Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
typedef enum
{
    KSEVENT_BDA_DEVICE_EVENT,

} KSEVENT_BDA_DEVICE;


////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {   L"IBDA_DeviceControl",
        &IID_IBDA_DeviceControl,
        CBdaDeviceControlInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
    {   L"IBDA_PinControl",
        &IID_IBDA_PinControl,
        CBdaPinControlInterfaceHandler::CreateInstance,
        NULL,
        NULL
    },
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);


///////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI
DllRegisterServer (
    void
    )
{
    return AMovieDllRegisterServer2( TRUE );

}


///////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer (
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer



///////////////////////////////////////////////////////////////////////////////
HRESULT
FindInterfaceOnGraph (
    IUnknown* pUnkGraph,
    REFIID riid,
    void **ppInterface
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    ULONG ulFetched = 0;

    if(!ppInterface)
    {
        return E_FAIL;
    }

    *ppInterface= NULL;

    if(!pUnkGraph)
    {
        return E_FAIL;
    }

    CComQIPtr<IFilterGraph, &IID_IFilterGraph> pFilterGraph(pUnkGraph);

    hr = pFilterGraph->EnumFilters(&pEnum);
    if(!pEnum)
    {
        return hr;
    }

    //
    // find the first filter in the graph that supports riid interface
    //
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }

    return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CBdaDeviceControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   pUnkOuter,
    HRESULT*    pHrStatus
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *pUnknown;

    pUnknown = new CBdaDeviceControlInterfaceHandler(
                       pUnkOuter,
                       NAME("IBDA_DeviceControl"),
                       pHrStatus
                       );
    if (!pUnknown)
    {
        *pHrStatus = E_OUTOFMEMORY;
    }

    return pUnknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaDeviceControlInterfaceHandler::CBdaDeviceControlInterfaceHandler(
    LPUNKNOWN   pUnkOuter,
    TCHAR*      ptchName,
    HRESULT*    phrStatus
    ) :
    CUnknown( ptchName, pUnkOuter, phrStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    IKsObject*   pKsObject = NULL;


    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Bad outer IUnknown.\n")
              );
        *phrStatus = VFW_E_NEED_OWNER;
        goto exit;
    }

    //  Initialize members
    //
    m_ObjectHandle = NULL;
    m_EndEventHandle = NULL;
    m_pBaseFilter = NULL;
    m_pGraph = NULL;
    m_pNetProvider = NULL;


    //  Get the IKsObject interface on KSProxy so that we can communicate
    //  with the driver.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                          __uuidof(IKsObject),
                          reinterpret_cast<PVOID*>(&pKsObject)
                          );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get IKSObject for device.\n")
              );
        goto errExit;
    }

    //  Get the interface to the DShow Filter.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                         __uuidof( IBaseFilter),
                         reinterpret_cast<PVOID*>(&m_pBaseFilter)
                         );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get IBaseFilter for device.\n")
              );
        goto errExit;
    }

    //  Since we are an aggregated to the base filter we must not keep
    //  a reference to the basefilter.
    //
    //$REVIEW - Can we use this Interface or must we always QI and Release
    //
    m_pBaseFilter->Release();

    //  Get the handle of the device.
    //
    m_ObjectHandle = pKsObject->KsGetObjectHandle( );
    if (!m_ObjectHandle)
    {
        *phrStatus = E_UNEXPECTED;
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get device handle.\n")
              );
        goto errExit;
    }


exit:
    RELEASE_AND_CLEAR( pKsObject);
    return;

errExit:
    RELEASE_AND_CLEAR( m_pBaseFilter);
    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pGraph);

    //$BUG  Close threads and devices

    goto exit;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaDeviceControlInterfaceHandler::~CBdaDeviceControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    DbgLog(( LOG_TRACE,
             10,
             "In BdaPlugIn DeviceControl Destructor\n"
           ));


    RELEASE_AND_CLEAR( m_pBaseFilter);
    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pGraph);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_DeviceControl))
    {
        return GetInterface(static_cast<IBDA_DeviceControl*>(this), ppv);
    }
    else if (riid ==  __uuidof(IBDA_Topology))
    {
        return GetInterface(static_cast<IBDA_Topology*>(this), ppv);
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::StartChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmStartChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> StartChanges.\n"
           ));

    ksmStartChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmStartChanges.Id = KSMETHOD_BDA_START_CHANGES;
    ksmStartChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmStartChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CheckChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmCheckChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CheckChanges.\n"
           ));

    ksmCheckChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmCheckChanges.Id = KSMETHOD_BDA_CHECK_CHANGES;
    ksmCheckChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCheckChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CommitChanges(
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSMETHOD    ksmCommitChanges;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CommitChanges.\n"
           ));

    ksmCommitChanges.Set = KSMETHODSETID_BdaChangeSync;
    ksmCommitChanges.Id = KSMETHOD_BDA_COMMIT_CHANGES;
    ksmCommitChanges.Flags = KSMETHOD_TYPE_NONE;

    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCommitChanges,
                    sizeof(KSMETHOD),
                    NULL,
                    NULL,
                    &BytesReturned
                    );

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetChangeState(
    ULONG *     pulChangeState
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> GetChangeState.\n"
           ));

    *pulChangeState = 0;

    return hResult;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::Set (
     IN  PKSPROPERTY pBdaDeviceControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pBdaDeviceControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::Get (
     IN  PKSPROPERTY pBdaDeviceControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pBdaDeviceControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}




////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CBdaPinControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   pUnkOuter,
    HRESULT*    pHrStatus
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *pUnknown;

    pUnknown = new CBdaPinControlInterfaceHandler(
                       pUnkOuter,
                       NAME("IBDA_PinControl"),
                       pHrStatus
                       );
    if (!pUnknown)
    {
        *pHrStatus = E_OUTOFMEMORY;
    }

    return pUnknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaPinControlInterfaceHandler::CBdaPinControlInterfaceHandler(
    LPUNKNOWN   pUnkOuter,
    TCHAR*      ptchName,
    HRESULT*    phrStatus
    ) :
    CUnknown( ptchName, pUnkOuter, phrStatus)
////////////////////////////////////////////////////////////////////////////////////////////
{
    IKsObject*              pKsObject = NULL;
    IPin *                  pPin = NULL;
    IPin *                  pConnectedPin = NULL;
    IBDA_NetworkProvider *  pNetProvider = NULL;
    IFilterGraph *          pGraph = NULL;
    IBaseFilter *           pBaseFilter = NULL;
    IUnknown *              pUnkDevice = NULL;
    PIN_INFO     pinInfoT;
    FILTER_INFO  filterInfoT;


    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Bad outer IUnknown.\n")
              );
        *phrStatus = VFW_E_NEED_OWNER;
        goto errExit;
    }

    //  Initialize members
    //
    m_ObjectHandle = NULL;

    m_pConnectedPin = NULL;

    m_pNetProvider = NULL;
    m_ulRegistrationCtx = 0;

    //  Get the IKsObject interface on KSProxy so that we can communicate
    //  with the driver.
    //
    *phrStatus =  pUnkOuter->QueryInterface(
                          __uuidof(IKsObject),
                          reinterpret_cast<PVOID*>(&pKsObject)
                          );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IKSObject for device.\n")
              );
        goto errExit;
    }


    //  Get an IPin interface for this pin
    //
    *phrStatus = pUnkOuter->QueryInterface( __uuidof( IPin), 
                                            (PVOID *) &pPin
                                            );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IPin for this pin.\n")
              );
        goto errExit;
    }


    //  First get the IUnknown for the recieving pin's filter.
    //
    *phrStatus = pPin->QueryPinInfo( &pinInfoT);
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get pin info for this pin.\n")
              );
        goto errExit;
    }
    pBaseFilter = pinInfoT.pFilter;
    if (!pBaseFilter)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get IBaseFilter for this filter.\n")
              );
        goto errExit;
    }

    //  Get a pointer the the graph that the filter is in.
    //
    *phrStatus = pBaseFilter->QueryFilterInfo( &filterInfoT);
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get filter info for this filter.\n")
              );
        goto errExit;
    }
    pGraph = filterInfoT.pGraph;
    if (!pGraph)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get graph for this filter.\n")
              );
        goto errExit;
    }

    //  Get a pointer to the network provider for this graph.
    //
    *phrStatus = FindInterfaceOnGraph( pGraph, 
                                       __uuidof( IBDA_NetworkProvider),
                                       (PVOID *) &pNetProvider
                                       );
    if (FAILED( *phrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get network provider for this graph.\n")
              );
        goto errExit;
    }
    if (!pNetProvider)
    {
        *phrStatus = E_NOINTERFACE;
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaPinControl: Can't get network provider for this graph.\n")
              );
        goto errExit;
    }


    if (pinInfoT.dir == PINDIR_INPUT)
    {
        //  Get the IUnknown for the filter that contains this pin.
        //
        *phrStatus = pBaseFilter->QueryInterface( __uuidof( IUnknown),
                                                  (PVOID *) &pUnkDevice
                                                  );
        if (FAILED(*phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IUnknown for filter.\n")
                  );
            goto errExit;
        }
        if (!pUnkDevice)
        {
            *phrStatus = E_NOINTERFACE;
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IUnknown for filter.\n")
                  );
            goto errExit;
        }
    
    
        //  Register this filter with the network provider.
        //
        *phrStatus = pNetProvider->RegisterDeviceFilter( pUnkDevice,
                                                         &m_ulRegistrationCtx
                                                         );
        if (FAILED( *phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't register filter with network provider.\n")
                  );
            goto errExit;
        }
    }
    else
    {
        //  Keep track of the connected device so that we can
        //  unregister it on disconnect
        //
        *phrStatus = pPin->ConnectedTo( &pConnectedPin);
        if (FAILED( *phrStatus))
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get connected pin.\n")
                  );
            goto errExit;
        }
    }


    //  Get the handle of the device.
    //
    m_ObjectHandle = pKsObject->KsGetObjectHandle( );
    if (!m_ObjectHandle)
    {
        *phrStatus = E_UNEXPECTED;
        DbgLog( ( LOG_ERROR,
                  0,
                  "Can't get device handle.\n")
              );
        goto errExit;
    }

    m_pNetProvider = pNetProvider;
    pNetProvider = NULL;

    m_pConnectedPin = pConnectedPin;
    pConnectedPin = NULL;


errExit:
    RELEASE_AND_CLEAR( pKsObject);
    RELEASE_AND_CLEAR( pPin);
    RELEASE_AND_CLEAR( pGraph);
    RELEASE_AND_CLEAR( pBaseFilter);
    RELEASE_AND_CLEAR( pUnkDevice);
    RELEASE_AND_CLEAR( pNetProvider);
    RELEASE_AND_CLEAR( pConnectedPin);
    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CBdaPinControlInterfaceHandler::~CBdaPinControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT                 hrStatus = NOERROR;
    IBDA_PinControl *       pPinControl = NULL;

    DbgLog(( LOG_TRACE,
             10,
             "~CBdaPinControlInterfaceHandler: In BdaPlgIn PinControl Destructor\n"
          ));

    if (m_pConnectedPin && m_pNetProvider)
    {

        hrStatus = m_pConnectedPin->QueryInterface( 
                                        __uuidof( IBDA_PinControl),
                                        (PVOID *) &pPinControl
                                        );
        if (!FAILED( hrStatus) && pPinControl)
        {
            ULONG                   ulRegistrationCtx;

             hrStatus = pPinControl->RegistrationContext( 
                                        &ulRegistrationCtx
                                        );
             if (!FAILED( hrStatus))
             {
                 m_pNetProvider->UnRegisterDeviceFilter( 
                                        ulRegistrationCtx
                                        );
             }
        }
        else
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaPinControl: Can't get IBDA_PinControl for connected pin.\n")
                  );
        }
    }

    RELEASE_AND_CLEAR( m_pNetProvider);
    RELEASE_AND_CLEAR( m_pConnectedPin);
    RELEASE_AND_CLEAR( pPinControl);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CBdaPinControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_PinControl))
    {
        return GetInterface(static_cast<IBDA_PinControl*>(this), ppv);
    }
#ifdef PROPERTY_PAGES
    else if (riid ==  IID_ISpecifyPropertyPages)
    {
        return GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    }
#endif // PROPERTY_PAGES

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}

#ifdef PROPERTY_PAGES
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPages (
    CAUUID * pPages
    )
///////////////////////////////////////////////////////////////////////////////
{
    pPages->cElems = 1 ;

    pPages->pElems = (GUID *) CoTaskMemAlloc( pPages->cElems * sizeof( GUID));

    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }

    (pPages->pElems)[0] = CLSID_BDAFrequecyFilterPropertyPage;

    return NOERROR;
}
#endif // PROPERTY_PAGES

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPinID (
    ULONG *     pulPinID
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinID;
    ULONG           ulcbReturned = 0;

    kspPinID.Set = KSPROPSETID_BdaPinControl;
    kspPinID.Id = KSPROPERTY_BDA_PIN_ID;
    kspPinID.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinID,
                     sizeof( KSPROPERTY),
                     (PVOID) pulPinID,
                     sizeof( ULONG),
                     &ulcbReturned
                     );

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaPinControlInterfaceHandler::GetPinType (
    ULONG *     pulPinType
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinType;
    ULONG           ulcbReturned = 0;

    kspPinType.Set = KSPROPSETID_BdaPinControl;
    kspPinType.Id = KSPROPERTY_BDA_PIN_TYPE;
    kspPinType.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinType,
                     sizeof( KSPROPERTY),
                     (PVOID) pulPinType,
                     sizeof( ULONG),
                     &ulcbReturned
                     );

    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdademod.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Digital Demodulator class
//
class CBdaDigitalDemodulator :
    public CUnknown,
    public IBDA_DigitalDemodulator
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaDigitalDemodulator (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaDigitalDemodulator ( );

    //
    //  IBDA_DigitalDemodulator
    //

    STDMETHODIMP
    put_ModulationType (
        ModulationType *    pModulationType
        );

    STDMETHODIMP
    get_ModulationType (
        ModulationType *    pModulationType
        );

    STDMETHODIMP
    put_InnerFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    get_InnerFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    put_InnerFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    get_InnerFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    put_OuterFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    get_OuterFECMethod (
        FECMethod * pFECMethod
        );

    STDMETHODIMP
    put_OuterFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    get_OuterFECRate (
        BinaryConvolutionCodeRate * pFECRate
        );

    STDMETHODIMP
    put_SymbolRate (
        ULONG * pSymbolRate
        );

    STDMETHODIMP
    get_SymbolRate (
        ULONG * pSymbolRate
        );

    STDMETHODIMP
    put_SpectralInversion (
        SpectralInversion * pSpectralInversion
        );

    STDMETHODIMP
    get_SpectralInversion (
        SpectralInversion * pSpectralInversion
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdaplgin.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: BdaPlgIn.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////


class CBdaDeviceControlInterfaceHandler :
    public CUnknown,
    public IBDA_DeviceControl,
    public IBDA_Topology
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

    STDMETHODIMP StartChanges(
            void
            );

    STDMETHODIMP CheckChanges(
            void
            );

    STDMETHODIMP CommitChanges(
            void
            );

    STDMETHODIMP GetChangeState(
            ULONG *     pState
            );

    STDMETHODIMP
    GetNodeTypes (
        ULONG *     pulcNodeTypes,
        ULONG       ulcMaxElements,
        ULONG       rgulNodeTypes[]
        );

    STDMETHODIMP
    GetNodeDescriptors (
        ULONG *                     pulcElements,
        ULONG                       ulcElementsMax,
        BDANODE_DESCRIPTOR          rgNodeDescriptors[]
        );


    STDMETHODIMP
    GetNodeInterfaces (
        ULONG       ulNodeType,
        ULONG *     pulcInterfaces,
        ULONG       ulcmaxElements,
        GUID        rgguidInterfaces[]
        );

    STDMETHODIMP
    GetPinTypes (
        ULONG *     pulcPinTypes,
        ULONG       ulcMaxElements,
        ULONG       rgulPinTypes[]
        );

    STDMETHODIMP
    GetTemplateConnections (
        ULONG *                     pulcConnections,
        ULONG                       ulcMaxElements,
        BDA_TEMPLATE_CONNECTION     rgConnections[]
        );

    STDMETHODIMP
    CreatePin (
        ULONG       ulPinType,
        ULONG *     pulPinId
        );

    STDMETHODIMP
    DeletePin (
        ULONG       ulPinId
        );

    STDMETHODIMP
    SetMediaType (
        ULONG           ulPinId,
        AM_MEDIA_TYPE * pMediaType
        );

    STDMETHODIMP
    SetMedium (
        ULONG           ulPinId,
        REGPINMEDIUM *  pMedium
        );

    STDMETHODIMP
    CreateTopology (
        ULONG           ulInputPinId,
        ULONG           ulOutputPinId
        );

    STDMETHODIMP
    GetControlNode (
        ULONG           ulInputPinId,
        ULONG           ulOutputPinId,
        ULONG           ulNodeType,
        IUnknown**      ppControlNode
        );

private:

    CBdaDeviceControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CBdaDeviceControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

    STDMETHODIMP EnableEvent (
            const GUID *pInterfaceGuid,
            ULONG ulId
            );

    STDMETHODIMP Set (
            IN  PKSPROPERTY  pBdaDeviceControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

    STDMETHODIMP Get (
            IN  PKSPROPERTY pBdaDeviceControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

private:

    HANDLE                  m_ObjectHandle;
    HANDLE                  m_EndEventHandle;
    KSEVENTDATA             m_EventData;
    IFilterGraph*           m_pGraph;
    IBaseFilter*            m_pBaseFilter;
    IBDA_NetworkProvider *  m_pNetProvider;
};


class CBdaPinControlInterfaceHandler :
    public CUnknown,
#ifdef PROPERTY_PAGES
    public ISpecifyPropertyPages,
#endif // PROPERTY_PAGES
    public IBDA_PinControl
{

public:

    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

    STDMETHODIMP
    RegistrationContext(
        ULONG *     pRegistrationCtx
        )
    {
        if (!pRegistrationCtx)
        {
            return E_POINTER;
        }
        if (!m_ulRegistrationCtx)
        {
            return E_FAIL;
        }

        *pRegistrationCtx = m_ulRegistrationCtx;

        return NOERROR;
    }

    STDMETHODIMP
    GetPinID (
        ULONG *     pulPinID
        );

    STDMETHODIMP
    GetPinType (
        ULONG *     pulPinID
        );

#ifdef PROPERTY_PAGES
    STDMETHODIMP
    GetPages (
        CAUUID * pPages
        ) ;
#endif // PROPERTY_PAGES

private:

    CBdaPinControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CBdaPinControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

private:

    HANDLE                  m_ObjectHandle;

    IPin *                  m_pConnectedPin;

    IBDA_NetworkProvider *  m_pNetProvider;
    ULONG                   m_ulRegistrationCtx;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdasignl.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"



////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Properties class
//
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutNetworkType (
    REFGUID     guidNetworkType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetNetworkType (
    GUID *      pguidNetworkType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutSignalSource (
    ULONG       ulSignalSource
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetSignalSource (
    ULONG *     pulSignalSource
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::PutTuningSpace (
    REFGUID     guidTuningSpace
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CSignalProperties::GetTuningSpace (
    GUID *      pguidTuningSpace
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOTIMPL;
}



////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Statistics class
//
////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
CBdaSignalStatistics::CBdaSignalStatistics (
    IUnknown *              pUnkOuter,
    CBdaControlNode *       pControlNode
    ) :
    CUnknown( NAME( "IBDA_SignalStatistics"), pUnkOuter, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;

    ASSERT( pUnkOuter);

    if (!pUnkOuter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pUnkOuter = pUnkOuter;
    m_pControlNode = pControlNode;
}


///////////////////////////////////////////////////////////////////////////////
CBdaSignalStatistics::~CBdaSignalStatistics ( )
///////////////////////////////////////////////////////////////////////////////
{
    m_pUnkOuter = NULL;
    m_pControlNode = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalStrength (
    LONG        lDbStrength
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalStrength (
    LONG *      plDbStrength
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_STRENGTH,
                             plDbStrength,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal strength (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalQuality (
    LONG        lPercentQuality
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalQuality (
    LONG *      plPercentQuality
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_QUALITY,
                             plPercentQuality,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal quality (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalPresent (
    BOOLEAN     fPresent
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalPresent (
    BOOLEAN *   pfPresent
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_PRESENT,
                             pfPresent,
                             sizeof( BOOLEAN),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal present (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SignalLocked (
    BOOLEAN     fLocked
    )
///////////////////////////////////////////////////////////////////////////////
{
    return E_NOINTERFACE;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SignalLocked (
    BOOLEAN *   pfLocked
    )
///////////////////////////////////////////////////////////////////////////////
{
    ULONG       ulcbReturned;
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SIGNAL_LOCKED,
                             pfLocked,
                             sizeof( BOOLEAN),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal locked (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_SampleTime (
    LONG        lmsSampleTime
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;

    hrStatus = put_KsProperty(
                             KSPROPERTY_BDA_SAMPLE_TIME,
                             &lmsSampleTime,
                             sizeof( LONG)
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get signal locked (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_SampleTime (
    LONG *      plmsSampleTime
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = E_NOINTERFACE;
    ULONG       ulcbReturned;

    hrStatus = get_KsProperty(
                             KSPROPERTY_BDA_SAMPLE_TIME,
                             plmsSampleTime,
                             sizeof( LONG),
                             &ulcbReturned
                             );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaSignalStatistics: Can't get sample time (0x%08x).\n", hrStatus)
                );
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::put_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->put_BdaNodeProperty(
                            __uuidof( IBDA_SignalStatistics),
                            dwPropID,
                            (UCHAR *) pvPropData,
                            ulcbPropData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaSignalStatistics::get_KsProperty (
    DWORD   dwPropID,
    PVOID   pvPropData,
    ULONG   ulcbPropData,
    ULONG * pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = E_NOINTERFACE;

    ASSERT( m_pControlNode);

    if (!m_pControlNode)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    hrStatus = m_pControlNode->get_BdaNodeProperty(
                            __uuidof( IBDA_SignalStatistics),
                            dwPropID,
                            (UCHAR *)pvPropData,
                            ulcbPropData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdafreq.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Frequency Filter class
//
class CBdaFrequencyFilter :
    public CUnknown,
    public IBDA_FrequencyFilter
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaFrequencyFilter (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaFrequencyFilter ( );

    //
    //  IBDA_FrequencyFilter
    //

    STDMETHODIMP
    put_Autotune (
        ULONG           ulTransponder
        );
    
    STDMETHODIMP
    get_Autotune (
        ULONG *         pulTransponder
        );

    STDMETHODIMP
    put_Frequency (
        ULONG           ulFrequency
        );

    STDMETHODIMP
    get_Frequency (
        ULONG *         pulFrequency
        );

    STDMETHODIMP
    put_Polarity (
        Polarisation    Polarity
        );

    STDMETHODIMP
    get_Polarity (
        Polarisation *  pPolarity
        );

    STDMETHODIMP
    put_Range (
        ULONG           ulRange
        );

    STDMETHODIMP
    get_Range (
        ULONG *         pulRange
        );

    STDMETHODIMP
    put_Bandwidth (
        ULONG           ulBandwidth
        );

    STDMETHODIMP
    get_Bandwidth (
        ULONG *         pulBandwidth
        );

    STDMETHODIMP
    put_FrequencyMultiplier (
        ULONG           ulMultiplier
        );

    STDMETHODIMP
    get_FrequencyMultiplier (
        ULONG *         pulMultiplier
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );


private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};


////////////////////////////////////////////////////////////////////////////////
//
// BDA LNB Info class
//
class CBdaLNBInfo :
    public CUnknown,
    public IBDA_LNBInfo
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaLNBInfo (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaLNBInfo ( );

    //
    //  IBDA_LNBInfo
    //

    STDMETHODIMP
    put_LocalOscilatorFrequencyLowBand (
        ULONG       ulLOFLow
        );

    STDMETHODIMP
    get_LocalOscilatorFrequencyLowBand (
        ULONG *     pulLOFLow
        );

    STDMETHODIMP
    put_LocalOscilatorFrequencyHighBand (
        ULONG       ulLOFHigh
        );

    STDMETHODIMP
    get_LocalOscilatorFrequencyHighBand (
        ULONG *     pulLOFHigh
        );

    STDMETHODIMP
    put_HighLowSwitchFrequency (
        ULONG       ulSwitchFrequency
        );

    STDMETHODIMP
    get_HighLowSwitchFrequency (
        ULONG *     pulSwitchFrequency
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\resource.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#define IDS_VERSION                     100
#define IDS_TITLE                       101

#ifndef IDC_STATIC
#define IDC_STATIC (-1)
#endif

/////////////////////////////////////////////////////////////////////////////
//
//  BDA Frequency Filter Property Pane
//

#define IDD_BDAFrequencyFilterDialog    102
#define IDS_FrequencyFilterPageName     1050
#define IDC_Frequency                   1057
#define IDC_STATIC_STRENGTH             1059
#define IDC_REFRESH                     1061
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdatopgy.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
///////////////////////////////////////////////////////////////////////////////

#include "pch.h"

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeTypes (
    ULONG *     pulcElements,
    ULONG       ulcMaxElements,
    ULONG       rgulNodeTypes[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      ksProperty;
    ULONG           ulcbReturned = 0;

    ksProperty.Set = KSPROPSETID_BdaTopology;
    ksProperty.Id = KSPROPERTY_BDA_NODE_TYPES;
    ksProperty.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &ksProperty,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulNodeTypes,
                     ulcMaxElements * sizeof( ULONG),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( ULONG) - 1) / sizeof( ULONG);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeDescriptors (
    ULONG *                 pulcElements,
    ULONG                   ulcMaxElements,
    BDANODE_DESCRIPTOR      rgulNodeDescriptors[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      ksProperty;
    ULONG           ulcbReturned = 0;

    ksProperty.Set = KSPROPSETID_BdaTopology;
    ksProperty.Id = KSPROPERTY_BDA_NODE_DESCRIPTORS;
    ksProperty.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &ksProperty,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulNodeDescriptors,
                     ulcMaxElements * sizeof( BDANODE_DESCRIPTOR),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( BDANODE_DESCRIPTOR) - 1) / sizeof( BDANODE_DESCRIPTOR);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetNodeInterfaces (
    ULONG       ulNodeType,
    ULONG *     pulcElements,
    ULONG       ulcMaxElements,
    GUID        rgguidInterfaces[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSP_NODE        kspNode;
    ULONG           ulcbReturned = 0;

    kspNode.Property.Set = KSPROPSETID_BdaTopology;
    kspNode.Property.Id = KSPROPERTY_BDA_NODE_PROPERTIES;
    kspNode.Property.Flags = KSPROPERTY_TYPE_GET;
    kspNode.NodeId = ulNodeType;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspNode,
                     sizeof( KSP_NODE),
                     (PVOID) rgguidInterfaces,
                     ulcMaxElements * sizeof( GUID),
                     &ulcbReturned
                     );

    *pulcElements = (ulcbReturned + sizeof( GUID) - 1) / sizeof( GUID);
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetPinTypes (
    ULONG *     pulcPinTypes,
    ULONG       ulcMaxElements,
    ULONG       rgulPinTypes[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspPinTypes;
    ULONG           ulcbReturned = 0;

    kspPinTypes.Set = KSPROPSETID_BdaTopology;
    kspPinTypes.Id = KSPROPERTY_BDA_PIN_TYPES;
    kspPinTypes.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspPinTypes,
                     sizeof( KSPROPERTY),
                     (PVOID) rgulPinTypes,
                     ulcMaxElements * sizeof( ULONG),
                     &ulcbReturned
                     );

    *pulcPinTypes = (ulcbReturned + sizeof( ULONG) - 1) / sizeof( ULONG);
    return hrStatus;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetTemplateConnections (
    ULONG *                     pulcConnections,
    ULONG                       ulcMaxElements,
    BDA_TEMPLATE_CONNECTION     rgConnections[]
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    KSPROPERTY      kspConnections;
    ULONG           ulcbReturned = 0;

    kspConnections.Set = KSPROPSETID_BdaTopology;
    kspConnections.Id = KSPROPERTY_BDA_TEMPLATE_CONNECTIONS;
    kspConnections.Flags = KSPROPERTY_TYPE_GET;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspConnections,
                     sizeof( KSPROPERTY),
                     (PVOID) rgConnections,
                     ulcMaxElements * sizeof( BDA_TEMPLATE_CONNECTION),
                     &ulcbReturned
                     );

    *pulcConnections =  (ulcbReturned + sizeof( BDA_TEMPLATE_CONNECTION) - 1)
                      / sizeof( BDA_TEMPLATE_CONNECTION);
    return hrStatus;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CreatePin (
    ULONG       ulPinType,
    ULONG *     pulPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hResult = NOERROR;
    KSM_BDA_PIN ksmCreatePin;
    ULONG       BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CreatePin.\n"
           ));

    ksmCreatePin.Method.Set = KSMETHODSETID_BdaDeviceConfiguration;
    ksmCreatePin.Method.Id = KSMETHOD_BDA_CREATE_PIN_FACTORY;
    ksmCreatePin.Method.Flags = KSMETHOD_TYPE_NONE;
    ksmCreatePin.PinType = ulPinType;
    
    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCreatePin,
                    sizeof(KSM_BDA_PIN),
                    pulPinId,
                    sizeof( ULONG),
                    &BytesReturned
                    );

    *pulPinId = ksmCreatePin.PinId;

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::DeletePin (
    ULONG       ulPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::SetMediaType (
    ULONG           ulPinId,
    AM_MEDIA_TYPE * pMediaType
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::SetMedium (
    ULONG           ulPinId,
    REGPINMEDIUM *  pMedium
    )
///////////////////////////////////////////////////////////////////////////////
{
    return NOERROR;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::CreateTopology (
    ULONG           ulInputPinId,
    ULONG           ulOutputPinId
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hResult = NOERROR;
    KSM_BDA_PIN_PAIR    ksmCreateTopology;
    ULONG               BytesReturned = 0;

    DbgLog(( LOG_TRACE,
             10,
             "BdaPlugIn:  --> CreateTopology.\n"
           ));

    ksmCreateTopology.Method.Set = KSMETHODSETID_BdaDeviceConfiguration;
    ksmCreateTopology.Method.Id = KSMETHOD_BDA_CREATE_TOPOLOGY;
    ksmCreateTopology.Method.Flags = KSMETHOD_TYPE_NONE;
    ksmCreateTopology.InputPinId = ulInputPinId;
    ksmCreateTopology.OutputPinId = ulOutputPinId;
    
    hResult = ::KsSynchronousDeviceControl(
                    m_ObjectHandle,
                    IOCTL_KS_METHOD,
                    (PVOID) &ksmCreateTopology,
                    sizeof(KSM_BDA_PIN_PAIR),
                    NULL,
                    0,
                    &BytesReturned
                    );

    return hResult;
}

///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaDeviceControlInterfaceHandler::GetControlNode (
    ULONG           ulInputPinId,
    ULONG           ulOutputPinId,
    ULONG           ulNodeType,
    IUnknown**      ppControlNode
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT             hrStatus = NOERROR;
    IPin*               pInputPin = NULL;
    IPin*               pOutputPin = NULL;
    KSP_BDA_NODE_PIN    kspControllingPinId;
    ULONG               ulControllingPinId;
    ULONG               ulcbReturned;
    CBdaControlNode *   pControlNode = NULL;

    //  Query the filter to determine on which pin to access the
    //  node type.
    //

    kspControllingPinId.Property.Set = KSPROPSETID_BdaTopology;
    kspControllingPinId.Property.Id = KSPROPERTY_BDA_CONTROLLING_PIN_ID;
    kspControllingPinId.Property.Flags = KSPROPERTY_TYPE_GET;
    kspControllingPinId.ulNodeType = ulNodeType;
    kspControllingPinId.ulInputPinId = ulInputPinId;
    kspControllingPinId.ulOutputPinId = ulOutputPinId;

    hrStatus = ::KsSynchronousDeviceControl(
                     m_ObjectHandle,
                     IOCTL_KS_PROPERTY,
                     (PVOID) &kspControllingPinId,
                     sizeof( KSP_BDA_NODE_PIN),
                     (PVOID) &ulControllingPinId,
                     sizeof( ULONG),
                     &ulcbReturned
                     );
    if (FAILED( hrStatus))
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "GetControlNode: No controlling pin found.\n")
              );
        goto errExit;
    }

    pControlNode = new CBdaControlNode( this,
                                        ulControllingPinId,
                                        ulNodeType
                                        );
    if (!pControlNode)
    {
        hrStatus = E_OUTOFMEMORY;
        DbgLog( ( LOG_ERROR,
                  0,
                  "GetControlNode: Can't create control node.\n")
              );
        goto errExit;
    }

    hrStatus = GetInterface( (IUnknown *) pControlNode,
                             (PVOID *) ppControlNode
                             );

errExit:

    return hrStatus;
}



///////////////////////////////////////////////////////////////////////////////
CBdaControlNode::CBdaControlNode (
    CBdaDeviceControlInterfaceHandler * pOwner,
    ULONG                               ulControllingPinId,
    ULONG                               ulNodeType
    ) :
    CUnknown( NAME("IBDA_ControlNode"), NULL, NULL)
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT         hrStatus = NOERROR;
    WCHAR           pstrPinId[16];

    ASSERT( pOwner);
    ASSERT( pOwner->m_pBaseFilter);

    if (!pOwner || !pOwner->m_pBaseFilter)
    {
        DbgLog( ( LOG_ERROR,
                  0,
                  "CBdaControlNode: No parent specified.\n")
              );

        return;
    }

    //  Initialize Members
    //
    m_pBaseFilter = pOwner->m_pBaseFilter;
    m_ulControllingPinId = ulControllingPinId;
    m_ulNodeType = ulNodeType;
    m_pControllingPin = NULL;
    m_pIKsPropertySet = NULL;
    m_pFrequencyFilter = NULL;
    m_pLNBInfo = NULL;
    m_pDigitalDemodulator = NULL;
    m_pConditionalAccess = NULL;
    m_pSignalStatistics = NULL;

    //  Try to open the controlling pin.
    //
    ControllingPin();
}

///////////////////////////////////////////////////////////////////////////////
CBdaControlNode::~CBdaControlNode ( )
///////////////////////////////////////////////////////////////////////////////
{
    RELEASE_AND_CLEAR( m_pControllingPin);
    RELEASE_AND_CLEAR( m_pIKsPropertySet);
    DELETE_RESET( m_pFrequencyFilter);
    DELETE_RESET( m_pLNBInfo);
    DELETE_RESET( m_pDigitalDemodulator);
    DELETE_RESET( m_pConditionalAccess);
    DELETE_RESET( m_pSignalStatistics);
    m_pBaseFilter = NULL;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;

    if (!ppv)
    {
        return E_POINTER;
    }

    if (riid ==  __uuidof(IBDA_FrequencyFilter))
    {
        if (!m_pFrequencyFilter)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pFrequencyFilter = new CBdaFrequencyFilter(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pFrequencyFilter)
        {
            return GetInterface(static_cast<IBDA_FrequencyFilter*>(m_pFrequencyFilter), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_LNBInfo))
    {
        if (!m_pLNBInfo)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pLNBInfo = new CBdaLNBInfo(
                                    pUnkMe,
                                    this
                                    );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pLNBInfo)
        {
            return GetInterface(static_cast<IBDA_LNBInfo*>(m_pLNBInfo), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_DigitalDemodulator))
    {
        if (!m_pDigitalDemodulator)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pDigitalDemodulator = new CBdaDigitalDemodulator(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pDigitalDemodulator)
        {
            return GetInterface(static_cast<IBDA_DigitalDemodulator*>(m_pDigitalDemodulator), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_Mpeg2CA))
    {
        if (!m_pConditionalAccess)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pConditionalAccess = new CBdaConditionalAccess(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pConditionalAccess)
        {
            return GetInterface(static_cast<IBDA_Mpeg2CA*>(m_pConditionalAccess), ppv);
        }
    }

    else if (riid ==  __uuidof(IBDA_SignalStatistics))
    {
        if (!m_pConditionalAccess)
        {
            IUnknown *      pUnkMe = NULL;

            hrStatus = GetInterface( (IUnknown *) this, (PVOID *) &pUnkMe);
            if (FAILED(hrStatus))
            {
                return hrStatus;
            }

            m_pSignalStatistics = new CBdaSignalStatistics(
                                            pUnkMe,
                                            this
                                            );
            RELEASE_AND_CLEAR( pUnkMe);
        }

        if (m_pSignalStatistics)
        {
            return GetInterface(static_cast<IBDA_SignalStatistics*>(m_pSignalStatistics), ppv);
        }
    }

    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::ControllingPin(
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    WCHAR       pstrPinId[32];

    if (!m_pControllingPin)
    {
        //  Try to open the controlling pin for this node.
        //
	StringCchPrintfW(pstrPinId, sizeof(pstrPinId)/sizeof(pstrPinId[0]), L"%u", m_ulControllingPinId);
        hrStatus = m_pBaseFilter->FindPin( pstrPinId,
                                           &m_pControllingPin
                                           );
        if (FAILED( hrStatus) || !m_pControllingPin)
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaControlNode::ControllingPin: Can't open controlling IPin.\n")
                  );
            m_pControllingPin = NULL;
        }
    }

    //  Open an IKSPropertySet interface on the object if we don't
    //  already have one.
    //
    if (m_pControllingPin && !m_pIKsPropertySet)
    {
        hrStatus = m_pControllingPin->QueryInterface(
                                          __uuidof( IKsPropertySet),
                                          (PVOID *) &m_pIKsPropertySet
                                          );
        if (FAILED(hrStatus) || !m_pIKsPropertySet)
        {
            DbgLog( ( LOG_ERROR,
                      0,
                      "CBdaControlNode::ControllingPin: Can't get IKsPropertySet.\n")
                  );
            m_pIKsPropertySet = NULL;
        }
    }

    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::put_BdaNodeProperty(
    REFGUID     refguidPropSet,
    ULONG       ulPropertyId,
    UCHAR*      pbPropertyData, 
    ULONG       ulcbPropertyData
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    KSP_NODE    nodeProperty;

    //  Make sure we have a controlling pin object.
    //
    ControllingPin();
    if (!m_pControllingPin || !m_pIKsPropertySet)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    nodeProperty.NodeId = m_ulNodeType;

    ASSERT( m_pIKsPropertySet);

    hrStatus = m_pIKsPropertySet->Set(
                            refguidPropSet,
                            ulPropertyId,
                            &nodeProperty.NodeId,
                            sizeof( KSP_NODE) - sizeof( KSPROPERTY),
                            (PVOID) pbPropertyData,
                            ulcbPropertyData
                            );

errExit:
    return hrStatus;
}


///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CBdaControlNode::get_BdaNodeProperty(
    REFGUID     refguidPropSet,
    ULONG       ulPropertyId,
    UCHAR*      pbPropertyData, 
    ULONG       ulcbPropertyData, 
    ULONG*      pulcbBytesReturned
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT     hrStatus = NOERROR;
    KSP_NODE    nodeProperty;

    //  Make sure we have a controlling pin object.
    //
    ControllingPin();
    if (!m_pControllingPin || !m_pIKsPropertySet)
    {
        hrStatus = E_NOINTERFACE;
        goto errExit;
    }

    nodeProperty.NodeId = m_ulNodeType;

    ASSERT( m_pIKsPropertySet);

    hrStatus = m_pIKsPropertySet->Get(
                            refguidPropSet,
                            ulPropertyId,
                            &nodeProperty.NodeId,
                            sizeof( KSP_NODE) - sizeof( KSPROPERTY),
                            (PVOID) pbPropertyData,
                            ulcbPropertyData,
                            pulcbBytesReturned
                            );

errExit:
    return hrStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\dvdplay\dvdstub.cpp ===
// dvdstub.cpp : Defines the entry point for the console application.
//

#pragma once
#include <Windows.h>
#include <stdio.h>
#ifndef MAXPATH
#define MAXPATH 1024
#endif

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     PSTR      pCmdLine,
                     int       nCmdShow)
{
	try{
		STARTUPINFO si;
		PROCESS_INFORMATION pi;
		
		ZeroMemory( &si, sizeof(si) );
		si.cb = sizeof(si);
		ZeroMemory( &pi, sizeof(pi) );
		TCHAR filePos[MAXPATH];
		ZeroMemory(filePos, sizeof(TCHAR)*MAXPATH);
		TCHAR filePath[MAXPATH];
		ZeroMemory(filePath, sizeof(TCHAR)*MAXPATH);
		DWORD szPath = (sizeof(TCHAR)/sizeof(BYTE))*MAXPATH;
		HKEY wmpKey = 0;
		LONG temp = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,         // handle to open key
			TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wmplayer.exe"), // subkey name
			0,   // reserved
			KEY_READ, // security access mask
			&wmpKey    // handle to open key
			);
		DWORD tempType = 0;
		temp = RegQueryValueEx(
			wmpKey,            // handle to key
			TEXT("Path"),  // value name
			0,   // reserved
			&tempType,       // type buffer
			(BYTE*)filePath,        // data buffer
			&szPath     // size of data buffer
			);
		TCHAR *namePos;
		DWORD retVal =  0;
		retVal = SearchPath(
			(TCHAR *)filePath,      // search path
			TEXT("wmplayer"),  // file name
			TEXT(".exe"), // file extension
			MAXPATH, // size of path buffer
			filePos,     // path buffer
			&namePos   // address of file name in path
			);
		TCHAR commandArgs[] = TEXT(" /device:dvd");
		BOOL retBool = CreateProcess(
			filePos,
			commandArgs,
			NULL,
			NULL,
			FALSE,
			0,
			NULL,
			NULL,
			&si,              // Pointer to STARTUPINFO structure.
			&pi             // Pointer to PROCESS_INFORMATION structure.
			);
	}
	catch(...){}    
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\dvdplay\resource.h ===
#pragma warning (disable : 4005)
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dvdplay.rc
//
#define IDD_ABOUTBOX                    100
#define IDP_OLE_INIT_FAILED             100
#define IDR_MAINFRAME                   128
#define IDD_VIDEO_WINDOW                130
#define IDD_UI_WINDOW                   131
#define IDD_DIALOG_AUDIO_VOLUME         132
#define IDR_MENU_OPTIONS                133
#define IDR_MENU_OPERATIONS             134
#define IDR_MENU_TITLE                  135
#define IDR_MENU_CHAPTER                136
#define IDD_DIALOG_SUBTITLE             137
#define IDD_DIALOG_AUDIO_LANGUAGE       138
#define IDR_MENU_ARROWS                 139
#define IDR_MENU_DOCK                   140
#define IDD_DIALOG_PARENT_CONTROL       144
#define IDD_DIALOG_ADMIN_LOGIN          145
#define IDD_DIALOG_SET_RATE             146
#define IDR_MENU_TITLE_CHAPTER          149
#define IDD_DIALOG_SEARCH_TITLE         150
#define IDD_DIALOG_SEARCH_CHAPTER       151
#define IDR_MENU_DVDLOGO                152
#define IDR_MENU_VIDEOWIN               206
#define IDD_DIALOG_ADMIN_PASSWD         218
#define IDB_PLAY                        1000
#define IDC_PLAY                        1000
#define IDB_STOP                        1001
#define IDC_STOP                        1001
#define IDB_PAUSE                       1003
#define IDC_PAUSE                       1003
#define IDB_EJECT                       1004
#define IDB_FULL_SCREEN                 1005
#define IDC_FULL_SCREEN                 1005
#define IDB_FAST_FORWARD                1006
#define IDC_FAST_FORWARD                1006
#define IDB_FAST_REWIND                 1007
#define IDC_FAST_REWIND                 1007
#define IDB_VERY_FAST_FORWARD           1008
#define IDC_VERY_FAST_FORWARD           1008
#define IDB_VERY_FAST_REWIND            1009
#define IDC_VERY_FAST_REWIND            1009
#define IDB_UP                          1010
#define IDC_UP                          1010
#define IDB_AUDIO_VOLUME                1011
#define IDC_AUDIO_VOLUME                1011
#define IDB_DOWN                        1012
#define IDC_DOWN                        1012
#define IDB_RIGHT                       1013
#define IDC_RIGHT                       1013
#define IDB_LEFT                        1014
#define IDC_LEFT                        1014
#define IDB_ENTER                       1015
#define IDC_ENTER                       1015
#define IDB_MENU                        1016
#define IDC_MENU                        1016
#define IDB_HELP                        1017
// Get rid of the commonly defined one to avoid warnings.
#undef IDC_HELP
#define IDC_HELP                        1017
#define IDB_STEP                        1018
#define IDB_OPTIONS                     1019
#define IDC_OPTIONS                     1019
#define IDC_STATIC_TITLE                1020
#define IDC_SLIDER_BALANCE              1021
#define IDC_CHECK_SHOW_LOGON            1022
#define IDC_STATIC_CHAPTER              1023
#define IDC_STATIC_PROGRESS             1024
#define IDC_CHECK_MUTE                  1025
#define IDC_CHECK_SUBTITLE              1026
#define IDC_LIST_SUBTITLE               1027
#define IDC_LIST_AUDIO_LANGUAGE         1028
#define IDC_LIST_NAME                   1032
#define IDC_EDIT_PASSWORD               1033
#define IDC_EDIT_CONFIRM                1038
#define IDC_COMBO_RATE                  1043
#define IDC_BUTTON_SAVE                 1044
#define IDC_STATIC_SELECT_NAME          1045
#define IDC_LIST_USER_RATE              1046
#define IDC_EDIT_NAME                   1047
#define IDC_BUTTON_CHANGE_OLD           1048
#define IDC_BUTTON_CHANGE_PASSWORD      1051
#define IDC_EDIT_NEW_PASSWORD           1053
#define IDC_STATIC_NEW_PASSWORD         1054
#define IDC_STATIC_HEIGHT2              1055
#define IDC_STATIC_HEIGHT1              1056
#define IDC_STATIC_PASSWORD             1057
#define IDC_STATIC_CONFIRM              1058
#define IDC_EDIT_CONFIRM_NEW            1061
#define IDC_STATIC_CONFIRM_NEW          1062
#define IDC_EDIT_HOUR                   1079
#define IDC_EDIT_MINUTE                 1080
#define IDC_EDIT_SECOND                 1081
#define IDC_SPIN_HOUR                   1082
#define IDC_SPIN_MINUTE                 1083
#define IDC_SPIN_SECOND                 1084
#define IDC_EDIT_TITLE_NUMBER           1091
#define IDC_SPIN_TITLE_NUMBER           1092
#define IDB_EJECT_DISC                  1094
#define IDC_EJECT_DISC                  1094
#define IDC_BUTTON_CLOSE                1096
#define IDC_SLIDER_VOLUME               1097
#define IDC_STATIC_TIME                 1098
#define IDC_STATIC_TOTAL_TIME           1099
#define IDC_STATIC_SEL_SUBTITLE_LAN     1100
#define IDC_STATIC_SEL_AUDIO_LAN        1101
#define IDC_STATIC_START_PLAY           1102
#define IDC_STATIC_GROUP_CHAPTER        1103
#define IDC_STATIC_HOUR                 1104
#define IDC_STATIC_MINUTE               1105
#define IDC_STATIC_SECOND               1106
#define IDC_STATIC_BALANCE              1107
#define IDC_STATIC_VOLUME               1108
#define IDC_STATIC_SEL_USER_NAME        1109
#define IDC_STATIC_RATING               1111
#define IDC_STATIC_USER                 1112
#define IDC_CONTEXT_HELP                1113
#define IDC_STATIC_TITLE_NUM            1115
#define IDC_BUTTON_DELETE               1120
#define IDC_STATIC_ADMIN_PASSWD         1121
#define IDC_EDIT_ADMIN_PASSWD           1122
#define IDC_STATIC_RATE_HIGH            1123
#define ID_OPTIONS_SEARCHFORTEXT        32772
#define ID_OPTIONS_SETRATINGS           32773
#define ID_OPTIONS_CAPTUREVIDEO_ASWALLPAPER 32775
#define ID_OPTIONS_CAPTUREVIDEO_ASPICTURE 32776
#define ID_OPTIONS_PROGRAMTITLES        32777
#ifdef DISPLAY_OPTIONS
   #define ID_OPTIONS_DISPLAY_PANSCAN      32779
   #define ID_OPTIONS_DISPLAY_LETTERBOX    32780
#endif
#define ID_OPTIONS_AUDIO_STEREO         32794
#define ID_OPTIONS_CAMERAANGLES_ANGLE1  32795
#define ID_OPTIONS_CAMERAANGLES_ANGLE2  32796
#define ID_OPTIONS_CAMERAANGLES_ANGLE3  32797
#ifdef DISPLAY_OPTIONS
   #define ID_OPTIONS_DISPLAY_WIDE         32798
#endif
#define ID_OPERATION_PLAY               32799
#define ID_OPERATION_PAUSE              32800
#define ID_OPERATION_STOP               32801
#define ID_OPERATION_VERYFASTREWIND     32803
#define ID_OPERATION_FASTFORWARD        32804
#define ID_OPERATION_SKIP_PREVIOSCHAPTER 32807
#define ID_OPERATION_SKIP_NEXTCHAPTER   32808
#define ID_OPERATION_SKIP_PREVIOUSFRAME 32809
#define ID_OPERATION_SKIP_NEXTFRAME     32810
#define ID_OPERATION_PLAYSPEED_NORMALSPEED 32811
#define ID_OPERATION_PLAYSPEED_DOUBLESPEED 32812
#define ID_OPERATION_PLAYSPEED_HALFSPEED 32813
#define ID_OPERATION_MENU               32814
#define ID_OPERATION_FULLSCREEN         32815
#define ID_OPERATION_TOOLBAR            32816
#define ID_OPERATION_SETVOLUME          32817
#define ID_OPERATION_CAPTUREVIDEO       32818
#define ID_TITLE_PREVIOUS               32819
#define ID_TITLE_MAINTITLE              32820
#define ID_TITLE_CREDITS                32821
#define ID_TITLE_COOLMOVIEINFO          32822
#define ID_CHAPTER                      32823
#define ID_CHAPTER_GOOSHYKISSING        32824
#define ID_OPERATION_EJECTDISK          32825
#define ID_OPERATION_FASTREWIND         32826
#define ID_OPERATION_VERYFASTFORWARD    32827
#define ID_OPTIONS_SUBTITLES            32828
#define ID_ARROWS_UP                    32829
#define ID_ARROWS_DOWN                  32830
#define ID_ARROWS_LEFT                  32831
#define ID_ARROWS_RIGHT                 32832
#define ID_ARROWS_ENTER                 32833
#define ID_DOCK_DOCKTOTOPOFSCREEN       32834
#define ID_DOCK_SHOWASFLOATINGWINDOW    32835
#define ID_DOCK_HIDE                    32836
#define ID_OPTIONS_SELECTDISK_CURRENTDISK 32837
#define ID_SEARCH_TITLE                 32838
#define ID_SEARCH_CHAPTER               32839
#define ID_DVDLOGO_ABOUT                32842
#define ID_DVDLOGO_HELP                 32843
#define ID_OPTIONS_CAMERAANGLES_ANGLE4  32845
#define ID_OPTIONS_CAMERAANGLES_ANGLE5  32846
#define ID_OPTIONS_CAMERAANGLES_ANGLE6  32847
#define ID_OPTIONS_CAMERAANGLES_ANGLE7  32848
#define ID_OPTIONS_CAMERAANGLES_ANGLE8  32849
#define ID_OPTIONS_CAMERAANGLES_ANGLE9  32850
#define ID_VIDEOWIN_PLAY                32851
#define ID_VIDEOWIN_PAUSE               32852
#define ID_VIDEOWIN_STOP                32853
#define ID_VIDEOWIN_FASTFORWARD         32854
#define ID_VIDEOWIN_FASTREWIND          32855
#define ID_VIDEOWIN_VERYFASTFORWARD     32856
#define ID_VIDEOWIN_VERYFASTREWIND      32857
#define ID_VIDEOWIN_GOTO_PREVIOUSCHAPTER 32860
#define ID_VIDEOWIN_GOTO_NEXTCHAPTER    32861
#define ID_VIDEOWIN_FULLSCREEN          32863
#define ID_OPTIONS_CLOSEDCAPTION        32864
#define ID_OPTIONS_SELECT_DISC          32865
#define ID_OPTIONS_SHOW_LOGON           32866
#define ID_OPTIONS_LANGUAGE             32867
#define ID_VIDEOWIN_MENU                32868
#define ID_OPTIONS_TITLE_MENU           32869
#define ID_VIDEOWIN_EJECTDISK           32871
#define ID_VIDEOWIN_PLAYSPEED_NORMALSPEED 32872
#define ID_VIDEOWIN_PLAYSPEED_DOUBLESPEED 32873
#define ID_VIDEOWIN_PLAYSPEED_HALFSPEED   32874
#define IDS_CANT_PLAY                   61204
#define IDS_CANT_PAUSE                  61205
#define IDS_CANT_STOP                   61206
#define IDS_CANT_INIT_QUARTZ            61207
#define IDS_CANT_RENDER_FILE            61208
#define IDS_CANT_FIND_DVD               61209
#define IDS_VPE_NOT_WORKING             61210
#define IDS_EJECT                       61211
#define IDS_UNEJECT                     61212
#define IDS_ENTER_PASSWORD              61212
#define IDS_CONFIRM_NEW_PASSWORD        61213
#define IDS_PASSOWRD_CONFIRM_WRONG      61214
#define IDS_PASSWORD_INCORRECT          61215
#define IDS_TYPE_A_NEW_PASSWORD         61216
#define IDS_EJECT_CANNOT_FIND_DISC      61217
#define IDS_EJECT_CANNOT_EJECT          61218
#define IDS_USER_NAME_NOT_FOUND_LOGON_AS_GUEST 61219
#define IDS_TYPE_A_USER_NAME            61220
#define IDS_USER_ALREADY_EXISTS         61221
#define IDS_SELECT_A_NAME               61222
#define IDS_MSGBOX_TITLE                61223
#define IDS_NOT_A_VALID_DVD_FILE        61224
#define IDS_OLD_PASSWORD                61225
#define IDS_NEW_PASSWORD                61226
#define IDS_PASSWORD                    61227
#define IDS_RESUME                      61228
#define IDS_MENU                        61229
#define IDS_NOT_MEET_MS_LOGO            61230
#define IDS_OEM_FLAG_PATH               61231
#define IDS_OEM_FLAG_NAME               61232
#define IDS_PLAY_TIP                    61233
#define IDS_PAUSE_TIP                   61234
#define IDS_STOP_TIP                    61235
#define IDS_EJECT_DISC_TIP              61236
#define IDS_VERY_FAST_REWIND_TIP        61237
#define IDS_FAST_REWIND_TIP             61238
#define IDS_FAST_FORWARD_TIP            61239
#define IDS_VERY_FAST_FORWARD_TIP       61240
#define IDS_STEP_TIP                    61241
#define IDS_FULL_SCREEN_TIP             61242
#define IDS_AUDIO_VOLUME_TIP            61243
#define IDS_MENU_TIP                    61244
#define IDS_ENTER_TIP                   61245
#define IDS_UP_TIP                      61246
#define IDS_DOWN_TIP                    61247
#define IDS_LEFT_TIP                    61248
#define IDS_RIGHT_TIP                   61249
#define IDS_ABOUT_TIP                   61250
#define IDS_HELP_TIP                    61250
#define IDS_OPTIONS_TIP                 61251
#define IDS_ADM_LOGON_BOX_TITLE         61252
#define IDS_ADM_LOGON_MSG               61253
#define IDS_GUEST                       61254
#define IDS_INI_USER                    61255
#define IDS_INI_USERNAME                61256
#define IDS_INI_PASSWORD                61257
#define IDS_INI_RATE                    61258
#define IDS_INI_KIDSAFE                 61259
#define IDS_INI_RATE_G                  61259
#define IDS_INI_THEATRICAL              61260
#define IDS_INI_RATE_PG                 61260
#define IDS_INI_ADULT                   61261
#define IDS_INI_RATE_ADULT              61261
#define IDS_INI_ADMINISTRATOR           61262
#define IDS_INI_NUMBEROFUSER            61263
#define IDS_NAME_EXIST_SELECT_FOR_CHANGE 61264
#define IDS_FAILED_CREATE_INSTANCE      61265
#define IDS_FOLLOWING_ERROR_HAPPENED    61266
#define IDS_FAILED_INIT_DSHOW           61267
#define IDS_UNKNOWN_ERROR               61268
#define IDS_WANT_CONTINUE               61269
#define IDS_STREAM_FAILED_ONE           61270
#define IDS_VIDEO_STREAM                61271
#define IDS_AUDIO_STREAM                61272
#define IDS_SUBPICTURE_STREAM           61273
#define IDS_INVALID_DVD_DISC            61274
#define IDS_NOT_FOUND_DVD_DISC          61275
#define IDS_FOLLOWING_ERRORS_HAPPENED   61276
#define IDS_NO_CC_IN_ERROR              61277
#define IDS_CC_OUT_ERROR                61278
#define IDS_FILE_OPEN_DLGBOX_TITLE      61279
#define IDS_BLACKBOX1_TITLE             61280
#define IDS_BLACKBOX2_CHAPTER           61281
#define IDS_BLACKBOX3_PROGRESS          61282
#define IDS_STREAM_FAILED_MORE          61283
#define IDS_INI_SHOW_LOGONBOX           61284
#define IDS_ADM_SETLOGONBOX_TITLE       61285
#define IDS_VIDEO_WINDOW_POS            61286
#define IDS_WINDOW_LEFT                 61287
#define IDS_WINDOW_TOP                  61288
#define IDS_WINDOW_WIDTH                61289
#define IDS_WINDOW_HEIGHT               61290
#define IDS_UI_WINDOW_POS               61291
#define IDS_UI_SHOWCMD                  61292
#define IDS_VIDEO_WND_FULLSCREEN        61293
#define IDS_INI_RATE_PG13               61294
#define IDS_INI_RATE_R                  61295
#define IDS_INI_RATE_NC17               61296
#define IDS_RATED_HIGH                  61297
#define IDS_DECODER_WRONG               61298
#define IDS_FONTHEIGHT                  61299
#define IDS_FONTFACE                    61300
#define IDS_CHARSET                     61301
#define IDS_CONTEXT_HELP_FILENAME       61302
#define IDS_UIWND_CLASSNAME             61303
#define IDS_SELECT_DELETE               61304
#define IDS_CANT_DELETE_GUEST           61305
#define IDS_SURE_TO_DELETE              61306
#define IDS_STREAM                      61307
#define IDS_NO_USER_SELECTED_GUEST_LOGON 61308
#define IDS_REGION_CHANGE_FAIL          61309
#define IDS_RATE_OVER_RIDE              61310
#define IDS_ERROR                       61311
#define IDS_MACROVISION_FAIL            61312
#define IDS_REGION_CHANGE_PROMPT        61313
#define TIMER_ID                        1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        219
#define _APS_NEXT_COMMAND_VALUE         32870
#define _APS_NEXT_CONTROL_VALUE         1124
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdasignl.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Signal Statistics class
//
class CBdaSignalStatistics :
    public CUnknown,
    public IBDA_SignalStatistics
{
    friend class CBdaControlNode;

public:

    DECLARE_IUNKNOWN;

    CBdaSignalStatistics (
        IUnknown *              pUnkOuter,
        CBdaControlNode *       pControlNode
        );

    ~CBdaSignalStatistics ( );

    //
    //  IBDA_SignalStatistics
    //
    STDMETHODIMP
    put_SignalStrength (
        LONG        lDbStrength
        );
    
    STDMETHODIMP
    get_SignalStrength (
        LONG *      plDbStrength
        );
    
    STDMETHODIMP
    put_SignalQuality (
        LONG        lPercentQuality
        );
    
    STDMETHODIMP
    get_SignalQuality (
        LONG *      plPercentQuality
        );
    
    STDMETHODIMP
    put_SignalPresent (
        BOOLEAN     fPresent
        );
    
    STDMETHODIMP
    get_SignalPresent (
        BOOLEAN *   pfPresent
        );
    
    STDMETHODIMP
    put_SignalLocked (
        BOOLEAN     fLocked
        );
    
    STDMETHODIMP
    get_SignalLocked (
        BOOLEAN *   pfLocked
        );
    
    STDMETHODIMP
    put_SampleTime (
        LONG        lmsSampleTime
        );
    
    STDMETHODIMP
    get_SampleTime (
        LONG *      plmsSampleTime
        );

    //
    //  Utility Methods
    //

    STDMETHODIMP
    put_KsProperty(
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData
        );

    STDMETHODIMP
    get_KsProperty (
        DWORD   dwPropID,
        PVOID   pvPropData,
        ULONG   ulcbPropData,
        ULONG * pulcbBytesReturned
        );

private:

    IUnknown *                          m_pUnkOuter;
    CBdaControlNode *                   m_pControlNode;
    CCritSec                            m_FilterLock;
};


////////////////////////////////////////////////////////////////////////////////
//
// SignalProperties Filter class
//
class CSignalProperties :
    public IBDA_SignalProperties
{

public:

    STDMETHODIMP
    PutNetworkType (
        REFGUID     guidNetworkType
        );

    STDMETHODIMP
    GetNetworkType (
        GUID *      pguidNetworkType
        );

    STDMETHODIMP
    PutSignalSource (
        ULONG       ulSignalSource
        );

    STDMETHODIMP
    GetSignalSource (
        ULONG *     pulSignalSource
        );

    STDMETHODIMP
    PutTuningSpace (
        REFGUID     guidTuningSpace
        );

    STDMETHODIMP
    GetTuningSpace (
        GUID *      pguidTuingSpace
        );

private:

    CCritSec        m_FilterLock;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header for BdaPlgIn.ax

--*/

// Windows
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <memory.h>
#include <stdio.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

// DShow
#include <streams.h>
#include <amstream.h>
#include <dvdmedia.h>

// DDraw
#include <ddraw.h>
#include <ddkernel.h>

// KS
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>

#include <atlbase.h>
#include <strmif.h>

#include <BdaTypes.h>
#include <BdaMedia.h>
#include <BdaIface.h>
#include "BdaRcvr.h"

//  ---------------------------------------------------------------------------
//      MACROS
//  ---------------------------------------------------------------------------

#define RELEASE_AND_CLEAR(punk)         if (punk) { (punk)->Release(); (punk) = NULL; }
#define DELETE_RESET(p)                 if (p) { delete (p); (p) = NULL ; }
#define DELETE_RESET_COM(p)             if (p) { CoTaskMemFree (p); (p) = NULL ; }
#define CLOSE_RESET_HANDLE(h)           if ((h) != NULL) { CloseHandle (h); (h) = NULL ;}
#define CLOSE_RESET_REG_KEY(r)          if ((r) != NULL) { RegCloseKey (r); (r) = NULL ;}
#define GOTO_NE(v,c,l)                  if ((v) != (c)) { ERROR_SPEW(v,!=,c) ; goto l ; }
#define GOTO_EQ(v,c,l)                  if ((v) == (c)) { ERROR_SPEW(v,==,c) ; goto l ; }
#define GOTO_NE_SET(v,c,l,h,r)          if ((v) != (c)) { (h) = (r) ; ERROR_SPEW(v,!=,c) ; goto l ; }
#define GOTO_EQ_SET(v,c,l,h,r)          if ((v) == (c)) { (h) = (r) ; ERROR_SPEW(v,==,c) ; goto l ; }
#define DIV_ROUND_UP_MAYBE(num,den)     ((num) / (den) + ((num) % (den) ? 1 : 0))
#define MIN(a,b)                        ((a) < (b) ? (a) : (b))
#define MAX(a,b)                        ((a) > (b) ? (a) : (b))
#define IN_RANGE(v,min,max)             (((min) <= (v)) && ((v) <= (max)))

#define NE_ERROR_RET(v,c)               ERROR_RET(v,!=,c)
#define EQ_ERROR_RET(v,c)               ERROR_RET(v,==,c)
#define NE_ERROR_RET_VAL(v,c,r)         ERROR_RET_VAL(v,!=,c,r)
#define EQ_ERROR_RET_VAL(v,c,r)         ERROR_RET_VAL(v,==,c,r)
#define NE_ERROR_RET_EX(v,c,m)          ERROR_RET_EX(v,!=,c,m)
#define EQ_ERROR_RET_EX(v,c,m)          ERROR_RET_EX(v,==,c,m)
#define NE_ERROR_RET_VAL_EX(v,c,r,m)    ERROR_RET_VAL_EX(v,!=,c,r,m)
#define EQ_ERROR_RET_VAL_EX(v,c,r,m)    ERROR_RET_VAL_EX(v,==,c,r,m)

//  empty if-clauses should be otpimized out in release builds
#define NE_SPEW(v,c,m)                  if ((v) != (c)) ERROR_SPEW_EX(v,!=,c,m)
#define EQ_SPEW(v,c,m)                  if ((v) == (c)) ERROR_SPEW_EX(v,==,c,m)

////////////////////////////////////////////////////////////////////////////////
//
// Forward declarations
//
class CBdaDeviceControlInterfaceHandler;
class CBdaControlNode;
class CBdaFrequencyFilter;
class CBdaLNBInfo;
class CBdaDigitalDemodulator;
class CBdaConditionalAccess;

#include "BdaTopgy.h"
#include "BdaSignl.h"
#include "BdaFreq.h"
#include "BdaDemod.h"
#include "BdaCA.h"
#include "BdaPlgIn.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\bdaplugin\bdatopgy.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;


////////////////////////////////////////////////////////////////////////////////
//
// BDA Control Node class
//
class CBdaControlNode :
    public CUnknown,
    public IBDA_KSNode
{
    friend class CBdaDeviceControlInterfaceHandler;
    friend class CBdaFrequencyFilter;
    friend class CBdaDigitalDemodulator;

public:

    DECLARE_IUNKNOWN;

    CBdaControlNode (
        CBdaDeviceControlInterfaceHandler * pOwner,
        ULONG                               ulControllingPinID,
        ULONG                               ulNodeType
        );

    ~CBdaControlNode ( );

    STDMETHODIMP
    NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv
        );

    //
    //  IBDA_KSNode
    //

    STDMETHODIMP
    ControllingPin( );

    STDMETHODIMP
    CBdaControlNode::put_BdaNodeProperty(
        REFGUID     refguidPropSet,
        ULONG       ulPropertyId,
        UCHAR*      pbPropertyData, 
        ULONG       ulcbPropertyData
        );

    STDMETHODIMP
    CBdaControlNode::get_BdaNodeProperty(
        REFGUID     refguidPropSet,
        ULONG       ulPropertyId,
        UCHAR*      pbPropertyData, 
        ULONG       ulcbPropertyData, 
        ULONG*      pulcbBytesReturned
        );


private:

    CCritSec                            m_FilterLock;

    IBaseFilter *                       m_pBaseFilter;
#ifdef NEVER
    HANDLE                              m_ObjectHandle;
#endif // NEVER

    ULONG                               m_ulNodeType;
    ULONG                               m_ulControllingPinId;
    IPin *                              m_pControllingPin;
    IKsPropertySet *                    m_pIKsPropertySet;

    CBdaFrequencyFilter *               m_pFrequencyFilter;
    CBdaLNBInfo *                       m_pLNBInfo;
    CBdaDigitalDemodulator *            m_pDigitalDemodulator;
    CBdaConditionalAccess *             m_pConditionalAccess;
    IBDA_SignalStatistics *             m_pSignalStatistics;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ipsink\ipsink.cpp ===
///////////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.cpp
//
//  Abstract:
//
//    Implements IPSink Plugin Component
//
//
////////////////////////////////////////////////////////////////////////////////////////////

#include "pch.h"
//#include "ipidl.h"
#include "ipuids.h"
#include "ipsink.h"

#define MULTI_PORT 4567
#define ETH_ADDR_SIZE 6
#define IPv4_ADDR_SIZE 4
#define MUTEX_NAME "GetAdapterIpMutex"


////////////////////////////////////////////////////////////////////////////////////////////
//
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {L"IBDA_IPSinkControl", &IID_IBDA_IPSinkControl, CIPSinkControlInterfaceHandler::CreateInstance, NULL, NULL}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);


///////////////////////////////////////////////////////////////////////////////
//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI
DllRegisterServer (
    void
    )
{
    return AMovieDllRegisterServer2( TRUE );

}


///////////////////////////////////////////////////////////////////////////////
//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer (
    void
    )
///////////////////////////////////////////////////////////////////////////////
{
    return AMovieDllRegisterServer2( FALSE );

} // DllUnregisterServer


///////////////////////////////////////////////////////////////////////////////
HRESULT
FindInterfaceOnGraph (
    IUnknown* pUnkGraph,
    REFIID riid,
    void **ppInterface
    )
///////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IBaseFilter> pFilter;
    CComPtr<IEnumFilters> pEnum;
    ULONG ulFetched = 0;

    if(!ppInterface)
    {
        return E_FAIL;
    }

    *ppInterface= NULL;

    if(!pUnkGraph)
    {
		DbgLog((LOG_ERROR,0,"GraphInit failed\n"));
        return E_FAIL;
    }

    CComQIPtr<IFilterGraph, &IID_IFilterGraph> pFilterGraph(pUnkGraph);

    hr = pFilterGraph->EnumFilters(&pEnum);
    if(!pEnum)
    {
        return hr;
    }

    //
    // find the first filter in the graph that supports riid interface
    //
    while(!*ppInterface && pEnum->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(riid, ppInterface);
        pFilter.Release();
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CUnknown*
CALLBACK
CIPSinkControlInterfaceHandler::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CUnknown *Unknown;

    Unknown = new CIPSinkControlInterfaceHandler(UnkOuter, NAME("IBDA_IPSinkControl"), hr);
    if (!Unknown)
    {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

CIPSinkControlInterfaceHandler::CIPSinkControlInterfaceHandler(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter, hr)
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

	
    if (SUCCEEDED(*hr))
    {
        if (UnkOuter)
        {
            IKsObject*   Object = NULL;


            m_UnkOuter = UnkOuter;

            //
            // The parent must support this interface in order to obtain
            // the handle to communicate to.
            //
            *hr =  UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
            if (FAILED (*hr))
            {
                return;
            }

            if (SUCCEEDED(*hr))
            {
                m_ObjectHandle = Object->KsGetObjectHandle ();
                if (!m_ObjectHandle)
                {
                    *hr = E_UNEXPECTED;
                }

                Object->Release();


                //
                // Test code to setup a thread and event
                //
                m_pEventSetID         = &IID_IBDA_IPSinkEvent;
                m_ThreadHandle        = NULL;

                m_pMulticastList      = NULL;
                m_pIPAddress          = NULL;
                m_pAdapterDescription = NULL;

                m_ulcbMulticastList   = 0;
                m_ulcbAdapterDescription = 0;
                m_ulcbIPAddress       = 0;

                m_ulcbAllocated       = 0;
                m_ulcbAllocatedForDescription = 0;
                m_ulcbAllocatedForAddress     = 0;

				g_hMutex=CreateMutex(NULL,FALSE,MUTEX_NAME);

				if(g_hMutex==0)
			        *hr = HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE);
           


                for (ul = 0; ul < EVENT_COUNT; ul++)
                {
                    m_EventHandle [ul]       = NULL;
                }

                *hr = CreateThread ();
            }
        }
        else
        {
            *hr = VFW_E_NEED_OWNER;
        }
    }

    return;
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
CIPSinkControlInterfaceHandler::~CIPSinkControlInterfaceHandler (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    //
    // Make sure we kill any threads we have running and
    // close the thread handle
    //
    ExitThread();


    //
    // Close the event handles
    //
    for (ul = 0; ul < EVENT_COUNT; ul++)
    {
        if (m_EventHandle [ul])
        {
            CloseHandle(m_EventHandle [ul]);
            m_EventHandle [ul] = NULL;
        }
    }

    m_ulcbMulticastList = 0;
    m_ulcbAllocated = 0;
    delete m_pMulticastList;
    m_pMulticastList = NULL;

    m_ulcbAdapterDescription = 0;
    m_ulcbAllocatedForDescription = 0;
    delete m_pAdapterDescription;
    m_pAdapterDescription = NULL;

    m_ulcbIPAddress = 0;
    m_ulcbAllocatedForAddress = 0;
    delete [] m_pIPAddress;
    m_pIPAddress = NULL;

    if(g_hMutex)
	 CloseHandle(g_hMutex);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    if (riid ==  __uuidof(IBDA_IPSinkControl))
    {
        return GetInterface(static_cast<IBDA_IPSinkControl*>(this), ppv);
    }
    if (riid ==  __uuidof(IBDA_IPSinkInfo))
    {
        return GetInterface(static_cast<IBDA_IPSinkInfo*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
HRESULT
CIPSinkControlInterfaceHandler::CreateThread (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;

    ASSERT( !m_EventHandle[EVENT_IPSINK_THREAD_SYNC]);
    if (!m_EventHandle[EVENT_IPSINK_THREAD_SYNC])
    {
        m_EventHandle[EVENT_IPSINK_THREAD_SYNC] 
            = CreateEvent ( NULL,           // no security attributes
                            TRUE,           // manual reset
                            FALSE,          // initial state not signaled
                            NULL            // no object name
                            );
    }

    ASSERT( !m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN]);
    if (!m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN])
    {
        m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN] 
            = CreateEvent ( NULL,           // no security attributes
                            TRUE,           // manual reset
                            FALSE,          // initial state not signaled
                            NULL            // no object name
                            );
    }

    if (   !m_EventHandle[EVENT_IPSINK_THREAD_SYNC]
        || !m_EventHandle[EVENT_IPSINK_THREAD_SHUTDOWN]
       )
    {
        ULONG   uliHandle;

        hr = HRESULT_FROM_WIN32( GetLastError ());
        
        goto errExit;
    }

    {
        ULONG ulcbSize            = 0;
        BYTE *pbMulticastList     = NULL;
        BYTE *pbAdapterDescription = NULL;

        //
        // Get the multicast list initially on startup
        //
        this->GetMulticastList (&ulcbSize, &pbMulticastList);
    
        this->GetAdapterDescription (&ulcbSize, &pbAdapterDescription);
    }

    ASSERT( !m_ThreadHandle);
    if (!m_ThreadHandle)
    {
        DWORD  ThreadId;
   
        m_ThreadHandle = ::CreateThread (
                               NULL,
                               0,
                               ThreadFunctionWrapper,
                               (LPVOID) this,
                               0,
                               (LPDWORD) &ThreadId
                               );
        if (m_ThreadHandle == NULL)
        {
            hr = HRESULT_FROM_WIN32 (GetLastError());
            goto errExit;
        }
    }

ret:
    return hr;

errExit:

    //
    // Close the event handles
    //
    ULONG   uliEvent;
    for (uliEvent = 0; uliEvent < EVENT_COUNT; uliEvent++)
    {
        if (m_EventHandle [uliEvent])
        {
            CloseHandle(m_EventHandle [uliEvent]);
            m_EventHandle [uliEvent] = NULL;
        }
    }

    goto ret;
}

////////////////////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP
CIPSinkControlInterfaceHandler::GetMulticastList (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_MULTICASTLIST;
    IPSinkControl.Flags = KSPROPERTY_TYPE_GET;

    m_ulcbMulticastList = 0;

    do

    {
        hr = this->Get (&IPSinkControl, m_pMulticastList, &m_ulcbMulticastList);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if (m_ulcbMulticastList > m_ulcbAllocated)
            {
                if (m_pMulticastList)
                {
                    delete (m_pMulticastList);
                }

                m_ulcbAllocated  = m_ulcbMulticastList;
                m_pMulticastList = new BYTE [m_ulcbAllocated];

                if (m_pMulticastList == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }
        else if (HRESULT_CODE (hr) != NOERROR)
        {
            goto ret;
        }
        else
        {

            HRESULT               hResult         = NOERROR;
            IBaseFilter*          pBaseFilter     = NULL;
            IFilterGraph*         pGraph          = NULL;
            IBDA_EthernetFilter*  pEthernetFilter = NULL;
            IBDA_NetworkProvider* pNetProvider    = NULL;


            *pulcbSize = m_ulcbMulticastList;
            *pbBuffer   = (PBYTE) m_pMulticastList;


            //
            // Get an interface pointer to the current graph
            //
            hResult =  m_UnkOuter->QueryInterface(IID_IBaseFilter, reinterpret_cast<PVOID*>(&pBaseFilter));
            pBaseFilter->QueryFilterInfo (&fi);
            pGraph = fi.pGraph;
            pBaseFilter->Release ();


            if (pGraph != NULL)
            {
                hResult = FindInterfaceOnGraph (pGraph, IID_IBDA_NetworkProvider, (PVOID *) &pNetProvider);
                if ( SUCCEEDED (hResult))
                {
                    if (pNetProvider)
                    {
                        //
                        // Get a pointer to the ethernet interface of the network provider
                        //
                        hResult = pNetProvider->QueryInterface (IID_IBDA_EthernetFilter, (PVOID*) &pEthernetFilter );
                        if (pEthernetFilter)
                        {
                            hResult = pEthernetFilter->PutMulticastList (m_ulcbMulticastList, m_pMulticastList);

                            //
                            // Release our reference to the net providers ethernet filter interface
                            //
                            pEthernetFilter->Release ();

                        }

                        pNetProvider->Release ();
                    }
                }

                pGraph->Release ();
            }
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);


ret:

    return hr;
}

STDMETHODIMP
CIPSinkControlInterfaceHandler::get_MulticastList (
    unsigned long *pulcbSize,                           
    BYTE         **ppbBufferOut
    )
{
    unsigned long ulcbSize;
    PBYTE         pbBuffer;
	
    if(!pulcbSize || !(ppbBufferOut))
      return E_POINTER;
	
    HRESULT hr = GetMulticastList(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;
    
    BYTE *pbBufferOut = (BYTE *) CoTaskMemAlloc(ulcbSize);
    if(NULL == pbBufferOut)
    {
        *pulcbSize = 0;
        return E_OUTOFMEMORY;
    }

    if(IsBadReadPtr(pbBuffer,ulcbSize) || IsBadWritePtr(pbBufferOut,ulcbSize))
    {
       *pulcbSize = 0;	
       CoTaskMemFree(pbBufferOut);     	
       return S_FALSE; 
    }		

    memcpy(pbBufferOut, pbBuffer, ulcbSize);                // copy into our newly allocated memory...

    *pulcbSize = ulcbSize;
    *ppbBufferOut = pbBufferOut;
    return S_OK;    
}
////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

STDMETHODIMP
CIPSinkControlInterfaceHandler::GetAdapterIPAddress (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )

{

  HRESULT hr = NOERROR;

  INT iterCnt=20;
  while(!m_pIPAddress && iterCnt) 
  {
	  Sleep(50);
	  iterCnt--;
  }

 if(iterCnt>0)
 {
  *pulcbSize = m_ulcbIPAddress;
  *pbBuffer  = m_pIPAddress;
 }
 else
	 hr=HRESULT_FROM_WIN32( ERROR_NOT_FOUND);
  return hr;

}


STDMETHODIMP
CIPSinkControlInterfaceHandler::privGetAdapterIPAddress (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
///////////////////////////////////////////////////////////////////////////////////////////
{

    HRESULT hr = NOERROR;
    DWORD dw;
    
    dw=WaitForSingleObject(g_hMutex,INFINITE);
    
    if(dw== WAIT_OBJECT_0){
      
      int ipAddrTableIndex ;

     PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pUniDirAdapterList=NULL;
     
       
      //IPHLPAPI varibles
      ULONG  outBufLen;
      DWORD retGetAdprInfo;


      ULONG dwSize;                 // size of buffer 
      DWORD retGetIpAddrTable;
      PMIB_IPADDRTABLE pIpAddrTable=0;  // buffer for mapping table 
     
      hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND);


      //$$BugBug  GetUniDirectionalAdapterInfo currently doesnot return the size when 
      //buffer is insufficient. So, GetIpAddrTable is used to check the upper bound of memory required.	  


      //force failure of the first GetIpAddrTable call to retrieve the size
      //of the buffer required and subsequently allocate sufficient memory

      	dwSize=0;

       retGetIpAddrTable=GetIpAddrTable(pIpAddrTable,&dwSize,TRUE);
     
      ASSERT(retGetIpAddrTable!=NO_ERROR);
  
       if(dwSize==0)
        {
           hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND);
           goto ret;
        }

 	pUniDirAdapterList= (PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS)malloc(dwSize);         
	
     
       if (pUniDirAdapterList == NULL)
        {
         hr = ERROR_NOT_ENOUGH_MEMORY;
         goto ret;
        }

    
      //retreive the unidirectional  IP address table from IPHLPAPI
           
	if(retGetIpAddrTable=GetUniDirectionalAdapterInfo(pUniDirAdapterList,&dwSize)!= NO_ERROR)
      
        {
           hr = HRESULT_FROM_WIN32( retGetIpAddrTable);
           goto ret;
         }
        
       
        hr=selectMulticastAddress();
        if(hr!= NOERROR)
            goto ret;

        //traverse the IpAddrTable and check each IP for a match

	   
        for(ipAddrTableIndex=pUniDirAdapterList->NumAdapters;
                               ipAddrTableIndex>0;ipAddrTableIndex-- )
         {
		
            //compare the ipAddress pIpAddrTable->table[i].dwAdd with 
            //the IP from stream class
		   
            if(validateIpAddr(pUniDirAdapterList->Address[ipAddrTableIndex-1]))
               break;
          }

        // Error return when NDIS port is not found 

        if(ipAddrTableIndex<=0)
          {
             hr = HRESULT_FROM_WIN32( ERROR_NOT_FOUND);
             goto ret;
          }

         if (m_pIPAddress == NULL)
          {
               m_ulcbAllocatedForAddress  = sizeof (IP_ADDRESS_STRING);
               m_pIPAddress = new BYTE [m_ulcbAllocatedForAddress];

                if (m_pIPAddress == NULL)
                {
                   hr = ERROR_NOT_ENOUGH_MEMORY;
                   goto ret;
                 }
                 m_ulcbIPAddress = m_ulcbAllocatedForAddress;
            }

         updateIpAddr(pUniDirAdapterList->Address[ipAddrTableIndex-1]);

         *pulcbSize = m_ulcbIPAddress;
         *pbBuffer  = m_pIPAddress;
          hr = NOERROR;
               
    
ret: 
	if(pUniDirAdapterList)
           free (pUniDirAdapterList); 
        }

	if(dw== WAIT_OBJECT_0)
	     ReleaseMutex(g_hMutex);
	return hr;
}






void CIPSinkControlInterfaceHandler::ConvertIpDwordToString(DWORD inIpAddr, LPSTR str)
{
    IP_ADDR ipAddr;
    ipAddr.d = inIpAddr;

     //Null termination by snprintf is assumed	
    _snprintf(str,sizeof(IP_ADDR_STRING),
            "%d.%d.%d.%d",
            ipAddr.b[0],
            ipAddr.b[1],
            ipAddr.b[2],
            ipAddr.b[3]
            );
}

BOOL CIPSinkControlInterfaceHandler::
         compareAddresses(PBYTE pMulticast,DWORD ipAddr)

{

    IP_ADDR ipUnionAddr1;
    IP_ADDR ipUnionAddr2;

    
    if(!pMulticast)
  	return (FALSE);

    if(IsBadReadPtr(pMulticast,IPv4_ADDR_SIZE))
    {
       return FALSE; 
    }		
	        	
    memcpy(&(ipUnionAddr1.d),pMulticast,IPv4_ADDR_SIZE);
    ipUnionAddr2.d=ipAddr;


    //Exclude the first 9 bits for comparison
    ipUnionAddr1.b[0]=ipUnionAddr2.b[0];
    ipUnionAddr1.b[1]&=0x7F;
    ipUnionAddr2.b[1]&=0x7F;

    return (memcmp(&(ipUnionAddr1.d),&(ipUnionAddr2.d),IPv4_ADDR_SIZE));

}


HRESULT CIPSinkControlInterfaceHandler::selectMulticastAddress()
{

    HRESULT hr = NOERROR;

    unsigned long ulMulticastList;
    PBYTE pMulticastList; //=new  BYTE[100];

    int iter=0x7fffff; //23 allowed bits for the MAC  
    IP_ADDR suffix;
	
    //choose an arbitrary multicast address 229.2.6.9
    m_multicastIpAddr.d=0x90602E5 ; 

    if(this->get_MulticastList(&ulMulticastList,&pMulticastList) !=S_OK)
    {
      goto ret;
    } 
    
    if(ulMulticastList==0)
        return hr;
	
     while(iter--)
      {
          suffix.d =rand()+iter;
   	  suffix.b[1] &= 0x7F; //Mask the 24th bit

	  int flag=1;


          //check if the random suffix clashes with any already enlisted multicast addresses 
          // on the NDIS adapter
          for(unsigned int i=0; i<ulMulticastList/ETH_ADDR_SIZE; i++)
          {
               
             if(!memcmp(&pMulticastList[i*ETH_ADDR_SIZE+3],&(suffix.b[1]),3))
                 flag=0;
           }
	if(flag)
		break;
	}
      	
      memcpy( &(m_multicastIpAddr.b[1]),&(suffix.b[1]),3);
	
   ret:
       return hr;

}

BOOL CIPSinkControlInterfaceHandler::validateIpAddr(DWORD ipAddr)
{
    BOOL                t ;
    BOOL                retVal=FALSE;
    DWORD               threadid ;
    struct ip_mreq      mreq ;
    int                 i ;
    struct sockaddr_in  saddr ;
    SOCKET              m_socket=0 ;
    IP_ADDR ipUnionAddr;

    unsigned long ulMulticastList;
    PBYTE pMulticastList; //=new BYTE[100];
   

    char ipStr[sizeof(IP_ADDR_STRING)];
    ConvertIpDwordToString(ipAddr,ipStr);
    unsigned long addr=inet_addr(ipStr);
    
    char multIpStr[sizeof(IP_ADDR_STRING)];
    ConvertIpDwordToString(m_multicastIpAddr.d,multIpStr);


	
    int nRet;
    WSADATA lp;
    WORD ws=1;
    nRet= WSAStartup((WORD)ws,&lp);

    if(nRet!=0)
	{goto ret;}

     m_socket = WSASocket(
        AF_INET,
        SOCK_DGRAM,
        0,
        NULL,
        0,
        WSA_FLAG_MULTIPOINT_C_LEAF | WSA_FLAG_MULTIPOINT_D_LEAF | WSA_FLAG_OVERLAPPED) ;
    
  	
     if (m_socket == INVALID_SOCKET) {
		goto ret ;
      } 
    
    
     ZeroMemory (& saddr, sizeof saddr) ;
     saddr.sin_family            = AF_INET ;
     saddr.sin_port              = htons (MULTI_PORT) ;  //  want data on this UDP port
     saddr.sin_addr.S_un.S_addr  = addr ;  

     t = TRUE ;
     i = setsockopt(
            m_socket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (char *)& t,
            sizeof t
            ) ;
     if (i == SOCKET_ERROR) {
        goto ret ;
      }
    
      i = bind(
            m_socket,
            (LPSOCKADDR) & saddr,
            sizeof saddr
            ) ;
      if (i == SOCKET_ERROR) {
        goto ret ;
      }

  

      ZeroMemory (& mreq, sizeof mreq) ;

    
      mreq.imr_multiaddr.s_addr   = inet_addr (multIpStr) ;   //  mcast IP (port specified when we bind)
      mreq.imr_interface.s_addr   = inet_addr (ipStr) ;  //  over this NIC

      i = setsockopt (
            m_socket,
            IPPROTO_IP,
            IP_ADD_MEMBERSHIP,
            (char *) & mreq,
            sizeof mreq
            ) ;

      if (i == SOCKET_ERROR) {
        goto ret ;
      }

	 
      if(this->get_MulticastList(&ulMulticastList,&pMulticastList) !=S_OK)
       {
          goto ret;
       } 
	

      //check for multicast enlistment in this NIC
      for(unsigned int j=0; j<ulMulticastList/ETH_ADDR_SIZE; j++)
    	{
          
            if(compareAddresses(&pMulticastList[j*ETH_ADDR_SIZE+2], mreq.imr_multiaddr.s_addr )==0)
             {
               retVal=TRUE;
             }
         }

   ret :
  
   if (m_socket != INVALID_SOCKET) {
        closesocket(m_socket) ;
        m_socket = INVALID_SOCKET ;
    }
 
   return retVal ;


}



void CIPSinkControlInterfaceHandler::updateIpAddr(DWORD inIpAddr)
{
   
    char str[sizeof(IP_ADDRESS_STRING)];
    ConvertIpDwordToString(inIpAddr, str) ;

    if(m_pIPAddress && !IsBadWritePtr(m_pIPAddress,sizeof(IP_ADDRESS_STRING)))	
     {
       memcpy(m_pIPAddress,str,sizeof(IP_ADDRESS_STRING));
     }	
   	    
}


STDMETHODIMP
CIPSinkControlInterfaceHandler::get_AdapterIPAddress (
    BSTR         *pbstrBuffer
    )
{
    unsigned long ulcbSize;
    PBYTE         pbBuffer;
	
    if(!pbstrBuffer)
	return E_POINTER;	

    if(IsBadWritePtr(pbstrBuffer,sizeof(pbstrBuffer)))
 	return E_POINTER;
    

    HRESULT hr = GetAdapterIPAddress(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;
	
       
    CComBSTR bstrTmp(ulcbSize, (char *) pbBuffer);              // copy into bstrTmp, it has a nice CopyTo method that alloc's correct way
    if(!bstrTmp)
        return ERROR_NOT_ENOUGH_MEMORY;
    return bstrTmp.CopyTo(pbstrBuffer);         
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::SetAdapterIPAddress (
    unsigned long ulcbSize,
    PBYTE         pbBuffer
    )
///////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_ADAPTER_ADDRESS;
    IPSinkControl.Flags = KSPROPERTY_TYPE_SET;

    hr = this->Set (&IPSinkControl, pbBuffer, ulcbSize);

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
HRESULT
CIPSinkControlInterfaceHandler::GetAdapterDescription (
    unsigned long *pulcbSize,
    PBYTE         *pbBuffer
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    KSPROPERTY  IPSinkControl = {0};
    HRESULT hr                = NOERROR;
    FILTER_INFO fi            = {0};

    //
    // Initialize KSPROPERTY structure
    //
    IPSinkControl.Set   = IID_IBDA_IPSinkControl;
    IPSinkControl.Id    = KSPROPERTY_IPSINK_ADAPTER_DESCRIPTION;
    IPSinkControl.Flags = KSPROPERTY_TYPE_GET;

    m_ulcbAdapterDescription = 0;

    do

    {
        hr = this->Get (&IPSinkControl, m_pAdapterDescription, &m_ulcbAdapterDescription);

        if (HRESULT_CODE (hr) == ERROR_MORE_DATA)
        {
            if (m_ulcbAdapterDescription > m_ulcbAllocatedForDescription)
            {
                if (m_pAdapterDescription)
                {
                    delete (m_pAdapterDescription);
                }

                m_ulcbAllocatedForDescription  = m_ulcbAdapterDescription;
                m_pAdapterDescription = new BYTE [m_ulcbAllocatedForDescription];

                if (m_pAdapterDescription == NULL)
                {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    goto ret;
                }
            }
        }
        else
        {
            *pbBuffer = m_pAdapterDescription;
            *pulcbSize = m_ulcbAllocatedForDescription;
            goto ret;
        }

    } while (HRESULT_CODE (hr) == ERROR_MORE_DATA);


ret:

    return hr;
}

STDMETHODIMP
CIPSinkControlInterfaceHandler::get_AdapterDescription (
    BSTR         *pbstrBuffer
    )
{
    unsigned long ulcbSize = 0;
    PBYTE         pbBuffer = NULL;

    if(!pbstrBuffer)	
	return E_POINTER;

    if(IsBadWritePtr(pbstrBuffer,sizeof(pbstrBuffer)))
 	return E_POINTER;
  
    HRESULT hr = GetAdapterDescription(&ulcbSize, &pbBuffer);
    if(FAILED(hr))
        return hr;

    if (!pbBuffer || !ulcbSize)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    CComBSTR bstrTmp(ulcbSize, (char *) pbBuffer);              // copy into bstrTmp, it has a nice CopyTo method that alloc's correct way
    if(!bstrTmp)
        return ERROR_NOT_ENOUGH_MEMORY;
    return bstrTmp.CopyTo(pbstrBuffer);         
}
////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::ThreadFunction (
    void
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    DWORD  dwWaitResult       = WAIT_OBJECT_0;
    HRESULT hr                = NOERROR;
    KSPROPERTY  IPSinkControl = {0};
    ULONG ulcbSize            = 0;
    BYTE *pbMulticastList     = NULL;
    BYTE *pbAdapterDescription = NULL;
    BYTE *pbNIC                = NULL;
    HANDLE hEvent              = NULL;


    //
    // Enable an event which will get signaled by the IPSink minidriver when there
    // is a change to the multicast list
    //
    if ((hr = EnableEvent (&IID_IBDA_IPSinkEvent, EVENT_IPSINK_MULTICASTLIST)) != NOERROR)
    {
        goto ret;
    }

    //
    // Enable an event which will get signaled by the IPSink minidriver when there
    // is a change in the adapter description
    //
    if ((hr = EnableEvent (&IID_IBDA_IPSinkEvent, EVENT_IPSINK_ADAPTER_DESCRIPTION)) != NOERROR)
    {
        if (m_EventHandle [EVENT_IPSINK_MULTICASTLIST])
        {
            // Close this event since we got an error.
            //
            CloseHandle (m_EventHandle [EVENT_IPSINK_MULTICASTLIST]);
        }
        m_EventHandle [EVENT_IPSINK_MULTICASTLIST] = NULL;

        goto ret;
    }

    do
    {



        dwWaitResult = WaitForMultipleObjects (
                            EVENT_COUNT,                  // number of handles in the handle array
                            this->m_EventHandle,          // pointer to the object-handle array
                            FALSE,                        // wait flag
                            INFINITE
                            );

        if (dwWaitResult == WAIT_FAILED)
        {
            dwWaitResult = GetLastError ();
            hr = E_FAIL;
            goto ret;
        }

        hEvent = this->m_EventHandle [dwWaitResult - WAIT_OBJECT_0];

        switch (dwWaitResult - WAIT_OBJECT_0)
        {
            case EVENT_IPSINK_MULTICASTLIST:

                hr = this->GetMulticastList (&ulcbSize, &pbMulticastList);

                break;

            case EVENT_IPSINK_ADAPTER_DESCRIPTION:

                hr = this->GetAdapterDescription (&ulcbSize, &pbAdapterDescription);
                hr = this->privGetAdapterIPAddress (&ulcbSize, &pbNIC);
                hr = this->SetAdapterIPAddress (ulcbSize, pbNIC);

                break;

            case EVENT_IPSINK_THREAD_SHUTDOWN:    
            default:
                goto ret;
                break;
        }


        //
        // Reset and get ready for the next event
        //

        if (ResetEvent (hEvent) == FALSE)
        {
            //
            // ERROR detected resetting event
            //
            hr = GetLastError ();
            goto ret;
        }

    } while (TRUE);


ret:

    //  Let the parent thread know that we're done.
    //
    if (m_EventHandle [EVENT_IPSINK_THREAD_SYNC])
    {
        SetEvent( m_EventHandle [EVENT_IPSINK_THREAD_SYNC]);
    }

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
DWORD
WINAPI
CIPSinkControlInterfaceHandler::ThreadFunctionWrapper (
    LPVOID pvParam
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    CIPSinkControlInterfaceHandler *pThread;

    pThread = (CIPSinkControlInterfaceHandler *) pvParam;

    return pThread->ThreadFunction ();
}



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::EnableEvent (
    const GUID *pInterfaceGuid,
    ULONG ulId
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    HRESULT hr = NOERROR;
    KSEVENT Event;
    DWORD BytesReturned;

    if (m_ObjectHandle && m_EventHandle [ulId] == NULL)
    {
        this->m_EventHandle [ulId] = CreateEvent (
                                NULL,           // no security attributes
                                TRUE,           // manual reset
                                FALSE,          // initial state not signaled
                                NULL            // no object name
                                );

        if (this->m_EventHandle [ulId])
        {
            //
            // Set the event information into some KS structures which will
            // get passed to KS and Streaming class
            //
            m_EventData.NotificationType        = KSEVENTF_EVENT_HANDLE;
            m_EventData.EventHandle.Event       = this->m_EventHandle [ulId];
            m_EventData.EventHandle.Reserved[0] = 0;
            m_EventData.EventHandle.Reserved[1] = 0;

            Event.Set   = *pInterfaceGuid; //IID_IBDA_IPSinkEvent;
            Event.Id    = ulId;
            Event.Flags = KSEVENT_TYPE_ENABLE;

            hr = ::KsSynchronousDeviceControl (
                m_ObjectHandle,
                IOCTL_KS_ENABLE_EVENT,
                &Event,
                sizeof(Event),
                &m_EventData,
                sizeof(m_EventData),
                &BytesReturned
                );

        }
        else
        {
            hr = HRESULT_FROM_WIN32( GetLastError ());
        }
    }

    return hr;
}



////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
void
CIPSinkControlInterfaceHandler::ExitThread(
    )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG ul = 0;

    if (m_ThreadHandle && m_EventHandle [EVENT_IPSINK_THREAD_SHUTDOWN])
    {
        //
        // Tell the thread to exit
        //
        m_ThreadHandle = NULL;
        if (SetEvent(m_EventHandle [EVENT_IPSINK_THREAD_SHUTDOWN]))
        {
            //
            // Synchronize with thread termination.
            //
            if (m_EventHandle [EVENT_IPSINK_THREAD_SYNC])
            {
                WaitForSingleObjectEx( 
                    m_EventHandle [EVENT_IPSINK_THREAD_SYNC],
                    INFINITE, 
                    FALSE
                    );
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::Set (
     IN  PKSPROPERTY pIPSinkControl,
     IN  PVOID  pvBuffer,
     IN  ULONG  ulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pIPSinkControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                ulcbSize,
                &BytesReturned);

    ulcbSize = BytesReturned;

    return hr;
}


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
STDMETHODIMP
CIPSinkControlInterfaceHandler::Get (
     IN  PKSPROPERTY pIPSinkControl,
     OUT PVOID  pvBuffer,
     OUT PULONG pulcbSize
     )
////////////////////////////////////////////////////////////////////////////////////////////
{
    ULONG       BytesReturned = 0;
    HRESULT     hr            = NOERROR;

    hr = ::KsSynchronousDeviceControl(
                m_ObjectHandle,
                IOCTL_KS_PROPERTY,
                (PVOID) pIPSinkControl,
                sizeof(KSPROPERTY),
                pvBuffer,
                *pulcbSize,
                &BytesReturned);

    *pulcbSize = BytesReturned;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ipsink\pch.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Precompiled header for ipsink.ax

--*/

// Windows


#include <winsock2.h>
#include <ws2tcpip.h>
#include <Iphlpapi.h>

// DShow
#include <streams.h>

// KS
#include <ks.h>
#include <ksproxy.h>

#include <atlbase.h>
#include <BdaIface.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ipsink\ipuids.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
// 
#define STATIC_IID_IBDA_IPSinkControl\
    0x3F4DC8E2L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E2-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkControl);
#define IID_IBDA_IPSinkControl DEFINE_GUIDNAMED(IID_IBDA_IPSinkControl)

// {A750108F-492E-4d51-95F7-649B23FF7AD7}
#define STATIC_IID_IBDA_IPSinkInfo\
    0xa750108f, 0x492e, 0x4d51, 0x95, 0xf7, 0x64, 0x9b, 0x23, 0xff, 0x7a, 0xd7
DEFINE_GUIDSTRUCT("A750108F-492E-4d51-95F7-649B23FF7AD7", IID_IBDA_IPSinkInfo);
#define IID_IBDA_IPSinkInfo DEFINE_GUIDNAMED(IID_IBDA_IPSinkInfo)


////////////////////////////////////////////////////////////////////////////////////////////
//
//
//
#define STATIC_IID_IBDA_IPSinkEvent\
    0x3F4DC8E3L, 0x4050, 0x11D3, 0x8F, 0x4B, 0x00, 0xC0, 0x4F, 0x79, 0x71, 0xE2
DEFINE_GUIDSTRUCT("3F4DC8E3-4050-11d3-8F4B-00C04F7971E2", IID_IBDA_IPSinkEvent);
#define IID_IBDA_IPSinkEvent DEFINE_GUIDNAMED(IID_IBDA_IPSinkEvent)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksclockf\ksclockf.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksclockf.cpp

Abstract:

    Provides an object interface to query, and a method to forward AM clocks.

--*/

#include <windows.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksclockf.h"

struct DECLSPEC_UUID("877e4352-6fea-11d0-b863-00aa00a216a1") IKsClock;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
struct DECLSPEC_UUID("877e4351-6fea-11d0-b863-00aa00a216a1") CLSID_KsClockF;

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] =
{
    {L"KS Clock Forwarder", &__uuidof(CLSID_KsClockF), CKsClockF::CreateInstance, NULL, NULL},
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CKsClockF::CreateInstance(
    LPUNKNOWN   UnkOuter,
    HRESULT*    hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Clock
    Forwarder. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new CKsClockF(UnkOuter, NAME("KsClockF Class"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


CKsClockF::CKsClockF(
    LPUNKNOWN   UnkOuter,
    TCHAR*      Name,
    HRESULT*    hr
    ) :
    CUnknown(Name, UnkOuter),
    m_RefClock(NULL),
    m_Thread(NULL),
    m_ThreadEvent(NULL),
    m_ClockHandle(NULL),
    m_State(State_Stopped),
    m_StartTime(0),
    m_PendingRun(FALSE)
/*++

Routine Description:

    The constructor for the clock forwarder object. Just initializes
    everything to NULL and opens the kernel mode clock proxy.

Arguments:

    UnkOuter -
        Specifies the outer unknown, which must be set.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // Must have a parent, as this is always an aggregated object.
    //
    if (UnkOuter) {
        //
        // Try to open the default clock device.
        //
        *hr = KsOpenDefaultDevice(
            KSCATEGORY_CLOCK,
            GENERIC_READ | GENERIC_WRITE,
            &m_ClockHandle);
    } else {
        *hr = VFW_E_NEED_OWNER;
    }
}


CKsClockF::~CKsClockF(
    )
/*++

Routine Description:

    The destructor for the clock forwarder instance.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // The kernel mode clock proxy may have failed to open.
    //
    if (m_ClockHandle) {
        //
        // If there is a clock handle, the clock may have been started. If there
        // was not a handle, then it could not have been started. This will close
        // down everything, and wait for the thread to terminate.
        //
        Stop();
        CloseHandle(m_ClockHandle);
    }
    //
    // No reference clock may have been yet associated, or it may have been changed.
    //
    if (m_RefClock) {
        m_RefClock->Release();
    }
}


STDMETHODIMP
CKsClockF::NonDelegatingQueryInterface(
    REFIID iid,
    void ** ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interfaces explicitly supported
    are IDistributorNotify and IKsObject.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (iid == __uuidof(IKsClock)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (iid == __uuidof(IDistributorNotify)) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(iid, ppv);
}


STDMETHODIMP
CKsClockF::Stop(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Stop method. This sets the state of
    the underlying kernel mode proxy to a Stop state. If a forwarding
    thread had been created, it is terminated.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Abort the startup sequence if necessary.
    //
    m_PendingRun = FALSE;
    m_State = State_Stopped;
    //
    // This is created first on a Pause.
    //
    if (m_ThreadEvent) {
        //
        // Check in case a Pause or Run failed because the thread could not be
        // created.
        //
        if (m_Thread) {
            //
            // Signal the thread of a change, and wait for the thread to terminate.
            // Waiting ensures that only a single outstanding thread is attached to
            // this clock forwarder instance.
            //
            SetEvent(m_ThreadEvent);
            WaitForSingleObjectEx(m_Thread, INFINITE, FALSE);
            CloseHandle(m_Thread);
            m_Thread = NULL;
        }
        CloseHandle(m_ThreadEvent);
        m_ThreadEvent = NULL;
    }
    //
    // Set the state on the clock proxy afterwards so that the thread does not
    // make it jump ahead after being stopped.
    //
    SetState(KSSTATE_STOP);
    return S_OK;
}


STDMETHODIMP
CKsClockF::Pause(
     )
/*++

Routine Description:

    Implements the IDistributorNotify::Pause method. This sets the state of
    the underlying kernel mode proxy to a Pause state. If this is a transition
    from Stop --> Pause, a forwarder thread is created if such a thread has
    not already been created. If this is a transition from Run --> Pause, the
    state is changed and the thread is notified.

Arguments:

    None.

Return Value:

    Returns S_OK if the state change could occur, else a thread creation error.

--*/
{
    //
    // Abort the startup sequence if necessary. If the clock is still waiting on
    // a sequence to occur, then this just ensures that the clock will not try
    // to calculate a new start time, and startup the clock. Note that the kernel
    // mode proxy state is changed after signalling the forwarder thread so that
    // the state is kept in sync when possible.
    //
    m_PendingRun = FALSE;
    //
    // If the graph is currently stopped, then the forwarding thread must be
    // created.
    //
    if (m_State == State_Stopped) {
        //
        // The reference clock may have been set back to NULL, so don't
        // bother creating the thread in this case.
        //
        if (m_RefClock) {
            DWORD       ThreadId;

            //
            // This is the event used by the thread to wait between probing the
            // ActiveMovie clock. It is also used to force the clock to check
            // the current state when going to a Stopped or Run state. The event
            // handle should have been closed on a Stop state change, but in
            // case that never happened, just check for a handle first.
            //
            if (!m_ThreadEvent) {
                m_ThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                if (!m_ThreadEvent) {
                    DWORD   LastError;

                    LastError = GetLastError();
                    return HRESULT_FROM_WIN32(LastError);
                }
            }
            //
            // The event handle should have been closed on a Stop state change,
            // but in case that never happened, just check for a handle first.
            //
            if (!m_Thread) {
                //
                // Create this in a suspended state so that the priority and
                // state can be set up first.
                //
                m_Thread = CreateThread(
                    NULL,
                    0,
                    reinterpret_cast<PTHREAD_START_ROUTINE>(CKsClockF::ClockThread),
                    reinterpret_cast<PVOID>(this),
                    CREATE_SUSPENDED,
                    &ThreadId);
                if (!m_Thread) {
                    DWORD   LastError;

                    //
                    // The event handle can be cleaned up later.
                    //
                    LastError = GetLastError();
                    return HRESULT_FROM_WIN32(LastError);
                }
                //
                // The thread only works in short spurts, and when it does, it
                // must be very timely. Of course this is limited by the priority
                // of the calling process class.
                //
                SetThreadPriority(m_Thread, THREAD_PRIORITY_HIGHEST);
            }
            //
            // Only resume the thread after the state has been changed so that
            // the thread does not immediately exit.
            //
            m_State = State_Paused;
            ResumeThread(m_Thread);
        }
    } else if (m_State == State_Running) {
        //
        // Else just change the internal state so that the forwarding thread
        // knows to wait INFINITE rather than continue to update the kernel
        // mode proxy.
        //
        m_State = State_Paused;
        //
        // Signal the thread so that it has a chance of keeping up with state
        // changes. This does not attempt to synchronize the transition with
        // the thread, as the thread itself takes care of this problem.
        // The thread may not exist since the clock may have been set back to
        // NULL, though this module will stay loaded until the graph is destroyed.
        //
        if (m_ThreadEvent) {
            SetEvent(m_ThreadEvent);
        }
    }
    //
    // Update the state of the kernel mode proxy.
    //
    SetState(KSSTATE_PAUSE);
    return S_OK;
}


STDMETHODIMP
CKsClockF::Run(
    REFERENCE_TIME  Start
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Run method. Signals the forwarder
    thread to change the state of the underlying kernel mode proxy to a
    Run state. The thread waits to actually forward the change until the
    Start time has been met.

Arguments:

    Start -
        The reference time at which the state change should occur. This
        may be in the future compared to the current time presented by
        the master clock.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Since the clock forwarder is chained off DShow as a distributor
    // notification, we will not get insertion of a pause state between stop 
    // and run if the graph transitions directly from stop to run.  Thus, if we
    // were in a stop state, we must insert our own pause transition to 
    // compensate for this.  (NTBUG: 371949)
    //
    if (m_State == State_Stopped)
        Pause();

    m_StartTime = Start;
    //
    // Indicate that a new start time has been specified. This makes the
    // forwarder thread check the new time in case it must pause before
    // starting the kernel mode clock.
    //
    m_PendingRun = TRUE;
    m_State = State_Running;
    //
    // The thread will have been waiting INFINITE with the kernel mode
    // clock in Pause for this change to occur. The thread may not exist
    // since the clock may have been set back to NULL, though this
    // module will stay loaded until the graph is destroyed.
    //
    if (m_ThreadEvent) {
        SetEvent(m_ThreadEvent);
    }
    return S_OK;
}


STDMETHODIMP
CKsClockF::SetSyncSource(
    IReferenceClock*    RefClock
    )
/*++

Routine Description:

    Implements the IDistributorNotify::SetSyncSource method. Assigns the
    current master clock for the graph. This is assumed to occur before the
    graph actually is started, since the forwarder thread relies on a clock
    being present.

Arguments:

    RefClock -
        The interface pointer on the new clock source, else NULL if any current
        clock source is being abandoned.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Release any current handle first.
    //
    if (m_RefClock) {
        m_RefClock->Release();
    }
    //
    // Reference the new handle being passed, if any. This may be NULL if a
    // different clock is being selected, and this distributor has not been
    // unloaded yet.
    //
    m_RefClock = RefClock;
    if (m_RefClock) {
        m_RefClock->AddRef();
    }
    return S_OK;
}


STDMETHODIMP
CKsClockF::NotifyGraphChange(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::NotifyGraphChange method. The forwarder
    does not need to do anything on graph changes.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP_(HANDLE)
CKsClockF::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. This is actually accessed
    through the IKsClock Guid, which just provides a unique Guid to use when
    trying to load the module through the distributor on the ActiveMovie graph.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying kernel mode proxy clock. This is used
    by the ActiveMovie filter proxy to hand to kernel mode filters.

--*/
{
    return m_ClockHandle;
}


STDMETHODIMP
CKsClockF::SetState(
    KSSTATE DeviceState
    )
/*++

Routine Description:

    Set the state of the underlying kernel mode proxy. Normally a master clock
    cannot be directly set, as it just reflects some stream time or physical
    clock, but in this case it is just acting as a proxy for an Active Movie
    clock, so it does provide such a mechanism.

Arguments:

    DeviceState -
        The state to set the device to.

Return Value:

    Returns any device call error.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Clock;
    Property.Id = KSPROPERTY_CLOCK_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_ClockHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &DeviceState,
        sizeof(DeviceState),
        &BytesReturned);
}


HRESULT
CKsClockF::ClockThread(
    CKsClockF*  KsClockF
    )
/*++

Routine Description:

    The forwarder thread routine.

Arguments:

    KsClockF -
        The instance.

Return Value:

    Returns NOERROR.

--*/
{
    KSPROPERTY      Property;

    //
    // Initialize the property structures once.
    //
    Property.Set = KSPROPSETID_Clock;
    Property.Id = KSPROPERTY_CLOCK_TIME;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // The thread exits when the state goes back to Stopped. This means that on
    // startup, the thread is put into a suspended state until m_State has been
    // set to Paused.
    //
    while (KsClockF->m_State != State_Stopped) {
        REFERENCE_TIME  RefTime;
        DWORD           ThreadWaitTime;

        //
        // When moving to a Run state, a new m_StartTime will be presented to
        // the clock forwarder. This is used to delay the actual starting of
        // the kernel mode proxy. The rest of the kernel mode filters may have
        // been started, but the clock won't be until the correct time on the
        // ActiveMovie clock is reached.
        //
        if (KsClockF->m_PendingRun) {
            //
            // Check the difference between the new m_StartTime and the
            // current time on the ActiveMovie clock. Wait for the specified
            // amount of time, if there is a negative value, else make the
            // wait timeout immediately. After the wait is up, the kernel
            // mode proxy is started.
            //
            KsClockF->m_RefClock->GetTime(&RefTime);
            if (RefTime > KsClockF->m_StartTime) {
                ThreadWaitTime = static_cast<ULONG>((RefTime - KsClockF->m_StartTime) / 10000);
            } else {
                ThreadWaitTime = 0;
            }
        } else if (KsClockF->m_State != State_Running) {
            //
            // Else the clock is likely in a Paused state, which means that
            // the thread should wait until a state change, at which time
            // the event will be signalled. The state could also have been
            // just changed to Stopped, but in that case the event will also
            // have been signalled, and the thread will exit.
            //
            ThreadWaitTime = INFINITE;
        } else {
            //
            // Else just wait the default amount of time.
            //
            ThreadWaitTime = 1000;
        }
        WaitForSingleObjectEx(KsClockF->m_ThreadEvent, ThreadWaitTime, FALSE);
        //
        // The state may have changed during the wait.
        //
        if (KsClockF->m_State == State_Running) {
            ULONG   BytesReturned;

            //
            // Determine if this is the first time through the loop after a
            // state change to Run. If so, the kernel mode proxy state must
            // now be started. The compare is interlocked so that multiple
            // state changes do not allow this assignment to wipe out the
            // current value of m_PendingRun.
            //
            // If a Run/Pause/Run sequence occurs quickly, there is a chance
            // that the kernel mode clock will be left running, even though
            // the m_StartTime has been changed to indicate that filters
            // should not be running yet. The kernel mode proxy time will
            // continuously be adjusted back until the ActiveMovie start time
            // catches up.
            //
            if (InterlockedCompareExchange(reinterpret_cast<PLONG>(&KsClockF->m_PendingRun), FALSE, TRUE)) {
                KsClockF->SetState(KSSTATE_RUN);
                //
                // If a Run/Pause sequence occurs quickly, there is a chance
                // that the kernel mode proxy will be set to the wrong state.
                // Therefore check afterwards, and set the proxy to a Pause
                // state if the graph state was changed after the compare,
                // but before setting the proxy state.
                //
                // Since when a transition to a Stopped state occurs, the
                // thread is terminated, then the kernel mode proxy state
                // is changed to a Stop state, this will not harm anything.
                // Otherwise the clock would correctly be placed back into
                // a Pause state. This saves attempting to synchronize with
                // the Run --> Pause transition.
                //
                if (KsClockF->m_State != State_Running) {
                    KsClockF->SetState(KSSTATE_PAUSE);
                }
            }
            //
            // Synchronize the kernel mode proxy with the current time,
            // offset by the m_StartTime, which gives actual stream time.
            // The kernel clock time progression stops when set to a stop
            // state, which is the difference between it and an Active
            // Movie clock.
            //
            KsClockF->m_RefClock->GetTime(&RefTime);
            RefTime -= KsClockF->m_StartTime;
            ::KsSynchronousDeviceControl(
                KsClockF->m_ClockHandle,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &RefTime,
                sizeof(RefTime),
                &BytesReturned);
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksclockf\ksclockf.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksclockf.h

Abstract:

    Internal header.

--*/

class CKsClockF :
    public CUnknown,
    public IDistributorNotify,
    public IKsObject {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsClockF(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~CKsClockF();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

    // Implement IDistributorNotify
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP NotifyGraphChange();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

private:
    STDMETHODIMP SetState(
        KSSTATE DeviceState);
    static HRESULT ClockThread(
        CKsClockF* KsClockF);

    IReferenceClock* m_RefClock;
    HANDLE m_Thread;
    HANDLE m_ThreadEvent;
    HANDLE m_ClockHandle;
    FILTER_STATE m_State;
    REFERENCE_TIME m_StartTime;
    BOOL m_PendingRun;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksbasaud\ksbasaud.h ===
//--------------------------------------------------------------------------;
//
//  File: ksbasaud.h
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Header for KsProxy audio interface handler for hardware decoders
//      
//  History:
//      11/08/99    glenne     created
//
//--------------------------------------------------------------------------;

//
// Interface Handler class for filter
//
class CKsIBasicAudioInterfaceHandler :
    public CBasicAudio,
    public IDistributorNotify
{

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsIBasicAudioInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);

    ~CKsIBasicAudioInterfaceHandler();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);
    
protected:

    // IDistributorNotify
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tBase);
    STDMETHODIMP NotifyGraphChange();

    // Implement IBasicAudio
    STDMETHODIMP put_Volume (IN  long   lVolume);
    STDMETHODIMP get_Volume (OUT long *plVolume);
    STDMETHODIMP put_Balance(IN  long   lVolume);
    STDMETHODIMP get_Balance(OUT long *plVolume);


private:
    bool IsVolumeControlSupported();
    bool KsControl(
        DWORD dwIoControl,
        PVOID pvIn,    ULONG cbIn,
        PVOID pvOut,   ULONG cbOut );
    template <class T, class S>
        bool KsControl( DWORD dwIoControl, T* pIn, S* pOut )
            { return KsControl( dwIoControl, pIn, sizeof(*pIn), pOut, sizeof(*pOut) ); }

private:
    bool    m_fIsVolumeSupported;
    IBaseFilter*    m_pFilter;
    HANDLE  m_hKsObject;
    LONG    m_lBalance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ipsink\ipsink.h ===
/////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996  Microsoft Corporation
//
//  Module Name: ipsink.h
//
//  Abstract:
//
//    Internal header
//
//
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
//
//
//

typedef enum
{
    EVENT_IPSINK_MULTICASTLIST,
    EVENT_IPSINK_ADAPTER_DESCRIPTION,
    EVENT_IPSINK_THREAD_SHUTDOWN,
    EVENT_IPSINK_THREAD_SYNC,
    EVENT_COUNT

} KSEVENT_IPSINK;



typedef union {
    DWORD  d;
    BYTE   b[4];
} IP_ADDR, *PIP_ADDR, IP_MASK, *PIP_MASK;

class CIPSinkControlInterfaceHandler :
    public CUnknown,
    public IBDA_IPSinkControl,
    public IBDA_IPSinkInfo
    {

public:

    DECLARE_IUNKNOWN;
    
    
// IBDA_IPSinkInfo  (in f:\nt\multimedia\Published\DXMDev\dshowdev\idl\bdaiface.idl )
    STDMETHODIMP get_MulticastList (
        unsigned long *pulcbSize,           // 6*N 6-byte 802.3 addresses
        BYTE          **pbBuffer            // allocated with CoTaskMemAlloc, must CoTaskMemFree in the callee
        );

    STDMETHODIMP get_AdapterDescription (
        BSTR    *pbstrBuffer
        );

    STDMETHODIMP get_AdapterIPAddress (
        BSTR     *pbstrBuffer
        );



    static CUnknown* CALLBACK CreateInstance(
            LPUNKNOWN UnkOuter,
            HRESULT* hr
            );

private:

// IBDA_IPSinkControl  (in f:\nt\multimedia\Published\DXMDev\dshowdev\idl\bdaiface.idl )
            // being depreciate - do not use in Ring3 code
    STDMETHODIMP GetMulticastList (
        unsigned long *pulcbSize,
        BYTE          **pbBuffer
        );

    STDMETHODIMP GetAdapterIPAddress (
        unsigned long *pulcbSize,
        PBYTE         *pbBuffer
        );

// local methods
    HRESULT GetAdapterDescription (
        unsigned long *pulcbSize,
        PBYTE         *pbBuffer
        );

    STDMETHODIMP SetAdapterIPAddress (
        unsigned long pulcbSize,
        PBYTE         pbBuffer
        );



    static DWORD WINAPI ThreadFunctionWrapper (LPVOID pvParam);

    STDMETHODIMP privGetAdapterIPAddress (
        unsigned long *pulcbSize,
        PBYTE         *pbBuffer
        );

    CIPSinkControlInterfaceHandler(
            LPUNKNOWN UnkOuter,
            TCHAR* Name,
            HRESULT* hr
            );

    ~CIPSinkControlInterfaceHandler (
            void
            );

    STDMETHODIMP NonDelegatingQueryInterface(
            REFIID riid,
            PVOID* ppv
            );

    STDMETHODIMP EnableEvent (
            const GUID *pInterfaceGuid,
            ULONG ulId
            );

    STDMETHODIMP ThreadFunction (
            void
            );

    STDMETHODIMP Set (
            IN  PKSPROPERTY  pIPSinkControl,
            IN  PVOID pvBuffer,
            IN  ULONG ulcbSize
            );

    STDMETHODIMP Get (
            IN  PKSPROPERTY pIPSinkControl,
            OUT PVOID  pvBuffer,
            OUT PULONG pulcbSize
            );

    HRESULT
    CreateThread (
            void
            );

    void ExitThread (
            void
            );


    BOOL validateIpAddr(
       	DWORD 
       	);
 
   void updateIpAddr(
   	      DWORD 
   	    );

   void ConvertIpDwordToString(
	   DWORD inIpAddr, 
	   LPSTR str
	   );

   BOOL compareAddresses (
	    PBYTE ,
	    DWORD 
	   );

   HRESULT selectMulticastAddress(
	   );

private:

    HANDLE                m_ObjectHandle;
    HANDLE                m_EndEventHandle;
    KSEVENTDATA           m_EventData;
    HANDLE                m_EventHandle [EVENT_COUNT];
    HANDLE                m_ThreadHandle;
    PBYTE                 m_pMulticastList;
    ULONG                 m_ulcbMulticastList;
    ULONG                 m_ulcbAllocated;
    PBYTE                 m_pAdapterDescription;
    ULONG                 m_ulcbAdapterDescription;
    ULONG                 m_ulcbAllocatedForDescription;
    PBYTE                 m_pIPAddress;
    ULONG                 m_ulcbIPAddress;
    ULONG                 m_ulcbAllocatedForAddress;
    LPUNKNOWN             m_UnkOuter;
    IP_ADDR                           m_multicastIpAddr ; 

    const GUID*           m_pPropSetID;
    const GUID*           m_pEventSetID;

    HANDLE           g_hMutex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksbasaud\ksbasaud.cpp ===
//--------------------------------------------------------------------------;
//
//  File: ksbasaud.cpp
//
//  Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//
//      Implements a DirectShow audio interface wrapper for KsProxy audio filters.
//      This file contains the startup code for the class plus the non interface-specific
//      code needed to implement the wrapper. This handler object code 
//      is instantiated via ksproxy's handler mechanism for ks filters and pins 
//      that support the static aggregates tagged in the g_Templates structure.
//      
//  History:
//      11/09/99    glenne     created
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksbasaud.h"
#include <initguid.h>
#include <math.h>

// struct DECLSPEC_UUID("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d") CLSID_KsIBasicAudioInterfaceHandler;

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//

#ifdef FILTER_DLL

static CFactoryTemplate g_Templates[] = 
{
    {L"KsIBasicAudioInterfaceHandler",  &CLSID_KsIBasicAudioInterfaceHandler, CKsIBasicAudioInterfaceHandler::CreateInstance, NULL, NULL}
};

static int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


#define DBG_LEVEL_TRACE_DETAILS 2
#define DBG_LEVEL_TRACE_FAILURES 1

// General purpose functions to convert from decibels to 
// amplitude and vice versa as well as symbolic consts

#define MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL 0xFFFFUL

// This function is passed a value that is in decibels
//  Maps -10000 to 0 decibels to 0x0000 to 0xffff linear
// 
static ULONG DBToAmplitude( LONG lDB )
{
    double dAF;

    if (0 <= lDB)
        return MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL;

    // input lDB is 100ths of decibels

    dAF = pow(10.0, (0.5+((double)lDB))/2000.0);

    // This gives me a number in the range 0-1
    // normalise to 0-MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL

    return (DWORD)(dAF*MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL);
}

static long AmplitudeToDB( long dwFactor )
{
    if (1>=dwFactor) {
	    return -10000;
    } else if (MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL <= dwFactor) {
	    return 0;	// This puts an upper bound - no amplification
    } else {
	    return (LONG)(2000.0 * log10((-0.5+(double)dwFactor)/double(MAX_VOLUME_AMPLITUDE_SINGLE_CHANNEL)));
    }
}


// Bounds a value between 2 others ...
static void bound(
    LONG *plValToBound, 
    const LONG dwLowerBound, 
    const LONG dwUpperBound
    )
{
    if (*plValToBound < dwLowerBound) {
        *plValToBound = dwLowerBound;
    } else if (*plValToBound > dwUpperBound) {
        *plValToBound = dwUpperBound;
    }
}


//
// GUID for this KsBasicAudioIntfHandler object
// {B9F8AC3E-0F71-11d2-B72C-00C04FB6BD3D}
// DEFINE_GUID(CLSID_KsIBasicAudioInterfaceHandler, 
// 0xb9f8ac3e, 0xf71, 0x11d2, 0xb7, 0x2c, 0x0, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d);

#if 0
// #ifdef FILTER_DLL
//--------------------------------------------------------------------------;
//
// templates for classes supported by this DLL
//
//--------------------------------------------------------------------------;
CFactoryTemplate g_Templates[] = 
{
    // Load for filters that support it
    {L"KsIBasicAudioInterfaceHandler",                   &CLSID_KsIBasicAudioInterfaceHandler, 
        CKsIBasicAudioInterfaceHandler::CreateInstance, NULL, NULL},

};

static int g_cTemplates = SIZEOF_ARRAY(g_Templates);

#endif  // #if 0

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::CreateInstance
//
// Create an instance of this audio interface handler for KsProxy.
//
// Returns a pointer to the non-delegating CUnknown portion of the object.
//
//--------------------------------------------------------------------------;
CUnknown* CALLBACK CKsIBasicAudioInterfaceHandler::CreateInstance ( LPUNKNOWN UnkOuter, HRESULT* phr )
{
    CUnknown *Unknown = NULL;

    if( !UnkOuter )
        return NULL;
        
    if( SUCCEEDED( *phr ) ) 
    {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_DETAILS
                , TEXT( "CKsIBasicAudioInterfaceHandler::CreateInstance called on object 0x%08lx" )
                , UnkOuter ) );
        //
        // first determine if we're being called for a filter or pin object
        //
        IBaseFilter * pFilter;
        *phr = UnkOuter->QueryInterface(
                                IID_IBaseFilter, 
                                reinterpret_cast<PVOID*>(&pFilter));
        if (SUCCEEDED( *phr ) ) {
            DbgLog( ( LOG_TRACE
                    , DBG_LEVEL_TRACE_DETAILS
                    , TEXT( "CKsIBasicAudioInterfaceHandler: load called on filter object" ) ) );
            //
            // if we're being called on a filter object, always create a new handler
            //
            Unknown = new CKsIBasicAudioInterfaceHandler( UnkOuter
                                            , NAME("DvdKs intf handler")
                                            , phr);
            if (!Unknown) {
                DbgLog( ( LOG_TRACE
                        , DBG_LEVEL_TRACE_FAILURES
                        , TEXT( "CKsIBasicAudioInterfaceHandler: ERROR - Load failed on filter object" ) ) );
                *phr = E_OUTOFMEMORY;
            }
            pFilter->Release();
        }
    } else {
        DbgLog( ( LOG_TRACE
                , DBG_LEVEL_TRACE_FAILURES
                , TEXT( "CKsIBasicAudioInterfaceHandler::CreateInstance called on NULL object" ) ) );
        *phr = E_FAIL;
    }
    return Unknown;
} 

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;
//
// Filter Handler methods
//
//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::CKsIBasicAudioInterfaceHandler
//
// The constructor for the DShow/KsProxy audio interface object. Save off 
// the IKsControl & IKsPropertySet ptrs for this object.
//
//--------------------------------------------------------------------------;
CKsIBasicAudioInterfaceHandler::CKsIBasicAudioInterfaceHandler( LPUNKNOWN UnkOuter, TCHAR* Name, HRESULT* phr )
: CBasicAudio(Name, UnkOuter)
, m_lBalance( 0 )
, m_hKsObject( 0 )
, m_fIsVolumeSupported( false ) // updated on first graph change
{
    if (UnkOuter) {
        IKsObject *pKsObject;
        //
        // The parent must support the IKsObject interface in order to obtain
        // the handle to communicate to
        //
        *phr = UnkOuter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
        if (SUCCEEDED(*phr)) {
            m_hKsObject = pKsObject->KsGetObjectHandle();
            ASSERT(m_hKsObject != NULL);

            *phr = UnkOuter->QueryInterface(IID_IBaseFilter, reinterpret_cast<PVOID*>(&m_pFilter));
            if (SUCCEEDED(*phr) ) {
                DbgLog((LOG_TRACE, 0, TEXT("IPin interface of pOuter is 0x%lx"), m_pFilter));
                //
                // Holding this ref count will prevent the proxy ever being destroyed
                //
                //  We're part of the parent, so the count is ok
                //
                m_pFilter->Release();
            }
            pKsObject->Release();
        }
    } else {
        *phr = VFW_E_NEED_OWNER;
    }
}

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::~CKsIBasicAudioInterfaceHandler
//
//--------------------------------------------------------------------------;
CKsIBasicAudioInterfaceHandler::~CKsIBasicAudioInterfaceHandler()
{
    DbgLog( ( LOG_TRACE
            , DBG_LEVEL_TRACE_DETAILS
            , TEXT( "CKsIBasicAudioInterfaceHandler destructor called" ) ) ); // save off constructor UnkOuter for logging?
}

//--------------------------------------------------------------------------;
//
// CDvdKsInftHandler::NonDelegationQueryInterface
//
// We support:
// 
// IBasicAudio         - basic output audio level and pan control, supported on filter and midi/wav audio input pins
// IDistributorNotify  - this is how ksproxy notifies of changes like pin creation, disconnects...
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::NonDelegatingQueryInterface
(
    REFIID  riid,
    PVOID*  ppv
)
{
    if (riid ==  IID_IBasicAudio) {
        return GetInterface(static_cast<IBasicAudio*>(this), ppv);
    }
    else if (riid == IID_IDistributorNotify) {
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
    }
    
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


//--------------------------------------------------------------------------;
//
// IDistributorNotify methods (filter)
//
//--------------------------------------------------------------------------;

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::SetSyncSouce
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::SetSyncSource(IReferenceClock *pClock) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Stop
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Stop() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Pause
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Pause() 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::Run
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::Run(REFERENCE_TIME tBase) 
{
    return S_OK;
}

//--------------------------------------------------------------------------;
//
// CKsIBasicAudioInterfaceHandler::NotifyGraphChange 
//
// This method will be called:
//
//  a) On the initial load of a ksproxy audio filter just after the filter pins have been
//     created. This will allow us to load a pin interface handler for any control input
//     pins that the filter supports, the cd audio, mic, and line input lines for example.
//     Pins of this type must support the IAMAudioInputMixer interface to allow DShow capture
//     apps to control the input mix level.
//
//--------------------------------------------------------------------------;
STDMETHODIMP CKsIBasicAudioInterfaceHandler::NotifyGraphChange() 
{
    HRESULT hr;
    IKsObject *pKsObject;

    ASSERT(m_pFilter != NULL);

    hr = m_pFilter->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&pKsObject));
    if (SUCCEEDED(hr)) {
        m_hKsObject = pKsObject->KsGetObjectHandle();

        pKsObject->Release();
        //
        // Re-enable the event on a reconnect, else ignore on a disconnect.
        //
        if (m_hKsObject) {
            m_fIsVolumeSupported = IsVolumeControlSupported();
            if( m_fIsVolumeSupported ) {
                put_Balance( m_lBalance );
            } else {
#ifdef _DEBUG
                MessageBox(NULL, TEXT("Volume control enabled on non-supported device"), TEXT("Failed"), MB_OK);
#endif
            }
        }
    }
    return hr;
}


bool CKsIBasicAudioInterfaceHandler::KsControl(
    DWORD dwIoControl,
    PVOID pvIn,  ULONG cbIn,
    PVOID pvOut, ULONG cbOut )
{
    if(!m_hKsObject){
        return false;
    }

   OVERLAPPED ov;

   RtlZeroMemory( &ov, sizeof(OVERLAPPED));
   if (NULL == (ov.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL ))){
      return false ;
   }

   DWORD cbReturned;
   bool fResult = (0 != DeviceIoControl( m_hKsObject,
                       dwIoControl,
                       pvIn, cbIn,
                       pvOut, cbOut,
                       &cbReturned,
                       &ov )) ;


   if (!fResult){
      if (ERROR_IO_PENDING == GetLastError()){
         WaitForSingleObject(ov.hEvent, INFINITE) ;
         fResult = true ;
      } else {
         fResult = false ;
      }
   }

   CloseHandle(ov.hEvent) ;
   return fResult;
}

bool CKsIBasicAudioInterfaceHandler::IsVolumeControlSupported()
// Returns true if the handle to the pin supports volume changes
// and false if not
{             
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME Volume;

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    // Just try to get the volume and see if it succeeds.
    return KsControl( IOCTL_KS_PROPERTY, &KsProperty, &Volume );
}

static void Debug_NoImplMessage()
{
#ifdef DEBUG
     MessageBox(NULL, TEXT("KsIBasicAudio Enumalator working, but device doesn't support it"), TEXT("Failed"), MB_OK);
#endif
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::get_Volume( long *plVolume )
{
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    int nRes;
    
    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_GET;

    bool fIOCallResult = KsControl( IOCTL_KS_PROPERTY, &KsProperty, &KsWaveVolume );

    if (fIOCallResult == false ){
        return E_FAIL; // unspecified failure -- for now
    }

    // this is the volume we return -- the larger of the 2 speaker values. 
    LONG lLeftDB = AmplitudeToDB(KsWaveVolume.LeftAttenuation);
    LONG lRightDB = AmplitudeToDB(KsWaveVolume.RightAttenuation);

    *plVolume = max( lLeftDB, lRightDB );

    m_lBalance = lRightDB - lLeftDB;
    return NOERROR;
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::put_Volume( long lVolume )
{
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    // This will be a DeviceIoControl put property call.
    KSPROPERTY KsProperty;
    KSWAVE_VOLUME KsWaveVolume;
    int nRes;
    BOOL bIOCallResult;

    LONG lLeftDB, lRightDB;
    if (m_lBalance >= 0) {
        // left is attenuated
        lLeftDB    = lVolume - m_lBalance ;
        lRightDB   = lVolume;
    } else {
        // right is attenuated
        lLeftDB    = lVolume;
        lRightDB   = lVolume - (-m_lBalance);
    }


    // These values should be attenuation values wrt reference volume and balance
    // We should remember to bound them ...
    KsWaveVolume.LeftAttenuation  = DBToAmplitude( lLeftDB );
    KsWaveVolume.RightAttenuation = DBToAmplitude( lRightDB );

    KsProperty.Set = KSPROPSETID_Wave;
    KsProperty.Id = KSPROPERTY_WAVE_VOLUME;
    KsProperty.Flags = KSPROPERTY_TYPE_SET;

    bIOCallResult = KsControl( IOCTL_KS_PROPERTY, &KsProperty, &KsWaveVolume );

    if (bIOCallResult == FALSE){
        return E_FAIL;   // unspecified failure -- for now
    }
    //  ODS("CKSProxy::put_Volume %ld %ld", lVolume, 0);
    return NOERROR;
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::get_Balance( long *plBalance ) 
{ 
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    long lVol;
    HRESULT hr = get_Volume(&lVol);
    if (SUCCEEDED(hr)){
        *plBalance = m_lBalance; // that's really it.
    }
    return hr; 
}

STDMETHODIMP 
CKsIBasicAudioInterfaceHandler::put_Balance( long lBalance )   
{ 
    if( !m_fIsVolumeSupported ) {
        Debug_NoImplMessage();
        return E_NOTIMPL;
    }
    LONG lVol;
    get_Volume(&lVol);              // get the present volume 

    m_lBalance = lBalance; // set the desired balance 
    // set the volume, so that 
    //      a. The present volume doesn't change.
    //      b. We get a new balance as required.
    return put_Volume(lVol);                
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksinterf\ksinterf.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksinterf.cpp

Abstract:

    This module implements the IKsInterfaceHandler interface for 
    the standard interfaces.

Author:

    Bryan A. Woodruff (bryanw) 1-Apr-1997

--*/

#include <windows.h>
#include <streams.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksinterf.h"

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {
        L"StandardInterfaceHandler", 
        &KSINTERFACESETID_Standard,
        CStandardInterfaceHandler::CreateInstance,
        NULL,
        NULL
    }
};
int g_cTemplates = SIZEOF_ARRAY( g_Templates );

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CStandardInterfaceHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of an
    interface handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( 
        LOG_TRACE, 
        0, 
        TEXT("CStandardInterfaceHandler::CreateInstance()")));

    Unknown = 
        new CStandardInterfaceHandler( 
                UnkOuter, 
                NAME("Standard Data Type Handler"), 
                KSINTERFACESETID_Standard,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CStandardInterfaceHandler::CStandardInterfaceHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown( Name, UnkOuter ),
    m_ClsID( ClsID )
/*++

Routine Description:

    The constructor for the interface handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    *hr = NOERROR;
} 


STDMETHODIMP
CStandardInterfaceHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsInterfaceHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsInterfaceHandler)) {
        return GetInterface(static_cast<IKsInterfaceHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CStandardInterfaceHandler::KsSetPin(
    IN IKsPin *KsPin
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsSetPin method. This is used to
    inform the streaming interface handler which pin it should be
    communicating with when passing data. This is set after the instance
    is created, but before any streaming is required of the instance.

    The function obtains the handle to the kernel mode pin.

Arguments:

    KsPin -
        Contains the interface to the pin to which this streaming interface
        handler is to be attached. It is assumed that this pin supports the
        IKsObject interface from which the underlying kernel handle can be
        obtained.

Return Value:

    Returns NOERROR if the pin passed was valid, else E_UNEXPECTED, or some
    QueryInterface error.

--*/
{
    IKsObject*  Object;
    HRESULT     hr;

    hr = KsPin->QueryInterface(__uuidof(IKsPinEx), reinterpret_cast<PVOID*>(&m_KsPinEx));
    if (SUCCEEDED( hr )) {
        //
        // Do not hold a cyclic reference to the pin.
        //
        m_KsPinEx->Release();
    } else {
        return hr;
    }
    
    hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
    //
    // The object must support the IKsObject interface in order to obtain
    // the handle to the kernel mode pin.
    //
    if (SUCCEEDED(hr)) {
        m_PinHandle = Object->KsGetObjectHandle();
        Object->Release();
        if (!m_PinHandle) {
            hr = E_UNEXPECTED;
            m_KsPinEx = NULL;
        }
    }
    return hr;
} 


STDMETHODIMP
GetSampleProperties(
    IN IMediaSample *Sample,
    OUT AM_SAMPLE2_PROPERTIES *SampleProperties
    )
/*++

Routine Description:

    Retrieves the properties of the given sample object. This is function
    obtains the sample properties even if the IMediaSample2 interface is
    not supported by the sample object. Note that the end time of a sample
    is corrected to not contain the incorrect value returned by the base
    classes.

Arguments:

    Sample -
        Contains the sample object whose properties are to be obtained. This
        object may or may not support IMediaSample2.

    SampleProperties -
        The place in which to put the sample properties retrieved.

Return Value:

    Returns NOERROR if the properties were retrieved, else any GetProperties
    error.

--*/
{
    HRESULT hr;

    //
    // This code was borrowed from the base class.
    //
    
    IMediaSample2 *Sample2;
    
    if (SUCCEEDED( Sample->QueryInterface(
                        __uuidof(IMediaSample2),
                        reinterpret_cast<PVOID*>(&Sample2) ) )) {
        //
        // If IMediaSample2 is supported, retrieving the properties
        // is easy.
                               
        hr = 
            Sample2->GetProperties(
                sizeof( *SampleProperties ), 
                reinterpret_cast<PBYTE>(SampleProperties) );
        Sample2->Release();
        SampleProperties->dwSampleFlags &= ~AM_SAMPLE_TYPECHANGED;
        if (!(SampleProperties->dwSampleFlags & AM_SAMPLE_TIMEVALID)) {
            SampleProperties->tStart = 0;
        }
        if (!(SampleProperties->dwSampleFlags & AM_SAMPLE_STOPVALID)) {
            //
            // Ignore the incorrect end time returned from any
            // IMediaSample implementation.
            //
            SampleProperties->tStop = SampleProperties->tStart;
        }
        
        if (FAILED( hr )) {
            return hr;
        }
    } else {
        //
        // Otherwise build the properties using the old interface.
        //
        
        SampleProperties->cbData = sizeof( *SampleProperties );
        SampleProperties->dwTypeSpecificFlags = 0;
        SampleProperties->dwStreamId = AM_STREAM_MEDIA;
        SampleProperties->dwSampleFlags = 0;
        if (S_OK == Sample->IsDiscontinuity()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_DATADISCONTINUITY;
        }
        if (S_OK == Sample->IsPreroll()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_PREROLL;
        }
        if (S_OK == Sample->IsSyncPoint()) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_SPLICEPOINT;
        }
        //
        // This call can return an informational status if the end time
        // is not set. This will never happen because the only way an
        // end time will not be valid while the start time is, is if the
        // IMediaSample2 interface is supported, which in this case it
        // is not. However, a client may be trying to do this, thus the
        // check below.
        //
        hr = Sample->GetTime(
            &SampleProperties->tStart,
            &SampleProperties->tStop);
        if (SUCCEEDED(hr)) {
            SampleProperties->dwSampleFlags |= AM_SAMPLE_TIMEVALID;
            if (SampleProperties->tStop != SampleProperties->tStart) {
                //
                // The only way to specify no valid stop time with the
                // SetTime interface is to make tStop == tStart. This means
                // that a zero duration frame, which has a valid stop time
                // cannot be created.
                //
                SampleProperties->dwSampleFlags |= AM_SAMPLE_STOPVALID;
            }
        } else {
            SampleProperties->tStart = 0;
            SampleProperties->tStop = 0;
        }
        Sample->GetPointer(&SampleProperties->pbBuffer);
        SampleProperties->lActual = Sample->GetActualDataLength();
        SampleProperties->cbBuffer = Sample->GetSize();
    }
    return S_OK;
}
   

STDMETHODIMP 
CStandardInterfaceHandler::KsProcessMediaSamples( 
    IN IKsDataTypeHandler *KsDataTypeHandler,
    IN IMediaSample** SampleList, 
    IN OUT PLONG SampleCount, 
    IN KSIOOPERATION IoOperation,
    OUT PKSSTREAM_SEGMENT *StreamSegment
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsProcessMediaSamples method. This
    function moves samples from or to the previously assigned filter pin.
    A stream header is initialized to represent each media sample in the
    stream segment. The I/O is then performed, the count of wait items is
    incremented, and the proxy I/O thread waits for completion.

Arguments:

    KsDataTypeHandler -
        Contains the interface to the data type handler for these media
        samples. This is the handler which knows the specifics about the
        particular media type being streamed.

    SampleList -
        Contains the list of samples to process.

    SampleCount -
        Contains the count of samples in SampleList. Is updated with the
        actual number of samples processed.

    IoOperation -
        Indicates the type of I/O operation to perform on the samples.
        This is KsIoOperation_Write or KsIoOperation_Read.

    StreamSegment -
        The place in which to put the pointer to the stream segment
        representing the headers sent to the kernel mode pin.

Return Value:

    Returns NOERROR if the samples were processed, else some memory allocation
    or an error from querying IMediaSample.

--*/
{
    int                     i;
    AM_SAMPLE2_PROPERTIES   SampleProperties;
    HRESULT                 hr;
    PKSSTREAM_HEADER        CurrentHeader;
    PKSSTREAM_SEGMENT_EX2   StreamSegmentEx;
    ULONG                   SizeOfStreamHeaders, Written;
    
    //
    // Allocate an extended stream segment
    //
        
    *StreamSegment = NULL;
    StreamSegmentEx = new KSSTREAM_SEGMENT_EX2;
    if (NULL == StreamSegmentEx) {
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    //
    // Create the event to be signalled on I/O completion
    //
    StreamSegmentEx->Common.CompletionEvent = 
        CreateEvent( 
            NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
            TRUE,       // BOOL bManualReset
            FALSE,      // BOOL bInitialState
            NULL );     // LPCTSTR lpName
            
    if (!StreamSegmentEx->Common.CompletionEvent) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        DbgLog((
            LOG_TRACE,
            0,
            TEXT("CStandardInterfaceHandler::KsProcessMediaSamples, failed to allocate event: %08x"),
            hr));
        *SampleCount = 0;
        delete StreamSegmentEx;
        return hr;        
    }
    
    //
    // The interface handler needs to stay present until this
    // stream segment has been completed. KsCompleteIo will then
    // release the object.
    //
    AddRef();
    StreamSegmentEx->Common.KsInterfaceHandler = this;
    
    //
    // The KsDataTypeHandler may be NULL.
    //
    StreamSegmentEx->Common.KsDataTypeHandler = KsDataTypeHandler;
    StreamSegmentEx->Common.IoOperation = IoOperation;
    
    //
    // If a data handler is specified, query for the extended
    // header size.
    //
    
    if (StreamSegmentEx->Common.KsDataTypeHandler) {
        
        StreamSegmentEx->Common.KsDataTypeHandler->KsQueryExtendedSize( 
            &StreamSegmentEx->ExtendedHeaderSize );
            
        //
        // If an extended header size is specified, then AddRef() the
        // data handler interface, otherwise we don't need to keep
        // the pointer around.
        //
        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->AddRef();
        } else {
            StreamSegmentEx->Common.KsDataTypeHandler = NULL;
        }
    } else {
        StreamSegmentEx->ExtendedHeaderSize = 0;
    }
    
    StreamSegmentEx->SampleCount = *SampleCount;
    
    //
    // Allocate the stream headers with the appropriate header sizes
    //
    
    SizeOfStreamHeaders =
        (sizeof( KSSTREAM_HEADER ) +         
            StreamSegmentEx->ExtendedHeaderSize) * *SampleCount;
     
    StreamSegmentEx->StreamHeaders = 
        (PKSSTREAM_HEADER)
            new BYTE[ SizeOfStreamHeaders ];
    if (NULL == StreamSegmentEx->StreamHeaders) {
        if (StreamSegmentEx->Common.KsDataTypeHandler) {
            StreamSegmentEx->Common.KsDataTypeHandler->Release();
        }
        Release();
        delete StreamSegmentEx;
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    RtlZeroMemory( 
        StreamSegmentEx->StreamHeaders, 
        SizeOfStreamHeaders );
    
    //
    // For each sample, initialize the header.
    //
    
    CurrentHeader = StreamSegmentEx->StreamHeaders;
    for (i = 0; i < *SampleCount; i++) {
        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->KsPrepareIoOperation( 
                SampleList[ i ],
                (PVOID)CurrentHeader,
                StreamSegmentEx->Common.IoOperation );
        }
        
        //
        // Copy data pointers, set time stamps, etc.
        //
        
        if (SUCCEEDED(hr = ::GetSampleProperties( 
                            SampleList[ i ],
                            &SampleProperties ) )) {
                            
            CurrentHeader->OptionsFlags =
                SampleProperties.dwSampleFlags;
            CurrentHeader->Size = sizeof( KSSTREAM_HEADER ) +
                StreamSegmentEx->ExtendedHeaderSize;
            CurrentHeader->TypeSpecificFlags = 
                SampleProperties.dwTypeSpecificFlags;    
            CurrentHeader->PresentationTime.Time = SampleProperties.tStart;
            CurrentHeader->PresentationTime.Numerator = 1;
            CurrentHeader->PresentationTime.Denominator = 1;
            CurrentHeader->Duration = 
                SampleProperties.tStop - SampleProperties.tStart;
            CurrentHeader->Data = SampleProperties.pbBuffer;
            CurrentHeader->FrameExtent = SampleProperties.cbBuffer;
            
            if (IoOperation == KsIoOperation_Write) {
                CurrentHeader->DataUsed = SampleProperties.lActual;
            }
            
            //
            // Add the sample to the sample list.
            //
            
            StreamSegmentEx->Samples[ i ] = SampleList[ i ];
            
            //
            // If this is a write operation, hold the sample by 
            // incrementing the reference count. This is released
            // on completion of the write.
            //
            if (StreamSegmentEx->Common.IoOperation == KsIoOperation_Write) {
                StreamSegmentEx->Samples[ i ]->AddRef();
            }
            
        } else {
            //
            // This is considered a fatal error.
            //
            
            DbgLog(( 
                LOG_TRACE, 
                0, 
                TEXT("::GetSampleProperties failed")));
        
            
            if (i) {
                //
                // Undo any of the work performed above.
                //

                CurrentHeader = 
                    reinterpret_cast<PKSSTREAM_HEADER>
                        (reinterpret_cast<PBYTE>(CurrentHeader) - 
                            (sizeof( KSSTREAM_HEADER ) +
                                StreamSegmentEx->ExtendedHeaderSize));
                
                for (--i; i >= 0; i--) {
                    StreamSegmentEx->Common.KsDataTypeHandler->KsCompleteIoOperation( 
                        StreamSegmentEx->Samples[ i ],
                        reinterpret_cast<PVOID>(CurrentHeader),
                        StreamSegmentEx->Common.IoOperation,
                        TRUE ); // BOOL Cancelled
                        
                    //
                    // Didn't get a chance to AddRef() the sample, do
                    // not release it.
                    //                        
                     
                    CurrentHeader = 
                        reinterpret_cast<PKSSTREAM_HEADER>
                            (reinterpret_cast<PBYTE>(CurrentHeader) - 
                                (sizeof( KSSTREAM_HEADER ) +
                                    StreamSegmentEx->ExtendedHeaderSize));
                }
            }
            
            delete StreamSegmentEx->StreamHeaders;
            if (StreamSegmentEx->Common.KsDataTypeHandler) {
                StreamSegmentEx->Common.KsDataTypeHandler->Release();
            }
            Release();
            delete StreamSegmentEx;
            *SampleCount = 0;
            return hr;
        }
        CurrentHeader = 
            reinterpret_cast<PKSSTREAM_HEADER>
                (reinterpret_cast<PBYTE>(CurrentHeader) + 
                    sizeof( KSSTREAM_HEADER ) +
                        StreamSegmentEx->ExtendedHeaderSize);
    }
    
    //
    // Write the stream header to the device and return.
    //
    
    StreamSegmentEx->Overlapped.hEvent = 
        StreamSegmentEx->Common.CompletionEvent;
    m_KsPinEx->KsIncrementPendingIoCount();
    
    if (!DeviceIoControl( 
            m_PinHandle,
            (IoOperation == KsIoOperation_Write) ? 
                IOCTL_KS_WRITE_STREAM : IOCTL_KS_READ_STREAM,
            NULL,
            0,
            StreamSegmentEx->StreamHeaders,
            SizeOfStreamHeaders,
            &Written,
            &StreamSegmentEx->Overlapped )) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        //
        // On a failure case signal the event, but do not decrement the
        // pending I/O count, since this is done in the completion
        // routine already.
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            hr = S_OK;
        } else {
            SetEvent( StreamSegmentEx->Overlapped.hEvent );
        }
    } else {
        //
        // Completed synchronously -- signal the event so that I/O processing 
        // will continue.  Note that the event is not signalled via 
        // DeviceIoControl() in this case.
        //
        
        SetEvent( StreamSegmentEx->Overlapped.hEvent );
        hr = S_OK;
    }
    
    *StreamSegment = reinterpret_cast<PKSSTREAM_SEGMENT>(StreamSegmentEx);
    
    return hr;
}    


STDMETHODIMP
CStandardInterfaceHandler::KsCompleteIo(
    IN PKSSTREAM_SEGMENT StreamSegment
    )
/*++

Routine Description:

    Implements the IKsInterfaceHandler::KsCompleteIo method. This function
    cleans up after I/O initiated by KsProcessMediaSamples. It discards
    allocated memory, updates the media samples and delivers them on a Read
    operation, and decrements the count of wait items for the proxy.

Arguments:

    StreamSegment -
        Contains the previously allocated stream segment which is being
        completed. This is called because the event was signalled for this
        stream segment, indicating that the kernel mode pin completed the
        I/O.

Return Value:

    Returns NOERROR.

--*/
{
    int                     i;
    BOOL                    Succeeded;
    PKSSTREAM_HEADER        CurrentHeader;
    PKSSTREAM_SEGMENT_EX2   StreamSegmentEx;
    ULONG                   Error, Returned;
    
    //
    // Clean up extended headers and release media samples.
    //
    
    StreamSegmentEx = (PKSSTREAM_SEGMENT_EX2) StreamSegment;
    CurrentHeader = StreamSegmentEx->StreamHeaders;
    
    Succeeded = 
        GetOverlappedResult( 
            m_PinHandle,
            &StreamSegmentEx->Overlapped,
            &Returned,
            FALSE );
    Error = (Succeeded ? NOERROR : GetLastError());
    
    for (i = 0; i < StreamSegmentEx->SampleCount; i++) {
        if (!Succeeded) {
            DbgLog(( 
                LOG_TRACE, 
                0, 
                TEXT("StreamSegment %08x failed"), StreamSegmentEx ));
                
            m_KsPinEx->KsNotifyError(
                StreamSegmentEx->Samples[ i ],
                HRESULT_FROM_WIN32( Error ) );
        }                
        
        // Millennium and beyond, copy the TypeSpecificFlags if non-zero
        if (StreamSegmentEx->StreamHeaders[i].TypeSpecificFlags) {
            IMediaSample2 * MediaSample2;
            HRESULT hr;

            hr = StreamSegmentEx->Samples[i]->QueryInterface(__uuidof(IMediaSample2), 
                                                             reinterpret_cast<PVOID*>(&MediaSample2));
            if (SUCCEEDED( hr )) {
                AM_SAMPLE2_PROPERTIES Sample2Properties;

                MediaSample2->GetProperties(FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual), 
                                            (PBYTE)&Sample2Properties);
                Sample2Properties.cbData = FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual);
                // Copy the type specific flags
                Sample2Properties.dwTypeSpecificFlags = StreamSegmentEx->StreamHeaders[i].TypeSpecificFlags;
                // There's no way to set TimeDiscontinuity from IMediaSample, so we must
                // copy this single bit here
                Sample2Properties.dwSampleFlags |= (StreamSegmentEx->StreamHeaders[i].OptionsFlags & KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY);
                MediaSample2->SetProperties(FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, lActual), 
                                            (PBYTE)&Sample2Properties);
                MediaSample2->Release();
            }
        }
        // end Millennium and beyond, copy the TypeSpecificFlags if non-zero


        if (StreamSegmentEx->ExtendedHeaderSize) {
            StreamSegmentEx->Common.KsDataTypeHandler->KsCompleteIoOperation( 
                StreamSegmentEx->Samples[ i ],
                reinterpret_cast<PVOID>(CurrentHeader),
                StreamSegmentEx->Common.IoOperation,
                !Succeeded );
        }        
        
        if (StreamSegmentEx->Common.IoOperation != KsIoOperation_Read) {
            //
            // We're going nowhere else with this sample, OK to release.
            //
            StreamSegmentEx->Samples[ i ]->Release();
        
        } else {
        
            //
            // If this is a read operation, deliver the sample to the input
            // pin.  IKsPin->KsDeliver() simply calls the base class to
            // deliver the sample to the connected input pin.
            //
        
            REFERENCE_TIME  tStart, *ptStart, tStop, *ptStop;
        
            //
            // Reflect stream header information in IMediaSample
            //
            
            //
            // (gubgub) Need to reflect media type change here!
            // There is no exisitng driver that will automously change
            // media type midstream. Nor can I see any in near future. 
            // To be complete, still, the type change shall be reflected. 
            // A separate is to be created to track this.
            // 
            
            ptStart = ptStop = NULL;
            
            if (Succeeded) {
                
                StreamSegmentEx->Samples[ i ]->SetDiscontinuity(
                    CurrentHeader->OptionsFlags & 
                        KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY );
                StreamSegmentEx->Samples[ i ]->SetPreroll(
                    CurrentHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_PREROLL
                    );
                StreamSegmentEx->Samples[ i ]->SetSyncPoint(
                    CurrentHeader->OptionsFlags &
                        KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT
                    );
                    
                if (CurrentHeader->OptionsFlags & 
                        KSSTREAM_HEADER_OPTIONSF_TIMEVALID) {
                    tStart = CurrentHeader->PresentationTime.Time;
                    ptStart = &tStart;
                    if (CurrentHeader->OptionsFlags &
                            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID) {
                        tStop = 
                            tStart + CurrentHeader->Duration;
                        ptStop = &tStop;
                    } 
                }
            }
                  
            if (FAILED(StreamSegmentEx->Samples[ i ]->SetTime( ptStart, ptStop )) && !ptStop) {
                //
                // There is no way to specify that the duration is
                // not valid through old SetTime. This means that a
                // zero duration sample with a valid duration cannot
                // be passed. GetSampleProperties makes the assumption
                // that if tStart == tStop on old GetTime, then the
                // duration is not valid.
                //
                StreamSegmentEx->Samples[ i ]->SetTime( ptStart, ptStart );
            }
                
            ASSERT( CurrentHeader->FrameExtent == 
                    static_cast<ULONG>(StreamSegmentEx->Samples[ i ]->GetSize()) );
            StreamSegmentEx->Samples[ i ]->SetActualDataLength( 
                (Succeeded) ? CurrentHeader->DataUsed : 0 );
            
            //
            // To avoid a chicken-vs-egg situation, the KsDeliver method
            // releases the sample so that when queuing buffers to the
            // device, we can retreive this sample if it is the last
            // sample.
            //
            
            if (Succeeded) {
                m_KsPinEx->KsDeliver( 
                    StreamSegmentEx->Samples[ i ], 
                    CurrentHeader->OptionsFlags );
            }                    
            else {
                //
                // Don't deliver cancelled packets or errors.
                //
                StreamSegmentEx->Samples[ i ]->Release();
            } 
        }
        
        CurrentHeader = 
            reinterpret_cast<PKSSTREAM_HEADER>
                (reinterpret_cast<PBYTE>(CurrentHeader) + 
                    sizeof( KSSTREAM_HEADER ) +
                        StreamSegmentEx->ExtendedHeaderSize);
    }   
    
    delete [] StreamSegmentEx->StreamHeaders;
    if (StreamSegmentEx->ExtendedHeaderSize) {
        StreamSegmentEx->Common.KsDataTypeHandler->Release();
    }
    
    m_KsPinEx->KsDecrementPendingIoCount();
    m_KsPinEx->KsMediaSamplesCompleted( StreamSegment );
    
    delete StreamSegmentEx;
    
    //
    // This was previously AddRef'd in KsProcessMediaSamples to keep this
    // instance present.
    //
    Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksinterf\ksinterf.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ksinterf.h
//
//--------------------------------------------------------------------------

#ifndef __KSINTERF__
#define __KSINTERF__

#define MAXIMUM_SAMPLES_PER_SEGMENT 64

// below renamed to prevent collision with struct with same name in ksiproxy.h
typedef struct _KSSTREAM_SEGMENT_EX2 {
    KSSTREAM_SEGMENT        Common;
    IMediaSample            *Samples[ MAXIMUM_SAMPLES_PER_SEGMENT ];
    int                     SampleCount;
    ULONG                   ExtendedHeaderSize;
    PKSSTREAM_HEADER        StreamHeaders;
    OVERLAPPED              Overlapped;

} KSSTREAM_SEGMENT_EX2, *PKSSTREAM_SEGMENT_EX2;

class CStandardInterfaceHandler :
    public CUnknown,
    public IKsInterfaceHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsInterfaceHandler
    
    STDMETHODIMP
    KsSetPin( 
        IN IKsPin *KsPin 
        );
    
    STDMETHODIMP 
    KsProcessMediaSamples( 
        IN IKsDataTypeHandler *KsDataTypeHandler,
        IN IMediaSample** SampleList, 
        IN OUT PLONG SampleCount, 
        IN KSIOOPERATION IoOperation,
        OUT PKSSTREAM_SEGMENT *StreamSegment
        );
        
    STDMETHODIMP
    KsCompleteIo(
        IN PKSSTREAM_SEGMENT StreamSegment
        );
        
private:
    CLSID     m_ClsID;
    IKsPinEx  *m_KsPinEx;
    HANDLE    m_PinHandle;

    CStandardInterfaceHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
};

#endif // __KSINTERF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksdata\ksdata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       ksdata.h
//
//--------------------------------------------------------------------------

#ifndef __KSDATA__
#define __KSDATA__

class CStandardDataTypeHandler :
    public CUnknown,
    public IKsDataTypeHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance( 
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface( 
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsDataTypeHandler
    
    STDMETHODIMP 
    KsCompleteIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation, 
        IN BOOL Cancelled
        );
        
    STDMETHODIMP 
    KsIsMediaTypeInRanges(
        IN PVOID DataRanges
        );
        
    STDMETHODIMP 
    KsPrepareIoOperation(
        IN IMediaSample *Sample, 
        IN PVOID StreamHeader, 
        IN KSIOOPERATION IoOperation
        );
    
    STDMETHODIMP 
    KsQueryExtendedSize( 
        IN ULONG* ExtendedSize
        );
        
    STDMETHODIMP 
    KsSetMediaType(
        const AM_MEDIA_TYPE *AmMediaType
        );
        
private:
    CLSID       m_ClsID;
    CMediaType  *m_MediaType;

    CStandardDataTypeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        REFCLSID ClsID,
        HRESULT* hr
        );
        
    ~CStandardDataTypeHandler();
        
};

#endif // __KSDATA__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksolay\ksolay.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksolay.h

Abstract:

    Internal header.

--*/

class COverlay :
    public CUnknown,
#ifdef __IOverlayNotify2_FWD_DEFINED__
    public IOverlayNotify2,
#else // !__IOverlayNotify2_FWD_DEFINED__
    public IOverlayNotify,
#endif // !__IOverlayNotify2_FWD_DEFINED__
    public IDistributorNotify {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

#ifdef __IOverlayNotify2_FWD_DEFINED__
    static LRESULT CALLBACK PaintWindowCallback(
        HWND Window,
        UINT Message,
        WPARAM wParam,
        LPARAM lParam
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    COverlay(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~COverlay();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID riid,
        PVOID* ppv);

#ifdef __IOverlayNotify2_FWD_DEFINED__
    STDMETHODIMP_(HWND)
    CreateFullScreenWindow( 
        PRECT MonitorRect
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    // Implement IOverlayNotify2
    STDMETHODIMP OnPaletteChange( 
        DWORD Colors,
        const PALETTEENTRY* Palette);
    STDMETHODIMP OnClipChange( 
        const RECT* Source,
        const RECT* Destination,
        const RGNDATA* Region);
    STDMETHODIMP OnColorKeyChange( 
        const COLORKEY* ColorKey);
    STDMETHODIMP OnPositionChange( 
        const RECT* Source,
        const RECT* Destination);
#ifdef __IOverlayNotify2_FWD_DEFINED__
    STDMETHODIMP OnDisplayChange( 
        HMONITOR Monitor
        );
#endif // __IOverlayNotify2_FWD_DEFINED__

    // Implement IDistributorNotify
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP NotifyGraphChange();

private:
    HANDLE m_Object;
    IOverlay* m_Overlay;
    IUnknown* m_UnkOwner;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksdata\ksdata.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksdata.cpp

Abstract:

    This module implements the IKsDataTypeHandler interface for various
    CMediaType major types.

Author:

    Bryan A. Woodruff (bryanw) 28-Mar-1997

--*/

#include <windows.h>
#include <streams.h>
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksdata.h"

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {
        L"KsDataTypeHandler", 
        &KSDATAFORMAT_TYPE_AUDIO,
        CStandardDataTypeHandler::CreateInstance,
        NULL,
        NULL
    }
};
int g_cTemplates = SIZEOF_ARRAY( g_Templates );

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CStandardDataTypeHandler::CreateInstance(
    IN LPUNKNOWN UnkOuter,
    OUT HRESULT* hr
    )
/*++

Routine Description:

    This is called by KS proxy code to create an instance of a
    data type handler. It is referred to in the g_Templates structure.

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;
    
    DbgLog(( LOG_TRACE, 0, TEXT("CStandardDataTypeHandler::CreateInstance()")));

    Unknown = 
        new CStandardDataTypeHandler( 
                UnkOuter, 
                NAME("Audio Data Type Handler"), 
                KSDATAFORMAT_TYPE_AUDIO,
                hr);
                
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


CStandardDataTypeHandler::CStandardDataTypeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    IN REFCLSID    ClsID,
    OUT HRESULT*   hr
    ) :
    CUnknown(Name, UnkOuter),
    m_ClsID(ClsID),
    m_MediaType(NULL)
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    IN REFCLSID ClsID -
        The CLSID of the object.

    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    *hr = NOERROR;
} 


CStandardDataTypeHandler::~CStandardDataTypeHandler()
{
    if (m_MediaType) {
        delete m_MediaType;
    }
}


STDMETHODIMP
CStandardDataTypeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsDataTypeHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsDataTypeHandler)) {
        return GetInterface(static_cast<IKsDataTypeHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 

STDMETHODIMP 
CStandardDataTypeHandler::KsCompleteIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation, 
    IN BOOL Cancelled
    )

/*++

Routine Description:
    Clean up the extended header and complete I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation
    
    IN BOOL Cancelled
        Set if the I/O operation was cancelled.

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsPrepareIoOperation(
    IN IMediaSample *Sample, 
    IN PVOID StreamHeader, 
    IN KSIOOPERATION IoOperation
    )

/*++

Routine Description:
    Intialize the extended header and prepare sample for I/O operation.
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, there
    is no work to do, just return S_OK.

Arguments:
    IN IMediaSample *Sample
        pointer to the associated media sample
    
    IN PVOID StreamHeader
        pointer to the stream header with extension
        
    IN KSIOOPERATION IoOperation
        specifies the type of I/O operation

Return:
    S_OK

--*/

{
    return S_OK;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsIsMediaTypeInRanges(
    IN PVOID DataRanges
)

/*++

Routine Description:
    Validates that the given media type is within the provided data ranges.

Arguments:
    IN PVOID DataRanges -
        pointer to data ranges which is a KSMULTIPLE_ITEM structure followed
        by ((PKSMULTIPLEITEM) DataRanges)->Count data range structures.

Return:

--*/

{
    ULONG               u;
    PKSDATARANGE_AUDIO  AudioRange;
    PKSMULTIPLE_ITEM    MultipleItem;
    
    DbgLog((LOG_TRACE, 0, TEXT("CStandardDataTypeHandler::KsIsMediaTypeInRanges")));
    
    ASSERT( *m_MediaType->Type() == KSDATAFORMAT_TYPE_AUDIO );
    
    MultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(DataRanges);
    
    for (u = 0, 
            AudioRange = reinterpret_cast<PKSDATARANGE_AUDIO>(MultipleItem + 1);
         u < MultipleItem->Count; 
         u++, 
            AudioRange = 
                reinterpret_cast<PKSDATARANGE_AUDIO>(reinterpret_cast<PBYTE>(AudioRange) + 
                    ((AudioRange->DataRange.FormatSize + 7) & ~7))) {
    
        //
        // Only validate those in the range that match the format specifier.
        //
        
        if (((AudioRange->DataRange.FormatSize < sizeof( KSDATARANGE )) ||
            (AudioRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_WILDCARD)) &&
            ((AudioRange->DataRange.FormatSize < sizeof( KSDATARANGE_AUDIO )) ||
            (AudioRange->DataRange.MajorFormat != KSDATAFORMAT_TYPE_AUDIO))) {
            continue;
        }

        //
        // Verify that the correct subformat and specifier are (or wildcards)
        // in the intersection.
        //
        
        if (((AudioRange->DataRange.SubFormat != 
                *m_MediaType->Subtype()) &&
             (AudioRange->DataRange.SubFormat != 
                KSDATAFORMAT_SUBTYPE_WILDCARD)) || 
            ((AudioRange->DataRange.Specifier != 
                *m_MediaType->FormatType()) &&
             (AudioRange->DataRange.Specifier !=
                KSDATAFORMAT_SPECIFIER_WILDCARD))) {
            continue;
        }

        //
        // Verify that we have an intersection with the specified format and 
        // our audio format dictated by our specific requirements.
        //
        
        if (*m_MediaType->FormatType() == 
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX &&
            AudioRange->DataRange.Specifier == 
                KSDATAFORMAT_SPECIFIER_WAVEFORMATEX) {
                
            PWAVEFORMATEX  WaveFormatEx;
            
            //
            // Verify that the data range size is correct
            //   
            
            //
            // 86040: Since were going to use the Format as WAVEFORMATEX, change the sizeof()
            // comparison to use WAVEFORMATEX instead of just WAVEFORMAT
            //
            
            if ((AudioRange->DataRange.FormatSize != sizeof( KSDATARANGE_AUDIO )) || m_MediaType->FormatLength() < sizeof( WAVEFORMATEX )) {
                continue;
            }
            
            WaveFormatEx = reinterpret_cast<PWAVEFORMATEX>(m_MediaType->Format());
            
            if ((WaveFormatEx->nSamplesPerSec < AudioRange->MinimumSampleFrequency) ||
                (WaveFormatEx->nSamplesPerSec > AudioRange->MaximumSampleFrequency) ||
                (WaveFormatEx->wBitsPerSample < AudioRange->MinimumBitsPerSample) ||
                (WaveFormatEx->wBitsPerSample > AudioRange->MaximumBitsPerSample) ||
                (WaveFormatEx->nChannels      > AudioRange->MaximumChannels)) {
                continue;
            }
            
            //
            // We have found a match.
            //
            
            return S_OK;
            
        } else {
        
            //
            // We match on the wildcard.
            //
            
            return S_OK;
        }
    }
    
    return S_FALSE;
}

STDMETHODIMP 
CStandardDataTypeHandler::KsQueryExtendedSize( 
    OUT ULONG* ExtendedSize
)

/*++

Routine Description:
    Returns the extended size for each stream header. 
    
    In the default case for major type == KSDATAFORMAT_TYPE_AUDIO, 
    the extended size is zero.

Arguments:
    OUT ULONG* ExtendedSize -
        pointer to receive the extended size.

Return:
    S_OK

--*/

{
    *ExtendedSize = 0;
    return S_OK;
}
    

STDMETHODIMP 
CStandardDataTypeHandler::KsSetMediaType(
    const AM_MEDIA_TYPE *AmMediaType
    )

/*++

Routine Description:
    Sets the media type for this instance of the data handler.

Arguments:
    const CMediaType *MediaType -
        pointer to the media type

Return:
    S_OK

--*/

{
    if (m_MediaType) {
        return E_FAIL;
    }
    if (m_MediaType = new CMediaType( *AmMediaType )) {
        return S_OK;
    } else {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksproxy\fmtchng.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    fmtchng.cpp

Abstract:

    This module implements the CFormatChangeHandler class which provides
    a private interface handler for in-stream format changes.

Author(s):

    Bryan A. Woodruff (bryanw) 12-May-1997

--*/

#include <windows.h>
#include <streams.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <tchar.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"


CFormatChangeHandler::CFormatChangeHandler(
    IN LPUNKNOWN   UnkOuter,
    IN TCHAR*      Name,
    OUT HRESULT*   hr
    ) :
    CUnknown( Name, UnkOuter, hr )
/*++

Routine Description:

    The constructor for the data handler object. 

Arguments:

    IN LPUNKNOWN UnkOuter -
        Specifies the outer unknown, if any.

    IN TCHAR *Name -
        The name of the object, used for debugging.
        
    OUT HRESULT *hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
} 


STDMETHODIMP
CFormatChangeHandler::NonDelegatingQueryInterface(
    IN REFIID  riid,
    OUT PVOID*  ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsInterfaceHandler.

Arguments:

    IN REFIID riid -
        The identifier of the interface to return.

    OUT PVOID *ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IKsInterfaceHandler)) {
        return GetInterface(static_cast<IKsInterfaceHandler*>(this), ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
CFormatChangeHandler::KsSetPin( 
    IN IKsPin *KsPin 
    )
{
    IKsObject*  Object;
    HRESULT     hr;

    hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&Object));
    if (SUCCEEDED(hr)) {
        m_PinHandle = Object->KsGetObjectHandle();
        Object->Release();
        if (m_PinHandle) {
            m_KsPin = KsPin;
        } else {
            hr = E_UNEXPECTED;
        }
    }
    return hr;
} 


STDMETHODIMP 
CFormatChangeHandler::KsProcessMediaSamples( 
    IN IKsDataTypeHandler *KsDataTypeHandler,
    IN IMediaSample** SampleList, 
    IN OUT PLONG SampleCount, 
    IN KSIOOPERATION IoOperation,
    OUT PKSSTREAM_SEGMENT *StreamSegment
    )
{
    AM_MEDIA_TYPE           *MediaType;
    HRESULT                 hr;
    REFERENCE_TIME          tStart, tStop;
    PKSDATAFORMAT           DataFormat;
    PKSSTREAM_SEGMENT_EX    StreamSegmentEx;
    ULONG                   DataFormatSize, Written;
    DECLARE_KSDEBUG_NAME(EventName);

    //
    // This special interface handler allows no data types and only
    // one data format to be specified in the sample array.
    //

    ASSERT( KsDataTypeHandler == NULL );
    ASSERT( *SampleCount == 1 );
    
    hr = 
        SampleList[ 0 ]->GetMediaType( &MediaType );
       
    if (FAILED( hr )) {
        return hr;
    }
    
    hr = ::InitializeDataFormat(
        static_cast<CMediaType*>(MediaType),
        0,
        reinterpret_cast<void**>(&DataFormat),
        &DataFormatSize);
    DeleteMediaType( MediaType );

    if (FAILED(hr)) {
        return hr;
    }
    
    //
    // Allocate an extended stream segment
    //
        
    *StreamSegment = NULL;
    StreamSegmentEx = new KSSTREAM_SEGMENT_EX;
    if (NULL == StreamSegmentEx) {
        *SampleCount = 0;
        return E_OUTOFMEMORY;
    }
    
    RtlZeroMemory( 
        StreamSegmentEx,
        sizeof( *StreamSegmentEx ) );
    
    //
    // Create the event to be signalled on I/O completion
    //
    BUILD_KSDEBUG_NAME(EventName, _T("EvStreamSegmentEx#%p"), StreamSegmentEx);
    StreamSegmentEx->Common.CompletionEvent = 
        CreateEvent( 
            NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
            TRUE,       // BOOL bManualReset
            FALSE,      // BOOL bInitialState
            KSDEBUG_NAME(EventName) );     // LPCTSTR lpName
    ASSERT(KSDEBUG_UNIQUE_NAME());
            
    if (!StreamSegmentEx->Common.CompletionEvent) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        DbgLog((
            LOG_TRACE,
            0,
            TEXT("CFormatChangeHandler::KsProcessMediaSamples, failed to allocate event: %08x"),
            hr));
        *SampleCount = 0;
        delete StreamSegmentEx;
        return hr;        
    }
    
    AddRef();
    StreamSegmentEx->Common.KsInterfaceHandler = static_cast<IKsInterfaceHandler*>(this);
    StreamSegmentEx->Common.IoOperation = IoOperation;
    
    //
    // Initialize the stream header.
    //
    
    StreamSegmentEx->StreamHeader.OptionsFlags =
        KSSTREAM_HEADER_OPTIONSF_TYPECHANGED;
        
    StreamSegmentEx->StreamHeader.Size = sizeof(KSSTREAM_HEADER);
    StreamSegmentEx->StreamHeader.TypeSpecificFlags = 0;
    if (S_OK == SampleList[ 0 ]->GetTime( &tStart, &tStop )) {
        StreamSegmentEx->StreamHeader.OptionsFlags |=
            KSSTREAM_HEADER_OPTIONSF_TIMEVALID |
            KSSTREAM_HEADER_OPTIONSF_DURATIONVALID;

        StreamSegmentEx->StreamHeader.PresentationTime.Time = tStart;
        StreamSegmentEx->StreamHeader.PresentationTime.Numerator = 1;
        StreamSegmentEx->StreamHeader.PresentationTime.Denominator = 1;
        StreamSegmentEx->StreamHeader.Duration = tStop - tStart;
    }
        
    StreamSegmentEx->StreamHeader.Data = DataFormat;
    StreamSegmentEx->StreamHeader.FrameExtent = DataFormatSize;
    StreamSegmentEx->StreamHeader.DataUsed = DataFormatSize;
    StreamSegmentEx->Sample = SampleList[ 0 ];
    StreamSegmentEx->Sample->AddRef();
    
    //
    // Write the stream header to the device and return.
    //
    
    StreamSegmentEx->Overlapped.hEvent = 
        StreamSegmentEx->Common.CompletionEvent;
    m_KsPin->KsIncrementPendingIoCount();
    
    
    if (!DeviceIoControl( 
            m_PinHandle,
            IOCTL_KS_WRITE_STREAM,
            NULL,
            0,
            &StreamSegmentEx->StreamHeader,
            sizeof( KSSTREAM_HEADER ),
            &Written,
            &StreamSegmentEx->Overlapped )) {
        DWORD   LastError;

        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        //
        // On a failure case signal the event, but do not decrement the
        // pending I/O count, since this is done in the completion
        // routine already.
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            hr = S_OK;
        } else {
            SetEvent( StreamSegmentEx->Overlapped.hEvent );
        }
    } else {
        //
        // Completed synchronously -- signal the event so that I/O processing 
        // will continue.  Note that the event is not signalled via 
        // DeviceIoControl() in this case.
        //
        
        SetEvent( StreamSegmentEx->Overlapped.hEvent );
        hr = S_OK;
    }
    
    *StreamSegment = reinterpret_cast<PKSSTREAM_SEGMENT>(StreamSegmentEx);
    
    return hr;
}


STDMETHODIMP
CFormatChangeHandler::KsCompleteIo(
    IN PKSSTREAM_SEGMENT StreamSegment
    )
{
    PKSSTREAM_SEGMENT_EX    StreamSegmentEx;
    
    //
    // Clean up extended headers and release media samples.
    //
    
    StreamSegmentEx = reinterpret_cast<PKSSTREAM_SEGMENT_EX>(StreamSegment);
    
    //
    // According to the base class documentation, the receiving pin
    // will AddRef() the sample if it keeps it so it is safe to release
    // the sample for read or write operations.
    // 
    
    StreamSegmentEx->Sample->Release();
    CoTaskMemFree(StreamSegmentEx->StreamHeader.Data);
    delete StreamSegmentEx;
    
    //
    // No need to call KsMediaSamplesCompleted() here.
    //
    m_KsPin->KsDecrementPendingIoCount();
    Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksproxy\ksalloc.cpp ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksalloc.cpp

Abstract:

    Memory allocator proxy

Author:

    Bryan A. Woodruff (bryanw) 14-Apr-1997

--*/

            
#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"

            
CKsAllocator::CKsAllocator(
    TCHAR* ObjectName,
    IUnknown *UnknownOuter,
    IPin *Pin,
    HANDLE FilterHandle,
    HRESULT *hr) :
        CMemAllocator( 
            ObjectName,
            UnknownOuter,
            hr 
            ),
        m_AllocatorHandle( NULL ),
        m_AllocatorMode( KsAllocatorMode_Kernel ),
        m_FilterHandle( NULL ),
        m_OwnerPin( NULL )

{
    
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::CKsAllocator()")));
}    
    
CKsAllocator::~CKsAllocator()
{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::~CKsAllocator()")));

    if (m_AllocatorHandle) {
        CloseHandle( m_AllocatorHandle );
    }
}

STDMETHODIMP 
CKsAllocator::QueryInterface(
    REFIID riid, 
    PVOID* ppv)
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    return GetOwner()->QueryInterface(riid, ppv);
}

STDMETHODIMP_(ULONG) 
CKsAllocator::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG) 
CKsAllocator::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    return GetOwner()->Release();
}



STDMETHODIMP 
CKsAllocator::NonDelegatingQueryInterface(
    REFIID riid, 
    void **ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object or supported by the
    base object.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(IKsAllocator) || riid == __uuidof(IKsAllocatorEx)) {
        return GetInterface( static_cast<IKsAllocatorEx*>(this), ppv );
    }
    return CMemAllocator::NonDelegatingQueryInterface( riid, ppv );
}



STDMETHODIMP_( VOID )
CKsAllocator::KsSetAllocatorHandle(
    HANDLE AllocatorHandle 
    )
{
    m_AllocatorHandle = AllocatorHandle;
}



STDMETHODIMP_(HANDLE)
CKsAllocator::KsCreateAllocatorAndGetHandle(
    IKsPin*   KsPin
)

{
    HANDLE               PinHandle;
    KSALLOCATOR_FRAMING  Framing;
    HRESULT              hr;
    IKsPinPipe*          KsPinPipe = NULL;
   
   
    if (m_AllocatorHandle) {
        CloseHandle( m_AllocatorHandle );
        m_AllocatorHandle = NULL;
    }
   
    PinHandle = ::GetObjectHandle( KsPin );
    if (! PinHandle) {
        return ((HANDLE) NULL);
    }
   
    hr = KsPin->QueryInterface( __uuidof(IKsPinPipe), reinterpret_cast<PVOID*>(&KsPinPipe) );
    if (! SUCCEEDED( hr )) {
        ASSERT(0);
        return ((HANDLE) NULL);
    }
   
    Framing.OptionsFlags = KSALLOCATOR_OPTIONF_SYSTEM_MEMORY;
    Framing.Frames = m_AllocatorPropertiesEx.cBuffers;
    Framing.FrameSize = m_AllocatorPropertiesEx.cbBuffer;
    Framing.FileAlignment = (ULONG) (m_AllocatorPropertiesEx.cbAlign - 1);
   
    if (m_AllocatorPropertiesEx.LogicalMemoryType == KS_MemoryTypeKernelPaged) {
        Framing.PoolType = PagedPool;
    }
    else {
        Framing.PoolType = NonPagedPool;
    }
   
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("PIPES ATTN CKsAllocator::KsGetAllocatorAndGetHandle, creating allocator %s(%s) %x %d %d %d %x"),
        KsPinPipe->KsGetFilterName(),
        KsPinPipe->KsGetPinName(),
        KsPin,
        Framing.Frames, Framing.FrameSize, Framing.FileAlignment, Framing.OptionsFlags));
    
    
    //
    // Returns an error code if unsuccessful.
    //    
        
    if (ERROR_SUCCESS !=
        KsCreateAllocator( 
            PinHandle, 
            &Framing,
            &m_AllocatorHandle )) {
   
        DWORD   LastError;
   
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32( LastError );
        m_AllocatorHandle = NULL;
        
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("PIPES ATTN CKsAllocator, KsCreateAllocator() failed: %08x"), hr));
    }
    
    if (KsPinPipe) {
       KsPinPipe->Release();
    }
   
    return m_AllocatorHandle;

}






STDMETHODIMP_(HANDLE)
CKsAllocator::KsGetAllocatorHandle()
{
    return m_AllocatorHandle;
}

STDMETHODIMP_( KSALLOCATORMODE )
CKsAllocator::KsGetAllocatorMode(
    VOID
    )
{
    return m_AllocatorMode;
}

STDMETHODIMP 
CKsAllocator::KsGetAllocatorStatus(
    PKSSTREAMALLOCATOR_STATUS AllocatorStatus 
    )
{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::KsGetAllocatorStatus")));
    return S_OK;
}    

STDMETHODIMP_( VOID )
CKsAllocator::KsSetAllocatorMode(
    KSALLOCATORMODE Mode
    )
{
    m_AllocatorMode = Mode;

    DbgLog((
        LOG_MEMORY,
        2,
        TEXT("CKsAllocator::KsSetAllocatorMode = %s"),
        (m_AllocatorMode == KsAllocatorMode_Kernel) ? TEXT("Kernel") : TEXT("User") ));
}    

STDMETHODIMP
CKsAllocator::Commit()
    
/*++

Routine Description:


Arguments:
    None.

Return:

--*/

{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::Commit")));

    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::Commit, kernel-mode allocator")));
        return S_OK;
    } else {
        return CMemAllocator::Commit();
    }
}

STDMETHODIMP 
CKsAllocator::Decommit(
    void
    )

/*++

Routine Description:


Arguments:
    None.

Return:

--*/

{
    DbgLog((
        LOG_MEMORY, 
        2, 
        TEXT("CKsAllocator::Decommit")));
        
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::Decommit, kernel-mode allocator")));
        return S_OK;
    } else {
        return CMemAllocator::Decommit();
    }
}

#if DBG || defined(DEBUG)
STDMETHODIMP 
CKsAllocator::GetBuffer(
    IMediaSample **Sample,
    REFERENCE_TIME * StartTime,
    REFERENCE_TIME * EndTime,
    DWORD Flags)

/*++

Routine Description:


Arguments:
    IMediaSample **Sample -

    REFERENCE_TIME * StartTime -

    REFERENCE_TIME * EndTime -

    DWORD Flags -

Return:

--*/

{
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::GetBuffer, kernel-mode allocator -- failing")));
        return E_FAIL;
    } else {
        return CMemAllocator::GetBuffer( Sample, StartTime, EndTime, Flags );
    }
}
    
STDMETHODIMP 
CKsAllocator::ReleaseBuffer(
    IMediaSample *Sample
    )

/*++

Routine Description:


Arguments:
    IMediaSample *Sample -

Return:

--*/

{
    if (m_AllocatorMode == KsAllocatorMode_Kernel) {
        DbgLog((
            LOG_MEMORY, 
            2, 
            TEXT("CKsAllocator::ReleaseBuffer, kernel-mode allocator -- failing")));
        return E_FAIL;
    } else {
        return CMemAllocator::ReleaseBuffer( Sample );
    }
}
#endif // DBG || defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksolay\ksolay.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksolay.cpp

Abstract:

    Provides a Property set interface handler for IOverlay and IOverlayNotify2.

--*/

#include <windows.h>
#include <tchar.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksolay.h"

#define WM_NEWCOLORREF (WM_USER)

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = 
{
    {L"OverlayPropSet", &KSPROPSETID_OverlayUpdate, COverlay::CreateInstance}
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


#ifdef __IOverlayNotify2_FWD_DEFINED__
//
// Defined by the standard DLL loading code in the base classes.
//
extern HINSTANCE g_hInst;

static const TCHAR PaintWindowClass[] = TEXT("KSOverlayPaintWindowClass");
#endif


CUnknown*
CALLBACK
COverlay::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of an IOverlay
    Property Set handler. It is referred to in the g_Templates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown *Unknown;

    Unknown = new COverlay(UnkOuter, NAME("OverlayPropSet"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
} 


COverlay::COverlay(
    LPUNKNOWN UnkOuter,
    TCHAR* Name,
    HRESULT* hr
    ) :
    CUnknown(Name, NULL),
    m_Object(NULL),
    m_Overlay(NULL),
    m_UnkOwner(UnkOuter)
/*++

Routine Description:

    The constructor for the Overlay Property Set objects. Does base class
    initialization for the Overlay interface objects.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // This object does not use the UnkOuter because it exposes no interfaces
    // which would ever be obtained by a client (IDistributorNotify is only
    // queried by the proxy, and used internally). Also, since Advise references
    // the given object, circular referencing would occur. So this separate
    // object allows the referencing/dereferencing to occur without having to
    // do increment/decrements on the refcount when using Advise/Unadvise.
    //
    // The parent must support the IKsObject interface in order to obtain
    // the handle to communicate to.
    //
    ASSERT(UnkOuter);
    //
    // This just does the normal initialization as if the pin were being
    // reconnected.
    //
    *hr = NotifyGraphChange();
}


COverlay::~COverlay(
    )
/*++

Routine Description:

    The desstructor for the Overlay Property Set object. Ensures that all
    the advise requests have been terminated.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    if (m_Overlay) {
        m_Overlay->Unadvise();
    }
}


STDMETHODIMP
COverlay::NonDelegatingQueryInterface(
    REFIID riid,
    PVOID* ppv
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The module does not actually
    support any interfaces from the point of view of the filter user, only
    from the point of view of the overlay notification source.

Arguments:

    riid -
        The identifier of the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (riid == __uuidof(IDistributorNotify)) {
        //
        // The IDistributorNotify interface will be queried by the proxy
        // in order to send graph change notifications. It will not hold
        // onto a reference count for the interface.
        //
        return GetInterface(static_cast<IDistributorNotify*>(this), ppv);
#ifdef __IOverlayNotify2_FWD_DEFINED__
    } else if (riid == __uuidof(IOverlayNotify2)) {
        //
        // The IOverlayNotify2 interface will be queried by the overlay
        // notification source if the driver sets the ADVISE_DISPLAY_CHANGE
        // notification bit.
        //
        return GetInterface(static_cast<IOverlayNotify2*>(this), ppv);
#endif // __IOverlayNotify2_FWD_DEFINED__
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
} 


STDMETHODIMP
COverlay::Stop(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Stop method. The forwarder
    does not need to do anything on this notification.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::Pause(
     )
/*++

Routine Description:

    Implements the IDistributorNotify::Pause method. The forwarder
    does not need to do anything on this notification.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::Run(
    REFERENCE_TIME  Start
    )
/*++

Routine Description:

    Implements the IDistributorNotify::Run method. The forwarder
    does not need to do anything on this notification.

Arguments:

    Start -
        The reference time at which the state change should occur.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::SetSyncSource(
    IReferenceClock*    RefClock
    )
/*++

Routine Description:

    Implements the IDistributorNotify::SetSyncSource method. The forwarder
    does not need to do anything on this notification.

Arguments:

    RefClock -
        The interface pointer on the new clock source, else NULL if any current
        clock source is being abandoned.

Return Value:

    Returns S_OK.

--*/
{
    return S_OK;
}


STDMETHODIMP
COverlay::NotifyGraphChange(
    )
/*++

Routine Description:

    Implements the IDistributorNotify::NotifyGraphChange method. This
    is called when the pin is being connected or disconnected subsequent
    to the initial loading of this instance.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    IKsObject*  PinObject;
    HRESULT     hr;

    //
    // Since this pin has been disconnected, any Advise which has been
    // set up must be removed. There may not be an Advise, because this
    // might have been called from the constructor, or initial setup
    // may have failed.
    //
    if (m_Overlay) {
        m_Overlay->Unadvise();
        //
        // Ensure that on subsequent failure an Unadvise will not be
        // performed on this object during the destructor.
        //
        m_Overlay = NULL;
    }
    hr = m_UnkOwner->QueryInterface(__uuidof(PinObject), reinterpret_cast<PVOID*>(&PinObject));
    if (SUCCEEDED(hr)) {
        //
        // If this is a new connection of the pin, then there will be an object
        // handle, else this will return NULL.
        //
        m_Object = PinObject->KsGetObjectHandle();
        //
        // Do not leave reference counts so that the filter can be destroyed.
        //
        PinObject->Release();
        //
        // If this is a connection, then set up Advise.
        //
        if (m_Object) {
            KSPROPERTY  Property;
            ULONG       BytesReturned;
            ULONG       Interests;

            //
            // Retrieve the interests for this device. These will determine
            // which notification occur. These flags map directly to the
            // DirectShow Overlay Interests flags.
            //
            Property.Set = KSPROPSETID_OverlayUpdate;
            Property.Id = KSPROPERTY_OVERLAYUPDATE_INTERESTS;
            Property.Flags = KSPROPERTY_TYPE_GET;
            hr = ::KsSynchronousDeviceControl(
                m_Object,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &Interests,
                sizeof(Interests),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                IPin*   Pin;

                hr = m_UnkOwner->QueryInterface(
                    __uuidof(Pin),
                    reinterpret_cast<PVOID*>(&Pin));
                if (SUCCEEDED(hr)) {
                    IPin*   ConnectedPin;

                    //
                    // The connected pin is the one which will support the
                    // IOverlay interface on which the Advise should be
                    // started.
                    //
                    hr = Pin->ConnectedTo(&ConnectedPin);
                    if (SUCCEEDED(hr)) {
                        hr = ConnectedPin->QueryInterface(
                            __uuidof(m_Overlay),
                            reinterpret_cast<PVOID*>(&m_Overlay));
                        if (SUCCEEDED(hr)) {
#ifndef __IOverlayNotify2_FWD_DEFINED__
                            Interests &= ADVISE_ALL;
#endif // !__IOverlayNotify2_FWD_DEFINED__
                            //
                            // The interests returned by the driver are just
                            // the properties which will be later accessed,
                            // and map directly to Advise constants.
                            //
                            hr = m_Overlay->Advise(
#ifdef __IOverlayNotify2_FWD_DEFINED__
                                static_cast<IOverlayNotify*>(static_cast<IOverlayNotify2*>(this)),
#else // !__IOverlayNotify2_FWD_DEFINED__
                                this,
#endif //!__IOverlayNotify2_FWD_DEFINED__
                                Interests);

                            //
                            // This can be released because this current object
                            // is deleted when the pin is being deleted.
                            // So the interface is actually always valid as long
                            // as this object is around. This avoids circular
                            // referencing, while still allowing Unadvise to occur.
                            //
                            m_Overlay->Release();
                            //
                            // Ensure that an Unadvise is not performed in the
                            // destructor, since this Advise failed.
                            //
                            if (FAILED(hr)) {
                                m_Overlay = NULL;
                            }
                        }
                        ConnectedPin->Release();
                    }
                    Pin->Release();
                }
            }
        } else {
            hr = VFW_E_NOT_CONNECTED;
        }
    }
    return hr;
}


STDMETHODIMP
COverlay::OnPaletteChange( 
    DWORD Colors,
    const PALETTEENTRY* Palette
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnPaletteChange method.

Arguments:

    Colors -
        The number of colors in the Palette parameter.

    Palette -
        The new palette entries

Return Value:

    Returns NOERROR if the new palette was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_PALETTE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        const_cast<PALETTEENTRY*>(Palette),
        Colors * sizeof(*Palette),
        &BytesReturned);
}


STDMETHODIMP
COverlay::OnClipChange( 
    const RECT* Source,
    const RECT* Destination,
    const RGNDATA* Region
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnClipChange method.

Arguments:

    Source -
        The new source rectangle.

    Destination -
        The new destination rectangle.

    Region -
        The new clipping region.

Return Value:

    Returns NOERROR if the new clipping was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;
    PBYTE       Data;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_CLIPLIST;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // The serialized format contains:
    //     Source
    //     Destination
    //     Region
    //
    Data = new BYTE[sizeof(*Source) + sizeof(*Destination) + Region->rdh.dwSize];
    if (!Data) {
        return E_OUTOFMEMORY;
    }
    //
    // This needs to be copied to a temporary buffer first,
    // because the source and destination rectangles must
    // be serialized.
    //
    *reinterpret_cast<RECT*>(Data) = *Source;
    *(reinterpret_cast<RECT*>(Data) + 1) = *Destination;
    memcpy(Data + sizeof(*Source) + sizeof(*Destination), Region, Region->rdh.dwSize);
    hr = ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Data,
        sizeof(*Source) + sizeof(*Destination) + Region->rdh.dwSize,
        &BytesReturned);
    delete [] Data;
    return hr;
}


STDMETHODIMP
COverlay::OnColorKeyChange( 
    const COLORKEY* ColorKey
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnColorKeyChange method.

Arguments:

    ColorKey -
        The new color key.

Return Value:

    Returns NOERROR if the new color key was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_COLORKEY;
    Property.Flags = KSPROPERTY_TYPE_SET;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        const_cast<COLORKEY*>(ColorKey),
        sizeof(*ColorKey),
        &BytesReturned);
}


STDMETHODIMP
COverlay::OnPositionChange( 
    const RECT* Source,
    const RECT* Destination
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnPositionChange method.

Arguments:

    Source -
        The new source rectangle.

    Destination -
        The new destination rectangle.

Return Value:

    Returns NOERROR if the new position was applied.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    RECT        Rects[2];

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // These rectangles must be serialized as follows:
    //
    Rects[0] = *Source;
    Rects[1] = *Destination;
    return ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Rects,
        sizeof(Rects),
        &BytesReturned);
}

#ifdef __IOverlayNotify2_FWD_DEFINED__

STDMETHODIMP
COverlay::OnDisplayChange( 
    HMONITOR Monitor
    )
/*++

Routine Description:

    Implement the IOverlayNotify2::OnDisplayChange method. This is called
    on a WM_DISPLAYCHANGE notification.

Arguments:

    Monitor -
        Contains the handle of the monitor on which overlay is occuring.

Return Value:

    Returns NOERROR.

--*/
{
    KSPROPERTY          Property;
    ULONG               BytesReturned;
    HRESULT             hr;
    MONITORINFOEX       MonitorInfo;
    DEVMODE             DevMode;
    DISPLAY_DEVICE      DisplayDevice;
    PKSDISPLAYCHANGE    DisplayChange;
    BYTE                DisplayBuffer[sizeof(*DisplayChange)+sizeof(DisplayDevice.DeviceID)/sizeof(TCHAR)*sizeof(WCHAR)];

    if (!m_Object) {
        return VFW_E_NOT_CONNECTED;
    }
    Property.Set = KSPROPSETID_OverlayUpdate;
    Property.Id = KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // Determine name of the monitor so that the display settings
    // and device information can be retrieved.
    //
    MonitorInfo.cbSize = sizeof(MonitorInfo);
    if (!GetMonitorInfo(Monitor, &MonitorInfo)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Retrieve the x, y, and bit depth of this display.
    //
    DevMode.dmSize = sizeof(DevMode);
    DevMode.dmDriverExtra = 0;
    if (!EnumDisplaySettings(MonitorInfo.szDevice, ENUM_CURRENT_SETTINGS, &DevMode)) {
        return HRESULT_FROM_WIN32(GetLastError());
    }
    //
    // Look for the display given the original name. The structure
    // will have the unique device identifier in it which can then
    // be used by the driver.
    //
    for (ULONG Device = 0;; Device++) {
        DisplayDevice.cb = sizeof(DisplayDevice);
        //
        // If the display device could not be found, or an error occurs,
        // just exit with the error.
        //
        if (!EnumDisplayDevices(NULL, Device, &DisplayDevice, 0)) {
            return HRESULT_FROM_WIN32(GetLastError());
        }
        //
        // Determine if this is the same device which was retrieved
        // from the monitor information.
        //
        if (!_tcscmp(DisplayDevice.DeviceName, MonitorInfo.szDevice)) {
            break;
        }
    }
    //
    // Initialize the display change structure to be passed in the
    // notification.
    //
    DisplayChange = reinterpret_cast<PKSDISPLAYCHANGE>(DisplayBuffer);
    DisplayChange->PelsWidth = DevMode.dmPelsWidth;
    DisplayChange->PelsHeight = DevMode.dmPelsHeight;
    DisplayChange->BitsPerPel = DevMode.dmBitsPerPel;
    //
    // Retrieve the number of characters in the string, including
    // the terminating NULL, in order to pass on the notification
    // property correctly.
    //
#ifdef _UNICODE
    Device = _tcslen(DisplayDevice.DeviceID);
    _tcscpy(DisplayChange->DeviceID, DisplayDevice.DeviceID);
#else //! _UNICODE
    //
    // Remove the size of the NULL terminator, which is already
    // included in the size of the DisplayChange structure.
    //
    Device = MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        DisplayDevice.DeviceID,
        -1,
        DisplayChange->DeviceID,
        sizeof(DisplayDevice.DeviceID) * sizeof(WCHAR)) - 1;
#endif //! _UNICODE
    hr = ::KsSynchronousDeviceControl(
        m_Object,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DisplayChange,
        sizeof(*DisplayChange) + Device * sizeof(WCHAR),
        &BytesReturned);
    //
    // If the driver has not dealt with this resolution before,
    // then it will complain, stating that it has more data to
    // present to the client. The list of colors which it wants
    // to paint will then be queried.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        HWND    PaintWindow;

        //
        // Create a full screen window to paint on so that hardware
        // can calibrate.
        //
        PaintWindow = CreateFullScreenWindow(&MonitorInfo.rcMonitor);
        if (PaintWindow) {
            Property.Id = KSPROPERTY_OVERLAYUPDATE_COLORREF;
            Property.Flags = KSPROPERTY_TYPE_GET;
            for (;;) {
                COLORREF    ColorRef;

                //
                // Request a color to paint with. If this is not
                // the initial request, then the driver can probe
                // its hardware based on the previous color retrieved.
                //
                hr = ::KsSynchronousDeviceControl(
                    m_Object,
                    IOCTL_KS_PROPERTY,
                    &Property,
                    sizeof(Property),
                    &ColorRef,
                    sizeof(ColorRef),
                    &BytesReturned);
                //
                // If another color was retrieved, paint with it.
                //
                if (SUCCEEDED(hr)) {
                    SendMessage(PaintWindow, WM_NEWCOLORREF, 0, ColorRef);
                } else {
                    //
                    // If the end of the list of colors was reached,
                    // just return success.
                    //
                    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
                        hr = NOERROR;
                    }
                    break;
                }
            }
            DestroyWindow(PaintWindow);
            UnregisterClass(PaintWindowClass, g_hInst);
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}


STDMETHODIMP_(HWND)
COverlay::CreateFullScreenWindow( 
    PRECT MonitorRect
    )
/*++

Routine Description:

    Implement the COverlay::CreateFullScreenWindow method. This is called
    to create a full screen window in order to allow painting with various
    colors to probe hardware.

Arguments:

    MonitorRect -
        The absolute location of monitor.

Return Value:

    Returns the handle of the window created, else NULL.

--*/
{
    WNDCLASSEX  WindowClass;
    HWND        PaintWindow;

    WindowClass.cbSize = sizeof(WindowClass);
    WindowClass.style = CS_HREDRAW | CS_VREDRAW;
    WindowClass.lpfnWndProc = PaintWindowCallback;
    WindowClass.cbClsExtra = 0;
    WindowClass.cbWndExtra = 0;
    WindowClass.hInstance = g_hInst;
    WindowClass.hIcon = NULL;
    WindowClass.hCursor = NULL;
    WindowClass.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_APPWORKSPACE + 1);
    WindowClass.lpszMenuName = NULL;
    WindowClass.lpszClassName = PaintWindowClass;
    WindowClass.hIconSm = NULL;
    if (!RegisterClassEx(&WindowClass)) {
        return NULL;
    }
    //
    // Create a window which covers the entire monitor on which
    // overlay is occuring.
    //
    PaintWindow = CreateWindowEx(
        WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
        PaintWindowClass,
        NULL,
        WS_POPUP | WS_VISIBLE,
        MonitorRect->left,
        MonitorRect->top,
        MonitorRect->right - MonitorRect->left,
        MonitorRect->bottom - MonitorRect->top,
        NULL,
        NULL,
        g_hInst,
        NULL);
    if (!PaintWindow) {
        UnregisterClass(PaintWindowClass, g_hInst);
    }
    return PaintWindow;
}


LRESULT
CALLBACK
COverlay::PaintWindowCallback(
    HWND Window,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    Implement the COverlay::PaintWindowCallback method. This is called
    in response to a message being sent to the window. This implements
    the full screen paint window, which is used to paint specified colors
    to a window for hardware probing.

Arguments:

    Window -
        The handle of the window.

    Message -
        The window message to process.

    wParam -
        Depends on the message.

    lParam -
        Depends on the message.

Return Value:

    Depends on the message.

--*/
{
    switch (Message) {
    case WM_CREATE:
        //
        // The cursor must be hidden so that it does no interfere with the
        // analog signal and provides a pure signal of the color the window
        // is supposed to represent.
        //
        ShowCursor(FALSE);
        break;
    case WM_DESTROY:
        ShowCursor(TRUE);
        break;
    case WM_PAINT:
        PAINTSTRUCT ps;

        BeginPaint(Window, &ps);
        EndPaint(Window, &ps);
        return (LRESULT)1;
    case WM_NEWCOLORREF:
        RECT        ClientRect;
        HDC         hdc;

        //
        // A new background color is specified in the lParam. This
        // should be used in painting the entire window.
        //
        GetClientRect(Window, &ClientRect);
        hdc = GetDC(Window);
        SetBkColor(hdc, *reinterpret_cast<COLORREF*>(&lParam));
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &ClientRect, NULL, 0, NULL);
        ReleaseDC(Window, hdc);
        return 0;
    }
    return DefWindowProc(Window, Message, wParam, lParam);
}
#endif //__IOverlayNotify2_FWD_DEFINED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksproxy\ksiproxy.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksiproxy.h

Abstract:

    Internal header.
    
Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw) 

--*/

#if !defined(_KSIPROXY_)
#define _KSIPROXY_

//
// This is used for adding unique names to event and semaphores 
// in checked builds.
//
#ifdef DEBUG
    #define KSDEBUG_NAME_LENGTH      64
    #define DECLARE_KSDEBUG_NAME(x)  TCHAR x[KSDEBUG_NAME_LENGTH]
    #define BUILD_KSDEBUG_NAME(buff, fmt, id) \
                _sntprintf(buff, KSDEBUG_NAME_LENGTH, (fmt _T("p%08lx")), (id), (ULONG)GetCurrentProcessId()); \
                buff[KSDEBUG_NAME_LENGTH - 1] = 0
    #define BUILD_KSDEBUG_NAME2(buff, fmt, id1, id2) \
                _sntprintf(buff, KSDEBUG_NAME_LENGTH, (fmt _T("p%08lx")), (id1), (id2), (ULONG)GetCurrentProcessId()); \
                buff[KSDEBUG_NAME_LENGTH - 1] = 0
    #define KSDEBUG_NAME(str)        (str)
    #define KSDEBUG_UNIQUE_NAME()    (GetLastError() != ERROR_ALREADY_EXISTS)
#else
    #define DECLARE_KSDEBUG_NAME(x)
    #define BUILD_KSDEBUG_NAME(buff, fmt, id)
    #define BUILD_KSDEBUG_NAME2(buff, fmt, id1, id2)
    #define KSDEBUG_NAME(str)        NULL
    #define KSDEBUG_UNIQUE_NAME()    TRUE
#endif

//
// This is used for formatting strings which contain guids returned
// from OLE functions, which are always Unicode. If the module is
// not being compiled for Unicode, then the format string must
// indicate the guid is Unicode.
//
#ifdef _UNICODE
#define GUID_FORMAT L"%s"
#else
#define GUID_FORMAT "%S"
#endif

#define SAFERELEASE( pInterface )   { if (NULL != (pInterface)) { IUnknown *pTemp = (pInterface); (pInterface) = NULL; pTemp->Release(); } }

//
// Taken from wdm.h POOL_TYPE.
// Won't compile with entire wdm.h included.
//
typedef enum _KSPOOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType
} KSPOOL_TYPE;


#define DEFAULT_STEPPING         1
#define ALLOC_DEFAULT_PREFIX     0
#define KS_PINWEIGHT_DEFAULT     0
#define KS_MEMORYWEIGHT_DEFAULT  0

//
// GLOBAL 
//
#ifndef GLOBAL_KSIPROXY
extern
#endif
struct {
    ULONG    CodePath;
    long     DefaultNumberBuffers;
    long     DefaultBufferSize;
    long     DefaultBufferAlignment;
} Global;

//
// Internal structures for pipes.
//
typedef enum {
    Pin_First, 
    Pin_Last, 
    Pin_Terminal, 
    Pin_All,   
    Pin_Input,   
    Pin_Output,
    Pin_MultipleOutput,
    Pin_SingleOutput,
    Pin_User,
    Pin_Inside_Pipe,
    Pin_Outside_Pipe,
    Pin_None
} PIN_TYPES_INTERNAL;


#define Pin_Test     0x00000000
#define Pin_Add      0x00000001
#define Pin_Remove   0x00000002
#define Pin_Move     0x00000004


typedef enum {
    NONE_OBJECT_DIFFERENT,
    OUT_OBJECT_DIFFERENT,
    IN_OBJECT_DIFFERENT,
    BOTH_OBJECT_DIFFERENT,
    NO_INTERSECTION
} KS_OBJECTS_INTERSECTION;

typedef KS_OBJECTS_INTERSECTION  *PKS_OBJECTS_INTERSECTION;


//
// framing change flags
//
#define  KS_FramingChangeMemoryType      0x00000001
#define  KS_FramingChangeAllocator       0x00000002
#define  KS_FramingChangeCompression     0x00000004
#define  KS_FramingChangePhysicalRange   0x00000008
#define  KS_FramingChangeOptimalRange    0x00000010
#define  KS_FramingChangePrty            0x00000020


//
// search flags in pin framing
//
#define  KS_SearchByLogicalMemoryType    0x00000001
#define  KS_SearchByMemoryType           0x00000002


//
// framing with fixed memory, bus and range.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       PinFlags;
    ULONG                       PinWeight;          // this pin framing's weight graph-wide
    ULONG                       CountItems;
    ULONG                       MemoryFlags;
    KS_LogicalMemoryType        LogicalMemoryType;
    ULONG                       BusFlags;   
    ULONG                       Flags;
    ULONG                       Frames;             // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    KS_FRAMING_RANGE            PhysicalRange;
    KS_COMPRESSION              OutputCompression;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange; 
    ULONG                       MemoryTypeWeight;   // this memory type weight pin-wide
} KS_FRAMING_FIXED, *PKS_FRAMING_FIXED;


//
// Connection table for pipes, based on logical memory types.
//
typedef struct {
    ULONG    NumPipes;
    ULONG    Code;
} CONNECTION_TABLE_ENTRY;


#define ConnectionTableDimension   7    // Needs to match the number of values enumerated in KS_LogicalMemoryType
#define ConnectionTableMaxEntries  6

typedef enum {
    KS_DIRECTION_UPSTREAM,
    KS_DIRECTION_DOWNSTREAM,
    KS_DIRECTION_ALL,
    KS_DIRECTION_DEFAULT
} KS_DIRECTION;


//
// Macros for QueryInterface 
//
#define GetInterfacePointerNoLockWithAssert(KnownPointer, InterfaceGuid, ReturnPointer, ReturnHResult)\
{\
    ReturnHResult = KnownPointer->QueryInterface(InterfaceGuid, reinterpret_cast<PVOID*>(&ReturnPointer));\
    if ( ! SUCCEEDED( ReturnHResult ) ) {\
        ASSERT(0);\
        ReturnPointer = NULL;\
    }\
    else {\
        ReturnPointer->Release();\
    }\
}


typedef BOOL
(STDMETHODCALLTYPE *PWALK_PIPE_CALLBACK)(
    IKsPin*     KsPin,
    ULONG       PinType,
    PVOID*      Param1,
    PVOID*      Param2,
    BOOL       *IsDone
    );

typedef struct {
    GUID        MemoryType;
    IKsPin*     KsPin;
    ULONG       PinType;
    ULONG       IsMustAllocator;
    ULONG       NumberMustAllocators;
    BOOL        FlagAssign;
} ALLOCATOR_SEARCH;

typedef struct {
    GUID                        MemoryType;
    PIPE_DIMENSIONS             Dimensions;
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange;
    ULONG                       Frames;
    ULONG                       Flags;
    long                        cbAlign;
} DIMENSIONS_DATA;

//
// Attributes interface attached to Media Types
//
interface __declspec(uuid("D559999A-A4C3-11D2-876A-00A0C9223196")) IMediaTypeAttributes;
interface IMediaTypeAttributes : public IUnknown {
    virtual STDMETHODIMP GetMediaAttributes(
        OUT PKSMULTIPLE_ITEM* Attributes
        ) = 0;
    virtual STDMETHODIMP SetMediaAttributes(
        IN PKSMULTIPLE_ITEM Attributes OPTIONAL
        ) = 0;
};

typedef struct _ITEM_LIST_ITEM {
    struct _ITEM_LIST_ITEM *fLink;
    struct _ITEM_LIST_ITEM *bLink;
} ITEM_LIST_ITEM, *PITEM_LIST_ITEM;

typedef struct _ITEM_LIST_HEAD {
    ITEM_LIST_ITEM  head;
    ITEM_LIST_ITEM  tail;
    DWORD           count;
    HANDLE          mutex;
} ITEM_LIST_HEAD, *PITEM_LIST_HEAD;

DWORD   ItemListInitialize( PITEM_LIST_HEAD pHead );
VOID    ItemListCleanup( PITEM_LIST_HEAD pHead );
VOID    ItemListAppendItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pNewItem );
DWORD   ItemListGetCount( PITEM_LIST_HEAD pHead );
VOID    ItemListInsertItemAfter( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem );
VOID    ItemListInsertItemBefore( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pOldItem, PITEM_LIST_ITEM pNewItem );
PITEM_LIST_ITEM ItemListRemoveItem( PITEM_LIST_HEAD pHead, PITEM_LIST_ITEM pItem );
PITEM_LIST_ITEM ItemListGetFirstItem( PITEM_LIST_HEAD pHead );
PITEM_LIST_ITEM ItemListGetLastItem( PITEM_LIST_HEAD pHead );

typedef enum {
    EVENT_SIGNALLED = 0,
    EVENT_CANCELLED
} ASYNC_ITEM_STATUS;

typedef VOID (*PASYNC_ITEM_ROUTINE)( ASYNC_ITEM_STATUS status, struct _ASYNC_ITEM *pItem );

typedef struct _ASYNC_ITEM {
    ITEM_LIST_ITEM      link;
    BOOLEAN             remove;
    HANDLE              event;
    PASYNC_ITEM_ROUTINE itemRoutine;
    PVOID               context;
} ASYNC_ITEM, *PASYNC_ITEM;

#define InitializeAsyncItem( pItm, autoRemove, evnt, routine, ctxt ) \
    (pItm)->link.fLink  = (pItm)->link.bLink = NULL;     \
    (pItm)->remove      = (autoRemove);                  \
    (pItm)->event       = (evnt);                        \
    (pItm)->itemRoutine = (routine);                     \
    (pItm)->context     = (ctxt);

class CAsyncItemHandler
{
public:
    CAsyncItemHandler( DWORD *pResult );
    ~CAsyncItemHandler( void );

    STDMETHODIMP_(DWORD) QueueAsyncItem( PASYNC_ITEM pItem );
    STDMETHODIMP_(VOID) RemoveAsyncItem( HANDLE itemHandle );

protected:
    typedef enum {
        WAKEUP_EXIT = 0,
        WAKEUP_NEWEVENT,
        WAKEUP_REMOVEEVENT
    } WAKEUP;

    static DWORD WINAPI AsyncItemProc( CAsyncItemHandler *pThis );
    HANDLE      m_hEvents[ MAXIMUM_WAIT_OBJECTS ];
    PASYNC_ITEM m_pItems[ MAXIMUM_WAIT_OBJECTS ];
    DWORD       m_arrayCount;
    WAKEUP      m_wakeupReason;
    HANDLE      m_hRemove;
    HANDLE      m_AsyncEvent;

    ITEM_LIST_HEAD  m_eventList;

    HANDLE  m_hWakeupEvent;
    HANDLE  m_hSlotSemaphore;
    HANDLE  m_hItemMutex;
    HANDLE  m_hThread;
    DWORD   m_threadId;
}; // CAsyncItemHandler

class CMediaTypeAttributes : public IMediaTypeAttributes {
private:
    PKSMULTIPLE_ITEM m_Attributes;

public:
    LONG m_cRef;

    CMediaTypeAttributes(
        );

    // IUnknown
    STDMETHODIMP QueryInterface(
        REFIID riid,
        void** ppv
        );
    STDMETHODIMP_(ULONG) AddRef(
        );
    STDMETHODIMP_(ULONG) Release(
        );

    // IMediaTypeAttributes
    STDMETHODIMP GetMediaAttributes(
        OUT PKSMULTIPLE_ITEM* Attributes
        );
    STDMETHODIMP SetMediaAttributes(
        IN PKSMULTIPLE_ITEM Attributes OPTIONAL
        );
};

//
// Aggregator class
//
class CAggregateMarshaler {
public:
    IID m_iid;
    CLSID m_ClassId;
    IUnknown* m_Unknown;
    IDistributorNotify* m_DistributorNotify;
    BOOL m_Volatile;
    BOOL m_Reconnected;
};

typedef CGenericList<CAggregateMarshaler> CMarshalerList;

//
// Allocator class
//

class CKsAllocator :
    public CMemAllocator,
    public IKsAllocatorEx {
    
public:
    CKsAllocator(
        TCHAR* ObjectName,
        IUnknown* UnknownOuter,
        IPin* Pin,
        HANDLE FilterHandle,
        HRESULT* hr);
    ~CKsAllocator();
    
    // Implement CUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Override CMemAllocator
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    
    // Override CMemAllocator
    STDMETHODIMP Commit();
    STDMETHODIMP Decommit();
#if DBG || defined(DEBUG)
    STDMETHODIMP GetBuffer(
        IMediaSample** Sample,
        REFERENCE_TIME* StartTime,
        REFERENCE_TIME* EndTime,
        DWORD Flags);
    STDMETHODIMP ReleaseBuffer(IMediaSample* Sample);
#endif    
    
    // Implement IKsAllocator and IKsAllocatorEx
    STDMETHODIMP_(HANDLE) KsGetAllocatorHandle();
    STDMETHODIMP_(KSALLOCATORMODE) KsGetAllocatorMode();
    STDMETHODIMP KsGetAllocatorStatus(PKSSTREAMALLOCATOR_STATUS AllocatorStatus);
    STDMETHODIMP_(VOID) KsSetAllocatorMode(KSALLOCATORMODE Mode);
    // IKsAllocatorEx
    STDMETHODIMP_(PALLOCATOR_PROPERTIES_EX) KsGetProperties() {return &m_AllocatorPropertiesEx; }
    STDMETHODIMP_(VOID) KsSetProperties(PALLOCATOR_PROPERTIES_EX PropEx) {m_AllocatorPropertiesEx = *PropEx; }
    STDMETHODIMP_(VOID) KsSetAllocatorHandle(HANDLE AllocatorHandle);
    STDMETHODIMP_(HANDLE) KsCreateAllocatorAndGetHandle(IKsPin*   KsPin);

    
private:
    IPin* m_OwnerPin;
    HANDLE m_FilterHandle;
    HANDLE m_AllocatorHandle;
    KSALLOCATORMODE m_AllocatorMode;
// new
    ALLOCATOR_PROPERTIES_EX m_AllocatorPropertiesEx;
};

//
// This is only used internally as a substitute for IKsObject
//
struct DECLSPEC_UUID("877e4352-6fea-11d0-b863-00aa00a216a1") IKsClock;
DECLARE_INTERFACE_(IKsClock, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetClockHandle)() PURE;
};

//
// Media Sample class
//

class CMicroMediaSample : public IMediaSample2 {
private:
    DWORD   m_Flags;
public:
    LONG    m_cRef;

    CMicroMediaSample(DWORD Flags);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IMediaSample
    STDMETHODIMP GetPointer(BYTE** Buffer);
    STDMETHODIMP_(LONG) GetSize();
    STDMETHODIMP GetTime(REFERENCE_TIME* TimeStart, REFERENCE_TIME* TimeEnd);
    STDMETHODIMP SetTime(REFERENCE_TIME* TimeStart, REFERENCE_TIME* TimeEnd);
    STDMETHODIMP IsSyncPoint();
    STDMETHODIMP SetSyncPoint(BOOL IsSyncPoint);
    STDMETHODIMP IsPreroll();
    STDMETHODIMP SetPreroll(BOOL IsPreroll);
    STDMETHODIMP_(LONG) GetActualDataLength();
    STDMETHODIMP SetActualDataLength(LONG Actual);
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE** MediaType);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE* MediaType);
    STDMETHODIMP IsDiscontinuity();
    STDMETHODIMP SetDiscontinuity(BOOL Discontinuity);
    STDMETHODIMP GetMediaTime(LONGLONG* TimeStart, LONGLONG* TimeEnd);
    STDMETHODIMP SetMediaTime(LONGLONG* TimeStart, LONGLONG* TimeEnd);

    // IMediaSample2
    STDMETHODIMP GetProperties(DWORD PropertiesSize, BYTE* Properties);
    STDMETHODIMP SetProperties(DWORD PropertiesSize, const BYTE* Properties);
};

//
// Proxy class
//

#define STOP_EOS        0
#define ENABLE_EOS      1
#define DISABLE_EOS     2

class CKsProxy :
    public CCritSec,
    public CBaseFilter,
    public CPersistStream,
    public ISpecifyPropertyPages,
    public IPersistPropertyBag,
    public IReferenceClock,
    public IMediaSeeking,
    public IKsObject,
    public IKsClock,
    public IKsPropertySet,
    public IKsClockPropertySet,
    public IAMFilterMiscFlags,
    public IKsControl,
    public IKsTopology,
    public IKsAggregateControl
#ifdef DEVICE_REMOVAL
   ,public IAMDeviceRemoval
#endif // DEVICE_REMOVAL
    {

public:
    static CUnknown* CALLBACK CreateInstance(LPUNKNOWN UnkOuter, HRESULT* hr);

    CKsProxy(LPUNKNOWN UnkOuter, HRESULT* hr);
    ~CKsProxy();

    // Implement CBaseFilter
    CBasePin* GetPin(int n);
    int GetPinCount();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();
    
    // Implement IKsClock
    STDMETHODIMP_(HANDLE) KsGetClockHandle();

    // Override CBaseFilter
    STDMETHODIMP SetSyncSource(IReferenceClock* RefClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME Start);
    STDMETHODIMP GetState(DWORD MSecs, FILTER_STATE* State);
    STDMETHODIMP JoinFilterGraph(IFilterGraph* Graph, LPCWSTR Name);
    STDMETHODIMP FindPin(LPCWSTR Id, IPin** Pin);

    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // Override CBaseFilter
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    STDMETHODIMP CreateClockHandle();
    STDMETHODIMP DetermineClockSource();
    STDMETHODIMP GetPinFactoryCount(PULONG PinFactoryCount);
    STDMETHODIMP GetPinFactoryDataFlow(ULONG PinFactoryId, PKSPIN_DATAFLOW DataFlow);
    STDMETHODIMP GetPinFactoryInstances(ULONG PinFactoryId, PKSPIN_CINSTANCES Instances);
    STDMETHODIMP GetPinFactoryCommunication(ULONG PinFactoryId, PKSPIN_COMMUNICATION Communication);
    STDMETHODIMP GeneratePinInstances();
    STDMETHODIMP ConstructPinName(ULONG PinFactoryId, KSPIN_DATAFLOW DataFlow, WCHAR** PinName);
    STDMETHODIMP PropagateAcquire(IKsPin* KsPin, ULONG FlagStarted);
    STDMETHODIMP_(HANDLE) GetPinHandle(CBasePin* Pin);
    STDMETHODIMP_(ULONG) GetPinFactoryId(CBasePin* Pin);
    STDMETHODIMP GetPinFactoryDataRanges(ULONG PinFactoryId, PVOID* DataRanges);
    STDMETHODIMP CheckMediaType(IUnknown* UnkOuter, ULONG PinFactoryId, const CMediaType* MediaType);
    STDMETHODIMP SetPinSyncSource(HANDLE PinHandle);
    STDMETHODIMP QueryTopologyItems(ULONG PropertyId, PKSMULTIPLE_ITEM* MultipleItem);
    STDMETHODIMP QueryInternalConnections(ULONG PinFactoryId, PIN_DIRECTION PinDirection, IPin** PinList, ULONG* PinCount);
    STDMETHODIMP_(VOID) DeliverBeginFlush(ULONG PinFactoryId);
    STDMETHODIMP_(VOID) DeliverEndFlush(ULONG PinFactoryId);
    STDMETHODIMP_(VOID) PositionEOS();
    STDMETHODIMP_(IKsQualityForwarder*) QueryQualityForwarder() { return m_QualityForwarder; }
    STDMETHODIMP_(HKEY) QueryDeviceRegKey() { return m_DeviceRegKey; }

    // Implement IReferenceClock
    STDMETHODIMP GetTime(REFERENCE_TIME* Time);
    STDMETHODIMP AdviseTime(REFERENCE_TIME BaseTime, REFERENCE_TIME StreamTime, HEVENT EventHandle, DWORD_PTR* AdviseCookie);
    STDMETHODIMP AdvisePeriodic(REFERENCE_TIME StartTime, REFERENCE_TIME PeriodTime, HSEMAPHORE SemaphoreHandle, DWORD_PTR* AdviseCookie);
    STDMETHODIMP Unadvise(DWORD_PTR AdviseCookie);
    
    // Implement IMediaSeeking
    STDMETHODIMP GetCapabilities(DWORD* Capabilities);
    STDMETHODIMP CheckCapabilities(DWORD* Capabilities);
    STDMETHODIMP IsFormatSupported(const GUID* Format);
    STDMETHODIMP QueryPreferredFormat(GUID* Format);
    STDMETHODIMP GetTimeFormat(GUID* Format);
    STDMETHODIMP IsUsingTimeFormat(const GUID* Format);
    STDMETHODIMP SetTimeFormat(const GUID* Format);
    STDMETHODIMP GetDuration(LONGLONG* Duration);
    STDMETHODIMP GetStopPosition(LONGLONG* Stop);
    STDMETHODIMP GetCurrentPosition(LONGLONG* Current);
    STDMETHODIMP ConvertTimeFormat(LONGLONG* Target, const GUID* TargetFormat, LONGLONG Source, const GUID* SourceFormat);
    STDMETHODIMP SetPositions(LONGLONG* Current, DWORD CurrentFlags, LONGLONG* Stop, DWORD StopFlags);
    STDMETHODIMP GetPositions(LONGLONG* Current, LONGLONG* Stop);
    STDMETHODIMP GetAvailable(LONGLONG* Earliest, LONGLONG* Latest);
    STDMETHODIMP SetRate(double Rate);
    STDMETHODIMP GetRate(double* Rate);
    STDMETHODIMP GetPreroll(LONGLONG* Preroll);

    // Implement IPersistPropertyBag
    STDMETHODIMP Load(LPPROPERTYBAG PropBag, LPERRORLOG ErrorLog);
    STDMETHODIMP Save(LPPROPERTYBAG PropBag, BOOL ClearDirty, BOOL SaveAllProperties);
    STDMETHODIMP InitNew();

    // Implement IPersist
    STDMETHODIMP GetClassID(CLSID* ClassId);
    
    // Implement CPersistStream
    DWORD GetSoftwareVersion();
    HRESULT WriteToStream(IStream* Stream);
    HRESULT ReadFromStream(IStream* Stream);
    int SizeMax();
    
    // Thread for I/O
    static DWORD IoThread(CKsProxy* KsProxy);
    static DWORD WaitThread(CKsProxy* KsProxy);
        
    // I/O interface
    STDMETHODIMP StartIoThread();
    STDMETHODIMP_(VOID) EnterIoCriticalSection();
    STDMETHODIMP_(ULONG) GetFreeIoSlotCount();
    STDMETHODIMP InsertIoSlot(PKSSTREAM_SEGMENT StreamSegment);
    STDMETHODIMP_(VOID) LeaveIoCriticalSection();
    STDMETHODIMP_(VOID) WaitForIoSlot();
    
    // Other helper functions
    STDMETHODIMP_(PWCHAR) GetFilterName() { return m_pName; }
    STDMETHODIMP QueryMediaSeekingFormats(PKSMULTIPLE_ITEM* MultipleItem);
    STDMETHODIMP_(REFERENCE_TIME) GetStartTime() { return m_tStart; }
    STDMETHODIMP_(VOID) TerminateEndOfStreamNotification(HANDLE PinHandle);
    STDMETHODIMP InitiateEndOfStreamNotification(HANDLE PinHandle);
    STDMETHODIMP_(ULONG) DetermineNecessaryInstances(ULONG PinFactoryId);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Helper function
    STDMETHODIMP ClockPropertyIo(ULONG PropertyId, ULONG Flags, ULONG BufferSize, PVOID Buffer);

    // Implement IKsClockPropertySet
    STDMETHODIMP KsGetTime(LONGLONG* Time);
    STDMETHODIMP KsSetTime(LONGLONG Time);
    STDMETHODIMP KsGetPhysicalTime(LONGLONG* Time);
    STDMETHODIMP KsSetPhysicalTime(LONGLONG Time);
    STDMETHODIMP KsGetCorrelatedTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsSetCorrelatedTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsGetCorrelatedPhysicalTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsSetCorrelatedPhysicalTime(KSCORRELATED_TIME* CorrelatedTime);
    STDMETHODIMP KsGetResolution(KSRESOLUTION* Resolution);
    STDMETHODIMP KsGetState(KSSTATE* State);

    // Implement IAMFilterMiscFlags
    STDMETHODIMP_(ULONG)GetMiscFlags();

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

    // Implement IKsTopology
    STDMETHODIMP CreateNodeInstance(
        IN ULONG NodeId,
        IN ULONG Flags,
        IN ACCESS_MASK DesiredAccess,
        IN IUnknown* UnkOuter OPTIONAL,
        IN REFGUID InterfaceId,
        OUT LPVOID* Interface
        );

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );

#ifdef DEVICE_REMOVAL
    // Implement IAMDeviceRemoval
    STDMETHODIMP DeviceInfo( 
        CLSID* InterfaceClass,
        WCHAR** SymbolicLink
        );
    STDMETHODIMP Reassociate(
        );
    STDMETHODIMP Disassociate(
        );
#endif // DEVICE_REMOVAL

private:
    typedef CGenericList<CBasePin> CBasePinList;

    typedef struct {
        ULONG   Message;
        PVOID   Param;
    } WAITMESSAGE, *PWAITMESSAGE;

    CBasePinList m_PinList;
    CMarshalerList m_MarshalerList;
    HANDLE m_FilterHandle;
    HANDLE m_ExternalClockHandle;
    HANDLE m_PinClockHandle;
    HANDLE m_IoThreadHandle;
    ULONG m_IoThreadId;
    BOOL m_IoThreadShutdown;
    CRITICAL_SECTION m_IoThreadCriticalSection;
    HANDLE m_IoFreeSlotSemaphore;
    PHANDLE m_IoEvents;
    PKSSTREAM_SEGMENT* m_IoSegments;
    LONG m_ActiveIoEventCount;
    CBasePin* m_PinClockSource;
    IKsQualityForwarder* m_QualityForwarder;
    BOOL m_MediaSeekingRecursion;
    HKEY m_DeviceRegKey;
    IPersistStream* m_PersistStreamDevice;
    HANDLE m_WaitThreadHandle;
    HANDLE* m_WaitEvents;
    HANDLE* m_WaitPins;
    ULONG m_ActiveWaitEventCount;
    HANDLE m_WaitReplyHandle;
    WAITMESSAGE m_WaitMessage;
    ULONG m_EndOfStreamCount;
    BOOL m_PropagatingAcquire;
    WCHAR* m_SymbolicLink;
    GUID m_InterfaceClassGuid;
    LONG m_EventNameIndex;
};

//
// Input pin class
//

class CKsInputPin :
    public CBaseInputPin,
    public IKsObject,
    public IKsPinEx,
    public IKsPinPipe,
    public ISpecifyPropertyPages,
    public IStreamBuilder,
    public IKsPropertySet,
    public IKsPinFactory,
    public IKsControl,
    public IKsAggregateControl {

private:
    HANDLE m_PinHandle;
    IKsDataTypeHandler* m_DataTypeHandler;
    IUnknown* m_UnkInner;
    IKsInterfaceHandler* m_InterfaceHandler;
    ULONG m_PinFactoryId;
    KSPIN_COMMUNICATION m_OriginalCommunication;
    KSPIN_COMMUNICATION m_CurrentCommunication;
    KSPIN_INTERFACE m_CurrentInterface;
    KSPIN_MEDIUM m_CurrentMedium;
    BOOL m_PropagatingAcquire;
    BOOL m_MarshalData;
    LONG m_PendingIoCount;
    HANDLE m_PendingIoCompletedEvent;
    CCritSec m_IoCriticalSection;
    CMarshalerList m_MarshalerList;
    BOOL m_QualitySupport;
    BOOL m_DeliveryError;
// new
    BOOL m_IsUpstreamPinUserMode;
    IKsAllocatorEx* m_pKsAllocator;
    PKSALLOCATOR_FRAMING_EX m_AllocatorFramingEx[Framing_Cache_Write];
    FRAMING_PROP m_FramingProp[Framing_Cache_Write];
    ULONG m_fPipeAllocator;       
    GUID m_BusOrig;
    BOOL m_PinBusCacheInit;

public:
    ULONG m_RelativeRefCount;
    CKsInputPin(
        TCHAR* ObjectName,
        int PinFactoryId,
        CLSID ClassId,
        CKsProxy* KsProxy,
        HRESULT* hr,
        WCHAR* PinName);
    ~CKsInputPin();

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

    // Implement IKsPinEx
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* MediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* InterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium);
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION* Communication, KSPIN_INTERFACE* Interface, KSPIN_MEDIUM* Medium);
    STDMETHODIMP KsPropagateAcquire();
    STDMETHODIMP KsDeliver(IMediaSample* Sample, ULONG Flags);
    STDMETHODIMP KsMediaSamplesCompleted( PKSSTREAM_SEGMENT StreamSegment );
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation);
    STDMETHODIMP KsReceiveAllocator(IMemAllocator* MemAllocator);
    STDMETHODIMP KsRenegotiateAllocator();
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount();
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount();
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta);
    STDMETHODIMP_(VOID) KsNotifyError(IMediaSample* Sample, HRESULT hr);

    STDMETHODIMP ProcessCompleteConnect(IPin* ReceivePin);
    STDMETHODIMP_(CMarshalerList*) MarshalerList() { return &m_MarshalerList; }
    STDMETHODIMP_(ULONG)PinFactoryId() { return m_PinFactoryId; }


    // Implement IKsPinPipe
    STDMETHODIMP KsGetPinFramingCache (PKSALLOCATOR_FRAMING_EX *FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetPinFramingCache (PKSALLOCATOR_FRAMING_EX FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP_(IPin*)KsGetConnectedPin() { return m_Connected; }
    STDMETHODIMP_(IKsAllocatorEx*)KsGetPipe(KSPEEKOPERATION Operation);
    STDMETHODIMP KsSetPipe(IKsAllocatorEx*   KsAllocator);
    STDMETHODIMP_(ULONG)KsGetPipeAllocatorFlag();
    STDMETHODIMP KsSetPipeAllocatorFlag(ULONG Flag);
    STDMETHODIMP_(GUID)KsGetPinBusCache();
    STDMETHODIMP KsSetPinBusCache(GUID Bus);
//  dbg
    STDMETHODIMP_(PWCHAR)KsGetPinName();
    STDMETHODIMP_(PWCHAR)KsGetFilterName();



    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    // Override CBaseInputPin
    STDMETHODIMP Disconnect();
    STDMETHODIMP GetAllocator(IMemAllocator** MemAllocator);
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES* Requirements);
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();

    // Override CBasePin
    BOOL IsConnected() { return (m_PinHandle != NULL); };//Note that this is not virtual
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Connect(IPin* ReceivePin, const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP QueryInternalConnections(IPin** PinList, ULONG* PinCount);
    HRESULT Active();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT Inactive();
    STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP NewSegment(REFERENCE_TIME Start, REFERENCE_TIME Stop, double Rate);
    STDMETHODIMP QueryId(LPWSTR* Id);
    
    // Implement CBasePin
    HRESULT CheckMediaType(const CMediaType* MediaType);

    // Override CBasePin
    STDMETHODIMP EndOfStream();
    HRESULT SetMediaType(const CMediaType* MediaType);
    HRESULT CheckConnect(IPin* Pin);
    HRESULT CompleteConnect(IPin* ReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int Position, CMediaType* MediaType);
    
    // Implement IMemInputPin
    STDMETHODIMP Receive(IMediaSample* MediaSample);
    STDMETHODIMP ReceiveMultiple(IMediaSample** MediaSamples, LONG Samples, LONG* SamplesProcessed);
    STDMETHODIMP ReceiveCanBlock();
    STDMETHODIMP NotifyAllocator(IMemAllocator* Allocator, BOOL ReadOnly);
    
    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IStreamBuilder
    STDMETHODIMP Render(IPin* PinOut, IGraphBuilder* Graph);
    STDMETHODIMP Backout(IPin* PinOut, IGraphBuilder* Graph);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Implement IKsPinFactory
    STDMETHODIMP KsPinFactory(ULONG* PinFactory);


    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    //
    // supporting routines (class specific)
    //
    STDMETHODIMP SetStreamMediaType(const CMediaType* MediaType);

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );
};

//
// Output pin class
//

#define UM_IOTHREAD_STOP    (WM_USER + 0x100)
#define UM_IOTHREAD_DELIVER (WM_USER + 0x101)

typedef CGenericList<ASYNC_ITEM> CIoQueue;
typedef CGenericList<IMediaSample> CIoThreadQueue;

typedef enum {

    FLUSH_NONE = 0,
    FLUSH_SYNCHRONIZE,
    FLUSH_SIGNAL

} FLUSH_MODE, *PFLUSH_MODE;

class CKsOutputPin :
    public CBaseOutputPin,
    public CBaseStreamControl,
    public IMediaSeeking,
    public IKsObject,
    public IKsPinEx,
    public IKsPinPipe,
    public ISpecifyPropertyPages,
    public IStreamBuilder,
    public IKsPropertySet,
    public IKsPinFactory,
    public IAMBufferNegotiation,
    public IAMStreamConfig,
    public IKsControl,
    public IKsAggregateControl,
    public IMemAllocatorNotifyCallbackTemp 
{

private:
    ALLOCATOR_PROPERTIES m_AllocatorProperties;
    ALLOCATOR_PROPERTIES m_SuggestedProperties;
    HANDLE m_PinHandle;
    HANDLE m_IoThreadExitEvent;
    HANDLE m_IoThreadHandle;
    HANDLE m_IoThreadSemaphore;
    ULONG m_IoThreadId;
    IKsDataTypeHandler* m_DataTypeHandler;
    IUnknown* m_UnkInner;
    IKsInterfaceHandler* m_InterfaceHandler;
    ULONG m_PinFactoryId;
    KSPIN_COMMUNICATION m_OriginalCommunication;
    KSPIN_COMMUNICATION m_CurrentCommunication;
    KSPIN_INTERFACE m_CurrentInterface;
    KSPIN_MEDIUM m_CurrentMedium;
    BOOL m_MarshalData; 
    BOOL m_PropagatingAcquire;
    BOOL m_UsingThisAllocator;
    HANDLE m_PendingIoCompletedEvent;
    LONG m_PendingIoCount;
    CMarshalerList m_MarshalerList;
    CIoQueue m_IoQueue;
    CCritSec m_IoCriticalSection;
    CIoThreadQueue m_IoThreadQueue;
    BOOL m_QualitySupport;
    BOOL m_LastSampleDiscarded;
    AM_MEDIA_TYPE* m_ConfigAmMediaType;
    BOOL m_DeliveryError;
    BOOL m_EndOfStream;
// new
    BOOL m_IsDownstreamPinUserMode;
    IKsAllocatorEx* m_pKsAllocator;
    PKSALLOCATOR_FRAMING_EX m_AllocatorFramingEx[Framing_Cache_Write];
    FRAMING_PROP m_FramingProp[Framing_Cache_Write];
    ULONG m_fPipeAllocator;       
    GUID m_BusOrig;
    BOOL m_PinBusCacheInit;
    BOOL m_bFlushing;

    HANDLE m_hMarshalEvent;
    HANDLE m_hFlushEvent;
    HANDLE m_hFlushCompleteEvent;
    HANDLE  m_hEOSevent;
    FLUSH_MODE m_FlushMode;

    CAsyncItemHandler *m_pAsyncItemHandler;

public:
    ULONG m_RelativeRefCount;
    CKsOutputPin(
        TCHAR* ObjectName,
        int PinFactoryId,
        CLSID ClassId,
        CKsProxy* KsProxy,
        HRESULT* hr,
        WCHAR* PinName);
    ~CKsOutputPin();

    // Implement IMediaSeeking
    STDMETHODIMP GetCapabilities(DWORD* Capabilities);
    STDMETHODIMP CheckCapabilities(DWORD* Capabilities);
    STDMETHODIMP IsFormatSupported(const GUID* Format);
    STDMETHODIMP QueryPreferredFormat(GUID* Format);
    STDMETHODIMP GetTimeFormat(GUID* Format);
    STDMETHODIMP IsUsingTimeFormat(const GUID* Format);
    STDMETHODIMP SetTimeFormat(const GUID* Format);
    STDMETHODIMP GetDuration(LONGLONG* Duration);
    STDMETHODIMP GetStopPosition(LONGLONG* Stop);
    STDMETHODIMP GetCurrentPosition(LONGLONG* Current);
    STDMETHODIMP ConvertTimeFormat(LONGLONG* Target, const GUID* TargetFormat, LONGLONG Source, const GUID* SourceFormat);
    STDMETHODIMP SetPositions(LONGLONG* Current, DWORD CurrentFlags, LONGLONG* Stop, DWORD StopFlags);
    STDMETHODIMP GetPositions(LONGLONG* Current, LONGLONG* Stop);
    STDMETHODIMP GetAvailable(LONGLONG* Earliest, LONGLONG* Latest);
    STDMETHODIMP SetRate(double Rate);
    STDMETHODIMP GetRate(double* Rate);
    STDMETHODIMP GetPreroll(LONGLONG* Preroll);

    // Implement IKsObject
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();

    // Implement IKsPinEx
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* MediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* InterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium);
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION* Communication, KSPIN_INTERFACE* Interface, KSPIN_MEDIUM* Medium);
    STDMETHODIMP KsPropagateAcquire();
    STDMETHODIMP KsDeliver(IMediaSample* Sample, ULONG Flags);
    STDMETHODIMP KsMediaSamplesCompleted( PKSSTREAM_SEGMENT StreamSegment );
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation);
    STDMETHODIMP KsReceiveAllocator(IMemAllocator* MemAllocator);
    STDMETHODIMP KsRenegotiateAllocator();
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount();
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount();
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta);
    STDMETHODIMP_(VOID) KsNotifyError(IMediaSample* Sample, HRESULT hr);

    STDMETHODIMP ProcessCompleteConnect(IPin* ReceivePin);
    STDMETHODIMP_(CMarshalerList*) MarshalerList() { return &m_MarshalerList; }
    STDMETHODIMP_(ULONG)PinFactoryId() { return m_PinFactoryId; }

    // Implement IKsPinPipe
    STDMETHODIMP KsGetPinFramingCache (PKSALLOCATOR_FRAMING_EX *FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetPinFramingCache (PKSALLOCATOR_FRAMING_EX FramingEx, PFRAMING_PROP FramingProp, FRAMING_CACHE_OPS Option);
    STDMETHODIMP KsSetUserModeAllocator(IMemAllocator*     MemAllocator);
    STDMETHODIMP_(IPin*)KsGetConnectedPin() { return m_Connected; }
    STDMETHODIMP_(IKsAllocatorEx*)KsGetPipe(KSPEEKOPERATION Operation);
    STDMETHODIMP KsSetPipe(IKsAllocatorEx*   KsAllocator);
    STDMETHODIMP_(ULONG)KsGetPipeAllocatorFlag();
    STDMETHODIMP KsSetPipeAllocatorFlag(ULONG Flag);
    STDMETHODIMP_(GUID)KsGetPinBusCache();
    STDMETHODIMP KsSetPinBusCache(GUID Bus);
// dbg
    STDMETHODIMP_(PWCHAR)KsGetPinName();
    STDMETHODIMP_(PWCHAR)KsGetFilterName();


    // Implement IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, PVOID* ppv);

    // Override CBasePin
    BOOL IsConnected() { return (m_PinHandle != NULL); };
    STDMETHODIMP ConnectionMediaType(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Connect(IPin* ReceivePin, const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP Disconnect();
    STDMETHODIMP QueryInternalConnections(IPin** PinList, ULONG* PinCount);
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverEndOfStream();
    HRESULT Active();
    HRESULT Run(REFERENCE_TIME tStart);
    HRESULT Inactive();
    STDMETHODIMP QueryAccept(const AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP QueryId(LPWSTR* Id);
    
    // Implement CBasePin
    HRESULT CheckMediaType(const CMediaType* pmt);

    // Override CBasePin
    HRESULT SetMediaType(const CMediaType* MediaType);
    HRESULT CheckConnect(IPin* Pin);
    HRESULT CompleteConnect(IPin* ReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int Position, CMediaType* MediaType);
    STDMETHODIMP Notify(IBaseFilter* Sender, Quality q);

    // Implement CBaseOutputPin
    HRESULT Deliver(IMediaSample* Sample);
    HRESULT DecideAllocator(IMemInputPin* Pin, IMemAllocator** MemAllocator);
    HRESULT DecideBufferSize(IMemAllocator* MemAllocator, ALLOCATOR_PROPERTIES* propInputRequest);
    HRESULT InitAllocator(IMemAllocator** MemAllocator, KSALLOCATORMODE AllocatorMode);

    // Implement ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID* Pages);

    // Implement IStreamBuilder
    STDMETHODIMP Render(IPin* PinOut, IGraphBuilder* Graph);
    STDMETHODIMP Backout(IPin* PinOut, IGraphBuilder* Graph);

    // Implement IKsPropertySet
    STDMETHODIMP Set(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength);
    STDMETHODIMP Get(REFGUID PropSet, ULONG Property, LPVOID InstanceData, ULONG InstanceLength, LPVOID PropertyData, ULONG DataLength, ULONG* BytesReturned);
    STDMETHODIMP QuerySupported(REFGUID PropSet, ULONG Property, ULONG* TypeSupport);
    
    // Implement IKsPinFactory
    STDMETHODIMP KsPinFactory(ULONG* PinFactory);

    // Implement IAMBufferNegotiation
    STDMETHODIMP SuggestAllocatorProperties(const ALLOCATOR_PROPERTIES* AllocatorProperties);
    STDMETHODIMP GetAllocatorProperties(ALLOCATOR_PROPERTIES* AllocatorProperties);
    
    // Implement IAMStreamConfig
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE* AmMediaType);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE** AmMediaType);
    STDMETHODIMP GetNumberOfCapabilities(int* Count, int* Size);
    STDMETHODIMP GetStreamCaps(int Index, AM_MEDIA_TYPE** AmMediaType, BYTE* MediaRange);

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

    //
    // supporting routines (class specific)
    //
    
    static DWORD IoThread(CKsOutputPin* KsOutputPin);
    
    STDMETHODIMP 
    QueueBuffersToDevice(
        void
        );
        
    STDMETHODIMP
    KsPropagateAllocatorRenegotiation(
        VOID
        );

    STDMETHODIMP CompletePartialMediaType(
        IN CMediaType* MediaType,
        OUT AM_MEDIA_TYPE** CompleteAmMediaType);

    // Implement IKsAggregateControl
    STDMETHODIMP KsAddAggregate(
        IN REFGUID Aggregate
        );
    STDMETHODIMP KsRemoveAggregate(
        IN REFGUID Aggregate
        );

    // Implement IKsProxyMediaNotify/IMemAllocatorNotify
    STDMETHODIMP NotifyRelease(
        );

    typedef struct _BUFFER_CONTEXT {
        CKsOutputPin *      pThis;
        PKSSTREAM_SEGMENT   streamSegment;
    } BUFFER_CONTEXT, *PBUFFER_CONTEXT;

    static VOID OutputPinBufferHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem ); 
    static VOID EOSEventHandler( ASYNC_ITEM_STATUS status, PASYNC_ITEM pItem );

    static VOID MarshalRoutine( IN ASYNC_ITEM_STATUS status, IN PASYNC_ITEM pItem );

    static VOID SynchronizeFlushRoutine( IN ASYNC_ITEM_STATUS status, IN PASYNC_ITEM pItem );

    HRESULT
    InitializeAsyncThread (
        );

};

typedef struct _KSSTREAM_SEGMENT_EX {
    KSSTREAM_SEGMENT    Common;
    IMediaSample*       Sample;
    KSSTREAM_HEADER     StreamHeader;
    OVERLAPPED          Overlapped;

} KSSTREAM_SEGMENT_EX, *PKSSTREAM_SEGMENT_EX;

class CFormatChangeHandler :
    public CUnknown,
    public IKsInterfaceHandler {

public:
    DECLARE_IUNKNOWN;

    static CUnknown* CALLBACK
    CreateInstance(
        LPUNKNOWN UnkOuter, 
        HRESULT* hr 
        );

    STDMETHODIMP 
    NonDelegatingQueryInterface(
        REFIID riid, 
        PVOID* ppv 
        );
    
    // Implement IKsInterfaceHandler
    
    STDMETHODIMP
    KsSetPin(
        IN IKsPin* KsPin 
        );
    
    STDMETHODIMP 
    KsProcessMediaSamples(
        IN IKsDataTypeHandler* KsDataTypeHandler,
        IN IMediaSample** SampleList, 
        IN OUT PLONG SampleCount, 
        IN KSIOOPERATION IoOperation,
        OUT PKSSTREAM_SEGMENT* StreamSegment
        );
        
    STDMETHODIMP
    KsCompleteIo(
        IN PKSSTREAM_SEGMENT StreamSegment
        );
        
    CFormatChangeHandler(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr
        );
        
private:
    IKsPin* m_KsPin;
    HANDLE m_PinHandle;
};


typedef struct {
    IKsPin*               KsPin;
    ULONG                 PinType;
    IKsAllocatorEx*       KsAllocator;
} KEY_PIPE_DATA;

//
// Topology node class
//

class CKsNode :
   public CUnknown,
   public IKsControl {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        IN PKSNODE_CREATE NodeCreate,
        IN ACCESS_MASK DesiredAccess,
        IN HANDLE ParentHandle,
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT* hr);

    CKsNode(
        IN PKSNODE_CREATE NodeCreate,
        IN ACCESS_MASK DesiredAccess,
        IN HANDLE ParentHandle,
        IN LPUNKNOWN UnkOuter,
        OUT HRESULT* hr);
    ~CKsNode();

    STDMETHODIMP NonDelegatingQueryInterface(
        IN REFIID riid,
        OUT PVOID* ppv);

    // Implement IKsControl
    STDMETHODIMP KsProperty(
        IN PKSPROPERTY Property,
        IN ULONG PropertyLength,
        IN OUT LPVOID PropertyData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsMethod(
        IN PKSMETHOD Method,
        IN ULONG MethodLength,
        IN OUT LPVOID MethodData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );
    STDMETHODIMP KsEvent(
        IN PKSEVENT Event OPTIONAL,
        IN ULONG EventLength,
        IN OUT LPVOID EventData,
        IN ULONG DataLength,
        OUT ULONG* BytesReturned
        );

private:
    HANDLE m_NodeHandle;
};

//
// helper function prototypes
//

STDMETHODIMP
SynchronousDeviceControl(
    HANDLE Handle,
    DWORD IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    );
STDMETHODIMP
GetState(
    HANDLE Handle,
    PKSSTATE State
    );
STDMETHODIMP
SetState(
    HANDLE Handle,
    KSSTATE State
    );
STDMETHODIMP
InitializeDataFormat(
    IN const CMediaType* MediaType,
    IN ULONG InitialOffset,
    OUT PVOID* Format,
    OUT ULONG* FormatLength
    );
STDMETHODIMP
SetMediaType(
    HANDLE Handle,
    const CMediaType* MediaType
    );
STDMETHODIMP
Active(
    IKsPin* KsPin,
    ULONG PinType,
    HANDLE PinHandle,
    KSPIN_COMMUNICATION Communication,
    IPin* ConnectedPin,
    CMarshalerList* MarshalerList,
    CKsProxy* KsProxy
    );
STDMETHODIMP
Run(
    HANDLE PinHandle,
    REFERENCE_TIME tStart,
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
Inactive(
    HANDLE PinHandle,
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
CheckConnect(
    IPin* Pin,
    KSPIN_COMMUNICATION CurrentCommunication
    );
STDMETHODIMP
GetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    );
STDMETHODIMP
FindCompatibleInterface(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_INTERFACE Interface
    );
STDMETHODIMP
FindCompatibleMedium(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_MEDIUM Medium
    );
STDMETHODIMP
SetDevIoMedium(
    IKsPin* Pin,
    PKSPIN_MEDIUM Medium
    );
STDMETHODIMP
GetMediaTypeCount(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG* MediaTypeCount
    );
STDMETHODIMP
GetMediaType(
    int Position,
    CMediaType* MediaType,
    HANDLE FilterHandle,
    ULONG PinFactoryId
    );
STDMETHODIMP_(KSPIN_COMMUNICATION)
ChooseCommunicationMethod(
    CBasePin* SourcePin,
    IKsPin* DestPin
    );
STDMETHODIMP
CreatePinHandle(
    KSPIN_INTERFACE& Interface,
    KSPIN_MEDIUM& Medium,
    HANDLE PeerPinHandle,
    CMediaType* MediaType,
    CKsProxy* KsProxy,
    ULONG PinFactoryId,
    ACCESS_MASK DesiredAccess,
    HANDLE* PinHandle
    );
STDMETHODIMP_(VOID) 
AppendSpecificPropertyPages(
    CAUUID* Pages,
    ULONG Guids,
    GUID* GuidList,
    TCHAR* GuidRoot,
    HKEY DeviceRegKey
    );
STDMETHODIMP 
GetPages(
    IKsObject* Pin,
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    KSPIN_COMMUNICATION Communication,
    HKEY DeviceRegKey,
    CAUUID* Pages
    );
STDMETHODIMP
GetPinFactoryInstances(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    PKSPIN_CINSTANCES Instances
    );
STDMETHODIMP
SetSyncSource(
    HANDLE PinHandle,
    HANDLE ClockHandle
    );
STDMETHODIMP
AggregateMarshalers(
    HKEY RootKey,
    TCHAR* SubKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP
AggregateTopology(
    HKEY RootKey,
    PKSMULTIPLE_ITEM MultipleItem,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP
CollectAllSets(
    HANDLE ObjectHandle,
    GUID** GuidList,
    ULONG* SetDataSize
    );
STDMETHODIMP_(VOID)
ResetInterfaces(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
AggregateSets(
    HANDLE ObjectHandle,
    HKEY DeviceRegKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    );
STDMETHODIMP_(VOID)
FreeMarshalers(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
UnloadVolatileInterfaces(
    CMarshalerList* MarshalerList,
    BOOL ForceUnload
    );
STDMETHODIMP_(VOID)
FollowFromTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    );
STDMETHODIMP_(VOID)
FollowToTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    );
STDMETHODIMP_(BOOL)
IsAcquireOrderingSignificant(
    HANDLE PinHandle
    );
STDMETHODIMP
QueryAccept(
    HANDLE PinHandle,
    const AM_MEDIA_TYPE* ConfigAmMediaType,
    const AM_MEDIA_TYPE* AmMediaType
    );
STDMETHODIMP_(VOID)
DistributeSetSyncSource(
    CMarshalerList* MarshalerList,
    IReferenceClock* RefClock
    );
STDMETHODIMP_(VOID)
DistributeStop(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
DistributePause(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP_(VOID)
DistributeRun(
    CMarshalerList* MarshalerList,
    REFERENCE_TIME Start
    );
STDMETHODIMP_(VOID)
DistributeNotifyGraphChange(
    CMarshalerList* MarshalerList
    );
STDMETHODIMP
AddAggregate(
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter,
    IN REFGUID Aggregate
    );
STDMETHODIMP
RemoveAggregate(
    CMarshalerList* MarshalerList,
    IN REFGUID Aggregate
    );
STDMETHODIMP
GetDegradationStrategies(
    HANDLE PinHandle,
    PVOID* Items
    );
STDMETHODIMP_(BOOL)
VerifyQualitySupport(
    HANDLE PinHandle
    );
STDMETHODIMP_(BOOL)
EstablishQualitySupport(
    IKsPin* Pin,
    HANDLE PinHandle,
    CKsProxy* Filter
    );
STDMETHODIMP_(PKSDEGRADE)
FindDegradeItem(
    PKSMULTIPLE_ITEM MultipleItem,
    ULONG DegradeItem
    );
STDMETHODIMP
GetAllocatorFraming(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING Framing
    );
STDMETHODIMP_(HANDLE)
GetObjectHandle(
    IUnknown* Object
    );
STDMETHODIMP
IsAllocatorCompatible(
    HANDLE PinHandle,
    HANDLE InputPinHandle,
    IMemAllocator* MemAllocator
    );
STDMETHODIMP_(VOID)
OpenDataHandler(
    IN const CMediaType* MediaType,
    IN IUnknown* UnkOuter OPTIONAL,
    OUT IKsDataTypeHandler** DataTypeHandler,
    OUT IUnknown** UnkInner
    );
STDMETHODIMP
GetAllocatorFramingEx(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx
    );
STDMETHODIMP_(VOID)
GetFramingFromFramingEx(
    IN KSALLOCATOR_FRAMING_EX* FramingEx,
    OUT KSALLOCATOR_FRAMING* Framing
    );
STDMETHODIMP_(VOID)
ValidateFramingRange(
    IN OUT PKS_FRAMING_RANGE    Range
    );
STDMETHODIMP_(VOID)
ValidateFramingEx(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    );
STDMETHODIMP_(BOOL)
GetPinFramingFromCache(
    IN IKsPin* KsPin,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx, 
    OUT PFRAMING_PROP FramingProp,
    IN FRAMING_CACHE_OPS Option
    );
STDMETHODIMP
CreatePipe(
    IN IKsPin* KsPin,
    OUT IKsAllocatorEx** KsAllocator
    );
STDMETHODIMP
ReleasePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN IKsPin* KsPin
    );
STDMETHODIMP
DeletePipe(
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP
DeleteUserModePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN IKsPin* KsPin
    );
STDMETHODIMP
MakePipesBasedOnFilter(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP
MakePipeBasedOnOnePin(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN IKsPin* OppositeKsPin
    );
STDMETHODIMP
MakePipeBasedOnFixedFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP
MakePipeBasedOnTwoPins(
    IN IKsPin* InPin,
    IN IKsPin* OutPin,
    IN ULONG PinType,
    IN ULONG ConnectPinType
    );
STDMETHODIMP
MakePipeBasedOnSplitter(
    IN IKsPin* InPin,
    IN IPin** OutPinList,
    IN ULONG OutPinCount,
    IN ULONG ConnectPinType
    );
STDMETHODIMP
ConnectPipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    );
STDMETHODIMP
ConnectPipeToUserModePin(
    IN IKsPin* OutKsPin,
    IN IMemInputPin* InMemPin
    );
STDMETHODIMP
DisconnectPins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT BOOL* FlagBypassBaseAllocators
    );
STDMETHODIMP
InitializePipeTermination(
    IN PIPE_TERMINATION* Termin,
    IN BOOL Reset
    );
STDMETHODIMP
InitializePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN BOOL Reset
    );
STDMETHODIMP_(BOOL)
CreatePipeForTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType
    );
STDMETHODIMP
MakeTwoPipesDependent(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    );
STDMETHODIMP_(BOOL)
IsFramingRangeDontCare(
    IN KS_FRAMING_RANGE Range
    );
STDMETHODIMP_(BOOL)
IsFramingRangeEqual(
    IN KS_FRAMING_RANGE* Range1,
    IN KS_FRAMING_RANGE* Range2
    );
STDMETHODIMP_(BOOL)
IsCompressionDontCare(
    IN KS_COMPRESSION Compression
    );
STDMETHODIMP
ResolvePipeOnConnection(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG FlagDisconnect,
    OUT ULONG* FlagChange
    );
STDMETHODIMP
ResolveNewPipeOnDisconnect(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_LogicalMemoryType OldLogicalMemoryType,
    IN GUID OldMemoryType,
    IN ULONG AllocatorHandlerLocation
    );
STDMETHODIMP_(BOOL)
GetFramingExFromFraming(
    OUT KSALLOCATOR_FRAMING_EX* FramingEx,
    IN KSALLOCATOR_FRAMING* Framing
    );
STDMETHODIMP_(BOOL)  
GetFramingFixedFromFramingEx(
    IN PKSALLOCATOR_FRAMING_EX FramingEx, 
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
ComputeChangeInFraming(
    IN IKsPin* KsPin, 
    IN ULONG PinType,
    IN GUID MemoryType,
    OUT ULONG* FramingDelta
    );
STDMETHODIMP_(BOOL)
SetDefaultDimensions(
    OUT PPIPE_DIMENSIONS Dimensions
    );
STDMETHODIMP_(BOOL)
ComputeNumPinsInPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT ULONG* NumPins
    );
STDMETHODIMP_(BOOL)
CanPipeUseMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType,
    IN ULONG FlagModify,
    IN ULONG QuickTest
    );
STDMETHODIMP_(BOOL)
GetBusForKsPin(
    IN IKsPin* KsPin,
    OUT GUID* Bus
    );
STDMETHODIMP_(BOOL)
IsHostSystemBus(
    IN GUID Bus
    );
STDMETHODIMP_(BOOL)
AreBusesCompatible(
    IN GUID Bus1,
    IN GUID Bus2
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByLogicalMemoryType(
    IN IKsPin* KsPin,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByLogicalMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByIndex(
    IN IKsPin* KsPin,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByIndex(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN BOOL FlagMustReturnFraming,
    OUT PKS_FRAMING_FIXED FramingExFixed
    );
STDMETHODIMP_(BOOL)
GetLogicalMemoryTypeFromMemoryType(
    IN GUID MemoryType,
    IN ULONG Flag,
    OUT KS_LogicalMemoryType* LogicalMemoryType
    );
STDMETHODIMP_(BOOL)
GetMemoryTypeFromLogicalMemoryType(
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT GUID* MemoryType
    );
STDMETHODIMP_(BOOL)
DoesPipePreferMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID ToMemoryType,
    IN GUID FromMemoryType,
    IN ULONG Flag
    );
STDMETHODIMP
SetUserModePipe(
    IN IKsPin* KsPin,
    IN ULONG KernelPinType,
    IN OUT ALLOCATOR_PROPERTIES* Properties,
    IN ULONG PropertyPinType,
    IN ULONG BufferLimit
    );
STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocationCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocation(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorPinType,
    OUT ULONG* AllocatorHandlerLocation
    );
STDMETHODIMP_(BOOL)
SplitPipes(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    );
STDMETHODIMP_(BOOL)
FindConnectedPinOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,        
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** ConnectedKsPin
    );
STDMETHODIMP_(BOOL)
FindAllConnectedPinsOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,
    OUT IKsPin** ListConnectedKsPins,
    OUT ULONG* CountConnectedKsPins
    );
STDMETHODIMP_(BOOL)
FindNextPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* KsAllocator,     
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** NextKsPin
    );
STDMETHODIMP_(BOOL)
FindFirstPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** FirstKsPin,
    OUT ULONG* FirstPinType
    );
STDMETHODIMP_(BOOL)
ComputeRangeBasedOnCompression(
    IN KS_FRAMING_RANGE From,
    IN KS_COMPRESSION Compression,
    OUT KS_FRAMING_RANGE* To
    );
STDMETHODIMP_(BOOL)
ComputeUlongBasedOnCompression(
    IN ULONG From,
    IN KS_COMPRESSION Compression,
    OUT ULONG* To
    );
STDMETHODIMP_(BOOL)
ReverseCompression(
    IN KS_COMPRESSION* From,
    OUT KS_COMPRESSION* To
    );
STDMETHODIMP_(BOOL)
MultiplyKsCompression(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
    );
STDMETHODIMP_(BOOL)
DivideKsCompression(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
    );
STDMETHODIMP_(BOOL)
IsGreaterKsExpansion(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2
    );
STDMETHODIMP_(BOOL)
IsKsExpansion(
    IN KS_COMPRESSION C
    );
STDMETHODIMP_(BOOL)
FrameRangeIntersection(
    IN KS_FRAMING_RANGE In,
    IN KS_FRAMING_RANGE Out,
    OUT PKS_FRAMING_RANGE Result,
    OUT PKS_OBJECTS_INTERSECTION Intersect
    );
STDMETHODIMP_(BOOL)
IntersectFrameAlignment(
    IN ULONG In,
    IN ULONG Out,
    OUT LONG* Result
    );
STDMETHODIMP_(BOOL)
ResolvePhysicalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    );
STDMETHODIMP_(BOOL)
ResolveOptimalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx,
    IN KS_FRAMING_RANGE Range,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
MovePinsToNewPipe(
    IN IKsPin* KsPin,           
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* NewKsAllocator,  
    IN BOOL MoveAllPins
    );
STDMETHODIMP
ResolvePipeDimensions(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction
    );
STDMETHODIMP
CreateSeparatePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
CanMergePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID MemoryType,
    IN ULONG FlagMerge
    );
STDMETHODIMP_(BOOL)
CanAddPinToPipeOnAnotherFilter(
    IN IKsPin* KsPinPipe,
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Flag
    );
STDMETHODIMP_(BOOL)
RemovePinFromPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
CanConnectPins(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin,
    IN ULONG Flag
    );
STDMETHODIMP_(BOOL)
OptimizePipesSystem(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    );
STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandler(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorPinType,
    IN BOOL FlagAssign
    );
STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandlerCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN HANDLE AllocatorHandle,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorPin,
    OUT ULONG* AllocatorPinType
    );
STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP
FixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP
UnfixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    );
STDMETHODIMP_(BOOL)
SetDefaultRange(
    OUT PKS_FRAMING_RANGE Range
    );
STDMETHODIMP_(BOOL)
SetDefaultRangeWeighted(
    OUT PKS_FRAMING_RANGE_WEIGHTED  RangeWeighted
    );
STDMETHODIMP_(BOOL)
SetDefaultCompression(
    OUT PKS_COMPRESSION Compression
    );
STDMETHODIMP_(BOOL)
IsKernelPin(
    IN IPin* Pin
    );          
STDMETHODIMP_(BOOL)
HadKernelPinBeenConnectedToUserPin(
    IN IKsPin* OutKsPin,
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP_(BOOL)
CreateAllocatorCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
ReassignPipeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
MemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
DimensionsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    OUT PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
NumPinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
DoesPinPreferMemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    );
STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    );
STDMETHODIMP_(BOOL)
CanPinUseMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType
    );
STDMETHODIMP_(BOOL)
IsPipeSupportPartialFrame(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT HANDLE* FirstPinHandle
    );
STDMETHODIMP_(BOOL)
ResultSinglePipe(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType,
    IN IKsPinPipe* InKsPinPipe,
    IN IKsPinPipe* OutKsPinPipe,
    IN IMemAllocator* MemAllocator,
    IN IKsAllocatorEx* KsAllocator,
    IN ULONG ExistingPipePinType
    );
STDMETHODIMP_(BOOL)
ResultSeparatePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN ULONG OutPinType,
    IN ULONG ExistingPipePinType,
    IN IKsAllocatorEx* KsAllocator
    );
STDMETHODIMP_(BOOL)
FindCommonMemoryTypeBasedOnPipeAndPin(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* ConnectKsPin,
    IN ULONG ConnectPinType,
    IN BOOL FlagMerge,
    OUT GUID* MemoryType
    );
STDMETHODIMP_(BOOL)
SplitterCanAddPinToPipes(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KEY_PIPE_DATA* KeyPipeData,
    IN ULONG KeyPipeDataCount
    );
STDMETHODIMP_(BOOL)
FindCommonMemoryTypesBasedOnBuses(
    IN PKSALLOCATOR_FRAMING_EX FramingEx1,
    IN PKSALLOCATOR_FRAMING_EX FramingEx2,
    IN GUID Bus1,
    IN GUID Bus2,
    IN OUT ULONG* CommonMemoryTypesCount,
    OUT GUID* CommonMemoryTypesList
    );
STDMETHODIMP_(BOOL)
FindAllPinMemoryTypesBasedOnBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN OUT ULONG* MemoryTypesCount,
    OUT GUID* MemoryTypesList
    );
STDMETHODIMP_(BOOL)
AddPinToPipeUnconditional(
    IN IKsPin* PipeKsPin,
    IN ULONG PipePinType,
    IN IKsPin* ConnectKsPin,
    IN ULONG ConnectPinType
    );
STDMETHODIMP_(BOOL)
GetFriendlyBusNameFromBusId(
    IN GUID BusId,
    OUT PTCHAR BusName
    );
STDMETHODIMP_(BOOL)
GetFriendlyLogicalMemoryTypeNameFromId(
    IN ULONG LogicalMemoryType,
    OUT PTCHAR LogicalMemoryName
    );
STDMETHODIMP_(BOOL)
DerefPipeFromPin(
    IN IPin* Pin
    );
STDMETHODIMP_(BOOL)
IsSpecialOutputReqs(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** OppositeKsPin,
    OUT ULONG* KsPinBufferSize,
    OUT ULONG* OppositeKsPinBufferSize
    );
STDMETHODIMP_(BOOL)
CanResizePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG RequestedSize
    );
STDMETHODIMP_(BOOL)
AdjustBufferSizeWithStepping(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    );
STDMETHODIMP_(VOID)
SetDefaultFramingExItems(
    IN OUT PKSALLOCATOR_FRAMING_EX FramingEx
    );
STDMETHODIMP_(BOOL)
CanAllocateMemoryType(
    IN GUID MemoryType
    );
STDMETHODIMP_(BOOL)
IsKernelModeConnection(
    IN IKsPin* KsPin
    );

#endif // _KSIPROXY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksproxy\ksinpin.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksinpin.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    Thomas O'Rourke (tomor) 2-Feb-1996
    George Shaw (gshaw)
    Bryan A. Woodruff (bryanw)

--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>
#include "ksiproxy.h"


CKsInputPin::CKsInputPin(
    TCHAR*      ObjectName,
    int         PinFactoryId,
    CLSID       ClassId,
    CKsProxy*   KsProxy,
    HRESULT*    hr,
    WCHAR*      PinName
    ) :
        CBaseInputPin(
            ObjectName,
            KsProxy,
            KsProxy,
            hr,
            PinName),
        m_PinHandle(NULL),
        m_DataTypeHandler(NULL),
        m_UnkInner(NULL),
        m_InterfaceHandler(NULL),
        m_MarshalData(TRUE),
        m_PinFactoryId(PinFactoryId),
        m_PropagatingAcquire(FALSE),
        m_PendingIoCount(0),
        m_PendingIoCompletedEvent(NULL),
        m_MarshalerList(
            NAME("Marshaler list"),
            DEFAULTCACHE,
            FALSE,
            FALSE),
        m_QualitySupport(FALSE),
        m_RelativeRefCount(1),
        m_pKsAllocator( NULL ),
        m_PinBusCacheInit(FALSE),
        m_fPipeAllocator (0),
        m_DeliveryError(FALSE)
/*++

Routine Description:

    The constructor for a pin. This function is passed an error return
    parameter so that initialization errors can be passed back. It calls the
    base class implementation constructor to initialize it's data memebers.

Arguments:

    ObjectName -
        This identifies the object for debugging purposes.

    PinFactoryId -
        Contains the pin factory identifier on the kernel filter that this
        pin instance represents.

    KsProxy -
        Contains the proxy on which this pin exists.

    hr -
        The place in which to put any error return.

    PinName -
        Contains the name of the pin to present to any query.

Return Value:

    Nothing.

--*/
{
    RtlZeroMemory(m_FramingProp, sizeof(m_FramingProp));
    RtlZeroMemory(m_AllocatorFramingEx, sizeof(m_AllocatorFramingEx));
    
    if (SUCCEEDED( *hr )) {
        TCHAR       RegistryPath[64];

        DECLARE_KSDEBUG_NAME(EventName);

        BUILD_KSDEBUG_NAME(EventName, _T("EvInPendingIo#%p"), this);
        m_PendingIoCompletedEvent =
            CreateEvent( 
                NULL,       // LPSECURITY_ATTRIBUTES lpEventAttributes
                FALSE,      // BOOL bManualReset
                FALSE,      // BOOL bInitialState
                KSDEBUG_NAME(EventName) );     // LPCTSTR lpName
        ASSERT(KSDEBUG_UNIQUE_NAME());

        if (m_PendingIoCompletedEvent) {
            *hr = KsProxy->GetPinFactoryCommunication(m_PinFactoryId, &m_OriginalCommunication);
            //
            // This is always initialized so that it can be queried, and changes
            // on actual device handle creation.
            //
            m_CurrentCommunication = m_OriginalCommunication;
            //
            // This type of pin will never actually be connected to, but should
            // have a media type selected.
            //
            if (m_CurrentCommunication == KSPIN_COMMUNICATION_NONE) {
                CMediaType      MediaType;

                *hr = GetMediaType(0, &MediaType);
                if (SUCCEEDED(*hr)) {
                    SetMediaType(&MediaType);
                }
            }
            //
            // Load any extra interfaces on the proxy that have been specified in
            // this pin factory id entry.
            //
            _stprintf(RegistryPath, TEXT("PinFactory\\%u\\Interfaces"), PinFactoryId);
            ::AggregateMarshalers(
                KsProxy->QueryDeviceRegKey(),
                RegistryPath,
                &m_MarshalerList,
                static_cast<IKsPin*>(this));
        } else {
            DWORD LastError = GetLastError();
            *hr = HRESULT_FROM_WIN32( LastError );
        }
    }
}

CKsInputPin::~CKsInputPin(
    )
/*++

Routine Description:

    The destructor for the pin instance. Cleans up any outstanding resources.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // Protect against a spurious delete because of aggregation. No need to
    // use an interlocking increment, as the object is being destroyed.
    //
    if (m_PinHandle) {
        //
        // Unload any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::UnloadVolatileInterfaces(&m_MarshalerList, TRUE);
        if (m_QualitySupport) {
            //
            // Reset this first to stop any further quality messages from
            // being acted on.
            //
            m_QualitySupport = FALSE;
            //
            // Remove previously established quality support.
            //
            ::EstablishQualitySupport(NULL, m_PinHandle, NULL);
            //
            // Ensure that the quality management forwarder flushes any
            // notifications.
            //
            static_cast<CKsProxy*>(m_pFilter)->QueryQualityForwarder()->KsFlushClient(static_cast<IKsPin*>(this));
        }
        
        //
        // Terminate any previous EOS notification that may have been started.
        //
        static_cast<CKsProxy*>(m_pFilter)->TerminateEndOfStreamNotification(
            m_PinHandle);
        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
    }
    if (m_PendingIoCompletedEvent) {
        CloseHandle(m_PendingIoCompletedEvent);
    }
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    if (m_InterfaceHandler) {
        m_InterfaceHandler->Release();
    }
    ::FreeMarshalers(&m_MarshalerList);

    SAFERELEASE( m_pKsAllocator );
    SAFERELEASE( m_pAllocator );

    for (ULONG Count = 0; Count < SIZEOF_ARRAY(m_AllocatorFramingEx); Count++) {
        if (m_AllocatorFramingEx[Count]) {
            for (ULONG Remainder = Count + 1; Remainder < SIZEOF_ARRAY(m_AllocatorFramingEx); Remainder++) {
                if (m_AllocatorFramingEx[Count] == m_AllocatorFramingEx[Remainder]) {
                    m_AllocatorFramingEx[Remainder] = NULL;
                }
            }
            delete m_AllocatorFramingEx[Count];
            m_AllocatorFramingEx[Count] = NULL;
        }
    }
}


STDMETHODIMP_(HANDLE)
CKsInputPin::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsObject::KsGetObjectHandle method. Returns the current device
    handle to the actual kernel pin this instance represents, if any such handle
    is open.

Arguments:

    None.

Return Value:

    Returns a handle, or NULL if no device handle has been opened, meaning this
    is an unconnected pin.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    return m_PinHandle;
}


STDMETHODIMP
CKsInputPin::KsQueryMediums(
    PKSMULTIPLE_ITEM* MediumList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryMediums method. Returns a list of Mediums
    which must be freed with CoTaskMemFree.

Arguments:

    MediumList -
        Points to the place in which to put the pointer to the list of
        Mediums. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_MEDIUMS,
        reinterpret_cast<PVOID*>(MediumList));
}


STDMETHODIMP
CKsInputPin::KsQueryInterfaces(
    PKSMULTIPLE_ITEM* InterfaceList
    )
/*++

Routine Description:

    Implements the IKsPin::KsQueryInterfaces method. Returns a list of
    Interfaces which must be freed with CoTaskMemFree.

Arguments:

    InterfaceList -
        Points to the place in which to put the pointer to the list of
        Interfaces. This must be freed with CoTaskMemFree if the function
        succeeds.

Return Value:

    Returns NOERROR if the list was retrieved, else an error.

--*/
{
    return ::KsGetMultiplePinFactoryItems(
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        KSPROPERTY_PIN_INTERFACES,
        reinterpret_cast<PVOID*>(InterfaceList));
}


STDMETHODIMP
CKsInputPin::KsCreateSinkPinHandle(
    KSPIN_INTERFACE&    Interface,
    KSPIN_MEDIUM&       Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsCreateSinkPinHandle method. This may be called from
    another pin in ProcessCompleteConnect, which is called from CompleteConnect.
    This allows a handle for a communications sink to always be created before a
    handle for a communications source, no matter which direction the data flow
    is going.

Arguments:

    Interface -
        Specifies the interface which has been negotiated.

    Medium -
        Specifies the medium which has been negotiated.

Return Value:

    Returns NOERROR if the handle was created, else some error.

--*/
{
    HRESULT     hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // This may have already been created if this end of the connection was
    // completed first because of data flow direction. This is not an error.
    //

    //
    // This connection uses a kernel mode data transfer, by definition.
    //
    m_MarshalData = FALSE;

    if (m_PinHandle) {
        return NOERROR;
    }
    hr = ::CreatePinHandle(
        Interface,
        Medium,
        NULL,
        &m_mt,
        static_cast<CKsProxy*>(m_pFilter),
        m_PinFactoryId,
        GENERIC_WRITE,
        &m_PinHandle);
    if (SUCCEEDED(hr)) {
        //
        // Assumes the caller knows what they are doing, and assigns
        // the communications type to this pin.
        //
        m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
        //
        // Save the current interface/medium
        //
        m_CurrentInterface = Interface;
        m_CurrentMedium = Medium;
        //
        // Load any extra interfaces based on the Property/Method/Event sets
        // supported by this object.
        //
        ::AggregateSets(
            m_PinHandle,
            static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
            &m_MarshalerList,
            static_cast<IKsPin*>(this));
        //
        // Establish the user mode quality manager support.
        //
        m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, (CKsProxy*)m_pFilter);
    }
    return hr;
}


STDMETHODIMP
CKsInputPin::KsGetCurrentCommunication(
    KSPIN_COMMUNICATION *Communication,
    KSPIN_INTERFACE *Interface,
    KSPIN_MEDIUM *Medium
    )
/*++

Routine Description:

    Implements the IKsPin::KsGetCurrentCommunication method. Returns the
    currently selected communications method, Interface, and Medium for this
    pin. These are a subset of the possible methods available to this pin,
    and is selected when the pin handle is being created.

Arguments:

    Communication -
        Optionally points to the place in which to put the current communications.

    Interface -
        Optionally points to the place in which to put the current Interface.

    Medium -
        Optionally points to the place in which to put the current Medium.

Return Value:

    Returns NOERROR if the pin handle has been created, else VFW_E_NOT_CONNECTED.
    Always returns current communication.

--*/
{
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    if (Communication) {
        *Communication = m_CurrentCommunication;
    }
    if (Interface) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Interface = m_CurrentInterface;
    }
    if (Medium) {
        if (!m_PinHandle) {
            return VFW_E_NOT_CONNECTED;
        }
        *Medium = m_CurrentMedium;
    }
    return NOERROR;
}


STDMETHODIMP
CKsInputPin::KsPropagateAcquire(
    )
/*++

Routine Description:

    Implements the IKsPin::KsPropagateAcquire method. Directs all the pins on
    the filter to attain the Acquire state, not just this pin. This is provided
    so that a Communication Source pin can direct the sink it is connected to to
    change state before the Source does. This forces the entire filter to which
    the sink belongs to change state so that any Acquire can be further
    propagated along if needed.

Arguments:

    None.

Return Value:

    Returns NOERROR if all pins could attain the Acquire state, else
    an error.

--*/
{
    HRESULT hr;
    //
    // Access is serialized within this call.
    //
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsInputPin::KsPropagateAcquire entry KsPin=%x"), static_cast<IKsPin*>(this) ));

    ::FixupPipe( static_cast<IKsPin*>(this), Pin_Input);

    hr = static_cast<CKsProxy*>(m_pFilter)->PropagateAcquire(static_cast<IKsPin*>(this), FALSE);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE CKsInputPin::KsPropagateAcquire exit KsPin=%x hr=%x"), 
            static_cast<IKsPin*>(this), hr ));

    return hr;
}   

STDMETHODIMP
CKsInputPin::ProcessCompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Completes the processing necessary to create a device handle on the
    underlying pin factory. This is called from CompleteConnect in order
    to negotiate a compatible Communication, Interface, and Medium, then
    create the device handle. The handle may have already been created if
    this was a Communication Sink.

    This can also be called from the NonDelegatingQueryInteface method in
    order to ensure that a partially complete connection has a device
    handle before returning an interface which has been aggregated.

Arguments:

    ReceivePin -
        The pin which is to receive the other end of this connection.

Return Value:

    Returns NOERROR if the pin could complete the connection request, else
    an error.

--*/
{
    HRESULT         hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The pin handle may have been created if this is a Communication Sink.
    // This is not an error.
    //

    if (!m_PinHandle) {
        IKsPin*         KsPin;
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        HANDLE          PeerPinHandle;

        //
        // Determine if the other end of the connection is also a proxy. If so,
        // then a compatible Communication, Interface, and Medium must be
        // determined, plus the other pin handle needs to be created first if
        // this side will be a Communication Source.
        //
        if (SUCCEEDED(ReceivePin->QueryInterface(__uuidof(IKsPin), reinterpret_cast<PVOID*>(&KsPin)))) {
            //
            // The only confusion is when this end can be both a Source and a
            // Sink. Note that this does not handle the case wherein a pin can
            // also be a Bridge at the same time. That is probably an invalid
            // and confusing possibility. It is also mostly the same as a Sink.
            //
            if (m_OriginalCommunication == KSPIN_COMMUNICATION_BOTH) {
                m_CurrentCommunication = ::ChooseCommunicationMethod(static_cast<CBasePin*>(this), KsPin);
            }
            //
            // Run through the list of Interfaces and Mediums each pin supports,
            // choosing the first one that is found compatible. This in no way
            // attempts to preserve the use of Interfaces and Mediums, and
            // relies on kernel filters to present them in best order first.
            //
            if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), KsPin, &Interface))) {
                hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), KsPin, &Medium);
            }
            if (SUCCEEDED(hr)) {
                if (hr == S_FALSE) {
                    //
                    // This is a usermode filter, but needs to support mediums
                    // because it wants to connect with a non-ActiveMovie
                    // medium. This should really be a kernelmode filter.
                    //
                    PeerPinHandle = NULL;
                    m_MarshalData = TRUE;
                } else {
                    //
                    // If this is a Communication Source, the Sink pin handle must
                    // be created first. Else the Sink handle is NULL (meaning that
                    // this is the Sink pin).
                    //
                    if (m_CurrentCommunication == KSPIN_COMMUNICATION_SOURCE) {
                        IKsObject*      KsObject;

                        hr = KsPin->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&KsObject));
                        if (SUCCEEDED(hr)) {
                            hr = KsPin->KsCreateSinkPinHandle(Interface, Medium);
                            PeerPinHandle = KsObject->KsGetObjectHandle();
                            KsObject->Release();
                        }
                    } else {
                        PeerPinHandle = NULL;
                    }
                    m_MarshalData = FALSE;
                }
            }
            KsPin->Release();
            if (FAILED(hr)) {
                return hr;
            }
        } else {
            //
            // If the other end of the connection is not a proxy, then this pin
            // must be a Communication Sink. It must also use the default
            // Interface and Dev I/O Medium.
            //
            m_CurrentCommunication = KSPIN_COMMUNICATION_SINK;
            if (FAILED(hr = FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
                return hr;
            }
            SetDevIoMedium(static_cast<IKsPin*>(this), &Medium);
            PeerPinHandle = NULL;
        }
        hr = ::CreatePinHandle(
            Interface,
            Medium,
            PeerPinHandle,
            &m_mt,
            static_cast<CKsProxy*>(m_pFilter),
            m_PinFactoryId,
            GENERIC_WRITE,
            &m_PinHandle);
        if (SUCCEEDED(hr)) {
            //
            // Save the current interface/medium
            //
            m_CurrentInterface = Interface;
            m_CurrentMedium = Medium;
            //
            // Load any extra interfaces based on the Property/Method/Event sets
            // supported by this object.
            //
            ::AggregateSets(
                m_PinHandle,
                static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                &m_MarshalerList,
                static_cast<IKsPin*>(this));
            //
            // Establish the user mode quality manager support.
            //
            m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, static_cast<CKsProxy*>(m_pFilter));
        }
    } else {
        hr = NOERROR;
    }

    //
    // Create an instance of the interface handler.
    //

    if (SUCCEEDED(hr) &&
        (NULL == m_InterfaceHandler) &&
        (m_CurrentCommunication != KSPIN_COMMUNICATION_BRIDGE)) {

        //
        // We must create an interface handler, if not, then
        // return the error.
        //

        hr =
            CoCreateInstance(
                m_CurrentInterface.Set,
                NULL,
#ifdef WIN9X_KS
                CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
                __uuidof(IKsInterfaceHandler),
                reinterpret_cast<PVOID*>(&m_InterfaceHandler));

        if (m_InterfaceHandler) {
            m_InterfaceHandler->KsSetPin( static_cast<IKsPin*>(this) );
        } else {
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::ProcessCompleteConnect failed to create interface handler"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName ));
        }
    }
    
    //
    // Finally, if we're marshalling data and if everything has succeeded
    // up to this point, then create the filter's I/O thread if necessary.
    //
    
    if (SUCCEEDED(hr) && m_MarshalData) {
        hr = static_cast<CKsProxy*>(m_pFilter)->StartIoThread();
    }
    if (SUCCEEDED(hr)) {
        //
        // This pin may generate EOS notifications, which must be
        // monitored so that they can be collected and used to
        // generate an EC_COMPLETE graph notification.
        //
        hr = static_cast<CKsProxy*>(m_pFilter)->InitiateEndOfStreamNotification(
            m_PinHandle);
    }
    
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    Implement the IUnknown::QueryInterface method. This just passes the query
    to the owner IUnknown object, which may pass it to the nondelegating
    method implemented on this object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE.

--*/
{
    HRESULT hr;

    hr = GetOwner()->QueryInterface(riid, ppv);
    return hr;
}


STDMETHODIMP_(ULONG)
CKsInputPin::AddRef(
    )
/*++

Routine Description:

    Implement the IUnknown::AddRef method. This just passes the AddRef
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    InterlockedIncrement((PLONG)&m_RelativeRefCount);
    return GetOwner()->AddRef();
}


STDMETHODIMP_(ULONG)
CKsInputPin::Release(
    )
/*++

Routine Description:

    Implement the IUnknown::Release method. This just passes the Release
    to the owner IUnknown object. Normally these are just implemented
    with a macro in the header, but this is easier to debug when reference
    counts are a problem

Arguments:

    None.

Return Value:

    Returns the current reference count.

--*/
{
    ULONG   RefCount;

    RefCount = GetOwner()->Release();
    //
    // Ensure that the proxy was not just deleted before trying to
    // delete this pin.
    //
    if (RefCount && !InterlockedDecrement((PLONG)&m_RelativeRefCount)) {
        //
        // This was a connection release from a pin already destined
        // for destruction. The filter had decremented the relative
        // refcount in order to delete it, and found that there was
        // still an outstanding interface being used. So this delayed
        // deletion occurs.
        //
        delete this;
    }
    return RefCount;
}


STDMETHODIMP
CKsInputPin::NonDelegatingQueryInterface(
    REFIID  riid,
    PVOID*  ppv
    )
/*++

Routine Description:

    Implement the CUnknown::NonDelegatingQueryInterface method. This
    returns interfaces supported by this object, or by the underlying
    pin class object. This includes any interface aggregated by the
    pin.

Arguments:

    riid -
        Contains the interface to return.

    ppv -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR or E_NOINTERFACE, or possibly some memory error.

--*/
{
    if (riid == __uuidof(ISpecifyPropertyPages)) {
        return GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv);
    } else if (riid == __uuidof(IKsObject)) {
        return GetInterface(static_cast<IKsObject*>(this), ppv);
    } else if (riid == __uuidof(IKsPin) || riid == __uuidof(IKsPinEx)) {
        return GetInterface(static_cast<IKsPinEx*>(this), ppv);
    } else if (riid == __uuidof(IKsPinPipe)) {
        return GetInterface(static_cast<IKsPinPipe*>(this), ppv);
    } else if (riid == __uuidof(IKsAggregateControl)) {
        return GetInterface(static_cast<IKsAggregateControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPropertySet)) {
        //
        // In order to allow another filter to access information on the
        // underlying device handle during its CompleteConnect processing,
        // force the connection to be completed now if possible.
        //
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsPropertySet*>(this), ppv);
    } else if (riid == __uuidof(IKsControl)) {
        if (m_Connected && !m_PinHandle) {
            ProcessCompleteConnect(m_Connected);
        }
        return GetInterface(static_cast<IKsControl*>(this), ppv);
    } else if (riid == __uuidof(IKsPinFactory)) {
        return GetInterface(static_cast<IKsPinFactory*>(this), ppv);
    } else if (riid == __uuidof(IStreamBuilder)) {
        //
        // Sink & Source pins are normally forced to be rendered, unless
        // there are already enough instances.
        //
        if ((m_CurrentCommunication & KSPIN_COMMUNICATION_BOTH) &&
            static_cast<CKsProxy*>(m_pFilter)->DetermineNecessaryInstances(m_PinFactoryId)) {
            return CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        }
        //
        // Returning this interface allows a Bridge and None pin to be
        // left alone by the graph builder.
        //
        return GetInterface(static_cast<IStreamBuilder*>(this), ppv);
    } else {
        HRESULT hr;
        
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (SUCCEEDED(hr)) {
            return hr;
        }
    }
    //
    // In order to allow another filter to access information on the
    // underlying device handle during its CompleteConnect processing,
    // force the connection to be completed now if possible. The
    // assumption is that if there is a Connected pin, but no device
    // handle yet, then this pin is part way through the connection
    // process, and should force completion in case the aggregated
    // interface wants to interact with the device. This must be done
    // before searching the list, since a volatile interface is only
    // added to the list when the the connection is completed.
    //
    if (m_Connected && !m_PinHandle) {
        ProcessCompleteConnect(m_Connected);
    }
    for (POSITION Position = m_MarshalerList.GetHeadPosition(); Position;) {
        CAggregateMarshaler*    Aggregate;

        Aggregate = m_MarshalerList.GetNext(Position);
        if ((Aggregate->m_iid == riid) || (Aggregate->m_iid == GUID_NULL)) {
            HRESULT hr;

            hr = Aggregate->m_Unknown->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr)) {
                return hr;
            }
        }
    }
    return E_NOINTERFACE;
}


STDMETHODIMP
CKsInputPin::Disconnect(
    )
/*++

Routine Description:

    Override the CBaseInput::Disconnect method. This does not call the base
    class implementation. It disconnects both Source and Sink pins, in
    addition to Bridge pins, which only have handles, and not connected pin
    interfaces, which traditionally is how connection is indicated. It
    specifically does not release the connected pin, since a Bridge may not
    have a connected pin. This is always done in BreakConnect.

Arguments:

    None.

Return Value:

    Returns S_OK, or S_FALSE if the pin was not connected or VFW_E_NOT_STOPPED
    if the filter is not in a Stop state.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Disconnect"), m_pName ));
    //
    // A disconnection can only occur if the filter is in a Stop state.
    //
    if (!IsStopped()) {
        return VFW_E_NOT_STOPPED;
    }
    //
    // A Bridge pin can be connected if it just has a device handle. It can't
    // actually report to ActiveMovie this connection, but it can still be
    // connected (with a NULL ReceivePin) and disconnected.
    //
    if (m_Connected || m_PinHandle) {
        //
        // Note that this does not release the connected pin, as that is done
        // in BreakConnect. This is because there may not be a pin in the case
        // of a Bridge.
        //
        BreakConnect();
        SAFERELEASE( m_pAllocator );
        return S_OK;
    }
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::ConnectionMediaType(
    AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Override the CBasePin::ConnectionMediaType method. Returns the
    current media type, if connected. The reason for overriding this
    is because IsConnected() is not a virtual function, and is used
    in the base classes to determine if a media type should be returned.

Arguments:

    AmMediaType -
        The place in which to return the media type.

Return Value:

    Returns NOERROR if the type was returned, else a memory or connection
    error.

--*/
{
    CAutoLock AutoLock(m_pLock);

    if (IsConnected()) {
        CopyMediaType(AmMediaType, &m_mt);
        return S_OK;
    }
    static_cast<CMediaType*>(AmMediaType)->InitMediaType();
    return VFW_E_NOT_CONNECTED;
}


STDMETHODIMP
CKsInputPin::Connect(
    IPin*                   ReceivePin,
    const AM_MEDIA_TYPE*    AmMediaType
    )
/*++

Routine Description:

    Override the CBaseInput::Connect method. Intercepts a connection
    request in order to perform special processing for a Bridge pin. A
    Bridge has no ReceivePin, and uses the first available Interface
    and a Dev I/O Medium. A normal connection request is just passed
    through to the base class.

Arguments:

    ReceivePin -
        Contains the pin on the other end of the proposed connection.
        This is NULL for a Bridge pin.

    AmMediaType -
        Contains the media type for the connection, else NULL if the
        media type is to be negotiated.

Return Value:

    Returns NOERROR if the connection was made, else some error.

--*/
{
#ifdef DEBUG
    PIN_INFO    pinInfo;
    ReceivePin->QueryPinInfo( &pinInfo );
    FILTER_INFO filterInfo;
    filterInfo.achName[0] = 0;
    if (pinInfo.pFilter) {
        pinInfo.pFilter->QueryFilterInfo( &filterInfo );
        if (filterInfo.pGraph) {
            filterInfo.pGraph->Release();
        }
        pinInfo.pFilter->Release();
    }
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Connect( %s(%s) )"), m_pName, filterInfo.achName, pinInfo.achName ));
#endif // DEBUG

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // The only reason to intercept the base class implementation is to
    // deal with a Bridge pin.
    //
    if (m_CurrentCommunication == KSPIN_COMMUNICATION_BRIDGE) {
        KSPIN_INTERFACE Interface;
        KSPIN_MEDIUM    Medium;
        HRESULT         hr;

        //
        // A Bridge pin does not have any other end to the connection.
        //
        if (ReceivePin) {
            return E_FAIL;
        }
        //
        // Normally this would check m_Connected, but since there is no
        // connection pin, it must check for a device handle.
        //
        if (m_PinHandle) {
            return VFW_E_ALREADY_CONNECTED;
        }
        if (!IsStopped()) {
            return VFW_E_NOT_STOPPED;
        }
        //
        // Find the first Interface and Medium.
        //
        if (SUCCEEDED(hr = ::FindCompatibleInterface(static_cast<IKsPin*>(this), NULL, &Interface))) {
            hr = ::FindCompatibleMedium(static_cast<IKsPin*>(this), NULL, &Medium);
        }
        if (FAILED(hr)) {
            return hr;
        }
        //
        // If there is no media type, just acquire the first one.
        //
        if (!AmMediaType) {
            CMediaType      MediaType;

            if (SUCCEEDED(hr = GetMediaType(0, &MediaType))) {
                hr = SetMediaType(&MediaType);
            }
        } else {
            hr = SetMediaType(static_cast<const CMediaType*>(AmMediaType));
        }
        if (SUCCEEDED(hr)) {
            hr = ::CreatePinHandle(
                Interface,
                Medium,
                NULL,
                &m_mt,
                static_cast<CKsProxy*>(m_pFilter),
                m_PinFactoryId,
                GENERIC_WRITE,
                &m_PinHandle);
            if (SUCCEEDED(hr)) {
                //
                // Load any extra interfaces based on the Property/Method/Event sets
                // supported by this object.
                //
                ::AggregateSets(
                    m_PinHandle,
                    static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
                    &m_MarshalerList,
                    static_cast<IKsPin*>(this));
                //
                // Establish the user mode quality manager support.
                //
                m_QualitySupport = ::EstablishQualitySupport(static_cast<IKsPin*>(this), m_PinHandle, static_cast<CKsProxy*>(m_pFilter));
                //
                // Create a new instance of this pin if necessary.
                //
                static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
            }
        }
        return hr;
    }
    HRESULT hr = CBasePin::Connect(ReceivePin, AmMediaType);
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::Connect() returns 0x%p"), m_pName, hr ));
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryInternalConnections(
    IPin**  PinList,
    ULONG*  PinCount
    )
/*++

Routine Description:

    Override the CBasePin::QueryInternalConnections method. Returns a list of
    pins which are related to this pin through topology.

Arguments:

    PinList -
        Contains a list of slots in which to place all pins related to this
        pin through topology. Each pin returned must be reference counted. This
        may be NULL if PinCount is zero.

    PinCount -
        Contains the number of slots available in PinList, and should be set to
        the number of slots filled or neccessary.

Return Value:

    Returns E_NOTIMPL to specify that all inputs go to all outputs and vice versa,
    S_FALSE if there is not enough slots in PinList, or NOERROR if the mapping was
    placed into PinList and PinCount adjusted.

--*/
{
    return static_cast<CKsProxy*>(m_pFilter)->QueryInternalConnections(m_PinFactoryId, m_dir, PinList, PinCount);
}


HRESULT
CKsInputPin::Active(
    )
/*++

Routine Description:

    Override the CBasePin::Active method. Propagate activation to Communication
    Sinks before applying it to this pin. Also guard against re-entrancy caused
    by a cycle in a graph.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);
#ifdef DEBUG
    if (m_PinHandle) {
        KSPROPERTY  Property;
        ULONG       BasicSupport;
        ULONG       BytesReturned;

        //
        // Ensure that if a pin supports a clock, that it also supports State changes.
        // This appears to currently be a common broken item.
        //
        Property.Set = KSPROPSETID_Stream;
        Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
        Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;
        hr = ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            &BasicSupport,
            sizeof(BasicSupport),
            &BytesReturned);
        if (SUCCEEDED(hr) && (BasicSupport & KSPROPERTY_TYPE_GET)) {
            Property.Set = KSPROPSETID_Connection;
            Property.Id = KSPROPERTY_CONNECTION_STATE;
            hr = ::KsSynchronousDeviceControl(
                m_PinHandle,
                IOCTL_KS_PROPERTY,
                &Property,
                sizeof(Property),
                &BasicSupport,
                sizeof(BasicSupport),
                &BytesReturned);
            if (FAILED(hr) || !(BasicSupport & KSPROPERTY_TYPE_SET)) {
                DbgLog((
                    LOG_ERROR, 
                    0, 
                    TEXT("%s(%s)::Active - Pin supports a clock but not State"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName ));
            }
        }
    }
#endif // DBG
    //
    // If this is re-entered while it is propagating the state change, then
    // it implies a cycle in the graph, and therefore is complete. This is
    // translated as either a transition from Stop through Acquire to Pause
    // (where the filter pins may already be in an Acquire state), or Run to
    // Pause.
    //
    if (m_PropagatingAcquire) {
        return NOERROR;
    }
    m_PropagatingAcquire = TRUE;
    //
    // This event is used when inactivating the pin, and may be needed to
    // wait for outstanding I/O to be completed. It must be reset, because
    // a previous transition may not have waited on it, and it will always
    // be set when the state is Stop, and the last I/O has been completed.
    //
    // Note that the filter state has been set to Pause before the Active
    // method is called, so I/O which is started and completes will not
    // accidentally set the event again.
    //
    ResetEvent(m_PendingIoCompletedEvent);
    //
    // Change any Sink first, then pass the state change to the device handle.
    //

    //
    // No need to call the base class here, it does nothing.
    //

    hr = ::Active(static_cast<IKsPin*>(this), Pin_Input, m_PinHandle, m_CurrentCommunication,
                  m_Connected, &m_MarshalerList, static_cast<CKsProxy*>(m_pFilter) );
    
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::Active returning %08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        hr ));

    m_PropagatingAcquire = FALSE;
    return hr;
}


HRESULT
CKsInputPin::Run(
    REFERENCE_TIME  tStart
    )
/*++

Routine Description:

    Override the CBasePin::Run method. This is translated as a transition
    from Pause to Run. The base classes already ensure that an Active is sent
    before a Run.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;
    CAutoLock   AutoLock(m_pLock);

    //
    // Pass the state change to the device handle.
    //
    if (SUCCEEDED(hr = ::Run(m_PinHandle, tStart, &m_MarshalerList))) {
        hr = CBasePin::Run(tStart);
    }
    return hr;
}


HRESULT
CKsInputPin::Inactive(
    )
/*++

Routine Description:

    Override the CBasePin::Inactive method. This is translated as a transition
    from Run to Stop or Pause to Stop. There does not appear to be a method of
    directly setting the state from Run to Pause though.

Arguments:

    None.

Return Value:

    Returns NOERROR if the transition was made, else some error.

--*/
{
    HRESULT     hr;

    //
    // Pass the state change to the device handle.
    //
    hr = ::Inactive(m_PinHandle, &m_MarshalerList);
    {
        //
        // If there is pending I/O, then the state transition must wait
        // for it to complete. The event is signalled when m_PendingIoCount
        // transitions to zero, and when IsStopped() is TRUE.
        //
        // Note that the filter state has been set to Stopped before the
        // Inactive method is called.
        //
        // This critical section will force synchronization with any
        // outstanding ReceiveMultiple call, such that it will have
        // looked at the filter state and exited.
        //
        m_IoCriticalSection.Lock();
        m_IoCriticalSection.Unlock();
        if (m_PendingIoCount) {
            WaitForSingleObjectEx(m_PendingIoCompletedEvent, INFINITE, FALSE);
        }
        ::UnfixupPipe(static_cast<IKsPin*>(this), Pin_Input);
        hr = CBaseInputPin::Inactive();
    }
    //
    // Reset the state of any previous delivery error.
    //
    m_DeliveryError = FALSE;
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryAccept(
    const AM_MEDIA_TYPE*    AmMediaType
    )
/*++

Routine Description:

    Implement the CBasePin::QueryAccept method. Determines if the proposed
    media type is currently acceptable to the pin. If currently streaming,
    this implies that a change of media types will occur in the stream.
    Note that this function does not lock the object, as it is expected
    to be called asynchronously by a knowledgeable client at a point in
    which the connection will not be broken. If IAMStreamConfig::SetFormat
    has been used to set a specific media type, then QueryAccept will only
    accept the type set.

Arguments:

    AmMediatype -
        The media type to check.

Return Value:

    Returns S_OK if the media type can currently be accepted, else S_FALSE.

--*/
{
    //
    // If this is called before connecting pins, or the pin is stopped,
    // then just check the media type. The function definition does not
    // contain any guidance as to what to do if the pin is not connected.
    //
    if (!m_PinHandle || IsStopped()) {
        return CheckMediaType(static_cast<const CMediaType*>(AmMediaType));
    }
    return ::QueryAccept(m_PinHandle, NULL, AmMediaType);
}


STDMETHODIMP
CKsInputPin::NewSegment(
    REFERENCE_TIME  Start,
    REFERENCE_TIME  Stop,
    double          Rate
    )
/*++

Routine Description:

    Temporary function!!

--*/
{
    KSRATE_CAPABILITY   RateCapability;
    KSRATE              PossibleRate;
    ULONG               BytesReturned;
    HRESULT             hr;

    RateCapability.Property.Set = KSPROPSETID_Stream;
    RateCapability.Property.Id  = KSPROPERTY_STREAM_RATECAPABILITY;
    RateCapability.Property.Flags = KSPROPERTY_TYPE_GET;
    // supposed to be Start == 0 && Stop == -1
    if (Start > Stop) {
        RateCapability.Rate.Flags = KSRATE_NOPRESENTATIONSTART | KSRATE_NOPRESENTATIONDURATION;
    } else {
        RateCapability.Rate.Flags = 0;
        RateCapability.Rate.PresentationStart = Start;
        RateCapability.Rate.Duration = Stop - Start;
    }
    //
    // This only works for the standard streaming interface.
    //
    ASSERT(m_CurrentInterface.Set == KSINTERFACESETID_Standard);
    ASSERT(m_CurrentInterface.Id == KSINTERFACE_STANDARD_STREAMING);
    RateCapability.Rate.Interface.Set = KSINTERFACESETID_Standard;
    RateCapability.Rate.Interface.Id = KSINTERFACE_STANDARD_STREAMING;
    //
    // + 0.5 for rounding.
    //
    RateCapability.Rate.Rate = (LONG)(Rate * 1000 + 0.5);
    RateCapability.Rate.Interface.Flags = 0;
    hr = ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_PROPERTY,
        &RateCapability,
        sizeof(RateCapability),
        &PossibleRate,
        sizeof(PossibleRate),
        &BytesReturned);
    if (SUCCEEDED(hr)) {
        ASSERT(BytesReturned == sizeof(PossibleRate));
        //
        // Some drivers do not seem to be able to return the actual data.
        //
        if (BytesReturned != sizeof(PossibleRate)) {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }
        if (PossibleRate.Rate != 1000) {
            //
            // This should also pass this downstream if != 1000. However,
            // except for topology, there is no way to determine where to
            // send the request.
            //
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::NewSegment: Rate change is only partially supported: %d"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                PossibleRate.Rate));
        }
        RateCapability.Property.Id  = KSPROPERTY_STREAM_RATE;
        RateCapability.Property.Flags = KSPROPERTY_TYPE_SET;
        //
        // Ask only for what the filter claimed it could do.
        //
        PossibleRate.Rate = 1000 + (RateCapability.Rate.Rate - PossibleRate.Rate);
        hr = ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_PROPERTY,
            &RateCapability.Property,
            sizeof(RateCapability.Property),
            &PossibleRate,
            sizeof(PossibleRate),
            &BytesReturned);
    }
    if (hr == HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) ||
        hr == HRESULT_FROM_WIN32( ERROR_SET_NOT_FOUND )) {
        hr = S_OK;        
    }
    return hr;
}


STDMETHODIMP
CKsInputPin::QueryId(
    LPWSTR* Id
    )
/*++

Routine Description:

    Override the CBasePin::QueryAccept method. This returns a unique identifier
    for a particular pin. This identifier is equivalent to the pin name in the
    base class implementation, but does not work if the kernel filter does not
    explicitly name pins, since multiple pins will have duplicate names, and
    graph save/load will not be able to rebuild a graph. The IBaseFilter::FindPin
    method is also implemented by the proxy to return the proper pin based on
    the same method here. This is based on the factory identifier. If multiple
    instances of a pin exist, then there will be duplicates. But new pins are
    inserted at the front of the pin list, so they will be found first, and
    graph building will still work.

Arguments:

    Id -
        The place in which to return a pointer to an allocated string containing
        the unique pin identifier.

Return Value:

    Returns NOERROR if the string was returned, else an allocation error.

--*/
{
    *Id = reinterpret_cast<WCHAR*>(CoTaskMemAlloc(8*sizeof(**Id)));
    if (*Id) {
        swprintf(*Id, L"%u", m_PinFactoryId);
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


HRESULT
CKsInputPin::CheckMediaType(
    const CMediaType*   MediaType
    )
/*++

Routine Description:

    Implement the CBasePin::CheckMediaType method. Just uses the common method
    on the filter with the Pin Factory Identifier.

Arguments:

    Mediatype -
        The media type to check.

Return Value:

    Returns NOERROR if the media type was valid, else some error.

--*/
{
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::CheckMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));
    return static_cast<CKsProxy*>(m_pFilter)->CheckMediaType(static_cast<IPin*>(this), m_PinFactoryId, MediaType);
}

STDMETHODIMP
CKsInputPin::SetStreamMediaType(
    const CMediaType *MediaType
    )

/*++

Routine Description:
    Sets the current stream media type.  This function is used by the
    SetMediaType() method and by the Receive() method via. the 
    ReceiveMultiple() method.
    
    Loads a media type handler corresponding to the subtype or type 
    of the media and sets the current stream media type member.  

Arguments:
    const CMediaType *MediaType - pointer to a media type

Return:

--*/

{
    //
    // Set the current stream media type.  Note that initially this
    // type is the same as the pin type, however, this member will change
    // for in-stream data format changes on filters that include such 
    // support.
    //
    
    //
    // Discard any previous data type handler.
    //
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }

    ::OpenDataHandler(MediaType, static_cast<IPin*>(this), &m_DataTypeHandler, &m_UnkInner);

    return S_OK;
}


HRESULT
CKsInputPin::SetMediaType(
    const CMediaType*   MediaType
    )
/*++

Routine Description:

    Override the CBasePin::SetMediaType method. This may be set either 
    before a connection is established, to indicate the media type to use 
    in the connection, or after the connection has been established in 
    order to change the current media type (which is done after a 
    QueryAccept of the media type).

    If the connection has already been made, then the call is directed at 
    the device handle in an attempt to change the current media type. 
    This method then calls the SetStreamMediaType() method which will set 
    the  media type for the kernel pin handle (if connected) and sets the 
    data  handler.  Finally, it calls the base class to actually modify the 
    media type, which does not actually fail, unless there is no memory.
    

Arguments:

    Mediatype -
        The media type to use on the pin.

Return Value:

    Returns NOERROR if the media type was validly set, else some error. If
    there is no pin handle yet, the function will likely succeed.

--*/
{
    HRESULT  hr;
    
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::SetMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Only pass this request to the device if there is actually a connection
    // currently.
    //
    if (m_PinHandle) {
        if (FAILED(hr = ::SetMediaType(m_PinHandle, MediaType))) {
            return hr;
        }
    }

    if (FAILED( hr = SetStreamMediaType( MediaType ) )) {
        return hr;        
    } else {
        return CBasePin::SetMediaType(MediaType);
    }
}


HRESULT
CKsInputPin::CheckConnect(
    IPin* Pin
    )
/*++

Routine Description:

    Override the CBasePin::CheckConnect method. First check data flow with
    the base class, then check compatible Communication types.

Arguments:

    Pin -
        The pin which is being checked for compatibility to connect to this
        pin.

Return Value:

    Returns NOERROR if the pin in compatible, else some error.

--*/
{
    HRESULT hr;

    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::CheckConnect"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    if (SUCCEEDED(hr = CBasePin::CheckConnect(Pin))) {
        hr = ::CheckConnect(Pin, m_CurrentCommunication);
    }
    return hr;
}


HRESULT
CKsInputPin::CompleteConnect(
    IPin* ReceivePin
    )
/*++

Routine Description:

    Override the CBasePin::Complete method. First try to create the device
    handle, which possibly tries to create a Sink handle on the receiving
    pin, then call the base class. If this all succeeds, generate a new
    unconnected pin instance if necessary.

Arguments:

    ReceivePin -
        The pin to complete connection on.

Return Value:

    Returns NOERROR if the connection was completed, else some error.

--*/
{
    HRESULT     hr;

    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Create devices handles first, then allow the base class to complete
    // the operation.
    //
    if (SUCCEEDED(hr = ProcessCompleteConnect(ReceivePin))) {
        hr = CBasePin::CompleteConnect(ReceivePin);
        if (SUCCEEDED(hr)) {
            //
            // Generate a new unconnected instance of this pin if there
            // are more possible instances available.
            //
            static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
        }
    }
    return hr;
}


HRESULT
CKsInputPin::BreakConnect(
    )
/*++

Routine Description:

    Override the CBasePin::BreakConnect method. Does not call the base class
    because it does not do anything. Releases any device handle. Also note that
    the connected pin is released here. This means that Disconnect must also
    be overridden in order to not release a connected pin.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    DbgLog(( LOG_CUSTOM1, 1, TEXT("CKsInputPin(%s)::BreakConnect"), m_pName ));
    //
    // This is not guarded by a critical section. It is assumed the caller
    // is synchronizing with other access to the filter pin.
    //
    // Update pipes.
    //
    
    //
    // Update the system of pipes - reflect disconnect.
    //
    BOOL    FlagBypassBaseAllocators = FALSE;

    if ( KsGetPipe(KsPeekOperation_PeekOnly) ) {
        ::DisconnectPins(static_cast<IKsPin*>(this), Pin_Input, &FlagBypassBaseAllocators);
    }
    
    // Close the device handle if it happened to be open. This is called at
    // various times, and may not have actually opened a handle yet.
    //
    if (m_PinHandle) {
        if (m_QualitySupport) {
            //
            // Reset this first to stop any further quality messages from
            // being acted on.
            //
            m_QualitySupport = FALSE;
            //
            // Remove previously established quality support.
            //
            ::EstablishQualitySupport(NULL, m_PinHandle, NULL);
            //
            // Ensure that the quality management forwarder flushes any
            // notifications.
            //
            static_cast<CKsProxy*>(m_pFilter)->QueryQualityForwarder()->KsFlushClient(static_cast<IKsPin*>(this));
        }
        //
        // Terminate any previous EOS notification that may have been started.
        //
        static_cast<CKsProxy*>(m_pFilter)->TerminateEndOfStreamNotification(
            m_PinHandle);
        ::SetSyncSource( m_PinHandle, NULL );
        CloseHandle(m_PinHandle);
        m_PinHandle = NULL;
        //
        // Mark all volatile interfaces as reset. Only Static interfaces,
        // and those Volatile interfaces found again will be set. Also
        // notify all interfaces of graph change.
        //
        ResetInterfaces(&m_MarshalerList);
    }
    m_MarshalData = TRUE;
    
    //
    // Reset the current Communication for the case of a Both.
    //
    m_CurrentCommunication = m_OriginalCommunication;
    //
    // There may not actually be a connection pin, such as when a connection
    // was not completed, or when this is a Bridge.
    //
    if (m_Connected) {
        m_Connected->Release();
        m_Connected = NULL;
    }
    //
    // If an interface handler was instantiated, release it.
    //
    if (m_InterfaceHandler) {
        m_InterfaceHandler->Release();
        m_InterfaceHandler = NULL;
    }
    //
    // If an data handler was instantiated, release it.
    //
    if (m_DataTypeHandler) {
        m_DataTypeHandler = NULL;
        SAFERELEASE( m_UnkInner );
    }
    //
    // Remove this pin instance if there is already an unconnected pin of
    // this type.
    //
    static_cast<CKsProxy*>(m_pFilter)->GeneratePinInstances();
    return NOERROR;
}


HRESULT
CKsInputPin::GetMediaType(
    int         Position,
    CMediaType* MediaType
    )
/*++

Routine Description:

    Override the CBasePin::GetMediaType method. Returns the specified media
    type on the Pin Factory Id.

Arguments:

    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    MediaType -
        The media type to initialize.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    DbgLog((
        LOG_TRACE, 
        2, 
        TEXT("%s(%s)::GetMediaType"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName ));

    return ::KsGetMediaType(
        Position,
        static_cast<AM_MEDIA_TYPE*>(MediaType),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId);
}


STDMETHODIMP_(IMemAllocator *)
CKsInputPin::KsPeekAllocator(
    KSPEEKOPERATION Operation
    )

/*++

Routine Description:
    Returns the assigned allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    KSPEEKOPERATION Operation -
        if KsPeekOperation_AddRef is specified, the m_pAllocator is
        AddRef()'d (if not NULL) before returning.

Return:
    the value of m_pAllocator

--*/

{
    if ((Operation == KsPeekOperation_AddRef) && (m_pAllocator)) {
        m_pAllocator->AddRef();
    }
    return m_pAllocator;
}


STDMETHODIMP
CKsInputPin::KsRenegotiateAllocator(
    )

/*++

Routine Description:
    This method is not valid for input pins.

Arguments:
    None.

Return:
    E_FAIL

--*/

{
    DbgLog((
        LOG_TRACE,
        0,
        TEXT("KsRenegotiateAllocator method is only valid for output pins.")));
    return E_FAIL;
}


STDMETHODIMP
CKsInputPin::KsReceiveAllocator(
    IMemAllocator *MemAllocator
    )

/*++

Routine Description:
    This routine is defined for all pins but is only valid for output pins.

Arguments:
    IMemAllocator *MemAllocator -
        Ignored.

Return:
    E_FAIL

--*/

{
    if (MemAllocator) {
        MemAllocator->AddRef();
    }
    // Do this after the AddRef() above in case MemAllocator == m_pAllocator
    SAFERELEASE( m_pAllocator );
    m_pAllocator = MemAllocator;
    return (S_OK);
}



STDMETHODIMP
CKsInputPin::NotifyAllocator(
    IMemAllocator *Allocator,
    BOOL ReadOnly
    )
/*++

Routine Description:

    Override the CBaseInputPin::NotifyAllocator method.

Arguments:

    Allocator -
        The new allocator to use.

    ReadOnly -
        Specifies whether the buffers are read-only.

            
NOTE:

    With new pipe-based allocators design, the only connection that
    should be handled here - is from user mode output pin to a kernel mode pin.
    
    Also, the old design expected that Allocator is assigned by User mode pin.
    We are not changing that until User mode components are upgraded to use new
    pipes design.
            
Return Value:

    Returns NOERROR.

--*/
{
    HRESULT                    hr;
    IKsAllocatorEx*            InKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx;
    ALLOCATOR_PROPERTIES       Properties, ActualProperties;
    PKSALLOCATOR_FRAMING_EX    InFramingEx;
    FRAMING_PROP               InFramingProp;
    KS_FRAMING_FIXED           InFramingExFixed;
    ULONG                      NumPinsInPipe;
    GUID                       Bus;
    ULONG                      FlagChange;
    ULONG                      PropertyPinType;
    BOOL                       IsSpecialOutputRequest;
    IKsPin*                    OutKsPin;
    ULONG                      OutSize, InSize;

    ASSERT( IsConnected() );
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN NotifyAllocator entry InKsPin=%x, Allocator=%x, ReadOnly=%d"),
            static_cast<IKsPin*>(this), Allocator, ReadOnly)); 

    //
    // sanity check - the only possible connection to user mode is via HOST_BUS
    //
    ::GetBusForKsPin(static_cast<IKsPin*>(this) , &Bus);

    if (! ::IsHostSystemBus(Bus) ) {
        //
        // Don't fail, as there are some weird user-mode filters that use medium to identify devices (JayBo).
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS: NotifyAllocator. BUS is not HOST_BUS.") ));
    }
   
    InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly );
   
    if (! InKsAllocator) {
        hr = ::MakePipesBasedOnFilter(static_cast<IKsPin*>(this), Pin_Input);
        if ( ! SUCCEEDED( hr )) {
            DbgLog((
                LOG_MEMORY,
                2,
                TEXT("%s(%s)::NotifyAllocator() returning %08x"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                hr ));
            return hr;
       }
    }
       
    //
    // Process any changes on input pin. 
    //
    hr = ::ResolvePipeOnConnection(static_cast<IKsPin*>(this), Pin_Input, FALSE, &FlagChange);
   
    //
    // see if input kernel pin can connect to user mode.
    //
    
    ::GetPinFramingFromCache( static_cast<IKsPin*>(this), &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);
    
    //
    // Don't enforce this yet.
    //
    if (0) {
        if (InFramingProp != FramingProp_None) {
            if (! ::GetFramingFixedFromFramingByLogicalMemoryType(InFramingEx, KS_MemoryTypeUser, &InFramingExFixed) ) {
                if (! ::GetFramingFixedFromFramingByLogicalMemoryType(InFramingEx, KS_MemoryTypeDontCare, &InFramingExFixed) ) {
                    DbgLog((LOG_MEMORY, 0,
                        TEXT("PIPES ERROR FILTERS: CKsInputPin::NotifyAllocator - doesn't support USER mode memory. Connection impossible.") ));
                    return E_FAIL;
                }
            }
        }
    }

    //
    // Connection is possible. 
    //
    ::ComputeNumPinsInPipe( static_cast<IKsPin*>(this), Pin_Input, &NumPinsInPipe);
   
    InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly);

    if (NumPinsInPipe > 1) {
        //
        // In intermediate version we split the pipe: so the pipe leading to(from) user mode pin
        // will always have just 1 kernel pin.
        //
        ::CreateSeparatePipe( static_cast<IKsPin*>(this), Pin_Input);
        
        InKsAllocator = KsGetPipe(KsPeekOperation_PeekOnly);
    }
   
    //
    // Here we have a single input pin on its pipe.
    //
    InAllocEx = InKsAllocator->KsGetProperties();
   
    //
    // Get upstream allocator properties.
    //
    hr = Allocator->GetProperties( &Properties);
    if ( ! SUCCEEDED( hr )) {
        DbgLog((LOG_MEMORY, 0, TEXT("PIPES ERROR FILTERS: CKsInputPin::NotifyAllocator - NO PROPERTIES.") ));
        return hr;
    }
   
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN NotifyAllocator. Prop=%d, %d, %d"),
        Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

    //
    // User mode pin will be an allocator unconditionally.
    // Decide which pin will determine base allocator properties.
    //
    if (InFramingProp != FramingProp_None) {
        PropertyPinType = Pin_All;
    }
    else {
        PropertyPinType = Pin_User;
    }

    //
    // See if connecting kernel-mode filter requires KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO (e.g. MsTee)
    //
    if ( ! (IsSpecialOutputRequest = IsSpecialOutputReqs(static_cast<IKsPin*>(this), Pin_Input, &OutKsPin, &InSize, &OutSize ) )) {
        //
        // Lets try to adjust the user-mode connection first, since we are negotiating it anyway.
        //
        OutSize = 0;
    }

    hr = ::SetUserModePipe( static_cast<IKsPin*>(this), Pin_Input, &Properties, PropertyPinType, OutSize);
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CKsInputPin::NotifyAllocator PinType=%d. Wanted Prop=%d, %d, %d"),
            PropertyPinType, Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

    hr = Allocator->SetProperties(&Properties, &ActualProperties);
    if (FAILED(hr)) {
        // If SetProperties failed, let's get some realistic values into ActualProperties because we'll use them later.
        hr = Allocator->GetProperties( &ActualProperties );
        ASSERT( SUCCEEDED(hr) );
    }
    
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CKsInputPin::NotifyAllocator ActualProperties=%d, %d, %d hr=%x"),
            ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

    //
    // Don't fail if SetProperties() above failed - we will have to live with the original allocator,
    // to not break existing clients.
    //

    hr = KsReceiveAllocator(Allocator);
   
    if (SUCCEEDED( hr )) {        
        //
        // CBaseInputPin::NotifyAllocator() releases the old interface, if any
        // and sets the m_ReadOnly and m_pAllocator members.
        //
        hr = CBaseInputPin::NotifyAllocator( Allocator, ReadOnly );
    }

    if (SUCCEEDED( hr ) && IsSpecialOutputRequest && (ActualProperties.cbBuffer > (long) OutSize ) ) {        
        //
        // We haven't succeeded sizing the input user-mode pipe. Lets try to resize the output pipe (WRT this k.m. filter).
        //
        if (! CanResizePipe(OutKsPin, Pin_Output, ActualProperties.cbBuffer) ) {
            //
            // Don't fail. Just log.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipeToUserModePin. Couldn't resize pipes OutKsPin=%x"), OutKsPin));
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES NotifyAllocator rets %x"), hr ));

    DbgLog((
        LOG_MEMORY,
        2,
        TEXT("%s(%s)::NotifyAllocator() returning %08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        hr ));
    
    return hr;
}



STDMETHODIMP
CKsInputPin::GetAllocator(
    IMemAllocator **MemAllocator
    )

/*++

Routine Description:
    Queries downstream pin for connected allocators.


Arguments:
    IMemAllocator **MemAllocator -
        pointer to received an AddRef()'d pointer to the allocator

Return:
    S_OK if successful or VFW_E_NO_ALLOCATOR on error.

--*/

{
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN %s(%s) CKsInputPin::GetAllocator KsPin=%x"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName,
            static_cast<IKsPin*>(this) ));

    return VFW_E_NO_ALLOCATOR;
} // GetAllocator


STDMETHODIMP
CKsInputPin::GetAllocatorRequirements(
    ALLOCATOR_PROPERTIES *AllocatorRequirements
    )

/*++

Routine Description:
    Calls the kernel filter to obtain the allocation requirements and
    fills the provided structure.

Arguments:
    ALLOCATOR_PROPERTIES *AllocatorRequirements -
        pointer to structure to receive the properties


Return:
    S_OK or result from CBaseInputPin::GetAllocatorRequirements()

--*/

{
    HRESULT             hr;
    KSALLOCATOR_FRAMING Framing;

    hr = ::GetAllocatorFraming(m_PinHandle, &Framing);
    if (SUCCEEDED(hr)) {
        AllocatorRequirements->cBuffers =
            Framing.Frames;
        AllocatorRequirements->cbBuffer =
            Framing.FrameSize;
        AllocatorRequirements->cbAlign =
            Framing.FileAlignment + 1;
        AllocatorRequirements->cbPrefix = 0;

        return hr;
    } else {
        return CBaseInputPin::GetAllocatorRequirements( AllocatorRequirements );
    }
}


STDMETHODIMP
CKsInputPin::BeginFlush(
    )
/*++

Routine Description:

    Override the CBaseInputPin::BeginFlush method. Forwards Begin-Flush
    notification to Topology-related output pins, if any, after first
    notifying the kernel pin.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    //
    // Wrap this in the I/O critical section.  This prevents us from marshaling
    // buffers in the middle of a flush.  It synchronizes the marshaler (in
    // particular on output pins) with the flush thread.
    //
    // NOTE: Per request, AVStream effectually issues a reset on topologically
    // related output pins when getting one on an input pin.  This means it
    // will reject marshalled buffers on the output pins in a flush state.
    // The proxy must understand that.  This is what the synchronization is
    // for (any such filter or kernel level client).
    //
    // The input pin's I/O critical section is also taken to guard against
    // a flush happening between the time m_bFlushing is set and the time we
    // marshal buffers.  The interface handler gets VERY cranky if a buffer
    // comes back DEVICE_NOT_READY (marshal in flush).  It will halt the entire
    // graph with EC_ERRORABORT.
    //
    static_cast<CKsProxy*>(m_pFilter)->EnterIoCriticalSection ();
    m_IoCriticalSection.Lock();
    m_DeliveryError = FALSE;
    CBaseInputPin::BeginFlush();
    if (m_PinHandle) {
        ULONG   BytesReturned;
        KSRESET ResetType;

        ResetType = KSRESET_BEGIN;
        ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_RESET_STATE,
            &ResetType,
            sizeof(ResetType),
            NULL,
            0,
            &BytesReturned);
    }
    m_IoCriticalSection.Unlock();
    static_cast<CKsProxy*>(m_pFilter)->DeliverBeginFlush(m_PinFactoryId);
    static_cast<CKsProxy*>(m_pFilter)->LeaveIoCriticalSection ();
    return S_OK;
}


STDMETHODIMP
CKsInputPin::EndFlush(
    )
/*++

Routine Description:

    Override the CBaseInputPin::EndFlush method. Forwards End-Flush
    notification to Topology-related output pins, if any, after first
    notifying the kernel pin.

Arguments:

    None.

Return Value:

    Returns S_OK.

--*/
{
    CBaseInputPin::EndFlush();
    if (m_PinHandle) {
        ULONG   BytesReturned;
        KSRESET ResetType;

        ResetType = KSRESET_END;
        ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_RESET_STATE,
            &ResetType,
            sizeof(ResetType),
            NULL,
            0,
            &BytesReturned);
    }
    static_cast<CKsProxy*>(m_pFilter)->DeliverEndFlush(m_PinFactoryId);
    return S_OK;
}


STDMETHODIMP
CKsInputPin::ReceiveCanBlock(
    )
/*++

Routine Description:

    Override the CBaseInputPin::ReceiveCanBlock method. 

Arguments:

    None.

Return Value:

    S_FALSE.

--*/
{
    //
    // Although we may block if all of the asynchronous I/O slots are filled
    // for this filter, this is not the normal case and we want to avoid
    // additional thread overhead.
    //
    
    //
    // Also note that the processing in CKsOutputPin::KsDeliver() will avoid 
    // blocking on downstream connected input pins by queueing the I/O to a 
    // worker thread.
    //
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::Receive(
    IMediaSample *MediaSample
    )
/*++

Routine Description:

    Override the CBaseInputPin::Receive method. Just passes control off to
    the ReceiveMultiple method.

Arguments:

    MediaSample -
        The single media sample to process.

Return Value:

    Returns the value of the ReceiveMultiple.

--*/
{
    LONG  SamplesProcessed;

    return ReceiveMultiple(
                &MediaSample,
                1,
                &SamplesProcessed );
}


STDMETHODIMP
CKsInputPin::ReceiveMultiple(
    IMediaSample **MediaSamples,
    LONG TotalSamples,
    LONG *SamplesProcessed
    )
/*++

Routine Description:

    Override the CBaseInputPin::ReceiveMultiple method.

Arguments:

    MediaSamples -
        The list of media samples to process.

    TotalSamples -
        The count of samples in the MediaSamples list.

    SamplesProcessed -
        The place in which to put the count of media samples actually processed.

Return Value:

    Returns S_OK if the media samples were queued to the device, else E_FAIL if
    a notification error occurred, or a sample could not be inserted into the
    stream (likely out of memory).

--*/
{
    int                 SubmittedSamples, CurrentSample;
    CKsProxy            *KsProxy = static_cast<CKsProxy*>(m_pFilter);
    AM_MEDIA_TYPE       *NewMediaType;
    BOOL                SkipNextFormatChange;
    HRESULT             hr;
    LONG                i;
    PKSSTREAM_SEGMENT   StreamSegment;

    *SamplesProcessed = 0;

    //
    // Make sure that we are in a streaming state.
    //   
    hr = CheckStreaming();
    if (hr != S_OK) {
        //
        // Note that if we are processing a flush, CheckStreaming()
        // returns S_FALSE.
        //
        return hr;
    }
    
    if (!m_MarshalData) {
        DbgLog((
            LOG_TRACE,
            2,
            TEXT("%s(%s)::ReceiveMultiple, m_MarshalData == FALSE"),
            static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
            m_pName));
        return E_FAIL;
    }

    CurrentSample = SubmittedSamples = 0;
    SkipNextFormatChange = FALSE;
    
    while (SubmittedSamples < TotalSamples) {

        NewMediaType = NULL;	
    
        //
        // Handle the in-stream data format changes, if any.
        //
        // Walk the sample list, check for the media type changed bit
        // and submit only those samples up to the media type change.
        //
        
        for (i = SubmittedSamples; i < TotalSamples; i++) {
            hr = 
                MediaSamples[ i ]->GetMediaType( &NewMediaType );
            if (S_FALSE == hr) {
                continue;
            }
            
            if (SUCCEEDED( hr )) {

                //
                // Yuck. Need to find another solution to "SkipNextFormatChange".
                //
                if (SkipNextFormatChange) {
                    SkipNextFormatChange = FALSE;
                    DeleteMediaType( NewMediaType );
                    NewMediaType = NULL;
                    continue;
                }
                
                //
                // A media type change is detected, NewMediaType contains 
                // the new media type.
                //

                DbgLog((
                    LOG_TRACE, 
                    2, 
                    TEXT("%s(%s)::ReceiveMultiple, media change detected"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName ));
                SkipNextFormatChange = TRUE;
            }
            break;
        }
        
        if (FAILED( hr )) {
            //
            // While processing the media sample list, we experienced
            // a failure.  This is considered fatal and we notify the
            // filter graph of this condition.
            //
            DbgLog((
                LOG_TRACE,
                2,
                TEXT("%s(%s)::ReceiveMultiple, failure during MediaType scan: %08x"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName,
                hr));
            break;        
        }
        
        //
        // Submit the samples associated with the current media type.
        //
        
        SubmittedSamples = i;

        //
        // Only submit the number of samples before the media type change.
        //
        
        i -= CurrentSample;

        if (i) {
            //
            // Synchronize with Inactive().
            //
            m_IoCriticalSection.Lock();
            if (IsStopped() || ((hr = CheckStreaming()) != S_OK)) {
                m_IoCriticalSection.Unlock();
                break;
            }
            hr = m_InterfaceHandler->KsProcessMediaSamples(
                m_DataTypeHandler,
                &MediaSamples[ CurrentSample ],
                &i,
                KsIoOperation_Write,
                &StreamSegment );
            m_IoCriticalSection.Unlock();
            if (!SUCCEEDED( hr )) {
                //
                // An error occurred while sending the packet to the
                // kernel-mode filter.
                //
                
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, I/O failed: %08x"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName,
                    hr));
                    
                KsNotifyError( MediaSamples[ CurrentSample ], hr );
            } 
            
            //
            // We succeeded to at least submit this information
            // to kernel-mode, increment samples processed counter.
            //
            *SamplesProcessed += i;
            CurrentSample = SubmittedSamples;
        
            while (!SUCCEEDED( KsProxy->InsertIoSlot( StreamSegment ) )) {
                //
                // Note that we're not really concerned with 
                // reentrancy in WaitForIoSlot() -- these threads will
                // be signalled when appropriate.  The assumption
                // is that Quartz will not get tripped up by this
                // condition.
                //
                KsProxy->WaitForIoSlot();
            }
        }
    
        //
        // Change to the new data type handler, if any.  To do so,
        // submit a packet with the format change information and then 
        // send the remaining data.
        //
        
        if (NewMediaType) {
            CFormatChangeHandler    *FormatChangeHandler;
        
            hr = SetStreamMediaType( static_cast<CMediaType*>(NewMediaType) );
            DeleteMediaType( NewMediaType );
            if (FAILED( hr )) {
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, SetStreamMediaType failed"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName));
                break;
            }
            
            //
            // The format change handler is a special interface
            // handler for in-stream data changes.  
            // Note that the IMediaSample** parameter contains the
            // pointer to the sample with the new media type.
            //
            
            FormatChangeHandler = 
                new CFormatChangeHandler(
                    NULL,
                    NAME("Data Format Change Handler"),
                    &hr );
            
            if (!FormatChangeHandler) {
                hr = E_OUTOFMEMORY;
                break;
            }
            if (FAILED( hr )) {
                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("%s(%s)::ReceiveMultiple, CFormatChangeHandler()"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName));
                break;
            }        
            
            //
            // Force the AddRef() for the interface and notify the
            // interface handler of the pin interface.  Note that
            // the interface handler is AddRef()'d/Release()'d during 
            // the processing of an I/O operation -- this interface
            // will be cleaned up when the I/O is completed.
            //
            //
            
            FormatChangeHandler->AddRef();
            FormatChangeHandler->KsSetPin( static_cast<IKsPin*>(this) );
        
            i = 1;
            //
            // Synchronize with Inactive().
            //
            KsProxy->EnterIoCriticalSection();
            if (IsStopped()) {
                KsProxy->LeaveIoCriticalSection();
                FormatChangeHandler->Release();
                break;
            }
            hr =
                FormatChangeHandler->KsProcessMediaSamples(
                    NULL,
                    &MediaSamples[ CurrentSample ],
                    &i,
                    KsIoOperation_Write,
                    &StreamSegment );
            KsProxy->LeaveIoCriticalSection();
            FormatChangeHandler->Release();
            
            if (SUCCEEDED( hr )) {
                while (!SUCCEEDED( KsProxy->InsertIoSlot( StreamSegment ) )) {
                    KsProxy->WaitForIoSlot();
                }
            } else {
                DbgLog((
                    LOG_TRACE,
                    0,
                    TEXT("%s(%s)::ReceiveMultiple, fc I/O failed: %08x"),
                    static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                    m_pName,
                    hr));
                    
                KsNotifyError( MediaSamples[ CurrentSample ], hr );
            
                break;
            }
        }
    }
    
    return hr;
}


STDMETHODIMP_(LONG)
CKsInputPin::KsIncrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsIncrementPendingIoCount method. Increments the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    return InterlockedIncrement( &m_PendingIoCount );
}


STDMETHODIMP_(LONG)
CKsInputPin::KsDecrementPendingIoCount(
    )
/*++

Routine Description:

    Implement the IKsPin::KsDecrementPendingIoCount method. Decrements the
    count of outstanding pending I/O on the pin, and is called from an
    Interface handler.

Arguments:

    None.

Return Value:

    Returns the current outstanding count.

--*/
{
    LONG PendingIoCount;
    
    if (0 == (PendingIoCount = InterlockedDecrement( &m_PendingIoCount ))) {
        //
        // The filter is in a stopped state, and this is the last I/O to
        // complete. At this point the Inactive method may be waiting on
        // all the I/O to be completed, so it needs to be signalled.
        //
        if (IsStopped()) {
            SetEvent( m_PendingIoCompletedEvent );
        }            
    }
    return PendingIoCount;
}


STDMETHODIMP_( VOID )
CKsInputPin::KsNotifyError(
    IMediaSample* Sample, 
    HRESULT hr
    )
/*++

Routine Description:
    Raises an error in the graph, if this has not already occurred.

Arguments:
    IMediaSample* Sample -
    
    HRESULT hr -

Return Value:
    None

--*/
{
    //
    // Don't raise an error if the I/O was cancelled.
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED)) {
        return;
    }       
    //
    // Notify the filter graph that we have an error. Ensure this
    // happens only once during a run, and that nothing further
    // is queued up.
    //
    m_DeliveryError = TRUE;
    m_pFilter->NotifyEvent( EC_ERRORABORT, hr, 0 );
}    
    

STDMETHODIMP
CKsInputPin::KsDeliver(
    IMediaSample* Sample,
    ULONG Flags
    )
/*++

Routine Description:
    Implements the IKsPin::KsDeliver method.  For input pins, this is an invalid
    entry point, just return E_FAIL.

Arguments:

    Sample -
        Pointer to a media sample.

    Flags -
        Sample flags.

Return:
    E_FAIL

--*/
{
    //
    // This is an unexpected call for an input pin.
    //
    return E_FAIL;
}


STDMETHODIMP 
CKsInputPin::KsMediaSamplesCompleted(
    PKSSTREAM_SEGMENT StreamSegment
    )

/*++

Routine Description:
    Notification handler for stream segment completed.  We don't care
    for input pins.

Arguments:
    PKSSTREAM_SEGMENT StreamSegment -
        segment completed

Return:
    Nothing.

--*/

{
    return S_OK;
}



STDMETHODIMP
CKsInputPin::KsQualityNotify(
    ULONG           Proportion,
    REFERENCE_TIME  TimeDelta
    )
/*++

Routine Description:

    Implementes the IKsPin::KsQualityNotify method. Receives quality
    management reports from the kernel mode pin which this Active
    Movie pin represents.

Arguments:

    Proportion -
        The proportion of data rendered.

    TimeDelta -
        The delta from nominal time at which the data is being received.

Return Value:

    Returns the result of forwarding the quality management report, else E_FAIL
    if the pin is not connected.

--*/
{
    Quality             q;
    IReferenceClock*    RefClock;

    //
    // This is reset when removing quality support, and just makes a quick
    // way out. This works because when a KsFlushClient() is done for this
    // pin on the quality forwarder, it synchronizes with the thread
    // delivering these messages.
    //
    if (!m_QualitySupport) {
        return NOERROR;
    }
    if (TimeDelta < 0) {
        q.Type = Famine;
    } else {
        q.Type = Flood;
    }
    q.Proportion = Proportion;
    q.Late = TimeDelta;
    if (SUCCEEDED(m_pFilter->GetSyncSource(&RefClock)) && RefClock) {
        RefClock->GetTime(&q.TimeStamp);
        RefClock->Release();
    } else {
        q.TimeStamp = 0;
    }
    if (m_pQSink) {
        return m_pQSink->Notify(m_pFilter, q);
    }
    if (m_Connected) {
        IQualityControl*    QualityControl;

        m_Connected->QueryInterface(__uuidof(IQualityControl), reinterpret_cast<PVOID*>(&QualityControl));
        if (QualityControl) {
            HRESULT hr;

            hr = QualityControl->Notify(m_pFilter, q);
            QualityControl->Release();
            return hr;
        }
    }
    return E_FAIL;
}


STDMETHODIMP
CKsInputPin::EndOfStream(
    )
/*++

Routine Description:

    Override the CBasePin::EndOfStream method. Forwards End-Of-Stream
    notification to Topology-related output pins, if any, else to the
    filter.

Arguments:

    None.

Return Value:

    Returns NOERROR.

--*/
{
    DbgLog((
        LOG_TRACE,
        2,
        TEXT("%s(%s)::EndOfStream"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName));
    //
    // Apparently this can be received when the filter is stopped, but
    // should be ignored.
    //
    if (static_cast<CKsProxy*>(m_pFilter)->IsStopped()) {
        return NOERROR;
    }
    //
    // Notification from any upstream filter is ignored, since the EOS
    // flag will be looked at by the marshaling code and sent when the
    // last I/O has completed.
    //
    if (m_MarshalData) {
        CMicroMediaSample*  MediaSample;
        HRESULT             hr;
        LONG                SamplesProcessed;
        IMediaSample*       MediaSamples;

        //
        // Generate a sample with an EOS flag set. AM does not set the
        // EOS flag within the stream.
        //
        MediaSample = new CMicroMediaSample(AM_SAMPLE_ENDOFSTREAM);
        if (!MediaSample) {
            DbgLog((
                LOG_TRACE,
                0,
                TEXT("%s(%s)::EndOfStream, failed to allocate EOS sample!"),
                static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
                m_pName));
            return E_OUTOFMEMORY;
        }
        MediaSamples = static_cast<IMediaSample*>(MediaSample);
        hr = ReceiveMultiple(
            &MediaSamples,
            1,
            &SamplesProcessed);
        if (FAILED(hr)) {
            return hr;
        }
    }
    //
    // End-Of-Stream notification is ignored for non-Marshaling pins. This
    // is because a proxy instance will have registered with EOS notification
    // downstream.
    //
    return S_FALSE;
}


STDMETHODIMP
CKsInputPin::GetPages(
    CAUUID* Pages
    )
/*++

Routine Description:

    Implement the ISpecifyPropertyPages::GetPages method. This adds any
    Specifier handlers to the property pages if the pin instances is still
    unconnected and it is a Bridge pin. Else it adds none.

Arguments:

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    return ::GetPages(
        static_cast<IKsObject*>(this),
        static_cast<CKsProxy*>(m_pFilter)->KsGetObjectHandle(),
        m_PinFactoryId,
        m_CurrentCommunication,
        static_cast<CKsProxy*>(m_pFilter)->QueryDeviceRegKey(),
        Pages);
}


STDMETHODIMP
CKsInputPin::Render(
    IPin*           PinOut,
    IGraphBuilder*  Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Render method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should attempt to render to.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsInputPin::Backout(
    IPin*           PinOut,
    IGraphBuilder*  Graph
    )
/*++

Routine Description:

    Implement the IStreamBuilder::Backout method. This is only exposed on Bridge
    and None pins in order to make the graph builder ignore these pins.

Arguments:

    PinOut -
        The pin which this pin should back out from.

    Graph -
        The graph builder making the call.

Return Value:

    Returns S_OK so that the graph builder will ignore this pin.

--*/
{
    return S_OK;
}


STDMETHODIMP
CKsInputPin::Set(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Set method. This sets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the data to pass to the property.

    DataLength -
        Contains the length of the data passed.

Return Value:

    Returns NOERROR if the property was set.

--*/
{
    ULONG   BytesReturned;

    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_SET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            &BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_SET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            &BytesReturned);
    }
}


STDMETHODIMP
CKsInputPin::Get(
    REFGUID PropSet,
    ULONG Id,
    LPVOID InstanceData,
    ULONG InstanceLength,
    LPVOID PropertyData,
    ULONG DataLength,
    ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsPropertySet::Get method. This gets a property on the
    underlying kernel pin.

Arguments:

    PropSet -
        The GUID of the set to use.

    Id -
        The property identifier within the set.

    InstanceData -
        Points to the instance data passed to the property.

    InstanceLength -
        Contains the length of the instance data passed.

    PropertyData -
        Points to the place in which to return the data for the property.

    DataLength -
        Contains the length of the data buffer passed.

    BytesReturned -
        The place in which to put the number of bytes actually returned.

Return Value:

    Returns NOERROR if the property was retrieved.

--*/
{
    if (InstanceLength) {
        PKSPROPERTY Property;
        HRESULT     hr;

        Property = reinterpret_cast<PKSPROPERTY>(new BYTE[sizeof(*Property) + InstanceLength]);
        if (!Property) {
            return E_OUTOFMEMORY;
        }
        Property->Set = PropSet;
        Property->Id = Id;
        Property->Flags = KSPROPERTY_TYPE_GET;
        memcpy(Property + 1, InstanceData, InstanceLength);
        hr = KsProperty(
            Property,
            sizeof(*Property) + InstanceLength,
            PropertyData,
            DataLength,
            BytesReturned);
        delete [] (PBYTE)Property;
        return hr;
    } else if (PropSet == AMPROPSETID_Pin) {
        KSP_PIN Pin;

        switch (Id) {
        case AMPROPERTY_PIN_CATEGORY:
            Pin.Property.Set = KSPROPSETID_Pin;
            Pin.Property.Id = KSPROPERTY_PIN_CATEGORY;
            Pin.Property.Flags = KSPROPERTY_TYPE_GET;
            Pin.PinId = m_PinFactoryId;
            Pin.Reserved = 0;
            return static_cast<CKsProxy*>(m_pFilter)->KsProperty(
                reinterpret_cast<PKSPROPERTY>(&Pin),
                sizeof(Pin),
                PropertyData,
                DataLength,
                BytesReturned);
        default:
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    } else {
        KSPROPERTY  Property;

        Property.Set = PropSet;
        Property.Id = Id;
        Property.Flags = KSPROPERTY_TYPE_GET;
        return KsProperty(
            &Property,
            sizeof(Property),
            PropertyData,
            DataLength,
            BytesReturned);
    }
}


STDMETHODIMP
CKsInputPin::QuerySupported(
    REFGUID PropSet,
    ULONG Id,
    ULONG* TypeSupport
    )
/*++

Routine Description:

    Implement the IKsPropertySet::QuerySupported method. Return the type of
    support is provided for this property.

Arguments:

    PropSet -
        The GUID of the set to query.

    Id -
        The property identifier within the set.

    TypeSupport
        Optionally the place in which to put the type of support. If NULL, the
        query returns whether or not the property set as a whole is supported.
        In this case the Id parameter is not used and must be zero.

Return Value:

    Returns NOERROR if the property support was retrieved.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = PropSet;
    Property.Id = Id;
    Property.Flags = TypeSupport ? KSPROPERTY_TYPE_BASICSUPPORT : KSPROPERTY_TYPE_SETSUPPORT;
    return KsProperty(
        &Property,
        sizeof(Property),
        TypeSupport,
        TypeSupport ? sizeof(*TypeSupport) : 0,
        &BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsPinFactory(
    ULONG* PinFactory
    )
/*++

Routine Description:

    Implement the IKsPinFactory::KsPinFactory method. Return the pin factory
    identifier.

Arguments:

    PinFactory -
        The place in which to put the pin factory identifier.

Return Value:

    Returns NOERROR.

--*/
{
    *PinFactory = m_PinFactoryId;
    return NOERROR;
}


STDMETHODIMP
CKsInputPin::KsProperty(
    IN PKSPROPERTY Property,
    IN ULONG PropertyLength,
    IN OUT LPVOID PropertyData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsProperty method. This is used to query and
    manipulate property sets on an object. It can perform a Get, Set, and
    various Support queries.

Arguments:

    Property -
        Contains the property set identification for the query.

    PropertyLength -
        Contains the length of the Property parameter. Normally this is
        the size of the KSPROPERTY structure.

    PropertyData -
        Contains either the data to apply to a property on a Set, the
        place in which to return the current property data on a Get, or the
        place in which to return property set information on a Support
        query.

    DataLength -
        Contains the size of the PropertyData buffer.

    BytesReturned -
        On a Get or Support query, returns the number of bytes actually
        used in the PropertyData buffer. This is not used on a Set, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_PROPERTY,
        Property,
        PropertyLength,
        PropertyData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsMethod(
    IN PKSMETHOD Method,
    IN ULONG MethodLength,
    IN OUT LPVOID MethodData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsMethod method. This is used to query and
    manipulate method sets on an object. It can perform an Execute and
    various Support queries.

Arguments:

    Method -
        Contains the method set identification for the query.

    MethodLength -
        Contains the length of the Method parameter. Normally this is
        the size of the KSMETHOD structure.

    MethodData -
        Contains either the IN and OUT parameters to the method, or the
        place in which to return method set information on a Support
        query.

    DataLength -
        Contains the size of the MethodData buffer.

    BytesReturned -
        Returns the number of bytes actually used in the MethodData buffer.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_METHOD,
        Method,
        MethodLength,
        MethodData,
        DataLength,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsEvent(
    IN PKSEVENT Event OPTIONAL,
    IN ULONG EventLength,
    IN OUT LPVOID EventData,
    IN ULONG DataLength,
    OUT ULONG* BytesReturned
    )
/*++

Routine Description:

    Implement the IKsControl::KsEvent method. This is used to set and
    query events sets on an object. It can perform an Enable, Disable and
    various Support queries.

Arguments:

    Event -
        Contains the event set identification for the enable, disable, or
        query. To disable an event, this parameter must be set to NULL, and
        EventLength set to zero. The EventData must be passed the original
        KSEVENTDATA pointer.

    EventLength -
        Contains the length of the Event parameter. Normally this is
        the size of the KSEVENT structure for an Enable. This would be set
        to zero for a Disable.

    EventData -
        Contains either the KSEVENTDATA to apply to a event on an Enable,
        or the place in which to return event set information on a Support
        query.

    DataLength -
        Contains the size of the EventData buffer. For an Enable or Disable
        this would normally be the size of a KSEVENTDATA, structure plus
        event specific data.

    BytesReturned -
        On a Support query, returns the number of bytes actually used in
        the EventData buffer. This is not used on an Enable or Disable, and
        is returned as zero.

Return Value:

    Returns any error from the underlying filter in processing the request.

--*/
{
    //
    // If an event structure is present, this must either be an Enable or
    // or a Support query.
    //
    if (EventLength) {
        return ::KsSynchronousDeviceControl(
            m_PinHandle,
            IOCTL_KS_ENABLE_EVENT,
            Event,
            EventLength,
            EventData,
            DataLength,
            BytesReturned);
    }
    //
    // Otherwise this must be a Disable.
    //
    return ::KsSynchronousDeviceControl(
        m_PinHandle,
        IOCTL_KS_DISABLE_EVENT,
        EventData,
        DataLength,
        NULL,
        0,
        BytesReturned);
}


STDMETHODIMP
CKsInputPin::KsGetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX* FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Implement the IKsPinPipe::KsGetPinFramingCache method. This is used to
    retrieve the extended framing for this pin.

Arguments:

    FramingEx -
        The buffer in which to return the extended framing requested.

    FramingProp -
        The buffer in which to return state of the framing requirements
        structure.

    Option -
        Indicates which extended framing to return. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    ASSERT( Option >= Framing_Cache_ReadLast);
    ASSERT( Option <= Framing_Cache_Write );
    if ((Option < Framing_Cache_ReadLast) || (Option > Framing_Cache_Write)) {
        return E_INVALIDARG;
    }
    *FramingEx = m_AllocatorFramingEx[Option - 1];
    *FramingProp = m_FramingProp[Option - 1];
    return S_OK;
}


STDMETHODIMP
CKsInputPin::KsSetPinFramingCache(
    PKSALLOCATOR_FRAMING_EX FramingEx,
    PFRAMING_PROP FramingProp,
    FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Implement the IKsPinPipe::KsSetPinFramingCache method. This is used to
    set the extended framing for this pin.

Arguments:

    FramingEx -
        Contains the new extended framing to set.

    FramingProp -
        Contains the new state to set on the extended framing type passed.

    Option -
        Indicates which extended framing to set. This is one of
        Framing_Cache_ReadOrig, Framing_Cache_ReadLast, or
        Framing_Cache_Write.

Return Value:

    Returns S_OK.

--*/
{
    //
    // The same pointer may be used for multiple items, so ensure that it
    // is not being used elsewhere before deleting it.
    //
    if (m_AllocatorFramingEx[Option - 1]) {
        ULONG PointerUseCount = 0;
        for (ULONG Options = 0; Options < SIZEOF_ARRAY(m_AllocatorFramingEx); Options++) {
            if (m_AllocatorFramingEx[Options] == m_AllocatorFramingEx[Option - 1]) {
                PointerUseCount++;
            }
        }
        //
        // This pointer is only used once, so it can be deleted. This
        // assumes that no client has acquired the pointer which is about
        // to be deleted.
        //
        if (PointerUseCount == 1) {
            delete m_AllocatorFramingEx[Option - 1];
        }
    }
    m_AllocatorFramingEx[Option - 1] = FramingEx;
    m_FramingProp[Option - 1] = *FramingProp;
    return S_OK;
}


STDMETHODIMP_(IKsAllocatorEx*)
CKsInputPin::KsGetPipe(
    KSPEEKOPERATION Operation
    )

/*++

Routine Description:
    Returns the assigned KS allocator for this pin and optionally
    AddRef()'s the interface.

Arguments:
    KSPEEKOPERATION Operation -
        if KsPeekOperation_AddRef is specified, the m_pKsAllocator is
        AddRef()'d (if not NULL) before returning.

Return Value:
    the value of m_pKsAllocator

--*/

{
    if ((Operation == KsPeekOperation_AddRef) && (m_pKsAllocator)) {
        m_pKsAllocator->AddRef();
    }
    return m_pKsAllocator;
}



STDMETHODIMP
CKsInputPin::KsSetPipe(
    IKsAllocatorEx *KsAllocator
    )

{
    DbgLog(( 
        LOG_CUSTOM1, 
        1, 
        TEXT("PIPES ATTN %s(%s)::KsSetPipe , m_pKsAllocator == 0x%08X, KsAllocator == 0x%08x"),
        static_cast<CKsProxy*>(m_pFilter)->GetFilterName(),
        m_pName,
        m_pKsAllocator,
        KsAllocator ));

    if (KsAllocator) {
        KsAllocator->AddRef();
    }
    SAFERELEASE( m_pKsAllocator );
    m_pKsAllocator = KsAllocator;
    return (S_OK);

}    


STDMETHODIMP
CKsInputPin::KsSetPipeAllocatorFlag(
    ULONG   Flag
    )
{
    m_fPipeAllocator = Flag;
    return (S_OK);
}


STDMETHODIMP_(ULONG)
CKsInputPin::KsGetPipeAllocatorFlag(
    )
{
    return m_fPipeAllocator;
}


STDMETHODIMP_(PWCHAR)
CKsInputPin::KsGetPinName(
    )
{
    return m_pName;
}

STDMETHODIMP_(PWCHAR)
CKsInputPin::KsGetFilterName(
    )
{
    return (static_cast<CKsProxy*>(m_pFilter)->GetFilterName() );
}

STDMETHODIMP_(GUID)
CKsInputPin::KsGetPinBusCache(
    )
{
    //
    // When we read the Pin bus cache for the first time,
    // we set the cache. 
    //
    if (! m_PinBusCacheInit) {
        ::GetBusForKsPin(static_cast<IKsPin*>(this), &m_BusOrig);
        m_PinBusCacheInit = TRUE;
    }

    return m_BusOrig;
}


STDMETHODIMP
CKsInputPin::KsSetPinBusCache(
    GUID    Bus
    )
{
    m_BusOrig = Bus;
    return (S_OK);
}


STDMETHODIMP
CKsInputPin::KsAddAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsAddAggregate method. This is used to
    load a COM server with zero or more interfaces to aggregate on the object.

Arguments:

    Aggregate -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the Aggregate was added.

--*/
{
    return ::AddAggregate(&m_MarshalerList, static_cast<IKsPin*>(this), Aggregate);
}


STDMETHODIMP
CKsInputPin::KsRemoveAggregate(
    IN REFGUID Aggregate
    )
/*++

Routine Description:

    Implement the IKsAggregateControl::KsRemoveAggregate method. This is used to
    unload a previously loaded COM server which is aggregating interfaces.

Arguments:

    Aggregate -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the Aggregate was removed.

--*/
{
    return ::RemoveAggregate(&m_MarshalerList, Aggregate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksqmf\ksqmf.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksqmf.cpp

Abstract:

    Provides an object interface to query, and a method to forward KS quality management.

--*/

#include <windows.h>
#include <limits.h>
#include <streams.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include "ksqmf.h"

EXTERN_C
DECLSPEC_IMPORT
ULONG
NTAPI
RtlNtStatusToDosError(
    IN ULONG Status
    );

#define WAIT_OBJECT_QUALITY 0
#define WAIT_OBJECT_ERROR   1
#define WAIT_OBJECT_FLUSH   2
#define WAIT_OBJECT_EXIT    3
#define TOTAL_WAIT_OBJECTS  4

//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
struct DECLSPEC_UUID("E05592E4-C0B5-11D0-A439-00A0C9223196") CLSID_KsQualityF;

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] =
{
    {L"KS Quality Forwarder", &__uuidof(CLSID_KsQualityF), CKsQualityF::CreateInstance, NULL, NULL},
};

int g_cTemplates = SIZEOF_ARRAY(g_Templates);

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

#endif


CUnknown*
CALLBACK
CKsQualityF::CreateInstance(
    LPUNKNOWN UnkOuter,
    HRESULT* hr
    )
/*++

Routine Description:

    This is called by ActiveMovie code to create an instance of a Quality
    Forwarder. It is referred to in the g_Tamplates structure.

Arguments:

    UnkOuter -
        Specifies the outer unknown, if any.

    hr -
        The place in which to put any error return.

Return Value:

    Returns a pointer to the nondelegating CUnknown portion of the object.

--*/
{
    CUnknown* Unknown;

    Unknown = new CKsQualityF(UnkOuter, NAME("KsQualityF Class"), hr);
    if (!Unknown) {
        *hr = E_OUTOFMEMORY;
    }
    return Unknown;
}


CKsQualityF::CKsQualityF(
    LPUNKNOWN UnkOuter,
    TCHAR* Name,
    HRESULT* hr
    ) :
    CUnknown(Name, UnkOuter),
    m_QualityManager(NULL),
    m_Thread(NULL),
    m_TerminateEvent(NULL),
    m_FlushEvent(NULL)
/*++

Routine Description:

    The constructor for the quality forwarder object. Just initializes
    everything to NULL and opens the kernel mode quality proxy.

Arguments:

    UnkOuter -
        Specifies the outer unknown, which must be set.

    Name -
        The name of the object, used for debugging.

    hr -
        The place in which to put any error return.

Return Value:

    Nothing.

--*/
{
    //
    // Must have a parent, as this is always an aggregated object.
    //
    if (UnkOuter) {
        //
        // Try to open the default quality management device.
        //
        *hr = KsOpenDefaultDevice(
            KSCATEGORY_QUALITY,
            GENERIC_READ,
            &m_QualityManager);
        if (SUCCEEDED(*hr)) {
            DWORD ThreadId;
            DWORD LastError;

            //
            // This is used to synchronize a flush. A waiter is signalled
            // once the outstanding I/O has been cleared.
            //
            m_FlushEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (m_FlushEvent) {
                //
                // This is used to signal the I/O thread that it should be
                // flushing. Each client will set this and wait on the
                // m_FlushEvent to be signalled. The I/O thread will signal
                // the event for each waiter.
                //
                m_FlushSemaphore = CreateSemaphore(NULL, 0, LONG_MAX, NULL);
                if (m_FlushSemaphore) {
                    //
                    // This is the event used by the thread to wait on Irp's.
                    //
                    m_TerminateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                    if (m_TerminateEvent) {
                        m_Thread = CreateThread(
                            NULL,
                            0,
                            reinterpret_cast<PTHREAD_START_ROUTINE>(CKsQualityF::QualityThread),
                            reinterpret_cast<PVOID>(this),
                            0,
                            &ThreadId);
                        if (m_Thread) {
                            SetThreadPriority(m_Thread, THREAD_PRIORITY_HIGHEST);
                            return;
                        }
                    }
                }
            }
            LastError = GetLastError();
            *hr = HRESULT_FROM_WIN32(LastError);
        }
    } else {
        *hr = VFW_E_NEED_OWNER;
    }
}


CKsQualityF::~CKsQualityF(
    )
/*++

Routine Description:

    The destructor for the quality forwarder instance.

Arguments:

    None.

Return Value:

    Nothing.

--*/
{
    //
    // The kernel mode quality proxy may have failed to open.
    //
    if (m_QualityManager) {
        //
        // If there is a quality handle, the thread may have been started. If there
        // was not a handle, then it could not have been started. This will close
        // down everything, and wait for the thread to terminate.
        //
        if (m_TerminateEvent) {
            if (m_Thread) {
                //
                // Signal the thread of a change, and wait for the thread to terminate.
                //
                SetEvent(m_TerminateEvent);
                WaitForSingleObjectEx(m_Thread, INFINITE, FALSE);
                CloseHandle(m_Thread);
            }
            CloseHandle(m_TerminateEvent);
        }
        if (m_FlushSemaphore) {
            CloseHandle(m_FlushSemaphore);
        }
        if (m_FlushEvent) {
            CloseHandle(m_FlushEvent);
        }
        CloseHandle(m_QualityManager);
    }
}


STDMETHODIMP 
CKsQualityF::NonDelegatingQueryInterface(
    REFIID InterfaceId,
    PVOID* Interface
    )
/*++

Routine Description:

    The nondelegating interface query function. Returns a pointer to the
    specified interface if supported. The only interface explicitly supported
    is IKsQualityForwarder.

Arguments:

    InterfaceId -
        The identifier of the interface to return.

    Interface -
        The place in which to put the interface pointer.

Return Value:

    Returns NOERROR if the interface was returned, else E_NOINTERFACE.

--*/
{
    if (InterfaceId == __uuidof(IKsQualityForwarder)) {
        return GetInterface(static_cast<IKsQualityForwarder*>(this), Interface);
    }
    return CUnknown::NonDelegatingQueryInterface(InterfaceId, Interface);
}


STDMETHODIMP_(HANDLE) 
CKsQualityF::KsGetObjectHandle(
    )
/*++

Routine Description:

    Implements the IKsQualityForwarder::KsGetObjectHandle method.

Arguments:

    None.

Return Value:

    Returns the handle to the underlying kernel mode proxy quality manager. This
    is used by the ActiveMovie filter proxy to hand to kernel mode filters.

--*/
{
    return m_QualityManager;
}


STDMETHODIMP_(VOID)
CKsQualityF::KsFlushClient(
    IN IKsPin* Pin
    )
/*++

Routine Description:

    Implements the IKsQualityForwarder::KsFlushClient method. Ensures that any
    pending quality complaints from the kernel mode quality manager are flushed.
    This function synchronizes with the delivery thread so that when it returns,
    there are no outstanding messages to send to the pin. Flushed messages are
    not passed on to the pin.

Arguments:

    Pin -
        The pin of the client which is to be flushed.

Return Value:

    Nothing.

--*/
{
    HANDLE EventList[2];
    LONG PreviousCount;

    //
    // Synchronize with the quality thread. Also ensure it does not go away
    // because of an error. First notify the I/O thread that there is another
    // waiter. Then wait on both types of I/O to be flushed.
    //
    ReleaseSemaphore(m_FlushSemaphore, 1, &PreviousCount);
    EventList[0] = m_FlushEvent;
    EventList[1] = m_Thread;
    WaitForMultipleObjects(
        SIZEOF_ARRAY(EventList),
        EventList,
        FALSE,
        INFINITE);
}


HRESULT
CKsQualityF::QualityThread(
    CKsQualityF* KsQualityF
    )
/*++

Routine Description:

    The forwarder thread routine.

Arguments:

    KsQualityF -
        The instance.

Return Value:

    Returns an error if the event could not be created, else NOERROR.

--*/
{
    KSPROPERTY PropertyQuality;
    KSPROPERTY PropertyError;
    OVERLAPPED ovQuality;
    OVERLAPPED ovError;
    HANDLE EventList[TOTAL_WAIT_OBJECTS];
    HRESULT hr;
    DWORD LastError;
    BOOL NeedQualityIo;
    BOOL NeedErrorIo;
    BOOL Flushing;

    //
    // Initialize the property structures once.
    //
    PropertyQuality.Set = KSPROPSETID_Quality;
    PropertyQuality.Id = KSPROPERTY_QUALITY_REPORT;
    PropertyQuality.Flags = KSPROPERTY_TYPE_GET;
    RtlZeroMemory(&ovQuality, sizeof(ovQuality));
    ovQuality.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ovQuality.hEvent == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    PropertyError.Set = KSPROPSETID_Quality;
    PropertyError.Id = KSPROPERTY_QUALITY_ERROR;
    PropertyError.Flags = KSPROPERTY_TYPE_GET;
    RtlZeroMemory(&ovError, sizeof(ovError));
    ovError.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ovError.hEvent == INVALID_HANDLE_VALUE) {
        LastError = GetLastError();
        CloseHandle(ovQuality.hEvent);
        return HRESULT_FROM_WIN32(LastError);
    }
    //
    // The ordering is obviously significant.
    //
    EventList[WAIT_OBJECT_QUALITY] = ovQuality.hEvent;
    EventList[WAIT_OBJECT_ERROR] = ovError.hEvent;
    EventList[WAIT_OBJECT_FLUSH] = KsQualityF->m_FlushSemaphore;
    EventList[WAIT_OBJECT_EXIT] = KsQualityF->m_TerminateEvent;
    //
    // Initially the loop needs to queue up an outstanding I/O against
    // both of the properties.
    //
    NeedQualityIo = TRUE;
    NeedErrorIo = TRUE;
    //
    // Flushing is not turned on until a flushing request is made by a client.
    //
    Flushing = FALSE;
    //
    // The thread exits when the termination event is set, or an error occurs.
    //
    hr = NOERROR;
    do {
        ULONG BytesReturned;
        DWORD WaitObject;
        KSQUALITY Quality;
        KSERROR Error;

        if (NeedQualityIo) {
            if (DeviceIoControl(
                KsQualityF->m_QualityManager,
                IOCTL_KS_PROPERTY,
                &PropertyQuality,
                sizeof(PropertyQuality),
                &Quality,
                sizeof(Quality),
                &BytesReturned,
                &ovQuality)) {
                //
                // Signal the event so that the wait will exit immediately.
                //
                SetEvent(ovQuality.hEvent);
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                    hr = NOERROR;
                    break;
                }
            }
            NeedQualityIo = FALSE;
        }
        if (NeedErrorIo) {
            if (DeviceIoControl(
                KsQualityF->m_QualityManager,
                IOCTL_KS_PROPERTY,
                &PropertyError,
                sizeof(PropertyError),
                &Error,
                sizeof(Error),
                &BytesReturned,
                &ovError)) {
                //
                // Signal the event so that the wait will exit immediately.
                //
                SetEvent(ovError.hEvent);
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
                    hr = NOERROR;
                    break;
                }
            }
            NeedErrorIo = FALSE;
        }
        //
        // If the thread is currently flushing I/O, then do not wait for
        // the next event. Instead just use the last value, which would have
        // been WAIT_OBJECT_FLUSH, to check for completed I/O.
        //
        if (!Flushing) {
            WaitObject = WaitForMultipleObjects(
                SIZEOF_ARRAY(EventList),
                EventList,
                FALSE,
                INFINITE);
        }
        switch (WaitObject - WAIT_OBJECT_0) {
        case WAIT_OBJECT_QUALITY:
            //
            // The I/O has been completed. On error just exit the thread.
            //
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovQuality, &BytesReturned, TRUE)) {
                reinterpret_cast<IKsPin*>(Quality.Context)->KsQualityNotify(
                    Quality.Proportion,
                    Quality.DeltaTime);
                NeedQualityIo = TRUE;
            } else {
                //
                // The I/O failed. Exit so that the thead does not
                // just spin.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
            break;
        case WAIT_OBJECT_ERROR:
            //
            // The I/O has been completed. On error just exit the thread.
            //
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovError, &BytesReturned, TRUE)) {
                IMediaEventSink* EventSink;
                HRESULT hrReturn;

                hrReturn = reinterpret_cast<IKsPin*>(Quality.Context)->QueryInterface(
                    __uuidof(IMediaEventSink),
                    reinterpret_cast<PVOID*>(&EventSink));
                //
                // Only notify the pin of the error if the event sink
                // is supported. Failure is ignored.
                //
                if (SUCCEEDED(hrReturn)) {
                    DWORD   DosError;

                    //
                    // The pin will not go away before this module,
                    // so release the reference immediately.
                    //
                    EventSink->Release();
                    DosError = RtlNtStatusToDosError(Error.Status);
                    hrReturn = HRESULT_FROM_WIN32(DosError);
                    EventSink->Notify(
                        EC_ERRORABORT,
                        hrReturn,
                        0);
                }
                NeedErrorIo = TRUE;
            } else {
                //
                // The I/O failed. Exit so that the thead does not
                // just spin.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
            break;
        case WAIT_OBJECT_FLUSH:
            //
            // A client wishes to synchronize with the thread to ensure
            // that all items have been flushed. Turn on the flushing
            // flag so that no more waits will occur until all data has
            // been flushed from the queues.
            //
            Flushing = TRUE;
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovQuality, &BytesReturned, FALSE)) {
                //
                // The current I/O had been completed, so keep trying
                // to perform I/O until a pending return occurs. Then
                // signal the waiter.
                //
                NeedQualityIo = TRUE;
            } else {
                //
                // On error, this will exit the outer loop and terminate
                // the thread. Else a wait on I/O will occur.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr == HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)) {
                    //
                    // No error, the I/O is just outstanding.
                    //
                    hr = NOERROR;
                } else {
                    //
                    // Exit the switch before flushing any Error I/O. This
                    // will then cause an exit of the thread.
                    //
                    break;
                }
            }
            if (GetOverlappedResult(KsQualityF->m_QualityManager, &ovError, &BytesReturned, FALSE)) {
                //
                // The current I/O had been completed, so keep trying
                // to perform I/O until a pending return occurs. Then
                // signal the waiter.
                //
                NeedErrorIo = TRUE;
            } else {
                //
                // On error, this will exit the outer loop and terminate
                // the thread. Else a wait on I/O will occur.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
                if (hr == HRESULT_FROM_WIN32(ERROR_IO_INCOMPLETE)) {
                    //
                    // No error, the I/O is just outstanding.
                    //
                    hr = NOERROR;
                }
            }
            //
            // If no I/O request needs to be made, then everything has been
            // flushed, and flushing for this client has been completed. Signal
            // the semaphore which one or more clients is waiting on, and end
            // the flushing. This will allow the wait to occur again, which
            // might start flushing for another client.
            //
            if (!NeedQualityIo && !NeedErrorIo) {
                //
                // This may restart any random waiter, but it does not matter,
                // since they are all waiting on the same thing.
                //
                SetEvent(KsQualityF->m_FlushEvent);
                Flushing = FALSE;
            }
            break;
        case WAIT_OBJECT_EXIT:
            //
            // The object is being shut down. Set an innocuous
            // error to exit the outer loop.
            //
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            break;
        }
        //
        // Exit the outer loop on failure.
        //
    } while (SUCCEEDED(hr));
    CloseHandle(ovQuality.hEvent);
    CloseHandle(ovError.hEvent);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksqmf\ksqmf.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ksqmf.h

Abstract:

    Internal header.

--*/

class CKsQualityF :
    public CUnknown,
    public IKsQualityForwarder {

public:
    DECLARE_IUNKNOWN

    static CUnknown* CALLBACK CreateInstance(
        LPUNKNOWN UnkOuter,
        HRESULT* hr);

    CKsQualityF(
        LPUNKNOWN UnkOuter,
        TCHAR* Name,
        HRESULT* hr);
    ~CKsQualityF();

    STDMETHODIMP NonDelegatingQueryInterface(
        REFIID InterfaceId,
        PVOID* Interface);

    // Implement IKsQualityForwarder
    STDMETHODIMP_(HANDLE) KsGetObjectHandle();
    STDMETHODIMP_(VOID) KsFlushClient(
        IKsPin* Pin);

private:
    static HRESULT QualityThread(
        CKsQualityF* KsQualityF);

    HANDLE m_QualityManager;
    HANDLE m_Thread;
    HANDLE m_TerminateEvent;
    HANDLE m_FlushEvent;
    HANDLE m_FlushSemaphore;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\dshow\filters.ks\ksproxy\ksutil.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ksutil.cpp

Abstract:

    Provides a generic Active Movie wrapper for a kernel mode filter (WDM-CSA).

Author(s):

    George Shaw (gshaw)

--*/

#include <windows.h>
#ifdef WIN9X_KS
#include <comdef.h>
#endif // WIN9X_KS
#include <setupapi.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>
#include <limits.h>
#include <devioctl.h>
#include <ks.h>
#include <ksmedia.h>
// Define this after including the normal KS headers so exports are
// declared correctly.
#define _KSDDK_
#include <ksproxy.h>

#define GLOBAL_KSIPROXY
#include "ksiproxy.h"
#include "kspipes.h"

const TCHAR MediaInterfacesKeyName[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaInterfaces");
const TCHAR IidNamedValue[] = TEXT("iid");

#if DBG || defined(DEBUG)
ULONG DataFlowVersion=274;
#endif


STDMETHODIMP
KsResolveRequiredAttributes(
    PKSDATARANGE DataRange,
    PKSMULTIPLE_ITEM Attributes OPTIONAL
    )
/*++

Routine Description:

    Attempts to find all attributes in the attribute list within the attributes
    attached to the data range, and ensure that all required attributes in the
    data range have been found.

Arguments:

    DataRange -
        The data range whose attribute list (if any) is to be searched. All
        required attributes in the attached list must be found. Any attribute
        list is assumed to follow the data range.

    Attributes -
        Optionally points to a list of attributes to find in the attribute
        list (if any) attached to the data range.

Return Value:

    Returns NOERROR if the lists were resolved, else ERROR_INVALID_DATA.

--*/
{
    if (Attributes) {
        //
        // If there are no attributes associated with this range, then the
        // function must fail.
        //
        if (!(DataRange->Flags & KSDATARANGE_ATTRIBUTES)) {
            return ERROR_INVALID_DATA;
        }

        PKSMULTIPLE_ITEM RangeAttributes;
        ULONG RequiredAttributes = 0;

        if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
            //
            // Count the required attributes in the range. Each time a required one
            // is encounted that resolves an attribute in the other list, the count
            // can be decremented. In the end, this count should be zero.
            //
            RangeAttributes = reinterpret_cast<PKSMULTIPLE_ITEM>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            PKSATTRIBUTE RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(RangeAttributes + 1);
            for (ULONG RangeCount = RangeAttributes->Count; RangeCount; RangeCount--) {
                if (RangeAttribute->Flags & KSATTRIBUTE_REQUIRED) {
                    RequiredAttributes++;
                }
                RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(RangeAttribute) + ((RangeAttribute->Size + 7) & ~7));
            }
        } else {
            //
            // There are no attributes in the range, so the required count will
            // be zero.
            //
            RangeAttributes = NULL;
        }

        PKSATTRIBUTE Attribute = reinterpret_cast<PKSATTRIBUTE>(Attributes + 1);

        for (ULONG AttributeCount = Attributes->Count; AttributeCount; AttributeCount--) {
            PKSATTRIBUTE RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(RangeAttributes + 1);
            for (ULONG RangeCount = RangeAttributes->Count; RangeCount; RangeCount--) {
                if (RangeAttribute->Attribute == Attribute->Attribute) {
                    //
                    // If the attribute found is required, adjust the count of
                    // outstanding required items. This should be zero at the
                    // end in order to succeed.
                    //
                    if (RangeAttribute->Flags & KSATTRIBUTE_REQUIRED) {
                        RequiredAttributes--;
                    }
                    break;
                }
                RangeAttribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(RangeAttribute) + ((RangeAttribute->Size + 7) & ~7));
            }
            //
            // The attribute could not be found in the range list.
            //
            if (!RangeCount) {
                return ERROR_INVALID_DATA;
            }
            Attribute = reinterpret_cast<PKSATTRIBUTE>(reinterpret_cast<BYTE*>(Attribute) + ((RangeAttribute->Size + 7) & ~7));
        }
        //
        // If all the required attributes were found, then return success.
        // This could be fooled by having the same required attribute present
        // multiple times, and another missing, but this is not a parameter
        // validation check.
        //
        return RequiredAttributes ? ERROR_INVALID_DATA : NOERROR;
    }
    //
    // If no attribute list has been passed in, then the function can only
    // succeed if there are no required attributes to find.
    //
    return (DataRange->Flags & KSDATARANGE_REQUIRED_ATTRIBUTES) ? ERROR_INVALID_DATA : NOERROR;
}


STDMETHODIMP
KsOpenDefaultDevice(
    REFGUID Category,
    ACCESS_MASK Access,
    PHANDLE DeviceHandle
    )
{
    HRESULT     hr;
    HDEVINFO    Set;
    DWORD       LastError;


    //
    // Retrieve the set of items. This may contain multiple items, but
    // only the first (default) item is used.
    //
    Set = SetupDiGetClassDevs(
        const_cast<GUID*>(&Category),
        NULL,
        NULL,
        DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (Set != INVALID_HANDLE_VALUE) {
        //
        // Reserve enough space for a large name, plus the details
        // structure.
        //
        PSP_DEVICE_INTERFACE_DETAIL_DATA    DeviceDetails;
        SP_DEVICE_INTERFACE_DATA            DeviceData;
        BYTE    Storage[sizeof(*DeviceDetails) + 256 * sizeof(TCHAR)];

        DeviceDetails = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(Storage);
        DeviceData.cbSize = sizeof(DeviceData);
        DeviceDetails->cbSize = sizeof(*DeviceDetails);
        //
        // Retrieve the first item in the set. If there are multiple items
        // in the set, the first item is always the "default" for the class.
        //
        if (SetupDiEnumDeviceInterfaces(Set, NULL, const_cast<GUID*>(&Category), 0, &DeviceData) &&
            SetupDiGetDeviceInterfaceDetail(Set, &DeviceData, DeviceDetails, sizeof(Storage), NULL, NULL)) {
            //
            // Open a handle on that item. There will be properties both
            // read and written, so open for read/write.
            //
            *DeviceHandle = CreateFile(
                DeviceDetails->DevicePath,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                NULL);
            if (*DeviceHandle == INVALID_HANDLE_VALUE) {
                //
                // Allow the caller to depend on the value being set to
                // NULL if the call fails.
                //
                *DeviceHandle = NULL;
                //
                // Retrieve creation error.
                //
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            } else {
                hr = S_OK;
            }
        } else {
            //
            // Retrieve enumeration or device details error.
            //
            LastError = GetLastError();
            hr = HRESULT_FROM_WIN32(LastError);
        }
        SetupDiDestroyDeviceInfoList(Set);
    } else {
        //
        // Retrieve class device list error.
        //
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
    }
    return hr;
}

#define STATUS_SOME_NOT_MAPPED      0x00000107
#define STATUS_MORE_ENTRIES         0x00000105
#define STATUS_ALERTED              0x00000101


STDMETHODIMP
KsSynchronousDeviceControl(
    HANDLE Handle,
    ULONG IoControl,
    PVOID InBuffer,
    ULONG InLength,
    PVOID OutBuffer,
    ULONG OutLength,
    PULONG BytesReturned
    )
/*++

Routine Description:

    Performs a synchronous Device I/O Control, waiting for the device to
    complete if the call returns a Pending status.

Arguments:

    Handle -
        The handle of the device to perform the I/O on.

    IoControl -
        The I/O control code to send.

    InBuffer -
        The first buffer.

    InLength -
        The size of the first buffer.

    OutBuffer -
        The second buffer.

    OutLength -
        The size of the second buffer.

    BytesReturned -
        The number of bytes returned by the I/O.

Return Value:

    Returns NOERROR if the I/O succeeded.

--*/
{
    OVERLAPPED  ov;
    HRESULT     hr;
    DWORD       LastError;
    DECLARE_KSDEBUG_NAME(EventName);

    RtlZeroMemory(&ov, sizeof(ov));
    BUILD_KSDEBUG_NAME(EventName, _T("EvKsSynchronousDeviceControl#%p"), &ov.hEvent);
    ov.hEvent = CreateEvent(NULL, TRUE, FALSE, KSDEBUG_NAME(EventName));
    ASSERT(KSDEBUG_UNIQUE_NAME());
    if ( !ov.hEvent ) {
        LastError = GetLastError();
        return HRESULT_FROM_WIN32(LastError);
    }
    if (!DeviceIoControl(
        Handle,
        IoControl,
        InBuffer,
        InLength,
        OutBuffer,
        OutLength,
        BytesReturned,
        &ov)) {
        LastError = GetLastError();
        hr = HRESULT_FROM_WIN32(LastError);
        if (hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING)) {
            if (GetOverlappedResult(Handle, &ov, BytesReturned, TRUE)) {
                hr = NOERROR;
            } else {
                LastError = GetLastError();
                hr = HRESULT_FROM_WIN32(LastError);
            }
        }
    } else {
        //
        // DeviceIoControl returns TRUE on success, even if the success
        // was not STATUS_SUCCESS. It also does not set the last error
        // on any successful return. Therefore any of the successful
        // returns which standard properties can return are not returned.
        //
        switch (ov.Internal) {
        case STATUS_SOME_NOT_MAPPED:
            hr = HRESULT_FROM_WIN32(ERROR_SOME_NOT_MAPPED);
            break;
        case STATUS_MORE_ENTRIES:
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            break;
        case STATUS_ALERTED:
            hr = HRESULT_FROM_WIN32(ERROR_NOT_READY);
            break;
        default:
            hr = NOERROR;
            break;
        }
    }
    CloseHandle(ov.hEvent);
    return hr;
}


STDMETHODIMP
GetState(
    HANDLE Handle,
    PKSSTATE State
    )
/*++

Routine Description:

    Queries a pin handle as to it's current state.

Arguments:

    Handle -
        The handle of the device to query.

    State -
        The place in which to put the current state.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        State,
        sizeof(*State),
        &BytesReturned);
    //
    // It is valid for a filter to not support the State property.
    // Returning a Run state makes pin Activation skip Acquire
    // order checking. If a pin does not keep track of state, then
    // it cannot indicate a need for acquire ordering, since not
    // keeping track of state would not allow it to know anything
    // about acquire ordering.
    //

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE GetState handle=%x %d rets %x"), Handle, *State, hr ));

    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        *State = KSSTATE_RUN;
        hr = NOERROR;

        DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE GetState SUBST handle=%x %d rets %x"), Handle, *State, hr ));
    }
    return hr;
}


STDMETHODIMP
SetState(
    HANDLE Handle,
    KSSTATE State
    )
/*++

Routine Description:

    Sets the state on a pin handle.

Arguments:

    Handle -
        The handle of the device to set.

    State -
        Contains the new state to set.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    ULONG       BytesReturned;
    HRESULT     hr;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_STATE;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &State,
        sizeof(State),
        &BytesReturned);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE SetState handle=%x %d rets %x"), Handle, State, hr ));

    //
    // It is valid for a filter to not support the State property.
    //
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        hr = NOERROR;
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE SetState SUBST handle=%x %d rets %x"), Handle, State, hr ));
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NOT_READY)) {
        hr = S_FALSE;
    }

    return hr;
}


STDMETHODIMP
InitializeDataFormat(
    IN const CMediaType* MediaType,
    IN ULONG InitialOffset,
    OUT PVOID* Format,
    OUT ULONG* FormatLength
    )
/*++

Routine Description:

    Given a media type, allocates and initializes a DataFormat structure.

Arguments:

    MediaType -
        The media type to extract the information from.

    InitialOffset -
        Contains the offset into the buffer at which the data format is to
        be placed. This allows a connection structure to be inserted into
        the buffer returned.

    Format -
        The place in which to return the pointer to the buffer allocated
        that contains the data format at the indicated offset. This must
        be freed with CoTaskMemFree.

    FormatLength -
        The place in which to return the length of the buffer allocated,
        not including any initial offset passed.

Return Value:

    Returns NOERROR on success, else E_OUTOFMEMORY.

--*/
{
    //
    // The media type may have associated attributes. Get a pointer to these
    // first, so that any allocation can take into account the extra space
    // needed.
    //
    PKSMULTIPLE_ITEM Attributes = NULL;
    if (MediaType->pUnk) {
        IMediaTypeAttributes* MediaAttributes;

        //
        // This is the specific interface which must be supported by the
        // attached object. Something else may have attached an object
        // instead, so no assumptions as to what is attached are made.
        //
        if (SUCCEEDED(MediaType->pUnk->QueryInterface(__uuidof(MediaAttributes), reinterpret_cast<PVOID*>(&MediaAttributes)))) {
            MediaAttributes->GetMediaAttributes(&Attributes);
            MediaAttributes->Release();
        }
    }
    //
    // If there are associated attributes, ensure that the data format allocation
    // takes into account the space needed for them.
    //
    *FormatLength = sizeof(KSDATAFORMAT) + MediaType->FormatLength();
    if (Attributes) {
        //
        // Align the data format, then add the attributes length.
        //
        *FormatLength = ((*FormatLength + 7) & ~7) + Attributes->Size;
    }
    *Format = CoTaskMemAlloc(InitialOffset + *FormatLength);
    if (!*Format) {
        return E_OUTOFMEMORY;
    }
    PKSDATAFORMAT DataFormat = reinterpret_cast<PKSDATAFORMAT>(reinterpret_cast<PBYTE>(*Format) + InitialOffset);
    DataFormat->FormatSize = sizeof(*DataFormat) + MediaType->FormatLength();
    DataFormat->Flags = MediaType->IsTemporalCompressed() ? KSDATAFORMAT_TEMPORAL_COMPRESSION : 0;
    DataFormat->SampleSize = MediaType->GetSampleSize();
    DataFormat->Reserved = 0;
    DataFormat->MajorFormat = *MediaType->Type();
    DataFormat->SubFormat = *MediaType->Subtype();
    DataFormat->Specifier = *MediaType->FormatType();
    CopyMemory(DataFormat + 1, MediaType->Format(), MediaType->FormatLength());
    //
    // If there are attributes, then they need to be appended.
    //
    if (Attributes) {
        DataFormat->Flags |= KSDATAFORMAT_ATTRIBUTES;
        CopyMemory(
            reinterpret_cast<PBYTE>(DataFormat) + ((DataFormat->FormatSize + 7) & ~7),
            Attributes,
            Attributes->Size);
    }
    return NOERROR;
}


STDMETHODIMP
SetMediaType(
    HANDLE Handle,
    const CMediaType* MediaType
    )
/*++

Routine Description:

    Given a media type, attempts to set the current data format of a pin.

Arguments:

    Handle -
        Handle of the pin.

    MediaType -
        The media type to extract the information from.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    PKSDATAFORMAT   DataFormat;
    KSPROPERTY      Property;
    HRESULT         hr;
    ULONG           BytesReturned;
    ULONG           FormatSize;

    hr = InitializeDataFormat(MediaType, 0, reinterpret_cast<void**>(&DataFormat), &FormatSize);
    if (FAILED(hr)) {
        return hr;
    }
    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_DATAFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        Handle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DataFormat,
        FormatSize,
        &BytesReturned);
    CoTaskMemFree(DataFormat);
    return hr;
}


STDMETHODIMP
Active(
    IKsPin* KsPin,
    ULONG PinType,
    HANDLE PinHandle,
    KSPIN_COMMUNICATION Communication,
    IPin* ConnectedPin,
    CMarshalerList* MarshalerList,
    CKsProxy* KsProxy
    )
/*++

Routine Description:

    Sets the state to Pause on the specified pin. If the pin is not
    actually connected, then the function silently succeeds. If the
    pin is a Communication Source, and the pin it is connected to is
    also a proxy, then the state of that filter is set to Acquire
    first. If it is connected to a Communication Source, then the
    connected filter is set to Acquire afterwards. The pins which call
    this function first check for recursion in case there is a loop
    in the graph.

Arguments:

    KsPin -
        The pin.

    PinType -
        Type of KsPin.

    PinHandle -
        Handle of the pin.

    Communication -
        Contains the Communication type for this pin.

    ConnectedPin -
        Contains the interface of any connected pin, or NULL if the
        pin is not actually connected.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

    KsProxy -
        This proxy instance object.


Return Value:

    Returns NOERROR, else some failure.

--*/
{
    HRESULT hr;

    //
    // An unconnected pin is fine.
    //
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Active entry KsPin=%x Handle=%x"), KsPin, PinHandle ));

    if (PinHandle) {
        KSSTATE State;

        if (FAILED(hr = GetState(PinHandle, &State))) {
            //
            // In case the pin was already activated for some reason,
            // ignore the expected warning case.
            //
            if ((hr != HRESULT_FROM_WIN32(ERROR_NO_DATA_DETECTED)) ||
                (State != KSSTATE_PAUSE)) {
                return hr;
            }
        }
        //
        // Only if the state is currently stopped should the transition
        // through Acquire be forced. Although it is valid to go specifically
        // to an Acquire state, ActiveMovie does not currently support
        // such a state.
        //
        if (State == KSSTATE_STOP) {
            //
            // This will propagate acquire through all the connected kernel-mode
            // pins graph-wide.
            //
            hr = KsProxy->PropagateAcquire(KsPin, TRUE);

            ::FixupPipe(KsPin, PinType);

            if (FAILED(hr) ) {
                return hr;
            }
        }
        //
        // Only bother changing the state if the pin is not already at the
        // correct state. Since a pipe has a single state, this pin may
        // already be in a Pause state.
        //
        if ((State != KSSTATE_PAUSE) && FAILED(hr = SetState(PinHandle, KSSTATE_PAUSE))) {
            //
            // If the state was Stop, then try to get back to that state on
            // an error, so as to partially clean up. Any other filter which
            // was affected was only put into an Acquire state, and they would
            // have been on the Communication sink side, so this should be
            // fine.
            //
            if (State == KSSTATE_STOP) {
                SetState(PinHandle, KSSTATE_STOP);
                DistributeStop(MarshalerList);
            }
        } else {
            DistributePause(MarshalerList);
        }
    } else {
        hr = NOERROR;
    }
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Active exit KsPin=%x Handle=%x rets %x"), KsPin, PinHandle, hr ));

    return hr;
}


STDMETHODIMP
Run(
    HANDLE PinHandle,
    REFERENCE_TIME tStart,
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Sets the state to Run on the specified pin. The base classes make
    sure that filters transition through all the states, so check should
    not be necessary.

Arguments:

    PinHandle -
        Handle of the pin.

    tStart -
        The offset to the actual starting time. This is ignored for now.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Run handle=%x"), PinHandle ));

    //
    // An unconnected pin is fine.
    //
    if (PinHandle) {
        hr = SetState(PinHandle, KSSTATE_RUN);
    } else {
        hr = NOERROR;
    }
    if (SUCCEEDED(hr)) {
        DistributeRun(MarshalerList, tStart);
    }
    return hr;
}


STDMETHODIMP
Inactive(
    HANDLE PinHandle,
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Sets the state to Stop on the specified pin.

Arguments:

    PinHandle -
        Handle of the pin.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is notified of state changes.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES_STATE Inactive handle=%x"), PinHandle ));

    //
    // An unconnected pin is fine.
    //
    if (PinHandle) {
        hr = SetState(PinHandle, KSSTATE_STOP);
    } else {
        hr = NOERROR;
    }
    DistributeStop(MarshalerList);
    return hr;
}


STDMETHODIMP
CheckConnect(
    IPin* Pin,
    KSPIN_COMMUNICATION CurrentCommunication
    )
/*++

Routine Description:

    Attempts to determine if the specified connection is even possible. This
    is in addition to the basic checking performed by the base classes. Checks
    the Communication type to see if the pin can even be connected to, and if
    it is compatible with the receiving pin.

Arguments:

    Pin -
        The receving pin whose Communication compatibility is to be checked.

    CurrentCommunication -
        The Communication type of the calling pin.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT     hr;
    IKsPin*     KsPin;

    DbgLog((LOG_TRACE, 2, TEXT("::CheckConnect")));

    //
    // Ensure that this pin can even connect to another pin at all.
    //
    if (!(CurrentCommunication & KSPIN_COMMUNICATION_BOTH)) {
        DbgLog((LOG_TRACE, 2, TEXT("failed CurrentCommunication check")));

        hr = E_FAIL;
    } else if (SUCCEEDED(hr = Pin->QueryInterface(__uuidof(IKsPin), reinterpret_cast<PVOID*>(&KsPin)))) {
        DbgLog((LOG_TRACE, 2, TEXT("retrieved peer IKsPin interface")));

        KSPIN_COMMUNICATION PeerCommunication;

        KsPin->KsGetCurrentCommunication(&PeerCommunication, NULL, NULL);
        //
        // Ensure the pin being checked is supports Source and/or Sink,
        // and that the combination of this pin and the peer pin covers
        // both Source and Sink so that one will be able to be Source,
        // and the other Sink.
        //
        if (!(PeerCommunication & KSPIN_COMMUNICATION_BOTH) ||
            (PeerCommunication | CurrentCommunication) != KSPIN_COMMUNICATION_BOTH) {
            hr = E_FAIL;
        }
        KsPin->Release();
    } else if (!(CurrentCommunication & KSPIN_COMMUNICATION_SINK)) {
        //
        // If the pin being checked in not a proxied pin, then this pin
        // must be a Sink.
        //
        DbgLog((LOG_TRACE, 2, TEXT("pin communication != Sink")));
        hr = E_FAIL;
    } else {
        hr = S_OK;
    }
    return hr;
}


STDMETHODIMP
KsGetMultiplePinFactoryItems(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG PropertyId,
    PVOID* Items
    )
/*++

Routine Description:

    Retrieves variable length data from Pin property items. Queries for the
    data size, allocates a buffer, and retrieves the data.

Arguments:

    FilterHandle -
        The handle of the filter to query.

    PinFactoryId -
        The Pin Factory Id to query.

    PropertyId -
        The property in the Pin property set to query.

    Items -
        The place in which to put the buffer containing the data items. This
        must be deleted with CoTaskMemFree if the function succeeds.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    HRESULT     hr;
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = PropertyId;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    //
    // Query for the size of the data.
    //
    hr = KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        NULL,
        0,
        &BytesReturned);
#if 1
//!! This goes away post-Beta!!
    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        ULONG       ItemSize;

        DbgLog((LOG_TRACE, 2, TEXT("Filter does not support zero length property query!")));
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            &ItemSize,
            sizeof(ItemSize),
            &BytesReturned);
        if (SUCCEEDED(hr)) {
            BytesReturned = ItemSize;
            hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
        }
    }
#endif
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the data.
        //
        *Items = CoTaskMemAlloc(BytesReturned);
        if (!*Items) {
            return E_OUTOFMEMORY;
        }
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            &Pin,
            sizeof(Pin),
            *Items,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            CoTaskMemFree(*Items);
        }
    }
    return hr;
}


STDMETHODIMP
FindIdentifier(
    PKSIDENTIFIER TargetIdentifier,
    PKSIDENTIFIER IdentifierList,
    ULONG IdentifierCount
    )
/*++

Routine Description:

    A helper function for FindCompatiblePinFactoryIdentifier. This function
    compares a target to the given list of identifiers, and returns whether
    the target was found in the list.

Arguments:

    TargetIdentifer -
        The target to search for in the list.

    IdentifierList -
        Points to a list of identifiers to compare the target against.

    IdentifierCount -
        Contains the number of items in the identifier list.

Return Value:

    Returns NOERROR if the target was found, else E_FAIL.

--*/
{
    for (; IdentifierCount; IdentifierCount--, IdentifierList++) {
        if (!memcmp(TargetIdentifier, IdentifierList, sizeof(*TargetIdentifier))) {
            return NOERROR;
        }
    }
    return E_FAIL;
}


STDMETHODIMP
FindCompatiblePinFactoryIdentifier(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    ULONG PropertyId,
    PKSIDENTIFIER Identifier
    )
/*++

Routine Description:

    Look for a matching identifier from the property given. This is essentially
    either an Interface or Medium identifier. Enumerate both lists and return
    the first match, if any. The destination may be NULL if just the first item
    is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        identifier only is to be returned.

    PropertyId -
        The property in the Pin property set to query.

    Identifier -
        The place in which to put the matching identifier, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    SourceItems;
    PKSIDENTIFIER       SourceIdentifier;

    //
    // Retrieve both lists of identifiers. Only retrieve the destination list
    // if a destination has been specified.
    //
    if (PropertyId == KSPROPERTY_PIN_MEDIUMS) {
        hr = SourcePin->KsQueryMediums(&SourceItems);
    } else {
        hr = SourcePin->KsQueryInterfaces(&SourceItems);
    }
    if (FAILED(hr)) {
        return hr;
    }
    SourceIdentifier = reinterpret_cast<PKSIDENTIFIER>(SourceItems + 1);
    if (DestPin) {
        PKSMULTIPLE_ITEM    DestItems;
        PKSIDENTIFIER       DestIdentifier;

        if (PropertyId == KSPROPERTY_PIN_MEDIUMS) {
            hr = DestPin->KsQueryMediums(&DestItems);
        } else {
            hr = DestPin->KsQueryInterfaces(&DestItems);
        }
        if (FAILED(hr)) {
            CoTaskMemFree(SourceItems);
            return hr;
        }
        DestIdentifier = (PKSIDENTIFIER)(DestItems + 1);
        hr = E_FAIL;
        //
        // Find the highest identifier in either the source or destination
        // which matches an identifier in the opposing list. This means that
        // instead of just running through each of the identifiers on one
        // list, comparing to all on the opposing list, the loop must look
        // from the top of each list in an alternating style. This produces
        // the exact same number of comparisons as a straight search through
        // one list. The source list is looked at first during each iteration,
        // so it arbitrarily may find a match first.
        //
        for (; SourceItems->Count && DestItems->Count; DestItems->Count--, DestIdentifier++) {
            //
            // For each item in the source, try to find it in the destination.
            //
            hr = FindIdentifier(SourceIdentifier, DestIdentifier, DestItems->Count);
            if (SUCCEEDED(hr)) {
                *Identifier = *SourceIdentifier;
                break;
            }
            //
            // This comparison was already done in the above search, so increment
            // to the next item in the list before doing the next search.
            //
            SourceItems->Count--;
            SourceIdentifier++;
            //
            // For each item in the destination, try to find it in the source.
            //
            hr = FindIdentifier(DestIdentifier, SourceIdentifier, SourceItems->Count);
            if (SUCCEEDED(hr)) {
                *Identifier = *DestIdentifier;
                break;
            }
        }
        CoTaskMemFree(DestItems);
    } else {
        KSPIN_INTERFACE Standard;

        //
        // If there is no destination, just return the first item. This is
        // for the case of a Bridge or UserMode to KernelMode connection.
        // If this is an Interface query, then given preference to the
        // standard interface first, else choose the first item if not
        // present in the list.
        //
        if (PropertyId == KSPROPERTY_PIN_INTERFACES) {
            Standard.Set = KSINTERFACESETID_Standard;
            Standard.Id = KSINTERFACE_STANDARD_STREAMING;
            Standard.Flags = 0;
            if (SUCCEEDED(FindIdentifier(&Standard, SourceIdentifier, SourceItems->Count))) {
                SourceIdentifier = &Standard;
            }
        }
        *Identifier = *SourceIdentifier;
    }
    CoTaskMemFree(SourceItems);
    return hr;
}


STDMETHODIMP
FindCompatibleInterface(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_INTERFACE Interface
    )
/*++

Routine Description:

    Look for a matching Interface given a pair of pins. The destination
    may be NULL if just the first Interface is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        Interface only is to be returned.

    Interface -
        The place in which to put the matching Interface, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    if (DestPin && SUCCEEDED(DestPin->KsGetCurrentCommunication(NULL, Interface, NULL))) {
        return NOERROR;
    }
    return FindCompatiblePinFactoryIdentifier(SourcePin, DestPin, KSPROPERTY_PIN_INTERFACES, Interface);
}


STDMETHODIMP
FindCompatibleMedium(
    IKsPin* SourcePin,
    IKsPin* DestPin,
    PKSPIN_MEDIUM Medium
    )
/*++

Routine Description:

    Look for a matching Medium given a pair of pins. The destination
    may be NULL if just the first Interface is to be returned.

Arguments:

    SourcePin -
        The source pin to enumerate.

    DestPin -
        The destination pin to enumerate. This can be NULL if the first
        Medium only is to be returned.

    Interface -
        The place in which to put the matching Medium, if any.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT hr;

    if (DestPin && SUCCEEDED(hr = DestPin->KsGetCurrentCommunication(NULL, NULL, Medium))) {
        return hr;
    }
    return FindCompatiblePinFactoryIdentifier(SourcePin, DestPin, KSPROPERTY_PIN_MEDIUMS, Medium);
}


STDMETHODIMP
SetDevIoMedium(
    IKsPin* Pin,
    PKSPIN_MEDIUM Medium
    )
/*++

Routine Description:

    Set the Medium type to be that used for DevIo communication compatible with
    a Communication Sink or Bridge which the proxy can talk to.

Arguments:

    Pin -
        The pin which will be communicated with.

    Medium
        The Medium structure to initialize.

Return Value:

    Returns NOERROR.

--*/
{
    Medium->Set = KSMEDIUMSETID_Standard;
    Medium->Id = KSMEDIUM_TYPE_ANYINSTANCE;
    Medium->Flags = 0;
    return NOERROR;
}


STDMETHODIMP
KsGetMediaTypeCount(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    ULONG* MediaTypeCount
    )
/*++

Routine Description:

    The the count of media types, which is the same as the count of data
    ranges on a Pin Factory Id.

Arguments:

    FilterHandle -
        The filter containing the Pin Factory to query.

    PinFactoryId -
        The Pin Factory Id whose data range count is to be queries.

    MediaTypeCount -
        The place in which to put the count of media types supported.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    HRESULT hr = KsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr)) {
        hr = KsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
    }
    if (SUCCEEDED(hr)) {

        /* NULL == MultipleItem is a pathological case where a driver returns
           a success code in KsGetMultiplePinFactoryItems() when passed a size 0
           buffer.  We'll just do with an assert since we're in ring 3. */
        ASSERT( NULL != MultipleItem );

        //
        // Enumerate the list, subtracting from the count returned the
        // number of attribute lists found. This means the count returned
        // is the actual number of data ranges, not the count returned by
        // the driver.
        //
        *MediaTypeCount = MultipleItem->Count;
        PKSDATARANGE DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
        for (; MultipleItem->Count--;) {
            //
            // If a data range has attributes, advance twice, reducing the
            // current count, and the count returned to the caller.
            //
            if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                MultipleItem->Count--;
                (*MediaTypeCount)--;
                //
                // This must be incremented here so that overlapping attribute
                // flags do not confuse the count.
                //
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
        }
        CoTaskMemFree(MultipleItem);
    }
    return hr;
}


STDMETHODIMP
KsGetMediaType(
    int Position,
    AM_MEDIA_TYPE* AmMediaType,
    HANDLE FilterHandle,
    ULONG PinFactoryId
    )
/*++

Routine Description:

    Returns the specified media type on the Pin Factory Id. This is done
    by querying the list of data ranges, and performing a data intersection
    on the specified data range, producing a data format. Then converting
    that data format to a media type.

Arguments:

    Position -
        The zero-based position to return. This corresponds to the data range
        item.

    AmMediaType -
        The media type to initialize.

    FilterHandle -
        The filter containing the Pin Factory to query.

    PinFactoryId -
        The Pin Factory Id whose nth media type is to be returned.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT             hr;
    PKSMULTIPLE_ITEM    MultipleItem = NULL;

    if (Position < 0) {
        return E_INVALIDARG;
    }
    //
    // Retrieve the list of data ranges supported by the Pin Factory Id.
    //
    hr = KsGetMultiplePinFactoryItems(
        FilterHandle,
        PinFactoryId,
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
        reinterpret_cast<PVOID*>(&MultipleItem));
    if (FAILED(hr)) {
        hr = KsGetMultiplePinFactoryItems(
            FilterHandle,
            PinFactoryId,
            KSPROPERTY_PIN_DATARANGES,
            reinterpret_cast<PVOID*>(&MultipleItem));
        if (FAILED(hr)) {
            return hr;
        }
    }

    /* NULL == MultipleItem is a pathological case where a driver returns
       a success code in KsGetMultiplePinFactoryItems() when passed a size 0
       buffer.  We'll just do with an assert since we're in ring 3. */
    ASSERT( NULL != MultipleItem );

    //
    // Ensure that this is in range.
    //
    if ((ULONG)Position < MultipleItem->Count) {
        PKSDATARANGE        DataRange;
        PKSP_PIN            Pin;
        PKSMULTIPLE_ITEM    RangeMultipleItem;
        PKSMULTIPLE_ITEM    Attributes;
        ULONG               BytesReturned;

        DataRange = reinterpret_cast<PKSDATARANGE>(MultipleItem + 1);
        //
        // Increment to the correct data range element.
        //
        for (; Position; Position--) {
            //
            // If this data range has associated attributes, skip past the
            // range so that the normal advancement will skip past the attributes.
            // Note that the attributes also have a size parameter as the first
            // structure element.
            //
            if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
                //
                // The count returned includes attribute lists, so check again
                // that the position is within range of the actual list of ranges.
                // The Position has not been decremented yet.
                //
                MultipleItem->Count--;
                if ((ULONG)Position >= MultipleItem->Count) {
                    CoTaskMemFree(MultipleItem);
                    return VFW_S_NO_MORE_ITEMS;
                }
                DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            }
            DataRange = reinterpret_cast<PKSDATARANGE>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            MultipleItem->Count--;
        }
        //
        // Calculate the query size once, adding in any attributes, which are
        // LONGLONG aligned.
        //
        ULONG QueryBufferSize = sizeof(*Pin) + sizeof(*RangeMultipleItem) + DataRange->FormatSize;
        if (DataRange->Flags & KSDATARANGE_ATTRIBUTES) {
            Attributes = reinterpret_cast<PKSMULTIPLE_ITEM>(reinterpret_cast<BYTE*>(DataRange) + ((DataRange->FormatSize + 7) & ~7));
            QueryBufferSize = ((QueryBufferSize + 7) & ~7) + Attributes->Size;
        } else {
            Attributes = NULL;
        }
        Pin = reinterpret_cast<PKSP_PIN>(new BYTE[QueryBufferSize]);
        if (!Pin) {
            CoTaskMemFree(MultipleItem);
            return E_OUTOFMEMORY;
        }
        Pin->Property.Set = KSPROPSETID_Pin;
        Pin->Property.Id = KSPROPERTY_PIN_DATAINTERSECTION;
        Pin->Property.Flags = KSPROPERTY_TYPE_GET;
        Pin->PinId = PinFactoryId;
        Pin->Reserved = 0;
        //
        // Copy the data range into the query.
        //
        RangeMultipleItem = reinterpret_cast<PKSMULTIPLE_ITEM>(Pin + 1);
        RangeMultipleItem->Size = sizeof(*RangeMultipleItem) + DataRange->FormatSize;
        RangeMultipleItem->Count = 1;
        CopyMemory(RangeMultipleItem + 1, DataRange, DataRange->FormatSize);
        //
        // If there are associated attributes, then add them as the next item
        // on the list. Space has already been made available for them.
        //
        if (Attributes) {
            RangeMultipleItem->Size = ((RangeMultipleItem->Size + 7) & ~7) + Attributes->Size;
            RangeMultipleItem->Count++;
            CopyMemory(
                reinterpret_cast<BYTE*>(RangeMultipleItem) + RangeMultipleItem->Size - Attributes->Size,
                Attributes,
                Attributes->Size);
        }
        //
        // Perform the data intersection with the data range, first to obtain
        // the size of the resultant data format structure, then to retrieve
        // the actual data format.
        //
        hr = KsSynchronousDeviceControl(
            FilterHandle,
            IOCTL_KS_PROPERTY,
            Pin,
            QueryBufferSize,
            NULL,
            0,
            &BytesReturned);
#if 1
//!! This goes away post-Beta!!
        if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            ULONG       ItemSize;

            DbgLog((LOG_TRACE, 2, TEXT("Filter does not support zero length property query!")));
            hr = KsSynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                QueryBufferSize,
                &ItemSize,
                sizeof(ItemSize),
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                BytesReturned = ItemSize;
                hr = HRESULT_FROM_WIN32(ERROR_MORE_DATA);
            }
        }
#endif
        if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
            PKSDATAFORMAT       DataFormat;

            ASSERT(BytesReturned >= sizeof(*DataFormat));
            DataFormat = reinterpret_cast<PKSDATAFORMAT>(new BYTE[BytesReturned]);
            if (!DataFormat) {
                delete [] (PBYTE)Pin;
                CoTaskMemFree(MultipleItem);
                return E_OUTOFMEMORY;
            }
            hr = KsSynchronousDeviceControl(
                FilterHandle,
                IOCTL_KS_PROPERTY,
                Pin,
                QueryBufferSize,
                DataFormat,
                BytesReturned,
                &BytesReturned);
            if (SUCCEEDED(hr)) {
                ASSERT(DataFormat->FormatSize == BytesReturned);
                CMediaType* MediaType = static_cast<CMediaType*>(AmMediaType);
                //
                // Initialize the media type based on the returned data format.
                //
                MediaType->SetType(&DataFormat->MajorFormat);
                MediaType->SetSubtype(&DataFormat->SubFormat);
                MediaType->SetTemporalCompression(DataFormat->Flags & KSDATAFORMAT_TEMPORAL_COMPRESSION);
                MediaType->SetSampleSize(DataFormat->SampleSize);
                if (DataFormat->FormatSize > sizeof(*DataFormat)) {
                    if (!MediaType->SetFormat(reinterpret_cast<BYTE*>(DataFormat + 1), DataFormat->FormatSize - sizeof(*DataFormat))) {
                        hr = E_OUTOFMEMORY;
                    }
                }
                MediaType->SetFormatType(&DataFormat->Specifier);
                //
                // If the returned format has associated attributes, then attach
                // them to the media type via the IUnknown interface available.
                // This attached object caches the attributes for later retrieval.
                //
                if (DataFormat->Flags & KSDATAFORMAT_ATTRIBUTES) {
                    CMediaTypeAttributes* MediaTypeAttributes = new CMediaTypeAttributes();
                    if (MediaTypeAttributes) {
                        MediaType->pUnk = static_cast<IUnknown*>(MediaTypeAttributes);
                        hr = MediaTypeAttributes->SetMediaAttributes(Attributes);
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            delete [] reinterpret_cast<BYTE*>(DataFormat);
        }
        delete [] reinterpret_cast<BYTE*>(Pin);
    } else {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    CoTaskMemFree(MultipleItem);
    return hr;
}


STDMETHODIMP_(KSPIN_COMMUNICATION)
ChooseCommunicationMethod(
    CBasePin* SourcePin,
    IKsPin* DestPin
    )
/*++

Routine Description:

    Returns the correct Communication method to use based on the source's
    Communication, and the destination. Note that in the case of a tie, where
    Both is supported, the Data Flow is used so that two proxies will not
    keep choosing the same Communication type.

Arguments:

    SourcePin -
        The source pin from this proxy instance.

    DestPin -
        The standard interface of a pin from some other proxy.

Return Value:

    Returns the Communication type chosen for this pin.

--*/
{
    KSPIN_COMMUNICATION PeerCommunication;
    PIN_DIRECTION       PinDirection;

    DestPin->KsGetCurrentCommunication(&PeerCommunication, NULL, NULL);
    switch (PeerCommunication) {
    case KSPIN_COMMUNICATION_SINK:
        return KSPIN_COMMUNICATION_SOURCE;
    case KSPIN_COMMUNICATION_SOURCE:
        return KSPIN_COMMUNICATION_SINK;
    case KSPIN_COMMUNICATION_BOTH:
        //
        // A tie is broken by using the Data Flow.
        //
        SourcePin->QueryDirection(&PinDirection);
        switch (PinDirection) {
        case PINDIR_INPUT:
            return KSPIN_COMMUNICATION_SINK;
        case PINDIR_OUTPUT:
            return KSPIN_COMMUNICATION_SOURCE;
        }
    }
    //
    // The compiler really wants a return here, even though the
    // parameter is an enumeration, and all items in the enumeration
    // are covered.
    //
    return KSPIN_COMMUNICATION_NONE;
}


STDMETHODIMP
CreatePinHandle(
    KSPIN_INTERFACE& Interface,
    KSPIN_MEDIUM& Medium,
    HANDLE PeerPinHandle,
    CMediaType* MediaType,
    CKsProxy* KsProxy,
    ULONG PinFactoryId,
    ACCESS_MASK DesiredAccess,
    HANDLE* PinHandle
    )
/*++

Routine Description:

    Create a pin handle given all the information to initialize the structures
    with.

Arguments:

    Interface -
        The compatible Interface to use.

    Medium -
        The compatible Medium to use.

    PeerPinHandle -
        The Pin handle to connect to, if any.

    MediaType -
        The compatible media type, which is converted to a data format.

    KsProxy -
        This proxy instance object.

    PinFactoryId -
        The Pin Factory Id to create the pin handle on.

    DesiredAccess -
        The desired access to the created handle.

    PinHandle -
        The place in which to put the handle created.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    HRESULT         hr;
    PKSPIN_CONNECT  Connect;
    DWORD           Error;
    ULONG           FormatSize;

    hr = InitializeDataFormat(
        MediaType,
        sizeof(*Connect),
        reinterpret_cast<void**>(&Connect),
        &FormatSize);
    if (FAILED(hr)) {
        return hr;
    }
    Connect->Interface = Interface;
    Connect->Medium = Medium;
    Connect->PinId = PinFactoryId;
    Connect->PinToHandle = PeerPinHandle;
    Connect->Priority.PriorityClass = KSPRIORITY_NORMAL;
    Connect->Priority.PrioritySubClass = KSPRIORITY_NORMAL;
    Error = KsCreatePin(
        KsProxy->KsGetObjectHandle(),
        Connect,
        DesiredAccess,
        PinHandle );
    hr = HRESULT_FROM_WIN32(Error);
    if (SUCCEEDED( hr )) {
        hr = KsProxy->SetPinSyncSource(*PinHandle);
    } else {
        *PinHandle = NULL;
    }
    CoTaskMemFree(Connect);
    return hr;
}

#ifdef DEBUG_PROPERTY_PAGES

STDMETHODIMP_(VOID)
AppendDebugPropertyPages (
    CAUUID* Pages,
    TCHAR *GuidRoot
    )

/*++

Routine Description:

    Search HKLM\*GuidRoot\DebugPages for any globally defined
    property pages used for debugging.  If such are defined, append them
    to the list of property pages specified in Pages. 

    Note: This routine is only defined when DEBUG_PROPERTY_PAGES is defined.
    I do this such that it can be enabled when needed and disabled when
    shipping.

Arguments:

    Pages -
        The list of property pages

    GuidRoot -
        The HKLM based location where to find the DebugPages key.

--*/

{

    TCHAR       RegistryPath[256];
    HKEY        RegistryKey;
    LONG        Result;

    //
    // The PropertyPages subkey can contain a list of subkeys
    // whose names correspond to COM servers of property pages.
    //
    _stprintf(
        RegistryPath,
        TEXT("%s\\DebugPages"),
        GuidRoot
        );
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        RegistryPath,
        0,
        KEY_READ,
        &RegistryKey);

    if (Result == ERROR_SUCCESS) {

        //
        // Enumerate all subkeys for CLSID's of debug property page COM
        // servers.
        //
        for (ULONG PropExtension = 0;; PropExtension++) {
            TCHAR   PageGuidString[40];
            CLSID*  PageList;
            GUID    PageGuid;
            ULONG   Element;
            GUID*   CurElement;

            Result = RegEnumKey(
                RegistryKey,
                PropExtension,
                PageGuidString,
                sizeof(PageGuidString)/sizeof(TCHAR));

            if (Result != ERROR_SUCCESS) {
                break;
            }

#ifdef _UNICODE
            IIDFromString(PageGuidString, &PageGuid);
#else
            WCHAR   UnicodeGuid[64];

            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, PageGuidString, -1, 
                UnicodeGuid, sizeof(UnicodeGuid));
            IIDFromString(UnicodeGuid, &PageGuid);
#endif

            //
            // Look through the list of items to determine
            // if this proppage is already on the list.
            //
            for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                if (PageGuid == *CurElement) {
                    break;
                }
            }
            //
            // If the page id for the proppage was found, then
            // skip it, since it is already on the list.
            //
            if (Element) {
                continue;
            }
                    //
            // Allocate a new list to include the extra Guid, and
            // move the guids to the new memory, then add on the
            // new guid and increment the total count of pages.
            //
            PageList = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * (Pages->cElems + 1)));
            if (!PageList) {
                break;
            }
            //
            // This function can be called with no original property
            // pages present.
            //
            if (Pages->cElems) {
                CopyMemory(PageList, Pages->pElems, sizeof(*Pages->pElems) * Pages->cElems);
                CoTaskMemFree(Pages->pElems);
            }
            Pages->pElems = PageList;
            Pages->pElems[Pages->cElems++] = PageGuid;
        }
        RegCloseKey(RegistryKey);
    }
}

#endif // DEBUG_PROPERTY_PAGES


STDMETHODIMP_(VOID)
AppendSpecificPropertyPages(
    CAUUID* Pages,
    ULONG Guids,
    GUID* GuidList,
    TCHAR* GuidRoot,
    HKEY DeviceRegKey
    )
/*++

Routine Description:

    This appends any additional property pages that are specific to each category
    or interface class guid passed. Skips duplicate pages.

Arguments:

    Pages -
        The structure to fill in with the page added list.

    Guids -
        Contains the number of guids present in GuidList.

    GuidList -
        The list of guids to use to look up under media categories for additional
        pages to append to the page list.

    GuidRoot -
        The root in HKLM that may contain the guid as a subkey. This is opened
        to locate the guid subkey and any property pages present.

    DeviceRegKey -
        The handle to the device registry storage location.

Return Value:

    Nothing.

--*/
{
    HKEY        AliasKey;

    //
    // Open the Page Aliases key if it exists in order to translate any
    // guids to private ones in case an alternate COM server is to be
    // used for a particular Property Page.
    //
    if (RegOpenKeyEx(DeviceRegKey, TEXT("PageAliases"), 0, KEY_READ, &AliasKey) != ERROR_SUCCESS) {
        AliasKey = NULL;
    }
    for (; Guids--;) {
        WCHAR      GuidString[CHARS_IN_GUID];

        StringFromGUID2(GuidList[Guids], GuidString, CHARS_IN_GUID);
        {
            TCHAR       RegistryPath[256];
            HKEY        RegistryKey;
            LONG        Result;

            //
            // The PropertyPages subkey can contain a list of subkeys
            // whose names correspond to COM servers of property pages.
            //
            _stprintf(
                RegistryPath,
                TEXT("%s\\") GUID_FORMAT TEXT("\\PropertyPages"),
                GuidRoot,
                GuidString);
            Result = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegistryPath,
                0,
                KEY_READ,
                &RegistryKey);
            if (Result == ERROR_SUCCESS) {
                //
                // Enumerate the subkeys as Guids which are COM classes. Each
                // one found is added to the list of property pages after
                // expanding the property page list.
                //
                for (ULONG PropExtension = 0;; PropExtension++) {
                    TCHAR   PageGuidString[40];
                    CLSID*  PageList;
                    GUID    PageGuid;
                    ULONG   Element;
                    GUID*   CurElement;

                    Result = RegEnumKey(
                        RegistryKey,
                        PropExtension,
                        PageGuidString,
                        NUMELMS(PageGuidString));
                    if (Result != ERROR_SUCCESS) {
                        break;
                    }
                    if (AliasKey) {
                        ULONG       ValueSize;

                        //
                        // Check in the device registry key if there is an alias for
                        // this Page guid that should be used with any object on this
                        // filter. This allows a filter to override standard Page
                        // COM servers, in order to provide their own Page.
                        //
                        ValueSize = sizeof(PageGuid);
                        //
                        // If this succeeds, then IIDFromString is skipped below,
                        // since the IID is already acquired. Else the translation
                        // with the original GUID happens.
                        //
                        Result = RegQueryValueEx(
                            AliasKey,
                            PageGuidString,
                            NULL,
                            NULL,
                            (PBYTE)&PageGuid,
                            &ValueSize);
                    } else {
                        //
                        // Set the Result value to something other than
                        // ERROR_SUCCESS so that the string translation
                        // is done.
                        //
                        Result = ERROR_INVALID_FUNCTION;
                    }
                    if (Result != ERROR_SUCCESS) {
                        //
                        // No alias was found, so translate the original
                        // string. Else the alias will be in PageGuid.
                        //
#ifdef _UNICODE
                        IIDFromString(PageGuidString, &PageGuid);
#else
                        WCHAR   UnicodeGuid[64];

                        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, PageGuidString, -1, UnicodeGuid, sizeof(UnicodeGuid));
                        IIDFromString(UnicodeGuid, &PageGuid);
#endif
                    }
                    //
                    // Look through the list of items to determine
                    // if this proppage is already on the list.
                    //
                    for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                        if (PageGuid == *CurElement) {
                            break;
                        }
                    }
                    //
                    // If the page id for the proppage was found, then
                    // skip it, since it is already on the list.
                    //
                    if (Element) {
                        continue;
                    }
                    //
                    // Allocate a new list to include the extra Guid, and
                    // move the guids to the new memory, then add on the
                    // new guid and increment the total count of pages.
                    //
                    PageList = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * (Pages->cElems + 1)));
                    if (!PageList) {
                        break;
                    }
                    //
                    // This function can be called with no original property
                    // pages present.
                    //
                    if (Pages->cElems) {
                        CopyMemory(PageList, Pages->pElems, sizeof(*Pages->pElems) * Pages->cElems);
                        CoTaskMemFree(Pages->pElems);
                    }
                    Pages->pElems = PageList;
                    Pages->pElems[Pages->cElems++] = PageGuid;
                }
                RegCloseKey(RegistryKey);
            }
        }
    }
    if (AliasKey) {
        RegCloseKey(AliasKey);
    }
}


STDMETHODIMP
GetPages(
    IKsObject* Pin,
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    KSPIN_COMMUNICATION Communication,
    HKEY DeviceRegKey,
    CAUUID* Pages
    )
/*++

Routine Description:

    This adds any Specifier handlers to the property pages if the pin instance
    is still unconnected and it is a Bridge pin. Else it adds none.

Arguments:

    Pin -
        The pin on this filter which the property pages are to be created.

    FilterHandle -
        The handle to this filter.

    PinFactoryId -
        The Pin Factory Id that the pin represents.

    Communication -
        The Communications type of this pin.

    DeviceRegKey -
        The handle to the device registry storage location.

    Pages -
        The structure to fill in with the page list.

Return Value:

    Returns NOERROR, else a memory allocation error. Fills in the list of pages
    and page count.

--*/
{
    ULONG   MediaTypeCount;
    GUID    PinCategory;
    KSP_PIN PinProp;
    ULONG   BytesReturned;

    MediaTypeCount = 0;
    Pages->cElems = 0;
    Pages->pElems = NULL;
    //
    // Only add pages if the pin is a Bridge and it is not already connected.
    // The pages are a method to connect a Bridge using UI.
    //
    if ((Communication == KSPIN_COMMUNICATION_BRIDGE) && !Pin->KsGetObjectHandle()) {
        KsGetMediaTypeCount(FilterHandle, PinFactoryId, &MediaTypeCount);
    }
    //
    // This is zero if the pin is not a bridge, or if it already connected, or
    // a media type count query failed.
    //
    if (MediaTypeCount) {
        Pages->pElems = reinterpret_cast<CLSID*>(CoTaskMemAlloc(sizeof(*Pages->pElems) * MediaTypeCount));
        if (!Pages->pElems) {
            return E_OUTOFMEMORY;
        }
        //
        // Each Specifier can be represented in a page.
        //
        for (CLSID* Elements = Pages->pElems; MediaTypeCount--;) {
            AM_MEDIA_TYPE AmMediaType;

            ZeroMemory(reinterpret_cast<PVOID>(&AmMediaType), sizeof(AmMediaType));
            if (SUCCEEDED(KsGetMediaType(MediaTypeCount, &AmMediaType, FilterHandle, PinFactoryId))) {
                WCHAR       ClassString[CHARS_IN_GUID];
                TCHAR       ClassRegistryPath[256];
                HKEY        ClassRegistryKey;
                LONG        Result;
                ULONG       ValueSize;
                ULONG       Element;
                GUID        ClassId;
                GUID*       CurElement;

                //
                // Since there can be data format handlers based on
                // Specifiers that are used by the proxy, and may
                // be registered under the guid of the Specifier,
                // these handlers are indirected through another
                // registry key, so that they can be registered with
                // an alternate GUID.
                //
                StringFromGUID2(AmMediaType.formattype, ClassString, CHARS_IN_GUID);
                _stprintf(
                    ClassRegistryPath,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaSpecifiers\\") GUID_FORMAT,
                    ClassString);
                Result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ClassRegistryPath, 0, KEY_READ, &ClassRegistryKey);
                //
                // If the key does not exist, this is OK, as there may be
                // no property page to load.
                //
                if (Result != ERROR_SUCCESS) {
                    continue;
                }
                ValueSize = sizeof(ClassId);
                Result = RegQueryValueEx(
                    ClassRegistryKey,
                    TEXT("clsid"),
                    NULL,
                    NULL,
                    reinterpret_cast<BYTE*>(&ClassId),
                    &ValueSize);
                RegCloseKey(ClassRegistryKey);
                if (Result != ERROR_SUCCESS) {
                    continue;
                }
                //
                // Look through the list of items to determine
                // if this Specifier is already on the list.
                //
                for (CurElement = Pages->pElems, Element = Pages->cElems; Element; Element--, CurElement++) {
                    if (ClassId == *CurElement) {
                        break;
                    }
                }
                //
                // If the class id for the Specifier was found, then
                // skip it, since it is already on the list.
                //
                if (Element) {
                    continue;
                }
                //
                // Add the new specifier.
                //
                Pages->cElems++;
                *(Elements++) = ClassId;
            }
        }
    }

    //
    // If DEBUG_PROPERTY_PAGES is defined, append any property pages used
    // for debugging.  Note that this does not have to be a debug build of
    // KsProxy in order to use this.  These are property pages useful for
    // debugging issues internal to KsProxy, AVStream, etc...  They will be
    // placed on **ALL** proxied pins.  To turn off this feature, do not
    // define DEBUG_PROPERTY_PAGES
    //
    #ifdef DEBUG_PROPERTY_PAGES
        AppendDebugPropertyPages (
            Pages,
            TEXT("Software\\Microsoft\\KsProxy")
            );
    #endif // DEBUG_PROPERTY_PAGES
    //
    // Look for a category guid in order to check for additional property pages
    // which may be based on the category of the pin.
    //
    PinProp.Property.Set = KSPROPSETID_Pin;
    PinProp.Property.Id = KSPROPERTY_PIN_CATEGORY;
    PinProp.Property.Flags = KSPROPERTY_TYPE_GET;
    PinProp.PinId = PinFactoryId;
    PinProp.Reserved = 0;
    if (SUCCEEDED(KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &PinProp,
        sizeof(PinProp),
        &PinCategory,
        sizeof(PinCategory),
        &BytesReturned))) {
        //
        // Both categories and interface classes are all placed in the same
        // registry location.
        //
        AppendSpecificPropertyPages(
            Pages,
            1,
            &PinCategory,
            TEXT("SYSTEM\\CurrentControlSet\\Control\\MediaCategories"),
            DeviceRegKey);
    }
    return NOERROR;
}


STDMETHODIMP
GetPinFactoryInstances(
    HANDLE FilterHandle,
    ULONG PinFactoryId,
    PKSPIN_CINSTANCES Instances
    )
/*++

Routine Description:

    Retrieves the pin instance count of the specified Pin Factory Id.

Arguments:

    FilterHandle -
        The handle to this filter.

    PinFactoryId -
        The Pin Factory Id to query.

    Instance -
        The place in which to put the instance information.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSP_PIN     Pin;
    ULONG       BytesReturned;

    Pin.Property.Set = KSPROPSETID_Pin;
    Pin.Property.Id = KSPROPERTY_PIN_CINSTANCES;
    Pin.Property.Flags = KSPROPERTY_TYPE_GET;
    Pin.PinId = PinFactoryId;
    Pin.Reserved = 0;
    return KsSynchronousDeviceControl(
        FilterHandle,
        IOCTL_KS_PROPERTY,
        &Pin,
        sizeof(Pin),
        Instances,
        sizeof(*Instances),
        &BytesReturned);
}


STDMETHODIMP
SetSyncSource(
    HANDLE PinHandle,
    HANDLE ClockHandle
    )
/*++

Routine Description:

    Sets the master clock on the specified pin handle, if that pin handle
    cares about clocks.

Arguments:

    PinHandle -
        The handle to the pin to set the clock on.

    ClockHandle -
        The handle of the clock to use.

Return Value:

    Returns NOERROR, else E_FAIL.

--*/
{
    KSPROPERTY  Property;
    HRESULT     hr;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &ClockHandle,
        sizeof(ClockHandle),
        &BytesReturned);
    if ((hr == HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_NOT_FOUND))) {
        return NOERROR;
    }
    return hr;
}


STDMETHODIMP_(CAggregateMarshaler*)
FindInterface(
    CMarshalerList* MarshalerList,
    CAggregateMarshaler* FindAggregate
    )
/*++

Routine Description:

    Looks for the specified aggregate on the list.

Arguments:

    MarshalerList -
        Points to the list of interfaces to search.

    FindAggregate -
        Contains the aggregate to look for.

Return Value:

    Returns the aggregate entry if found, else NULL.

--*/
{
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler*Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        //
        // Don't skip static aggregates, since they can override
        // dynamic ones.
        //
        if ((FindAggregate->m_iid == Aggregate->m_iid) &&
            (FindAggregate->m_ClassId == Aggregate->m_ClassId)) {
            return Aggregate;
        }
    }
    return NULL;
}


STDMETHODIMP
AddAggregateObject(
    CMarshalerList* MarshalerList,
    CAggregateMarshaler* Aggregate,
    IUnknown* UnkOuter,
    BOOL Volatile
    )
/*++

Routine Description:

    Looks for the specified aggregate on the list, and if it is not already
    present, adds the object passed, else deletes the object passed.

Arguments:

    MarshalerList -
        Points to the list of interfaces to search, and which to add the
        new item.

    Aggregate -
        Contains the aggregate to look for, and which to add to the list if
        it is unique. This is destroyed if it is not unique.

    UnkOuter -
        The outer IUnknown which is used in the CoCreateInstance if a new
        aggregate is being added.

    Volatile -
        Indicates whether or not this is a volatile interface. This is used
        to initialize the volatile setting of the aggregate object.

Return Value:

    Returns the aggregate entry if found, in which case the
    Reconnected flag is set, else NULL.

--*/
{
    CAggregateMarshaler*    OldAggregate;
    HRESULT                 hr;

    //
    // If the interface is already on the marshaler list, then
    // just set the entry. Else try to make a new instance to
    // place on the list.
    //
    if (OldAggregate = FindInterface(MarshalerList, Aggregate)) {
        //
        // Since the Static interfaces are loaded at the start,
        // a Static interface cannot be a duplicate of a Volatile
        // interface.
        //
        ASSERT(Volatile || (Volatile == OldAggregate->m_Volatile));
        //
        // Any old error code to make the object passed in be deleted.
        //
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        //
        // Since the aggregate is being re-used, then notify it
        // that a reconnection is being performed. This can only
        // be done if IDistributorNotify is supported. If not, then
        // it is assumed that the aggregate does not care about
        // reconnections. Static aggregates are notified during set
        // aggregation. Also, only do the notification once per
        // connection.
        //
        if (OldAggregate->m_Volatile && !OldAggregate->m_Reconnected) {
            //
            // A matching aggregate has been found. Mark it as being
            // in use, so that cleanup will leave this intact. This
            // also means that it has been notified on reconnection.
            //
            OldAggregate->m_Reconnected = TRUE;
            if (OldAggregate->m_DistributorNotify) {
                OldAggregate->m_DistributorNotify->NotifyGraphChange();
            }
        }
    } else {
        hr = CoCreateInstance(Aggregate->m_ClassId,
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(&Aggregate->m_Unknown));
    }
    if (SUCCEEDED(hr)) {
        //
        // Query for the generic interface which is used to notify extensions
        // of changes. This does not have to be supported. If not supported,
        // then it just will not be notified.
        //
        if (SUCCEEDED(Aggregate->m_Unknown->QueryInterface(
            __uuidof(IDistributorNotify),
            reinterpret_cast<PVOID*>(&Aggregate->m_DistributorNotify)))) {
            //
            // If the distributor interface was supported, meaning that the
            // interface handler does cares about change notification, the
            // reference count on the object is adjusted so that it is still
            // one.
            //
            Aggregate->m_DistributorNotify->Release();
        }
        //
        // Volatile interfaces are created on pins during a connection,
        // and may go away when the next connection is made.
        //
        Aggregate->m_Volatile = Volatile;
        //
        // Set this if it is a Volatile, else set it to FALSE for a
        // Static interface so that it will be notified on connection.
        //
        Aggregate->m_Reconnected = Volatile;
        MarshalerList->AddTail(Aggregate);
    } else {
        //
        // Either a failure occured, or a duplicate was found and used.
        //
        delete Aggregate;
    }
    return hr;
}


STDMETHODIMP_(VOID)
NotifyStaticAggregates(
    CMarshalerList* MarshalerList
    )
{
    //
    // Notify all Static aggregated interfaces on the list which have
    // not already been notified.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        if (!Aggregate->m_Volatile && !Aggregate->m_Reconnected && Aggregate->m_DistributorNotify) {
            //
            // Now this item will have been notified, so mark it.
            // This save a little time on disconnect, since the
            // items which have not been marked either did not
            // get notified, or can't be notified. The unload
            // code for Volatiles checks for the Volatile bit, not
            // just the Reconnect bit.
            //
            Aggregate->m_Reconnected = TRUE;
            Aggregate->m_DistributorNotify->NotifyGraphChange();
        }
    }
}


STDMETHODIMP
AggregateMarshalers(
    HKEY RootKey,
    TCHAR* SubKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerates the specified key under the class and aggregates any
    modules which represent an interface. These can be retrieved through
    a normal QueryInterface on the calling object, and can add to the
    normal interfaces provided by that object.

Arguments:

    RootKey -
        Contains the root key on which to append the SubKey. This is normally
        the interface device key.

    SubKey -
        Contains the subkey to query under the root containing the list of
        aggregates.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR, else a memory error. Ignores error trying to load
    interfaces.

--*/
{
    LONG        Result;
    HKEY        ClassRegistryKey;
    HKEY        InterfacesRegistryKey;

    Result = RegOpenKeyEx(RootKey, SubKey, 0, KEY_READ, &ClassRegistryKey);
    //
    // If the key does not exist, this is OK, as there may be no interfaces
    // to load.
    //
    if (Result != ERROR_SUCCESS) {
        return NOERROR;
    }
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If there is no list of registered media interfaces, then there are
    // no extensions to load, even if an Interfaces subkey exists in the
    // PnP registry subkey.
    //
    if (Result != ERROR_SUCCESS) {
        RegCloseKey(ClassRegistryKey);
        return NOERROR;
    }
    //
    // Enumerate each key as a textual Guid to look up in the MediaInterfaces
    // subkey.
    //
    for (LONG KeyEntry = 0;; KeyEntry++) {
        TCHAR                   GuidString[64];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        Result = RegEnumKey(
            ClassRegistryKey,
            KeyEntry,
            GuidString,
            sizeof(GuidString)/sizeof(TCHAR));
        if (Result != ERROR_SUCCESS) {
            break;
        }
        //
        // Retrieve the Guid representing the COM interface which will
        // represent this entry.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
            GuidString,
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This guid is not registered.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the original guid is, and the interface
        // presented is whatever the registry specifies, which may be
        // GUID_NULL, meaning that multiple interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
#ifdef _UNICODE
        IIDFromString(GuidString, &Aggregate->m_ClassId);
#else
        WCHAR   UnicodeGuid[64];

        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, GuidString, -1, UnicodeGuid, sizeof(UnicodeGuid));
        IIDFromString(UnicodeGuid, &Aggregate->m_ClassId);
#endif
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
    }
    RegCloseKey(InterfacesRegistryKey);
    RegCloseKey(ClassRegistryKey);
    return NOERROR;
}


STDMETHODIMP
AggregateTopology(
    HKEY RootKey,
    PKSMULTIPLE_ITEM MultipleItem,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerates the topology of the filter, looking up each topology guid as
    an interface to be added to the filter. These can be retrieved through
    a normal QueryInterface on the calling object, and can add to the
    normal interfaces provided by that object.

Arguments:

    RootKey -
        This is not currently used, but may be if indirection is useful.
        Contains the root key on which to append the SubKey. This is normally
        the interface device key.

    MultipleItem -
        Contains the list of topology nodes to aggregate.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR, else a memory error. Ignores error trying to load
    interfaces.

--*/
{
    LONG        Result;
    HKEY        InterfacesRegistryKey;

    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If there is no list of registered media interfaces, then there are
    // no extensions to load.
    //
    if (Result != ERROR_SUCCESS) {
        return NOERROR;
    }
    //
    // Enumerate each node as a Guid to look up in the MediaInterfaces subkey.
    //
    for (ULONG Node = MultipleItem->Count; Node; Node--) {
        WCHAR                   GuidString[CHARS_IN_GUID];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        StringFromGUID2(
            *(reinterpret_cast<GUID*>(MultipleItem + 1) + Node - 1),
            GuidString,
            CHARS_IN_GUID);
#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif

        //
        // Retrieve the Guid representing the COM interface which will
        // represent this entry.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
#ifdef _UNICODE
            GuidString,
#else
            AnsiGuid,
#endif
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This guid is not registered.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the original guid is, and the interface
        // presented is whatever the registry specifies, which may be
        // GUID_NULL, meaning that multiple interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
        IIDFromString(GuidString, &Aggregate->m_ClassId);
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
    }
    RegCloseKey(InterfacesRegistryKey);
    return NOERROR;
}


STDMETHODIMP
CollectAllSets(
    HANDLE ObjectHandle,
    GUID** GuidList,
    ULONG* SetDataSize
    )
/*++

Routine Description:

    Enumerate the Property/Method/Event sets supported by the object, and
    return a list of them.

Arguments:

    ObjectHandle -
        Handle of the object to enumerate the sets on. This would normally
        be a filter or pin.

    GuidList -
        Points to the place in which to place a pointer to a list of guids.
        This only will contain a pointer if SetDataSize is non-zero, else
        it will be set to NULL. This must be freed by the caller.

    SetDataSize -
        Indicates the number of items returned in the GuidList. If this is
        non-zero, GuidList is returned with a pointer to a list which must
        be freed, else no list is returned.

Return Value:

    Returns NOERROR, else a memory error or ERROR_SET_NOT_FOUND.

--*/
{
    HRESULT         hr;
    KSIDENTIFIER    Identifier;
    ULONG           PropertyDataSize;
    ULONG           MethodDataSize;
    ULONG           EventDataSize;
    ULONG           BytesReturned;

    //
    // Always initialize this so that the caller can just use it to determine
    // if the guid list is present.
    //
    *SetDataSize = 0;
    //
    // Query for the list of sets.
    //
    Identifier.Set = GUID_NULL;
    Identifier.Id = 0;
    //
    // This flag is actually the same for property/method/event sets.
    //
#if KSPROPERTY_TYPE_SETSUPPORT != KSMETHOD_TYPE_SETSUPPORT
#error KSPROPERTY_TYPE_SETSUPPORT != KSMETHOD_TYPE_SETSUPPORT
#endif
#if KSPROPERTY_TYPE_SETSUPPORT != KSEVENT_TYPE_SETSUPPORT
#error KSPROPERTY_TYPE_SETSUPPORT != KSEVENT_TYPE_SETSUPPORT
#endif
    Identifier.Flags = KSPROPERTY_TYPE_SETSUPPORT;
    //
    // Query for the size of the data for each set.
    //
    PropertyDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_PROPERTY,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &PropertyDataSize);
    MethodDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_METHOD,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &MethodDataSize);
    EventDataSize = 0;
    KsSynchronousDeviceControl(
        ObjectHandle,
        IOCTL_KS_ENABLE_EVENT,
        &Identifier,
        sizeof(Identifier),
        NULL,
        0,
        &EventDataSize);
    if (!(PropertyDataSize + MethodDataSize + EventDataSize)) {
        //
        // There are no property/method/event sets on this object.
        //
        *GuidList = NULL;
        return ERROR_SET_NOT_FOUND;
    }
    //
    // Allocate a buffer and query for the data.
    //
    *GuidList = new GUID[(PropertyDataSize + MethodDataSize + EventDataSize)/sizeof(**GuidList)];
    if (!*GuidList) {
        return E_OUTOFMEMORY;
    }
    if (PropertyDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_PROPERTY,
            &Identifier,
            sizeof(Identifier),
            *GuidList,
            PropertyDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the properties part of the list.
            //
            PropertyDataSize = 0;
        }
    }
    if (MethodDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_METHOD,
            &Identifier,
            sizeof(Identifier),
            *GuidList + PropertyDataSize / sizeof(**GuidList),
            MethodDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the methods part of the list.
            //
            MethodDataSize = 0;
        }
    }
    if (EventDataSize) {
        hr = KsSynchronousDeviceControl(
            ObjectHandle,
            IOCTL_KS_ENABLE_EVENT,
            &Identifier,
            sizeof(Identifier),
            *GuidList + (PropertyDataSize + MethodDataSize) / sizeof(**GuidList),
            EventDataSize,
            &BytesReturned);
        if (FAILED(hr)) {
            //
            // Just remove the events part of the list.
            //
            EventDataSize = 0;
        }
    }
    PropertyDataSize += (MethodDataSize + EventDataSize);
    if (!PropertyDataSize) {
        //
        // All of the queries done failed. This must be freed here, since a
        // zero length return indicates that there is no list to free.
        //
        delete [] *GuidList;
        *GuidList = NULL;
        return ERROR_SET_NOT_FOUND;
    }
    //
    // This was already initialize to zero, so it only needs to be
    // updated if the result is non-zero. Return the number of items,
    // no the byte size.
    //
    *SetDataSize = PropertyDataSize / sizeof(**GuidList);
    return NOERROR;
}


STDMETHODIMP_(VOID)
ResetInterfaces(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Resets the Reconnected flag in all entries, and notifies all the
    interface. This allows a Reconnect on a pin to keep volatile
    interfaces present while doing the reconnect, and only remove such
    interfaces which are no longer represented by a Set on the
    underlying object.

Arguments:

    MarshalerList -
        Points to the list of interfaces which are to be reset.

Return Value:

    Nothing.

--*/
{
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;

        Aggregate = MarshalerList->GetNext(Position);
        //
        // If this interface has been reconnected, let it know
        // that the pin is now disconnected. This is always set
        // for Static interfaces. This might not be set if a
        // connection failed.
        //
        if (Aggregate->m_Reconnected) {
            //
            // Volatile interfaces will be unloaded if they are not
            // reconnected. Static interfaces will stay loaded, and
            // be notified in the cleanup.
            //
            Aggregate->m_Reconnected = FALSE;
            //
            // If the item has a distributor interface, let it know
            // that the pin is disconnected.
            //
            if (Aggregate->m_DistributorNotify) {
                Aggregate->m_DistributorNotify->NotifyGraphChange();
            }
        }
    }
}


STDMETHODIMP
AggregateSets(
    HANDLE ObjectHandle,
    HKEY DeviceRegKey,
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter
    )
/*++

Routine Description:

    Enumerate the Property/Method/Event sets supported by the object and
    add an interface for each which is actually registered to have an
    interface representation. These can be retrieved through a normal
    QueryInterface on the calling object, and can add to the normal
    interfaces provided by that object.

Arguments:

    ObjectHandle -
        Handle of the object to enumerate the sets on. This would normally
        be a filter or pin.

    DeviceRegKey -
        The handle to the device registry storage location.

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is appended to with each entry found.

    UnkOuter -
        Contains the outer IUnknown to be passed to the object whose interface
        is to be aggregated.

Return Value:

    Returns NOERROR.

--*/
{
    ULONG       SetDataSize;
    GUID*       GuidList;
    LONG        Result;
    HKEY        InterfacesRegistryKey;
    HKEY        AliasKey;

    //
    // Notify static aggregates of the connection.
    //
    NotifyStaticAggregates(MarshalerList);
    CollectAllSets(ObjectHandle, &GuidList, &SetDataSize);
    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    if ((Result != ERROR_SUCCESS) || !GuidList) {
        //
        // There are no interface handlers registered, therefore none
        // will be aggregated.
        //
        if (GuidList) {
            delete [] GuidList;
        }
        if (Result == ERROR_SUCCESS) {
            RegCloseKey(InterfacesRegistryKey);
        }
        //
        // Remove any volatile interfaces which have been reset.
        // They were reset on the previous BreakConnect.
        //
        UnloadVolatileInterfaces(MarshalerList, FALSE);
        return NOERROR;
    }
    //
    // Open the Set Aliases key if it exists in order to translate any
    // guids to private ones in case an alternate COM server is to be
    // used for a particular Set being aggregated.
    //
    if (RegOpenKeyEx(DeviceRegKey, TEXT("SetAliases"), 0, KEY_READ, &AliasKey) != ERROR_SUCCESS) {
        AliasKey = NULL;
    }
    for (; SetDataSize--;) {
        WCHAR                   GuidString[CHARS_IN_GUID];
        ULONG                   ValueSize;
        GUID                    Interface;
        CAggregateMarshaler*    Aggregate;
        HKEY                    ItemRegistryKey;

        StringFromGUID2(GuidList[SetDataSize], GuidString, CHARS_IN_GUID);
#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
        if (AliasKey) {
            //
            // Check in the device registry key if there is an alias for
            // this Set guid that should be used with any object on this
            // filter. This allows a filter to override standard Set
            // COM servers, in order to provide their own interfaces.
            //
            ValueSize = sizeof(Interface);
            Result = RegQueryValueEx(
                AliasKey,
#ifdef _UNICODE
                GuidString,
#else
                AnsiGuid,
#endif
                NULL,
                NULL,
                (PBYTE)&Interface,
                &ValueSize);
            //
            // If this named value exists, use it. Release the old guid
            // and update the guid list, since this new guid will be
            // treated just like the guid for the Set.
            //
            if (Result == ERROR_SUCCESS) {
                GuidList[SetDataSize] = Interface;
                StringFromGUID2(GuidList[SetDataSize], GuidString, CHARS_IN_GUID);
#ifndef _UNICODE
                WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
            }
        }
        //
        // Retrieve the Guid representing the COM interface which will
        // represent this set.
        //
        Result = RegOpenKeyEx(
            InterfacesRegistryKey,
#ifdef _UNICODE
            GuidString,
#else
            AnsiGuid,
#endif
            0,
            KEY_READ,
            &ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // This interface is not supposed to be aggregated.
            //
            continue;
        }
        ValueSize = sizeof(Interface);
        Result = RegQueryValueEx(
            ItemRegistryKey,
            IidNamedValue,
            NULL,
            NULL,
            (PBYTE)&Interface,
            &ValueSize);
        RegCloseKey(ItemRegistryKey);
        if (Result != ERROR_SUCCESS) {
            //
            // Allow the module to expose multiple interfaces.
            //
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (!Aggregate) {
            //
            // Probably ran out of memory.
            //
            break;
        }
        //
        // The class is whatever the Set guid is, and the interface presented
        // is whatever the registry specifies, which may be different than the
        // guid for the Set, or may be GUID_NULL, meaning that multiple
        // interfaces are exposed.
        //
        Aggregate->m_iid = Interface;
        Aggregate->m_ClassId = GuidList[SetDataSize];
        AddAggregateObject(MarshalerList, Aggregate, UnkOuter, TRUE);
    }
    RegCloseKey(InterfacesRegistryKey);
    //
    // If this exists, then close it.
    //
    if (AliasKey) {
        RegCloseKey(AliasKey);
    }
    delete [] GuidList;
    //
    // Remove any volatile interfaces which have been reset.
    // They were reset on the previous BreakConnect.
    //
    UnloadVolatileInterfaces(MarshalerList, FALSE);
    return NOERROR;
}


STDMETHODIMP_(VOID)
FreeMarshalers(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Frees a previously Marshaled list of aggregated interfaces. Assumes that the
    calling object has protected itself against re-entrancy when the Marshaled
    interfaces release their reference count on the parent.

Arguments:

    MarshalerList -
        Points to the list of interfaces which the calling object is aggregating.
        This list is freed.

Return Value:

    Nothing.

--*/
{
    //
    // Release and destroy all the aggregations on the object.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler*Aggregate;
        POSITION            PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);
        MarshalerList->Remove(PrevPosition);
        Aggregate->m_Unknown->Release();
        delete Aggregate;
    }
}


STDMETHODIMP_(VOID)
UnloadVolatileInterfaces(
    CMarshalerList* MarshalerList,
    BOOL ForceUnload
    )
/*++

Routine Description:

    Frees the volatile entries on the previously Marshaled list of aggregated
    interfaces. Since aggregated interfaces should never keep any reference
    count on a parent, the reference count is not protected.

Arguments:

    MarshalerList -
        Points to the list of interfaces which the calling object has aggregated.
        This list from which volatile members are removed.

    ForceUnload -
        Forces the interface to be unloaded even if the Reconnected flag is set.

Return Value:

    Nothing.

--*/
{
    //
    // Release and destroy the volatile aggregations on the object.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;
        POSITION PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);
        //
        // Only unload volatile interfaces which have been reset. During
        // a Reconnect in SetFormat, the interfaces will not be reloaded.
        //
        if (Aggregate->m_Volatile && (ForceUnload || !Aggregate->m_Reconnected)) {
            MarshalerList->Remove(PrevPosition);
            Aggregate->m_Unknown->Release();
            delete Aggregate;
        }
    }
}


STDMETHODIMP_(VOID)
FollowFromTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    )
/*++

Routine Description:

    Follows a ToNode of a given connection to another FromNode, going with the
    data flow of the connections. If an actual Pin Factory is encountered as
    the destination of a connection, and it is not the originating Pin Factory,
    the related Pin Factory reference array element is incremented to show that
    a specific Pin Factory is actually related through connections to the
    original Pin Factory.

Arguments:

    Connection -
        Contains the list of topology connections.

    Count -
        Contains the count of Connection elements.

    PinFactoryId -
        The originaing Pin Factory Identifier. This is used to ensure that a
        connection ending at the original Pin Factory is not counted, and
        thus returned in the internal connections array.

    ConnectionBranch -
        The current connection being traced. If this is an end point (ToNode
        contains KSFILTER_NODE rather than a node identifier), then the
        PinFactoryIdList is updated. Else the connection path is followed by
        recursively calling this function with each connection that contains
        the new node identifier.

    PinFactoryIdList -
        Contains the list of slots, one for each Pin Factory Identifier, which
        is incremented on finding a related Pin Factory. This can then be
        used to locate all pin instances of related Pin Factories.

Return Value:

    Nothing.

--*/
{
    //
    // If this is an end point in a connection path, then determine if it
    // ended up at the starting point. If not, then count this as a new
    // Pin Factory whose instances are to be added to the related pins.
    //
    if (ConnectionBranch->ToNode == KSFILTER_NODE) {
        if (ConnectionBranch->ToNodePin != PinFactoryId) {
            //
            // This just needs to be non-zero to count.
            //
            PinFactoryIdList[ConnectionBranch->ToNodePin]++;
        }
    } else {
        //
        // This is not an end point, so the path must be followed to the
        // next connection point. To ensure that a circular connection
        // path does not recurse forever, make sure that the FromNode and
        // FromNodePin are modified. Changing the FromNode to KSFILTER_NODE
        // ensures that the comparison below will never succeed, since the
        // ToNode compared to will never be KSFILTER_NODE. Changing the
        // FromNodePin to -1 ensures that the comparison in
        // CKsProxy::QueryInternalConnections never succeeds, and it does
        // not call this function with connection paths which have already
        // been traced.
        //
        ConnectionBranch->FromNode = KSFILTER_NODE;
        ConnectionBranch->FromNodePin = static_cast<ULONG>(-1);
        for (ULONG ConnectionItem = 0; ConnectionItem < Count; ConnectionItem++) {
            //
            // Only new connection points not already recursed into will be
            // found by this comparison.
            //
            if (ConnectionBranch->ToNode == Connection[ConnectionItem].FromNode) {
                FollowFromTopology(Connection, Count, PinFactoryId, &Connection[ConnectionItem], PinFactoryIdList);
            }
        }
    }
}


STDMETHODIMP_(VOID)
FollowToTopology(
    PKSTOPOLOGY_CONNECTION Connection,
    ULONG Count,
    ULONG PinFactoryId,
    PKSTOPOLOGY_CONNECTION ConnectionBranch,
    PULONG PinFactoryIdList
    )
/*++

Routine Description:

    Follows a ToNode of a given connection to another FromNode, going against the
    data flow of the connections. If an actual Pin Factory is encountered as
    the destination of a connection, and it is not the originating Pin Factory,
    the related Pin Factory reference array element is incremented to show that
    a specific Pin Factory is actually related through connections to the
    original Pin Factory.

Arguments:

    Connection -
        Contains the list of topology connections.

    Count -
        Contains the count of Connection elements.

    PinFactoryId -
        The originaing Pin Factory Identifier. This is used to ensure that a
        connection ending at the original Pin Factory is not counted, and
        thus returned in the internal connections array.

    ConnectionBranch -
        The current connection being traced. If this is an end point (ToNode
        contains KSFILTER_NODE rather than a node identifier), then the
        PinFactoryIdList is updated. Else the connection path is followed by
        recursively calling this function with each connection that contains
        the new node identifier.

    PinFactoryIdList -
        Contains the list of slots, one for each Pin Factory Identifier, which
        is incremented on finding a related Pin Factory. This can then be
        used to locate all pin instances of related Pin Factories.

Return Value:

    Nothing.

--*/
{
    //
    // If this is an end point in a connection path, then determine if it
    // ended up at the starting point. If not, then count this as a new
    // Pin Factory whose instances are to be added to the related pins.
    //
    if (ConnectionBranch->FromNode == KSFILTER_NODE) {
        if (ConnectionBranch->FromNodePin != PinFactoryId) {
            //
            // This just needs to be non-zero to count.
            //
            PinFactoryIdList[ConnectionBranch->FromNodePin]++;
        }
    } else {
        //
        // This is not an end point, so the path must be followed to the
        // next connection point. To ensure that a circular connection
        // path does not recurse forever, make sure that the ToNode and
        // ToNodePin are modified. Changing the ToNode to KSFILTER_NODE
        // ensures that the comparison below will never succeed, since the
        // FromNode compared to will never be KSFILTER_NODE. Changing the
        // ToNodePin to -1 ensures that the comparison in
        // CKsProxy::QueryInternalConnections never succeeds, and it does
        // not call this function with connection paths which have already
        // been traced.
        //
        ConnectionBranch->ToNode = KSFILTER_NODE;
        ConnectionBranch->ToNodePin = static_cast<ULONG>(-1);
        for (ULONG ConnectionItem = 0; ConnectionItem < Count; ConnectionItem++) {
            //
            // Only new connection points not already recursed into will be
            // found by this comparison.
            //
            if (ConnectionBranch->FromNode == Connection[ConnectionItem].ToNode) {
                FollowToTopology(Connection, Count, PinFactoryId, &Connection[ConnectionItem], PinFactoryIdList);
            }
        }
    }
}


STDMETHODIMP_(BOOL)
IsAcquireOrderingSignificant(
    HANDLE PinHandle
    )
/*++

Routine Description:

    Queries the pin handle to determine if transition from Stop to Acquire
    state ordering is significant. If the property is not supported, or if
    the value returned is FALSE, the the ordering is not significant. Only
    a return of TRUE in the AcquireOrdering buffer implies significance.

Arguments:

    PinHandle -
        Contains the handle of the pin to query.

Return Value:

    Returns TRUE if Acquire state change ordering is significant to this
    pin, and therefore must be propagated to the connected filter first.

--*/
{
    KSPROPERTY  Property;
    HRESULT     hr;
    BOOL        AcquireOrdering;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ACQUIREORDERING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &AcquireOrdering,
        sizeof(AcquireOrdering),
        &BytesReturned);
    if (SUCCEEDED(hr) && AcquireOrdering) {
        return TRUE;
    }
    return FALSE;
}


STDMETHODIMP
QueryAccept(
    IN HANDLE PinHandle,
    IN const AM_MEDIA_TYPE* ConfigAmMediaType OPTIONAL,
    IN const AM_MEDIA_TYPE* AmMediaType
    )
/*++

Routine Description:

    Implement the CBasePin::QueryAccept method. Determines if the proposed
    media type is currently acceptable to the pin. If currently streaming,
    this implies that a change of media types will occur in the stream.
    Note that this function does not lock the object, as it is expected
    to be called asynchronously by a knowledgeable client at a point in
    which the connection will not be broken. If IAMStreamConfig::SetFormat
    has been used to set a specific media type, then QueryAccept will only
    accept the type set.

Arguments:

    PinHandle -
        Contains the handle of the pin to query.

    ConfigAmMediaType -
        Optionally contains a media type set using IAMStreamConfig::SetFormat.
        If this is set, the filter is not even queried, and a direct comparison
        is performed instead.

    AmMediaType -
        The media type to check.

Return Value:

    Returns S_OK if the media type can currently be accepted, else S_FALSE.

--*/
{
    PKSDATAFORMAT   DataFormat;
    KSPROPERTY      Property;
    HRESULT         hr;
    ULONG           BytesReturned;
    ULONG           FormatSize;

    //
    // If a media type has been set via IAMStreamConfig::SetFormat, then only
    // that type is acceptable.
    //
    if (ConfigAmMediaType) {
        return (reinterpret_cast<const CMediaType*>(AmMediaType) == reinterpret_cast<const CMediaType*>(ConfigAmMediaType)) ? S_OK : S_FALSE;
    }
    hr = InitializeDataFormat(
        reinterpret_cast<const CMediaType*>(AmMediaType),
        0,
        reinterpret_cast<void**>(&DataFormat),
        &FormatSize);
    if (FAILED(hr)) {
        //
        // The function is only supposed to return either S_OK or S_FALSE,
        // no matter what the error really is.
        //
        return S_FALSE;
    }
    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT;
    Property.Flags = KSPROPERTY_TYPE_SET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        DataFormat,
        FormatSize,
        &BytesReturned);
    CoTaskMemFree(DataFormat);
    if (FAILED(hr)) {
        return S_FALSE;
    }
    return S_OK;
}


STDMETHODIMP_(VOID)
DistributeSetSyncSource(
    CMarshalerList* MarshalerList,
    IReferenceClock* RefClock
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new sync source. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

    RefClock -
        The new reference clock.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->SetSyncSource(RefClock);
        }
    }
}


STDMETHODIMP_(VOID)
DistributeStop(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Stop();
        }
    }
}


STDMETHODIMP_(VOID)
DistributePause(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Pause();
        }
    }
}


STDMETHODIMP_(VOID)
DistributeRun(
    CMarshalerList* MarshalerList,
    REFERENCE_TIME Start
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    new state. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->Run(Start);
        }
    }
}


STDMETHODIMP_(VOID)
DistributeNotifyGraphChange(
    CMarshalerList* MarshalerList
    )
/*++

Routine Description:

    Given a list of aggregated interfaces, notify each on the list of the
    graph change. This is used to notify aggregated interfaces on both
    the filter and the pins.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to enumerate and notify.

Return Value:

    Nothing.

--*/
{
    //
    // Notify all aggregated interfaces on the list. Ignore any error return.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        IDistributorNotify* DistributorNotify;

        DistributorNotify = MarshalerList->GetNext(Position)->m_DistributorNotify;
        if (DistributorNotify) {
            DistributorNotify->NotifyGraphChange();
        }
    }
}


STDMETHODIMP
AddAggregate(
    CMarshalerList* MarshalerList,
    IUnknown* UnkOuter,
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    This is used to load a COM server with zero or more interfaces to aggregate
    on the object.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to add to.

    UnkOuter -
        The outer IUnknown which is used in the CoCreateInstance if a new
        aggregate is being added.

    AggregateClass -
        Contains the Aggregate reference to translate into a COM server which
        is to be aggregated on the object.

Return Value:

    Returns S_OK if the interface was added.

--*/
{
    LONG Result;
    HRESULT hr;
    HKEY InterfacesRegistryKey;
    WCHAR GuidString[CHARS_IN_GUID];

    Result = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        MediaInterfacesKeyName,
        0,
        KEY_READ,
        &InterfacesRegistryKey);
    //
    // If the location of the registered interfaces cannot be opened, it is
    // still OK to try and load the interface, as it just may not be
    // registered.
    //
    if (Result != ERROR_SUCCESS) {
        InterfacesRegistryKey = NULL;
    }
    //
    // Make the aggregate class a string so that it can be used as part of
    // a key name.
    //
    StringFromGUID2(AggregateClass, GuidString, CHARS_IN_GUID);
    {
        HKEY ItemRegistryKey;
        GUID    Interface;
        CAggregateMarshaler* Aggregate;

#ifndef _UNICODE
        char    AnsiGuid[64];
        BOOL    DefaultUsed;

        WideCharToMultiByte(0, 0, GuidString, -1, AnsiGuid, sizeof(AnsiGuid), NULL, &DefaultUsed);
#endif
        //
        // If the parent key was opened, try this child key.
        //
        if (Result == ERROR_SUCCESS) {
            //
            // Retrieve the Guid representing the COM interface which will
            // represent this entry.
            //
            Result = RegOpenKeyEx(
                InterfacesRegistryKey,
#ifdef _UNICODE
                GuidString,
#else
                AnsiGuid,
#endif
                0,
                KEY_READ,
                &ItemRegistryKey);
            //
            // This does not really have to succeed, since the client is explicitly
            // loading the handler. It does allow the client to indicate specific
            // interface support though.
            //
            if (Result == ERROR_SUCCESS) {
                ULONG ValueSize;

                ValueSize = sizeof(Interface);
                Result = RegQueryValueEx(
                    ItemRegistryKey,
                    IidNamedValue,
                    NULL,
                    NULL,
                    (PBYTE)&Interface,
                    &ValueSize);
                RegCloseKey(ItemRegistryKey);
            }
        }
        //
        // If there is no MediaInterfaces entry, or no named value under
        // the key, then allow the module to expose multiple interfaces.
        //
        if (Result != ERROR_SUCCESS) {
            Interface = GUID_NULL;
        }
        Aggregate = new CAggregateMarshaler;
        if (Aggregate) {
            //
            // The class is whatever the original guid is, and the interface
            // presented is whatever the registry specifies, which may be
            // GUID_NULL, meaning that multiple interfaces are exposed.
            //
            Aggregate->m_iid = Interface;
            Aggregate->m_ClassId = AggregateClass;
            hr = AddAggregateObject(MarshalerList, Aggregate, UnkOuter, FALSE);
        } else {
            hr = E_OUTOFMEMORY;
        }
    }
    //
    // This key may not exist, and so was not opened.
    //
    if (InterfacesRegistryKey) {
        RegCloseKey(InterfacesRegistryKey);
    }
    return hr;
}


STDMETHODIMP
RemoveAggregate(
    CMarshalerList* MarshalerList,
    IN REFGUID AggregateClass
    )
/*++

Routine Description:

    This is used to unload a previously loaded COM server which is aggregating
    interfaces.

Arguments:

    MarshalerList -
        The list of Marshaled interfaces to search.

    AggregateClass -
        Contains the Aggregate reference to look up and unload.

Return Value:

    Returns S_OK if the interface was removed.

--*/
{
    //
    // Find the aggregate specified.
    //
    for (POSITION Position = MarshalerList->GetHeadPosition(); Position;) {
        CAggregateMarshaler* Aggregate;
        POSITION PrevPosition;

        PrevPosition = Position;
        Aggregate = MarshalerList->GetNext(Position);

        //
        // If the class identifier matches, unload the interface.
        //
        if (Aggregate->m_ClassId == AggregateClass) {
            MarshalerList->Remove(PrevPosition);
            Aggregate->m_Unknown->Release();
            delete Aggregate;
            return S_OK;
        }
    }
    return HRESULT_FROM_WIN32(ERROR_NO_MATCH);
}


STDMETHODIMP
GetDegradationStrategies(
    HANDLE PinHandle,
    PVOID* Items
    )
/*++

Routine Description:

    Retrieves the variable length degradation strategies data from a pin.
    Queries for the data size, allocates a buffer, and retrieves the data.

Arguments:

    PinHandle -
        The handle of the pin to query.

    Items -
        The place in which to put the buffer containing the data items. This
        must be deleted as an array.

Return Value:

    Returns NOERROR, else some error.

--*/
{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_DEGRADATION;
    Property.Flags = KSPROPERTY_TYPE_GET;
    //
    // Query for the size of the degradation strategies.
    //
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        NULL,
        0,
        &BytesReturned);
    if (hr == HRESULT_FROM_WIN32(ERROR_MORE_DATA)) {
        //
        // Allocate a buffer and query for the degradation strategies.
        //
        *Items = reinterpret_cast<PVOID>(new BYTE[BytesReturned]);
        if (!*Items) {
            return E_OUTOFMEMORY;
        }
        hr = KsSynchronousDeviceControl(
            PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *Items,
            BytesReturned,
            &BytesReturned);
        if (FAILED(hr)) {
            delete [] reinterpret_cast<BYTE*>(*Items);
        }
    }
    return hr;
}


STDMETHODIMP_(BOOL)
VerifyQualitySupport(
    HANDLE PinHandle
    )
/*++

Routine Description:

    This is used by output pins to verify that relevant degradation
    strategies are supported by this pin.

Arguments:

    PinHandle -
        The handle of the pin to query.

Return Value:

    Returns TRUE if any relevant degradation strategy is supported, else
    FALSE.

--*/
{
    PKSMULTIPLE_ITEM    MultipleItem = NULL;
    PKSDEGRADE          DegradeList;
    BOOL                SupportsQuality;

    //
    // Retrieve the list of degradation strategies.
    //
    if (FAILED(GetDegradationStrategies(PinHandle, reinterpret_cast<PVOID*>(&MultipleItem)))) {
        return FALSE;
    }

    /* NULL == MultipleItem is a pathological case where a driver returns
       a success code in KsSynchronousDeviceControl() (in GetDegradationStrategies())
       when passed a size 0 buffer.  We'll just do with an assert since we're in ring 3. */
    ASSERT( NULL != MultipleItem );

    //
    // Enumerate the list of degradation strategies supported, looking for
    // any standard method.
    //
    DegradeList = reinterpret_cast<PKSDEGRADE>(MultipleItem + 1);
    for (SupportsQuality = FALSE; MultipleItem->Count--; DegradeList++) {
        if (DegradeList->Set == KSDEGRADESETID_Standard) {
            SupportsQuality = TRUE;
            break;
        }
    }
    delete [] reinterpret_cast<BYTE*>(MultipleItem);
    return SupportsQuality;
}


STDMETHODIMP_(BOOL)
EstablishQualitySupport(
    IKsPin* Pin,
    HANDLE PinHandle,
    CKsProxy* Filter
    )
/*++

Routine Description:

    This is used by input pins to establish the quality management sink
    for the kernel mode pin via the user mode quality manager forwarder.
    If the filter has been able to locate the user mode forwarder, then
    the handle to the kernel mode quality manager proxy is retrieved and
    passed to the pin.

    This is also used to remove any previously set Quality Manager on a
    pin. Passing a NULL Filter parameter removes any previous setting.

Arguments:

    Pin -
        The user mode pin which represents the kernel mode pin. This is
        used as context for quality management reports generated by the
        kernel mode pin. This can then be used to send such reports
        back to this originating pin, or used in centralized quality
        management. This should be NULL if Filter is NULL.

    PinHandle -
        The handle of the pin to set the quality manager to.

    Filter -
        The filter on which this pin resides. The filter is queried for
        the user mode quality manager forwarder. This may be set to NULL
        in order to remove any previously established quality support.

Return Value:

    Returns TRUE if the handle to the kernel mode quality manager proxy
    was set on the pin, else FALSE if there is not quality manager, or
    the kernel mode pin does not care about quality management notification.

--*/
{
    IKsQualityForwarder*QualityForwarder;
    KSPROPERTY          Property;
    KSQUALITY_MANAGER   QualityManager;
    ULONG               BytesReturned;
    HRESULT             hr;

    //
    // Determine if a user mode quality forwarder was found. If there is
    // not one present, then quality management cannot be performed on
    // the kernel filters. If this parameter is NULL, then any previous
    // quality manager is being removed.
    //
    if (Filter) {
        QualityForwarder = Filter->QueryQualityForwarder();
        if (!QualityForwarder) {
            return FALSE;
        }
    }
    //
    // Set the quality manager sink on the pin, which comes from the
    // user mode version previously opened. The context for the
    // complaints is the IKsPin interface, which the user mode quality
    // manager uses to forward complaints back to the pin, or to a
    // central quality manager.
    //
    Property.Set = KSPROPSETID_Stream;
    Property.Id = KSPROPERTY_STREAM_QUALITY;
    Property.Flags = KSPROPERTY_TYPE_SET;
    //
    // If the Filter paramter is NULL, then any previous quality manager
    // is being removed. Else the handle to the kernel mode proxy is to
    // be sent.
    //
    if (Filter) {
        QualityManager.QualityManager = QualityForwarder->KsGetObjectHandle();
    } else {
        QualityManager.QualityManager = NULL;
    }
    QualityManager.Context = reinterpret_cast<PVOID>(Pin);
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        &QualityManager,
        sizeof(QualityManager),
        &BytesReturned);
    return SUCCEEDED(hr);
}


STDMETHODIMP_(PKSDEGRADE)
FindDegradeItem(
    PKSMULTIPLE_ITEM MultipleItem,
    ULONG DegradeItem
    )
/*++

Routine Description:

    Given a list of degradation items, locates the specified item belonging
    to the standard degradation set.

Arguments:

    MultipleItem -
        Points to the head of a multiple item list, which contains the
        list of degradation strategies to search.

    DegradeItem -
        The item within the standard degradation set to search for.

Return Value:

    Returns a pointer to the degradation item, or NULL if not found.

--*/
{
    PKSDEGRADE  DegradeList;
    ULONG       Count;

    DegradeList = reinterpret_cast<PKSDEGRADE>(MultipleItem + 1);
    for (Count = MultipleItem->Count; Count--; DegradeList++) {
        if ((DegradeList->Set == KSDEGRADESETID_Standard) && (DegradeList->Id == DegradeItem)) {
            return DegradeList;
        }
    }
    return NULL;
}


STDMETHODIMP
GetAllocatorFraming(
    IN  HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING Framing
    )

/*++

Routine Description:
    Retrieves the allocator framing structure from the given pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    PKSALLOCATOR_FRAMING Framing -
        pointer to allocator framing structure

Return:
    converted WIN32 error or S_OK

--*/

{
    HRESULT     hr;
    KSPROPERTY  Property;
    ULONG       BytesReturned;

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING;
    Property.Flags = KSPROPERTY_TYPE_GET;
    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        Framing,
        sizeof(*Framing),
        &BytesReturned );

    return hr;
}


STDMETHODIMP
GetAllocatorFramingEx(
    IN HANDLE PinHandle,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx
    )

/*++

Routine Description:
    Queries the driver, allocates and retrieves the new
    allocator framing structure from the given pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    PKSALLOCATOR_FRAMING_EX FramingEx -
        pointer to pointer to allocator framing structure

Return:
    converted WIN32 error or S_OK

--*/

{
    HRESULT                  hr;
    KSPROPERTY               Property;
    ULONG                    BytesReturned;


    if ( ! ( (*FramingEx) = new (KSALLOCATOR_FRAMING_EX) ) ) {
        return E_OUTOFMEMORY;
    }

    Property.Set = KSPROPSETID_Connection;
    Property.Id = KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX;
    Property.Flags = KSPROPERTY_TYPE_GET;

    hr = KsSynchronousDeviceControl(
        PinHandle,
        IOCTL_KS_PROPERTY,
        &Property,
        sizeof(Property),
        *FramingEx,
        sizeof(KSALLOCATOR_FRAMING_EX),
        &BytesReturned );

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        delete (*FramingEx);
        (*FramingEx) = reinterpret_cast<PKSALLOCATOR_FRAMING_EX>(new BYTE[ BytesReturned ]);
        if (! (*FramingEx) ) {
            return E_OUTOFMEMORY;
        }

        hr = KsSynchronousDeviceControl(
            PinHandle,
            IOCTL_KS_PROPERTY,
            &Property,
            sizeof(Property),
            *FramingEx,
            BytesReturned,
            &BytesReturned );
    }

    if (! SUCCEEDED( hr )) {
        delete (*FramingEx);
        *FramingEx = NULL;
    }

    return hr;
}


STDMETHODIMP_(HANDLE)
GetObjectHandle(
    IUnknown *Object
    )
/*++

Routine Description:
    Using the IKsObject interface, this function returns the object
    handle of the given object or NULL if the interface is not supported.

Arguments:
    PUNKNOWN *Object -
        Pointer to interface w/ IUnknown.

Return:
    Handle of object or NULL.

--*/
{
    IKsObject   *KsObject;
    HANDLE      ObjectHandle;
    HRESULT     hr;

    hr = Object->QueryInterface(__uuidof(IKsObject), reinterpret_cast<PVOID*>(&KsObject));
    if (SUCCEEDED(hr)) {
        ObjectHandle = KsObject->KsGetObjectHandle();
        KsObject->Release();
        return ObjectHandle;
    }

    return NULL;
}


STDMETHODIMP
IsAllocatorCompatible(
    HANDLE PinHandle,
    HANDLE DownstreamInputHandle,
    IMemAllocator *MemAllocator
    )

/*++

Routine Description:

    Determines if the current allocator is compatible with this pin.

Arguments:
    HANDLE PinHandle -
        handle of pin

    HANDLE DownstreamInputHandle -
        handle of connected input pin

    IMemAllocator *MemAllocator -
        pointer to current allocator interface

Return:
    S_OK or an appropriate failure code

--*/

{
    IKsAllocatorEx      *KsAllocator;
    BOOL                Requirements;
    HRESULT             hr;
    KSALLOCATOR_FRAMING RequiredFraming;

    if (NULL != PinHandle) {
        hr =
            GetAllocatorFraming( PinHandle, &RequiredFraming );
    } else {
        hr = E_FAIL;
    }

    Requirements =
         SUCCEEDED( hr ) &&
         (0 == (RequiredFraming.RequirementsFlags &
                KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY));

    //
    // Query current allocator for the IKsAllocatorEx interface
    //

    hr =
        MemAllocator->QueryInterface(
            __uuidof(IKsAllocatorEx),
            reinterpret_cast<PVOID*>(&KsAllocator) );

    if (FAILED( hr )) {

        DbgLog((
            LOG_TRACE,
            2,
            TEXT("::IsAllocatorCompatible, user-mode allocator")));


        //
        // Assuming that this allocator is a user-mode allocator.
        //

        //
        // If the pin doesn't care about memory requirements, then the
        // current allocator is OK but we'll still reflect our preferences
        // for allocation sizes in DecideBufferSize().
        //

        if (Requirements) {

            //
            // If the pin does not accept host memory or if it specifies
            // that it must be an allocator, then fail immediately.
            //
            if ((0 == (RequiredFraming.RequirementsFlags &
                    KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY)) ||
                (RequiredFraming.RequirementsFlags &
                     KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, must allocate || !system_memory")));

                return E_FAIL;
            }

            //
            // Remaining issues for UM allocator hook up...
            //
            // KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER
            //    e.g. ReadOnly must == TRUE, but only ReadOnly for an
            //     allocator is set on NotifyAllocator
            // KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY
            //    passed on as ReadOnly=FALSE during NotifyAllocator
            //

        }

        return S_OK;

    } else {

        //
        // Allocator is either pure kernel-mode or is a user-mode
        // implementation for compatibility.
        //

        KSALLOCATOR_FRAMING InputFraming;

        DbgLog((
            LOG_TRACE,
            2,
            TEXT("::IsAllocatorCompatible, IKsAllocatorEx found: mode = %s"),
            (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_User) ?
                TEXT("user") : TEXT("kernel") ));

        //
        // Assume that the allocator is acceptable
        //

        hr = S_OK;

        //
        // If there is nothing specified for the input connection
        // or if there are no allocator preferences specified, assume
        // that the pin is an in-place modifier.
        //

        RtlZeroMemory( &InputFraming, sizeof( InputFraming ) );
        if (!DownstreamInputHandle ||
             FAILED( GetAllocatorFraming(
                        DownstreamInputHandle,
                        &InputFraming ) )) {

            InputFraming.RequirementsFlags =
                KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER;
        }

        //
        // If the connection is to a user-mode filter and if this
        // allocator is kernel-mode, then we must reject this allocator.
        //

        if (!DownstreamInputHandle &&
            (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_Kernel)) {

            DbgLog((
                LOG_TRACE,
                2,
                TEXT("::IsAllocatorCompatible, no input handle and allocator is kernel-mode")));

            hr = E_FAIL;
        }

        if (Requirements) {

            //
            // If this pin must be an allocator, so be it.
            //

            if (RequiredFraming.RequirementsFlags &
                    KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, must be allocator")));

                hr = E_FAIL;
            }

            //
            // If this pin requires the frame to remain in tact
            // and if the downstream allocator modifies data in place
            // then reject the allocator.
            //

            if ((RequiredFraming.RequirementsFlags &
                 KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY) &&
                 (InputFraming.RequirementsFlags &
                 KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, req. frame integrity but modifier")));

                hr = E_FAIL;
            }

            //
            // If the kernel mode allocator requires device memory
            // and this allocator is set up to be a user-mode
            // implementation, then reject the allocator.
            //

            if ((0 ==
                    (RequiredFraming.RequirementsFlags &
                     KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY)) &&
                (KsAllocator->KsGetAllocatorMode() ==
                    KsAllocatorMode_User)) {

                DbgLog((
                    LOG_TRACE,
                    2,
                    TEXT("::IsAllocatorCompatible, req. !system_memory and alloctor is user-mode")));

                hr = E_FAIL;
            }

            //
            // For all other conditions, the allocator is acceptable.
            //
        }
        KsAllocator->Release();

        return hr;
    }
}


STDMETHODIMP_(VOID)
OpenDataHandler(
    IN const CMediaType* MediaType,
    IN IUnknown* UnkOuter,
    OUT IKsDataTypeHandler** DataTypeHandler,
    OUT IUnknown** UnkInner
    )
/*++

Routine Description:

    Attempts to open a data type handler based on the media type passed.
    Returns both the unreferenced data type handler interface, and the
    inner IUnknown of the object.

Arguments:

    MediaType -
        The media type to use in loading the data type handler.

    UnkOuter -
        Contains the outer IUnknown to pass to the CoCreateInstance.

    DataTypeHandler -
        The place in which to return the data type handler interface.
        This has no reference count on it. This must not be dereferenced.
        This will be set to NULL on failure.

    UnkInner -
        The place in which to return the referenced inner IUnknown of
        the object. This is the interface which must be dereferenced in
        order to discard the object. This will be set to NULL on failure.

Return:

    Nothing.

--*/
{
    *DataTypeHandler = NULL;
    *UnkInner = NULL;
    //
    // First try the FormatType of the media type.
    //
    CoCreateInstance(
        *MediaType->FormatType(),
        UnkOuter,
#ifdef WIN9X_KS
        CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
        CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
        __uuidof(IUnknown),
        reinterpret_cast<PVOID*>(UnkInner));
    if (!*UnkInner) {
        //
        // Fallback to the sub type.
        //
        CoCreateInstance(
            *MediaType->Subtype(),
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(UnkInner));
    }
    if (!*UnkInner) {
        //
        // Fallback to the major type.
        //
        CoCreateInstance(
            *MediaType->Type(),
            UnkOuter,
#ifdef WIN9X_KS
            CLSCTX_INPROC_SERVER,
#else // WIN9X_KS
            CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
#endif // WIN9X_KS
            __uuidof(IUnknown),
            reinterpret_cast<PVOID*>(UnkInner));
    }
    //
    // If the inner IUnknown has been retrieved, get the interface
    // of interest.
    //
    if (*UnkInner) {
        (*UnkInner)->QueryInterface(
            __uuidof(IKsDataTypeHandler),
            reinterpret_cast<PVOID*>(DataTypeHandler));
        if (*DataTypeHandler) {
            //
            // Do not keep a reference count on this interface so that
            // it will not block unloading of the owner object. Only
            // the inner IUnknown will have a reference count.
            //
            (*DataTypeHandler)->Release();
            //
            // Set the media type on the handler.
            //
            (*DataTypeHandler)->KsSetMediaType(MediaType);
        } else {
            //
            // Could not get the data type handler interface, so fail
            // everything.
            //
            (*UnkInner)->Release();
            *UnkInner = NULL;
        }
    }
}

//
// Micro Media Sample class functions
//


CMicroMediaSample::CMicroMediaSample(
    DWORD Flags
    ) :
    m_Flags(Flags),
    m_cRef(1)
{
}


STDMETHODIMP
CMicroMediaSample::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if ((riid == __uuidof(IMediaSample)) ||
        (riid == __uuidof(IMediaSample2)) ||
        (riid == __uuidof(IUnknown))) {
        return GetInterface(static_cast<IMediaSample2*>(this), ppv);
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)
CMicroMediaSample::AddRef(
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CMicroMediaSample::Release(
    )
{
    LONG    Ref;

    Ref = InterlockedDecrement(&m_cRef);
    if (!Ref) {
        delete this;
    }
    return (ULONG)Ref;
}


STDMETHODIMP
CMicroMediaSample::GetPointer(
    BYTE** Buffer
    )
{
    *Buffer = NULL;
    return NOERROR;
}


STDMETHODIMP_(LONG)
CMicroMediaSample::GetSize(
    )
{
    return 0;
}


STDMETHODIMP
CMicroMediaSample::GetTime(
    REFERENCE_TIME* TimeStart,
    REFERENCE_TIME* TimeEnd
    )
{
    return VFW_E_SAMPLE_TIME_NOT_SET;
}


STDMETHODIMP
CMicroMediaSample::SetTime(
    REFERENCE_TIME* TimeStart,
    REFERENCE_TIME* TimeEnd
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsSyncPoint(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetSyncPoint(
    BOOL IsSyncPoint
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsPreroll(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetPreroll(
    BOOL IsPreroll
    )
{
    return NOERROR;
}


STDMETHODIMP_(LONG)
CMicroMediaSample::GetActualDataLength(
    )
{
    return 0;
}


STDMETHODIMP
CMicroMediaSample::SetActualDataLength(
    LONG Actual
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::GetMediaType(
AM_MEDIA_TYPE** MediaType
    )
{
    *MediaType = NULL;
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetMediaType(
    AM_MEDIA_TYPE* MediaType
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::IsDiscontinuity(
    )
{
    return S_FALSE;
}


STDMETHODIMP
CMicroMediaSample::SetDiscontinuity(
    BOOL Discontinuity
    )
{
    return S_OK;
}


STDMETHODIMP
CMicroMediaSample::GetMediaTime(
    LONGLONG* TimeStart,
    LONGLONG* TimeEnd
    )
{
    return VFW_E_MEDIA_TIME_NOT_SET;
}


STDMETHODIMP
CMicroMediaSample::SetMediaTime(
    LONGLONG* TimeStart,
    LONGLONG* TimeEnd
    )
{
    return NOERROR;
}


STDMETHODIMP
CMicroMediaSample::GetProperties(
    DWORD PropertiesSize,
    BYTE* Properties
    )
{
    AM_SAMPLE2_PROPERTIES   Props;

    Props.cbData = min(PropertiesSize, sizeof(Props));
    Props.dwSampleFlags = m_Flags;
    Props.dwTypeSpecificFlags = 0;
    Props.pbBuffer = NULL;
    Props.cbBuffer = 0;
    Props.lActual = 0;
    Props.tStart = 0;
    Props.tStop = 0;
    Props.dwStreamId = AM_STREAM_MEDIA;
    Props.pMediaType = NULL;
    CopyMemory(Properties, &Props, Props.cbData);
    return S_OK;
}


STDMETHODIMP
CMicroMediaSample::SetProperties(
    DWORD PropertiesSize,
    const BYTE* Properties
    )
{
    return S_OK;
}

//
// Media Attributes class functions
//


CMediaTypeAttributes::CMediaTypeAttributes(
    ) :
    m_Attributes(NULL),
    m_cRef(1)
{
}


STDMETHODIMP
CMediaTypeAttributes::QueryInterface(
    REFIID riid,
    void** ppv
    )
{
    if (riid == __uuidof(IMediaTypeAttributes) ||
        riid == __uuidof(IUnknown)) {
        return GetInterface(static_cast<IMediaTypeAttributes*>(this), ppv);
    }
    return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG)
CMediaTypeAttributes::AddRef(
    )
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG)
CMediaTypeAttributes::Release(
    )
{
    LONG    Ref;

    Ref = InterlockedDecrement(&m_cRef);
    if (!Ref) {
        if (m_Attributes) {
            CoTaskMemFree(m_Attributes);
        }
        delete this;
    }
    return (ULONG)Ref;
}


STDMETHODIMP
CMediaTypeAttributes::GetMediaAttributes(
    OUT PKSMULTIPLE_ITEM* Attributes
    )
{
    //
    // Return a pointer directly to the cached data, assuming that
    // the caller understands the lifespan of the pointer returned.
    //
    *Attributes = m_Attributes;
    return NOERROR;
}


STDMETHODIMP
CMediaTypeAttributes::SetMediaAttributes(
    IN PKSMULTIPLE_ITEM Attributes OPTIONAL
    )
{
    //
    // Remove any currently cached data, then cache the data passed
    // in, if any.
    //
    if (m_Attributes) {
        CoTaskMemFree(m_Attributes);
        m_Attributes = NULL;
    }
    if (Attributes) {
        m_Attributes = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(Attributes->Size));
        if (m_Attributes) {
            CopyMemory(m_Attributes, Attributes, Attributes->Size);
        } else {
            return E_OUTOFMEMORY;
        }
    }
    return NOERROR;
}

//
// major pipe functions
//


STDMETHODIMP
MakePipesBasedOnFilter(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Whenever the pin that doesn't have a pipe gets connected, we are calling
    this function to build the pipe[-s] on a filter containing connecting pin.

    It is possible that the connecting pin has been created after other pin[-s]
    on the same filter had been connected. Therefore, some other pins on this filter
    may have caused creation of pipes on this filter.

    To not break existing clients, we have to solve the general case with splitters
    (one pipe for multiple read-only inputs).


Arguments:

    KsPin -
        connecting pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IPin*         Pin;
    ULONG*        OutPinCount;
    ULONG*        InPinCount;
    IPin***       InPinList;
    IPin***       OutPinList;
    ULONG         i;
    ULONG         PinCountFrwd = 0;
    ULONG         PinCountBkwd = 0;
    IPin**        PinListFrwd;
    IPin**        PinListBkwd;
    IKsPin*       InKsPin;
    IKsPin*       OutKsPin;
    HRESULT       hr;



    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter entry KsPin=%x"), KsPin ));

    //
    // Find out this filter's topology
    //
    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

    //
    // to simplify the logic: frwd/bkwd - are relative to KsPin,
    // but out/in - are actually relative to the filter.
    //
    if (PinType == Pin_Input) {
        OutPinCount = &PinCountFrwd;
        OutPinList  = &PinListFrwd;
        InPinCount  = &PinCountBkwd;
        InPinList   = &PinListBkwd;
    }
    else {
        InPinCount  = &PinCountFrwd;
        InPinList   = &PinListFrwd;
        OutPinCount = &PinCountBkwd;
        OutPinList  = &PinListBkwd;
    }

    //
    // go forward (could be upstream - for the Pin_Output)
    //
    hr = Pin->QueryInternalConnections(
        NULL,
        &PinCountFrwd );

    if ( ! (SUCCEEDED( hr ) )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections rets=%x"), hr));
    }
    else {
        if (PinCountFrwd == 0) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter PinCount forward=0 ") ));
            hr = MakePipeBasedOnOnePin(KsPin, PinType, NULL);
        }
        else {
            if (NULL == (PinListFrwd = new IPin*[ PinCountFrwd ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipesBasedOnFilter E_OUTOFMEMORY on new IPin, %d pins"),
                        PinCountFrwd ));
            }
            else {
                hr = Pin->QueryInternalConnections(
                    PinListFrwd,
                    &PinCountFrwd );

                if ( ! (SUCCEEDED( hr ) )) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections frwd rets=%x"), hr));
                }
                else {
                    hr = PinListFrwd[ 0 ]->QueryInternalConnections(
                            NULL,
                            &PinCountBkwd );

                    //
                    // going backward after gone forward - we should always have at least one pin=KsPin.
                    //
                    if ( ! ( (SUCCEEDED( hr ) && PinCountBkwd) )) {

                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections bkwd rets=%x count=%d"),
                                hr, PinCountBkwd));

                        hr = E_FAIL;
                    }
                    else {
                        if (NULL == (PinListBkwd = new IPin*[ PinCountBkwd ])) {
                            hr = E_OUTOFMEMORY;

                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipesBasedOnFilter E_OUTOFMEMORY on new IPin back, %d pins"),
                                    PinCountBkwd ));

                        }
                        else {
                            hr = PinListFrwd[ 0 ]->QueryInternalConnections(
                                PinListBkwd,
                                &PinCountBkwd );

                            if ( ! (SUCCEEDED( hr ) )) {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR: MakePipesBasedOnFilter QueryInternalConnections bkwd rets=%x"), hr));
                                ASSERT( 0 );
                            }
                            else {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter: input pins=%d, output pins=%d"), *InPinCount, *OutPinCount ));

                                //
                                // here we know how many input pins and output pins on this filter are connected internally,
                                // so we can decide on how many pipes are needed.
                                //
                                if ( *InPinCount > 1) {
                                    //
                                    // this is a mixer; we need separate pipe for each input and output.
                                    // there is no properties yet to expose pin-to-pin framing relationship matrix.
                                    // NOTE: it doesn't matter whether it is M->1 mixer or M->N mixer, N>1 - we
                                    // need separate independent pipe for each pin anyway.
                                    //
                                    IKsPin*       TempKsPin;
                                    IKsPinPipe*   TempKsPinPipe;


                                    for (i = 0; i < *InPinCount; i++) {
                                        GetInterfacePointerNoLockWithAssert((*InPinList)[ i ], __uuidof(IKsPin), TempKsPin, hr);

                                        GetInterfacePointerNoLockWithAssert(TempKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

                                        if (! TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                                            hr = MakePipeBasedOnOnePin(TempKsPin, Pin_Input, NULL);
                                        }
                                    }

                                    for (i = 0; i < *OutPinCount; i++) {
                                        GetInterfacePointerNoLockWithAssert((*OutPinList)[ i ], __uuidof(IKsPin), TempKsPin, hr);

                                        GetInterfacePointerNoLockWithAssert(TempKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

                                        if (! TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                                            hr = MakePipeBasedOnOnePin(TempKsPin, Pin_Output, NULL);
                                        }
                                    }
                                }
                                else {
                                    //
                                    // this filter is either 1->N (N>1) splitter or 1->1 transform.
                                    //
                                    GetInterfacePointerNoLockWithAssert((*InPinList)[ 0 ], __uuidof(IKsPin), InKsPin, hr);

                                    if ( *OutPinCount > 1) {
                                        //
                                        // 1->N splitter, N>1
                                        //
                                        if ( (PinType != Pin_Input) && ( *OutPinCount > 1) ) {
                                            //
                                            // Make the connecting pin (KsPin) the first item in the OutPinList array,
                                            // by the convention with MakePipeBasedOnSplitter().
                                            //
                                            IPin*         TempPin;

                                            TempPin = (*OutPinList)[0];

                                            for (i=0; i < *OutPinCount; i++) {
                                                GetInterfacePointerNoLockWithAssert((*OutPinList)[ i ], __uuidof(IKsPin), OutKsPin, hr);

                                                if (OutKsPin == KsPin) {
                                                    (*OutPinList)[0] = (*OutPinList)[i];
                                                    (*OutPinList)[i] = TempPin;

                                                    break;
                                                }
                                            }
                                        }
                                        hr = MakePipeBasedOnSplitter(InKsPin, *OutPinList, *OutPinCount, PinType);
                                    }
                                    else {
                                        //
                                        // 1->1 transform
                                        //
                                        GetInterfacePointerNoLockWithAssert((*OutPinList)[ 0 ], __uuidof(IKsPin), OutKsPin, hr);

                                        hr = MakePipeBasedOnTwoPins(InKsPin, OutKsPin, Pin_Output, PinType);
                                    }
                                }
                                for (i=0; i<PinCountBkwd; i++) {
                                    PinListBkwd[i]->Release();
                                }
                            }
                            delete [] PinListBkwd;
                        }
                    }
                    for (i=0; i<PinCountFrwd; i++) {
                        PinListFrwd[i]->Release();
                    }
                }
                delete [] PinListFrwd;
            }
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipesBasedOnFilter rets=%x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnOnePin(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN IKsPin* OppositeKsPin
    )
/*++

Routine Description:

    Only one pin will decide on the pipe properties.
    There is no framing dependency on any other pin.

Arguments:

    KsPin -
        pin that determines the framing.

    PinType -
        KsPin type.

    OppositeKsPin -
        if NULL, then ignore the opposite pin,
        otherwise - OppositeKsPin pin doesn't have framing properties.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    IKsAllocatorEx*            KsAllocator;
    IKsAllocatorEx*            OppositeKsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    PIPE_TERMINATION*          TerminPtr;
    PIPE_TERMINATION*          OppositeTerminPtr;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                OppositeKsPinPipe;
    GUID                       Bus;
    BOOL                       FlagDone = 0;


    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnOnePin entry KsPin=%x, OppositeKsPin=%x"),
            KsPin, OppositeKsPin ));

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! OppositeKsPin ) {

        KSPIN_COMMUNICATION        Communication;

        KsPin->KsGetCurrentCommunication(&Communication, NULL, NULL);

        //
        // no pipe for bridge pins
        //
        if ( Communication == KSPIN_COMMUNICATION_BRIDGE ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin Single pin is a bridge.") ));

            FlagDone = 1;
        }
    }
    else {
        GetInterfacePointerNoLockWithAssert(OppositeKsPin, __uuidof(IKsPinPipe), OppositeKsPinPipe, hr);

        OppositeKsAllocator = OppositeKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        if (OppositeKsAllocator) {
            //
            // OppositeKsPin has a pipe already.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin OppositePin has a pipe already.") ));
            OppositeKsPinPipe->KsSetPipe(NULL);
            OppositeKsPin->KsReceiveAllocator( NULL );
        }
    }

    if (! FlagDone) {
        //
        // create and initialize the pipe (set the pipe in don't care state)
        //
        hr = CreatePipe(KsPin, &KsAllocator);

        if ( SUCCEEDED( hr )) {
            hr = InitializePipe(KsAllocator, 0);

            if ( SUCCEEDED( hr )) {
                GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

                if ( ! KsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
                    KsPin->KsReceiveAllocator(MemAllocator);
                }
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnOnePin KsPin has a MemAlloc already.") ));
                }
                KsPinPipe->KsSetPipe(KsAllocator);

                AllocEx = KsAllocator->KsGetProperties();
                //
                // Set the BusType and LogicalMemoryType for non-host-system buses.
                //
                GetBusForKsPin(KsPin, &Bus);
                AllocEx->BusType = Bus;

                if (! IsHostSystemBus(Bus) ) {
                    //
                    // Set the LogicalMemoryType for non-host-system buses.
                    //
                    AllocEx->LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
                }

                if (OppositeKsPin) {
                    if ( ! OppositeKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) )  {
                        OppositeKsPin->KsReceiveAllocator(MemAllocator);
                    }
                    else {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnOnePin OppositeKsPin has a MemAlloc already.") ));
                        ASSERT(0);
                    }
                    OppositeKsPinPipe->KsSetPipe(KsAllocator);
                }

                //
                // Get the pin framing from pin cache
                //
                GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);
                if (FramingProp != FramingProp_None) {
                    //
                    // Get the fixed memory\bus framing (first memory, fixed bus) from the FramingEx.
                    //
                    GetFramingFixedFromFramingByBus(FramingEx, Bus, TRUE, &FramingExFixed);

                    //
                    // since the pipe was initialized to defaults, we only need to update non-default pipe settings.
                    //
                    AllocEx->cBuffers = FramingExFixed.Frames;
                    AllocEx->cbBuffer = FramingExFixed.OptimalRange.Range.MaxFrameSize;
                    AllocEx->cbAlign  = (long) (FramingExFixed.FileAlignment + 1);
                    AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;

                    //
                    // Set pipe's LogicalMemoryType and MemoryType based on Framing and Bus.
                    //
                    if (AllocEx->LogicalMemoryType != KS_MemoryTypeDeviceSpecific) {
                        //
                        // For standard system bus - everything is defined from framing.
                        //
                        GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &AllocEx->LogicalMemoryType);
                        AllocEx->MemoryType = FramingExFixed.MemoryType;
                    }
                    else {
                        //
                        // Handle Device Specific Buses here.
                        //
                        if ( (FramingExFixed.MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
                             (FramingExFixed.MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
                             (FramingExFixed.MemoryType == KSMEMORY_TYPE_USER) ) {
                            //
                            // These are illegal memory types for non-host-system-buses, must be the legacy filters.
                            //
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTER MakePipeBasedOnOnePin: KsPin=%x HostSystemMemory over NonHost Bus."), KsPin ));

                            if (FramingProp == FramingProp_Old) {
                                //
                                // We don't want to break existing filters, so we correct their erroneous settings.
                                //
                                AllocEx->MemoryType = KSMEMORY_TYPE_DONT_CARE;
                            }
                            else {
                                //
                                // We refuse to connect new filters with wrong FRAMING_EX properties.
                                //
                                hr = E_FAIL;
                            }
                        }
                    }

                    if ( SUCCEEDED (hr) ) {
                        //
                        // to minimize code - use an indirection to cover both sides of a pipe.
                        //
                        if (PinType == Pin_Input) {
                            OppositeTerminPtr = &AllocEx->Output;
                            TerminPtr = &AllocEx->Input;
                        }
                        else if ( (PinType == Pin_Output) || (PinType == Pin_MultipleOutput) ) {
                            OppositeTerminPtr =  &AllocEx->Input;
                            TerminPtr = &AllocEx->Output;
                        }
                        else {
                            ASSERT (0);
                        }

                        if (! OppositeKsPin) {
                            OppositeTerminPtr->OutsideFactors |= PipeFactor_LogicalEnd;
                        }

                        if (PinType == Pin_MultipleOutput) {
                            AllocEx->Flags |= KSALLOCATOR_FLAG_MULTIPLE_OUTPUT;
                        }

                        AllocEx->Flags = FramingExFixed.Flags;

                        //
                        // set appropriate flags depending on pin's framing.
                        //
                        if (! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
                            AllocEx->InsideFactors |= PipeFactor_PhysicalRanges;
                        }

                        if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {
                            AllocEx->InsideFactors |= PipeFactor_OptimalRanges;
                        }

                        //
                        // Set the pipe allocator handling pin.
                        //
                        AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                        //
                        // Resolve the pipe.
                        //
                        hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);
                    }
                }
            }

            KsAllocator->Release();
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnOnePin rets %x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnFixedFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_FRAMING_FIXED FramingExFixed
    )
/*++

Routine Description:

    A fixed framing will define the new pipe properties.

Arguments:

    KsPin -
        pin that creates a pipe

    PinType -
        KsPin type.

    FramingExFixed -
        Fixed framing defining pipe properties.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPinPipe*                KsPinPipe;


    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnFixedFraming entry KsPin=%x"), KsPin ));

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    //
    // create and initialize the pipe (set the pipe in don't care state)
    //
    hr = CreatePipe(KsPin, &KsAllocator);

    if (SUCCEEDED( hr )) {

        hr = InitializePipe(KsAllocator, 0);

        if (SUCCEEDED( hr )) {

            GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

            if ( ! KsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {

                KsPin->KsReceiveAllocator(MemAllocator);
                KsPinPipe->KsSetPipe(KsAllocator);
                AllocEx = KsAllocator->KsGetProperties();

                //
                // since the pipe was initialized to defaults, we only need to update non-default pipe settings.
                //
                AllocEx->cBuffers = FramingExFixed.Frames;
                AllocEx->cbBuffer = FramingExFixed.OptimalRange.Range.MaxFrameSize;
                AllocEx->cbAlign  = (long) (FramingExFixed.FileAlignment + 1);
                AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;

                GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &AllocEx->LogicalMemoryType);
                AllocEx->MemoryType = FramingExFixed.MemoryType;

                if (PinType == Pin_MultipleOutput) {
                    AllocEx->Flags |= KSALLOCATOR_FLAG_MULTIPLE_OUTPUT;
                }

                AllocEx->Flags = FramingExFixed.Flags;

                //
                // set appropriate flags depending on pin's framing.
                //
                if (! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
                    AllocEx->InsideFactors |= PipeFactor_PhysicalRanges;
                }

                if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {
                    AllocEx->InsideFactors |= PipeFactor_OptimalRanges;
                }

                //
                // Set the pipe allocator handling pin.
                //
                AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                //
                // Resolve the pipe.
                //
                hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);

            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnFixedFraming KsPin has a MemAlloc already.") ));
                ASSERT(0);
            }
        }

        KsAllocator->Release();
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnFixedFraming rets %x"), hr ));

    return hr;
}


STDMETHODIMP
MakePipeBasedOnTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN ULONG OutPinType,
    IN ULONG ConnectPinType
    )
/*++

Routine Description:

    Both input and output pins on the same filter will determine the pipe settings.

Arguments:

    InKsPin -
        Input pin.

    OutKsPin -
        Output pin.

    OutPinType -
        Output pin type (Output or MultipleOutput).

    ConnectPinType -
        Connected pin type (Input or Output).


Return Value:

    S_OK or an appropriate error code.

--*/
{
    HRESULT                    hr;
    KSPIN_COMMUNICATION        InCommunication, OutCommunication;
    PKSALLOCATOR_FRAMING_EX    InFramingEx, OutFramingEx;
    FRAMING_PROP               InFramingProp, OutFramingProp;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    KS_FRAMING_FIXED           InFramingExFixed, OutFramingExFixed;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    GUID                       InBus, OutBus, ConnectBus;
    BOOL                       FlagBusesCompatible;
    ULONG                      ExistingPipePinType;
    ULONG                      CommonMemoryTypesCount;
    GUID                       CommonMemoryType;



    ASSERT(InKsPin && OutKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins entry In=%x, Out=%x"), InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // check for the bridge pins.
    //
    InKsPin->KsGetCurrentCommunication(&InCommunication, NULL, NULL);
    OutKsPin->KsGetCurrentCommunication(&OutCommunication, NULL, NULL);

    if ( ( InCommunication == KSPIN_COMMUNICATION_BRIDGE ) &&
         ( OutCommunication == KSPIN_COMMUNICATION_BRIDGE ) ) {
        //
        // error in a filter - it can't have 2 pins and both pins are bridges.
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR IN FILTER: both pins are bridge pins.") ));
        hr = E_FAIL;
    }
    else if ( InCommunication == KSPIN_COMMUNICATION_BRIDGE ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Input pin is a bridge.") ));

        if (! (OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) )) {
            hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, NULL);
        }
    }
    else if ( OutCommunication == KSPIN_COMMUNICATION_BRIDGE ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Output pin is a bridge.") ));

        if (! (InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) )) {
            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
        }
    }
    else {
        //
        // One of the pins should not have the pipe assigned, because one of the the pins is the connecting pin.
        // We should not have called this function if the connecting pin had a pipe.
        //
        if ( InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) && OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnTwoPins - both pins have pipes already.") ));
            ASSERT(0);
            hr = E_FAIL;
        }
        else {
            //
            // Get the pins framing from pins cache.
            //
            GetPinFramingFromCache(InKsPin, &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);
            GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - Framing Prop In=%d, Out=%d"), InFramingProp, OutFramingProp ));

            //
            // Get buses for pins and see if they are compatible.
            //
            GetBusForKsPin(InKsPin, &InBus);
            GetBusForKsPin(OutKsPin, &OutBus);

            if (ConnectPinType == Pin_Input) {
                ConnectBus = InBus;
            }
            else {
                ConnectBus = OutBus;
            }

            FlagBusesCompatible = AreBusesCompatible(InBus, OutBus);
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - FlagBusesCompatible=%d"), FlagBusesCompatible ));

            //
            // See if one pipe was created.
            //
            KsAllocator = InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
            if (KsAllocator) {
                ExistingPipePinType = Pin_Input;
            }
            else {
                KsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
                if (KsAllocator) {
                    ExistingPipePinType = Pin_Output;
                }
            }

            if (KsAllocator) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - %d pin had a pipe already."), ExistingPipePinType ));
                //
                // Connecting pin should not have any pipe association yet.
                //
                if (ExistingPipePinType == ConnectPinType) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR MakePipeBasedOnTwoPins - connecting %d pin had a pipe already."), ExistingPipePinType ));
                    ASSERT(0);
                    hr = E_FAIL;
                }
                else {
                    GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);
                }
            }

            if ( SUCCEEDED (hr) ) {
                if ( (InFramingProp == FramingProp_None) && (OutFramingProp == FramingProp_None) ) {
                    //
                    // if both pins don't care then we assume that the filter supports in-place transform
                    // and we will create one pipe for both pins if Input and Output buses are compatible.
                    //
                    // NOTE: for splitters we always have an output framing, so we won't execute the following code.
                    //
                    if (FlagBusesCompatible) {
                        ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, KSMEMORY_TYPE_DONT_CARE, InKsPinPipe, OutKsPinPipe,
                            MemAllocator, KsAllocator, ExistingPipePinType);
                    }
                    else {
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                    }
                }
                else if ( OutFramingProp != FramingProp_None ) {
                    //
                    // The first memory type per fixed bus in the pin's framing
                    // will determine the KS choice.
                    // If OutKsPin is not connected yet, then OutBus=GUID_NULL, so the first
                    // framing item is returned.
                    //
                    GetFramingFixedFromFramingByBus(OutFramingEx, OutBus, TRUE, &OutFramingExFixed);

                    if (OutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER) {

                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins - in place modifier") ));
                        //
                        // Check to see if Input and Output Buses allow a single pipe throughout this filter.
                        //
                        if (! FlagBusesCompatible) {
                            //
                            // The only way to build a single pipe across multiple buses -
                            // is to explicitly agree on a fixed common memory type for all the pipe's pins.
                            // Both pins must support extended framing and both pins must agree on a common fixed memory type.
                            //
                            if ( (OutFramingProp != FramingProp_Ex) || (InFramingProp != FramingProp_Ex) ) {
                                ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                            }
                            else {
                                if (! KsAllocator) {
                                    //
                                    // There is no pipes on this filter yet.
                                    // Get the first common memory type for the filter pins per the known ConnectBus.
                                    //
                                    CommonMemoryTypesCount = 1;

                                    if (FindCommonMemoryTypesBasedOnBuses(InFramingEx, OutFramingEx, ConnectBus, GUID_NULL,
                                            &CommonMemoryTypesCount, &CommonMemoryType) ) {

                                        CreatePipeForTwoPins(InKsPin, OutKsPin, ConnectBus, CommonMemoryType);
                                    }
                                    else {
                                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                                    }
                                }
                                else {
                                    //
                                    // A pipe on one of the filter's pins already exists.
                                    //
                                    IKsPin*      PipeKsPin;
                                    ULONG        PipePinType;
                                    IKsPin*      ConnectKsPin;

                                    if (ConnectPinType == Pin_Input) {
                                        PipeKsPin = OutKsPin;
                                        PipePinType = Pin_Output;
                                        ConnectKsPin = InKsPin;
                                    }
                                    else {
                                        PipeKsPin = InKsPin;
                                        PipePinType = Pin_Input;
                                        ConnectKsPin = OutKsPin;
                                    }

                                    if (! FindCommonMemoryTypeBasedOnPipeAndPin(PipeKsPin, PipePinType, ConnectKsPin, ConnectPinType, TRUE, NULL) ) {
                                        //
                                        // If a single pipe thru this filter was possible, then it has been built by
                                        // FindCommonMemoryTypeBasedOnPipeAndPin function above, and we are done.
                                        //
                                        // We are here ONLY if a single pipe solution thru this filter is not possible,
                                        // so we will have separate pipes on this filter.
                                        //
                                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                                    }
                                }
                            }
                        }
                        else {
                            //
                            // We won't consider possible input pin's framing.
                            //
                            if (! KsAllocator) {
                                hr = MakePipeBasedOnOnePin(OutKsPin, OutPinType, InKsPin);
                            }
                            else {
                                //
                                // add one pin to existing pipe
                                //
                                ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, OutFramingExFixed.MemoryType, InKsPinPipe, OutKsPinPipe,
                                    MemAllocator, KsAllocator, ExistingPipePinType);
                            }
                        }
                    }
                    else {
                        //
                        // make two pipes on this filter.
                        //
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                        //
                        // there can be framing size dependancies between two pins (or pipes)
                        //
                        if (OutFramingExFixed.OutputCompression.RatioConstantMargin == 0)  {
                            //
                            // make the two pipes dependant
                            //
                            hr = MakeTwoPipesDependent(InKsPin, OutKsPin);
                            if (! SUCCEEDED( hr )) {
                                ASSERT(0);
                            }
                        }
                    }
                }
                else if ( InFramingProp != FramingProp_None ) {

                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnTwoPins - Input pin sets framing") ));

                    GetFramingFixedFromFramingByBus(InFramingEx, InBus, TRUE, &InFramingExFixed);

                    if (! FlagBusesCompatible) {
                        ResultSeparatePipes(InKsPin, OutKsPin, OutPinType, ExistingPipePinType, KsAllocator);
                    }
                    else {
                        //
                        // since there is no Output pin framing, we do in place. It is consistent with an old allocators scheme.
                        //
                        ResultSinglePipe(InKsPin, OutKsPin, ConnectBus, InFramingExFixed.MemoryType, InKsPinPipe, OutKsPinPipe,
                            MemAllocator, KsAllocator, ExistingPipePinType);
                    }
                }
            }
        }
    }
    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnTwoPins rets %x"), hr ));

    return hr;

}


STDMETHODIMP
MakePipeBasedOnSplitter(
    IN IKsPin* InKsPin,
    IN IPin** OutPinList,
    IN ULONG OutPinCount,
    IN ULONG ConnectPinType
    )
/*++

Routine Description:

    One input and all output pins on the same filter will determine the filter pipe[-s] settings.
    In case the connecting pin is an output pin, it should be listed first in the OutPinList.

Arguments:

    InKsPin -
        Input pin.

    OutPinList -
        Output pins list.

    OutPinCount -
        Count of the Output pin list above.

    ConnectPinType -
        Connecting pin type (Input or Output).

Return Value:

    S_OK or an appropriate error code.

--*/
{

    HRESULT                    hr;
    PKSALLOCATOR_FRAMING_EX    OutFramingEx;
    KS_FRAMING_FIXED           OutFramingExFixed;
    FRAMING_PROP               OutFramingProp;
    IKsAllocatorEx*            TempKsAllocator;
    ULONG                      i, j;
    IKsPin*                    OutKsPin;
    IKsPinPipe*                TempKsPinPipe;
    BOOL                       IsInputPinPipeCreated = 0;
    ULONG                      FlagReadOnly;
    KEY_PIPE_DATA*             KeyPipeData = NULL;
    ULONG                      KeyPipeDataCount = 0;
    ULONG                      FoundPipe;
    GUID                       Bus;



    ASSERT(InKsPin && OutPinList && (OutPinCount > 1) );

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN MakePipeBasedOnSplitter entry InKsPin=%x, OutPinCount=%d"), InKsPin, OutPinCount ));

    //
    // To do: Currently filters don't set KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY on input pins.
    // Splitters (MsTee) don't indicate KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY or
    // KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER on output pins,
    // so there is no way to decide on a single (read-only) output pipe.
    // Current allocators  don't consider flags at all, assuming that single
    // output pipe is possible by default.
    //
    // Assign FlagReadOnly=KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER | KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY
    // when all filters are updated to use correct read-only flags.
    // Strictly speaking, only KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY flag means read-only, but in case
    // of splitters, KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER on output pin means using one allocator for
    // input and output pins, so if there are multiple output pins on a splitter - then such setting makes
    // sense only for read-only connections.
    //
    // For now:
    //
    FlagReadOnly = 0xffffffff;

    //
    // See if the input pin has a pipe already.
    //
    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

    if ( TempKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) {
        IsInputPinPipeCreated = 1;
    }

    //
    // It is possible that some pins on this splitter are already connected, and some pipes
    // are built (e.g. the new output pin was created after some pins had been connected).
    // There are 3 types of output pins: pins already connected (they must have corresponding pipes);
    // pins that are not yet connected; and one connecting pin (if ConnectPinType==Pin_Output)
    //

    //
    // In order to quickly look-up possible pipes connections, we maintain the table of the existing pipes.
    //
    if (OutPinCount > 0) {
        if (NULL == (KeyPipeData = new KEY_PIPE_DATA[ OutPinCount ]))  {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR E_OUTOFMEMORY MakePipeBasedOnSplitter. OutPinCount=%d"), OutPinCount ));
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr) ) {
        //
        // First pass - build the table of the existing pipes on this filter: KeyPipeData.
        //
        for (i=0; i<OutPinCount; i++) {

            GetInterfacePointerNoLockWithAssert(OutPinList[ i ], __uuidof(IKsPin), OutKsPin, hr);

            GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

            //
            // See if there is any pipe built on this pin; and if there is a kernel mode pipe - see if it is already
            // listed in KeyPipeData[].
            //
            TempKsAllocator = TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
            if (TempKsAllocator && IsKernelModeConnection(OutKsPin) ) {
                FoundPipe = 0;
                for (j=0; j<KeyPipeDataCount; j++) {
                    if (TempKsAllocator == KeyPipeData[j].KsAllocator) {
                        FoundPipe = 1;
                        break;
                    }
                }

                if (! FoundPipe) {
                    KeyPipeData[KeyPipeDataCount].KsPin = OutKsPin;
                    KeyPipeData[KeyPipeDataCount].PinType = Pin_Output;
                    KeyPipeData[KeyPipeDataCount].KsAllocator = TempKsAllocator;
                    KeyPipeDataCount++;
                }
            }
        }

        DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnSplitter KeyPipeDataCount=%d, IsInputPinPipeCreated=%d"),
                KeyPipeDataCount, IsInputPinPipeCreated ));

        //
        // Build the pipe for the Input pin (if it has not been built yet).
        // We do it now, because we want to try to put the Input pin on one of the
        // pipes that had been already built for the CONNECTED output pins on the same filter.
        //
        if (! IsInputPinPipeCreated) {
            if (SplitterCanAddPinToPipes(InKsPin, Pin_Input, KeyPipeData, KeyPipeDataCount) ) {
                IsInputPinPipeCreated = 1;
            }
        }

        //
        // Second pass: build the pipes for the output pins that don't have pipes yet.
        // In case ConnectPinPipe==Pin_Output, the OutPinList[0] is the connecting pin,
        // so the connecting pin is always handled first.
        //
        for (i=0; i<OutPinCount; i++) {

            GetInterfacePointerNoLockWithAssert(OutPinList[ i ], __uuidof(IKsPin), OutKsPin, hr);

            GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), TempKsPinPipe, hr);

            if (TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly ) ) {
                continue;
            }

            GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);
            if (OutFramingProp == FramingProp_None) {
                //
                // Output pin must have the framing properties to qualify for "in-place" transform.
                //
                hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
            }
            else {
                GetBusForKsPin(OutKsPin, &Bus);
                GetFramingFixedFromFramingByBus(OutFramingEx, Bus, TRUE, &OutFramingExFixed);
                if (OutFramingExFixed.Flags & FlagReadOnly) {
                    if (SplitterCanAddPinToPipes(OutKsPin, Pin_Output, KeyPipeData, KeyPipeDataCount) ) {
                        //
                        // Done with this output pin.
                        //
                        continue;
                    }

                    //
                    // None of the existing pipes is compatible with this output pin,
                    // so we have to build a new pipe for this output pin.
                    // Also, for the first new pipe we build here (we start with the connecting pin),
                    // consider the input pin on this filter (if the input pin does not have a pipe yet).
                    //
                    if (! IsInputPinPipeCreated) {
                        hr = MakePipeBasedOnTwoPins(InKsPin, OutKsPin, Pin_Output, ConnectPinType);
                        IsInputPinPipeCreated = 1;
                    }
                    else {
                        hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
                    }
                }
                else {
                    hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
                }
            }

            //
            // Add new output pipe to the KeyPipeData
            //
            TempKsAllocator = TempKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
            ASSERT(TempKsAllocator);

            KeyPipeData[KeyPipeDataCount].KsPin = OutKsPin;
            KeyPipeData[KeyPipeDataCount].PinType = Pin_Output;
            KeyPipeData[KeyPipeDataCount].KsAllocator = TempKsAllocator;
            KeyPipeDataCount++;
        }
    }


    //
    // If we haven't yet created the pipe for the input pin, we must
    // create it now.
    //
    if (! IsInputPinPipeCreated) {
        hr = MakePipeBasedOnOnePin (InKsPin, Pin_Input, NULL);
        IsInputPinPipeCreated = 1;
    }

    if (KeyPipeData) {
        delete [] KeyPipeData;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES MakePipeBasedOnSplitter rets %x, KeyPipeDataCount=%d"), hr, KeyPipeDataCount ));

    return hr;

}


STDMETHODIMP
MakeTwoPipesDependent(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
   )
/*++

Routine Description:

    Both input and output pins reside on the same filter,
    but they belong to different pipes.

    Two pipes are dependent if their frame sizes are dependent.
    There are the following reasons for creating dependend pipes:

    - output pin does have framing properties and it doesn't specify "in-place" transform.
    - memory types do not allow a single pipe solution.
    - we have a downstream expansion, and the very first filter doesn't support partial frame read operation.

Arguments:

    InKsPin -
        input pin.

    OutKsPin -
        output pin.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    //
    // Don't need this for an intermediate version.
    //
    return S_OK;

}


STDMETHODIMP
ConnectPipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin
    )
/*++

Routine Description:

    Connecting pipes.

    Merging pipes into one pipe is not possible if: incompatible memory types,
    or incompatible physical framing, or there are pins on both sides that require their own allocators.

    There are two extreme cases:

    OPTIMAL CASE - trying to find the optimal solution by optimizing some formal goal-function.
    NO OPTIMIZATION CASE - ignoring most of the framing info, just getting connected.

    OPTIMAL CASE - each of the two connecting pipes has optimal solution. In case that memory types,
    and optimal ranges do intersect - this intersection yields the optimal solution for the entire graph.
    (The total MAX can't be greater than sum of the upstream and downstream independent MAX-es.)

    In case either memory types or optimal ranges do not intersect - we will need to search for optimal
    solution trying out a lot of possible pipes-systems in both upstream and downstream directions from
    the connection point.

    INTERMEDIATE MODEL - in case that memory types and physical ranges do intersect - the connection is
    possible by merging the connecting pipes. We will also consider the optimal ranges of the pipe system
    with the greater weight.

    In case either memory types or physical ranges do not intersect - we will have to modify existing
    pipes systems to make the connection possible.
    For each combination of upstream and downstream memory types and buses we have non-exhaustive list
    of preferred connection types in priority order.

    If all connection types fail - then the connection is not possible and we will return the corresponding
    error code.

    We also must cover the case when the connecting pin's framing or medium changes dynamically.
    In the intermediate model we do the following:

    If any of the connecting pin's medium or framing changed:
    - Try to use one pipe through the connecting pin.
    - Split the pipe at the connecting pin.


Arguments:

    InKsPin -
        input pin on downstream filter

    OutKsPin -
        output pin on upstream filter

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            InKsAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx, OutAllocEx;
    HRESULT                    hr;
    ULONG                      Attempt, NumPipes, FlagChange;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;

    ASSERT (InKsPin && OutKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes entry Out=%x In=%x"), OutKsPin, InKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // 1. Process any changes on the output pin.
    //
    hr = ResolvePipeOnConnection(OutKsPin, Pin_Output, FALSE, &FlagChange);
    if ( SUCCEEDED( hr ) ) {
        //
        // 2. Process any changes on the input pin.
        //
        hr = ResolvePipeOnConnection(InKsPin, Pin_Input, FALSE, &FlagChange);
    }

    if ( SUCCEEDED( hr ) ) {
        //
        // 3. Based on the logical memory types for the connecting pipes
        //    manage the connection.
        //
        OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        OutAllocEx = OutKsAllocator->KsGetProperties();

        InKsAllocator = InKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        InAllocEx = InKsAllocator->KsGetProperties();

        for (Attempt = 0; Attempt < ConnectionTableMaxEntries; Attempt++) {
            NumPipes = ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].NumPipes;

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes, Out=%x %d, In=%x %d, Attempt=%d, Pipes=%d"),
                    OutKsAllocator, OutAllocEx->LogicalMemoryType,
                    InKsAllocator, InAllocEx->LogicalMemoryType,
                    Attempt, NumPipes ));

            if (NumPipes == 0) {
                //
                // means that we used all the possible attempts for this combination.
                //
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipes Pipes=3 (0)") ));

                if (! CanConnectPins(OutKsPin, InKsPin, Pin_Move) ) {
                    hr = E_FAIL;
                }

                break;
            }

            if (NumPipes == 1) {
                //
                // try to merge pipes using predetermined memory type.
                //
                if (ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].Code == KS_DIRECTION_DOWNSTREAM) {
                    if ( CanPipeUseMemoryType(OutKsPin, Pin_Output, InAllocEx->MemoryType, InAllocEx->LogicalMemoryType, FALSE, TRUE) ) {
                        if (CanMergePipes(InKsPin, OutKsPin, InAllocEx->MemoryType, TRUE) ) {
                            break;
                        }
                    }
                }
                else {
                    if ( CanPipeUseMemoryType(InKsPin, Pin_Input, OutAllocEx->MemoryType, OutAllocEx->LogicalMemoryType, FALSE, TRUE) ) {
                        if (CanMergePipes(InKsPin, OutKsPin, OutAllocEx->MemoryType, TRUE) ) {
                            break;
                        }
                    }
                }
            }
            else if (NumPipes == 2) {
                //
                // try to have 2 pipes with predetermined breaking pins and memory types.
                //
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipes Pipes=2") ));

                if (ConnectionTable[OutAllocEx->LogicalMemoryType] [InAllocEx->LogicalMemoryType] [Attempt].Code == KS_DIRECTION_DOWNSTREAM) {
                    if (CanAddPinToPipeOnAnotherFilter(InKsPin, OutKsPin, Pin_Output, Pin_Move) ) {
                        break;
                    }
                }
                else {
                    if (CanAddPinToPipeOnAnotherFilter(OutKsPin, InKsPin, Pin_Input, Pin_Move) ) {
                        break;
                    }
                }
            }
            else if (NumPipes == 3) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipes Pipes=3") ));

                if (CanConnectPins(OutKsPin, InKsPin, Pin_Move) ) {
                    break;
                }
            }
        }

        //
        // We have successfully connected the pins.
        // Lets optimize the dependent pipes system.
        //
        if ( SUCCEEDED( hr ) ) {
            OptimizePipesSystem(OutKsPin, InKsPin);
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipes rets %x"), hr ));

    return hr;

}


STDMETHODIMP
ResolvePipeOnConnection(
    IN  IKsPin* KsPin,
    IN  ULONG PinType,
    IN  ULONG FlagDisconnect,
    OUT ULONG* FlagChange
    )
/*++

Routine Description:

    When pin is connecting/disconnecting, its framing properties
    and medium may change. This routine returns the FlagChange
    indicating the framing properties that have changed (if any).

Arguments:

    KsPin -
        connecting/disconnecting pin.

    PinType -
        KsPin type.

    FlagDisconnect -
        1 if KsPin is disconnecting,
        0 if KsPin is connecting.

    FlagChange -
        resulting change in a pipe system.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    ULONG                      FramingDelta;
    HRESULT                    hr;
    KS_LogicalMemoryType       LogicalMemoryType;
    IKsPinPipe*                KsPinPipe;
    GUID                       BusLast, BusOrig;
    BOOL                       FlagDone = 0;



    ASSERT (KsPin);

    *FlagChange = 0;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (!SUCCEEDED(hr)) {
        return hr;
    }

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // See if KsPin's medium has changed.
    // Note: we are keeping the most recent value of the pin's connection bus in pin's cache.
    // We are interested in the pin's bus delta at the particular time, when we are computing
    // the graph data flow solution.
    //
    GetBusForKsPin(KsPin, &BusLast);
    BusOrig = KsPinPipe->KsGetPinBusCache();

    if ( BusOrig != BusLast ) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x Bus Changed"), KsPin ));

        if (! AreBusesCompatible(AllocEx->BusType, BusLast) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x Buses incompatible"), KsPin ));

            KsPinPipe->KsSetPinBusCache(BusLast);
            //
            // Pipe has to be changed - different memory type must be used.
            //
            if (! FindCommonMemoryTypeBasedOnPipeAndPin(KsPin, PinType, KsPin, PinType, TRUE, NULL) ) {
                CreateSeparatePipe(KsPin, PinType);
            }
            *FlagChange = 1;
            FlagDone = 1;
        }
    }

    if (! FlagDone) {
        KsPinPipe->KsSetPinBusCache(BusLast);

        //
        // See if KsPin framing has changed.
        //
        ComputeChangeInFraming(KsPin, PinType, AllocEx->MemoryType, &FramingDelta);
        if (! FramingDelta) {
            FlagDone = 1;
        }
    }

    if (! FlagDone) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection KsPin=%x, FramingDelta=%x"),
                KsPin, FramingDelta));

        //
        // input pipe should not have an upstream dependent pipe.
        //
        if (PinType == Pin_Input) {
            if (AllocEx->PrevSegment) {
                ASSERT(0);
           }
        }

        //
        // handle the situation when this pin has no framing now.
        //
        GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

        if (FramingProp != FramingProp_None) {
            //
            // If this pin's framing changed - we will try to use a single pipe.
            // If using a single pipe is not possible - then we will split the pipe at this pin.
            //
            // Pipe can have one assigned allocator handler only.
            // In case there has been a "MUST ALLOCATE" pin assigned on a pipe already .AND.
            // the connecting pin's framing changed and it now requires "MUST ALLOCATE" - then
            // we have to split the pipe.
            //
            if ((AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
                (FramingDelta & KS_FramingChangeAllocator) ) {

                if (GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
                    if (FramingExFixed.MemoryFlags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {

                        CreateSeparatePipe(KsPin, PinType);
                        *FlagChange = 1;

                        FlagDone = 1;
                    }
                }
            }

            if (! FlagDone) {
                //
                // Handle memory type change in this pin.
                //
                if (FramingDelta & KS_FramingChangeMemoryType) {

                    if (AllocEx->LogicalMemoryType == KS_MemoryTypeDontCare) {

                        if (GetFramingFixedFromFramingByLogicalMemoryType(FramingEx, KS_MemoryTypeAnyHost, &FramingExFixed) ) {

                            GetLogicalMemoryTypeFromMemoryType(FramingExFixed.MemoryType, FramingExFixed.MemoryFlags, &LogicalMemoryType);
                            if (LogicalMemoryType != KS_MemoryTypeDontCare) {
                                //
                                // Try to change 'dont care' pipe into this pin memory type
                                // if pipe dimensions allow.
                                //
                                if ( CanPipeUseMemoryType(KsPin, PinType, FramingExFixed.MemoryType, LogicalMemoryType, TRUE, FALSE) ) {
                                    *FlagChange = 1;
                                }
                                else {
                                    CreateSeparatePipe(KsPin, PinType);
                                    *FlagChange = 1;

                                    FlagDone = 1;
                                }
                            }
                        }
                        else {
                            //
                            // pin doesn't explicitly support host memory types.
                            //
                            if (IsHostSystemBus(BusLast) ) {
                                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTER: ConnectPipes - Framing doesn't specify host memory, but medium does.") ));
                                hr = E_FAIL;
                            }
                            else {
                                //
                                // The put pin is connected via non-host bus. Its current pipe uses host memory.
                                // So this pipe can't go thru put pin.
                                //
                                CreateSeparatePipe(KsPin, PinType);
                                *FlagChange = 1;

                                FlagDone = 1;
                            }
                        }
                    }
                    else {
                        //
                        // Pipe has fixed memory type.
                        // We will try to have KsPin to reside on its original pipe.
                        //
                        if (GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
                            if ( ! CanPipeUseMemoryType(KsPin, PinType, AllocEx->MemoryType, AllocEx->LogicalMemoryType, TRUE, FALSE) ) {
                                CreateSeparatePipe(KsPin, PinType);
                                *FlagChange = 1;

                                FlagDone = 1;
                            }
                        }
                        else {
                            //
                            // this pin doesn't support this pipe's memory.
                            //
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection: Pin doesn't support its old pipe memory") ));

                            // RSL CreateSeparatePipe(KsPin, PinType);
                            // *FlagChange = 1;

                            FlagDone = 1;
                        }
                    }
                }

                if ( SUCCEEDED(hr) && (! FlagDone) ) {
                    //
                    // Handle dimensions change in KsPin framing (ranges, compression).
                    //
                    if ( (FramingDelta & KS_FramingChangeCompression ) ||
                        (FramingDelta & KS_FramingChangePhysicalRange) ||
                        (FramingDelta & KS_FramingChangeOptimalRange ) ) {

                        *FlagChange = 1;

                        if ( ! SUCCEEDED (ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT) )) {
                            CreateSeparatePipe(KsPin, PinType);
                        }
                    }
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ResolvePipeOnConnection rets %x FlagChange=%d"), hr, *FlagChange));

    return hr;

}


STDMETHODIMP
ConnectPipeToUserModePin(
    IN IKsPin* OutKsPin,
    IN IMemInputPin* InMemPin
    )
/*++

Routine Description:

    Connecting kernel pipe to user-mode pin.

    User-mode pins do not currently support framing, they only support simple allocators.
    If user-mode input pin has its own allocator handler, then we will use this allocator handler for kernel pin.
    Otherwise, there is no way to know about user-mode pin allocator preferences anyway,
    (except, of course, that it must be a user-mode memory), so we will change our
    system of pipes to satisfy just one condition - to have a user-mode memory termination.


Arguments:

    OutKsPin -
        kernel mode output pin.

    InMemPin -
        user mode input pin.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IMemAllocator*             UserMemAllocator;
    IMemAllocator*             OutMemAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    PKSALLOCATOR_FRAMING_EX    OutFramingEx;
    FRAMING_PROP               OutFramingProp;
    ALLOCATOR_PROPERTIES       Properties, ActualProperties;
    HRESULT                    hr;
    BOOL                       UserAllocProperties = FALSE;
    ULONG                      NumPinsInPipe;
    IKsPinPipe*                OutKsPinPipe;
    ULONG                      PropertyPinType;
    GUID                       Bus;
    ULONG                      FlagChange;
    BOOL                       IsSpecialOutputRequest = FALSE;
    IKsPin*                    InKsPin;
    ULONG                      OutSize, InSize;

    ASSERT (InMemPin && OutKsPin);


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipeToUserModePin. OutKsPin=%x"), OutKsPin));

    //
    // Process any changes on output pin.
    //
    hr = ResolvePipeOnConnection(OutKsPin, Pin_Output, FALSE, &FlagChange);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    RtlZeroMemory( &Properties, sizeof( Properties ) );

    //
    // sanity check - the only possible connection to user mode is via HOST_BUS
    //
    GetBusForKsPin(OutKsPin, &Bus);

    if (! IsHostSystemBus(Bus) ) {
        //
        // Don't fail, as there are some weird video port filters that connect via non-host-bus with the user-mode filters.
        //
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN FILTERS: ConnectPipeToUserModePin. BUS is not HOST_BUS.") ));
    }

    if (SUCCEEDED(hr) ) {
        //
        // see if output kernel pin can connect to user mode.
        //
        GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_Update);

        //
        // Don't enforce this yet.
        //
#if 0
        if (OutFramingProp == FramingProp_Ex) {

            KS_FRAMING_FIXED           OutFramingExFixed;

            if (! GetFramingFixedFromFramingByLogicalMemoryType(OutFramingEx, KS_MemoryTypeUser, &OutFramingExFixed) ) {
                if (! GetFramingFixedFromFramingByLogicalMemoryType(OutFramingEx, KS_MemoryTypeDontCare, &OutFramingExFixed) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS: ConnectPipeToUserModePin. Out framing doesn't support USER mode memory. Connection impossible.") ));
                    hr = E_FAIL;
                }
            }
        }
#endif

        //
        // Connection is possible.
        //
        ComputeNumPinsInPipe(OutKsPin, Pin_Output, &NumPinsInPipe);

        OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

        if (NumPinsInPipe > 1) {
            //
            // In intermediate version we split the pipe: so the pipe leading to(from) user mode pin
            // will always have just 1 kernel pin.
            //
            // Note: decrementing of RefCount for the original pipe happens inside CreateSeparatePipe.
            //
            CreateSeparatePipe(OutKsPin, Pin_Output);
            OutKsAllocator = OutKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        }

        //
        // get downstream allocator properties
        //
        hr = InMemPin->GetAllocatorRequirements( &Properties);
        if ( SUCCEEDED( hr )) {
            UserAllocProperties = TRUE;
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. UserAllocProperties exist: Prop=%d, %d, %d"),
                    Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));
        }

        UserMemAllocator = NULL;
        InMemPin->GetAllocator( &UserMemAllocator );

        //
        // decide which pin will determine base allocator properties.
        //
        if (UserAllocProperties) {
            if (OutFramingProp != FramingProp_None) {
                PropertyPinType = Pin_All;
            }
            else {
                PropertyPinType = Pin_User;
            }
        }
        else {
            PropertyPinType = Pin_Output;
        }

        //
        // See if connecting kernel-mode filter requires KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO (e.g. MsTee)
        //
        if ( ! (IsSpecialOutputRequest = IsSpecialOutputReqs(OutKsPin, Pin_Output, &InKsPin, &OutSize, &InSize ) )) {
            InSize = 0;
        }

        //
        // Try to use an existing user-mode input pin's allocator first.
        //
        SetUserModePipe(OutKsPin, Pin_Output, &Properties, PropertyPinType, InSize);

        //
        // decide which pin will be an allocator handler.
        //
        if (UserMemAllocator) {

            if ((FramingProp_None == OutFramingProp) ||
                !(KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE & OutFramingEx->FramingItem[0].MemoryFlags)) {
                // Either the pin has no particular framing requirements or
                // it is not requiring a kernel allocator, so we'll try use mode first.

                DbgLog(( LOG_MEMORY, 2, TEXT("PIPES UserAlloc. ConnectPipeToUserModePin. PinType=%d. Wanted Prop=%d, %d, %d"),
                         PropertyPinType, Properties.cBuffers, Properties.cbBuffer, Properties.cbAlign));

                hr = UserMemAllocator->SetProperties(&Properties, &ActualProperties);

                DbgLog(( LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. ActualProperties=%d, %d, %d hr=%x"),
                         ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

                //
                // Make sure that actual properties are usable.
                //
                if (SUCCEEDED(hr) && ActualProperties.cbBuffer) {

                    hr = InMemPin->NotifyAllocator( UserMemAllocator, FALSE );
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. NotifyAllocator rets %x"), hr ));
                    
                    if (SUCCEEDED(hr)) {
                        
                        IMemAllocatorCallbackTemp* AllocatorNotify;

                        //
                        // If this allocator supports the new notification interface, then
                        // use it. This may force this own filter's allocator to be used.
                        // Don't set up notification until Commit time.
                        //
                        if (SUCCEEDED(UserMemAllocator->QueryInterface(__uuidof(IMemAllocatorCallbackTemp), reinterpret_cast<PVOID*>(&AllocatorNotify)))) {
                            AllocatorNotify->Release();
                            hr = OutKsPin->KsReceiveAllocator(UserMemAllocator);
                            }
                        else {
                            DbgLog((LOG_MEMORY, 0, TEXT("PIPES ConnectPipeToUserModePin. Allocator does not support IMemAllocator2")));
                            hr = E_NOINTERFACE;
                            } // if ... else
                        } // if (SUCCEEDED(hr))
                    } // if (SUCCEEDED(hr) && ActualProperties.cbBuffer)
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN ConnectPipeToUserModePin. ActualProperties are not satisfactory") ));
                    } // else
                if (FAILED(hr)) {
                    SAFERELEASE( UserMemAllocator );
                    }
            } // if ((FramingProp_None == OutFramingProp) || ...
        else {
            // Kernel mode allocator required and framing requirements are present
            SAFERELEASE( UserMemAllocator );
            } // else
        } // if (UserMemAllocator)

        if (!UserMemAllocator) {
            //
            // We are here only if the user-mode allocator is not useful and we will create our own.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN ConnectPipeToUserModePin. KsProxy user-mode allocator. PinType=%d"),
                    PropertyPinType ));
            //
            // communicate new allocator handler and new properties (part of new allocator) to user mode pin.
            //
            OutKsAllocator->KsSetAllocatorMode(KsAllocatorMode_User);

            GetInterfacePointerNoLockWithAssert(OutKsAllocator, __uuidof(IMemAllocator), OutMemAllocator, hr);

            hr = OutMemAllocator->SetProperties(&Properties, &ActualProperties);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. ActualProperties=%d, %d, %d hr=%x"),
                    ActualProperties.cBuffers, ActualProperties.cbBuffer, ActualProperties.cbAlign, hr));

            if ( SUCCEEDED( hr ) ) {
                hr = InMemPin->NotifyAllocator( OutMemAllocator, FALSE );
                if (SUCCEEDED(hr)) {
                    OutKsPin->KsReceiveAllocator(OutMemAllocator);
                }
            }
        }
        else {
            SAFERELEASE( UserMemAllocator );
        }
    }

    if ( SUCCEEDED( hr ) && IsSpecialOutputRequest && (ActualProperties.cbBuffer < (long) InSize) ) {
        //
        // We haven't succeeded sizing the output user-mode pipe. Lets try to resize the input pipe (WRT this k.m. filter).
        //
        if (! CanResizePipe(InKsPin, Pin_Input, ActualProperties.cbBuffer) ) {
            //
            // Don't fail. Just log.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR ConnectPipeToUserModePin. Couldn't resize pipes InKsPin=%x"), InKsPin));
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ConnectPipeToUserModePin. Rets %x"), hr));

    return hr;

}


STDMETHODIMP
DisconnectPins(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT BOOL* FlagBypassBaseAllocators
    )
/*++

Routine Description:

    Handling disconnecting pins allocators.

Arguments:

    KsPin -
        kernel mode pin at the pipe break point.

    PinType -
        KsPin type.

    FlagBypassBaseAllocators -
        indicates whether or not the base allocators handlers should be bypassed.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    IPin*                      ConnectedPin;
    IKsPin*                    ConnectedKsPin;
    HRESULT                    hr;
    IKsAllocatorEx*            KsAllocator;
    IKsAllocatorEx*            ConnectedKsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    KS_LogicalMemoryType       OrigLogicalMemoryType;
    GUID                       OrigMemoryType;
    ULONG                      AllocatorHandlerLocation;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                ConnectedKsPinPipe;



    ASSERT(KsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins entry KsPin=%x, PinType=%d"), KsPin, PinType ));

    *FlagBypassBaseAllocators = TRUE;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    //
    // Retrieve the original pipe properties before destroying access to it.
    //
    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    AllocEx = KsAllocator->KsGetProperties();

    OrigLogicalMemoryType = AllocEx->LogicalMemoryType;
    OrigMemoryType = AllocEx->MemoryType;

    ConnectedPin = KsPinPipe->KsGetConnectedPin();
    if (ConnectedPin) {
        if (! IsKernelPin(ConnectedPin) ) {
            //
            // Connected pin is a user-mode pin.
            //
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins - from User Mode") ));

            //
            // Well, m_Connected may be set, but it does not mean that the pins had completed their connection.
            // We need to look at our internal pipes state to see if the reported connection is in fact real.
            //
            if ( (PinType == Pin_Output) && (! HadKernelPinBeenConnectedToUserPin(KsPin, KsAllocator) ) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN DisconnectPins: never been connected !") ));
            }
            else {
                //
                // Currently, one-pin-pipe is the only pipe available for user-mode pins connections.
                //
                *FlagBypassBaseAllocators = FALSE;

                //
                // Don't delete the pipe that hosts a user-mode KsProxy allocator.
                //
                if (KsAllocator->KsGetAllocatorMode() != KsAllocatorMode_User) {
                    ULONG   numPins = 0;
                    ComputeNumPinsInPipe( KsPin, PinType, &numPins );
                    if (numPins > 1) {
                        RemovePinFromPipe( KsPin, PinType );
                    }
                    else {
                        KsPinPipe->KsSetPipe( NULL );
                        KsPin->KsReceiveAllocator( NULL );
                    }
                }
            }
        }
        else {
            GetInterfacePointerNoLockWithAssert(ConnectedPin, __uuidof(IKsPin), ConnectedKsPin, hr);

            //
            // Connected pin is a kernel-mode pin.
            //
            if (PinType == Pin_Output) {
                //
                // Otherwise: the pipe has been already split when we processed the disconnect
                // on the output pin.
                // So, we need to only take care of possible framing change on input.
                //
                //
                // Sometimes we get the disconnect when pins have not been connected yet.
                // Handle this situation gracefully for pipes by testing the pipe pointers
                // on both pins.
                //
                GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                if (KsAllocator == ConnectedKsAllocator) {
                    //
                    // Output pins disconnect operation handles the pipe splitting.
                    //
                    // Also, remember the location of the allocator handler (if exists) relative to breaking point.
                    //
                    GetAllocatorHandlerLocation(ConnectedKsPin, Pin_Input, KS_DIRECTION_ALL, NULL, NULL, &AllocatorHandlerLocation);
                    //
                    // If allocator handler pin is found, then AllocatorHandlerLocation can be either Pin_Inside_Pipe
                    // (upstream from KsPin, including KsPin)  or Pin_Outside_Pipe (downstream from KsPin).
                    //

                    //
                    // Split the pipe - creates two pipes out of the original one and destroys the original one.
                    //
                    if (!SplitPipes (KsPin, ConnectedKsPin)) {
                        hr = E_FAIL;
                    }

                    if (SUCCEEDED (hr)) {
                        //
                        // Resolve both new pipes taking into consideration original pipe's properties.
                        //
                        hr = ResolveNewPipeOnDisconnect(KsPin, Pin_Output, OrigLogicalMemoryType, OrigMemoryType, AllocatorHandlerLocation);
                    }

                    if (SUCCEEDED( hr )) {
                        //
                        // AllocatorHandlerLocation was computed relative to KsPin, so we need to reverse it
                        // for the ConnectedKsPin-based pipe.
                        //
                        if (AllocatorHandlerLocation == Pin_Outside_Pipe) {
                            AllocatorHandlerLocation = Pin_Inside_Pipe;
                        }
                        else if (AllocatorHandlerLocation == Pin_Inside_Pipe) {
                            AllocatorHandlerLocation = Pin_Outside_Pipe;
                        }

                        hr = ResolveNewPipeOnDisconnect(ConnectedKsPin, Pin_Input, OrigLogicalMemoryType, OrigMemoryType, AllocatorHandlerLocation);
                    }
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES DisconnectPins rets %x, FlagBypass=%d"), hr, *FlagBypassBaseAllocators ));

    return  hr;
}


STDMETHODIMP
ResolveNewPipeOnDisconnect(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN KS_LogicalMemoryType OldLogicalMemoryType,
    IN GUID OldMemoryType,
    IN ULONG AllocatorHandlerLocation
    )
/*++

Routine Description:

    Resolves the pipe defined by KsPin, considering original pipe memory type.

Arguments:

    KsPin -
        pin

    PinType -
        KsPin type

    OldLogicalMemoryType -
        original pipe's LogicalMemoryType

    OldMemoryType -
        original pipe's MemoryType

    AllocatorHandlerLocation -
        location of the original allocator handler relative to KsPin.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    ULONG                      FlagChange;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;
    BOOL                       IsNeedResolvePipe = 1;
    BOOL                       FlagDone = 0;


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolveNewPipeOnDisconnect entry KsPin=%x"), KsPin));

    ASSERT(KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // By default set the memory type from the original pipe.
    // It may get updated below.
    //
    AllocEx->MemoryType = OldMemoryType;
    AllocEx->LogicalMemoryType = OldLogicalMemoryType;

    //
    // Process any changes on this pin.
    //
    hr = ResolvePipeOnConnection(KsPin, PinType, TRUE, &FlagChange);

    if ( SUCCEEDED( hr ) ) {

        if (FlagChange) {
            //
            // We have solved the pipe in the function above.
            // No need to solve it again here.
            //
            IsNeedResolvePipe = 0;
        }
        else {
            //
            // Lets see if we can relax the new pipe.
            //
            if (OldLogicalMemoryType != KS_MemoryTypeDontCare) {

                if ( DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_DONT_CARE, OldMemoryType, TRUE) ) {
                    // IsNeedResolvePipe = 0;
                    FlagDone = 1;
                }
            }

            if (! FlagDone) {
                //
                // In case we had a specific memory type in the original pipe, and
                // a physical memory range, and an allocator handler pin, then only one of the two
                // new pipes will have such allocator pin.
                //
                // Handle the case when the original allocator handler resides on different pipe now.
                //
                if (AllocatorHandlerLocation != Pin_Inside_Pipe) {

                    if (OldLogicalMemoryType == KS_MemoryTypeDeviceHostMapped) {
                        //
                        // KS_MemoryTypeDeviceHostMapped means that pin knows how to allocate device memory.
                        // Since the allocator handler pin from the original pipe is not on this pipe,
                        // we try to resolve the allocator (and to relax the pipe).
                        //
                        if ( (! DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_KERNEL_PAGED, OldMemoryType, TRUE) ) &&
                             (! DoesPipePreferMemoryType(KsPin, PinType, KSMEMORY_TYPE_KERNEL_NONPAGED, OldMemoryType, TRUE) ) ) {

                            if ( OldLogicalMemoryType != KS_MemoryTypeDontCare) {
                                AssignPipeAllocatorHandler(KsPin, PinType, OldMemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
                            }
                        }
                    }
                }
            }
        }
    }


    if (SUCCEEDED (hr) && IsNeedResolvePipe) {
        hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_DEFAULT);
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolveNewPipeOnDisconnect rets %x"), hr));

    return  hr;
}


STDMETHODIMP_(BOOL)
WalkPipeAndProcess(
    IN IKsPin* RootKsPin,
    IN ULONG RootPinType,
    IN IKsPin* BreakKsPin,
    IN PWALK_PIPE_CALLBACK CallerCallback,
    IN PVOID* Param1,
    IN PVOID* Param2
    )
/*++

Routine Description:

    Walks the pipe defined by its root pin downstream.

    Because of possible multiple read-only downstream connections, the pipe can be
    generally represented as a tree.

    This routine walks the pipe layer by layer downstream starting with RootKsPin.
    For each new pin found, the supplied CallerCallback is called passing thru the
    supplied Param1 and Param2.

    CallerCallback may return IsDone=1, indicating that the walking process should
    immediately stop.

    If CallerCallback never sets IsDone=1, then the tree walking process is continued
    until all the pins on this pipe are processed.

    If BreakKsPin is not NULL, then BreakKsPin and all the downstream pins starting at
    BreakKsPin are not enumerated.
    This is used when we want to split RootKsPin-tree at BreakKsPin point.

    NOTE: It is possible to change the algorithm to use the search handles, and do something
    like FindFirstPin/FindNextPin - but it is more complex and less efficient. On the other hand,
    it is more generic.

Arguments:

    RootKsPin -
        root pin for the pipe.

    RootPinType -
        root pin type.

    BreakKsPin -
        break pin for the pipe.

    CallerCallback -
        defined above.

    Param1 -
        first parameter for CallerCallback

    Param2 -
        last parameter for CallerCallback


Return Value:

    TRUE on success.

--*/
{


#define INCREMENT_PINS  25

    IKsPin**            InputList;
    IKsPin**            OutputList = NULL;
    IKsPin**            TempList;
    IKsPin*             InputKsPin;
    ULONG               CountInputList = 0;
    ULONG               AllocInputList = INCREMENT_PINS;
    ULONG               CountOutputList = 0;
    ULONG               AllocOutputList = INCREMENT_PINS;
    ULONG               CurrentPinType;
    ULONG               i, j, Count;
    BOOL                RetCode = TRUE;
    BOOL                IsDone = FALSE;
    HRESULT             hr;
    IKsAllocatorEx*     KsAllocator;
    IKsPinPipe*         KsPinPipe;
    BOOL                IsBreakKsPinHandled;



    if (BreakKsPin) {
        IsBreakKsPinHandled = 0;
    }
    else {
        IsBreakKsPinHandled = 1;
    }

    //
    // allocate minimum memory for both input and output lists.
    //

    InputList = new IKsPin*[ INCREMENT_PINS ];
    if (! InputList) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList") ));
        RetCode = FALSE;
    }
    else {
        OutputList = new IKsPin*[ INCREMENT_PINS ];
        if (! OutputList) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList") ));
            RetCode = FALSE;
        }
    }

    if (RetCode) {
        //
        // get the pipe pointer from RootKsPin as a search key for all downstream pins.
        //
        GetInterfacePointerNoLockWithAssert(RootKsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

        //
        // depending on the root pin type, prepare the lists and counts to enter the main tree walking loop.
        //
        if (RootPinType == Pin_Input) {
            InputList[0] = RootKsPin;
            CountInputList = 1;
        }
        else {
            //
            // there could be multiple output pins at the same level with this root pin.
            //
            if (! FindConnectedPinOnPipe(RootKsPin, KsAllocator, TRUE, &InputKsPin) ) {
                OutputList[0] = RootKsPin;
                CountOutputList = 1;
            }
            else {
                //
                // first - get the count of connected output pins.
                //
                if (! (RetCode = FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, NULL, &Count) ) ) {
                    ASSERT(0);
                }
                else {
                    if (Count > AllocOutputList) {
                        AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                        delete [] OutputList;

                        OutputList = new IKsPin*[ AllocOutputList ];
                        if (! OutputList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                    AllocOutputList ));

                            RetCode = FALSE;
                        }
                    }

                    if (RetCode) {
                        //
                        // fill the pins.
                        //
                        if (! FindAllConnectedPinsOnPipe(InputKsPin, KsAllocator, &OutputList[0], &Count) ) {
                            ASSERT(0);
                            RetCode = FALSE;
                        }

                        CountOutputList = Count;
                    }
                }
            }
        }

        if (RetCode) {
            CurrentPinType = RootPinType;

            //
            // main tree walking loop.
            //
            do {
                if (CurrentPinType == Pin_Input) {
                    //
                    // remove the BreakKsPin from the InputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountInputList; i++) {
                            if (InputList[i] == BreakKsPin) {
                                for (j=i; j<CountInputList-1; j++) {
                                    InputList[j] = InputList[j+1];
                                }
                                CountInputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    //
                    // process current layer.
                    //
                    if (CountInputList) {
                        for (i=0; i<CountInputList; i++) {
                            RetCode = CallerCallback( InputList[i], Pin_Input, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountOutputList = 0;

                        for (i=0; i<CountInputList; i++) {

                            if (FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, NULL, &Count) ) {

                                Count += CountOutputList;

                                if (Count > AllocOutputList) {
                                    AllocOutputList = ( (Count/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = OutputList;

                                    OutputList = new IKsPin*[ AllocOutputList ];
                                    if (! OutputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new OutputList %d"),
                                                AllocOutputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountOutputList) {
                                            MoveMemory(OutputList, TempList, CountOutputList * sizeof(OutputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }

                                if (! (RetCode = FindAllConnectedPinsOnPipe(InputList[i], KsAllocator, &OutputList[CountOutputList], &Count) ) ) {
                                    ASSERT(0);
                                    break;
                                }

                                CountOutputList += Count;
                            }
                        }

                        CurrentPinType = Pin_Output;
                    }
                    else {
                        break;
                    }

                }
                else { // Output
                    //
                    // remove the BreakKsPin from the OutputList if found.
                    //
                    if (! IsBreakKsPinHandled) {
                        for (i=0; i<CountOutputList; i++) {
                            if (OutputList[i] == BreakKsPin) {
                                for (j=i; j<CountOutputList-1; j++) {
                                    OutputList[j] = OutputList[j+1];
                                }
                                CountOutputList--;
                                IsBreakKsPinHandled = 1;
                                break;
                            }
                        }
                    }

                    if (CountOutputList) {
                        for (i=0; i<CountOutputList; i++) {
                            RetCode = CallerCallback( OutputList[i], Pin_Output, Param1, Param2, &IsDone);
                            if (IsDone) {
                                break;
                            }
                        }

                        if (IsDone) {
                            break;
                        }

                        //
                        // Build next layer
                        //
                        CountInputList = 0;

                        for (i=0; i<CountOutputList; i++) {

                            if (FindNextPinOnPipe(OutputList[i], Pin_Output, KS_DIRECTION_DOWNSTREAM, KsAllocator, FALSE, &InputKsPin) ) {

                                InputList[CountInputList] = InputKsPin;

                                CountInputList++;
                                if (CountInputList >= AllocInputList) {
                                    AllocInputList = ( (CountInputList/INCREMENT_PINS) + 1) * INCREMENT_PINS;
                                    TempList = InputList;

                                    InputList = new IKsPin*[ AllocInputList ];
                                    if (! InputList) {
                                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR WalkPipeAndProcess E_OUTOFMEMORY on new InputList %d"),
                                                AllocInputList ));

                                        RetCode = FALSE;
                                        break;
                                    }

                                    if (TempList) {
                                        if (CountInputList) {
                                            MoveMemory(InputList, TempList,  CountInputList * sizeof(InputList[0]));
                                        }
                                        delete [] TempList;
                                    }
                                }
                            }
                        }

                        CurrentPinType = Pin_Input;
                    }
                    else {
                        break;
                    }
                }

            } while (RetCode);
        }
    }


    //
    // Possible to use IsDone in future.
    //

    if (InputList) {
        delete [] InputList;
    }

    if (OutputList) {
        delete [] OutputList;
    }


    return RetCode;

}

//
// common pipe utilities
//

STDMETHODIMP
CreatePipe(
    IN  IKsPin* KsPin,
    OUT IKsAllocatorEx** KsAllocator
    )
/*++

Routine Description:

    Creates the pipe (CKsAllocator object).

Arguments:

    KsPin -
        pin, to create a pipe on.

    KsAllocator -
        returns interface pointer to new pipe.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    CKsAllocator*    pKsAllocator;
    IPin*            Pin;
    HRESULT          hr;



    ASSERT (KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

    //
    // Create the allocator proxy
    //
    if (NULL ==
            (pKsAllocator =
                new CKsAllocator(
                    NAME("CKsAllocator"),
                    NULL,
                    Pin,
                    NULL,
                    &hr ))) {

        hr = E_OUTOFMEMORY;
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR CreatePipe E_OUTOFMEMORY on new CKsAllocator ") ));
    }
    else if (FAILED( hr )) {
        delete pKsAllocator;
    }
    else {
        //
        // Get a referenced IKsAllocatorEx
        //
        hr = pKsAllocator->QueryInterface( __uuidof(IKsAllocatorEx), reinterpret_cast<PVOID*>(KsAllocator) );
    }


    if (FAILED( hr )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR CreatePipe rets hr=%x"), hr ));
    }
    else {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipe rets KsAllocator=%x, hr=%x"), *KsAllocator, hr ));
    }

    return hr;
}


STDMETHODIMP
InitializePipeTermination(
    IN PIPE_TERMINATION* Termin,
    IN BOOL Reset
    )
/*++

Routine Description:

    Initializes termination point of the pipe.

Arguments:

    Termin -
        pipe termination

    Reset -
        1 - if pipe termination has been initialized already.
        0 - else.


Return Value:

    S_OK or an appropriate error code.

--*/
{


    Termin->PhysicalRange.MinFrameSize = 0;
    Termin->PhysicalRange.MaxFrameSize = ULONG_MAX;
    Termin->PhysicalRange.Stepping = DEFAULT_STEPPING;

    Termin->OptimalRange.Range.MinFrameSize = 0;
    Termin->OptimalRange.Range.MaxFrameSize = ULONG_MAX;
    Termin->OptimalRange.Range.Stepping = DEFAULT_STEPPING;



    Termin->Compression.RatioNumerator = 1;
    Termin->Compression.RatioDenominator = 1;
    Termin->Compression.RatioConstantMargin = 0;

    Termin->OutsideFactors = PipeFactor_None;

    Termin->Flags = 0;

    return S_OK;
}


STDMETHODIMP
InitializePipe(
    IN IKsAllocatorEx* KsAllocator,
    IN BOOL Reset
    )
/*++

Routine Description:

    Initializes the pipe.

Arguments:

    KsAllocator -
        pipe

    Reset -
        1 - if this pipe has been initialized already.
        0 - else.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;



    ASSERT (KsAllocator);

    //
    // in place properties modification.
    //
    AllocEx = KsAllocator->KsGetProperties();

    AllocEx->cBuffers = 0;
    AllocEx->cbBuffer = 0;
    AllocEx->cbAlign  = 0;
    AllocEx->cbPrefix = 0;

    AllocEx->State = PipeState_DontCare;

    if ( SUCCEEDED(hr = InitializePipeTermination( &AllocEx->Input, Reset) ) &&
         SUCCEEDED(hr = InitializePipeTermination( &AllocEx->Output, Reset) ) ) {

        AllocEx->Strategy = 0;

        AllocEx->Flags = KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
        AllocEx->Weight = 0;

        AllocEx->MemoryType = KSMEMORY_TYPE_DONT_CARE;
        AllocEx->BusType = GUID_NULL;
        AllocEx->LogicalMemoryType = KS_MemoryTypeDontCare;
        AllocEx->AllocatorPlace = Pipe_Allocator_None;

        SetDefaultDimensions(&AllocEx->Dimensions);

        AllocEx->PhysicalRange.MinFrameSize = 0;
        AllocEx->PhysicalRange.MaxFrameSize = ULONG_MAX;
        AllocEx->PhysicalRange.Stepping = DEFAULT_STEPPING;


        AllocEx->PrevSegment = NULL;
        AllocEx->CountNextSegments = 0;
        AllocEx->NextSegments = NULL;


        AllocEx->InsideFactors = PipeFactor_None;

        AllocEx->NumberPins = 1;

    }

    return hr;
}


STDMETHODIMP_(BOOL)
CreatePipeForTwoPins(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID ConnectBus,
    IN GUID MemoryType
    )
/*++

Routine Description:

    Creates a pipe connecting two pins.
    The bus and memory type for the new pipe have been decided by the caller.

Arguments:

    InKsPin -
        input pin.

    OutKsPin -
        output pin.

    ConnectBus -
        bus that connects the pins above.

    MemoryType -
        memory type that the pipe will use.

Return Value:

    TRUE

--*/
{
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    IKsAllocatorEx*            KsAllocator;
    IMemAllocator*             MemAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipeForTwoPins entry InKsPin=%x, OutKsPin=%x"),
            InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    if ( SUCCEEDED( hr = CreatePipe(OutKsPin, &KsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(KsAllocator, 0) ) ) {

        GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

        if (! OutKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
            OutKsPin->KsReceiveAllocator(MemAllocator);
        }
        else {
            ASSERT(0);
        }

        OutKsPinPipe->KsSetPipe(KsAllocator);

        if (! InKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly) ) {
            InKsPin->KsReceiveAllocator(MemAllocator);
        }
        else {
            ASSERT(0);
        }

        InKsPinPipe->KsSetPipe(KsAllocator);

        AllocEx = KsAllocator->KsGetProperties();

        AllocEx->BusType = ConnectBus;
        AllocEx->MemoryType = MemoryType;

        if (! IsHostSystemBus(ConnectBus) ) {
            //
            // Set the LogicalMemoryType for non-host-system buses.
            //
            AllocEx->LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
        }
        else {
            GetLogicalMemoryTypeFromMemoryType(MemoryType, KSALLOCATOR_FLAG_DEVICE_SPECIFIC, &AllocEx->LogicalMemoryType);
        }

        AllocEx->NumberPins = 2;

        //
        // Set the pipe allocator handling pin.
        //
        AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

        //
        // Resolve the pipe.
        //
        hr = ResolvePipeDimensions(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT);

        KsAllocator->Release();
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreatePipeForTwoPins rets. %x"), hr ));

    if ( SUCCEEDED(hr) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
GetPinFramingFromCache(
    IN IKsPin* KsPin,
    OUT PKSALLOCATOR_FRAMING_EX* FramingEx,
    OUT PFRAMING_PROP FramingProp,
    IN FRAMING_CACHE_OPS Option
    )
/*++

Routine Description:

    Reads pin framing from pin cache.

    If framing has not been read yet, or if Option = Framing_Cache_Update,
    then this routine will update the pin framing cache.

Arguments:

    KsPin -
        pin.

    FramingEx -
        pin framing pointer returned

    FramingProp -
        pin framing type returned

    Option -
        one of the FRAMING_CACHE_OPS.

Return Value:

    TRUE on success.

--*/
{
    HANDLE                   PinHandle;
    HRESULT                  hr;
    IKsObject*               KsObject;
    KSALLOCATOR_FRAMING      Framing;
    IKsPinPipe*              KsPinPipe;
    BOOL                     RetCode = TRUE;


    ASSERT (KsPin);
    ASSERT( Option >= Framing_Cache_Update );
    ASSERT( Option <= Framing_Cache_Write );

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (Option != Framing_Cache_Update) {
        //
        // forward request to the pin cache directly
        //
        /* Could check return value here, but Option check above currently guarantees this will succeed. */
        KsPinPipe->KsGetPinFramingCache(FramingEx, FramingProp, Option);
    }

    if ( (Option == Framing_Cache_Update) ||
         ( (*FramingProp == FramingProp_Uninitialized) && (Option != Framing_Cache_Write) ) )  {
        //
        // need to query the driver (pin)
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

        PinHandle = KsObject->KsGetObjectHandle();

        //
        // try to get FramingEx first
        //
        hr = GetAllocatorFramingEx(PinHandle, FramingEx);
        if (! SUCCEEDED( hr )) {
            //
            // pin doesn't support FramingEx. Lets try getting simple Framing.
            //
            hr = GetAllocatorFraming(PinHandle, &Framing);
            if (! SUCCEEDED( hr )) {
                //
                // pin doesn't support any framing properties.
                //
                *FramingProp = FramingProp_None;

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) - FramingProp_None"),
                    KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName() ));
            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) FramingProp_Old %d %d %d %x %d"),
                    KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName(),
                    Framing.Frames, Framing.FrameSize, Framing.FileAlignment, Framing.OptionsFlags, Framing.PoolType));

                *FramingProp = FramingProp_Old;

                if ( ! ( (*FramingEx) = new (KSALLOCATOR_FRAMING_EX) ) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR GetPinFramingFromCache %s(%s) out of memory."),
                        KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName() ));

                    RetCode = FALSE;
                }
                else {
                    GetFramingExFromFraming(*FramingEx, &Framing);
                }
            }
        }
        else {
            *FramingProp = FramingProp_Ex;

            SetDefaultFramingExItems(*FramingEx);

            DbgLog((LOG_MEMORY, 2, TEXT("PIPES GetPinFramingFromCache %s(%s) - FramingProp_Ex %d %d %d %x, %d"),
                KsPinPipe->KsGetFilterName(), KsPinPipe->KsGetPinName(),
                (*FramingEx)->FramingItem[0].Frames,  (*FramingEx)->FramingItem[0].FramingRange.Range.MaxFrameSize,
                (*FramingEx)->FramingItem[0].FileAlignment, (*FramingEx)->FramingItem[0].Flags, (*FramingEx)->CountItems));
        }

        if (RetCode) {
            if ( *FramingProp != FramingProp_None ) {
                ::ValidateFramingEx(*FramingEx);
            }

            if (Option != Framing_Cache_Update) {
                //
                // in case FramingProp was Uninitialized - we need to update both _ReadOrig and _ReadLast cache fields.
                //
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadOrig);
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadLast);
            }
            else {
                //
                // update the _ReadLast cache field on Update request
                //
                KsPinPipe->KsSetPinFramingCache(*FramingEx, FramingProp, Framing_Cache_ReadLast);
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetFramingExFromFraming(
    OUT KSALLOCATOR_FRAMING_EX* FramingEx,
    IN KSALLOCATOR_FRAMING* Framing
    )
/*++

Routine Description:

    Converts from KSALLOCATOR_FRAMING to KSALLOCATOR_FRAMING_EX.

Arguments:

    FramingEx -
        resulting KSALLOCATOR_FRAMING_EX.

    Framing -
        original KSALLOCATOR_FRAMING.


Return Value:

    TRUE on success.

--*/
{

    FramingEx->PinFlags = 0;
    FramingEx->PinWeight = KS_PINWEIGHT_DEFAULT;
    FramingEx->CountItems = 1;

    if (Framing->RequirementsFlags & KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY) {
        if (Framing->PoolType == PagedPool) {
            FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_KERNEL_PAGED;
        }
        else {
            FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_KERNEL_NONPAGED;
        }
    }
    else {
        //
        // device memory
        //
        // don't set KSALLOCATOR_FLAG_DEVICE_SPECIFIC flag
        //
        FramingEx->FramingItem[0].MemoryType = KSMEMORY_TYPE_DEVICE_UNKNOWN;
    }

    FramingEx->FramingItem[0].MemoryFlags = Framing->OptionsFlags;

    FramingEx->FramingItem[0].BusType = GUID_NULL;
    FramingEx->FramingItem[0].BusFlags = 0;

    FramingEx->FramingItem[0].Flags = Framing->OptionsFlags | KSALLOCATOR_FLAG_CAN_ALLOCATE | KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

    FramingEx->FramingItem[0].Frames = Framing->Frames;
    FramingEx->FramingItem[0].FileAlignment = Framing->FileAlignment;

    SetDefaultRange(&FramingEx->FramingItem[0].PhysicalRange);
    SetDefaultCompression(&FramingEx->OutputCompression);

    FramingEx->FramingItem[0].MemoryTypeWeight = KS_MEMORYWEIGHT_DEFAULT;

    FramingEx->FramingItem[0].FramingRange.Range.MinFrameSize  = Framing->FrameSize;
    FramingEx->FramingItem[0].FramingRange.Range.MaxFrameSize  = Framing->FrameSize;
    FramingEx->FramingItem[0].FramingRange.Range.Stepping  = DEFAULT_STEPPING;
    FramingEx->FramingItem[0].FramingRange.InPlaceWeight = 0;
    FramingEx->FramingItem[0].FramingRange.NotInPlaceWeight = 0;

    return TRUE;
}


STDMETHODIMP_(VOID)
GetFramingFromFramingEx(
    IN KSALLOCATOR_FRAMING_EX* FramingEx,
    OUT KSALLOCATOR_FRAMING* Framing
    )
/*++

Routine Description:

    Converts from KSALLOCATOR_FRAMING_EX to KSALLOCATOR_FRAMING


Arguments:

    FramingEx -
        original KSALLOCATOR_FRAMING_EX.

    Framing -
        resulting KSALLOCATOR_FRAMING.


Return Value:

    NONE.

--*/
{
    //
    // This should not be called in the intermediate model.
    //
    ASSERT(0);

}


STDMETHODIMP_(VOID)
ValidateFramingRange(
    IN OUT PKS_FRAMING_RANGE    Range
    )
{
    if ( ( Range->MinFrameSize == ULONG_MAX ) || ( Range->MinFrameSize > Range->MaxFrameSize ) ) {
        Range->MinFrameSize = 0;
    }

    if ( Range->MinFrameSize == 0 ) {
        if ( Range->MaxFrameSize == 0 ) {
            Range->MaxFrameSize = ULONG_MAX;
        }
    }
    else if ( ( Range->MaxFrameSize == 0 ) || ( Range->MaxFrameSize == ULONG_MAX ) ) {
        Range->MaxFrameSize = Range->MinFrameSize;
    }
}


STDMETHODIMP_(VOID)
ValidateFramingEx(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    )
{
    ULONG   i;

    for (i=0; i<FramingEx->CountItems; i++) {
        ValidateFramingRange(&FramingEx->FramingItem[i].FramingRange.Range);
        ValidateFramingRange(&FramingEx->FramingItem[i].PhysicalRange);

        if (! IsFramingRangeDontCare(FramingEx->FramingItem[i].PhysicalRange) ) {
            FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize =
                max( FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize,
                     FramingEx->FramingItem[i].PhysicalRange.MinFrameSize );

            FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize =
                min( FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize,
                     FramingEx->FramingItem[i].PhysicalRange.MaxFrameSize );

            if ( FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize >
                 FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize ) {

                FramingEx->FramingItem[i].FramingRange.Range.MinFrameSize =
                    FramingEx->FramingItem[i].FramingRange.Range.MaxFrameSize;
            }

            if (FramingEx->FramingItem[i].FramingRange.InPlaceWeight == 0) {
                FramingEx->FramingItem[i].FramingRange.InPlaceWeight = 1;
            }
        }
    }
}


STDMETHODIMP_(VOID)
SetDefaultFramingExItems(
    IN OUT PKSALLOCATOR_FRAMING_EX  FramingEx
    )
{
    ULONG   i;

    for (i=0; i<FramingEx->CountItems; i++) {
        if (CanAllocateMemoryType (FramingEx->FramingItem[i].MemoryType) ) {
            FramingEx->FramingItem[i].Flags |= KSALLOCATOR_FLAG_CAN_ALLOCATE;
        }
    }
}


STDMETHODIMP_(BOOL)
SetDefaultRange(
    OUT PKS_FRAMING_RANGE  Range
)
{
    Range->MinFrameSize = 0;
    Range->MaxFrameSize = ULONG_MAX;
    Range->Stepping = DEFAULT_STEPPING;

    return TRUE;
}


STDMETHODIMP_(BOOL)
SetDefaultRangeWeighted(
    OUT PKS_FRAMING_RANGE_WEIGHTED  RangeWeighted
)
{
    SetDefaultRange(&RangeWeighted->Range);
    RangeWeighted->InPlaceWeight = 0;
    RangeWeighted->NotInPlaceWeight = 0;

    return TRUE;
}


STDMETHODIMP_(BOOL)
SetDefaultCompression(
    OUT PKS_COMPRESSION Compression
)
{
    Compression->RatioNumerator = 1;
    Compression->RatioDenominator = 1;
    Compression->RatioConstantMargin = 0;

    return TRUE;
}


STDMETHODIMP_(BOOL)
IsFramingRangeDontCare(
    IN KS_FRAMING_RANGE Range
)

{
    if ( (Range.MinFrameSize == 0) &&
         (Range.MaxFrameSize == ULONG_MAX) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsFramingRangeEqual(
    IN KS_FRAMING_RANGE* Range1,
    IN KS_FRAMING_RANGE* Range2
)

{
    if ( (Range1->MinFrameSize == Range2->MinFrameSize) &&
         (Range1->MaxFrameSize == Range2->MaxFrameSize) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsCompressionDontCare(
    IN KS_COMPRESSION Compression
)

{
    if ( (Compression.RatioNumerator == 1) && (Compression.RatioDenominator == 1) && (Compression.RatioConstantMargin == 0) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsCompressionEqual(
    IN KS_COMPRESSION* Compression1,
    IN KS_COMPRESSION* Compression2
)

{
    if ( (Compression1->RatioNumerator == Compression2->RatioNumerator) &&
         (Compression1->RatioDenominator == Compression2->RatioDenominator) &&
         (Compression1->RatioConstantMargin == Compression2->RatioConstantMargin) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
ComputeRangeBasedOnCompression(
    IN KS_FRAMING_RANGE From,
    IN KS_COMPRESSION Compression,
    OUT KS_FRAMING_RANGE* To
)

{
    ComputeUlongBasedOnCompression(From.MinFrameSize, Compression, &To->MinFrameSize);
    ComputeUlongBasedOnCompression(From.MaxFrameSize, Compression, &To->MaxFrameSize);
    To->Stepping = From.Stepping;

    return TRUE;
}


STDMETHODIMP_(BOOL)
ComputeUlongBasedOnCompression(
    IN  ULONG From,
    IN  KS_COMPRESSION Compression,
    OUT ULONG* To
    )
{


    if ( (Compression.RatioNumerator == ULONG_MAX) || (From == ULONG_MAX) ) {
        *To = ULONG_MAX;
    }
    else {
        if (Compression.RatioDenominator == 0) {
            ASSERT(0);
            return FALSE;
        }

        *To = (ULONG) (From * Compression.RatioNumerator / Compression.RatioDenominator);
    }

    return TRUE;

}


STDMETHODIMP_(BOOL)
ReverseCompression(
    IN  KS_COMPRESSION* From,
    OUT KS_COMPRESSION* To
    )

{

    To->RatioNumerator = From->RatioDenominator;
    To->RatioDenominator = From->RatioNumerator;
    To->RatioConstantMargin = From->RatioConstantMargin;

    return TRUE;


}


STDMETHODIMP_(BOOL)
MultiplyKsCompression(
    IN  KS_COMPRESSION C1,
    IN  KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
)

{

    Res->RatioNumerator = (ULONG) (C1.RatioNumerator * C2.RatioNumerator);
    Res->RatioDenominator = (ULONG) (C1.RatioDenominator * C2.RatioDenominator);
    Res->RatioConstantMargin = 0;

    return TRUE;

}


STDMETHODIMP_(BOOL)
DivideKsCompression(
    IN  KS_COMPRESSION C1,
    IN  KS_COMPRESSION C2,
    OUT KS_COMPRESSION* Res
)

{

    Res->RatioNumerator = (ULONG) (C1.RatioNumerator * C2.RatioDenominator);
    Res->RatioDenominator = (ULONG) (C1.RatioDenominator * C2.RatioNumerator);
    Res->RatioConstantMargin = 0;

    return TRUE;

}


STDMETHODIMP_(BOOL)
IsGreaterKsExpansion(
    IN KS_COMPRESSION C1,
    IN KS_COMPRESSION C2
)

{
    ASSERT(C1.RatioDenominator && C2.RatioDenominator);

    if (! (C1.RatioDenominator && C2.RatioDenominator) ) {
        return FALSE;
    }

    if ( (C1.RatioNumerator / C1.RatioDenominator) >= (C2.RatioNumerator / C2.RatioDenominator) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IsKsExpansion(
    IN KS_COMPRESSION C
)

{
    if (C.RatioNumerator > C.RatioDenominator) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
IntersectFrameAlignment(
    IN ULONG In,
    IN ULONG Out,
    OUT LONG* Result
)

{


    return TRUE;

}


STDMETHODIMP_(BOOL)
FrameRangeIntersection(
    IN KS_FRAMING_RANGE In,
    IN KS_FRAMING_RANGE Out,
    OUT PKS_FRAMING_RANGE Result,
    OUT PKS_OBJECTS_INTERSECTION Intersect
    )

{

    Result->MinFrameSize = max(In.MinFrameSize, Out.MinFrameSize);
    Result->MaxFrameSize = min(In.MaxFrameSize, Out.MaxFrameSize);
    Result->Stepping = max(In.Stepping, Out.Stepping);

    if (Result->MinFrameSize > Result->MaxFrameSize) {
        *Intersect = NO_INTERSECTION;
        return FALSE;
    }

    if ( (Result->MinFrameSize == In.MinFrameSize) && (Result->MaxFrameSize == In.MaxFrameSize) ) {
        if ( (Result->MinFrameSize == Out.MinFrameSize) && (Result->MaxFrameSize == Out.MaxFrameSize) ) {
            *Intersect = NONE_OBJECT_DIFFERENT;
        }
        else {
            *Intersect = OUT_OBJECT_DIFFERENT;
        }
    }
    else {
        if ( (Result->MinFrameSize == Out.MinFrameSize) && (Result->MaxFrameSize == Out.MaxFrameSize) ) {
            *Intersect = IN_OBJECT_DIFFERENT;
        }
        else {
            *Intersect = BOTH_OBJECT_DIFFERENT;
        }
    }



    return TRUE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingEx(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    OUT PKS_FRAMING_FIXED FramingExFixed
    )
{

    FramingExFixed->CountItems = FramingEx->CountItems;
    FramingExFixed->PinFlags = FramingEx->PinFlags;
    FramingExFixed->OutputCompression = FramingEx->OutputCompression;
    FramingExFixed->PinWeight = FramingEx->PinWeight;

    FramingExFixed->MemoryType = FramingEx->FramingItem[0].MemoryType;
    FramingExFixed->MemoryFlags = FramingEx->FramingItem[0].MemoryFlags;

    GetLogicalMemoryTypeFromMemoryType(
        FramingExFixed->MemoryType,
        FramingExFixed->MemoryFlags,
        &FramingExFixed->LogicalMemoryType
        );

    FramingExFixed->BusType = FramingEx->FramingItem[0].BusType;
    FramingExFixed->BusFlags = FramingEx->FramingItem[0].BusFlags;
    FramingExFixed->Flags = FramingEx->FramingItem[0].Flags;
    FramingExFixed->Frames = FramingEx->FramingItem[0].Frames;
    FramingExFixed->FileAlignment = FramingEx->FramingItem[0].FileAlignment;
    FramingExFixed->PhysicalRange = FramingEx->FramingItem[0].PhysicalRange;
    FramingExFixed->MemoryTypeWeight = FramingEx->FramingItem[0].MemoryTypeWeight;
    FramingExFixed->OptimalRange = FramingEx->FramingItem[0].FramingRange;

    return TRUE;
}


STDMETHODIMP_(BOOL)
ComputeChangeInFraming(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    OUT ULONG* FramingDelta
    )
/*++

Routine Description:

    This routine checks to see if pin's framing properties, corresponding
    to MemoryType, have changed. If so, this routine returns the bitmap,
    indicating which framing properties have changed.


Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

    MemoryType -
        memory type.

    FramingDelta -
        bitmap indicating which framing properties have changed.

Return Value:

    TRUE on SUCCESS

--*/

{
    PKSALLOCATOR_FRAMING_EX  OrigFramingEx = NULL, LastFramingEx = NULL;
    FRAMING_PROP             OrigFramingProp, LastFramingProp;
    KS_FRAMING_FIXED         OrigFramingExFixed, LastFramingExFixed;
    IKsPinPipe*              KsPinPipe;
    HRESULT                  hr;
    BOOL                     retCode;


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    *FramingDelta = 0;

    //
    // Get the pin framing from Cache.
    //
    retCode = GetPinFramingFromCache(KsPin, &OrigFramingEx, &OrigFramingProp, Framing_Cache_ReadOrig);
    if (!retCode) {
        return FALSE;
    }

    //
    // Get the pin framing from driver, bypassing and updating Cache.
    //
    retCode = GetPinFramingFromCache(KsPin, &LastFramingEx, &LastFramingProp, Framing_Cache_Update);
    if (!retCode) {
        return FALSE;
    }

    if (OrigFramingProp == FramingProp_None) {
        if  (LastFramingProp != FramingProp_None) {
            //
            // First we try to get the pin framing entry that corresponds to pipe MemoryType.
            //
            if (! GetFramingFixedFromFramingByMemoryType(LastFramingEx, MemoryType, &LastFramingExFixed) ) {
                //
                // There is no MemoryType corresponding entry, so we get the first entry.
                //
                (*FramingDelta) |= KS_FramingChangeMemoryType;

                GetFramingFixedFromFramingByIndex(LastFramingEx, 0, &LastFramingExFixed);
            }

            if (LastFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) && (! IsCompressionDontCare(LastFramingExFixed.OutputCompression)) ) {
                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeDontCare(LastFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeDontCare(LastFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
    }
    else {
        if  (LastFramingProp == FramingProp_None) {
            //
            // First we try to get the pin framing entry that corresponds to pipe MemoryType.
            //
            ASSERT( NULL != OrigFramingEx );
            if (! GetFramingFixedFromFramingByMemoryType(OrigFramingEx, MemoryType, &OrigFramingExFixed) ) {
                //
                // There is no MemoryType corresponding entry, so we get the first entry.
                //
                (*FramingDelta) |= KS_FramingChangeMemoryType;

                GetFramingFixedFromFramingByIndex(OrigFramingEx, 0, &OrigFramingExFixed);
            }

            if (OrigFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) && (! IsCompressionDontCare(OrigFramingExFixed.OutputCompression)) ) {
                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeDontCare(OrigFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeDontCare(OrigFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
        else {
            //
            // Framing always existed on this pin.
            // See if it had changed.
            //
            ASSERT( NULL != OrigFramingEx );
            if (! GetFramingFixedFromFramingByMemoryType(OrigFramingEx, MemoryType, &OrigFramingExFixed) ) {
                GetFramingFixedFromFramingByIndex(OrigFramingEx, 0, &OrigFramingExFixed);
            }

            if (! GetFramingFixedFromFramingByMemoryType(LastFramingEx, MemoryType, &LastFramingExFixed) ) {
                GetFramingFixedFromFramingByIndex(LastFramingEx, 0, &LastFramingExFixed);
            }

            if (OrigFramingExFixed.MemoryType != LastFramingExFixed.MemoryType) {
                (*FramingDelta) |= KS_FramingChangeMemoryType;
            }

            if ( (OrigFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) !=
                 (LastFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {

                (*FramingDelta) |= KS_FramingChangeAllocator;
            }

            if ( (PinType != Pin_Input) &&
                 (! IsCompressionEqual(&OrigFramingExFixed.OutputCompression, &LastFramingExFixed.OutputCompression) ) ) {

                (*FramingDelta) |= KS_FramingChangeCompression;
            }

            if (! IsFramingRangeEqual(&OrigFramingExFixed.PhysicalRange, &LastFramingExFixed.PhysicalRange) ) {
                (*FramingDelta) |= KS_FramingChangePhysicalRange;
            }

            if (! IsFramingRangeEqual(&OrigFramingExFixed.OptimalRange.Range, &LastFramingExFixed.OptimalRange.Range) ) {
                (*FramingDelta) |= KS_FramingChangeOptimalRange;
            }
        }
    }

    KsPinPipe->KsSetPinFramingCache(LastFramingEx, &LastFramingProp, Framing_Cache_ReadOrig);

    return TRUE;

}


STDMETHODIMP_(BOOL)
SetDefaultDimensions(
    OUT PPIPE_DIMENSIONS Dimensions
)

{

    SetDefaultCompression(&Dimensions->AllocatorPin);
    SetDefaultCompression(&Dimensions->MaxExpansionPin);
    SetDefaultCompression(&Dimensions->EndPin);

    return TRUE;
}


STDMETHODIMP_(BOOL)
NumPinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )

{

    ULONG  NumPins = PtrToUlong(*Param1);

    NumPins++;
    (*Param1) = (PVOID) UIntToPtr(NumPins);

    return TRUE;

}


STDMETHODIMP_(BOOL)
ComputeNumPinsInPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT ULONG* NumPins
)

{

    IKsPin*   FirstKsPin;
    ULONG     FirstPinType;
    BOOL      RetCode = TRUE;

    *NumPins = 0;

    RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, NumPinsCallback, (PVOID*) NumPins, NULL);
    }
    else {
        ASSERT(RetCode);
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
CanPinUseMemoryType(
    IN IKsPin* KsPin,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType
    )

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    BOOL                       RetCode = TRUE;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        if (LogicalMemoryType == KS_MemoryTypeDeviceSpecific) {
            RetCode = FALSE;
        }
    }
    else if (LogicalMemoryType == KS_MemoryTypeDeviceSpecific) {
        RetCode = GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, NULL);
    }
    else {
        if (! ( GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, NULL) ||
              (MemoryType == KSMEMORY_TYPE_DONT_CARE) ||
              (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ) ) {

            RetCode = FALSE;
        }
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
MemoryTypeCallback(
    IN  IKsPin* KsPin,
    IN  ULONG PinType,
    IN  PVOID* Param1,
    IN  PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    GUID                    MemoryType;
    KS_LogicalMemoryType    LogicalMemoryType;
    BOOL                    RetCode;


    memcpy(&MemoryType, Param1, sizeof(GUID) );
    memcpy(&LogicalMemoryType, Param2, sizeof(KS_LogicalMemoryType) );

    RetCode = CanPinUseMemoryType(KsPin, MemoryType, LogicalMemoryType);

    if (! RetCode ) {
        *IsDone = 1;
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
CanPipeUseMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN KS_LogicalMemoryType LogicalMemoryType,
    IN ULONG FlagModify,
    IN ULONG QuickTest
    )
/*++

Routine Description:

    Assumed that there is a pin capable of allocating MemoryType somewhere,
    (true for all current callers), so in case of device memory (either
    bus-specific or host-mapped) we don't test whether KsPin-pipe knows how
    to allocate device memory.

    Also, none of the current callers tries to force any "host-accessible"
    memory on the device-specific pipe.

    Was BUG-BUG: Later - to generalize this function by handling cases above.
    Not important for the intermediate model.

    SOLUTION:

    If MemoryType is "device specific" memory type, then we require that
    each pin in KsPin-pipe should explicitly support this device memory
    type GUID in its framing properties.

    For any other memory types (host-accessible):
    If there is a pin in KsPin-pipe with framing properties that do not list
    either MemoryType GUID or "wildcard" - then such a pipe doesn't support
    MemoryType.

    In any other case - KsPin-pipe can support MemoryType.


Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    MemoryType -
        memory type to test.

    LogicalMemoryType -
        logical memory type, corresponding to MemoryType above.

    FlagModify -
        if 1 - then modify KsPin's pipe properties to use the MemoryType.
        if 0 - don't change the pipe.

    QuickTest -
        if 1 - then KsPin points to resolved pipe, so quick pipe-wide test is possible.

Return Value:

    TRUE - if pipe can use given memory type.

--*/
{

    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    BOOL                       RetCode = FALSE;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;


    //
    // Handle QuickTest case first.
    //
    if (QuickTest) {
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
        AllocEx = KsAllocator->KsGetProperties();

        if ( (AllocEx->LogicalMemoryType == LogicalMemoryType) ||
             ( (AllocEx->LogicalMemoryType == KS_MemoryTypeKernelPaged) && (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ) ) {

            RetCode = TRUE;
        }
    }

    if (! RetCode) {
        //
        // A pipe can use MemoryType if every pin can use this MemoryType.
        //
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);

        if (RetCode) {
            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, MemoryTypeCallback, (PVOID*) &MemoryType, (PVOID*) &LogicalMemoryType);
        }
        else {
            ASSERT(RetCode);
        }
    }

    //
    // Change pipe's memory type if requested.
    //
    if (RetCode && FlagModify) {
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
        AllocEx = KsAllocator->KsGetProperties();

        AllocEx->MemoryType = MemoryType;
        AllocEx->LogicalMemoryType = LogicalMemoryType;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanPipeUseMemoryType rets %d"), RetCode ));

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetBusForKsPin(
    IN IKsPin* KsPin,
    OUT GUID* Bus
    )
{

    KSPIN_MEDIUM    Medium;
    HRESULT         hr;


    ASSERT(KsPin);

    hr = KsPin->KsGetCurrentCommunication(NULL, NULL, &Medium);
    if (! SUCCEEDED(hr) ) {
        if (hr == VFW_E_NOT_CONNECTED) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN GetBusForKsPin: KsPin=%x not connected"), KsPin ));
        }
        else {
            ASSERT(0);
        }

        *Bus = GUID_NULL;
    }
    else {
        *Bus = Medium.Set;
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
IsHostSystemBus(
    IN GUID Bus
    )

{
    if ( (Bus == KSMEDIUMSETID_Standard) || (Bus == GUID_NULL) ) {
        return TRUE;
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
AreBusesCompatible(
    IN GUID Bus1,
    IN GUID Bus2
    )

{
    if ( (Bus1 == Bus2) ||
         ( IsHostSystemBus(Bus1) && IsHostSystemBus(Bus2) ) ) {

        return TRUE;
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
IsKernelPin(
    IN IPin* Pin
    )

{

    IKsPinPipe*  KsPinPipe;
    HRESULT      hr;



    hr = Pin->QueryInterface( __uuidof(IKsPinPipe), reinterpret_cast<PVOID*>(&KsPinPipe) );
    if (! SUCCEEDED( hr )) {
        return FALSE;
    }
    else {
        if (KsPinPipe) {
            KsPinPipe->Release();
        }
        return TRUE;
    }
}


STDMETHODIMP_(BOOL)
HadKernelPinBeenConnectedToUserPin(
    IN IKsPin* OutKsPin,
    IN IKsAllocatorEx* KsAllocator
)
/*++

Routine Description:

    Test to see if an output kernel-mode pin had been connected to a user-mode input pin.

Arguments:

    OutKsPin -
        kernel mode output pin.

    KsAllocator -
        OutKsPin's allocator.


Return Value:

    TRUE if pins had been connected.

--*/
{
    IMemAllocator*   PipeMemAllocator;
    IMemAllocator*   PinMemAllocator;
    HRESULT          hr;

    if (KsAllocator) {
        PinMemAllocator = OutKsPin->KsPeekAllocator(KsPeekOperation_PeekOnly);
        GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), PipeMemAllocator, hr);

        if ( (KsAllocator->KsGetAllocatorMode() == KsAllocatorMode_User) && (PipeMemAllocator == PinMemAllocator) ) {
            //
            // OutKsPin's pipe hosts KsProxy user-mode base allocator.
            //
            return TRUE;
        }
        else if ( (KsAllocator->KsGetAllocatorMode() != KsAllocatorMode_User) && (PipeMemAllocator != PinMemAllocator) &&
                   PinMemAllocator ) {

            return TRUE;
        }
        else {
            return FALSE;
        }
    }
    else {
        return FALSE;
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByMemoryType(
    IN  IKsPin* KsPin,
    IN  GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        return FALSE;
    }
    else {
        return (GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, FramingExFixed) );
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID MemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    ULONG                      i;
    BOOL                       RetCode = FALSE;


    for (i=0; i<FramingEx->CountItems; i++) {
        if (FramingEx->FramingItem[i].MemoryType == MemoryType) {
            if (FramingExFixed) {
                RetCode = GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed);
                break;
            }
            else {
                RetCode = TRUE;
                break;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByLogicalMemoryType(
    IN IKsPin* KsPin,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        return FALSE;
    }
    else {
        return ( GetFramingFixedFromFramingByLogicalMemoryType(FramingEx, LogicalMemoryType,FramingExFixed) );
    }
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByLogicalMemoryType(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{
    ULONG                      i;
    GUID                       MemoryType;
    BOOL                       RetCode = TRUE;


    if ( (LogicalMemoryType == KS_MemoryTypeDontCare) ||
         (LogicalMemoryType == KS_MemoryTypeKernelPaged) ||
         (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) ||
         (LogicalMemoryType == KS_MemoryTypeUser) ) {

        RetCode = GetMemoryTypeFromLogicalMemoryType(LogicalMemoryType, &MemoryType);
        ASSERT(RetCode);

        return ( GetFramingFixedFromFramingByMemoryType(FramingEx, MemoryType, FramingExFixed) );
    }

    if (LogicalMemoryType != KS_MemoryTypeAnyHost) {
        ASSERT(0);
        return FALSE;
    }

    //
    // Handle KS_MemoryTypeAnyHost.
    //
    for (i=0; i<FramingEx->CountItems; i++) {
        if ( (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_DONT_CARE) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
            (FramingEx->FramingItem[i].MemoryType == KSMEMORY_TYPE_USER) ) {

            if (FramingExFixed) {
                return ( GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed) );
            }
            else {
                return TRUE;
            }
        }
    }

    return FALSE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByBus(
    IN PKSALLOCATOR_FRAMING_EX FramingEx,
    IN GUID Bus,
    IN BOOL FlagMustReturnFraming,
    OUT PKS_FRAMING_FIXED FramingExFixed
    )
{

    ULONG   i;


    for (i=0; i<FramingEx->CountItems; i++) {
        if (FramingEx->FramingItem[i].BusType == Bus) {
            if (FramingExFixed) {
                return ( GetFramingFixedFromFramingByIndex(FramingEx, i, FramingExFixed) );
            }
            else {
                return TRUE;
            }
        }
    }

    //
    // Special case GUID_NULL for old filters.
    //
    if (Bus == GUID_NULL) {
        if (FramingExFixed) {
            GetFramingFixedFromFramingByIndex(FramingEx, 0, FramingExFixed);
        }
        return TRUE;
    }

    //
    // In case there is no framing items corresponding to given Bus, and
    // FlagMustReturnFraming is set - return first framing.
    //
    if (FlagMustReturnFraming) {
        ASSERT(FramingExFixed);
        return ( GetFramingFixedFromFramingByIndex(FramingEx, 0, FramingExFixed) );
    }

    return FALSE;
}


STDMETHODIMP_(BOOL)
GetFramingFixedFromFramingByIndex(
     IN PKSALLOCATOR_FRAMING_EX FramingEx,
     IN ULONG FramingIndex,
     OUT PKS_FRAMING_FIXED FramingExFixed
)

{

    if (FramingEx->CountItems < FramingIndex) {
        FramingExFixed = NULL;
        return FALSE;
    }

    FramingExFixed->CountItems = FramingEx->CountItems;
    FramingExFixed->PinFlags = FramingEx->PinFlags;
    FramingExFixed->OutputCompression = FramingEx->OutputCompression;
    FramingExFixed->PinWeight = FramingEx->PinWeight;

    FramingExFixed->MemoryType = FramingEx->FramingItem[FramingIndex].MemoryType;
    FramingExFixed->MemoryFlags = FramingEx->FramingItem[FramingIndex].MemoryFlags;

    GetLogicalMemoryTypeFromMemoryType(
        FramingExFixed->MemoryType,
        FramingExFixed->MemoryFlags,
        &FramingExFixed->LogicalMemoryType
        );

    FramingExFixed->BusType = FramingEx->FramingItem[FramingIndex].BusType;
    FramingExFixed->BusFlags = FramingEx->FramingItem[FramingIndex].BusFlags;
    FramingExFixed->Flags = FramingEx->FramingItem[FramingIndex].Flags;
    FramingExFixed->Frames = FramingEx->FramingItem[FramingIndex].Frames;
    FramingExFixed->FileAlignment = FramingEx->FramingItem[FramingIndex].FileAlignment;
    FramingExFixed->PhysicalRange = FramingEx->FramingItem[FramingIndex].PhysicalRange;
    FramingExFixed->MemoryTypeWeight = FramingEx->FramingItem[FramingIndex].MemoryTypeWeight;
    FramingExFixed->OptimalRange = FramingEx->FramingItem[FramingIndex].FramingRange;

    return TRUE;

}


STDMETHODIMP_(BOOL)
GetFramingFixedFromPinByIndex(
    IN IKsPin* KsPin,
    IN ULONG FramingIndex,
    OUT PKS_FRAMING_FIXED FramingExFixed
)

{

    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;


    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp == FramingProp_None) {
        FramingExFixed = NULL;
        return FALSE;
    }

    if (FramingEx->CountItems < FramingIndex) {
        FramingExFixed = NULL;
        return FALSE;
    }

    return ( GetFramingFixedFromFramingByIndex(FramingEx, FramingIndex, FramingExFixed) );

}


STDMETHODIMP_(BOOL)
GetLogicalMemoryTypeFromMemoryType(
    IN GUID MemoryType,
    IN ULONG Flag,
    OUT KS_LogicalMemoryType* LogicalMemoryType
)

{
    if (MemoryType == KSMEMORY_TYPE_DONT_CARE) {
        *LogicalMemoryType = KS_MemoryTypeDontCare;
    }
    else if (MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) {
        *LogicalMemoryType = KS_MemoryTypeKernelPaged;
    }
    else if (MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) {
        *LogicalMemoryType = KS_MemoryTypeKernelNonPaged;
    }
    else if (MemoryType == KSMEMORY_TYPE_USER) {
        *LogicalMemoryType = KS_MemoryTypeUser;
    }
    else {
        //
        // device memory GUID
        //
        if (Flag & KSALLOCATOR_FLAG_DEVICE_SPECIFIC) {
            *LogicalMemoryType = KS_MemoryTypeDeviceSpecific;
        }
        else {
            *LogicalMemoryType = KS_MemoryTypeDeviceHostMapped;
        }
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
GetMemoryTypeFromLogicalMemoryType(
    IN KS_LogicalMemoryType LogicalMemoryType,
    OUT GUID* MemoryType
    )

{
    if (LogicalMemoryType == KS_MemoryTypeDontCare) {
        *MemoryType = KSMEMORY_TYPE_DONT_CARE;
    }
    else if (LogicalMemoryType == KS_MemoryTypeKernelPaged) {
        *MemoryType = KSMEMORY_TYPE_KERNEL_PAGED;
    }
    else if (LogicalMemoryType == KS_MemoryTypeKernelNonPaged) {
        *MemoryType = KSMEMORY_TYPE_KERNEL_NONPAGED;
    }
    else if (LogicalMemoryType == KS_MemoryTypeUser) {
        *MemoryType = KSMEMORY_TYPE_USER;
    }
    else {
        return FALSE;
    }

    return TRUE;
}




STDMETHODIMP_(BOOL)
CanAllocateMemoryType(
    IN GUID MemoryType
    )
{
    if ( (MemoryType == KSMEMORY_TYPE_KERNEL_PAGED) ||
         (MemoryType == KSMEMORY_TYPE_KERNEL_NONPAGED) ||
         (MemoryType == KSMEMORY_TYPE_USER) ) {

        return TRUE;
    }
    else {
        return FALSE;
    }
}



STDMETHODIMP_(BOOL)
DoesPinPreferMemoryTypeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )

{
    GUID                       FromMemoryType;
    GUID                       ToMemoryType;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    ULONG                      i;
    BOOL                       RetCode = TRUE;



    memcpy(&FromMemoryType, Param1, sizeof(GUID) );
    memcpy(&ToMemoryType, Param2, sizeof(GUID) );

    if (FromMemoryType != ToMemoryType) {
        GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

        if (FramingProp == FramingProp_None) {
            if (FromMemoryType == KSMEMORY_TYPE_DONT_CARE) {
                *IsDone = 1;
                RetCode = FALSE;
            }
        }
        else {
            for (i=0; i<FramingEx->CountItems; i++) {
                if (FramingEx->FramingItem[i].MemoryType == FromMemoryType) {
                    //
                    // FromMemoryType is listed above ToMemoryType in KsPin framing properties.
                    //
                    *IsDone = 1;
                    RetCode =FALSE;
                    break;
                }
                if (FramingEx->FramingItem[i].MemoryType == ToMemoryType) {
                    //
                    // ToMemoryType is listed above FromMemoryType in KsPin framing properties.
                    //
                    break;
                }
            }
        }

    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
DoesPipePreferMemoryType(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID ToMemoryType,
    IN GUID FromMemoryType,
    IN ULONG Flag
    )
/*++

Routine Description:

    If every pin on a KsPin-pipe, that has framing properties, lists the "ToMemoryType"
    above "FromMemoryType" in its framing properties - then we say that the entire pipe prefers
    "ToMemoryType" over "FromMemoryType".

    NOTE:
    In future - consider the weights as well.


Arguments:

    KsPin -
        pin that determines a pipe.

    PinType -
        KsPin type

    ToMemoryType -
        see above

    FromMemoryType -
        see above

    Flag -
        if 1 - then modify KsPin-pipe to use "ToMemoryType", if KsPin-pipe actually prefers it.
        0 - don't modify KsPin-pipe.


Return Value:

    TRUE - if KsPin-pipe prefers "ToMemoryType" over "FromMemoryType".
    FALSE - else.

--*/
{

    IKsPin*   FirstKsPin;
    ULONG     FirstPinType;
    ULONG     RetCode = TRUE;



    if (ToMemoryType != FromMemoryType) {

        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        if (! RetCode) {
            ASSERT(RetCode);
        }
        else {
            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, DoesPinPreferMemoryTypeCallback,
                                        (PVOID*) &FromMemoryType, (PVOID*) &ToMemoryType);

            if (RetCode && Flag) {

                IKsAllocatorEx*            KsAllocator;
                PALLOCATOR_PROPERTIES_EX   AllocEx;
                IKsPinPipe*                KsPinPipe = NULL;
                HRESULT                    hr;

                GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

                KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
                AllocEx = KsAllocator->KsGetProperties();

                AllocEx->MemoryType = ToMemoryType;
                GetLogicalMemoryTypeFromMemoryType(AllocEx->MemoryType, 0, &AllocEx->LogicalMemoryType);
            }
        }
    }

    return RetCode;
}


STDMETHODIMP
SetUserModePipe(
    IN IKsPin* KsPin,
    IN ULONG KernelPinType,
    IN OUT ALLOCATOR_PROPERTIES* Properties,
    IN ULONG PropertyPinType,
    IN ULONG BufferLimit
    )
/*++

Routine Description:

    Set the properties on the base allocator that connects kernel and user mode pins.


Arguments:

    KsPin -
        kernel pin

    KernelPinType -
        KsPin type

    Properties -
        base allocator properties

    PropertyPinType -
        type of the pin that determines the allocator properties.

    BufferLimit -
        the buffer size limit, derived from the related filter.
        If zero, then no limits are in effect.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    HRESULT                    hr;
    IKsPinPipe*                KsPinPipe;


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if (PropertyPinType == Pin_User) {
        //
        // only user pin decides on the final settings
        //
        AllocEx->cBuffers = Properties->cBuffers;
        AllocEx->cbBuffer = Properties->cbBuffer;
        AllocEx->cbAlign  = Properties->cbAlign;
        AllocEx->cbPrefix = ALLOC_DEFAULT_PREFIX;
    }
    else if (PropertyPinType == Pin_All) {
        //
        // both kernel and user pins decide on the final settings.
        //
        Properties->cBuffers = max(AllocEx->cBuffers, Properties->cBuffers);

        if (AllocEx->Flags & KSALLOCATOR_FLAG_ATTENTION_STEPPING) {
            if (! AdjustBufferSizeWithStepping(AllocEx) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR SetUserModePipe Couldn't AdjustBufferSizeWithStepping") ));
            }
        }

        if (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) {
            Properties->cbBuffer = max(AllocEx->cbBuffer, Properties->cbBuffer);
        }
        else {
            Properties->cbBuffer = AllocEx->cbBuffer;
        }

        if (BufferLimit) {
            if (KernelPinType == Pin_Output) {
                if (AllocEx->cbBuffer < (long) BufferLimit) {
                    Properties->cbBuffer = (long) BufferLimit;
                }
            }
            else { // Pin_Input
                if (AllocEx->cbBuffer > (long) BufferLimit) {
                    Properties->cbBuffer = (long) BufferLimit;
                }
            }
        }

        Properties->cbAlign = max(AllocEx->cbAlign, Properties->cbAlign);

        AllocEx->cBuffers = Properties->cBuffers;
        AllocEx->cbBuffer = Properties->cbBuffer;
        AllocEx->cbAlign  = Properties->cbAlign;
        AllocEx->cbPrefix = Properties->cbPrefix;
    }
    else {
        //
        // only kernel pin decides on the final settings
        //
        Properties->cBuffers = AllocEx->cBuffers;

        if (BufferLimit) {
            if (KernelPinType == Pin_Output) {
                if (AllocEx->cbBuffer < (long) BufferLimit) {
                    AllocEx->cbBuffer = (long) BufferLimit;
                }
            }
            else {
                if (AllocEx->cbBuffer > (long) BufferLimit) {
                    AllocEx->cbBuffer = (long) BufferLimit;
                }
            }
        }

        if (AllocEx->Flags & KSALLOCATOR_FLAG_ATTENTION_STEPPING) {
            if (! AdjustBufferSizeWithStepping(AllocEx) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR SetUserModePipe Couldn't AdjustBufferSizeWithStepping") ));
            }
        }

        Properties->cbBuffer = AllocEx->cbBuffer;
        Properties->cbAlign =  AllocEx->cbAlign;
    }

    //
    // Consistent with current allocator scheme.
    //
    if (Properties->cBuffers == 0) {
        Properties->cBuffers = 1;
    }

    if (Properties->cbBuffer == 0) {
        Properties->cbBuffer = 1;
    }

    if (Properties->cbAlign == 0) {
        Properties->cbAlign = 1;
    }

    AllocEx->MemoryType = KSMEMORY_TYPE_USER;
    AllocEx->LogicalMemoryType = KS_MemoryTypeUser;

    return hr;

}


STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocationCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    IKsPinPipe*                KsPinPipe;
    HRESULT                    hr;
    BOOL                       RetCode = FALSE;


    AllocSearch = (ALLOCATOR_SEARCH *) Param1;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (KsPinPipe->KsGetPipeAllocatorFlag() & 1) {
        AllocSearch->KsPin = KsPin;
        AllocSearch->PinType = PinType;
        *IsDone = 1;

        RetCode = TRUE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
GetAllocatorHandlerLocation(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorHandlerPinType,
    OUT ULONG* AllocatorHandlerLocation
    )
/*++

Routine Description:

    Finds the allocator handler pin on a given pipe.

    Also, finds the AllocatorHandlerLocation = Pin_Inside_Pipe/Pin_Outside_Pipe - relative to KsPin.
    When caller is interested in AllocatorHandlerLocation, KsPin should be the input pin that is
    the first downstream pin located outside of a pipe.

    Walk the pins on a pipe defined by KsPin. Find the pin that has the pipe allocator handler flag set.
    If no such pin found - return FALSE.

Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    Direction -
        direction relative to KsPin to look for the allocator handler.

    KsAllocatorHandlerPin -
        returned pin that will be an allocator handler.

    AllocatorHandlerPinType -
        type of the KsAllocatorHandlerPin.

    AllocatorHandlerLocation -
        see above.


Return Value:

    TRUE on success.

--*/
{

    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    IKsPin*                    BreakKsPin;
    IKsPinPipe*                KsPinPipe;
    BOOL                       RetCode = TRUE;
    HRESULT                    hr;
    ALLOCATOR_SEARCH           AllocSearch;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsAllocatorEx*            KsAllocator;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if ( (Direction == KS_DIRECTION_UPSTREAM) || (Direction == KS_DIRECTION_ALL) ) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);

        if (! RetCode) {
            ASSERT(RetCode);
        }
        else {
            //
            // even for KS_DIRECTION_ALL - we want to stop at KsPin.
            //
            BreakKsPin = KsPin;
        }
    }
    else { // KS_DIRECTION_DOWNSTREAM
        FirstKsPin = KsPin;
        FirstPinType = PinType;
        BreakKsPin = NULL;
    }

    if (RetCode) {

        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, GetAllocatorHandlerLocationCallback, (PVOID*) &AllocSearch, NULL);

        if (RetCode) {
            if (KsAllocatorHandlerPin) {
                *KsAllocatorHandlerPin = AllocSearch.KsPin;
            }

            if (AllocatorHandlerPinType) {
                *AllocatorHandlerPinType = AllocSearch.PinType;
            }

            if (AllocatorHandlerLocation) {
                *AllocatorHandlerLocation = Pin_Inside_Pipe;
            }
        }
        else if (Direction != KS_DIRECTION_ALL) {
            if (AllocatorHandlerLocation) {
                *AllocatorHandlerLocation = Pin_Outside_Pipe;
            }

            RetCode = FALSE;
        }
        else {
            //
            // Search downstream if Direction=KS_DIRECTION_ALL only.
            //
            FirstKsPin = KsPin;
            FirstPinType = PinType;
            BreakKsPin = NULL;

            RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, GetAllocatorHandlerLocationCallback, (PVOID*) &AllocSearch, NULL);

            if (RetCode) {
                if (KsAllocatorHandlerPin) {
                    *KsAllocatorHandlerPin = AllocSearch.KsPin;
                }

                if (AllocatorHandlerPinType) {
                    *AllocatorHandlerPinType = AllocSearch.PinType;
                }

                if (AllocatorHandlerLocation) {
                    *AllocatorHandlerLocation = Pin_Outside_Pipe;
                }
            }
            else {
                if (AllocatorHandlerLocation) {
                    *AllocatorHandlerLocation = Pin_None;
                }

                RetCode = FALSE;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
SplitPipes(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin
    )
/*++

Routine Description:

    Create two pipes out of one pipe.
    The pipe break point is determined by the parameters.

Arguments:

    OutKsPin -
        output pin on upstream filter.

    InKsPin -
        input pin on downstream filter.


Return Value:

    TRUE on success.

--*/
{
    IKsAllocatorEx*   NewKsAllocator;
    IKsPinPipe*       KsPinPipe;
    IKsAllocatorEx*   OldKsAllocator;
    HRESULT           hr;
    ULONG             RetCode = TRUE;


    //
    // First - see how many pins were on the original pipe -
    // as we will destroy it at the end of this
    //
    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    OldKsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

    //
    // Start with input pipe - its input pin is the terminator for new pipe.
    //

    if ( SUCCEEDED( hr = CreatePipe(InKsPin, &NewKsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(NewKsAllocator, 0) ) ) {

        MovePinsToNewPipe(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT, NewKsAllocator, FALSE);

        NewKsAllocator->Release();
    }
    else {
        ASSERT(0);
        RetCode = FALSE;
    }

    //
    // output pipe
    //
    if ( SUCCEEDED( hr ) &&
         SUCCEEDED( hr = CreatePipe(OutKsPin, &NewKsAllocator) ) &&
         SUCCEEDED( hr = InitializePipe(NewKsAllocator, 0) ) ) {

        MovePinsToNewPipe(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

        NewKsAllocator->Release();
    }
    else {
        ASSERT(0);
        RetCode = FALSE;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindFirstPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT IKsPin** FirstKsPin,
    OUT ULONG* FirstPinType
    )
{

    IKsPin*      CurrentKsPin;
    IKsPin*      StoreKsPin;
    ULONG        CurrentPinType;
    ULONG        RetCode;


    CurrentKsPin = KsPin;
    CurrentPinType = PinType;

    do {
        StoreKsPin = CurrentKsPin;

        RetCode = FindNextPinOnPipe(StoreKsPin, CurrentPinType, KS_DIRECTION_UPSTREAM, NULL, FALSE, &CurrentKsPin);

        if (! RetCode) {
            *FirstKsPin = StoreKsPin;
            *FirstPinType = CurrentPinType;
            return (TRUE);
        }

        if (CurrentPinType == Pin_Input) {
            CurrentPinType = Pin_Output;
        }
        else {
            CurrentPinType = Pin_Input;
        }

    } while ( 1 );

}


STDMETHODIMP_(BOOL)
FindNextPinOnPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** NextKsPin
)

{
    IPin*             Pin;
    IKsPinPipe*       KsPinPipe;
    IKsAllocatorEx*   NextKsAllocator;
    IKsPinPipe*       NextKsPinPipe;
    HRESULT           hr;
    ULONG             RetCode = FALSE;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        if  ( ((PinType == Pin_Input) && (Direction == KS_DIRECTION_UPSTREAM)) ||
              ((PinType == Pin_Output) && (Direction == KS_DIRECTION_DOWNSTREAM))    )  {

            Pin = KsPinPipe->KsGetConnectedPin();

            if (Pin && IsKernelPin(Pin) ) {

                hr = Pin->QueryInterface( __uuidof(IKsPin), reinterpret_cast<PVOID*>(NextKsPin) );
                if ( SUCCEEDED( hr ) && (*NextKsPin) )  {
                    //
                    // Otherwise: user pin -> end of pipe
                    //
                    (*NextKsPin)->Release();

                    GetInterfacePointerNoLockWithAssert((*NextKsPin), __uuidof(IKsPinPipe), NextKsPinPipe, hr);

                    NextKsAllocator = NextKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                    if (FlagIgnoreKey || (KsAllocator == NextKsAllocator) ) {
                        RetCode = TRUE;
                    }
                }
            }
        }
        else {
            RetCode = FindConnectedPinOnPipe(KsPin, KsAllocator, FlagIgnoreKey, NextKsPin);
        }
    }

    return  RetCode;
}


STDMETHODIMP_(BOOL)
FindConnectedPinOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,        // NULL - if same pipe.
    IN BOOL FlagIgnoreKey,
    OUT IKsPin** ConnectedKsPin
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPinPipe*      ConnectedKsPinPipe;



    ASSERT(KsPin);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        if ( ! (SUCCEEDED( hr ) )) {
            ASSERT( 0 );
        }
        else if (PinCount) {
            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindConnectedPinOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);
                if ( ! (SUCCEEDED( hr ) )) {
                    ASSERT( 0 );
                }
                else {
                    //
                    // Find first ConnectedKsPin in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {
                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), (*ConnectedKsPin), hr);

                        GetInterfacePointerNoLockWithAssert((*ConnectedKsPin), __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (FlagIgnoreKey || (ConnectedKsAllocator == KsAllocator) ) {
                            RetCode = TRUE;
                            break;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }

    if (! RetCode) {
        (*ConnectedKsPin) = NULL;
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
FindAllConnectedPinsOnPipe(
    IN IKsPin* KsPin,
    IN IKsAllocatorEx* KsAllocator,
    OUT IKsPin** ListConnectedKsPins,
    OUT ULONG* CountConnectedKsPins
)

{
    BOOL             RetCode = FALSE;
    IKsAllocatorEx*  ConnectedKsAllocator;
    IPin*            Pin;
    ULONG            PinCount = 0;
    IPin**           PinList;
    ULONG            i;
    HRESULT          hr;
    IKsPinPipe*      KsPinPipe;
    IKsPin*          ConnectedKsPin;
    IKsPinPipe*      ConnectedKsPinPipe;




    ASSERT(KsPin);

    *CountConnectedKsPins = 0;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    if (! KsAllocator) {
        KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    }

    if (KsAllocator) {
        //
        // find connected Pins
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IPin), Pin, hr);

        hr = Pin->QueryInternalConnections(NULL, &PinCount);
        ASSERT( SUCCEEDED( hr ) );

        if ( SUCCEEDED( hr ) && (PinCount != 0) ) {

            if (NULL == (PinList = new IPin*[ PinCount ])) {
                hr = E_OUTOFMEMORY;
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FindAllConnectedPinsOnPipe E_OUTOFMEMORY on new PinCount=%d"), PinCount ));
            }
            else {
                hr = Pin->QueryInternalConnections(PinList, &PinCount);

                ASSERT( SUCCEEDED( hr ) );

                if ( SUCCEEDED( hr ) ) {
                    //
                    // Find all  ConnectedKsPin-s in the PinList array that resides on the same KsPin-pipe.
                    //
                    for (i = 0; i < PinCount; i++) {

                        GetInterfacePointerNoLockWithAssert(PinList[ i ], __uuidof(IKsPin), ConnectedKsPin, hr);

                        GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

                        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);

                        if (ConnectedKsAllocator == KsAllocator) {
                            if (ListConnectedKsPins) {
                                ListConnectedKsPins[*CountConnectedKsPins] = ConnectedKsPin;
                            }

                            (*CountConnectedKsPins)++;

                            RetCode = TRUE;
                        }
                    }
                    for (i=0; i<PinCount; i++) {
                        PinList[i]->Release();
                    }
                }
                delete [] PinList;
            }
        }
    }
    return RetCode;

}


STDMETHODIMP_(BOOL)
ResolvePhysicalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx
    )
/*++

Routine Description:

    Compute pipe terminal physical ranges, based on known pipe dimensions and framing physical range
    set on the MaxExpansionPin.

Arguments:

    AllocEx -
        pipe properties.

Return Value:

    TRUE on SUCCESS.

--*/
{
    KS_COMPRESSION             TempCompression;

    //
    // if pipe doesn't have real physical limits - do nothing.
    //
    if ( (AllocEx->PhysicalRange.MaxFrameSize != ULONG_MAX) && (AllocEx->PhysicalRange.MaxFrameSize != 0) ) {
        //
        // Input pipe termination.
        //
        ReverseCompression(&AllocEx->Dimensions.MaxExpansionPin, &TempCompression);
        ComputeRangeBasedOnCompression(AllocEx->PhysicalRange, TempCompression, &AllocEx->Input.PhysicalRange);

        //
        // Output pipe termination.
        //
        DivideKsCompression(AllocEx->Dimensions.EndPin, AllocEx->Dimensions.MaxExpansionPin, &TempCompression);
        ComputeRangeBasedOnCompression(AllocEx->PhysicalRange, TempCompression, &AllocEx->Output.PhysicalRange);
    }

    return TRUE;
}


STDMETHODIMP_(BOOL)
ResolveOptimalRangesBasedOnDimensions(
    IN OUT PALLOCATOR_PROPERTIES_EX AllocEx,
    IN KS_FRAMING_RANGE Range,
    IN ULONG PinType
    )

/*++

Routine Description:

    Compute pipe terminal optimal ranges, based on known pipe dimensions
    and known framing optimal range at the specified pipe termination.


Arguments:

    AllocEx -
        pipe properties.

    Range -
        optimal framing range at the pipe termination, specified by PinType argument.

    PinType -
        defines the pipe termination side (input vs. output).

Return Value:

    TRUE on SUCCESS.

--*/
{

    KS_COMPRESSION             TempCompression;

    if (PinType == Pin_Input) {
        ComputeRangeBasedOnCompression(Range, AllocEx->Dimensions.EndPin, &AllocEx->Output.OptimalRange.Range);
    }
    else {
        ReverseCompression ( &AllocEx->Dimensions.EndPin, &TempCompression);
        ComputeRangeBasedOnCompression(Range, TempCompression, &AllocEx->Output.OptimalRange.Range);
    }

    return TRUE;

}


STDMETHODIMP_(BOOL)
ReassignPipeCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    IKsAllocatorEx*  KsAllocator = (IKsAllocatorEx*) Param1;
    IKsPinPipe*      KsPinPipe;
    IMemAllocator*   MemAllocator;
    HRESULT          hr;



    GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

    KsPin->KsReceiveAllocator(MemAllocator);

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsPinPipe->KsSetPipe(KsAllocator);


    return TRUE;
}


STDMETHODIMP_(BOOL)
MovePinsToNewPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction,
    IN IKsAllocatorEx* NewKsAllocator,
    IN BOOL MoveAllPins
    )
/*++

Routine Description:
    Walk the pipe determined by KsPin.
    All pin on this pipe should join new pipe specified by NewKsAllocator.
    The old pipe should be deleted.

    NOTE:
    KsPin is a terminal pin on a pipe for current callers.
    Generalize this routine if needed.


Arguments:


    KsPin -
        pin

    PinType -
        KsPin type

    Direction -
        not currently used.

    NewKsAllocator -
        new pipe.

    MoveAllPins -
        if 1 - then move all pins on the KsPin-pipe, including the pins upstream from KsPin,
        else - move pins downstream from KsPin only, including KsPin.


Return Value:

    TRUE on success.

--*/
{

    IKsPin*         FirstKsPin;
    ULONG           FirstPinType;
    ULONG           RetCode = TRUE;




    if (MoveAllPins) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);
    }
    else {
        if (PinType != Pin_Input) {
            ASSERT(0);
            RetCode = FALSE;
        }
        else {
            FirstKsPin = KsPin;
            FirstPinType = PinType;
        }
    }

    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, ReassignPipeCallback, (PVOID*) NewKsAllocator, NULL);
    }

    return RetCode;

}


STDMETHODIMP_(BOOL)
CreateAllocatorCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    IKsAllocatorEx*  KsAllocator;
    HANDLE           AllocatorHandle;
    IKsPinPipe*      KsPinPipe;
    HRESULT          hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );

    AllocatorHandle = KsAllocator->KsCreateAllocatorAndGetHandle(KsPin);
    if (AllocatorHandle) {
        (*Param1) = (PVOID) AllocatorHandle;
        *IsDone = 1;
    }

    return TRUE;
}


STDMETHODIMP
FixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Fixes up the kernel mode pipe defined by KsPin.
    Creates a single allocator handler on every pipe.
    Creates one or more allocator pin[-s] on one selected filter on every pipe.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPin*                    FirstKsPin;
    IKsPin*                    AllocKsHandlerPin;
    IKsPin*                    AllocKsPin;
    IKsPinPipe*                KsPinPipe;
    HANDLE                     AllocatorHandle = INVALID_HANDLE_VALUE;
    BOOL                       RetCode;
    ULONG                      FirstPinType;
    HRESULT                    hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe entry KsPin=%x, KsAllocator=%x"), KsPin, KsAllocator ));

    //
    // check if pipe has been finalized.
    //
    if ( (AllocEx->State == PipeState_Finalized) || (AllocEx->MemoryType == KSMEMORY_TYPE_USER) ) {
        RetCode = TRUE;
    }
    else {
        //
        // In case this pipe has "don't care" properties, set default pipe values.
        //
        if (AllocEx->cBuffers == 0) {
            AllocEx->cBuffers = Global.DefaultNumberBuffers;
        }

        if (AllocEx->cbBuffer == 0) {
            AllocEx->cbBuffer = Global.DefaultBufferSize;
        }

        if (AllocEx->cbAlign == 0) {
            AllocEx->cbAlign = Global.DefaultBufferAlignment;
        }

        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);

        if (RetCode) {
            //
            // Make sure that KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO reqs are satisfied at the pipes junction points.
            //
            if (FirstPinType == Pin_Output) {
                IKsPin* InKsPin;
                ULONG OutSize, InSize;
                BOOL IsDone = FALSE;

                if ( IsSpecialOutputReqs(FirstKsPin, Pin_Output, &InKsPin, &OutSize, &InSize) )  {
                    if ( IsKernelModeConnection(FirstKsPin) ) {
                        if ( CanResizePipe(FirstKsPin, Pin_Output, InSize) ) {
                            IsDone =TRUE;
                        }
                    }

                    if (! IsDone) {
                        if ( IsKernelModeConnection(InKsPin) ) {
                            if ( CanResizePipe(InKsPin, Pin_Input, OutSize) ) {
                                IsDone =TRUE;
                            }
                        }
                    }

                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN FixupPipe CanResizePipe ret %d."), IsDone ));
                }
            }

            //
            // First, try to use assigned allocator handler.
            // There could be a problem since the old framing did not indicate KSALLOCATOR_FLAG_CAN_ALLOCATE
            //
            if ( AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL,
                                            &AllocKsHandlerPin, NULL, TRUE) ) {

                AllocatorHandle = KsAllocator->KsCreateAllocatorAndGetHandle(AllocKsHandlerPin);

                if (! AllocatorHandle) {
                    AllocatorHandle = INVALID_HANDLE_VALUE;
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe assigned allocator handler doesn't work.") ));
                }
            }
            else {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe AssignPipeAllocatorHandler failed.") ));
            }

            if (AllocatorHandle == INVALID_HANDLE_VALUE) {
                //
                // Assigned allocator handler doesn't work.
                // Try every pin from the beginning of the pipe.
                //
                RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, CreateAllocatorCallback,
                                             (PVOID*) &AllocatorHandle, NULL);
            }

            if ( (! RetCode) || (AllocatorHandle == INVALID_HANDLE_VALUE) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FixupPipe: could not assign an allocator handler.") ));
            }
            else {
                //
                // Unlike old KsProxy that was assigning an allocator to the multiple pins without choice,
                // we decided to make an allocator assignment more informative.
                //
                // In most cases, there will be a single "allocator implementer pin" on a pipe.
                // "Allocator implementer pin" (pin that handles physical frames allocation) can be different from
                // an "allocator requestor pin" (pin that manages the data flow using the services of the "allocator implementer pin").
                // Every pipe has exactly one allocator-implementer-pin and one or more allocator-requestor-pins.
                // In case there are multiple allocator-requestor-pins on one pipe, they always belong to one filter.
                //
                // To enable the new filter shell to make the intelligent optimized graph control decisions, we are
                // providing the "pipe ID" information for every pin. The pipe ID is the allocator file handle that
                // is unique for each pipe. The filter uses this handle to access the allocator file object.
                //
                RetCode = AssignAllocatorsAndPipeIdForPipePins(KsPin, PinType, AllocatorHandle, KS_DIRECTION_ALL, &AllocKsPin, NULL);

                if (! RetCode) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FixupPipe: could not find an allocator pin.") ));
                }
                else {
                    AllocEx->State = PipeState_Finalized;
                }
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN FixupPipe rets RetCode=%d"), RetCode ));

    if (RetCode) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }

}


STDMETHODIMP
UnfixupPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Unfixes up the pipe, defined by KsPin.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type.

Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPinPipe*                KsPinPipe;
    HRESULT                    hr;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if (AllocEx->State == PipeState_Finalized)  {
        AllocEx->State = PipeState_RangeFixed;
    }

    return S_OK;
}


STDMETHODIMP_(BOOL)
DimensionsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{
    IKsPinPipe*                KsPinPipe;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    HRESULT                    hr;
    DIMENSIONS_DATA            *DimData;
    BOOL                       IsAllocator;
    ULONG                      Type;
    KS_COMPRESSION             TempCompression;
    KS_FRAMING_RANGE           TempRange;
    KS_FRAMING_RANGE           ResultRange;
    KS_OBJECTS_INTERSECTION    Intersect;
    BOOL                       RetCode = TRUE;


    DimData = (DIMENSIONS_DATA *) Param1;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    IsAllocator = KsPinPipe->KsGetPipeAllocatorFlag() & 1;

    //
    // Get current pin framing
    //
    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if ( FramingProp != FramingProp_None) {
        GetFramingFixedFromFramingByIndex(FramingEx, 0, &FramingExFixed);

        //
        // handle pin compression.
        //
        if (! IsCompressionDontCare(FramingExFixed.OutputCompression) ) {
            if (PinType != Pin_Output) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES DimensionsCallback - ERROR IN FILTER: compression is set on input pin") ));
            }
            else {
                MultiplyKsCompression(DimData->Dimensions.EndPin, FramingExFixed.OutputCompression, &TempCompression);

                DimData->Dimensions.EndPin = TempCompression;

                if ( IsGreaterKsExpansion(DimData->Dimensions.EndPin, DimData->Dimensions.MaxExpansionPin) ) {
                    DimData->Dimensions.MaxExpansionPin = DimData->Dimensions.EndPin;
                }
            }
        }

        if (IsAllocator) {
            DimData->Dimensions.AllocatorPin = DimData->Dimensions.EndPin;
        }

        //
        // Handle phys. range and required optimal range framing properties.
        //
        Type = 0;
        if ( ! IsFramingRangeDontCare(FramingExFixed.PhysicalRange) ) {
            Type = 1;
        }
        else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
            DimData->Flags &= ~KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;
            Type = 2;
        }

        if ( Type != 0 ) {
            ReverseCompression(&DimData->Dimensions.EndPin, &TempCompression);

            if (Type == 1) {
                ComputeRangeBasedOnCompression(FramingExFixed.PhysicalRange, TempCompression, &TempRange);
            }
            else {
                ComputeRangeBasedOnCompression(FramingExFixed.OptimalRange.Range, TempCompression, &TempRange);
            }

            if (! FrameRangeIntersection(TempRange, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES DimensionsCallback - ERROR - No Phys. Range intersection") ));
                RetCode = FALSE;
                *IsDone = TRUE;
            }
            else {
                DimData->PhysicalRange = ResultRange;
            }

            //
            // since the physical range changed, update the optimal range.
            //
            if (! FrameRangeIntersection(DimData->OptimalRange.Range, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                DimData->OptimalRange.Range = DimData->PhysicalRange;
            }
            else {
                DimData->OptimalRange.Range = ResultRange;
            }

        }

        if (RetCode) {
            //
            // handle optimal range.
            //
            if (! IsFramingRangeDontCare(FramingExFixed.OptimalRange.Range) ) {

                if ( (FramingExFixed.OptimalRange.InPlaceWeight > DimData->OptimalRange.InPlaceWeight) ||
                     IsFramingRangeDontCare(DimData->OptimalRange.Range) ) {

                    ReverseCompression(&DimData->Dimensions.EndPin, &TempCompression);
                    ComputeRangeBasedOnCompression(FramingExFixed.OptimalRange.Range, TempCompression, &TempRange);

                    if (! FrameRangeIntersection(TempRange, DimData->PhysicalRange, &ResultRange, &Intersect) ) {
                        DimData->OptimalRange.Range = DimData->PhysicalRange;
                    }
                    else {
                        DimData->OptimalRange.Range = ResultRange;
                    }

                    DimData->OptimalRange.InPlaceWeight = FramingExFixed.OptimalRange.InPlaceWeight;
                }
            }

            //
            // handle number of frames for the pipe.
            //
            if (FramingExFixed.Frames > DimData->Frames) {
                DimData->Frames = FramingExFixed.Frames;
            }

            //
            // handle alignment for the pipe.
            //
            if ( (long) (FramingExFixed.FileAlignment + 1) > DimData->cbAlign) {
                DimData->cbAlign = (long) (FramingExFixed.FileAlignment + 1);
            }

            //
            // Handle stepping for the pipe.
            //
            if ( (FramingExFixed.PhysicalRange.Stepping > 1) &&
                 (DimData->PhysicalRange.Stepping < FramingExFixed.PhysicalRange.Stepping) ) {

                DimData->PhysicalRange.Stepping = FramingExFixed.PhysicalRange.Stepping;
                DimData->Flags |= KSALLOCATOR_FLAG_ATTENTION_STEPPING;
            }
            else if ( (FramingExFixed.OptimalRange.Range.Stepping > 1) &&
                      (DimData->OptimalRange.Range.Stepping < FramingExFixed.OptimalRange.Range.Stepping) ) {

                DimData->OptimalRange.Range.Stepping = FramingExFixed.OptimalRange.Range.Stepping;
                DimData->Flags |= KSALLOCATOR_FLAG_ATTENTION_STEPPING;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP
ResolvePipeDimensions(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Direction
    )
/*++

Routine Description:

    Resolve dimensions and framing ranges on the pipe defined by KsPin.
    Assumes that the memory type and allocator handler pin are already set on the pipe.

Arguments:

    KsPin -
        pin that defines a pipe.

    PinType -
        KsPin type.

    Direction -
        not currently used.


Return Value:

    S_OK or an appropriate error code.

--*/
{
    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsPin*                    FirstKsPin;
    IKsPinPipe*                KsPinPipe;
    ULONG                      FirstPinType;
    ULONG                      RetCode;
    DIMENSIONS_DATA            DimData;
    HRESULT                    hr;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           ResultRange;
    ULONG                      Scaled;
    TCHAR                      LogicalMemoryName[13], BusName[13];


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly);
    AllocEx = KsAllocator->KsGetProperties();

    //
    // Set dimension data.
    //
    DimData.MemoryType = AllocEx->MemoryType;
    SetDefaultDimensions(&DimData.Dimensions);
    SetDefaultRange(&DimData.PhysicalRange); // resolved on first pin on pipe
    SetDefaultRangeWeighted(&DimData.OptimalRange); // resolved on first pin on pipe
    DimData.Frames = 0;
    DimData.cbAlign = 0;
    DimData.Flags = KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY;

    //
    // Walk the pipe and process the dimension data in DimensionsCallback.
    //
    RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
    ASSERT(RetCode);

    if (RetCode) {
        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, NULL, DimensionsCallback, (PVOID*) &DimData, NULL);

        if (RetCode) {
            //
            // Retrieve the pipe dimension data and resolve the pipe.
            //
            AllocEx->Dimensions = DimData.Dimensions;
            AllocEx->cBuffers = DimData.Frames;
            AllocEx->cbAlign = DimData.cbAlign;
            AllocEx->Flags = DimData.Flags;
            AllocEx->Input.OptimalRange.Range = DimData.OptimalRange.Range;
            AllocEx->PhysicalRange.Stepping = DimData.PhysicalRange.Stepping;

            //
            // Resolve pipe physical range.
            //
            ComputeRangeBasedOnCompression(DimData.PhysicalRange, AllocEx->Dimensions.MaxExpansionPin, &AllocEx->PhysicalRange);
            ResolvePhysicalRangesBasedOnDimensions(AllocEx);

            //
            // optimal range is always a subset of the physical range.
            //
            if (! FrameRangeIntersection(AllocEx->Input.OptimalRange.Range, AllocEx->Input.PhysicalRange, &ResultRange, &Intersect) ) {
                AllocEx->Input.OptimalRange.Range = AllocEx->Input.PhysicalRange;
            }
            else {
                AllocEx->Input.OptimalRange.Range = ResultRange;
            }

            //
            // Compute optimal range at the Output pipe termination, based on the optimal range at the Input pipe termination.
            //
            ResolveOptimalRangesBasedOnDimensions(AllocEx, AllocEx->Input.OptimalRange.Range, Pin_Input);

            //
            // Compute pipe frame size.
            //
            if (AllocEx->Input.OptimalRange.Range.MaxFrameSize != ULONG_MAX) {
                ComputeUlongBasedOnCompression(
                    AllocEx->Input.OptimalRange.Range.MaxFrameSize,
                    AllocEx->Dimensions.MaxExpansionPin,
                    &Scaled);

                AllocEx->cbBuffer = (long) Scaled;
            }
            else {
                AllocEx->cbBuffer = 0;
            }


            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolvePipeDimensions KsAlloc=%x Dim=%d/%d, %d/%d, %d/%d, Res=%d, %d, %d"),
                KsAllocator,
                AllocEx->Dimensions.AllocatorPin.RatioNumerator, AllocEx->Dimensions.AllocatorPin.RatioDenominator,
                AllocEx->Dimensions.MaxExpansionPin.RatioNumerator, AllocEx->Dimensions.MaxExpansionPin.RatioDenominator,
                AllocEx->Dimensions.EndPin.RatioNumerator, AllocEx->Dimensions.EndPin.RatioDenominator,
                AllocEx->cBuffers, AllocEx->cbBuffer, AllocEx->cbAlign));

            GetFriendlyLogicalMemoryTypeNameFromId(AllocEx->LogicalMemoryType, LogicalMemoryName);
            GetFriendlyBusNameFromBusId(AllocEx->BusType, BusName);
        }
    }

    if (RetCode) {
        hr = S_OK;
    }
    else {
        hr = E_FAIL;
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ResolvePipeDimensions hr=%x, LMT=%s, Bus=%s, Step=%d/%d, Flags=%x"),
            hr, LogicalMemoryName, BusName,  AllocEx->Input.PhysicalRange.Stepping, AllocEx->Input.OptimalRange.Range.Stepping, AllocEx->Flags));

    return hr;

}


STDMETHODIMP
CreateSeparatePipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Remove the KsPin from its current pipe and decrement RefCount on that pipe.

    Create new pipe on KsPin based on its last framing.
    Resolve the original pipe (it doesn't have the KsPin any more).

Arguments:

    KsPin -
        terminal pin on a pipe.

    PinType -
        KsPin type

Return Value:

    S_OK or an appropriate error code.

--*/
{

    IKsAllocatorEx* KsAllocator;
    IKsPin*         ConnectedKsPin;
    IKsPinPipe*     KsPinPipe;
    HRESULT         hr;


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreateSeparatePipe KsPin=%x"), KsPin));

    //
    // first - get connected pin on same filter on same pipe (if any).
    //
    FindConnectedPinOnPipe(KsPin, NULL, FALSE, &ConnectedKsPin);

    //
    // Decrement RefCount on KsPin's current pipe.
    //
    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    ASSERT(KsAllocator);

    KsPinPipe->KsSetPipe(NULL);
    KsPin->KsReceiveAllocator(NULL);

    //
    // create separate pipe on KsPin
    //
    hr = MakePipeBasedOnOnePin(KsPin, PinType, NULL);

    //
    // resolve the original pipe if exist
    //
    if (ConnectedKsPin) {
        ULONG                      ConnectedPinType;
        PALLOCATOR_PROPERTIES_EX   ConnectedAllocEx;
        IKsAllocatorEx*            ConnectedKsAllocator;
        IKsPinPipe*                ConnectedKsPinPipe;
        ULONG                      Direction;



        GetInterfacePointerNoLockWithAssert(ConnectedKsPin, __uuidof(IKsPinPipe), ConnectedKsPinPipe, hr);

        ConnectedKsAllocator = ConnectedKsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
        ConnectedAllocEx = ConnectedKsAllocator->KsGetProperties();

        if (PinType == Pin_Input) {
            ConnectedPinType = Pin_Output;
            Direction = KS_DIRECTION_DOWNSTREAM;
        }
        else {
            ConnectedPinType = Pin_Input;
            Direction = KS_DIRECTION_UPSTREAM;
        }

        //
        // Update original pipe's allocator handler and resolve original pipe's dimensions.
        //
        AssignPipeAllocatorHandler(ConnectedKsPin, ConnectedPinType, ConnectedAllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
        hr = ResolvePipeDimensions(ConnectedKsPin, ConnectedPinType, Direction);
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CreateSeparatePipe rets %x"), hr));

    return hr;
}


STDMETHODIMP_(BOOL)
CanAddPinToPipeOnAnotherFilter(
    IN IKsPin* PipeKsPin,
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN ULONG Flag
    )
/*++

Routine Description:

    Checks to see if KsPin can be added to the pipe defined by PipeKsPin.
    This pipe exist on the connecting filter.
    If KsPin can be added - then change the pipe system according to the Flag passed (see below).

Arguments:

    PipeKsPin -
        pin defining a pipe.

    KsPin -
        pin we want to add to the pipe above.

    PinType -
        KsPin's type.

    Flag -
        0 -> don't change the pipe system.
        Pin_Move -> move KsPin from its current pipe to the PipeKsPin-pipe.
        Pin_Add -> add KsPin to the PipeKsPin-pipe.

Return Value:

    TRUE - if KsPin can be added to the pipe above.


--*/
{

    IKsAllocatorEx*            KsAllocator;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    PKSALLOCATOR_FRAMING_EX    FramingEx;
    FRAMING_PROP               FramingProp;
    KS_FRAMING_FIXED           FramingExFixed;
    HRESULT                    hr;
    BOOL                       RetCode = FALSE;
    IKsPinPipe*                PipeKsPinPipe;
    IKsPinPipe*                KsPinPipe;
    IMemAllocator*             MemAllocator;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;
    BOOL                       FlagDone = 0;



    ASSERT(KsPin && PipeKsPin);

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanAddPinToPipeOnAnotherFilter entry PipeKsPin=%x, KsPin=%x"),
                PipeKsPin, KsPin ));


    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(PipeKsPin, __uuidof(IKsPinPipe), PipeKsPinPipe, hr);

    KsAllocator = PipeKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    //
    // To not break existing graphs, we assume that if two connecting pins agree on a medium,
    // then the connection is possible.
    // We will enforce the rule to expose correct memories in the pin framing properties only
    // for the new filters that support extended framing.
    //
    GetPinFramingFromCache(KsPin, &FramingEx, &FramingProp, Framing_Cache_ReadLast);

    if (FramingProp == FramingProp_Ex) {
        if (! GetFramingFixedFromFramingByMemoryType(FramingEx, AllocEx->MemoryType, &FramingExFixed) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter: no MemoryType KsPin=%x"), KsPin));
            FlagDone = 1;
        }
        else {
            //
            // Check to see if both the pipe and KsPin must allocate.
            //
            if ( (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
                 (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanAddPinToPipeOnAnotherFilter - both MUST_ALLOCATE KsPin=%x"), KsPin));
                FlagDone = 1;
            }
        }
    }

    //
    // Check the physical limits intersection.
    //
    if ( (! FlagDone) && (FramingProp != FramingProp_None) ) {
        GetFramingFixedFromFramingByIndex(FramingEx, 0, &FramingExFixed);

        if (PinType == Pin_Output) {
            if (! FrameRangeIntersection(AllocEx->Input.PhysicalRange, FramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                FlagDone = 1;
            }
            else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if (! FrameRangeIntersection(AllocEx->Input.PhysicalRange, FramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                    FlagDone = 1;
                }
            }
        }
        else {
            if (! FrameRangeIntersection(AllocEx->Output.PhysicalRange, FramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                FlagDone = 1;
            }
            else if ( (FramingProp == FramingProp_Ex) && (! (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if (! FrameRangeIntersection(AllocEx->Output.PhysicalRange, FramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanAddPinToPipeOnAnotherFilter Phys. intersection empty. ") ));
                    FlagDone = 1;
                }
            }
        }
    }

    if (! FlagDone) {
        //
        // Adding KsPin to the specified pipe is possible.
        // Perform the Move/Add/None operation as requested by Flag.
        //
        RetCode = TRUE;

        if (Flag == Pin_Move) {
            RemovePinFromPipe(KsPin, PinType);
        }

        if ( (Flag == Pin_Move) || (Flag == Pin_Add) ) {
            GetInterfacePointerNoLockWithAssert(KsAllocator, __uuidof(IMemAllocator), MemAllocator, hr);

            KsPin->KsReceiveAllocator(MemAllocator);

            KsPinPipe->KsSetPipe(KsAllocator);
            //
            // Set the pipe allocator handling pin and resolve the pipe.
            //
            AssignPipeAllocatorHandler(KsPin, PinType, AllocEx->MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);
            hr = ResolvePipeDimensions(KsPin, PinType, KS_DIRECTION_ALL);
            if (FAILED (hr) ) {
                RetCode = FALSE;
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanAddPinToPipeOnAnotherFilter rets. %d"), RetCode));

    return RetCode;
}


STDMETHODIMP_(BOOL)
CanMergePipes(
    IN IKsPin* InKsPin,
    IN IKsPin* OutKsPin,
    IN GUID MemoryType,
    IN ULONG FlagMerge
    )
/*++

Routine Description:

    KS has already checked that MemoryType satisfies both pipes
    before calling this function.

    The only responsibility of this function is to make sure that it is
    possible to satisfy pipe physical limits and 'must allocate' requests.

Arguments:

    InKsPin -
        input pin on downstream pipe.

    OutKsPin -
        output pin on upstream pipe.

    MemoryType -
        memory type of the merged (resulting) pipe.

    FlagMerge -
        if 1 - then actually merge the pipes if possible.

Return Value:

    TRUE if pipe merge is possible.

--*/
{
    IKsPin*                    AllocInKsPin = NULL;
    IKsPin*                    AllocOutKsPin = NULL;
    KS_FRAMING_FIXED           AllocInFramingExFixed, AllocOutFramingExFixed;
    IKsAllocatorEx*            InKsAllocator;
    IKsAllocatorEx*            OutKsAllocator;
    IKsAllocatorEx*            NewKsAllocator;
    PALLOCATOR_PROPERTIES_EX   InAllocEx, OutAllocEx, NewAllocEx;
    KS_COMPRESSION             TempCompression;
    HRESULT                    hr;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    BOOL                       RetCode = TRUE;
    TCHAR                      LogicalMemoryName[13], BusName[13];



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes entry In=%x Out=%x"), InKsPin, OutKsPin ));

    //
    // Find the allocator handler pin for the resulting pipe.
    //
    if ( AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_UPSTREAM, &AllocOutKsPin, NULL, FALSE) ) {
        RetCode = GetFramingFixedFromPinByMemoryType( AllocOutKsPin, MemoryType, &AllocOutFramingExFixed);
        ASSERT(RetCode);
    }

    if (RetCode &&
        AssignPipeAllocatorHandler(InKsPin, Pin_Input, MemoryType, KS_DIRECTION_DOWNSTREAM, &AllocInKsPin, NULL, FALSE) ) {

        RetCode = GetFramingFixedFromPinByMemoryType( AllocInKsPin, MemoryType, &AllocInFramingExFixed);
        ASSERT(RetCode);
    }

    if (RetCode && AllocOutKsPin && AllocInKsPin) {
        if ( (AllocOutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) &&
            (AllocInFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {
            //
            // Pipes merge is not possible when both pins require to be the allocator handlers.
            //
            RetCode = FALSE;
        }
    }

    if (RetCode) {
        //
        // Get pipes properties
        //
        GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

        GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

        InKsAllocator = InKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        InAllocEx = InKsAllocator->KsGetProperties();

        OutKsAllocator = OutKsPinPipe->KsGetPipe( KsPeekOperation_PeekOnly );
        OutAllocEx = OutKsAllocator->KsGetProperties();

        //
        // We need to resolve the pipe geometry now. See if we can satisfy the physical range.
        // Since the phys. range is reflected in both pipes termination points, we can just intersect
        // the phys. ranges of the connecting pins to see if there is a solution.
        //
        if (! FrameRangeIntersection(OutAllocEx->Output.PhysicalRange, InAllocEx->Input.PhysicalRange, &FinalRange, &Intersect) ) {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanMergePipes Phys. intersection empty. ") ));
            RetCode = FALSE;
        }

        if (RetCode) {
            //
            // The last test: if the resulting pipe expands, then the single pipe solution
            // is possible only if the first pin on a pipe supports partial filling of a frame.
            //
            MultiplyKsCompression(OutAllocEx->Dimensions.EndPin, InAllocEx->Dimensions.EndPin, &TempCompression);

            if ( IsKsExpansion(TempCompression) ) {
                if ( IsPipeSupportPartialFrame(OutKsPin, Pin_Output, NULL) ) {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanMergePipes Partial Frame Fill requested, hr=%x, Expansion=%d/%d"),
                                                hr, TempCompression.RatioNumerator, TempCompression.RatioDenominator ));
                }
                else {
                    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanMergePipes - Partial Frame Fill REFUSED Expansion=%d/%d"),
                                                TempCompression.RatioNumerator, TempCompression.RatioDenominator ));

                    RetCode = FALSE;
                }
            }
        }

        if (RetCode && FlagMerge) {
            //
            // We are done with our new pipe feasibility study. Create resulting pipe
            //
            hr = CreatePipe(OutKsPin, &NewKsAllocator);
            if (! SUCCEEDED( hr )) {
                ASSERT(0);
                RetCode = FALSE;
            }

            if (RetCode) {
                hr = InitializePipe(NewKsAllocator, 0);
                if (! SUCCEEDED( hr )) {
                    ASSERT(0);
                    RetCode = FALSE;
                }
            }

            if (RetCode) {
                NewAllocEx = NewKsAllocator->KsGetProperties();

                //
                // Copy the properties from Upstream side.
                //
                *NewAllocEx = *OutAllocEx;

                //
                // Fill necessary info.
                //
                NewAllocEx->MemoryType = MemoryType;
                GetLogicalMemoryTypeFromMemoryType(MemoryType, NewAllocEx->Flags, &NewAllocEx->LogicalMemoryType);

                //
                // All pins from both connecting pipes should join new pipe now.
                // Both connecting pipes should be deleted.
                //
                MovePinsToNewPipe(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

                MovePinsToNewPipe(InKsPin, Pin_Input, KS_DIRECTION_DEFAULT, NewKsAllocator, TRUE);

                //
                // Assign allocator handler on NewKsAllocator
                //
                AssignPipeAllocatorHandler(OutKsPin, Pin_Output, MemoryType, KS_DIRECTION_ALL, NULL, NULL, TRUE);

                //
                // Compute dimensions for new pipe.
                //
                hr = ResolvePipeDimensions(OutKsPin, Pin_Output, KS_DIRECTION_DEFAULT);

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes KsAlloc=%x, Dim=%d/%d, %d/%d, %d/%d, Res=%d, %d, %d"),
                    NewKsAllocator,
                    NewAllocEx->Dimensions.AllocatorPin.RatioNumerator, NewAllocEx->Dimensions.AllocatorPin.RatioDenominator,
                    NewAllocEx->Dimensions.MaxExpansionPin.RatioNumerator, NewAllocEx->Dimensions.MaxExpansionPin.RatioDenominator,
                    NewAllocEx->Dimensions.EndPin.RatioNumerator, NewAllocEx->Dimensions.EndPin.RatioDenominator,
                    NewAllocEx->cBuffers, NewAllocEx->cbBuffer, NewAllocEx->cbAlign));

                GetFriendlyLogicalMemoryTypeNameFromId(NewAllocEx->LogicalMemoryType, LogicalMemoryName);
                GetFriendlyBusNameFromBusId(NewAllocEx->BusType, BusName);

                DbgLog((LOG_MEMORY, 2, TEXT("PIPES LMT=%s, Bus=%s"), LogicalMemoryName, BusName ));

                NewKsAllocator->Release();
            }
        }
    }

    DbgLog((LOG_MEMORY, 2, TEXT("PIPES CanMergePipes rets %d"), RetCode ));

    return RetCode;

}


STDMETHODIMP_(BOOL)
CanConnectPins(
    IN IKsPin* OutKsPin,
    IN IKsPin* InKsPin,
    IN ULONG FlagConnect
    )
/*++

Routine Description:

    Attempt to create a separate pipe for just 2 pins.

Arguments:

    OutKsPin -
        output pin on upstream pipe.

    InKsPin -
        input pin on downstream pipe.

    FlagConnect -
        if 1 - then actually connect pins into one pipe, if possible.

Return Value:

    TRUE - if connecting pins into one pipe is possible.

--*/
{

    PKSALLOCATOR_FRAMING_EX    InFramingEx, OutFramingEx;
    FRAMING_PROP               InFramingProp, OutFramingProp;
    HRESULT                    hr;
    BOOL                       RetCode = TRUE;
    KS_FRAMING_FIXED           InFramingExFixed, OutFramingExFixed;
    IKsPinPipe*                InKsPinPipe;
    IKsPinPipe*                OutKsPinPipe;
    GUID                       Bus;
    BOOL                       IsHostBus;
    ULONG                      CommonMemoryTypesCount;
    GUID                       CommonMemoryType;
    KS_OBJECTS_INTERSECTION    Intersect;
    KS_FRAMING_RANGE           FinalRange;



    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanConnectPins entry InKsPin=%x OutKsPin=%x"),
                InKsPin, OutKsPin ));

    GetInterfacePointerNoLockWithAssert(InKsPin, __uuidof(IKsPinPipe), InKsPinPipe, hr);

    GetInterfacePointerNoLockWithAssert(OutKsPin, __uuidof(IKsPinPipe), OutKsPinPipe, hr);

    //
    // Get framing from KsPins
    //
    GetPinFramingFromCache(OutKsPin, &OutFramingEx, &OutFramingProp, Framing_Cache_ReadLast);

    GetPinFramingFromCache(InKsPin, &InFramingEx, &InFramingProp, Framing_Cache_ReadLast);

    //
    // Get connecting bus ID.
    //
    GetBusForKsPin(InKsPin, &Bus);
    IsHostBus = IsHostSystemBus(Bus);

    if ( (OutFramingProp == FramingProp_None) && (InFramingProp == FramingProp_None) ) {
        if (FlagConnect) {
            RemovePinFromPipe(InKsPin, Pin_Input);
            RemovePinFromPipe(OutKsPin, Pin_Output);
            CreatePipeForTwoPins(InKsPin, OutKsPin, Bus, GUID_NULL);
        }
    }
    else if (OutFramingProp == FramingProp_None) {
        //
        // Input pin will define the pipe.
        //
        if (FlagConnect) {
            RemovePinFromPipe(InKsPin, Pin_Input);

            hr = MakePipeBasedOnOnePin(InKsPin, Pin_Input, NULL);
            ASSERT( SUCCEEDED( hr ) );

            if ( SUCCEEDED( hr ) ) {
                if (! CanAddPinToPipeOnAnotherFilter(InKsPin, OutKsPin, Pin_Output, Pin_Move) ) {
                    //
                    // must be able to succeed since OutKsPin doesn't care
                    //
                    ASSERT(0);
                }
            }
        }
    }
    else if (InFramingProp == FramingProp_None) {
        //
        // Output pin will define the pipe.
        //
        if (FlagConnect) {
            hr = MakePipeBasedOnOnePin(OutKsPin, Pin_Output, NULL);
            ASSERT( SUCCEEDED( hr ) );

            if ( SUCCEEDED( hr ) ) {
                if (! CanAddPinToPipeOnAnotherFilter(OutKsPin, InKsPin, Pin_Input, Pin_Move) ) {
                    //
                    // must be able to succeed since OutKsPin doesn't care
                    //
                    ASSERT(0);
                }
            }
        }
    }
    else {
        //
        // Both pins have the framing.
        // Find the MemoryType to connect the pins.
        //
        CommonMemoryTypesCount = 1;

        if (! FindCommonMemoryTypesBasedOnBuses(InFramingEx, OutFramingEx, Bus, GUID_NULL,
                &CommonMemoryTypesCount, &CommonMemoryType) ) {
            //
            // Filters that support new FRAMING_EX properties must agree on the memory type.
            //
            if ( (! IsHostBus) && (InFramingProp == FramingProp_Ex) && (OutFramingProp == FramingProp_Ex) ) {
                DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR FILTERS CanConnectPins - new filters don't agree on MemoryType") ));

                RetCode = FALSE;
            }
            else {
                //
                // Since we can't find the common MemoryType, get any MemoryType per Bus.
                //
                GetFramingFixedFromFramingByBus(InFramingEx, Bus, TRUE, &InFramingExFixed);
                GetFramingFixedFromFramingByBus(OutFramingEx, Bus, TRUE, &OutFramingExFixed);
            }
        }
        else {
            RetCode = GetFramingFixedFromFramingByMemoryType(InFramingEx,
                                                             CommonMemoryType,
                                                             &InFramingExFixed);
            ASSERT( RetCode && "PrefixBug 5463 would be hit" );
            if ( RetCode ) {
                RetCode = GetFramingFixedFromFramingByMemoryType(OutFramingEx,
                                                                 CommonMemoryType,
                                                                 &OutFramingExFixed);
                ASSERT( RetCode && "PrefixBug 5450 would be hit" );
            }
        }

        if (RetCode) {
            //
            // check the pins physical framing intersection.
            //
            if ( (OutFramingProp == FramingProp_Ex) && (! (OutFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                if ( (InFramingProp == FramingProp_Ex) && (! (InFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                    if (! FrameRangeIntersection(OutFramingExFixed.OptimalRange.Range, InFramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
                else {
                    if (! FrameRangeIntersection(OutFramingExFixed.OptimalRange.Range, InFramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
            }
            else { // Out pin doesn't insist.
                if ( (InFramingProp == FramingProp_Ex) && (! (InFramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY) ) ) {
                    if (! FrameRangeIntersection(OutFramingExFixed.PhysicalRange, InFramingExFixed.OptimalRange.Range, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
                else {
                    if (! FrameRangeIntersection(OutFramingExFixed.PhysicalRange, InFramingExFixed.PhysicalRange, &FinalRange, &Intersect) ) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES WARN CanConnectPins intersection empty. ") ));
                        RetCode = FALSE;
                    }
                }
            }
        }

        if (RetCode && FlagConnect) {
            //
            // Select the pin with the highest weight.
            //
            RemovePinFromPipe(InKsPin, Pin_Input);
            RemovePinFromPipe(OutKsPin, Pin_Output);

            if (InFramingExFixed.MemoryTypeWeight > OutFramingExFixed.MemoryTypeWeight) {
                hr = MakePipeBasedOnFixedFraming(InKsPin, Pin_Input, InFramingExFixed);
                AddPinToPipeUnconditional(InKsPin, Pin_Input, OutKsPin, Pin_Output);
            }
            else {
                hr = MakePipeBasedOnFixedFraming(OutKsPin, Pin_Output, OutFramingExFixed);
                AddPinToPipeUnconditional(OutKsPin, Pin_Output, InKsPin, Pin_Input);
            }
        }
    }


    DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN CanConnectPins rets. RetCode=%d"), RetCode ));

    return RetCode;
}


STDMETHODIMP_(BOOL)
RemovePinFromPipe(
    IN IKsPin* KsPin,
    IN ULONG PinType
    )
/*++

Routine Description:

    Just remove the KsPin from the pipe it points to.
    If there are any pins left on this pipe - then resolve ranges.
    No dependancies and relaxation, since the caller has already done it.

Arguments:

    KsPin -
        pin.

    PinType -
        KsPin type

Return Value:

    TRUE on SUCCESS.

--*/
{
    BOOL             RetCode = TRUE;
    ULONG            NumPinsInPipe;
    IKsPin*          ConnectedKsPin;
    ULONG            ConnectedPinType;
    IKsPinPipe*      KsPinPipe;
    HRESULT          hr;
    ULONG            Direction;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    ComputeNumPinsInPipe(KsPin, PinType, &NumPinsInPipe);

    if (NumPinsInPipe == 1) {
        //
        // We can delete the pipe.
        //
        KsPinPipe->KsSetPipe(NULL);
        KsPin->KsReceiveAllocator( NULL );
    }
    else {
        //
        // Find first connected pin residing on this pipe.
        //
        if (! FindConnectedPinOnPipe(KsPin, NULL, FALSE, &ConnectedKsPin) ) {
            //
            // Should not happen - since NumPinsInPipe > 1
            // Delete the pipe.
            //
            ASSERT(0);
            KsPinPipe->KsSetPipe(NULL);
            KsPin->KsReceiveAllocator( NULL );
        }
        else {
            //
            // Remove the KsPin and resolve the rest of the pipe.
            //
            KsPinPipe->KsSetPipe(NULL);
            KsPin->KsReceiveAllocator( NULL );

            if (PinType == Pin_Input) {
                ConnectedPinType = Pin_Output;
                Direction = KS_DIRECTION_DOWNSTREAM;
            }
            else {
                ConnectedPinType = Pin_Input;
                Direction = KS_DIRECTION_UPSTREAM;
            }

            hr = ResolvePipeDimensions(ConnectedKsPin, ConnectedPinType, Direction);

            if (FAILED (hr) ) {
                RetCode = FALSE;
            }
        }
    }

    return  RetCode;

}


STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandlerCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    KS_FRAMING_FIXED           FramingExFixed;
    IKsPinPipe*                KsPinPipe = NULL;
    HRESULT                    hr;
    BOOL                       RetCode = TRUE;


    AllocSearch = (ALLOCATOR_SEARCH *) Param1;


    if (AllocSearch->FlagAssign) {
        //
        // Clear the allocator handler flag on all pins, this flag will be later set on one special pin.
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        KsPinPipe->KsSetPipeAllocatorFlag(0);
    }


    if ( GetFramingFixedFromPinByMemoryType( KsPin, AllocSearch->MemoryType, &FramingExFixed) ) {
        if (FramingExFixed.Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) {
            AllocSearch->NumberMustAllocators++;

            if (AllocSearch->NumberMustAllocators > 1) {
                //
                // There should not be more than 1 'MUST ALLOCATE' pin on a pipe.
                //
                *IsDone = 1;
                RetCode = FALSE;
            }
            else {
                AllocSearch->KsPin = KsPin;
                AllocSearch->PinType = PinType;
            }
        }
        else {
            if ( (! AllocSearch->NumberMustAllocators) && (FramingExFixed.Flags & KSALLOCATOR_FLAG_CAN_ALLOCATE) ) {
                AllocSearch->KsPin = KsPin;
                AllocSearch->PinType = PinType;
            }
        }
    }

    return RetCode;
}


STDMETHODIMP_(BOOL)
AssignPipeAllocatorHandler(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN GUID MemoryType,
    IN ULONG Direction,
    OUT IKsPin** KsAllocatorHandlerPin,
    OUT ULONG* AllocatorHandlerPinType,
    IN BOOL FlagAssign
    )
/*++

Routine Description:

    Finds the allocator handling pin on a given pipe corresponding to the specified MemoryType.
    If FlagAssign=1, then this routine assigns the allocator handling pin on a given pipe and
    marks the pipe as 'MUST ALLOCATE' if requested by any pin's framing.

    Walks the pins on KsPin-pipe, in the specified Direction.

    IF KsPin-pipe has 'MUST_ALLOCATE' pin
        Return the 'MUST ALLOCATE'pin
    ELSE
        Find the very first pin that explicitly supports MemoryType in its framing.
        Mark such pin as KsPin-pipe allocator handler and return TRUE.
        If no such pin found - return FALSE.
    ENDIF


Arguments:

    KsPin -
        pin that defines the pipe.

    PinType -
        KsPin type.

    MemoryType -
        memory type for the allocator to use.

    Direction -
        direction relative to KsPin to look for the allocator handler.

    KsAllocatorHandlerPin -
        returned pin that will be an allocator handler.

    AllocatorHandlerPinType -
        type of the KsAllocatorHandlerPin.

    FlagAssign -
        1 - do allocator handler assignment and set pipe flags - "assign allocator handler" operation.
        0 - don't set any pin/pipe allocators handler flags - just "find allocator handler" operation.


Return Value:

    TRUE on success.

--*/
{


    IKsPin*                    FirstKsPin;
    ULONG                      FirstPinType;
    IKsPin*                    BreakKsPin;
    IKsPinPipe*                KsPinPipe;
    IKsPinPipe*                AllocKsPinPipe;
    BOOL                       RetCode;
    HRESULT                    hr;
    ALLOCATOR_SEARCH           AllocSearch;
    PALLOCATOR_PROPERTIES_EX   AllocEx;
    IKsAllocatorEx*            KsAllocator;



    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

    KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly );
    AllocEx = KsAllocator->KsGetProperties();

    if ( (Direction == KS_DIRECTION_UPSTREAM) || (Direction == KS_DIRECTION_ALL) ) {
        RetCode = FindFirstPinOnPipe(KsPin, PinType, &FirstKsPin, &FirstPinType);
        ASSERT(RetCode);
    }
    else { // KS_DIRECTION_DOWNSTREAM
        FirstKsPin = KsPin;
        FirstPinType = PinType;
        RetCode = TRUE;
    }

    if (RetCode) {
        if ( Direction == KS_DIRECTION_UPSTREAM ) {
            BreakKsPin = KsPin;
        }
        else { // KS_DIRECTION_DOWNSTREAM or KS_DIRECTION_ALL
            BreakKsPin = NULL;
        }

        AllocSearch.MemoryType = MemoryType;
        AllocSearch.FlagAssign = FlagAssign;
        AllocSearch.KsPin = NULL;

        if ( (AllocEx->MemoryType == MemoryType) && (AllocEx->Flags & KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE) ) {
            AllocSearch.IsMustAllocator = 1;
        }
        else {
            AllocSearch.IsMustAllocator = 0;
        }
        AllocSearch.NumberMustAllocators = 0;

        RetCode = WalkPipeAndProcess(FirstKsPin, FirstPinType, BreakKsPin, AssignPipeAllocatorHandlerCallback, (PVOID*) &AllocSearch, NULL);

        if (! AllocSearch.KsPin) {
            RetCode = FALSE;
        }

        if (RetCode) {
            if (KsAllocatorHandlerPin) {
                *KsAllocatorHandlerPin = AllocSearch.KsPin;
            }

            if (AllocatorHandlerPinType) {
                *AllocatorHandlerPinType = AllocSearch.PinType;
            }

            if (FlagAssign) {

                if (AllocSearch.NumberMustAllocators) {
                    AllocEx->Flags |= KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE;
                }
                else {
                    AllocEx->Flags &= ~KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE;
                }

                GetInterfacePointerNoLockWithAssert(AllocSearch.KsPin, __uuidof(IKsPinPipe), AllocKsPinPipe, hr);

                AllocKsPinPipe->KsSetPipeAllocatorFlag(1);
            }
        }
        else {
            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AssignPipeAllocatorHandler returns FALSE, KsPin=%x, NumMustAlloc=%d"),
                    KsPin, AllocSearch.NumberMustAllocators));
        }
    }


    return (RetCode);

}


STDMETHODIMP_(BOOL)
AssignAllocatorsAndPipeIdForPipePinsCallback(
    IN IKsPin* KsPin,
    IN ULONG PinType,
    IN OUT PVOID* Param1,
    IN PVOID* Param2,
    OUT BOOL* IsDone
    )
{

    ALLOCATOR_SEARCH           *AllocSearch;
    HANDLE                     AllocatorHandle;
    KSPIN_COMMUNICATION        Communication;
    IKsObject*                 KsObject;
    KSPROPERTY                 PropertySetAlloc;
    KSPROPERTY                 PropertySetPipeId;
    ULONG                      BytesReturned;
    HRESULT                    hr;
    IPin*                      InPin = NULL;
    ULONG                      InPinCount = 0;
    IPin*                      OutPin;
    IKsPin**                   OutKsPinList = NULL;
    ULONG                      OutPinCount = 0;
    IKsAllocatorEx*            KsAllocator;
    IKsPinPipe*                KsPinPipe;
    IKsPin*                    Temp1KsPin;
    IKsPin*                    Temp2KsPin;
    ULONG                      i;
    BOOL                       IsAllocator;
    BOOL                       RetCode = TRUE;



    AllocSearch = (ALLOCATOR_SEARCH *) Param1;
    AllocatorHandle = (HANDLE) (*Param2);

    //
    // Unconditionally assign the Pipe Id to every pin on a pipe.
    //
    PropertySetPipeId.Set = KSPROPSETID_Stream;
    PropertySetPipeId.Id = KSPROPERTY_STREAM_PIPE_ID;
    PropertySetPipeId.Flags = KSPROPERTY_TYPE_SET;

    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

    hr = KsSynchronousDeviceControl(
        KsObject->KsGetObjectHandle(),
        IOCTL_KS_PROPERTY,
        &PropertySetPipeId,
        sizeof( PropertySetPipeId ),
        &AllocatorHandle,
        sizeof( HANDLE ),
        &BytesReturned );

    if ( SUCCEEDED( hr )) {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES PIPE_ID (AllocatorHandle=%x) assigned to Pin=%x"),
             AllocatorHandle, KsPin));
    }
    else {
        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN PIPE_ID (AllocatorHandle=%x) assigned to Pin=%x hr=%x"),
             AllocatorHandle, KsPin, hr));
    }

    //
    // The only candidates for Allocators-requestors are KSPIN_COMMUNICATION_SOURCE pins.
    // KSPIN_COMMUNICATION_BRIDGE pins do not communicate to outside filters.
    //
    KsPin->KsGetCurrentCommunication(&Communication, NULL, NULL);

    if ( (Communication & KSPIN_COMMUNICATION_SOURCE) && (! AllocSearch->FlagAssign) ) {
        //
        // We need to get a KsAllocator from this KsPin to use for
        // the following search of all the output pins on the same filter and
        // on the same pipe.
        //
        GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsPinPipe), KsPinPipe, hr);

        if ( ! (KsAllocator = KsPinPipe->KsGetPipe(KsPeekOperation_PeekOnly) ) ) {
            ASSERT(0);
            RetCode = FALSE;
        }
        else {
            PropertySetAlloc.Set = KSPROPSETID_Stream;
            PropertySetAlloc.Id = KSPROPERTY_STREAM_ALLOCATOR;
            PropertySetAlloc.Flags = KSPROPERTY_TYPE_SET;

            //
            // If this _SOURCE pin is an output pin then it must be an allocator,
            // since we are walking the pipe from upstream in this function.
            //
            // If this _SOURCE pin is an input pin then we check to see if there is any output _SOURCE
            // pin on the same pipe on the same filter.
            // If so, then this input pin is the allocator.
            // Otherwise - we should check to see whether this pin's filter is the last downstream
            // filter on this pipe.
            // If it is the last filter - then this _SOURCE pin must be an allocator,
            // otherwise - the allocator must be located further downstream.
            //
            if (PinType == Pin_Input) {

                if (! FindAllConnectedPinsOnPipe(KsPin, KsAllocator, NULL, &OutPinCount) ) {
                    //
                    // downstream pin belongs to different pipe (if not-in-place OR user-mode connection).
                    //
                    IsAllocator = 1;
                    OutPinCount = 0;
                }
                else {
                    IsAllocator = 0;

                    if (OutPinCount) {

                        OutKsPinList = new IKsPin* [ OutPinCount ];
                        if (! OutKsPinList) {
                            DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR OUTOFMEMORY AssignAllocatorsAndPipeIdForPipePinsCallback OutPinCount=%d"), OutPinCount));
                            RetCode = FALSE;
                        }
                        else {
                            //
                            // fill the pins.
                            //
                            if (! FindAllConnectedPinsOnPipe(KsPin, KsAllocator, &OutKsPinList[0], &OutPinCount) ) {
                                ASSERT(0);
                                RetCode = FALSE;
                            }
                            else {
                                //
                                // check to see if there is at least one output _SOURCE pin.
                                //
                                for (i=0; i<OutPinCount; i++) {
                                    OutKsPinList[i]->KsGetCurrentCommunication(&Communication, NULL, NULL);
                                    if (Communication & KSPIN_COMMUNICATION_SOURCE) {
                                        IsAllocator = 1;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                if ( RetCode &&
                     (IsAllocator ||
                     (! FindNextPinOnPipe(KsPin, Pin_Input, KS_DIRECTION_DOWNSTREAM, NULL, FALSE, &Temp1KsPin) ) ||
                     (! FindNextPinOnPipe(Temp1KsPin, Pin_Output, KS_DIRECTION_DOWNSTREAM, NULL, FALSE, &Temp2KsPin) ) ) ) {


                    GetInterfacePointerNoLockWithAssert(KsPin, __uuidof(IKsObject), KsObject, hr);

                    hr = KsSynchronousDeviceControl(
                        KsObject->KsGetObjectHandle(),
                        IOCTL_KS_PROPERTY,
                        &PropertySetAlloc,
                        sizeof( PropertySetAlloc ),
                        &AllocatorHandle,
                        sizeof( HANDLE ),
                        &BytesReturned );

                    if ( SUCCEEDED( hr )) {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ATTN AllocatorHandle=%x assigned to Pin=%x"),
                             AllocatorHandle, KsPin));
                    }
                    else {
                        DbgLog((LOG_MEMORY, 2, TEXT("PIPES ERROR AllocatorHandle=%x assigned to Pin=%x hr=%x"),
                             AllocatorHandle, KsPin, hr));
                    }

                    AllocSearch->FlagAssign = 1;
                }

            }
            else {
                //
                // This pin is the output pin and it is on a filter that provides the allocator.
                //
                // Also, since each pipe is walked separately, we only need to handle one pipe
                // at a time. There is no inter-dependencies between different pipes.
                //
                GetInterfacePointer