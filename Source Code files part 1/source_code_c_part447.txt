 ",
                                        length, ScBSBytePosition(BS)) );

  while (stat==NoErrors && length>0)
  {
    stat=ScBSPutBits(BS, (ScBitString_t)*buffer, 8);
    buffer++;
    length--;
  }
  return(stat);
}

/*
** ScBSPutBit()
** Put a single bit onto the bitstream
*/
ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit)
{
  ScStatus_t stat;
  const int shift=BS->shift;

  _SlibDebug(_DEBUG_, printf("ScBSPutBit(0x%lX): Byte offset = 0x%X ",
                                                bit, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_ && bit>1, printf("ScBSPutBit(): bit>1") );
  if (shift < (SC_BITBUFFSZ-1))
  {
    BS->OutBuff<<=1;
    if (bit)
      BS->OutBuff|=1;
    BS->shift=shift+1;
    stat=NoErrors;
  }
  else if (shift == SC_BITBUFFSZ-1)
  {
    if (bit)
      stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<1)+1);
    else
      stat=sc_BSStoreDataWord(BS, BS->OutBuff<<1);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    _SlibDebug(_DEBUG_, printf("BS Storing(0x%lX)\n", BS->OutBuff) );
    stat=sc_BSStoreDataWord(BS, BS->OutBuff);
    BS->OutBuff=bit;
    BS->shift=1;
  }
  BS->CurrentBit++;
  return(stat);
}

/*
** Name:    ScBSGetBitsVarLen()
** Purpose: Return bits from the bitstream. # bits depends on table
*/
int ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, int len)
{
  int index, lookup;

  index=(int)ScBSPeekBits(BS, len);
  lookup = table[index];
  _SlibDebug(_DEBUG_,
     printf("ScBSGetBitsVarLen(len=%d): Byte offset=0x%X table[%d]=0x%X Return=%d\n",
                      len, ScBSBytePosition(BS), index, lookup, lookup >> 6) );
  ScBSGetBits(BS, lookup & 0x3F);
  return(lookup >> 6);
}


#ifndef ScBSBitPosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBitPosition()
** Purpose: Return the absolute bit position in the stream
*/
long ScBSBitPosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit);
}
#endif

#ifndef ScBSBytePosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBytePosition()
** Purpose: Return the absolute byte position in the stream
*/
long ScBSBytePosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit>>3);
}
#endif

/*
** Name:    ScBSSeekAlign()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
** Return:  Returns TRUE if the sync was found otherwise it returns FALSE.
*/
int ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word, int word_len)
{
  _SlibDebug(_VERBOSE_,
            printf("ScBSSeekAlign(BS=%p, seek_word=0x%x, word_len=%d)\n",
                                    BS, seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlign(BS=%p) word_len=0\n", BS) );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );

#if USE_FAST_SEEK
  if (word_len%8==0 && word_len<=32 && !BS->EOI)  /* do a fast seek */
  {
    unsigned char *buff, nextbyte;
    const unsigned char byte1=(seek_word>>(word_len-8))&0xFF;
    int bytesinbuff;
    seek_word-=((ScBitString_t)byte1)<<word_len;
    word_len-=8;
    _SlibDebug(_VERIFY_ && seek_word >= (ScBitString_t)1<<word_len,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    if (BS->buffp>=(BS->shift/8)) /* empty OutBuff & InBuff */
    {
      BS->shift=0;
      BS->OutBuff=0;
      BS->InBuff=0;
      BS->buffp-=BS->shift/8;
    }
    else while (BS->shift) /* search whats in OutBuff & InBuff first */
    {
      _SlibDebug(_DEBUG_,
              printf("ScBSSeekAlign() Fast searching OutBuff & InBuff\n") );
      nextbyte=BS->OutBuff>>(SC_BITBUFFSZ-8);
      BS->shift-=8;
      BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
      BS->InBuff<<=8;
      BS->CurrentBit+=8;
      if (nextbyte==byte1
            && (word_len==0 || ScBSPeekBits(BS, word_len)==seek_word))
      {
        /* found seek_word in buffer */
        ScBSSkipBits(BS, word_len);
        return(!BS->EOI);
      }
    }
    _SlibDebug(_VERIFY_ && BS->shift,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    _SlibDebug(_VERIFY_ && BS->OutBuff,
       printf("ScBSSeekAlign(BS=%p) OutBuff (0x%lX) <> 0\n", BS, BS->OutBuff) );
    _SlibDebug(_VERIFY_ && BS->InBuff,
       printf("ScBSSeekAlign(BS=%p) InBuff (0x%lX) <> 0\n", BS, BS->InBuff) );

    bytesinbuff=BS->bufftop-BS->buffp;
    if (bytesinbuff<=0) /* Get more data if all out */
    {
      if (!sc_BSGetData(BS))
      {
        BS->EOI=TRUE;
        return(FALSE);
      }
      bytesinbuff=BS->bufftop;
    }
    buff=BS->buff+BS->buffp;
    switch (word_len/8)
    {
      case 0: /* word length = 1 byte */
              while (1)
              {
                if (*buff++==byte1)
                {
                  BS->buffp=buff-BS->buff;
                  BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                  _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X at pos %d (0x%X)\n",
                                 byte1, BS->CurrentBit/8, BS->CurrentBit/8) );
                  _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte1,
                    printf("ScBSSeekAlign() bad position for buffp\n") );
                  return(TRUE);
                }
                if ((--bytesinbuff)==0)
                {
                  if (!sc_BSGetData(BS))
                  {
                    BS->EOI=TRUE;
                    return(FALSE);
                  }
                  buff=BS->buff;
                  bytesinbuff=BS->bufftop;
                }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
              }
              break;
      case 1: /* word length = 2 bytes */
              {
                const unsigned char byte2=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      BS->buffp=buff-BS->buff;
                      BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                       printf("ScBSSeekAlign() Found %X %X at pos %d (0x%X)\n",
                            byte1, byte2, BS->CurrentBit/8, BS->CurrentBit/8) );
                      _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte2,
                         printf("ScBSSeekAlign() bad position for buffp\n") );
                      return(TRUE);
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 2: /* word length = 3 bytes */
              {
                const unsigned char byte2=(seek_word>>8)&0xFF;
                const unsigned char byte3=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        BS->buffp=buff-BS->buff;
                        BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                        _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte3,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                        return(TRUE);
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 3: /* word length = 4 bytes */
              {
                const unsigned char byte2=(seek_word>>16)&0xFF;
                const unsigned char byte3=(seek_word>>8)&0xFF;
                const unsigned char byte4=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        if ((--bytesinbuff)==0)
                        {
                          BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                          if (!sc_BSGetData(BS))
                          {
                            BS->EOI=TRUE;
                            return(FALSE);
                          }
                          buff=BS->buff;
                          bytesinbuff=BS->bufftop;
                        }
                        if (*buff++==byte4)
                        {
                          BS->buffp=buff-BS->buff;
                          BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                          _SlibDebug(_DEBUG_,
                 printf("ScBSSeekAlign() Found %X %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3, byte4,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                          _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte4,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                          return(TRUE);
                        }
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
       default:
              _SlibDebug(_VERIFY_,
                printf("ScBSSeekAlign() Bad fast word length %d\n", word_len) );
              break;
    }
  }
  else
#endif
  {  /* a slow seek */
    ScBitString_t val;
    const ScBitString_t maxi = ((ScBitString_t)1 << word_len)-(ScBitString_t)1;
    val = ScBSGetBits(BS, word_len);
    _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
    while ((val&maxi)!=seek_word && !BS->EOI)
      val = (val<<8)|ScBSGetBits(BS, 8);
    _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  }
  _SlibDebug(_WARN_,
            _debug_stop=BS->CurrentBit;
            if ((_debug_stop-_debug_start)>word_len)
              printf("ScBSSeekAlign() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
             );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlign() Exit with %s\n",
                                  BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopAt()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
**          Searches only until end_byte_pos is reached.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopAt(ScBitstream_t *BS, ScBitString_t seek_word,
                        int word_len, unsigned long end_byte_pos)
{
  ScBSPosition_t end_bit_pos=end_byte_pos<<3;
  ScBitString_t val;
  const ScBitString_t maxi = ((ScBitString_t)1 << word_len) - 1;

  _SlibDebug(_VERBOSE_,
       printf("ScBSSeekAlignStopAt(seek_word=0x%x, word_len=%d, end=%d)\n",
                                      seek_word, word_len, end_byte_pos) );
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);

  ScBSByteAlign(BS)
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);
  if ((BS->CurrentBit+word_len)>end_bit_pos)
  {
    ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
    return(FALSE);
  }
  val = ScBSGetBits(BS, word_len);
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  while ((val&maxi)!=seek_word && !BS->EOI)
  {
    if ((BS->CurrentBit+word_len)>end_bit_pos)
    {
      ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
      _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
      return(FALSE);
    }
    val <<= 8;
    val |= ScBSGetBits(BS, 8);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopAt() Exit with %s\n",
                                       BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBefore()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopBefore(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBefore() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 8);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekStopBefore()
** Purpose: Seeks for a word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, 
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_, 
             printf("ScBSSeekStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,  
              printf("ScBSSeekStopBefore() word_len=0\n") );

  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 1);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_, 
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBeforeW()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
**
** NB: This version uses Dolby style word loading for bitstream
*/
int ScBSSeekAlignStopBeforeW(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBeforeW(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBeforeW() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoadW(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBitsW(BS, 8);
    ScBSPreLoadW(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBeforeW() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBeforeW() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSGetBytesStopBefore()
** Purpose: Gets all the bytes until seek_word (byte aligned)
**          is encountered.
**          Searches only until 'length' bytes are read.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, u_int length,
                           u_int *ret_length, ScBitString_t seek_word,
                           int word_len)
{
  unsigned long offset=0;
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSGetBytesStopBefore(seek_word=0x%x, word_len=%d)\n",
                                       seek_word, word_len) );
  ScBSByteAlign(BS)
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len) != seek_word &&
             offset<length && !BS->EOI)
  {
    *buffer = (unsigned char)ScBSGetBits(BS, 8);
    buffer++;
    offset++;
    ScBSPreLoad(BS, word_len);
  }

  *ret_length=offset;
  _SlibDebug(_DEBUG_,
             printf("ScBSGetBytesStopBefore(ret_length=%d) Exit with %s\n",
               *ret_length, (BS->EOI||offset>=length) ? "FALSE" : "TRUE") );
  if (BS->EOI || offset>=length)
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScBSFlush()
** Purpose: Flushes data from the buffers
*/
ScStatus_t ScBSFlush(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() In\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if ((BS->Mode=='w' || BS->Mode=='b') && BS->buffp>0)
  {
    if (BS->shift>0) /* some remaining bits in internal buffers */
    {
      /* byte align last bits */
      ScBSAlignPutBits(BS);
      if (BS->buffp>=BS->bufftop)
        stat=sc_BSPutData(BS);
      /* Copy the remaining bytes in OutBuff to the current buffer */
      while (BS->shift>0 && BS->buffp<BS->bufftop)
      {
        BS->shift-=8;
        BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
      }
      stat=sc_BSPutData(BS);
      if (BS->shift>0) /* still some bytes left */
      {
        while (BS->shift>0 && BS->buffp<BS->bufftop)
        {
          BS->shift-=8;
          BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
        }
        stat=sc_BSPutData(BS);
      }
    }
    else
      stat=sc_BSPutData(BS);
  }
  ScBSReset(BS);  /* release and re-initialize buffer pointers */
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() Out\n") );
  return(stat);
}

/*
** Name:    ScBSResetCounters()
** Purpose: Resets the bit position counters to zero
*/
ScStatus_t ScBSResetCounters(ScBitstream_t *BS)
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->CurrentBit=0;
  return(NoErrors);
}

/*
** Name:    ScBSFlushSoon()
** Purpose: Flushes data from the buffers at the next
**          32 or 64 bit boundary
*/
ScStatus_t ScBSFlushSoon(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlushSoon()\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if (BS->Mode=='w' || BS->Mode=='b')
    BS->Flush=TRUE;
  return(stat);
}

/*
** Name:    ScBSDestroy()
** Purpose: Destroys a bitstream (Closes and frees associated memory)
**          created using ScBSCreateFromBufferQueue() or
**          ScBSCreateFromFile()
*/
ScStatus_t ScBSDestroy(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSDestroy\n") );
  if (!BS)
    return(ScErrorBadPointer);

/* We won't flush automatically
  if (BS->Mode=='w' || BS->Mode=='b')
    ScBSFlush(BS);
*/
  if (BS->RdBufAllocated)
    ScFree(BS->RdBuf);
  ScFree(BS);
  return(stat);
}

/*********************** Buffer/Image Queue Management ***********************/
/*                                                                           */
/* ScBufQueueCreate()  - Create a buffer queue                               */
/* ScBufQueueDestroy() - Destroy a buffer queue                              */
/* ScBufQueueAdd()     - Add a buffer to tail of a queue                     */
/* ScBufQueueRemove()  - Remove the buffer at the head of a queue            */
/* ScBufQueueGetNum()  - Return number of buffers in a queue                 */
/* ScBufQueueGetHead() - Return info about buffer at head of a queue         */
/*                                                                           */
/*****************************************************************************/


ScStatus_t ScBufQueueCreate(ScQueue_t **Q)
{
  if ((*Q = (ScQueue_t *)ScAlloc(sizeof(ScQueue_t))) == NULL)
    return(ScErrorMemory);
  (*Q)->NumBufs = 0;
  (*Q)->head = (*Q)->tail = NULL;
  _SlibDebug(_QUEUE_, printf("ScBufQueueCreate() Q=%p\n",*Q) );
  return(NoErrors);
}

ScStatus_t ScBufQueueDestroy(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy(Q=%p)\n",Q) );
  if (!Q)
    return(ScErrorBadArgument);
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy()\n") );

  while (ScBufQueueGetNum(Q))
    ScBufQueueRemove(Q);

  ScFree(Q);
  return(NoErrors);
}

ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size, int Type)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Type = Type;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueRemove(ScQueue_t *Q)
{
  struct ScBuf_s *head;
  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove(Q=%p)\n",Q) );

  if (!Q)
    return(ScErrorBadPointer);

  if (!(head = Q->head))
    return(ScErrorBadQueueEmpty);

  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove() Data=%p Size=%d\n",
                            Q->head->Data,Q->head->Size) );
  Q->head = head->Prev;
  if (!Q->head)
    Q->tail = NULL;
  Q->NumBufs--;
  ScFree(head);
  return(NoErrors);
}

int ScBufQueueGetNum(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetNum(Q=%p) num=%d\n",
                             Q, Q ? Q->NumBufs : 0) );
  return(Q ? Q->NumBufs : 0);
}

ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data, int *Size)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHead() Data=%p Size=%d\n",
                               Q->head->Data,Q->head->Size) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  return(NoErrors);
}

ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data, int *Size,
                                 int *Type)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    if (Type) *Type = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHeadExt() Data=%p Size=%d Type=%d\n",
                               Q->head->Data,Q->head->Size,Q->head->Type) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  if (Type) *Type = Q->head->Type;
  return(NoErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\scon_int.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_internals.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_INTERNALS_H_
#define _SCON_INTERNALS_H_

#include "scon.h"

typedef struct SconVideoInfo_s {
  dword         Width;
  dword         Height;
  SconBoolean_t NegHeight; /* height is negative */
  dword         Stride;
  dword         FourCC;
  dword         BPP;       /* bits per pixel */
  dword         Pixels;    /* total pixels in a frame */
  dword         ImageSize; /* image size in bytes */
  dword         RGBmasks;  /* 565, 555, 888 */
  dword         Rmask;     /* Red mask */
  dword         Gmask;     /* Green mask */
  dword         Bmask;     /* Blue mask */
} SconVideoInfo_t;

typedef struct SconAudioInfo_s {
  dword SPS;      /* samples per second: 8000, 11025, 22050, etc */
  dword BPS;      /* bits per sample: 8 or 16 */
  dword Channels; /* channels: 1=mono, 2=stereo */
} SconAudioInfo_t;

typedef struct SconInfo_s {
  SconMode_t        Mode;
  SconBoolean_t     InputInited;  /* input format has been setup */
  SconBoolean_t     OutputInited; /* output format has been setup */
  SconBoolean_t     SameFormat;   /* input and output are the same format */
  SconBoolean_t     Flip;         /* image must be flipped when converted */
  SconBoolean_t     ScaleDown;    /* input image is being scaled down */
  SconBoolean_t     ScaleUp;      /* input image is being scaled up */
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Input;
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Output;
  unsigned char    *FImage;        /* format conversion image buffer */
  dword             FImageSize;
  unsigned char    *SImage;        /* scaling image buffer */
  dword             SImageSize;
  void             *Table;         /* conversion lookup table */
  dword             TableSize;
  void             *dbg;           /* debug handle */
} SconInfo_t;

/********************** Private Prototypes ***********************/
/*
 * scon_video.c
 */
unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo);
SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize);

/*
 * scon_yuv_to_rgb.c
 */
SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info);
SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info);
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);

#endif /* _SCON_INTERNALS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\scon.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_H_
#define _SCON_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"

typedef void       *SconHandle_t;
typedef ScBoolean_t SconBoolean_t;

typedef enum {
  SCON_MODE_NONE,
  SCON_MODE_VIDEO,  /* Video conversions */
  SCON_MODE_AUDIO   /* Audio conversions */
} SconMode_t;

typedef enum {
  SconErrorNone = 0,
  SconErrorInternal,
  SconErrorMemory,
  SconErrorBadArgument,
  SconErrorBadHandle,
  SconErrorBadMode,
  SconErrorUnsupportedFormat,
  SconErrorBufSize,
  SconErrorUnsupportedParam,
  SconErrorImageSize,        /* Invalid image height and/or width */
  SconErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SconErrorInit,             /* initialization error */
} SconStatus_t;

typedef enum {
  SCON_INPUT = 1,
  SCON_OUTPUT = 2,
  SCON_INPUT_AND_OUTPUT = 3,
} SconParamType_t;

typedef enum {
  /* SCON Parameters */
  SCON_PARAM_VERSION=0x00,  /* SCON version number */
  SCON_PARAM_VERSION_DATE,  /* SCON build date */
  SCON_PARAM_DEBUG,         /* debug handle */
  SCON_PARAM_KEY,           /* SCON security key */
  /* Video Parameters */
  SCON_PARAM_WIDTH=0x100,
  SCON_PARAM_HEIGHT,
  SCON_PARAM_STRIDE,            /* bytes between scan lines */
  SCON_PARAM_IMAGESIZE,
  SCON_PARAM_VIDEOFORMAT,
  SCON_PARAM_VIDEOBITS,
  SCON_PARAM_VIDEOQUALITY,      /* video quality */
} SconParameter_t;

typedef qword SconListParam1_t;
typedef qword SconListParam2_t;

typedef struct SconList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SconListParam1_t param1;
  SconListParam2_t param2;
} SconList_t;

/********************** Public Prototypes ***********************/
/*
 * scon_api.c
 */
EXTERN SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                             void *informat, void *outformat);
EXTERN SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                void *outbuf, dword outbufsize);
EXTERN SconBoolean_t SconIsSame(SconHandle_t handle);
EXTERN SconStatus_t SconClose(SconHandle_t handle);
EXTERN SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value);

#endif /* _SCON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_conv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_convert.h,v $
 * Revision 1.1.9.4  1996/09/29  22:19:34  Hans_Graves
 * 	Added stride argument to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:43  Hans_Graves]
 *
 * Revision 1.1.9.3  1996/09/18  23:45:50  Hans_Graves
 * 	Added protos for ScRgbToYuv411(), 411sTo422i, 411sTo422s,
 * 	and 1611PlanarTo411
 * 	[1996/09/18  23:31:09  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/08/20  22:11:52  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:26  Bjorn_Engberg]
 * 
 * Revision 1.1.6.5  1996/04/11  20:22:02  Hans_Graves
 * 	Removed protos for GetDitherTemplate10/15(), their static now.
 * 	[1996/04/11  20:05:44  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:19  Hans_Graves
 * 	Added _S after assembly routines
 * 	[1996/04/10  21:21:54  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:34  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:31  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:02  Hans_Graves
 * 	Cleaned up convert protos
 * 	[1996/03/29  21:46:48  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/08  16:20:39  Bjorn_Engberg
 * 	Got rid of compiler warning messages.
 * 	[1996/01/08  15:23:14  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1996/01/02  18:31:15  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:03  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:21  Hans_Graves
 * 	Added prototype for ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:41  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/11/30  20:17:04  Hans_Graves
 * 	Renamed ScYuvToRgb() to ScYuv422toRgb()
 * 	[1995/11/30  20:10:09  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/11/28  22:47:31  Hans_Graves
 * 	Added prototype for ScYuv1611ToRgb()
 * 	[1995/11/28  21:34:55  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/11/17  21:31:25  Hans_Graves
 * 	Added prototype for ScYuv411ToRgb()
 * 	[1995/11/17  20:51:27  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/10/17  15:37:05  Karen_Dintino
 * 	Move DitherTemplate routines from render to common
 * 	[1995/10/17  15:36:49  Karen_Dintino]
 * 
 * Revision 1.1.2.14  1995/10/13  16:57:16  Bjorn_Engberg
 * 	Added prototypes for routines in sc_convert_yuv.c
 * 	[1995/10/13  16:48:55  Bjorn_Engberg]
 * 
 * Revision 1.1.2.13  1995/10/10  21:43:04  Bjorn_Engberg
 * 	Modified RgbToYuv prototype declarations.
 * 	[1995/10/10  21:10:52  Bjorn_Engberg]
 * 
 * Revision 1.1.2.12  1995/10/06  20:46:29  Farokh_Morshed
 * 	Change ScRgbInterlToYuvInterl to take a Bmh by reference
 * 	[1995/10/06  20:46:06  Farokh_Morshed]
 * 
 * Revision 1.1.2.11  1995/10/02  19:30:52  Bjorn_Engberg
 * 	Added more BI_BITFIELDS formats.
 * 	[1995/10/02  18:15:47  Bjorn_Engberg]
 * 
 * Revision 1.1.2.10  1995/09/26  15:58:48  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:12  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/09/22  12:58:40  Bjorn_Engberg
 * 	Changed uchar to u_char in a function prototype.
 * 	[1995/09/22  12:48:40  Bjorn_Engberg]
 * 
 * Revision 1.1.2.8  1995/09/20  17:39:19  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:04  Karen_Dintino]
 * 
 * Revision 1.1.2.7  1995/09/18  19:47:49  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:15  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1995/09/15  18:17:47  Farokh_Morshed
 * 	Move ValidBI_BITFIELDSKinds from SC.h to SC_convert.h
 * 	[1995/09/15  18:17:19  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/09/14  14:40:35  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:25:20  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/09/11  19:17:25  Hans_Graves
 * 	Added ValidateBI_BITFIELDS() prototype.
 * 	[1995/09/11  19:14:45  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/08/03  15:01:09  Hans_Graves
 * 	Added prototype for ScConvert422ToYUV_char()
 * 	[1995/08/03  15:00:49  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:23  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:22:50  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
** Filename: SC_convert.h
** Purpose:  Header info for using conversion routines.
*/

#include "SC.h"

enum ValidBI_BITFIELDSKinds {
  pRGB,		/* 32-bit 00RRGGBB special case */
  pBGR,		/* 32-bit 00BBGGRR special case */
  pRGB555,	/* 16-bit 0RRRRRGGGGGBBBBB special case */
  pRGB565,	/* 16-bit RRRRRGGGGGGBBBBB special case */
  pRGBnnn,	/* 16-bit general case */
  InvalidBI_BITFIELDS
};

/*********************** Prototypes *************************/
/*
** sc_convert.c
*/
EXTERN enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(LPBITMAPINFOHEADER lpbi);
EXTERN int ScIsUpsideDown(BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors);
extern ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				 BITMAPINFOHEADER *OutBmh,
				 u_char *OutImage,
				 u_char *YData, u_char *CbData, u_char *CrData);
extern ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut,
                         int width, int height, long stride);
extern ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
                        u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh,
                              u_char *R, u_char *G, u_char *B, u_short *ImageOut);
extern ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                        u_char *Y, u_char *U, u_char *V, int width, int height);
extern ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
extern ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
EXTERN ScStatus_t ScRgbInterlToYuvInterl (LPBITMAPINFOHEADER Bmh, int Width,
			int Height, u_char *ImageIn, u_short *ImageOut);
extern ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern int ScConvert422ToBlockYUV(u_char *, int, float *, float *, float *,
                                    int, int);
extern void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
                            float *Comp1, float *Comp2, float *Comp3,
                            int Width, int Height);
extern void ScConvertGrayToBlock (u_char *RawImage, int bpp,
                       float *Comp1, int Width, int Height);
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height);
extern ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *Cb, u_char *Cr, 
                                  long width, long height);
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern ScStatus_t ScConvert1611sTo411s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                         int Width, int Height);
extern ScStatus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride);
/*
** sc_convert2.s
*/
extern void ScConvert422iTo422sf_S(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern int ScSepYUVto422i_S(u_char *Y, u_char *U,
                          u_char *V, u_char *ImageOut,
                          u_int width, u_int height);
extern ScStatus_t ScConvert422ToYUV_char_S(u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_S(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );


/*
** sc_convert_yuv.c
*/

extern int ScInitYUVcvt();
extern int ScInitYUVtoRGB(void **pColpack,
			  BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern int sc_SIFrenderYUVtoRGBnn(u_char *pY, u_char *pU, u_char *pV,
				  u_char *Oimage,
				  void *Colpack,
				  int pixels, int lines);
extern void YUV_To_RGB_422_Init(int bSign, int bBGR, _int64 * pTable);


#ifdef USE_C
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_C
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_C
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_C
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_C
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#else /* USE_C */
#define ScConvert422ToYUV_char   ScConvert422ToYUV_char_S
#define ScConvert422PlanarTo422i ScConvert422PlanarTo422i_S
#define ScConvert411sTo422i      ScConvert411sTo422i_C
#define ScConvert411sTo422s      ScConvert411sTo422s_C
#define ScSepYUVto422i           ScSepYUVto422i_S
#define ScConvert422PlanarTo411  ScConvert422PlanarTo411_C
#define ScConvertNTSC422toCIF411 ScConvertNTSC422toCIF411_C
#define ScConvert422iTo422s      ScConvert422iTo422s_C
#define ScConvert422iTo422sf     ScConvert422iTo422sf_S
#define ScConvert1611sTo411s     ScConvert1611sTo411s_C
#define ScConvert411sTo1611s     ScConvert411sTo1611s_C
#define ScConvert1611sTo422s     ScConvert1611sTo422s_C
#define ScConvert1611sTo422i     ScConvert1611sTo422i_C
#define ScConvertRGB24sTo422i    ScConvertRGB24sTo422i_C
#define ScConvertRGB24To411s     ScConvertRGB24To411s_C
#define ScConvertRGB555To411s    ScConvertRGB555To411s_C
#define ScConvertRGB565To411s    ScConvertRGB565To411s_C
#endif /* USE_C */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_conv.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_convert.c,v $
 * Revision 1.1.8.6  1996/10/28  17:32:17  Hans_Graves
 * 	Add use IsYUV422Sep() macro in ScConvertSepYUVToOther().
 * 	[1996/10/28  16:51:30  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/10/02  18:42:50  Hans_Graves
 * 	Fix RGB 24-bit conversion in ScYuv411ToRgb().
 * 	[1996/10/02  18:32:51  Hans_Graves]
 *
 * Revision 1.1.8.4  1996/09/29  22:19:32  Hans_Graves
 * 	Added stride support to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:17  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/09/18  23:45:34  Hans_Graves
 * 	Added ScConvert1611PlanarTo411_C, ScConvert411sTo422s_C, and ScRgbToYuv411
 * 	[1996/09/18  21:52:27  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/05/07  19:55:42  Hans_Graves
 * 	Added YUV 4:1:1 to RGB 32-bit conversion - C code
 * 	[1996/05/07  19:44:38  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/11  20:21:57  Hans_Graves
 * 	Moved ScIsUpsideDown() from sc_convert_yuv.c
 * 	[1996/04/11  20:03:44  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/09  16:04:24  Hans_Graves
 * 	Added ValidateBI_BITFIELDS(). Fixed BI_RGB 16 bit conversion in ScYuv411ToRgb()
 * 	[1996/04/09  14:46:27  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/03  21:41:07  Hans_Graves
 * 	Change include path for <mmsystems.h>
 * 	[1996/04/03  21:37:55  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/02/22  17:35:17  Bjorn_Engberg
 * 	Added support for BI_BITFIELDS 16 and BI_RGB 32 rendering.
 * 	[1996/02/22  17:31:35  Bjorn_Engberg]
 *
 * Revision 1.1.4.3  1996/01/02  18:30:33  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts
 * 	[1996/01/02  15:21:27  Bjorn_Engberg]
 *
 * Revision 1.1.4.2  1995/12/07  19:31:15  Hans_Graves
 * 	Added ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:00  Hans_Graves]
 *
 * Revision 1.1.2.21  1995/11/30  20:17:02  Hans_Graves
 * 	Cleaned up ScYuv422toRgb() routine
 * 	[1995/11/30  20:13:26  Hans_Graves]
 *
 * Revision 1.1.2.20  1995/11/28  22:47:28  Hans_Graves
 * 	Make XIMAGE 24 identical to BI_BITFIELDS pBGR
 * 	[1995/11/28  22:26:11  Hans_Graves]
 *
 * 	Added ScYuv1611ToRgb() routine for use by Indeo
 * 	[1995/11/28  21:34:28  Hans_Graves]
 *
 * Revision 1.1.2.19  1995/11/17  21:31:21  Hans_Graves
 * 	Add ScYuv411ToRgb() conversion routine.
 * 	[1995/11/17  20:50:51  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/10/25  18:19:18  Bjorn_Engberg
 * 	Support Upside Down in ScRgbInterlToYuvInterl().
 * 	[1995/10/25  18:05:18  Bjorn_Engberg]
 *
 * Revision 1.1.2.17  1995/10/10  21:43:02  Bjorn_Engberg
 * 	Speeded up RgbToYuv code and made it table driven.
 * 	[1995/10/10  21:21:48  Bjorn_Engberg]
 *
 * Revision 1.1.2.16  1995/10/09  19:44:31  Bjorn_Engberg
 * 	Removed ValidateBI_BITFIELDS(), it's now in sc_convert_yuv.c
 * 	[1995/10/09  19:44:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.15  1995/10/06  20:43:23  Farokh_Morshed
 * 	Enhance ScRgbInterlToYuvInterl to handle BI_BITFIELDS
 * 	[1995/10/06  20:42:43  Farokh_Morshed]
 *
 * Revision 1.1.2.14  1995/10/02  19:30:26  Bjorn_Engberg
 * 	Added support for Assebler YUV to RGB routines.
 * 	[1995/10/02  18:39:05  Bjorn_Engberg]
 *
 * Revision 1.1.2.13  1995/09/28  20:37:53  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:37:39  Farokh_Morshed]
 *
 * Revision 1.1.2.12  1995/09/26  15:58:47  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:09  Paul_Gauthier]
 *
 * Revision 1.1.2.11  1995/09/22  18:56:35  Paul_Gauthier
 * 	{** Merge Information **}
 * 	      {** Command used:       bsubmit **}
 * 	      {** Ancestor revision:  1.1.2.7 **}
 * 	      {** Merge revision:     1.1.2.10 **}
 * 	{** End **}
 * 	Use faster method for 16bit YUV output for TGA2
 * 	[1995/09/22  18:39:55  Paul_Gauthier]
 *
 * Revision 1.1.2.10  1995/09/21  18:26:45  Farokh_Morshed
 * 	When BI_RGB or BI_BITFIELDS, invert the image while translating from
 * 	YUV to RGB.  Also fix the coefficient for the YUV colors.
 * 	This work was actually done by Bjorn
 * 	[1995/09/21  18:26:19  Farokh_Morshed]
 *
 * Revision 1.1.2.9  1995/09/20  17:39:18  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:22  Karen_Dintino]
 *
 * Revision 1.1.2.8  1995/09/20  14:59:31  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.7  1995/09/18  19:47:47  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:13  Paul_Gauthier]
 *
 * Revision 1.1.2.6  1995/09/14  14:40:34  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:26:13  Karen_Dintino]
 *
 * Revision 1.1.2.5  1995/09/11  18:47:25  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.3 **}
 * 		{** Merge revision:	1.1.2.4 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:43:39  Farokh_Morshed]
 *
 * Revision 1.1.2.4  1995/09/05  17:17:34  Paul_Gauthier
 * 	Fix for softjpeg decompression JPEG -> BICOMP_DECYUVDIB
 * 	[1995/09/05  17:17:09  Paul_Gauthier]
 *
 * Revision 1.1.2.3  1995/08/03  15:01:06  Hans_Graves
 * 	Moved ScConvert422ToYUV_char_C() from h261.
 * 	[1995/08/03  14:46:23  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:27  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:06:30  Hans_Graves]
 *
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
**
**  Miscellaneous conversion utility subroutines
**
**  Author(s): Victor Bahl
**  Date:      May 27, 1993
**
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <mmsystem.h>
#else /* !WIN32 */
#include <mmsystem.h>
#endif /* !WIN32 */

#include "SC_conv.h"
#include "SC_err.h"

#ifndef BI_DECSEPRGBDIB
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#endif

#define NEW_YCBCR		/* Use new YUV to RGB coefficients */

/*
** Name:     ScCreateBMHeader
** Purpose:  Allocate memory for a (Microsoft specified) bitmap header and
**           fill in the appropriate fields
**
*/
BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors)
{
    BITMAPINFOHEADER *pHead;
    int struct_size = sizeof(BITMAPINFOHEADER) + ncolors*sizeof(RGBQUAD);

    if ((pHead = (BITMAPINFOHEADER *)ScAlloc(struct_size)) == NULL) {
       puts("Can't Allocate memory for image headers");
       return NULL;
    }

    pHead->biSize          = sizeof(BITMAPINFOHEADER);
    pHead->biWidth         = width;
    pHead->biHeight        = height;
    pHead->biPlanes        = 1;
    pHead->biBitCount      = (WORD)bpp;
    pHead->biCompression   = format;
    pHead->biSizeImage     = 0;
    pHead->biXPelsPerMeter = 0;
    pHead->biYPelsPerMeter = 0;
    pHead->biClrUsed       = ncolors;
    pHead->biClrImportant  = 0;

    return pHead;
}

/*
** Function: ScIsUpsideDown
** Descript: Return TRUE if the current combination
** of input and output formats and image
** heights means that the image should be
** flipped during the render stage.
*/
int ScIsUpsideDown( BITMAPINFOHEADER *lpbiIn,
                    BITMAPINFOHEADER *lpbiOut )
{
    int ups = 0 ;
    if( lpbiIn )
      ups = (((lpbiIn->biCompression == BI_RGB) ||
              (lpbiIn->biCompression == BI_BITFIELDS)) ^
             ((int) lpbiIn->biHeight < 0)) ;
    if( lpbiOut )
      ups ^= (((lpbiOut->biCompression == BI_RGB) ||
               (lpbiOut->biCompression == BI_BITFIELDS)) ^
              ((int) lpbiOut->biHeight < 0)) ;
    return ups ;
}

/*
**++
**  FUNCTIONAL_DESCRIPTION:
**	Return an enum value that validates a BI_BITFIELDS bitmapinfoheader
**      with BI_BITFIELDS format.
**
**  FORMAL PARAMETERS:
**	Pointer to bitmapinfoheader
**  RETURN VALUE:
**	A value from enum type ValidBI_BITFIELDSKinds.
**/
enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(
    LPBITMAPINFOHEADER 	lpbi)
{
    DWORD *MaskPtr;

    if (lpbi == NULL || lpbi->biCompression != BI_BITFIELDS)
        return InvalidBI_BITFIELDS;

    MaskPtr = (DWORD *)&lpbi[1];

    /*
     * For 32-bit BI_BITFIELDS, we support
     * only the special cases 00RRGGBB and 00BBGGRR.
     */

    if( lpbi->biBitCount == 32 ) {
	if (MaskPtr[1] != 0x0000FF00U)
	    return InvalidBI_BITFIELDS;
	else if (MaskPtr[0] == 0x00FF0000U && MaskPtr[2] == 0x000000FFU)
	    return pRGB;
	else if (MaskPtr[0] == 0x000000FFU && MaskPtr[2] == 0x00FF0000U)
            return pBGR;
	else
	    return InvalidBI_BITFIELDS;
    }

#ifdef WIN32
    /*
     * For 16-bit BI_BITFIELDS, we support any legal
     * color arrangement, but RGB565 and RGB555 are
     * recognized as special since we have extra
     * fast assembler code for those cases.
     */

    else if( lpbi->biBitCount == 16 ) {
	int i ;
	if( MaskPtr[2] == 0x001f ) {
	    if( MaskPtr[0] == 0xf800 && MaskPtr[1] == 0x07e0 )
	    	return pRGB565 ;
	    else if( MaskPtr[0] == 0x7c00 && MaskPtr[1] == 0x03e00 )
	    	return pRGB555 ;
	}
	/*
	 * Generic case: First make sure that each mask is
	 * a 16-bit mask.
	 */

	if( (MaskPtr[0] | MaskPtr[1] | MaskPtr[2]) & ~0x0000ffff )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Masks must not overlap.
	 */

	if( (MaskPtr[0] & MaskPtr[1]) ||
	    (MaskPtr[0] & MaskPtr[2]) ||
	    (MaskPtr[1] & MaskPtr[2]) )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Make sure each mask contains a contiguous
	 * sequence of 1's (or is 0).
	 */

	for( i=0 ; i<3 ; i++ ) {
	   DWORD v = MaskPtr[i] ;
	   if( (((v-1)|v)+1)&v )
	       return InvalidBI_BITFIELDS ;	
	}

	/*
	 * If we pass all these tests, we have
	 * a valid generic 16-bit BI_BITFIELDS case.
	 */

	return pRGBnnn ;
    }

#endif /* WIN32 */

    /*
     * No other biBitCounts are supported.
     */

    return InvalidBI_BITFIELDS ;
}

/*********************** Conversion Routines ***************************/

static void sc_ExtractBlockNonInt(u_char *InData, float **OutData,
	   		          int ByteWidth, int x, int y)
{
  register int i,j;
  u_char *Inp, *IStart = InData + 8*y*ByteWidth + 8*x;

  for (i = 0 , Inp = IStart ; i < 8 ; i++ , Inp += ByteWidth)
    for (j = 0 ; j < 8 ; j++)
      *((*OutData)++) = (float)((int)(*Inp++) - 128);
}


/*
** Name:     ScConvertSepYUVToOther
** Purpose:  Convert Seperated YUV 422 to another format
**
*/
ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				  BITMAPINFOHEADER *OutBmh,
				  u_char *OutImage,
				  u_char *YData, u_char *CbData, u_char *CrData)
{
    /*
    ** no need to do extensive checking, DecompressBegin and CompressBegin
    ** should take care of static checking (eg. valid output colorspace
    */


    /*
    ** Are we converting from SepYUV to RGB ?
    */
    if ((OutBmh->biCompression == BI_RGB)              ||
        (OutBmh->biCompression == BI_BITFIELDS)        ||
        (OutBmh->biCompression == BI_DECXIMAGEDIB) ||
	(OutBmh->biCompression == BI_DECSEPRGBDIB)) {
        /*
	** It is assumed that YUV is subsampled 4:2:2, we will need to
	** generalize the code below to handle other cases as well -- VB
	*/
        if (InBmh->biBitCount == 8)
	  ScYuv422ToRgb (OutBmh, YData, NULL, NULL, OutImage);
        else
	  ScYuv422ToRgb (OutBmh, YData, CbData, CrData, OutImage);
    }
    /*
    ** Are we converting from SepYUV to Interlaced YUV ?
    */
    else if (IsYUV422Sep(OutBmh->biCompression))
    {
       /*
       ** It is assumed that YUV is subsampled 4:2:2, we will need to
       ** generalize the code below to handle other cases as well
       **   XXX - Bad idea to do this here, should be done as part of
       **         decompression (VB)
       **   XXX - While we can move the Sep YUV to 422 interleaved
       **         to decompression, we also need a copy here so we
       **         can use this as a general purpose dither'ing
       **         device. (JPL)
       */
       int i, j;

       /*
       ** If the input format is Mono JPEG and the output format is
       ** packed YUV422, we must reset the U and V values to neutral (Gray).
       */
       if (InBmh->biBitCount == 8) {
#ifdef __alpha
         /*
	  * If we're an Alpha, and the buffer is quadword
	  * aligned, we can use 64-bit transfers.
	  */
         if( ((INT_PTR) OutImage & 0x7) == 0 )
	   {
	     _int64 val   = 0x7f007f007f007f00L ;
	     _int64 *iptr = (_int64 *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>2) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         else
#endif /* __alpha */
	   {
	     int val   = 0x7f007f00 ;
	     int *iptr = (int *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>1) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         /*
	 ** Plug in the luminance samples
	 */
         for( i=(OutBmh->biWidth * abs(OutBmh->biHeight)) ; i>0 ; i-- ) {
           *OutImage = *YData++;
           OutImage +=2;
         }
       }
       /*
       ** Color input
       */
       else {
	 /* If this is quad padded in both X and Y and quad aligned,
	 ** we can call the assembly routine
	 */
	 if ( (abs(OutBmh->biHeight) & 0x7) == 0 &&
	     (OutBmh->biWidth & 0x7) == 0 &&
	     ((ULONG_PTR)OutImage & 0xf) == 0 )
	   {
	     ScConvert422PlanarTo422i(YData, CbData, CrData, OutImage,
				      OutBmh->biWidth, abs(OutBmh->biHeight));
	   }
	 else {
	   for (i=0; i<abs(OutBmh->biHeight); i++)
	     /* Remember, pixels are 16 bit in interleaved YUV. That
	     ** means the 4 bytes below represent two pixels so our
	     ** loop should be for half the width.
	     */
	     for (j=0; j<OutBmh->biWidth>>1; j++) {     /* Note: was j+=2 */
	       *OutImage++ = *YData++;
	       *OutImage++ = *CbData++;
	       *OutImage++ = *YData++;
	       *OutImage++ = *CrData++;
	     }
	 }
       }
    }
    else return(ScErrorUnrecognizedFormat);

    return(ScErrorNone);
}

/*
** Name:    ScYuv411ToRgb
** Purpose: convert 16-bit YCrCb 4:1:1 to an 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
*/
ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut, int Width, int Height, long stride)
{
   const int pixels = Width;
   int lines  = Height;
   register int row, col;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 2x2 matrix of pixels */
   int R1,R2,R3,R4;
   int G1,G2,G3,G4;
   int B1,B2,B3,B4;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y1=Y, *Y2=Y+pixels;
#define _LoadRGBfrom411() \
         R1 = R2 = R3 = R4 = (int) (              + (1.596 * V)); \
         G1 = G2 = G3 = G4 = (int) (- (0.391 * U) - (0.813 * V)); \
         B1 = B2 = B3 = B4 = (int) (+ (2.018 * U)              ); \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R1 += Luma; G1 +=Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R2 += Luma; G2 +=Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         } \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R3 += Luma; G3 +=Luma; B3 += Luma; \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R4 += Luma; G4 +=Luma; B4 += Luma; \
         if ((R3 | G3 | B3 | R4 | G4 | B4) & 0xffffff00) { \
           if (R3<0) R3=0; else if (R3>255) R3=255; \
           if (G3<0) G3=0; else if (G3>255) G3=255; \
           if (B3<0) B3=0; else if (B3>255) B3=255; \
           if (R4<0) R4=0; else if (R4>255) R4=255; \
           if (G4<0) G4=0; else if (G4>255) G4=255; \
           if (B4<0) B4=0; else if (B4>255) B4=255; \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 16:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
#ifdef WIN95  /* RGB 565 - 16 bit */
		      *(Sout1++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<8)|((G3&0xfC)<<3)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<8)|((G4&0xfC)<<3)|((B4&0xf8)>>3);
#else /* RGB 555 - 15 bit */
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
#endif
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout1, *Cout2;
                  stride*=3;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
	              *(Cout1++) = (u_char)B1; *(Cout1++) = (u_char)G1; *(Cout1++) = (u_char)R1;
	              *(Cout1++) = (u_char)B2; *(Cout1++) = (u_char)G2; *(Cout1++) = (u_char)R2;
	              *(Cout2++) = (u_char)B3; *(Cout2++) = (u_char)G3; *(Cout2++) = (u_char)R3;
	              *(Cout2++) = (u_char)B4; *(Cout2++) = (u_char)G4; *(Cout2++) = (u_char)R4;
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 32:
                {
                  unsigned dword *Wout1 = (unsigned dword *)ImageOut,
                                 *Wout2=Wout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1);
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Wout1++) = (R1<<16) | (G1<<8) | B1;
		      *(Wout1++) = (R2<<16) | (G2<<8) | B2;
		      *(Wout2++) = (R3<<16) | (G3<<8) | B3;
		      *(Wout2++) = (R4<<16) | (G4<<8) | B4;
                    }
                    Y1=Y2;
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData1, *GData1, *BData1;
              u_char *RData2, *GData2, *BData2;
              RData1 = ImageOut;
              GData1 = RData1 + (pixels * lines);
              BData1 = GData1 + (pixels * lines);
              RData2 = RData1 + pixels;
              GData2 = GData1 + pixels;
              BData2 = BData1 + pixels;
              for (row = 0; row < lines; row+=2)
              {
                Y2=Y1+pixels;
                for (col = 0; col < pixels; col += 2)
                {
	          U = *Cb++ - 128;
	          V = *Cr++ - 128;
                  _LoadRGBfrom411();
		  *(RData1++) = (u_char)R1; *(RData1++) = (u_char)R2;
          *(RData2++) = (u_char)R3; *(RData2++) = (u_char)R4;
		  *(GData1++) = (u_char)G1; *(GData1++) = (u_char)G2;
		  *(GData2++) = (u_char)G3; *(GData2++) = (u_char)G4;
		  *(BData1++) = (u_char)B1; *(BData1++) = (u_char)B2;
		  *(BData2++) = (u_char)B3; *(BData2++) = (u_char)B4;
	        }
                RData1=RData2;
                RData2=RData1+pixels;
                Y1=Y2;
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout1 = (unsigned dword *)ImageOut,
                             *Iout2=Iout1+pixels;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (R1<<16) | (G1<<8) | B1;
                    *(Iout1++) = (R2<<16) | (G2<<8) | B2;
                    *(Iout2++) = (R3<<16) | (G3<<8) | B3;
                    *(Iout2++) = (R4<<16) | (G4<<8) | B4;
                  }
                  Y1=Y2;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (B1<<16) | (G1<<8) | R1;
                    *(Iout1++) = (B2<<16) | (G2<<8) | R2;
                    *(Iout2++) = (B3<<16) | (G3<<8) | R3;
                    *(Iout2++) = (B4<<16) | (G4<<8) | R4;
                  }
                  Y1=Y2;
                }
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv1611ToRgb
** Purpose: convert 16-bit YCrCb 16:1:1 (YUV9/YVU9) to 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
** This routine is used by Indeo, which actually only has 7-bits for
** Y, U and V components.  The 8th bits are ignored.
*/
ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   const int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
   register int row, col, i;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 4x4 matrix of pixels */
   int R[16], G[16], B[16], tmpR, tmpG, tmpB, cR, cG, cB;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y0=Y, *Y1, *Y2, *Y3;
#define _LoadRGBfrom1611() \
         cR=(int) (             + (1.596 * V));\
	 cG=(int) (-(0.391 * U) - (0.813 * V));\
	 cB=(int) (+(2.018 * U)              );\
         for (i=0; i<4; i++) { \
	   Luma = (int) ((((int)(*Y0++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<8; i++) { \
	   Luma = (int) ((((int)(*Y1++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<12; i++) { \
	   Luma = (int) ((((int)(*Y2++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<16; i++) { \
	   Luma = (int) ((((int)(*Y3++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout0 = (unsigned dword *)ImageOut,
                             *Iout1, *Iout2, *Iout3;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<8; i++)
                        *(Iout1++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<12; i++)
                        *(Iout2++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<16; i++)
                        *(Iout3++) = (R[i]<<16) | (G[i]<<8) | B[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<8; i++)
                        *(Iout1++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<12; i++)
                        *(Iout2++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<16; i++)
                        *(Iout3++) = (B[i]<<16) | (G[i]<<8) | R[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
            }
            break;
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout0 = (u_short *)ImageOut, *Sout1, *Sout2, *Sout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Sout0 = &((u_short *)ImageOut)[tmp];  /* For 32-bit */
                     Sout1=Sout0-pixels; Sout2=Sout1-pixels; Sout3=Sout2-pixels;
                    }
                    else {
                     Sout1=Sout0+pixels; Sout2=Sout1+pixels; Sout3=Sout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4; i++) {
                          *(Sout0++) = 0;
                          *(Sout1++) = 0;
                          *(Sout2++) = 0;
                          *(Sout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                          *(Sout0++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<8; i++)
                          *(Sout1++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<12; i++)
                          *(Sout2++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<16; i++)
                          *(Sout3++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                      }
                    }
                    Sout0=Sout3;
                    Y0=Y3;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout0 = (u_char *)ImageOut, *Cout1, *Cout2, *Cout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Cout0 = &((u_char *)ImageOut)[tmp*3];  /* For 32-bit */
                     Cout1=Cout0-pixels; Cout2=Cout1-pixels; Cout3=Cout2-pixels;
                    }
                    else {
                     Cout1=Cout0+pixels; Cout2=Cout1+pixels; Cout3=Cout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4*3; i++) {
                          *(Cout0++) = 0;
                          *(Cout1++) = 0;
                          *(Cout2++) = 0;
                          *(Cout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                        { *(Cout0++)=(u_char)B[i]; *(Cout0++)=(u_char)G[i]; *(Cout0++)=(u_char)R[i]; }
                        for (; i<8; i++)
                        { *(Cout1++)=(u_char)B[i]; *(Cout1++)=(u_char)G[i]; *(Cout1++)=(u_char)R[i]; }
                        for (; i<12; i++)
                        { *(Cout2++)=(u_char)B[i]; *(Cout2++)=(u_char)G[i]; *(Cout2++)=(u_char)R[i]; }
                        for (; i<16; i++)
                        { *(Cout3++)=(u_char)B[i]; *(Cout3++)=(u_char)G[i]; *(Cout3++)=(u_char)R[i]; }
                      }
                    }
                    Cout0=Cout3;
                    Y0=Y3;
                  }
                }
                break;
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv422ToRgb
** Purpose: convert 16-bit YCrCb 4:2:2 to an 24-bit/16-bit/32-bit RGB
**
** Note:    The code below is pixel based and is *extremely* inefficient, we
**	    plan to replace the dumb code below with some fast code
** If Cb==NULL and Cr==NULL then assume BI_DECGRAYDIB (use only Y component).
*/
ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   register int row, col;
   register int Luma,U=0,V=0;
   int R1,R2, G1,G2, B1,B2;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char *RData, *GData, *BData;	/* pointers for non-interlaced mode */
   u_char  *Cout = (u_char *)ImageOut;
   u_short *Sout = (u_short *)ImageOut;
   u_int   *Iout = (u_int *)ImageOut;
   int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
#ifdef NEW_YCBCR
#define _LoadRGBfrom422() \
         if (U || V) { \
           R1 = R2 = (int) (              + (1.596 * V)); \
           G1 = G2 = (int) (- (0.391 * U) - (0.813 * V)); \
           B1 = B2 = (int) (+ (2.018 * U)              );  \
         } else { R1=R2=G1=G2=B1=B2=0; } \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R1 += Luma; G1 += Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R2 += Luma; G2 += Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#else
#define _LoadRGBfrom422() \
	 Luma = *(Y++); \
         R1 = Luma                + (1.4075 * V); \
         G1 = Luma - (0.3455 * U) - (0.7169 * V); \
         B1 = Luma + (1.7790 * U); \
	 Luma = *(Y++); \
         R2 = Luma                + (1.4075 * V); \
         G2 = Luma - (0.3455 * U) - (0.7169 * V); \
         B2 = Luma + (1.7790 * U); \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#endif /* NEW_YCBCR */

   /*
    * Normally, images are stored right side up,
    * that is with the first pixel in the buffer
    * corresponding to the top left pixel in the image.
    *
    * The Microsoft standard Device Independent bitmap
    * formats BI_RGB and BI_BITFIELD are stored with
    * the lower left pixel first.
    * We view that as upside down.
    *
    * Each format can also have a negative height,
    * which also signifes upside down.
    *
    * Since two negatives makes a positive, that means
    * that BI_ formats with a negative height are right side up.
    */

   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS)
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** needed if the three components are to be provided in a
   ** non-interlaced mode:
   */
   if (Bmh->biCompression == BI_DECSEPRGBDIB) {
      RData = ImageOut;
      GData = RData + (pixels * lines);
      BData = GData + (pixels * lines);
   }


   /*
   ** The assumption is that YCrCb are subsampled 4:2:2
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/2
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout = (u_short *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Sout = &((u_short *)ImageOut)[tmp]; /* For 16-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
                    }
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout = (u_char *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Cout = &((u_char *)ImageOut)[3*tmp]; /* For 24-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
	              *(Cout++) = (u_char)B1; *(Cout++) = (u_char)G1; *(Cout++) = (u_char)R1;
	              *(Cout++) = (u_char)B2; *(Cout++) = (u_char)G2; *(Cout++) = (u_char)R2;
                    }
                  }
                }
                break;
              case 32:
                {
                  u_int *Iout = (u_int *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp]; /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Iout++) = (R1<<16) | (G1<<8) | B1 ;
		      *(Iout++) = (R2<<16) | (G2<<8) | B2 ;
                    }
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData, *GData, *BData;
              RData = ImageOut;
              GData = RData + (pixels * lines);
              BData = GData + (pixels * lines);
              for (row = 0; row < lines; row++)
              {
                for (col = 0; col < pixels; col += 2)
                {
                  if (Cb) {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                  }
                  _LoadRGBfrom422();
		  *(RData++) = (u_char)R1; *(RData++) = (u_char)R2;
		  *(GData++) = (u_char)G1; *(GData++) = (u_char)G2;
		  *(BData++) = (u_char)B1; *(BData++) = (u_char)B2;
	        }
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 16 or 32-bit RGB */
            switch (Bmh->biBitCount)
            {
	    case 16:
	      {	/* 16-bit BI_BITFIELDS, hardcoded to RGB565 */
		u_short *Sout = (u_short *)ImageOut;
                for (row = 0; row < lines; row++)
                {
                  if (Ups)
                  {
                    tmp = pixels * (lines-row-1) ;
                    Sout = &((u_short *)ImageOut)[tmp];  /* For 16-bit */
                  }
                  for (col = 0; col < pixels; col += 2)
                  {
                    if (Cb) {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                    }
                    _LoadRGBfrom422();
                    *(Sout++) = ((R1<<8) & 0xf800) | ((G1<<3) & 0x07e0) | ((B1>>3) & 0x01f);
                    *(Sout++) = ((R2<<8) & 0xf800) | ((G2<<3) & 0x07e0) | ((B2>>3) & 0x01f);
                  }
                }
	      }
	      break ;
	    case 24:
	    case 32:
	      { /* 32-bit RGB */
                u_int *Iout = (u_int *)ImageOut;
                if (ValidateBI_BITFIELDS(Bmh) == pRGB)
		{
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (R1<<16) | (G1<<8) | B1;
                      *(Iout++) = (R2<<16) | (G2<<8) | B2;
                    }
                  }
		}
                else /* pBGR and XIMAGE 24-bit */
                {
		  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (B1<<16) | (G1<<8) | R1;
                      *(Iout++) = (B2<<16) | (G2<<8) | R2;
                    }
                  }
		}	
	      }
	      break;
	    }
            break;
       default:
	    return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}

/*
** Name: ScInitRgbToYuv
** Purpose: Initializes tables for RGB to YUV conversion.
**
** Notes:
**
**	The tables are allocated and filled in once the first
**	time they are needed. They will remin for the lifetime
**	of the server.
**
**	The following formula is used:
**
**	y =  0.257 * r + 0.504 * g + 0.098 * b +  16 ; /+  16 - 235 +/
**	u = -0.148 * r - 0.291 * g + 0.439 * b + 128 ; /+  16 - 239 +/
**	v =  0.439 * r - 0.368 * g - 0.071 * b + 128 ; /+  16 - 239 +/
**
**	But we rewrite it thus:
**
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
**
**    ( By the way, the old constants are:				     )
**    ( y = r *  0.299 + g *  0.587 + b *  0.114        ;		     )
**    ( u = r * -0.169 + g * -0.332 + b *  0.500  + 128 ;		     )
**    ( v = r *  0.500 + g * -0.419 + b * -0.0813 + 128 ;		     )
**    ( or								     )
**    ( y =  0.0    + 0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
**
**	This particular arrangement of the formula allows Y, U and V values
**	to be calculated in paralell by simple table lookup.
**	The paralellism comes from the fact that Y,U and V values
**	are stored in the same word, but in different bytes.
**	The tables are such that the contribution from red, green
**	and blue can simply be added together, without any carry
**	between bytes. Since the YUV space is larger than the RGB
**	cube, and the RGB cube fits entirely within YUV space,
**	there is no overflow and no range checking is needed.
**
*/

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/*
 * We only need an int (32 bits) per table entry but
 * 64-bit aligned access is faster on alpha.
 */

#ifdef __alpha
_int64 *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#else /* !__alpha */
unsigned int *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#endif /* !__alpha */

int ScInitRgbToYuv()
{
  int i, y, u, v ;

  if( RedToYuyv == NULL ) {
#ifdef __alpha
    RedToYuyv   = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    GreenToYuyv = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    BlueToYuyv  = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
#else /* !__alpha */
    RedToYuyv   = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    GreenToYuyv = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    BlueToYuyv  = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
#endif /* !__alpha */

    if( !RedToYuyv || !GreenToYuyv || !BlueToYuyv )
      return 0 ;

    for( i=0 ; i<256 ; i++ ) {

      /*
       * Calculate contribution from red.
       * We will also add in the constant here.
       * Pack it into the tables thus: lsb->YUYV<-msb
       */

      y = (int) (YC + YR * i) ;
      u = (int) (UC + UR * (255-i)) ;
      v = (int) (VC + VR * i) ;
      RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from green.
       */

      y = (int) (YG * i) ;
      u = (int) (UG * (255-i)) ;
      v = (int) (VG * (255-i)) ;
      GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from blue.
       */

      y = (int) (YB * i) ;
      u = (int) (UB * i) ;
      v = (int) (VB * (255-i)) ;
      BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

    }
  }
  return 1 ;
}

/*
** Name:    ScConvertRGB24sTo422i_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh, u_char *R, u_char *G,
                                   u_char *B, u_short *ImageOut)
{
   register int row, col;
   int yuyv,r,g,b;
   int pixels = Bmh->biWidth;
   int lines  = abs(Bmh->biHeight);

   if( !RedToYuyv && !ScInitRgbToYuv() )
     return ScErrorMemory ;

   for (row = 0; row < lines; row++) {
      for (col = 0; col < pixels; col++) {
        r = *(R++); g = *(G++); b = *(B++);

	/*
	 * Quick convert to YUV.
	 */

	yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;

        /*
         * Pack 4:2:2 = YUYV YUYV ...
	 * We'll pack YU or YV depending on whether col is odd or not.
	 * Shift yuyv 0 for even, 16 for odd columns.
         */

	*(ImageOut++) = yuyv >> ((col & 1) << 4) ;

      }
    }
    return (NoErrors);
}

#define M_RND(f) ((int) ((f) + .5))

/*
** Name:    ScConvertRGB24To411s_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                                  u_char *Y, u_char *U, u_char *V,
                                  int width, int height)
{
  register int row, col;
  int yuyv, r, g, b;
  u_char *tmp, *evl, *odl;

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    for (row = height-1; row; row--)
    {
      tmp = inimage+(width*row*3);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-(width*3);
      }
      else
      {
        evl = tmp;
        odl = tmp-(width*3);
      }
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    tmp = inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB555To411s_C
** Purpose: convert 16-bit RGB (5:5:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB555(in16, r, g, b) b = (inpixel>>7)&0xF8; \
                                 g = (inpixel>>2)&0xF8; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (inpixel>>7)&0xF8; \
                                 g += (inpixel>>2)&0xF8; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB565To411s_C
** Purpose: convert 16-bit RGB (5:6:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB565(in16, r, g, b) b = (inpixel>>8)&0xF8; \
                                 g = (inpixel>>3)&0xFC; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB565(in16, r, g, b) b += (inpixel>>8)&0xF8; \
                                 g += (inpixel>>3)&0xFC; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScRgbInterlToYuvInterl
** Purpose: convert many RGB formats to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScRgbInterlToYuvInterl (
    LPBITMAPINFOHEADER Bmh,
    int Width,
    int Height,
    u_char *ImageIn,
    u_short *ImageOut)
{
    register int row, col;
    int yuyv,r,g,b,mask=0x00ff;
    int pixels = Width;
    int lines  = abs(Height);
    int IspBGR = (ValidateBI_BITFIELDS(Bmh) == pBGR) ||
         (Bmh->biCompression==BI_DECXIMAGEDIB && Bmh->biBitCount==24);
    int IspRGB_BI_RGB_24 = (Bmh->biCompression==BI_RGB && Bmh->biBitCount==24);
    int linestep = 0 ;

    if( !RedToYuyv && !ScInitRgbToYuv() )
      return ScErrorMemory ;

    /*
     * Check the input format and decide
     * whether the image is to be turned
     * upside down or not.
     */

    if( (Bmh->biCompression == BI_RGB ||
    	 Bmh->biCompression == BI_BITFIELDS) ^
	((int) Bmh->biHeight < 0) ) {
	ImageOut = &ImageOut[ pixels * (lines - 1) ] ;
	linestep = -(pixels << 1) ;
    }

    /*
     * To avoid if-then-else statements inside
     * the inner loop, we have 3 loops.
     */

    /*
     * 24 bits per pixel RGB.
     */

    if (IspRGB_BI_RGB_24) {

      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *(ImageIn++);
	  g = *(ImageIn++);
	  r = *(ImageIn++);

	  /*
	   * Quick convert from RGB to YUV. Just add together
	   * the contributions from each of Red, Green and Blue.
	   */

	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	
	  /*
	   * Pack 4:2:2 = YUYV YUYV ...
	   * We'll pack YU or YV depending on whether col is odd or not.
	   * Shift yuyv 0 for even, 16 for odd columns.
	   */
	
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;

	}
	/*
	 * In case we're turning the image upside down.
	 * This will do nothing if it's right side up.
	 */
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0BGR.
     */
    else if (IspBGR) {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  r = *((int *) ImageIn)++ ;
	  b = (r>>16) & mask ;
	  g = (r>> 8) & mask ;
	  r &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0RGB.
     */
    else {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *((int *) ImageIn)++ ;
	  r = (b>>16) & mask ;
	  g = (b>> 8) & mask ;
	  b &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }

    return (NoErrors);
}


/*
** Function: ScConvert422ToYUV_char_C
** Purpose:  Extract the Y, U and V components into separate planes.
**           The interleaved format is YUYV, 4:2:2, we want 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;

  Width/=2;
  Height=abs(Height)/2;
  for (y = 0; y < Height; y++)
  {
    for (x = 0 ; x < Width; x++)
    {
      *Y++ = *RawImage++;
      *U++ = *RawImage++;
      *Y++ = *RawImage++;
      *V++ = *RawImage++;
    }
    for (x = 0; x < Width; x++)
    {
      *Y++ = *RawImage;
      RawImage+=2;
      *Y++ = *RawImage;
      RawImage+=2;
    }
 }
 return (NoErrors);
}

/*
** Function: ScConvert422PlanarTo411_C
** Purpose:  Extract the Y, U and V components from (4:2:2)
**           planes and convert to 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RY, *RU, *RV;
  RY=RawImage;
  RU=RY+(Width*Height);
  RV=RU+(Width*Height/2);

  Height=abs(Height);
  memcpy(Y, RawImage, Width*Height);
  for (y = Height/2; y > 0; y--)
  {
    memcpy(U, RU, HalfWidth);
    memcpy(V, RV, HalfWidth);
    U+=HalfWidth;
    V+=HalfWidth;
    RU+=Width; /* skip odd U and V lines */
    RV+=Width;
 }
 return (NoErrors);
}

/*
** C versions of block-extraction routines. To be replaced by ASM
*/
void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
			    float *Comp1, float *Comp2, float *Comp3,
			    int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int UBlocks    = Width/16;
  int VBlocks    = Width/16;
  int ByteWidth  = Width*2;
  u_char *I1 = RawImage;
  u_char *I2 = I1 + Width*abs(Height);
  u_char *I3 = I2 + Width*abs(Height)/2;
  float *C1 = Comp1, *C2 = Comp2, *C3 = Comp3;

  for (y = 0 ; y < VertBlocks ; y++) {
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
    for (x = 0 ; x < UBlocks ; x++)
      sc_ExtractBlockNonInt(I2, &C2, ByteWidth, x, y);
    for (x = 0 ; x < VBlocks ; x++)
      sc_ExtractBlockNonInt(I3, &C3, ByteWidth, x, y);
  }
}

void ScConvertGrayToBlock (u_char *RawImage, int bpp,
		       float *Comp1, int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int ByteWidth  = Width;
  u_char *I1 = RawImage;
  float *C1 = Comp1;

  for (y = 0 ; y < VertBlocks ; y++)
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
}


/*
** Function: ScSepYUVto422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height)
{
  /* need C code for this */
  return(0);
}

/*
** Function: ScConvert422PlanarTo422i_C
** Purpose:  Convert a 4:2:2 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *OutImage,
				     long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *OutImage++ = *Y++;
       *OutImage++ = *Cb++;
       *OutImage++ = *Y++;
       *OutImage++ = *Cr++;
    }
  }
}

/*
** Function: ScConvert422iTo422s_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *U, u_char *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = *InImage++;
       *U++ = *InImage++;
       *Y++ = *InImage++;
       *V++ = *InImage++;
    }
  }
}

/*
** Function: ScConvert422iTo422sf_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = (float)*InImage++;
       *U++ = (float)*InImage++;
       *Y++ = (float)*InImage++;
       *V++ = (float)*InImage++;
    }
  }
}

/*
** Function: ScConvert411sTo422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p422e, *p422o, *Yo=Y+width;
  int i, j;
  height=abs(height)/2;
  p422e=OutImage;
  p422o=OutImage+width*2;

  for (i=0; i<height; i++)
  {
    for (j=0; j<width; j+=2)
    {
      *p422e++ = *Y++;
      *p422e++ = *Cb;
      *p422e++ = *Y++;
      *p422e++ = *Cr;
      *p422o++ = *Yo++;
      *p422o++ = *Cb++;
      *p422o++ = *Yo++;
      *p422o++ = *Cr++;
    }
    p422e=p422o;
    p422o=p422e+width*2;
    Y=Yo;
    Yo=Y+width;
  }
}

/*
** Function: ScConvert411sTo422s_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p411, *p422e, *p422o;
  int i, j;
  height=abs(height);

  if (OutImage!=Y)
    memcpy(OutImage, Y, width*height); /* copy Y components */
  p411=Cb+((height/2)-1)*(width/2);
  p422e=OutImage+((height*width*3)/2)-width; /* U component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
  p411=Cr+((height/2)-1)*(width/2);
  p422e=OutImage+(height*width*2)-width; /* V component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
}

/*
** Name:    ScConvert1611sTo411s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:1:1
*/
ScStatus_t ScConvert1611sTo411s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y++)
  {
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU++;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV++;
 }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:2:2
*/
ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  unsigned char *Uo, *Vo;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = Height/32; y>0; y--)
  {
    Vo=V+Width;
    Uo=U+Width;
    for (x = Width/4; x > 0; x--)
    {
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU++;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV++;
    }
    V=Vo; U=Uo;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422i_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to 4:2:2 interleaved
*/
ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                  int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *Ye, *Yo, *Ye2, *Yo2, *RU, *RV;
  unsigned char *o1, *e1, *o2, *e2;
  unsigned char U, V;

  RU=inimage+Width*abs(Height);
  RV=RU+(Width*abs(Height))/16;

  e1=outimage;
  Ye=inimage;
  for (y = abs(Height)/4; y>0; y--)
  {
    Yo=Ye+Width;
    Ye2=Yo+Width;
    Yo2=Ye2+Width;
    o1=e1+Width*2;
    e2=o1+Width*2;
    o2=e2+Width*2;
    for (x = Width/4; x > 0; x--)
    {
      U = *RU++;
      V = *RV++;
      /* even line */
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      /* odd line */
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      /* even line */
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      /* odd line */
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
    }
    e1=o2;
    Ye=Yo2;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert411sTo1611s_C
** Purpose: convert a YCrCb 4:1:1 to YCrCb 16:1:1 (YUV9/YVU9)
*/
ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y, c0, c1, c2, c3;
  unsigned char *Ue, *Uo, *Ve, *Vo;
  int pixels = Width * abs(Height), tmp;
  Width/=2;
  tmp = pixels / 4;
  Ue=inimage+pixels;
  Uo=Ue+Width;
  Ve=Ue+tmp;
  Vo=Ve+Width;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ue++;
      c1=*Ue++;
      c2=*Uo++;
      c3=*Uo++;
      *U++ = (c0+c1+c2+c3)/4;
    }
    Ue=Uo;
    Uo+=Width;
  }
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ve++;
      c1=*Ve++;
      c2=*Vo++;
      c3=*Vo++;
      *V++ = (c0+c1+c2+c3)/4;
    }
    Ve=Vo;
    Vo+=Width;
  }
  return (NoErrors);
}

/*
** Function: ScConvertNTSCtoCIF422()
** Purpose:  Convert a Q/CIF frame from a 4:2:2 NTSC input.  We dup every 10th
**           pixel horizontally and every 4th line vertically.  We also
**           discard the chroma on every other line, since CIF wants 4:1:1.
*/
ScStatus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride)
{
  int h, w;

  int vdup = 5;
  for (h = 0; h < 240; ++h)
  {
    int hdup = 10/2;
    for (w = 320; w > 0; w -= 2)
    {
      yp[0] = framein[0];
      yp[1] = framein[2];
      yp += 2;
      if ((h & 1) == 0)
      {
        *up++ = framein[1];
        *vp++ = framein[3];
      }
      framein += 4;
      if (--hdup <= 0)
      {
        hdup = 10/2;
        yp[0] = yp[-1];
        yp += 1;
        if ((h & 1) == 0)
        {
          if ((w & 2) == 0)
          {
            up[0] = up[-1];
            ++up;
            vp[0] = vp[-1];
            ++vp;
          }
        }
      }
    }
    if (--vdup <= 0)
    {
      vdup = 5;
      /* copy previous line */
      memcpy((char*)yp, (char*)yp - stride, stride);
      yp += stride;
      if ((h & 1) == 0)
      {
        int s = stride >> 1;
        memcpy((char*)up, (char*)up - s, s);
        memcpy((char*)vp, (char*)vp - s, s);
        up += s;
        vp += s;
      }
    }
  }
  return (NoErrors);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\scon_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_api.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif


static unsigned dword sconTranslateFourCC(unsigned dword FourCC)
{
  switch (FourCC)
  {
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
          return(BI_YUY2);
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
      case BI_DECSEPYUVDIB:  /* YUV 4:2:2 Planar */
          return(BI_YU16SEP);
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
      case BI_RGB:           /* RGB */
      case BI_BITFIELDS:     /* RGB masked */
#ifndef WIN32
      case BI_DECXIMAGEDIB:  /* Unix Ximage RGB */
#endif /* !WIN32 */
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
      default:
          return(FourCC);
  }
}

static void sconInitInfo(SconInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("sconInitInfo()\n") );
  Info->Mode = SCON_MODE_NONE;
  Info->InputInited = FALSE;
  Info->OutputInited = FALSE;
  Info->Flip = FALSE;
  Info->SameFormat = TRUE;
  Info->ScaleUp = FALSE;
  Info->ScaleDown = FALSE;
  Info->FImage = NULL;
  Info->FImageSize = 0;
  Info->SImage = NULL;
  Info->SImageSize = 0;
  Info->Table = NULL;
  Info->TableSize = 0;
  Info->dbg = NULL;
}

static void sconValidateInfo(SconInfo_t *Info)
{
  if (Info->Mode==SCON_MODE_VIDEO)
  {
    if (Info->InputInited && Info->OutputInited)
    {
      SconVideoInfo_t *in_vinfo=&Info->Input.vinfo;
      SconVideoInfo_t *out_vinfo=&Info->Output.vinfo;
      Info->Flip=(in_vinfo->NegHeight!=out_vinfo->NegHeight)?TRUE:FALSE;
      sconCalcImageSize(in_vinfo);
      sconCalcImageSize(out_vinfo);
      Info->ScaleDown=(in_vinfo->Pixels>out_vinfo->Pixels)?TRUE:FALSE;
      Info->ScaleUp=(in_vinfo->Pixels<out_vinfo->Pixels)?TRUE:FALSE;
      if (!Info->ScaleDown && !Info->ScaleUp && in_vinfo->Width>out_vinfo->Width)
        Info->ScaleUp=TRUE;
      in_vinfo->FourCC=sconTranslateFourCC(in_vinfo->FourCC);
      out_vinfo->FourCC=sconTranslateFourCC(out_vinfo->FourCC);
      if (in_vinfo->BPP==out_vinfo->BPP && 
          in_vinfo->FourCC==out_vinfo->FourCC)
        Info->SameFormat=TRUE;
      else
        Info->SameFormat=FALSE;
    }
  }
}

static void sconBMHtoVideoInfo(BITMAPINFOHEADER *bmh, SconVideoInfo_t *vinfo)
{
  vinfo->Width=bmh->biWidth;
  if (bmh->biHeight<0) /* height is negative */
  {
    vinfo->Height=-bmh->biHeight;
    vinfo->NegHeight=TRUE;
  }
  else /* height is positive */
  {
    vinfo->Height=bmh->biHeight;
    vinfo->NegHeight=FALSE;
  }
  vinfo->FourCC=bmh->biCompression;
  vinfo->BPP=bmh->biBitCount;
  vinfo->Stride=vinfo->Width*((vinfo->BPP+7)>>3);
  /* RGB bit masks */
  vinfo->Rmask=0;
  vinfo->Gmask=0;
  vinfo->Bmask=0;
  vinfo->RGBmasks=0;
  if (vinfo->FourCC==BI_BITFIELDS || vinfo->FourCC==BI_RGB ||
      vinfo->FourCC==BI_DECXIMAGEDIB)
  {
    if (vinfo->BPP==32 || vinfo->BPP==24)
    {
      vinfo->Rmask=0xFF0000;
      vinfo->Gmask=0x00FF00;
      vinfo->Bmask=0x0000FF;
    }
    else if (vinfo->BPP==16) /* RGB 565 */
    {
      vinfo->Rmask=0xF800;
      vinfo->Gmask=0x07E0;
      vinfo->Bmask=0x001F;
    }
    if (vinfo->FourCC==BI_BITFIELDS &&
        bmh->biSize>=sizeof(BITMAPINFOHEADER)+3*4)
    {
      DWORD *MaskPtr = (DWORD *)&bmh[1];
      if (MaskPtr[0] && MaskPtr[1] && MaskPtr[2])
      {
        /* get bit masks */
        vinfo->Rmask=MaskPtr[0];
        vinfo->Gmask=MaskPtr[1];
        vinfo->Bmask=MaskPtr[2];
      }
    }
    if (vinfo->Rmask==0xF800 && vinfo->Gmask==0x07E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x07E0 && vinfo->Bmask==0xF800)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x7C00 && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x7C00)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0xFF0000 && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0x0000FF)
      vinfo->RGBmasks=888;
    else if (vinfo->Rmask==0x0000FF && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0xFF0000)
      vinfo->RGBmasks=888;
  }
}

SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                      void *informat, void *outformat)
{
  SconInfo_t *Info;
  if (smode==SCON_MODE_VIDEO)
  {
    if ((Info = (SconInfo_t *)ScAlloc(sizeof(SconInfo_t))) == NULL)
      return(SconErrorMemory);
    sconInitInfo(Info);
    Info->Mode=smode;
    if (informat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)informat, &Info->Input.vinfo);
      Info->InputInited = TRUE;
    }
    if (outformat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)outformat, &Info->Output.vinfo);
      Info->OutputInited = TRUE;
    }
    sconValidateInfo(Info);
    *handle=(SconHandle_t)Info;
    return(SconErrorNone);
  }
  else
    return(SconErrorBadMode);
}

SconStatus_t SconClose(SconHandle_t handle)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  _SlibDebug(_VERBOSE_, printf("SconClose()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (Info->Table)
    ScPaFree(Info->Table);
  if (Info->FImage)
    ScPaFree(Info->FImage);
  if (Info->SImage)
    ScPaFree(Info->SImage);
  ScFree(Info);
  return(SconErrorNone);
}

/*
** Name: SconIsSame
** Desc: Return true if input and output formats are identical.
** Return: TRUE   input == output format
**         FALSE  input != out format
*/
SconBoolean_t SconIsSame(SconHandle_t handle)
{
  if (handle)
  {
    SconInfo_t *Info=(SconInfo_t *)handle;

    if (Info->Mode==SCON_MODE_VIDEO)
    {
      if (Info->SameFormat && !Info->Flip && !Info->ScaleUp && !Info->ScaleDown)
        return(TRUE);
    }
  }
  return(FALSE);
}

SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                              void *outbuf, dword outbufsize)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status;
  _SlibDebug(_VERBOSE_, printf("SconConvert()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  if (Info->Mode==SCON_MODE_VIDEO)
    status=sconConvertVideo(Info, inbuf, inbufsize, outbuf, outbufsize);
  else
    status=SconErrorBadMode;
  return(status);
}

SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status=SconErrorNone;
  if (!handle)
    return(SconErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SconSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SCON_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SconSetParamInt(SCON_PARAM_STRIDE)\n") );
          if (Info->Mode==SCON_MODE_VIDEO)
          {
            if (ptype==SCON_INPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Input.vinfo.Stride=(long)value;
            if (ptype==SCON_OUTPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Output.vinfo.Stride=(long)value;
          }
          else
            status=SconErrorBadMode;
          break;
    default:
          return(SconErrorUnsupportedParam);
  }
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_err.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_err.h,v $
 * Revision 1.1.4.2  1996/12/03  00:08:28  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:34  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/08/04  16:32:25  Karen_Dintino
 * 	New error codes for H.261
 * 	[1995/08/04  16:24:25  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/26  17:48:54  Hans_Graves
 * 	Added ErrorClientEnd errors.
 * 	[1995/07/26  17:44:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/07/11  22:11:27  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:52:53  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/07/11  14:50:45  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:18  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:35:04  Hans_Graves
 * 	Added ScErrorDevOpen and fixed some error numbers
 * 	[1995/06/22  21:31:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:28  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:25:17  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:59  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:23:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:19:26  Hans_Graves
 * 	Expanded to include new libraries: Sg,Su,Sa,Sr
 * 	[1995/04/07  19:11:07  Hans_Graves]
 * 
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*----------------------------------------------------------------------------
 * Modification History: SC_err.h (previously SV_err.h)
 *
 * 05-Nov-1991  Victor Bahl & Bob Ulichney   creation date
 * 07-Oct-1994  Paul Gauthier                SLIB v3.0 incl. MPEG Decode
 * 09-Nov-1994  Paul Gauthier                Optimizations
 *--------------------------------------------------------------------------*/

#ifndef _SC_ERR_H_
#define _SC_ERR_H_
/* 	
** List of possible errors that can be returned from routines in any 
** of SLIB libraries.
*/

/******************** Error Offsets **********************************/
#define ERR_SC   0x0000  /* Common Error */
#define ERR_SV   0x1000  /* Video Error */
#define ERR_SA   0x2000  /* Audio Error */
#define ERR_SR   0x3000  /* Render Error */

#define	NoErrors                   0

/******************** Sc (common) Errors ****************************/
#define ScErrorNone                NoErrors
#define ScErrorForeign             (ERR_SC+1)
#define ScErrorMemory              (ERR_SC+2)
#define ScErrorBadPointer          (ERR_SC+3)
#define ScErrorNullStruct          (ERR_SC+4)
#define ScErrorFile                (ERR_SC+5)
#define ScErrorEOI                 (ERR_SC+6)
#define ScErrorBadArgument         (ERR_SC+7)
#define ScErrorSmallBuffer         (ERR_SC+8)
#define ScErrorUnrecognizedFormat  (ERR_SC+9)
#define ScErrorEndBitstream        (ERR_SC+10)
#define ScErrorMapFile             (ERR_SC+11)
#define ScErrorBadQueueEmpty       (ERR_SC+12)
#define ScErrorClientEnd           (ERR_SC+13)
#define ScErrorDevOpen             (ERR_SC+14)
#define ScErrorNetConnectIn        (ERR_SC+15)
#define ScErrorNetConnectOut       (ERR_SC+16)
#define ScErrorNetProtocol         (ERR_SC+17)
#define ScErrorNetSend             (ERR_SC+18)
#define ScErrorNetReceive          (ERR_SC+19)
#define ScErrorNetBadHeader        (ERR_SC+20)
#define ScErrorNetBadTrailer       (ERR_SC+21)
#define ScErrorNetChecksum         (ERR_SC+22)

/******************** Sv (video) Errors ****************************/
#ifdef ERR_SV
#define	SvErrorNone                NoErrors
#define SvErrorMemory              ScErrorMemory
#define SvErrorBadPointer          ScErrorBadPointer
#define SvErrorNullStruct          ScErrorNullStruct
#define SvErrorBadArgument         ScErrorBadArgument
#define SvErrorSmallBuffer         ScErrorSmallBuffer
#define SvErrorEndBitstream        ScErrorEndBitstream
#define SvErrorClientEnd           ScErrorClientEnd

#define SvErrorCodecType           (ERR_SV+2)
#define SvErrorCodecHandle         (ERR_SV+3)
#define SvErrorNullCodec           (ERR_SV+4)
#define SvErrorNullToken           (ERR_SV+5)
#define SvErrorSyncLost            (ERR_SV+6)
#define	SvErrorLevels	           (ERR_SV+7)
#define	SvErrorOrder	           (ERR_SV+8)
#define SvErrorLevNoneg            (ERR_SV+9)
#define SvErrorLev1K               (ERR_SV+10)
#define SvErrorLevGt0              (ERR_SV+11)
#define SvErrorYuvOnly             (ERR_SV+13)
#define SvErrorDevOpen             (ERR_SV+14)
#define SvErrorDevMap              (ERR_SV+15)
#define SvErrorStatQueMap          (ERR_SV+16)
#define SvErrorDevLock             (ERR_SV+17)
#define SvErrorDevUlock            (ERR_SV+18)
#define SvErrorCache               (ERR_SV+19)
#define SvErrorPageAll             (ERR_SV+20)
#define SvErrorTimeOut             (ERR_SV+21)
#define SvErrorSelect              (ERR_SV+22)
#define SvErrorMapOvrfl            (ERR_SV+23)
#define SvErrorForeign             (ERR_SV+24)
#define SvErrorIIC                 (ERR_SV+25)
#define SvErrorCompPtrs            (ERR_SV+26)
#define SvErrorVideoInput          (ERR_SV+27)
#define SvErrorPhase	           (ERR_SV+28)
#define SvErrorCmdQueMap	   (ERR_SV+29)
#define SvErrorTmpQueMap	   (ERR_SV+30)
#define SvErrorStart               (ERR_SV+31)
#define SvErrorStop                (ERR_SV+32)
#define SvErrorWaitMix             (ERR_SV+33)
#define SvErrorClose               (ERR_SV+34)
#define SvErrorCmdQFull            (ERR_SV+35)
#define SvErrorPictureOp           (ERR_SV+36)
#define SvErrorRefToken            (ERR_SV+37)
#define SvErrorEditChange          (ERR_SV+38)
#define SvErrorCompROI             (ERR_SV+39)
#define SvErrorBufOverlap          (ERR_SV+40)
#define SvErrorReqQueueFull        (ERR_SV+41)
#define SvErrorCompBufOverflow     (ERR_SV+42)
#define SvErrorFunctionInputs      (ERR_SV+43)
#define SvErrorIICAck              (ERR_SV+44)
#define SvErrorCompressedData      (ERR_SV+45)
#define SvErrorDecompPreload       (ERR_SV+46)
#define SvErrorHuffCode            (ERR_SV+47)
#define SvErrorOutOfData           (ERR_SV+48)
#define SvErrorMarkerFound         (ERR_SV+49)
#define SvErrorSgMapsExhausted     (ERR_SV+50)
#define SvErrorSgMapInit           (ERR_SV+51)
#define SvErrorSgMapAlreadyFree    (ERR_SV+52)
#define SvErrorSgMapId             (ERR_SV+53)
#define SvErrorNumBytes            (ERR_SV+54)
#define SvErrorDevName             (ERR_SV+55)
#define SvErrorAnalogPortTiming    (ERR_SV+56)
#define SvErrorFrameMode           (ERR_SV+57)
#define SvErrorSampFactors         (ERR_SV+58)
#define SvErrorNumComponents       (ERR_SV+59)
#define SvErrorDHTTable            (ERR_SV+60)
#define SvErrorQuantTable          (ERR_SV+61)
#define SvErrorRestartInterval     (ERR_SV+62)
#define SvErrorJfifRev             (ERR_SV+63)
#define SvErrorEmptyJPEG           (ERR_SV+64)
#define SvErrorJPEGPrecision       (ERR_SV+65)
#define SvErrorSOFLength           (ERR_SV+66)
#define SvErrorSOSLength           (ERR_SV+67)
#define SvErrorSOSCompNum          (ERR_SV+68)
#define SvErrorMarker              (ERR_SV+69)
#define SvErrorSOFType             (ERR_SV+70)
#define SvErrorFrameNum            (ERR_SV+71)
#define SvErrorHuffUndefined       (ERR_SV+72)
#define SvErrorJPEGData            (ERR_SV+73)
#define SvErrorQMismatch           (ERR_SV+74)
#define SvErrorEmptyFlush          (ERR_SV+75)
#define SvErrorDmaChan             (ERR_SV+76)
#define SvErrorFuture              (ERR_SV+77)
#define SvErrorWrongev             (ERR_SV+78)
#define SvErrorUnknev              (ERR_SV+79)
#define SvErrorQueueExecuting      (ERR_SV+80)
#define SvErrorReturnAddr          (ERR_SV+81)
#define SvErrorObjClass            (ERR_SV+82)
#define SvErrorRegAnchor           (ERR_SV+83)
#define SvErrorTimerRead           (ERR_SV+84)
#define SvErrorDriverFatal         (ERR_SV+85)
#define SvErrorChromaSubsample     (ERR_SV+86)
#define SvErrorReadBufSize         (ERR_SV+87)
#define SvErrorQuality             (ERR_SV+88)
#define SvErrorBadImageSize        (ERR_SV+89)
#define SvErrorValue               (ERR_SV+90)
#define SvErrorDcmpNotStarted      (ERR_SV+91)
#define SvErrorNotImplemented      (ERR_SV+92)
#define SvErrorNoSOIMarker         (ERR_SV+93)
#define SvErrorProcessingAborted   (ERR_SV+94)
#define SvErrorCompNotStarted      (ERR_SV+95)
#define SvErrorNotAligned          (ERR_SV+96)
#define SvErrorBadQueueEmpty       (ERR_SV+97)
#define SvErrorCannotDecompress    (ERR_SV+98)
#define SvErrorMultiBufChanged     (ERR_SV+99)
#define SvErrorNotDecompressable   (ERR_SV+100)
#define SvErrorIndexEmpty          (ERR_SV+101)
#define SvErrorFile                (ERR_SV+102)
#define SvErrorEOI                 (ERR_SV+103)
#define SvErrorUnrecognizedFormat  (ERR_SV+104)
#define SvErrorIllegalMType	   (ERR_SV+105)
#define SvErrorExpectedEOB         (ERR_SV+106)
#define SvErrorNoCompressBuffer    (ERR_SV+107)
#define SvErrorNoImageBuffer       (ERR_SV+108)
#define SvErrorCBPWrite		   (ERR_SV+109)
#define SvErrorEncodingMV          (ERR_SV+110)
#define SvErrorEmptyHuff           (ERR_SV+111)
#define SvErrorIllegalGBSC         (ERR_SV+112)
#define SvErrorEndOfSequence       (ERR_SV+113)



#endif ERR_SV


/******************** Sa (video) Errors ****************************/
#ifdef ERR_SA
#define	SaErrorNone                NoErrors
#define SaErrorMemory              ScErrorMemory
#define SaErrorBadPointer          ScErrorBadPointer
#define SaErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SaErrorNullStruct          ScErrorNullStruct
#define SaErrorFile                ScErrorFile
#define SaErrorEOI                 ScErrorEOI
#define SaErrorBadArgument         ScErrorBadArgument
#define SaErrorSmallBuffer         ScErrorSmallBuffer
#define SaErrorClientEnd           ScErrorClientEnd

#define SaErrorCodecType           (ERR_SA+1)
#define SaErrorCodecHandle         (ERR_SA+2)
#define SaErrorNullCodec           (ERR_SA+3)
#define SaErrorSyncLost            (ERR_SA+4)
#define SaErrorMPEGLayer           (ERR_SA+5)
#define SaErrorMPEGModeExt         (ERR_SA+6)
#define SaErrorNoCompressBuffer    (ERR_SA+7)
#define SaErrorNoAudioBuffer       (ERR_SA+8)
#endif ERR_SA

/******************** Sr (render) Errors ****************************/
#ifdef ERR_SR
#define	SrErrorNone                NoErrors
#define SrErrorMemory              ScErrorMemory
#define SrErrorBadPointer          ScErrorBadPointer
#define SrErrorUnrecognizedFormat  ScErrorUnrecognizedFormat
#define SrErrorNullStruct          ScErrorNullStruct
#define SrErrorFile                ScErrorFile
#define SrErrorEOI                 ScErrorEOI
#define SrErrorBadArgument         ScErrorBadArgument
#define SrErrorSmallBuffer         ScErrorSmallBuffer
#define SrErrorClientEnd           ScErrorClientEnd

#define SrErrorRenderType          (ERR_SR+1)
#define SrErrorRenderHandle        (ERR_SR+2)
#define SrErrorRenderNotStarted    (ERR_SR+3)
#define SrErrorDitherNOL           (ERR_SR+4)
#define SrErrorDitherPhase         (ERR_SR+5)
#define SrErrorDefSteepness        (ERR_SR+6)
#define SrErrorSteepness           (ERR_SR+7)
#define SrErrorDefYoffset          (ERR_SR+8)
#define SrErrorYoffset             (ERR_SR+9)
#define SrErrorDefXoffset          (ERR_SR+10)
#define SrErrorXoffset             (ERR_SR+11)
#define SrErrorNumColors           (ERR_SR+12)
#define SrErrorBadNumColors        (ERR_SR+13)
#define SrErrorColorSpace          (ERR_SR+14)
#define SrErrorBadImageSize        (ERR_SR+15)
#define SrErrorValue               (ERR_SR+16)
#endif ERR_SR

#endif _S_ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_dct.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_dct.c,v $
 * Revision 1.1.4.6  1996/01/08  16:41:14  Hans_Graves
 * 	Moved IDCT routines to sc_idct.c
 * 	[1996/01/08  15:31:42  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/02  18:30:42  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused local variables.
 * 	[1996/01/02  15:23:37  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:16:55  Bjorn_Engberg
 * 	Define floorf = floor for NT since NT does not have floorf.
 * 	[1995/12/28  17:10:31  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/07  19:31:16  Hans_Graves
 * 	Added ScFDCT8x8s_C() and ScIDCT8x8s_C to be used by MPEG encoder
 * 	[1995/12/07  17:43:21  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:40  Hans_Graves
 * 	Added ScScaleIDCT8x8().
 * 	[1995/09/13  14:40:56  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:33  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:08:02  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_dct.c
** DCT related functions.
** (Pulled from MPEG/JPEG Decode & Encode source.)
*/

#include <math.h>
#include "SC.h"

/*-----------------------------------------------------------------------
                Forward Discrete Cosine Transform
 -------------------------------------------------------------------------*/

#define F (float)
#define RSQ2    F 0.7071067811865
#define COSM1P3 F 1.3065629648764
#define COS1M3  F 0.5411961001462
#define COS3    F 0.3826834323651

#ifdef WIN32
#define floorf  F floor
#endif /* WIN32 */

/*
** Name:    ScIFDCT
** Purpose: IFDCT takes the fast inverse DCT of 32 data points
*/
void ScIFDCT(float in_block[32], float out_block[32])
{
        static float            cpi4,cpi8,c3pi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,s3pi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init=0;

        float                   temp;
        float                   c0,c1,c2,c3,c4,c5,c6,c7,c8;
        float                   c9,c10,c11,c12,c13,c14,c15;
        float                   c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;
        float                   *out_block_ptr;
        float                   *in_block_ptr;
/* initialization.  This is to be done only once. */

        if(init==0) {
        /* establish internal variables */
	  cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (3.0*PI/8.0);     c3pi8 = F cos(temp);   s3pi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
	  init++;
        }

        /* rearrange coefficients to do bit reversed ordering */

          in_block_ptr = &in_block[0];
          d0  = *in_block_ptr++ * F 1.414213562; /******** normalization ********/

          d16 = *in_block_ptr++;
                  d8  = *in_block_ptr++;
          d24 = *in_block_ptr++;
                  e4  = *in_block_ptr++;
          d20 = *in_block_ptr++;
                  d12 = *in_block_ptr++;
          d28 = *in_block_ptr++;
          d2  = *in_block_ptr++;
          d18 = *in_block_ptr++;
                  d10 = *in_block_ptr++;
          d26 = *in_block_ptr++;
                  e6  = *in_block_ptr++;
          d22 = *in_block_ptr++;
                  d14 = *in_block_ptr++;
          d30 = *in_block_ptr++;
          d1  = *in_block_ptr++;
          d17 = *in_block_ptr++;
                  d9  = *in_block_ptr++;
          d25 = *in_block_ptr++;
                  e5  = *in_block_ptr++;
          d21 = *in_block_ptr++;
                  d13 = *in_block_ptr++;
          d29 = *in_block_ptr++;
          d3  = *in_block_ptr++;
          d19 = *in_block_ptr++;
                  d11 = *in_block_ptr++;
          d27 = *in_block_ptr++;
                  e7  = *in_block_ptr++;
          d23 = *in_block_ptr++;
                  d15 = *in_block_ptr++;
          d31 = *in_block_ptr++;

        /* first stage of fast idct */

          c16=spi64*d16-cpi64*d31;
          c31=spi64*d31+cpi64*d16;

          c17=s17pi64*d17-c17pi64*d30;
          c30=s17pi64*d30+c17pi64*d17;

          c18=s9pi64*d18-c9pi64*d29;
          c29=s9pi64*d29+c9pi64*d18;

          c19=s25pi64*d19-c25pi64*d28;
          c28=s25pi64*d28+c25pi64*d19;

          c20=s5pi64*d20-c5pi64*d27;
          c27=s5pi64*d27+c5pi64*d20;

          c21=s21pi64*d21-c21pi64*d26;
          c26=s21pi64*d26+c21pi64*d21;

          c22=s13pi64*d22-c13pi64*d25;
          c25=s13pi64*d25+c13pi64*d22;

          c23=s29pi64*d23-c29pi64*d24;
          c24=s29pi64*d24+c29pi64*d23;

        /* second stage of fast idct */

          e8=spi32*d8-cpi32*d15;
          e15=spi32*d15+cpi32*d8;

          e9=c7pi32*d9-s7pi32*d14;
          e14=c7pi32*d14+s7pi32*d9;

          e10=s5pi32*d10-c5pi32*d13;
          e13=s5pi32*d13+c5pi32*d10;

          e11=c3pi32*d11-s3pi32*d12;
          e12=c3pi32*d12+s3pi32*d11;

                  d16=c17+c16;
          e17=c16-c17;
          e18=c19-c18;
                  d19=c18+c19;
                  d20=c21+c20;
          e21=c20-c21;
          e22=c23-c22;
                  d23=c22+c23;
                  d24=c25+c24;
          e25=c24-c25;
          e26=c27-c26;
                  d27=c26+c27;
                  d28=c29+c28;
          e29=c28-c29;
          e30=c31-c30;
                  d31=c30+c31;

        /* third stage of fast idct */

          d4=spi16*e4-cpi16*e7;
          d7=spi16*e7+cpi16*e4;

          d5=c3pi16*e5-s3pi16*e6;
          d6=c3pi16*e6+s3pi16*e5;

                c8=e9+e8;
          d9=e8-e9;
          d10=e11-e10;
                c11=e10+e11;
                c12=e13+e12;
          d13=e12-e13;
          d14=e15-e14;
                c15=e14+e15;

          d17= -cpi16*e17+spi16*e30;
          d30=cpi16*e30+spi16*e17;

          d18= -spi16*e18-cpi16*e29;
          d29=spi16*e29-cpi16*e18;

          d21=c3pi16*e26-s3pi16*e21;
          d26=c3pi16*e21+s3pi16*e26;

          d22= -s3pi16*e25-c3pi16*e22;
          d25= -s3pi16*e22+c3pi16*e25;

        /* fourth stage of fast idct */

          c0=cpi4*(d1+d0);
          c1=cpi4*(d0-d1);
          c2= -cpi8*d3+spi8*d2;
          c3= cpi8*d2+spi8*d3;
                  e4=d5+d4;
          c5=d4-d5;
          c6=d7-d6;
                  e7=d6+d7;
          c9=spi8*d14-cpi8*d9;
          c14=spi8*d9+cpi8*d14;

          c10= -cpi8*d13-spi8*d10;
          c13= -cpi8*d10+spi8*d13;
                  e16=d19+d16;
          c19=d16-d19;
                  e17=d18+d17;
          c18=d17-d18;
          c20=d23-d20;
                  e23=d20+d23;
          c21=d22-d21;
                  e22=d21+d22;
                  e24=d27+d24;
          c27=d24-d27;
                  e25=d26+d25;
          c26=d25-d26;
          c28=d31-d28;
                  e31=d28+d31;
          c29=d30-d29;
                  e30=d29+d30;

        /* fifth stage of fast idct */

          e0=c3+c0;
          e3=c0-c3;
          e1=c2+c1;
          e2=c1-c2;
          e5=cpi4*(c6-c5);
          e6=cpi4*(c6+c5);
                  d8=c11+c8;
          e11=c8-c11;
                  d9=c10+c9;
          e10=c9-c10;
          e12=c15-c12;
                  d15=c12+c15;
          e13=c14-c13;
                  d14=c13+c14;
          e18=spi8*c29-cpi8*c18;
          e29=spi8*c18+cpi8*c29;

          e19=spi8*c28-cpi8*c19;
          e28=spi8*c19+cpi8*c28;

          e20= -cpi8*c27-spi8*c20;
          e27= -cpi8*c20+spi8*c27;

          e21= -cpi8*c26-spi8*c21;
          e26= -cpi8*c21+spi8*c26;

        /* sixth stage of fast dct */

          d0=e0+e7;
          d7=e0-e7;

          d1=e1+e6;
          d6=e1-e6;

          d2=e2+e5;
          d5=e2-e5;

          d3=e3+e4;
          d4=e3-e4;

          d10=cpi4*(e13-e10);
          d13=cpi4*(e13+e10);

          d11=cpi4*(e12-e11);
          d12=cpi4*(e12+e11);

                  c16=e23+e16;
          d23=e16-e23;

                  c17=e22+e17;
          d22=e17-e22;

                  c18=e21+e18;
          d21=e18-e21;

                  c19=e20+e19;
          d20=e19-e20;

          d24=e31-e24;
                  c31=e24+e31;

          d25=e30-e25;
                  c30=e25+e30;

          d26=e29-e26;
                  c29=e26+e29;

          d27=e28-e27;
                  c28=e27+e28;

        /* seventh stage of fast dct */

          c0=d0+d15;
          c15=d0-d15;

          c1=d1+d14;
          c14=d1-d14;

          c2=d2+d13;
          c13=d2-d13;

          c3=d3+d12;
          c12=d3-d12;

          c4=d4+d11;
          c11=d4-d11;

          c5=d5+d10;
          c10=d5-d10;

          c6=d6+d9;
          c9=d6-d9;

          c7=d7+d8;
          c8=d7-d8;

          c20=cpi4*(d27-d20);
          c27=cpi4*(d27+d20);

          c21=cpi4*(d26-d21);
          c26=cpi4*(d26+d21);

          c22=cpi4*(d25-d22);
          c25=cpi4*(d25+d22);

          c23=cpi4*(d24-d23);
          c24=cpi4*(d24+d23);


        /* last stage of fast idct */
          out_block_ptr = &out_block[0];
          *out_block_ptr++ = c0+c31;
          *out_block_ptr++ = c1+c30;
          *out_block_ptr++ = c2+c29;
          *out_block_ptr++ = c3+c28;
          *out_block_ptr++ = c4+c27;
          *out_block_ptr++ = c5+c26;
          *out_block_ptr++ = c6+c25;
          *out_block_ptr++ = c7+c24;
          *out_block_ptr++ = c8+c23;
          *out_block_ptr++ = c9+c22;
          *out_block_ptr++ = c10+c21;
          *out_block_ptr++ = c11+c20;
          *out_block_ptr++ = c12+c19;
          *out_block_ptr++ = c13+c18;
          *out_block_ptr++ = c14+c17;
          *out_block_ptr++ = c15+c16;
          *out_block_ptr++ = -c16+c15;
          *out_block_ptr++ = -c17+c14;
          *out_block_ptr++ = -c18+c13;
          *out_block_ptr++ = -c19+c12;
          *out_block_ptr++ = -c20+c11;
          *out_block_ptr++ = -c21+c10;
          *out_block_ptr++ = -c22+c9;
          *out_block_ptr++ = -c23+c8;
          *out_block_ptr++ = -c24+c7;
          *out_block_ptr++ = -c25+c6;
          *out_block_ptr++ = -c26+c5;
          *out_block_ptr++ = -c27+c4;
          *out_block_ptr++ = -c28+c3;
          *out_block_ptr++ = -c29+c2;
          *out_block_ptr++ = -c30+c1;
          *out_block_ptr++ = -c31+c0;
}

/*
 * Name:    ScFDCT
 * Purpose: FDCT takes the fast forward DCT of 32 data points
 * optimize: 21%
 */
void ScFDCT(float in_block[32],float out_block1[32],float out_block2[32])
{
        static float            cpi4,cpi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init = 1;

        register float          c0,c1,c2,c3,c4,c5,c6,c7,c8;
        register float          c9,c10,c11,c12,c13,c14,c15;
        register float          c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;

/* initialization.  This is to be done only once. */

        if(init) {
        /* establish internal variables */
          float   temp;
          cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
          init = 0;
        }

        /* first stage of fast dct */

          c0= in_block[0] + in_block[31];
          c1= in_block[1] + in_block[30];
          c2= in_block[2] + in_block[29];
          c3= in_block[3] + in_block[28];
          c4= in_block[4] + in_block[27];
          c5= in_block[5] + in_block[26];
          c6= in_block[6] + in_block[25];
          c7= in_block[7] + in_block[24];
          c8= in_block[8] + in_block[23];
          c9= in_block[9] + in_block[22];
          c10= in_block[10] + in_block[21];
          c11= in_block[11] + in_block[20];
          c12= in_block[12] + in_block[19];
          c13= in_block[13] + in_block[18];
          c14= in_block[14] + in_block[17];
          c15= in_block[15] + in_block[16];

                  d16= in_block[15] - in_block[16];
                  d17= in_block[14] - in_block[17];
                  d18= in_block[13] - in_block[18];
                  d19= in_block[12] - in_block[19];
          c20= in_block[11] - in_block[20];
          c21= in_block[10] - in_block[21];
          c22= in_block[9] - in_block[22];
          c23= in_block[8] - in_block[23];
          c24= in_block[7] - in_block[24];
          c25= in_block[6] - in_block[25];
          c26= in_block[5] - in_block[26];
          c27= in_block[4] - in_block[27];
                  d28= in_block[3] - in_block[28];
                  d29= in_block[2] - in_block[29];
                  d30= in_block[1] - in_block[30];
                  d31= in_block[0] - in_block[31];

        /* second stage of fast dct */

          d0=c0+c15;
          d1=c1+c14;
          d2=c2+c13;
          d3=c3+c12;
          d4=c4+c11;
          d5=c5+c10;
          d6=c6+c9;
          d7=c7+c8;
                  e8=c7-c8;
                  e9=c6-c9;
          d10=c5-c10;
          d11=c4-c11;
          d12=c3-c12;
          d13=c2-c13;
                  e14=c1-c14;
                  e15=c0-c15;
          d20=cpi4*(c27-c20);
          d21=cpi4*(c26-c21);
          d22=cpi4*(c25-c22);
          d23=cpi4*(c24-c23);
          d24=cpi4*(c24+c23);
          d25=cpi4*(c25+c22);
          d26=cpi4*(c26+c21);
          d27=cpi4*(c27+c20);

        /* third stage of fast dct */

          e0=d0+d7;
          e1=d1+d6;
          e2=d2+d5;
          e3=d3+d4;
                  c4=d3-d4;
          e5=d2-d5;
          e6=d1-d6;
                  c7=d0-d7;
          e10=cpi4*(d13-d10);
          e11=cpi4*(d12-d11);
          e12=cpi4*(d12+d11);
          e13=cpi4*(d13+d10);
                c16=d23+d16;
                c17=d22+d17;
          e18=d21+d18;
          e19=d20+d19;
          e20=d19-d20;
          e21=d18-d21;
                  c22=d17-d22;
                  c23=d16-d23;
                  c24=d31-d24;
                  c25=d30-d25;
          e26=d29-d26;
          e27=d28-d27;
          e28=d27+d28;
          e29=d26+d29;
                  c30=d25+d30;
                  c31=d24+d31;

        /* fourth stage of fast dct */

          c0=e3+e0;
          c1=e2+e1;
          c2=e1-e2;
          c3=e0-e3;
          c5=cpi4*(e6-e5);
          c6=cpi4*(e6+e5);
                  d8=e11+e8;
          c9=e10+e9;
          c10=e9-e10;
                  d11=e8-e11;
                  d12=e15-e12;
          c13=e14-e13;
          c14=e13+e14;
                  d15=e12+e15;
          c18=spi8*e29-cpi8*e18;
          c19=spi8*e28-cpi8*e19;
          c20= -cpi8*e27-spi8*e20;
          c21= -cpi8*e26-spi8*e21;
          c26= -cpi8*e21+spi8*e26;
          c27= -cpi8*e20+spi8*e27;
          c28=spi8*e19+cpi8*e28;
          c29=spi8*e18+cpi8*e29;

        /* fifth stage of fast dct */

                  d0=cpi4*(c1+c0);              /*done*/
                  d1=cpi4*(c0-c1);              /*done*/
                  d2=cpi8*c3+spi8*c2;           /*done*/
                  d3= -cpi8*c2+spi8*c3;         /*done*/
          d4=c5+c4;
          d5=c4-c5;
          d6=c7-c6;
          d7=c6+c7;
          d9=spi8*c14-cpi8*c9;
          d10= -cpi8*c13-spi8*c10;
          d13= -cpi8*c10+spi8*c13;
          d14=spi8*c9+cpi8*c14;
                  e16=c19+c16;
          d17=c18+c17;
          d18=c17-c18;
                  e19=c16-c19;
                  e20=c23-c20;
          d21=c22-c21;
          d22=c21+c22;
                  e23=c20+c23;
                  e24=c27+c24;
          d25=c26+c25;
          d26=c25-c26;
                  e27=c24-c27;
                  e28=c31-c28;
          d29=c30-c29;
          d30=c29+c30;
                  e31=c28+c31;

        /* sixth stage of fast dct */
                  e4=cpi16*d7+spi16*d4;         /*done*/
                  e5=s3pi16*d6+c3pi16*d5;       /*done*/
                  e6= -s3pi16*d5+c3pi16*d6;     /*done*/
                  e7= -cpi16*d4+spi16*d7;       /*done*/
          e8=d9+d8;
          e9=d8-d9;
          e10=d11-d10;
          e11=d10+d11;
          e12=d13+d12;
          e13=d12-d13;
          e14=d15-d14;
          e15=d14+d15;
          e17=spi16*d30-cpi16*d17;
          e18= -cpi16*d29-spi16*d18;
          e29= -cpi16*d18+spi16*d29;
          e30=spi16*d17+cpi16*d30;

          e21=c3pi16*d26-s3pi16*d21;
          e22= -s3pi16*d25-c3pi16*d22;
          e25= -s3pi16*d22+c3pi16*d25;
          e26=c3pi16*d21+s3pi16*d26;

        /* seventh stage of fast dct */

                  d8=cpi32*e15+spi32*e8;        /*done*/
                  d9=s7pi32*e14+c7pi32*e9;      /*done*/
                  d10=c5pi32*e13+s5pi32*e10;    /*done*/
                  d11=s3pi32*e12+c3pi32*e11;    /*done*/
                  d12= -s3pi32*e11+c3pi32*e12;  /*done*/
                  d13= -c5pi32*e10+s5pi32*e13;  /*done*/
                  d14= -s7pi32*e9+c7pi32*e14;   /*done*/
                  d15= -cpi32*e8+spi32*e15;     /*done*/
          c16=e17+e16;
          c17=e16-e17;
          c18=e19-e18;
          c19=e18+e19;
          c20=e21+e20;
          c21=e20-e21;
          c22=e23-e22;
          c23=e22+e23;
          c24=e25+e24;
          c25=e24-e25;
          c26=e27-e26;
          c27=e26+e27;
          c28=e29+e28;
          c29=e28-e29;
          c30=e31-e30;
          c31=e30+e31;


        /* last stage of fast dct */

          d16=cpi64*c31+spi64*c16;      /*done*/
          d17=c17pi64*c30+s17pi64*c17;  /*done*/
          d18=c9pi64*c29+s9pi64*c18;    /*done*/
          d19=c25pi64*c28+s25pi64*c19;  /*done*/
          d20=c5pi64*c27+s5pi64*c20;    /*done*/
          d21=c21pi64*c26+s21pi64*c21;  /*done*/
          d22=c13pi64*c25+s13pi64*c22;  /*done*/
          d23=c29pi64*c24+s29pi64*c23;  /*done*/
          d24= -c29pi64*c23+s29pi64*c24;/*done*/
          d25= -c13pi64*c22+s13pi64*c25;/*done*/
          d26= -c21pi64*c21+s21pi64*c26;/*done*/
          d27= -c5pi64*c20+s5pi64*c27;  /*done*/
          d28= -c25pi64*c19+s25pi64*c28;/*done*/
          d29= -c9pi64*c18+s9pi64*c29;  /*done*/
          d30= -c17pi64*c17+s17pi64*c30;/*done*/
          d31= -cpi64*c16+spi64*c31;    /*done*/

        /* rearrange coefficients to undo bit reversed ordering */
          out_block2[16] = -d0;/******** normalization done in window********/
          out_block2[15] = -d16;
          out_block2[14] = -d8;
          out_block2[13] = -d24;
          out_block2[12] = -e4;
          out_block2[11] = -d20;
          out_block2[10] = -d12;
          out_block2[9] = -d28;
          out_block2[8] = -d2;
          out_block2[7] = -d18;
          out_block2[6] = -d10;
          out_block2[5] = -d26;
          out_block2[4] = -e6;
          out_block2[3] = -d22;
          out_block2[2] = -d14;
          out_block2[1] = -d30;
          out_block2[0] = -d1;

          out_block1[0] =d1;
          out_block1[1] =d17;
          out_block1[2] =d9;
          out_block1[3] =d25;
          out_block1[4] =e5;
          out_block1[5] =d21;
          out_block1[6] =d13;
          out_block1[7] =d29;
          out_block1[8] =d3;
          out_block1[9] =d19;
          out_block1[10] =d11;
          out_block1[11] =d27;
          out_block1[12] =e7;
          out_block1[13] =d23;
          out_block1[14] =d15;
          out_block1[15] =d31;
          out_block1[16] = F 0;
}

/*
** Name:      ScFDCT8x8_C
** Purpose:   2-d Forward DCT (C version).  Customized for (8x8) blocks
**            "c" version
**
*/
void ScFDCT8x8_C(float *ipbuf, float *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        register float *spptr, *interptr;
        register float *spptr_int;
        float tempptr[64];


        spptr_int = ipbuf;
        interptr = tempptr;

        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr_int[0] + spptr_int[7];
           t7  = spptr_int[0] - spptr_int[7];
           t1  = spptr_int[1] + spptr_int[6];
           t6  = spptr_int[1] - spptr_int[6];
           t2  = spptr_int[2] + spptr_int[5];
           t5  = spptr_int[2] - spptr_int[5];
           t3  = spptr_int[3] + spptr_int[4];
           t4  = spptr_int[3] - spptr_int[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           interptr[16]  = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr_int +=  8;
           interptr++;
        }


        spptr = tempptr;
        interptr = outbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr[0] + spptr[7];
           t7  = spptr[0] - spptr[7];
           t1  = spptr[1] + spptr[6];
           t6  = spptr[1] - spptr[6];
           t2  = spptr[2] + spptr[5];
           t5  = spptr[2] - spptr[5];
           t3  = spptr[3] + spptr[4];
           t4  = spptr[3] - spptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           interptr[16] = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr +=  8;
           interptr++;
       }
}

static const float dct_constants[64] = {
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.09011998,   F 0.06497288,   F 0.06897485,   F 0.07664075,
       F 0.09011998,   F 0.11470097,   F 0.16652001,   F 0.32664075,
   F 0.09567086,   F 0.06897485,   F 0.07322331,   F 0.08136138,
       F 0.09567086,   F 0.12176590,   F 0.17677669,   F 0.34675997,
   F 0.10630377,   F 0.07664074,   F 0.08136138,   F 0.09040392,
       F 0.10630377,   F 0.13529903,   F 0.19642374,   F 0.38529903,
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.15909483,   F 0.11470097,   F 0.12176590,   F 0.13529903,
       F 0.15909483,   F 0.20248929,   F 0.29396889,   F 0.57664073,
   F 0.23096988,   F 0.16652001,   F 0.17677669,   F 0.19642374,
       F 0.23096988,   F 0.29396892,   F 0.42677671,   F 0.83715260,
   F 0.45306373,   F 0.32664075,   F 0.34675995,   F 0.38529903,
       F 0.45306373,   F 0.57664073,   F 0.83715260,   F 1.64213395
};

/*
** Name:      ScFDCT8x8s_C
** Purpose:   2-d Forward DCT (C version) for (8x8) blocks
**
*/
void ScFDCT8x8s_C(short *inbuf, short *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        float *tempptr, tempbuf[64];
        const float *cptr=dct_constants;

        tempptr=tempbuf;
        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = F (inbuf[0] + inbuf[7]);
           t7  = F (inbuf[0] - inbuf[7]);
           t1  = F (inbuf[1] + inbuf[6]);
           t6  = F (inbuf[1] - inbuf[6]);
           t2  = F (inbuf[2] + inbuf[5]);
           t5  = F (inbuf[2] - inbuf[5]);
           t3  = F (inbuf[3] + inbuf[4]);
           t4  = F (inbuf[3] - inbuf[4]);

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;

           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           tempptr[32]  = t0 - t1;
           tempptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           tempptr[16]  = t2 + t3;
           tempptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           tempptr[8]  = t5 + t6;
           tempptr[56] = t5 - t6;
           tempptr[24] = t7 - t4;
           tempptr[40] = t7 + t4;

           inbuf +=  8;
           tempptr++;
        }


        tempptr = tempbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = tempptr[0] + tempptr[7];
           t7  = tempptr[0] - tempptr[7];
           t1  = tempptr[1] + tempptr[6];
           t6  = tempptr[1] - tempptr[6];
           t2  = tempptr[2] + tempptr[5];
           t5  = tempptr[2] - tempptr[5];
           t3  = tempptr[3] + tempptr[4];
           t4  = tempptr[3] - tempptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           outbuf[32]  = (short) floorf((t0 - t1)*cptr[4]+0.499999);
           outbuf[0]   = (short) floorf((t0 + t1)*cptr[0]+0.499999);
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           outbuf[16] = (short) floorf((t2 + t3)*cptr[2]+0.499999);
           outbuf[48] = (short) floorf((t3 - t2)*cptr[6]+0.499999);

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           outbuf[8]  = (short) floorf((t5 + t6)*cptr[1]+0.499999);
           outbuf[56] = (short) floorf((t5 - t6)*cptr[7]+0.499999);
           outbuf[24] = (short) floorf((t7 - t4)*cptr[3]+0.499999);
           outbuf[40] = (short) floorf((t7 + t4)*cptr[5]+0.499999);

           tempptr += 8;
           cptr    += 8;
           outbuf++;
       }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_mem.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_mem.c,v $
 * Revision 1.1.4.2  1996/01/02  18:30:56  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:04  Bjorn_Engberg]
 *
 * Revision 1.1.2.4  1995/09/20  14:59:33  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.3  1995/09/14  17:28:09  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:21:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:53  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:15:46  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/03  19:12:55  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:17  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  17:46:54  Hans_Graves
 * 	Added ScAlloc2()
 * 	[1995/04/17  17:45:28  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:40:03  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:39:43  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
**  Modification History: sc_mem.c
**      05-29-93  Victor Bahl  Paged aligned malloc and free
**      12-07-93  PSG          Added error reporting code
**      03-15-95  HWG          Moved to Su library, Added SuAlloc & SuFree
**      04-04-97  HWG          With WIN32 use LocalAlloc and LocalFree in
**                               place of malloc and free
**                             Added ScCalloc function.
**      04-15-97  HWG          Added memory linked list to help track leaks
**                             Fixed potential initalization bug in linked
**                               list used to track ScPaMalloc's
--------------------------------------------------------------------------*/
/*
#define _SLIBDEBUG_
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <stdlib.h>
#include <malloc.h>
#endif /* WIN32 */
#include "SC.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   0  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */

/* keep a linked list to ttrack memory leaks */
typedef struct memblock_s {
    void *ptr;
    dword size;
    dword counter;
    char  desc[15];
    struct memblock_s *next;
} memblock_t;

static memblock_t *_blocklist=NULL;
static _blockcounter=0;
static _memused=0;

void scMemAddWatch(void *ptr, dword size, char *desc)
{
  memblock_t *pblock;
#if defined(WIN32)
  pblock = (void *)LocalAlloc(LPTR, sizeof(memblock_t));
#else
  pblock = (void *)malloc(sizeof(memblock_t));
#endif
  _memused+=size;
  if (pblock)
  {
    pblock->ptr=ptr;
    pblock->next=_blocklist;
    pblock->size=size;
    pblock->counter=_blockcounter;
    if (desc==NULL)
      pblock->desc[0]=0;
    else
    {
      int i;
      for (i=0; desc[i] && i<14; i++)
        pblock->desc[i]=desc[i];
      pblock->desc[i]=0;
    }
    _blocklist=pblock;
    _blockcounter++;
  }
}

ScBoolean_t scMemRemoveWatch(void *ptr)
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  while (pblock)
  {
    if (pblock->ptr==ptr) /* remove from list */
    {
      if (plastblock==NULL) /* beginning of linked list */
        _blocklist=pblock->next;
      else
        plastblock->next=pblock->next;
      _memused-=pblock->size;
#ifdef WIN32
      LocalFree(pblock);
#else
      free(pblock);
#endif
      if (_blocklist==NULL) /* all memory freed, reset counter */
        _blockcounter=0;
      return(TRUE);
    }
    plastblock=pblock;
    pblock=pblock->next;
  }
  return(FALSE);
}

dword scMemDump()
{
  memblock_t *plastblock=NULL, *pblock=_blocklist;
  ScDebugPrintf(NULL, "scMemDump: memused=%ld\n", _memused);
  while (pblock)
  {
    ScDebugPrintf(NULL, " ptr=%p counter=%ld size=%ld desc=%s\n",
        pblock->ptr, pblock->counter, pblock->size, pblock->desc);
    pblock=pblock->next;
  }
  return(_memused);
}
#endif

#ifdef WIN32
int getpagesize()
{
    SYSTEM_INFO sysInfo;
    static int pagesize = 0 ;

    if( pagesize == 0 ) {
	GetSystemInfo(&sysInfo);

	pagesize = (int)sysInfo.dwPageSize;
    }

    return pagesize ;
}

#define bzero(_addr_,_len_) memset(_addr_,0,_len_)
#endif

/*------------------------------------------------------------------------
                         Simple Memory Allocation
-------------------------------------------------------------------------*/
/*
** Name:    ScAlloc
** Purpose: Allocate number of bytes of memory.
**
*/
void *ScAlloc(unsigned long bytes)
{
  void *ptr;

#ifdef  MACINTOSH
  ptr = NewPtr(bytes);
#elif MSC60
  ptr = (void FAR *) _fmalloc((unsigned int)bytes); /* far memory */
#elif defined(WIN32)
  ptr = (void *)LocalAlloc(LPTR, bytes);
#else
  ptr = (void *)malloc(bytes);
#endif
  _SlibDebug(ptr, scMemAddWatch(ptr, bytes, NULL) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScAlloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScCalloc
** Purpose: Allocate number of bytes of memory and zero it out.
**
*/
void *ScCalloc(unsigned long bytes)
{
  void *ptr = ScAlloc(bytes);
  if (ptr != NULL)
  {
#ifdef  MSC60
     _fmemset(ptr, 0, (unsigned int)bytes);
#else
     memset(ptr, 0, bytes);
#endif
  }
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScCalloc(%ld) returns %p\n",bytes,ptr) );
  return(ptr);
}

/*
** Name:    ScAlloc2
** Purpose: Allocate number of bytes of memory equal to "bytes".
**          Takes an extra argument "name" which identifies the block
**          (used for debugging).
*/
void *ScAlloc2(unsigned long bytes, char *desc)
{
  void *ptr;

  ptr = ScAlloc(bytes);
#ifdef _SLIBDEBUG_
  if (_blocklist) /* copy description to leak tracking info */
  {
    int i;
    for (i=0; desc[i] && i<14; i++)
      _blocklist->desc[i]=desc[i];
    _blocklist->desc[i]=0;
  }
#endif
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "ScAlloc(%ld, %s) returns %p\n",bytes,desc,ptr) );
  return(ptr);
}

/*
** Name:    ScFree
** Purpose: Free memory pointed to by "*ptr_addr"
**
*/
void ScFree(void *ptr)
{
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "ScFree(%p)\n", ptr) );
  _SlibDebug(ptr, scMemRemoveWatch(ptr) );
  if (ptr != NULL)
  {
#ifdef MACINTOSH
    DisposPtr(ptr);
#elif defined(WIN32)
#ifdef _SLIBDEBUG_
    _SlibDebug(LocalFree(ptr)!=NULL, ScDebugPrintf(NULL, "ScFree(%p) failed\n", ptr) );
#else
    LocalFree(ptr);
#endif
#else
    free(ptr);
#endif
  }
}

/*
** Name:    ScMemCheck
** Purpose: Check block of memory all equal to a single byte,
**          else return FALSE
*/
int ScMemCheck(char *array, int test, int num)
{
  int i=0;
  /* 'test' is only tested as a char (bottom 8 bits) */
  while (array[i] == test && i<num)
    i++;
  if (i==num)
    return TRUE;
  else
    return FALSE;
}

/*------------------------------------------------------------------------
                Paged aligned malloc() and free()
-------------------------------------------------------------------------*/

/*
** This structure is used by the page align malloc/free support code.
** These "working sets" will  contain  the malloc-ed address and the
** page aligned address for the free*() call.
*/
typedef struct mpa_ws_s
{
    char *palign_addr;          /* the page aligned address that's used */
    char *malloc_addr;          /* the malloc-ed address to free */
    struct mpa_ws_s *next;      /* for the next on the list */
} mpa_ws_t;


/*
** Initialized and uninitialized data.
*/
static mpa_ws_t *mpa_qhead=NULL;      /* local Q head for the malloc stuctures */


/*
** Name:    ScPaMalloc
** Purpose: Allocate Paged Alligned Memory
**          This  routine  allocates  and returns to  the caller a system
**          page  aligned buffer. Enough  space  will  be added, one more
**          page, to allow the pointers to be  adjusted  to the next page
**          boundry. A local linked list will keep copies of the original
**          and adjusted addresses. This list will be used by sv_PaFree()
**          to free the correct buffer.
**
*/
char *ScPaMalloc(int size)
{
    mpa_ws_t *ws;                 /* pointer for the working set  */
    ULONG_PTR tptr;               /* to store pointer temp for bit masking */
    int PageSize = getpagesize(); /* system's page size           */

    /*
    ** The space for the working set structure that will go on the queue
    ** is allocated first.
    */
    if ((ws = (mpa_ws_t *)ScAlloc(sizeof(mpa_ws_t))) == (mpa_ws_t *)NULL)
        return( (char *)NULL );


    /*
    ** Using the requested size, from the argument list, and the page size
    ** from the system,  allocate enough space to page align the requested
    ** buffer.  The original request will have the space of one system page
    ** added to it.  The pointer will be adjusted.
    */
    ws->malloc_addr = (char *)ScAlloc(size + PageSize);
    if (ws->malloc_addr == (char *)NULL)
    {
      ScFree(ws);                              /* not going to be used */
      return((char *)NULL);                    /* signal the failure */
    } else
        (void) bzero (ws->malloc_addr, (size + PageSize));

    /*
    ** Now using the allocated space + 1 page, adjust the pointer to
    ** point to the next page boundry.
    */
    ws->palign_addr = ws->malloc_addr + PageSize;       /* to the next page */

    /*
    ** Using the page size and subtracting 1 to get a bit mask, mask off
    ** the low order "page offset" bits to get the aligned address.  Now the
    ** aligned pointer will contain the address of the next page with enough
    ** space to hold the users requested size.
    */
    tptr  = (ULONG_PTR)ws->palign_addr;            /* copy to local int    */
    tptr &= (ULONG_PTR)(~(PageSize - 1));          /* Mask addr bit to the */
    ws->palign_addr = (char *)tptr;             /* put back the address */
    /*
    ** Put the working set onto the linked list so that the original
    ** malloc-ed buffer can be freeed when the user program is done with it.
    */
    ws->next=mpa_qhead;
    mpa_qhead=ws;                  /* just put it at the head */

    /*
    ** Now return the aligned address to the caller.
    */
    return((char *)ws->palign_addr);
}

/*
** Name:    ScPaFree
** Purpose: This is a local free routine to return to the system a previously
**          alloc-ed buffer.  A local linked list keeps copies of the original
**          and adjusted addresses.  This list is used by this routine to free
**          the correct buffer.
*/
void ScPaFree (void *pa_addr)
{
    mpa_ws_t *p, *q;                    /* walkers for the malloc list */

    /*
    ** Walk along the malloc-ed memory linked list, watch for a match
    ** on the page aligned address.  If a match is found break out of the
    ** loop.
    */
    p = mpa_qhead;                 /* set the pointers */
    q = NULL;

    while (p != NULL)
    {
       if (p->palign_addr == pa_addr)   /* found the buffer */
          break;

       q = p;                           /* save current */
       p = p->next;                     /* get next */
    }
    _SlibDebug(_WARN_ && p==NULL,
      ScDebugPrintf(NULL, "ScPaFree(%p) Illegal pointer\n", pa_addr) );

    /*
    ** After falling out of the loop the pointers are at the place where
    ** some work has to be done, (this could also be at the beginning).
    ** If a match is found call the free() routine to return the buffer, if
    ** the loop fell off the end just return.
    */
    if (p != NULL)
    {
        /*
        ** Where on the list is it, check for making it empty.
        */
        if (q == NULL)                   /* at the front */
            mpa_qhead = p->next;   /* pop off front */
        else                            /* inside the list */
            q->next = p->next;          /* pop it */

        ScFree(p->malloc_addr);           /* free the malloc-ed addr */

        /*
        ** Now free up the working set, it is not needed any more.
        */
        ScFree(p);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SV.h,v $
 * Revision 1.1.10.6  1996/10/28  17:32:21  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  17:05:52  Hans_Graves]
 *
 * Revision 1.1.10.5  1996/10/12  17:18:18  Hans_Graves
 * 	Rearranged PARAMs. Added SV_PARAM_HALFPEL and SV_PARAM_SKIPPEL.
 * 	[1996/10/12  16:55:44  Hans_Graves]
 * 
 * Revision 1.1.10.4  1996/09/18  23:45:53  Hans_Graves
 * 	More PARAMs
 * 	[1996/09/18  21:56:45  Hans_Graves]
 * 
 * Revision 1.1.10.3  1996/07/19  02:11:02  Hans_Graves
 * 	Added SV_PARAM_DEBUG
 * 	[1996/07/19  01:23:39  Hans_Graves]
 * 
 * Revision 1.1.10.2  1996/05/07  19:55:54  Hans_Graves
 * 	Added SV_HUFF_DECODE and SV_HUFF_ENCODE
 * 	[1996/05/07  17:23:47  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/04/10  21:47:20  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:51  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/04/04  23:35:03  Hans_Graves
 * 	Added SV_PARAM_FINALFORMAT enum
 * 	[1996/04/04  23:02:48  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/04/01  15:17:45  Bjorn_Engberg
 * 	Replace include mmsystem.h with windows.h and mmreg.h for NT.
 * 	[1996/04/01  14:58:57  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/03/29  22:21:06  Hans_Graves
 * 	Include <mmsystem.h> here only
 * 	[1996/03/29  21:48:59  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/03/16  19:22:55  Karen_Dintino
 * 	added H261 NT includes
 * 	[1996/03/16  18:39:31  Karen_Dintino]
 * 
 * Revision 1.1.6.4  1996/02/06  22:53:54  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/01/02  18:31:16  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:05  Bjorn_Engberg]
 * 
 * Revision 1.1.6.2  1995/12/07  19:31:23  Hans_Graves
 * 	Added defs for SV_MPEG_ENCODE,SV_MPEG2_DECODE,SV_MPEG2_ENCODE,IT_FULL,FULL_WIDTH,FULL_HEIGHT
 * 	[1995/12/07  17:59:38  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/22  18:17:02  Hans_Graves
 * 	Remove MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  18:14:14  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/22  15:04:40  Hans_Graves
 * 	Added definitions for MPEG_SUPPORT, H261_SUPPORT, and JPEG_SUPPORT
 * 	[1995/09/22  15:04:22  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/20  14:59:39  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:40:10  Bjorn_Engberg]
 * 
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:57:52  Paul_Gauthier]
 * 
 * Revision 1.1.2.15  1995/09/05  14:52:39  Hans_Graves
 * 	Removed BI_* definitions - moved to SC.h
 * 	[1995/09/05  14:50:45  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/08/31  21:13:27  Paul_Gauthier
 * 	Add SV_JPEG_QUANT_NEW/OLD definitions
 * 	[1995/08/31  21:13:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.12  1995/08/08  13:21:17  Hans_Graves
 * 	Added Motion Estimation types
 * 	[1995/08/07  22:03:30  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/31  21:11:02  Karen_Dintino
 * 	Add yuv12 definition
 * 	[1995/07/31  19:27:58  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/07/26  17:48:56  Hans_Graves
 * 	Added prototypes for sv_GetMpegImageInfo() and sv_GetH261ImageInfo().
 * 	[1995/07/26  17:45:14  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/21  17:41:03  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:31  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/17  22:01:33  Hans_Graves
 * 	Defined SvBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:45:06  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/17  16:12:05  Hans_Graves
 * 	Added extern's to prototypes.
 * 	[1995/07/17  15:56:16  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:17  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.4 **}
 * 		{** Merge revision:	1.1.2.5 **}
 * 	{** End **}
 * 	Add H.261 Decompress support
 * 	[1995/07/01  18:27:43  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/22  21:35:06  Hans_Graves
 * 	Moved filetypes to SC.h
 * 	[1995/06/22  21:29:42  Hans_Graves]
 * 
 * 	Added TimeCode parameter to SvPictureInfo struct
 * 	[1995/04/26  19:23:55  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/19  20:30:48  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:13:47  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:31  Hans_Graves
 * 	Added SvGetInputBitstream() prototype.
 * 	[1995/06/09  16:36:52  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:38  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:28:39  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/01/17  16:40:30  Paul_Gauthier
 * 	Use Modified Adjust LUTs for Indeo video
 * 	[1995/01/17  16:38:31  Paul_Gauthier]
 * 
 * Revision 1.1.2.8  1994/12/12  15:39:28  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:59  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:26  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/08  21:58:59  Paul_Gauthier
 * 	Changed <mmsystem.h> to <mme/mmsystem.h>
 * 	[1994/11/08  21:47:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/25  19:17:47  Paul_Gauthier
 * 	Changes for random access
 * 	[1994/10/25  19:09:07  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:55  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:45  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:43  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:59  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:51:19  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:05  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*	"%Z% %M% revision %I%; last modified %G%"; */
/*
**                              SV.h 
**
**    User required data structures for Software Video Codec
**
*/

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*---------------------------------------------------------------------------
 * Modification History: SV.h 
 *
 *   08-Sep-1994  PSG   Modified to include MPEG decoder
 *   10-Jan-1994  VB	Created for SLIB 
 *--------------------------------------------------------------------------*/

#ifndef _SV_H_
#define _SV_H_

#ifndef _SV_COMMON_
#define _SV_COMMON_

#include <sys/types.h>
#include "SC.h"

#define SV_CONTINUE 0
#define SV_ABORT    1

typedef void      *SvHandle_t;       /* Identifies a codec or renderer */
typedef ScStatus_t SvStatus_t;       /* Return status code */

#ifdef WIN32
#include <windows.h>
#include <mmreg.h>
#else /* !WIN32 */
#include <mmsystem.h> 
#endif /* !WIN32 */

#endif /* _SV_COMMON_ */

#define SV_USE_BUFFER       STREAM_USE_BUFFER
#define SV_USE_BUFFER_QUEUE STREAM_USE_QUEUE
#define SV_USE_FILE         STREAM_USE_FILE

typedef enum {
   SV_JPEG_DECODE = 100,
   SV_JPEG_ENCODE = 101,
   SV_MPEG_DECODE = 102,
   SV_MPEG_ENCODE = 103,
   SV_MPEG2_DECODE = 104,
   SV_MPEG2_ENCODE = 105,
   SV_H261_DECODE = 106,
   SV_H261_ENCODE = 107,
   SV_H263_DECODE = 108,
   SV_H263_ENCODE = 109,
   SV_HUFF_DECODE = 110,
   SV_HUFF_ENCODE = 111
} SvCodecType_e;

/*
** Parameters
*/
typedef enum {
  /* General params */
  SV_PARAM_WIDTH = 0x10,    /* image width */
  SV_PARAM_HEIGHT,          /* image height */
  SV_PARAM_BITRATE,         /* bit rate (bits per second) */
  SV_PARAM_NATIVEFORMAT,    /* native decompressed format (FOURCC) */
  SV_PARAM_FINALFORMAT,     /* Final format (format returned by codec) */
  SV_PARAM_BITSPERPIXEL,    /* Average bits per pixel */
  SV_PARAM_FPS,             /* frames per second */
  SV_PARAM_ASPECTRATIO,     /* Aspect ratio: height/width */
  SV_PARAM_BITSTREAMING,    /* is this a bitstreaming CODEC */
  /* Frame params */
  SV_PARAM_FRAME = 0x30,    /* current frame number */
  SV_PARAM_KEYSPACING,      /* I frames */
  SV_PARAM_SUBKEYSPACING,   /* P frames */
  /* Timecode/length */
  SV_PARAM_TIMECODE = 0x50, /* Actual frame timecode */
  SV_PARAM_CALCTIMECODE,    /* Calculated frame timecode for start of seq */
  SV_PARAM_LENGTH,          /* total video length in miliiseconds */
  SV_PARAM_FRAMES,          /* total video frames */
  /* Decode params */
  SV_PARAM_FRAMETYPE = 0x70, /* I, P, B or D frame */
  /* Encode params */
  SV_PARAM_ALGFLAGS,        /* Algorithm flags */
  SV_PARAM_MOTIONALG,       /* Motion estimation algorithm */
  SV_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SV_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SV_PARAM_QUANTI,          /* Intra-frame Quantization Step */
  SV_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SV_PARAM_QUANTB,          /* Bi-drectional frame Quantization Step */
  SV_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* Encode/Decode params */
  SV_PARAM_QUALITY=0x90,    /* Quality: 0=worst 99>=best */
  SV_PARAM_FASTDECODE,      /* Fast decode desired */
  SV_PARAM_FASTENCODE,      /* Fast decode desired */
  SV_PARAM_VBVBUFFERSIZE,   /* Video Buffer Verifier buffer size in bytes */
  SV_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SV_PARAM_FORMATEXT,       /* format extensions (i.e. rtp) */
  SV_PARAM_PACKETSIZE,      /* packet size in bytes (rtp) */
  SV_PARAM_DEBUG,           /* Setup debug info */
} SvParameter_t;

/*
** Old & new quantization modes for use by the "convertjpeg" program
** that converts JPEG clips using old quantiztion algorithm to new algorithm
*/
typedef enum {
   SV_JPEG_QUANT_NEW = 0,
   SV_JPEG_QUANT_OLD = 1
} SvQuantMode_e;

/*
** Store basic info for user about the codec
*/
typedef struct SV_INFO_s {
    u_int Version;              /* Codec version number  */
    int   CodecStarted;         /* SvDecompressBegin/End */
    u_int NumOperations;        /* Current # of decompresses */
} SV_INFO_t;

/*
** Image types
*/
#define IT_NTSC 0
#define IT_CIF  1
#define IT_QCIF 2
#define IT_FULL 3

/*
** Algorithms (Motion Estimation)
*/
#define ME_CRAWL        1
#define ME_BRUTE        2
#define ME_TEST1        3
#define ME_TEST2        4
#define ME_FASTEST      ME_CRAWL

/*
** Standard Image sizes
*/
#define FULL_WIDTH      640
#define FULL_HEIGHT     480
#define NTSC_WIDTH      320
#define NTSC_HEIGHT     240
#define SIF_WIDTH       352
#define SIF_HEIGHT      240
#define CIF_WIDTH       352
#define CIF_HEIGHT      288
#define SQCIF_WIDTH     128
#define SQCIF_HEIGHT    96
#define QCIF_WIDTH      176
#define QCIF_HEIGHT     144
#define CIF4_WIDTH      (CIF_WIDTH*2)
#define CIF4_HEIGHT     (CIF_HEIGHT*2)
#define CIF16_WIDTH     (CIF_WIDTH*4)
#define CIF16_HEIGHT    (CIF_HEIGHT*4)

/******************** MPEG structures & constants ***************************/

/*
** Picture types
*/
#define SV_I_PICTURE 1
#define SV_P_PICTURE 2
#define SV_B_PICTURE 4
#define SV_D_PICTURE 8
#define SV_ANY_PICTURE  SV_I_PICTURE | SV_P_PICTURE | SV_B_PICTURE
#define SV_ALL_PICTURES SV_ANY_PICTURE | SV_D_PICTURE

/*
** Status values returned by SvFindNextPicture
*/
#define SV_CAN_DECOMPRESS    1
#define SV_CANNOT_DECOMPRESS 2

/*
** SvPictureInfo_t describes picture found by CODEC
*/
typedef struct SvPictureInfo_s {
  int Type;                     /* SV_I_PICTURE | SV_P_PICTURE |             */
                                /* SV_B_PICTURE | SV_D_PICTURE               */
  int myStatus;                   /* CAN_DECOMPRESS or CANNOT_DECOMPRESS     */
  int TemporalRef;              /* Temporal reference # from picture header  */
  int PicNumber;                /* Cummulative picture num from stream start */
  qword ByteOffset;             /* Cummulative byte offset from stream start */
  qword TimeCode;               /* TimeCode: hours (5 bits), min (6 bits),   */
                                /*           sec (6 bits), frame (6 bits)    */
} SvPictureInfo_t;

/*
** SvCallbackInfo_t passes info back & forth during callback
*/
typedef ScCallbackInfo_t SvCallbackInfo_t;

/*
** Structure used in sv_GetMpegImageInfo call
*/
typedef struct SvImageInfo_s {
  int len;                      /* Meaning depends on file format */
  int precision;                /* Bits per pixel */
  int height;                   /* Height of images in pixels */
  int width;                    /* Width  of images in pixels */
  int numcomps;                 /* Number of color components present */
  float picture_rate;           /* Picture rate decoded from seq header */
} SvImageInfo_t;

/******************** End of MPEG structures & constants *********************/


/******************** JPEG structures & constants ****************************/

/*
** Huffman Tables (JPEG)
*/
typedef struct SvHTable_s {
    u_int bits[16];
    u_int value[256];
} SvHTable_t;


typedef struct SvHuffmanTables_s {
    SvHTable_t DcY;
    SvHTable_t DcUV;
    SvHTable_t AcY;
    SvHTable_t AcUV;
} SvHuffmanTables_t;


/*
** Quantization Tables (JPEG)
*/
typedef u_int SvQTable_t;
typedef struct SvQuantTables_s {
    SvQTable_t c1[64];
    SvQTable_t c2[64];
    SvQTable_t c3[64];
} SvQuantTables_t;

/******************** End of JPEG structures & constants *********************/

/*
** Table of contents structure
*/
typedef struct SvToc_s {
    u_int offset;                 /* Byte offset of start of video frame */
    u_int size;                   /* Size in bytes of frame */
    u_int type;                   /* Type of frame (SV_I_PICTURE, ...) */
} SvToc_t;

typedef struct IndexStr {         /* AVI-format table of contents entry */
  size_t        size;
  unsigned long offset;
} IndexStr, indexStr;

#define SvSetRate(Svh, Rate) SvSetParamInt(Svh, SV_PARAM_BITRATE, Rate)
#define SvSetFrameRate(Svh, FrameRate) SvSetParamFloat(Svh, SV_PARAM_FPS, FrameRate)

EXTERN SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh);
EXTERN SvStatus_t SvCloseCodec (SvHandle_t Svh);
EXTERN SvStatus_t SvDecompressQuery(SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                                    BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize);
EXTERN SvStatus_t SvDecompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			        u_char *DcmpImage, int MaxOutLen);
EXTERN SvStatus_t SvDecompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
    			           void *Buffer_UserData, int BufSize);
EXTERN SvStatus_t SvSetDataDestination (SvHandle_t Svh, int Source, int Fd, 
			                void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SvGetDataSource (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetDataDestination (SvHandle_t Svh);
EXTERN ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh);
EXTERN SvStatus_t SvFlush(SvHandle_t Svh);
EXTERN SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo);
EXTERN SvStatus_t SvFindNextPicture (SvHandle_t Svh, 
                                     SvPictureInfo_t *PictureInfo);
#ifdef JPEG_SUPPORT
EXTERN SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht);
EXTERN SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt);
EXTERN SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode);
EXTERN SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality);
EXTERN SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality);
#endif /* JPEG_SUPPORT */

EXTERN SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                  ScBoolean_t value);
EXTERN SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                  qword value);
EXTERN SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                  float value);
EXTERN ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
EXTERN qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param);
EXTERN float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param);

EXTERN SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvCompressEnd (SvHandle_t Svh);
EXTERN SvStatus_t SvCompress (SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *InputImage, int InLen, int *CmpBytes);
EXTERN SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize);
EXTERN SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, 
                                             BITMAPINFOHEADER *ImgOut);
EXTERN SvStatus_t SvRegisterCallback (SvHandle_t, 
          int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
          void *UserData);
#ifdef MPEG_SUPPORT
EXTERN SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetMpegImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
EXTERN SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr);
EXTERN SvStatus_t sv_GetH261ImageInfo(int fd, SvImageInfo_t *iminfo);
#endif /* H261_SUPPORT */

#endif /* _SV_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_err.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_errors.c,v $
 * Revision 1.1.7.2  1996/12/03  00:08:25  Hans_Graves
 * 	Added SvErrorEndOfSequence error.
 * 	[1996/12/03  00:07:32  Hans_Graves]
 *
 * Revision 1.1.5.2  1996/01/02  18:30:45  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:01  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/08/04  16:32:23  Karen_Dintino
 * 	Add new errors for H.261
 * 	[1995/08/04  16:25:15  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/07/26  17:48:53  Hans_Graves
 * 	Added errors: NoCompressBuffer and ClientEnd
 * 	[1995/07/26  17:46:13  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/11  22:11:26  Karen_Dintino
 * 	Add new H.261 Error Codes
 * 	[1995/07/11  21:56:35  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/07/11  14:50:37  Hans_Graves
 * 	Added ScErrorNet* errors
 * 	[1995/07/11  14:24:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:44  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:11:22  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:13:40  Hans_Graves
 * 	First time under SLIB
 * 	[1995/05/03  19:12:02  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:28:50  Hans_Graves
 * 	Redesigned error handling (taken from sv_printerrors.c)
 * 	     to handle multiple libraries (Sg, Su, Sv, Sa, Sr)
 * 	[1995/04/07  18:28:06  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <stdio.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"

char _serr_msg[80];

typedef struct ErrorDesc_s {
  int   code;
  char *name;
  char *text;
} ErrorDesc_t;

/*
** ErrorDesc is a table of all errors that need to be translated into
** text messages.  Order doesn't matter, except that if there are two
** error numbers which are of the same value, the first one will be
** returned.
** Note: Any %s contained in the message text will be filled by the
**       string assigned to _serr_msg
*/
static ErrorDesc_t ErrorDesc[] =
{
  NoErrors, 		"",
			"",
/******************** Sc (Common) **************************/
  ScErrorNone, 		"",
			"",
  ScErrorForeign,	"ScErrorForeign",
			"%s",
  ScErrorMemory,	"ScErrorMemory",
			"memory request denied",
  ScErrorBadPointer,	"ScErrorBadPointer",
			"Invalid pointer passed to function",
  ScErrorNullStruct, 	"ScErrorNullStruct",
			"Parameter set structure is required",
  ScErrorFile, 		"ScErrorFile",
                        "file",
  ScErrorEOI, 		"ScErrorEOI",
			"End of Input reached",
  ScErrorBadArgument, 	"ScErrorBadArgument",
			"Invalid argument to function",
  ScErrorSmallBuffer, 	"ScErrorSmallBuffer",
			"Buffer too small",
  ScErrorUnrecognizedFormat, "ScErrorUnrecognizedFormat",
			"Unrecognized format",
  ScErrorEndBitstream,	"ScErrorEndBitstream",
			"End of data bitstream reached",
  ScErrorBadQueueEmpty,	"ScErrorBadQueueEmpty",
			"Buffer queue is empty",
  ScErrorClientEnd,     "ScErrorClientEnd",
                        "Client ended processing",
  ScErrorNetConnectIn,  "ScErrorNetConnectIn",
			"No network connection made for input.",
  ScErrorNetConnectOut, "ScErrorNetConnectOut",
			"No network connection made for output.",
  ScErrorNetProtocol,   "ScErrorNetProtocol",
			"Unsupported network protocol.",
  ScErrorNetSend,       "ScErrorNetSend",
			"Network error sending data.",
  ScErrorNetReceive,    "ScErrorNetReceive",
			"Network error receiving data.",
  ScErrorNetBadHeader,  "ScErrorNetBadHeader",
			"Bad network data header received.",
  ScErrorNetBadTrailer, "ScErrorNetBadTrailer",
			"Bad network data trailor received.",
  ScErrorNetChecksum,   "ScErrorNetChecksum",
			"Checksum error on data received over network.",
/******************** Sv (Video) ****************************/
  SvErrorForeign,	"SvErrorForeign",
			"%s",
  SvErrorMemory,	"SvErrorMemory",
			"memory request denied",
  SvErrorBadPointer,	"SvErrorBadPointer",
			"Invalid pointer passed to function",
  SvErrorFile,		"SvErrorFile",
			"Not a JPEG file",
  SvErrorEOI,		"SvErrorEOI",
			"Empty JPEG file",
  SvErrorBadArgument,	"SvErrorBadArgument",
			"Invalid argument to function",
  SvErrorSmallBuffer,	"SvErrorSmallBuffer",
			"Buffer too small",
  SvErrorEndBitstream,	"SvErrorEndBitstream",
			"End of data bitstream reached",
  SvErrorCodecType,	"SvErrorCodecType",
			"Codec type not recognized",
  SvErrorCodecHandle,	"SvErrorCodecHandle",
			"Invalid Codec handle",
  SvErrorNullCodec,	"SvErrorNullCodec",
			"Codec argument may not be NULL",
  SvErrorNullToken,	"SvErrorNullToken",
			"Registration token  may not be NULL",
  SvErrorSyncLost,	"SvErrorSyncLost",
			"Syncronization lost in data bitstream",
  SvErrorLevels,	"SvErrorLevels",
			"levels - must be between 2 and 256",
  SvErrorOrder,		"SvErrorOrder",
			"order - must be between 0 and 6",
  SvErrorLevNoneg,	"SvErrorLevNoneg",
			"%s - Must be nonnegative",
  SvErrorLev1K,		"SvErrorLev1K",	
			"%s - Must be between -1000 and 1000",
  SvErrorLevGt0,	"SvErrorLevGt0",
			"%s - Must be greater than zero",
  SvErrorYuvOnly,	"SvErrorYuvOnly",
			"operation supported for YUV images only",
  SvErrorDevOpen,	"SvErrorDevOpen",
			"unable to open device %s",
  SvErrorDevMap,	"SvErrorDevMap",
			"unable to map device registers",
  SvErrorStatQueMap,	"SvErrorStatQueMap",
			"unable to map status queue",
  SvErrorDevLock,	"SvErrorDevLock",
			"unable to Lock %s bytes of memory",
  SvErrorDevUlock,	"SvErrorDevUlock",
			"unable to unLock memory %s",
  SvErrorCache,		"SvErrorCache",	
			"could not make the pages NONCACHEABLE",
  SvErrorPageAll,	"SvErrorPageAll",
			"memory has to be page alligned, need integral # of pages",
  SvErrorTimeOut,	"SvErrorTimeOut",
			"time out on following operation(s): %s",
  SvErrorSelect,	"SvErrorSelect",
			"select failure during following operation(s): %s",
  SvErrorMapOvrfl,	"SvErrorMapOvrfl",
			"DMA scatter/gather map overflow",
  SvErrorIIC,		"SvErrorIIC",
			"IIC Bus error",
  SvErrorCompPtrs,	"SvErrorCompPtrs",
			"storage for compression flushing and/or byte count missing",
  SvErrorVideoInput,	"SvErrorVideoInput",
			"no video input",
  SvErrorPhase,		"SvErrorPhase",
			"Invalid Phase",
  SvErrorCmdQueMap,	"SvErrorCmdQueMap",
			"CmdQueue Map",
  SvErrorTmpQueMap,	"SvErrorTmpQueMap",
			"TmpQueue Map",
  SvErrorStart,		"SvErrorStart",
			"couldn't start the application",
  SvErrorStop,		"SvErrorStop",
			"couldn't stop the application",
  SvErrorWaitMix,	"SvErrorWaitMix",
			"non-blocking operations still pending",
  SvErrorClose,		"SvErrorClose",
			"Error closing device",
  SvErrorCmdQFull,	"SvErrorCmdQFull",
			"JLib internal error -- CmdQueue full",
  SvErrorPictureOp,	"SvErrorPictureOp",
			"Picture operation failed",
  SvErrorRefToken,	"SvErrorRefToken",
			"Reference token required on edit",
  SvErrorEditChange,	"SvErrorEditChange",
			"No change specified for edit",
  SvErrorCompROI,	"SvErrorCompROI",
			"SvError compression ROI",
  SvErrorBufOverlap,	"SvErrorBufOverlap",
			"Buffer overlaps previously registered buffer",
  SvErrorReqQueueFull,	"SvErrorReqQueueFull",
			"JLib internal error -- RequestQueue is full",
  SvErrorCompBufOverflow,"SvErrorCompBufOverflow",
			"Compression buffer overflow",
  SvErrorFunctionInputs,"SvErrorFunctionInputs",
			"Illegal library function inputs",
  SvErrorIICAck,	"SvErrorIICAck",
			"Missing acknowledge on video IIC bus",
  SvErrorCompressedData,"SvErrorCompressedData",
			"Cannot find end of compressed data",
  SvErrorDecompPreload,	"SvErrorDecompPreload",
			"Compressed data preload failed",
  SvErrorHuffCode,	"SvErrorHuffCode",
			"huffman code in compressed data",
  SvErrorOutOfData,	"SvErrorOutOfData",
			"Compressed data exhausted",
  SvErrorMarkerFound,	"SvErrorMarkerFound",
			"marker found in compressed data",
  SvErrorSgMapsExhausted,"SvErrorSgMapsExhausted",
			"No more DMA Map pages available",
  SvErrorSgMapInit,	"SvErrorSgMapInit",
			"Failure initializing DMA Map Pool",
  SvErrorSgMapAlreadyFree,"SvErrorSgMapAlreadyFree",
			"Freeing a DMA Map that is already free",
  SvErrorSgMapId,	"SvErrorSgMapId",
			"Invalid DMA Map Id",
  SvErrorNumBytes,	"SvErrorNumBytes",
			"Location for number of compressed bytes is required",
  SvErrorDevName,	"SvErrorDevName",
			"%s is not a valid JV2 device",
  SvErrorDevName,	"SvErrorNullStruct",
			"Parameter set structure is required",
  SvErrorAnalogPortTiming,"SvErrorAnalogPortTiming",
			"Analog port settings differ from pending settings: Use blocking call",
  SvErrorFrameMode,	"SvErrorFrameMode",
			"Frame mode not supported with PAL or SECAM video",
  SvErrorSampFactors,	"SvErrorSampFactors",
			"Invalid sampling factor",
  SvErrorNumComponents,	"SvErrorNumComponents",
			"Too many components for interleaved scan",
  SvErrorDHTTable,	"SvErrorDHTTable",
			"Invalid Huffman table",
  SvErrorQuantTable,	"SvErrorQuantTable",
			"Invalid quantization table",
  SvErrorRestartInterval,"SvErrorRestartInterval",
			"Invalid restart interval",
  SvErrorJfifRev,	"SvErrorJfifRev",
			"Unsupported JFIF version",
  SvErrorEmptyJPEG,	"SvErrorEmptyJPEG",
			"Empty JPEG image (DNL not supported)",
  SvErrorJPEGPrecision,	"SvErrorJPEGPrecision",
			"Unsupported JPEG data precision",
  SvErrorSOFLength,	"SvErrorSOFLength",
			"Invalid SOF length",
  SvErrorSOSLength,	"SvErrorSOSLength",
			"Invalid SOS length",
  SvErrorSOSCompNum,	"SvErrorSOSCompNum",
			"Invalid SOS number of components",
  SvErrorMarker,	"SvErrorMarker",
			"Unexpected Marker",
  SvErrorSOFType,	"SvErrorSOFType",
			"Unsupported SOF marker type",
  SvErrorFrameNum,	"SvErrorFrameNum",
			"frame number",
  SvErrorHuffUndefined,	"SvErrorHuffUndefined",
			"Huffman tables not initialized",
  SvErrorJPEGData,	"SvErrorJPEGData",
			"Corrupt JPEG data",
  SvErrorQMismatch,	"SvErrorQMismatch",
			"Request/status queue mismatch",
  SvErrorEmptyFlush,	"SvErrorEmptyFlush",
			"Driver's temp (flush) queue is empty",
  SvErrorDmaChan,	"SvErrorDmaChan",
			"invalid DMA channel",
  SvErrorFuture,	"SvErrorFuture",
			"future",
  SvErrorWrongev,	"SvErrorWrongev",
			"wrong ev",
  SvErrorUnknev,	"SvErrorUnknev",
			"unknown ev",
  SvErrorQueueExecuting,"SvErrorQueueExecuting",
			"JLib internal error -- Can't download with running queue",
  SvErrorReturnAddr,	"SvErrorReturnAddr",
			"JLib internal error -- Missing return address",
  SvErrorObjClass,	"SvErrorObjClass",
			"JLib internal error -- SvError object class",
  SvErrorRegAnchor,	"SvErrorRegAnchor",
			"JLib internal error -- No registration object anchor",
  SvErrorTimerRead,	"SvErrorTimerRead",
			"reading timer",
  SvErrorDriverFatal,	"SvErrorDriverFatal",
			"Fatal driver error",
  SvErrorChromaSubsample,"SvErrorChromaSubsample",
			"Chroma subsample must be Mono, 4:2:2 or 4:2:0",
  SvErrorReadBufSize,	"SvErrorReadBufSize",
			"Compressed data buffer too small",
  SvErrorQuality,	"SvErrorQuality",
			"Invalid Quality value. Range = 0 to 10,000",
  SvErrorUnrecognizedFormat,"SvErrorUnrecognizedFormat",
			"Unrecognized image format",
  SvErrorIllegalMType,    "SvErrorIllegalMType",
                        "Illegal Macroblock type",
  SvErrorBadImageSize,	"SvErrorBadImageSize",
			"Invalid image size",
  SvErrorValue,		"SvErrorValue",
			"Invalid parameter value",
  SvErrorDcmpNotStarted,"SvErrorDcmpNotStarted",
			"Codec not setup. Call SvDecompressBegin",
  SvErrorNotImplemented,"SvErrorNotImplemented",
			"Not implemented yet",
  SvErrorNoSOIMarker,	"SvErrorNoSOIMarker",
			"Invalid JPEG data",
  SvErrorProcessingAborted,"SvErrorProcessingAborted",
			"Processing Aborted by callback",
  SvErrorCompNotStarted,"SvErrorCompNotStarted",
			"Codec not setup. Call SvCompressBegin",
  SvErrorNotAligned,	"SvErrorNotAligned",
			"Memory pointer not 64-bit aligned",
  SvErrorBadQueueEmpty,	"SvErrorBadQueueEmpty",
			"Buffer queue is empty",
  SvErrorCannotDecompress,"SvErrorCannotDecompress",
			"Picture cannot be decompressed",
  SvErrorMultiBufChanged,"SvErrorMultiBufChanged",
			"Multibuffer address has changed",
  SvErrorNotDecompressable,"SvErrorNotDecompressable",
			"Picture not decompressable",
  SvErrorIndexEmpty,	"SvErrorIndexEmpty",
			"Requested frame not in index",
  SvErrorExpectedEOB,   "SvErrorExpectedEOB",
			"Expected End Of Block",
  SvErrorNoCompressBuffer, "SvErrorNoCompressBuffer",
			"No more compressed buffers available",
  SvErrorNoImageBuffer, "SvErrorNoImageBuffer",
			"No more image buffers available",
  SvErrorCBPWrite, "SvErrorCBPWrite",
			"CBP Write Error",
  SvErrorEncodingMV, "SvErrorEncodingMV",
                        "Cannot encode Motion Vectors",
  SvErrorEmptyHuff, "SvErrorEmptyHuff",
                        "Attempting to write an empty huffman code",
  SvErrorIllegalGBSC, "SvErrorIllegalGBSC",
                        "Illegal GOB Start Code",
  SvErrorEndOfSequence, "SvEndOfSequence",
                        "End Of Sequence",
/******************** Sa (Audio) ****************************/
  SaErrorNullCodec,	"SaErrorNullCodec",
			"Codec argument may not be NULL",
  SaErrorSyncLost,	"SaErrorSyncLost",
			"Syncronization lost in data bitstream",
  SaErrorMPEGLayer,     "SaErrorMPEGLayer",
			"Bad MPEG Layer %s",
  SaErrorMPEGModeExt,   "SaErrorMPEGModeExt",
			"Bad MPEG Mode Extension %s",
  SaErrorNoCompressBuffer, "SaErrorNoCompressBuffer",
			"No more compressed buffers available",
  SaErrorNoAudioBuffer, "SaErrorNoAudioBuffer",
			"No more audio buffers available",
/******************** Sr (Render) ****************************/
  SrErrorRenderType,	"SrErrorRenderType",
			"Render type not recognized",
  SrErrorRenderHandle,	"SrErrorRenderHandle",
			"Invalid Render handle",
  SrErrorRenderNotStarted,"SrErrorRenderNotStarted",
			"Renderer not setup. Call SvRenderBegin",
  SrErrorDitherNOL,	"SrErrorDitherNOL",
			"Invalid NOL value - must be between 2 & 256",
  SrErrorDitherPhase,	"SrErrorDitherPhase",
			"Invalid PhaseX/Y value - must be >= 0",
  SrErrorDefSteepness,	"SrErrorDefSteepness",
			"Invalid Default Steepness -1000.0 to +1000.0",
  SrErrorSteepness,	"SrErrorSteepness",
			"Invalid Steepness -1000.0 to +1000.0",
  SrErrorDefYoffset,	"SrErrorDefYoffset",
			"Invalid Default Yoffset -100.0 to +100.0",
  SrErrorYoffset,	"SrErrorYoffset",
			"Invalid Yoffset -100.0 to +100.0",
  SrErrorDefXoffset,	"SrErrorDefXoffset",
			"Invalid Default Xoffset -100.0 to +100.0",
  SrErrorXoffset,	"SrErrorXoffset",
			"Invalid Xoffset -100.0 to +100.0",
  SrErrorNumColors,	"SrErrorNumColors",
			"Not enough colors available for dithering",
  SrErrorBadNumColors,	"SrErrorBadNumColors",
			"Invalid Number of colors. Range = 2 to 256",
  SrErrorColorSpace,	"SrErrorColorSpace",
			"unsupported color space",
  SrErrorBadImageSize,	"SrErrorBadImageSize",
			"Invalid image size",
  SrErrorValue,		"SrErrorValue",
			"Invalid parameter value",
  0,			NULL, NULL
};


ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars)
{
  int status;
  char msg[255], *pmsg;
  ErrorDesc_t *perr=ErrorDesc;

  msg[0]=0;
  pmsg=msg;
  while (perr->name!=NULL && perr->code!=errno)
    perr++;
  if (perr->name!=NULL) /* matching message found */
  {
    if (perr->name[0])
    {
      sprintf(msg,"(%s) ",perr->name);
      pmsg+=strlen(pmsg);
    }
    if (perr->text[0])
    {
      sprintf (pmsg, perr->text, _serr_msg);
      pmsg+=strlen(pmsg);
    }
    if (*msg) /* put newline if there was a message */
    {
      *pmsg++='\n';
      *pmsg=0;
    }
    status=NoErrors;
  }
  else
  {
    sprintf (msg, "No text exists for error number %d\n", errno);
    status=ScErrorForeign;
  }
  if (*msg)
  {
    if (ReturnMsg == NULL)
    {
      switch(errno&0xF000)
      {
        case ERR_SC:
	  fprintf (stderr,"SLIB Error -- %s", msg);
          break;
#ifdef ERR_SV
        case ERR_SV:
	  fprintf (stderr,"SLIB Video Error -- %s", msg);
          break;
#endif
#ifdef ERR_SA
        case ERR_SA:
	  fprintf (stderr,"SLIB Audio Error -- %s", msg);
          break;
#endif
#ifdef ERR_SR
        case ERR_SR:
	  fprintf (stderr,"SLIB Render Error -- %s", msg);
          break;
#endif
        default:
	  fprintf (stderr,"Error -- %s", msg);
      }
    }
    else
    {
      strncpy (ReturnMsg, msg, MaxChars);
      ReturnMsg[MaxChars-1] = 0; /* Make sure string is NULL terminated */
    }
  }

  return (status);
}


char *ScGetErrorStr(int errno)
{
  static char errstr[255];
  errstr[0]=0;
  ScGetErrorText(errno, errstr, sizeof(errstr)-1);
  return(errstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\slib.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib.h,v $
 * Revision 1.1.6.22  1996/12/13  18:19:02  Hans_Graves
 * 	Added SlibErrorNoBeginning enum
 * 	[1996/12/13  17:42:20  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/12/10  19:21:51  Hans_Graves
 * 	Added Avg/VarVideoTimeDiff and SlibFrameToTime100() macro
 * 	[1996/12/10  19:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/05  20:10:13  Hans_Graves
 * 	Added AvgVideoTimeDiff and AvgAudioTimeDiff to SlibInfo_t
 * 	[1996/12/05  20:07:53  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/12/03  00:08:29  Hans_Graves
 * 	Added unit SLIB_UNIT_PERCENT100 and Seek type SLIB_SEEK_RESYNC.
 * 	[1996/12/03  00:02:47  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/20  02:15:07  Hans_Graves
 * 	Added SEEK_AHEAD.
 * 	[1996/11/20  01:49:55  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/18  23:07:14  Hans_Graves
 * 	Change operations to the time-based instead of frame-based.
 * 	[1996/11/18  22:56:34  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:02  Hans_Graves
 * 	Added proto for slibRenamePin().
 * 	[1996/11/11  17:58:03  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:50:59  Hans_Graves
 * 	Added AC3 stuff. Better seperation of stream types.
 * 	[1996/11/08  21:18:22  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/31  00:08:53  Hans_Graves
 * 	Added SLIB_TIME_UNKNOWN
 * 	[1996/10/31  00:07:57  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/28  17:32:23  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:19:38  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/17  00:23:30  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:17:53  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/12  17:18:19  Hans_Graves
 * 	Added params HALFPEL and SKIPPEL. Seperated MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  16:57:14  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/10/03  19:14:19  Hans_Graves
 * 	Added PTimeCode and DTimeCode to Info struct.
 * 	[1996/10/03  19:08:35  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/29  22:19:35  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:28:25  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/25  19:16:41  Hans_Graves
 * 	Reduce number of includes needed publicly by adding SLIB_INTERNAL ifdef.
 * 	[1996/09/25  19:02:38  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/23  18:04:01  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  18:03:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/09/18  23:46:20  Hans_Graves
 * 	Clean up. Added SlibAddBufferEx() and SlibReadData() protos.
 * 	[1996/09/18  21:59:36  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/08/09  20:51:19  Hans_Graves
 * 	Fix proto for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:06:26  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:05  Hans_Graves
 * 	New params. Added SlibRegisterVideoBuffer.
 * 	[1996/07/19  01:26:07  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/10  21:16:53  Hans_Graves
 * 	Changes for Callback support.
 * 	[1996/05/10  20:59:56  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/07  19:56:00  Hans_Graves
 * 	Added Callback framework.
 * 	[1996/05/07  17:23:12  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/24  22:33:42  Hans_Graves
 * 	Added proto for slibValidateBitrates()
 * 	[1996/04/24  22:27:46  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/23  21:01:41  Hans_Graves
 * 	Added SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:36  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/22  15:04:50  Hans_Graves
 * 	Added protos for: slibValidateVideoParams, slibValidateAudioParams, SlibValidateParams
 * 	[1996/04/22  15:03:17  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/19  21:52:20  Hans_Graves
 * 	Additions to SlibInfo: TotalBitRate, MuxBitRate, SystemTimeStamp, PacketCount
 * 	[1996/04/19  21:49:13  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/15  14:18:35  Hans_Graves
 * 	Added temp audio buffer info
 * 	[1996/04/15  14:09:23  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/10  21:47:36  Hans_Graves
 * 	Moved definition for EXTERN to SC.h
 * 	[1996/04/10  21:24:09  Hans_Graves]
 * 
 * 	Added QUALITY and FAST params
 * 	[1996/04/10  20:41:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/09  16:04:39  Hans_Graves
 * 	Added EXTERN define for cplusplus compatibility
 * 	[1996/04/09  14:49:16  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/01  19:07:50  Hans_Graves
 * 	Change slibVerifyVideoParams() proto
 * 	[1996/04/01  19:05:31  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  16:23:11  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:51  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/03/29  22:21:13  Hans_Graves
 * 	Added HeaderProcessed to SlibInfo
 * 	[1996/03/27  21:52:31  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:42  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE parameter
 * 	[1996/03/12  16:11:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:31  Hans_Graves
 * 	Added Imagebuf to SlibInfo_t
 * 	[1996/03/08  16:23:53  Hans_Graves]
 * 
 * Revision 1.1.2.13  1996/02/19  18:03:53  Hans_Graves
 * 	Added more SEEK types.
 * 	[1996/02/19  17:59:12  Hans_Graves]
 * 
 * Revision 1.1.2.12  1996/02/13  18:47:45  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:41:51  Hans_Graves]
 * 
 * Revision 1.1.2.11  1996/02/07  23:23:51  Hans_Graves
 * 	Added slibCountCodesOnPin() prototype
 * 	[1996/02/07  23:19:11  Hans_Graves]
 * 
 * Revision 1.1.2.10  1996/02/06  22:53:55  Hans_Graves
 * 	Prototype updates
 * 	[1996/02/06  22:44:06  Hans_Graves]
 * 
 * Revision 1.1.2.9  1996/02/02  17:36:01  Hans_Graves
 * 	Updated prototypes
 * 	[1996/02/02  17:28:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1996/01/30  22:23:06  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:22:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1996/01/15  16:26:26  Hans_Graves
 * 	Added: TYPE_WAVE, more PARAMs, SlibWriteAudio()
 * 	[1996/01/15  15:44:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/01/11  16:17:26  Hans_Graves
 * 	Added SlibGet/SetParam() prototypes
 * 	[1996/01/11  16:13:44  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/08  16:41:25  Hans_Graves
 * 	Cleaned up prototypes
 * 	[1996/01/08  15:48:38  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/12/07  19:31:27  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:28:11  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/11/09  23:14:03  Hans_Graves
 * 	Added Time structure members and prototypes
 * 	[1995/11/09  23:10:32  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/11/06  18:47:45  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:32  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SLIB_H_
#define _SLIB_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"
#ifdef SLIB_INTERNAL
#include "SV.h"
#include "SA.h"
#include "scon.h"
#endif /* SLIB_INTERNAL */

typedef void       *SlibHandle_t;
typedef ScBoolean_t SlibBoolean_t;
typedef int         SlibStream_t;
typedef qword       SlibTime_t;
typedef qword       SlibPosition_t;

#define SLIB_TIME_NONE     (SlibTime_t)(-1)
#define SLIB_TIME_UNKNOWN  (SlibTime_t)(-2)

/* units used in seeking */
typedef enum {
  SLIB_UNIT_NONE,
  SLIB_UNIT_FRAMES,     /* frames */
  SLIB_UNIT_MS,         /* milliseconds */
  SLIB_UNIT_PERCENT100, /* one hundredth of percent */
} SlibUnit_t;

#define SlibTimeIsValid(stime)  ((stime)>=0)
#define SlibTimeIsInValid(stime)  ((stime)<0)
#define SlibTimeToFrame(Sh,vs,stime) \
      ((qword)((stime)*SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS))/1000)
#define SlibFrameToTime(Sh,vs,frame) \
  ((SlibTime_t)((float)(frame*1000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))
#define SlibFrameToTime100(Sh,vs,frame) \
 ((SlibTime_t)((float)(frame*100000)/SlibGetParamFloat(Sh, vs, SLIB_PARAM_FPS)))

typedef qword SlibListParam1_t;
typedef qword SlibListParam2_t;

typedef struct SlibList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SlibListParam1_t param1;
  SlibListParam2_t param2;
} SlibList_t;

typedef enum {
  SlibErrorNone = 0,
  SlibErrorInternal,
  SlibErrorMemory,
  SlibErrorBadArgument,
  SlibErrorBadHandle,
  SlibErrorBadStream,
  SlibErrorBadMode,
  SlibErrorUnsupportedFormat,
  SlibErrorReading,
  SlibErrorWriting,
  SlibErrorBufSize,
  SlibErrorEndOfStream,
  SlibErrorForwardOnly,
  SlibErrorUnsupportedParam,
  SlibErrorImageSize,        /* Invalid image height and/or width */
  SlibErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SlibErrorInit,             /* initialization error */
  SlibErrorFileSize,         /* file size unknown */
  SlibErrorBadPosition,      /* position argument to seek is invalid */
  SlibErrorBadUnit,          /* units are invalid */
  SlibErrorNoBeginning,      /* couldn't begin the codecs */
  SlibErrorNoData,           /* no data available */
} SlibStatus_t;

typedef enum {
  SLIB_MODE_NONE,
  SLIB_MODE_COMPRESS,
  SLIB_MODE_COMPRESS_APPEND,
  SLIB_MODE_DECOMPRESS,
} SlibMode_t;

typedef enum {
  SLIB_TYPE_UNKNOWN=0,
  /* MPEG elementary stream types */
  SLIB_TYPE_MPEG1_VIDEO=0x01,
  SLIB_TYPE_MPEG1_AUDIO=0x02,
  SLIB_TYPE_MPEG2_VIDEO=0x04,
  SLIB_TYPE_MPEG2_AUDIO=0x08,
  SLIB_TYPE_AC3_AUDIO=0x10,
  /* MPEG multiplex types */
  SLIB_TYPE_MPEG_SYSTEMS=0x100,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2=0x104, /* MPEG Systems with MPEG2 data */
  SLIB_TYPE_MPEG_TRANSPORT=0x200,
  SLIB_TYPE_MPEG_PROGRAM=0x400,
  /* H26? stream types */
  SLIB_TYPE_H261=0x800,
  SLIB_TYPE_RTP_H261=0x808,
  SLIB_TYPE_H263=0x810,
  SLIB_TYPE_RTP_H263=0x818,
  /* RIFF stream types */
  SLIB_TYPE_RIFF=0x1000,
  SLIB_TYPE_PCM_WAVE,
  SLIB_TYPE_AVI,
  SLIB_TYPE_MJPG_AVI,
  SLIB_TYPE_JPEG_AVI,
  SLIB_TYPE_YUV_AVI,
  /* Other stream types */
  SLIB_TYPE_JPEG_QUICKTIME=0x2000,
  SLIB_TYPE_JFIF,
  SLIB_TYPE_MJPG,
  SLIB_TYPE_JPEG,
  SLIB_TYPE_YUV,
  SLIB_TYPE_RGB,
  SLIB_TYPE_PCM,
  /* G72? stream types */
  SLIB_TYPE_G723=0x4000,
  /* Miscellaneous types */
  SLIB_TYPE_RASTER=0x8000,
  SLIB_TYPE_BMP,
  /* Test stream types */
  SLIB_TYPE_SLIB=0xC000,
  SLIB_TYPE_SHUFF
} SlibType_t;

#ifdef OLD_SLIB
#define SLIB_TYPE_MPEG1_SYSTEMS   SLIB_TYPE_MPEG_SYSTEMS
#define SLIB_TYPE_MPEG2_SYSTEMS   SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_TRANSPORT SLIB_TYPE_MPEG_TRANSPORT
#define SLIB_TYPE_MPEG2_PROGRAM   SLIB_TYPE_MPEG_PROGRAM
#endif /* OLD_SLIB */

#define SlibTypeIsMPEG(stype) (stype>=SLIB_TYPE_MPEG1_VIDEO && \
                               stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEGVideo(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x705))
#define SlibTypeIsMPEGAudio(stype) (stype<=SLIB_TYPE_MPEG_PROGRAM && \
                                    (stype&0x70A))
#define SlibTypeIsMPEGMux(stype) (stype>=SLIB_TYPE_MPEG_SYSTEMS && \
                                  stype<=SLIB_TYPE_MPEG_PROGRAM)
#define SlibTypeIsMPEG2(stype) (stype==SLIB_TYPE_MPEG2_VIDEO || \
                                stype==SLIB_TYPE_MPEG_PROGRAM || \
                                stype==SLIB_TYPE_MPEG_TRANSPORT || \
                                stype==SLIB_TYPE_MPEG2_AUDIO)
#define SlibTypeIsMPEG1(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                stype==SLIB_TYPE_MPEG1_AUDIO || \
                                stype==SLIB_TYPE_MPEG_SYSTEMS)
#define SlibTypeIsH26X(stype)  ((stype&0xFF00)==0x0800)
#define SlibTypeIsAVI(stype)   (stype>=SLIB_TYPE_AVI && \
                                stype<=SLIB_TYPE_YUV_AVI)
#define SlibTypeIsAudioOnly(stype) (stype==SLIB_TYPE_MPEG1_AUDIO || \
                                    stype==SLIB_TYPE_AC3_AUDIO || \
                                    stype==SLIB_TYPE_G723 || \
                                    stype==SLIB_TYPE_PCM || \
                                    stype==SLIB_TYPE_PCM_WAVE)
#define SlibTypeIsVideoOnly(stype) (stype==SLIB_TYPE_MPEG1_VIDEO || \
                                    stype==SLIB_TYPE_MPEG2_VIDEO || \
                                    SlibTypeIsH26X(stype) || \
                                    stype==SLIB_TYPE_YUV || \
                                    stype==SLIB_TYPE_RGB || \
                                    stype==SLIB_TYPE_BMP || \
                                    stype==SLIB_TYPE_RASTER)
#define SlibTypeIsMux(stype)     (SlibTypeIsMPEGMux(stype) || \
                                  SlibTypeIsAVI(stype))
#define SlibTypeHasTimeStamps(stype) (SlibTypeIsMPEGMux(stype))

typedef enum {
  SLIB_DATA_COMPRESSED=0,
  SLIB_DATA_AUDIO,
  SLIB_DATA_VIDEO,
  SLIB_DATA_PRIVATE
} SlibDataType_t;

typedef enum {
  SLIB_MSG_CONTINUE=0,
  SLIB_MSG_OPEN=0x01,
  SLIB_MSG_ENDOFDATA=0x10,
  SLIB_MSG_ENDOFSTREAM,
  SLIB_MSG_BUFDONE,
  SLIB_MSG_REPOSITION=0x20,
  SLIB_MSG_BADPOSITION,
  SLIB_MSG_CLOSE=0x80
} SlibMessage_t;

typedef qword SlibCBParam1_t;
typedef qword SlibCBParam2_t;

typedef enum {
  SLIB_QUERY_QUERIES,
  SLIB_QUERY_TYPES,
  SLIB_QUERY_COMP_TYPES,
  SLIB_QUERY_DECOMP_TYPES,
  SLIB_QUERY_MODES,
  SLIB_QUERY_PARAMETERS,
  SLIB_QUERY_ERRORS
} SlibQueryType_t;

typedef enum {
  /* these use position */
  SLIB_SEEK_EXACT=0x00,    /* jump to the exact frame */
  SLIB_SEEK_KEY,           /* jump to the closest key (I) frame */
  SLIB_SEEK_AHEAD,         /* jump ahead by a certain amount */
  SLIB_SEEK_NEXT_NEAR=0x08, /* advance to a frame near the requested frame */
  SLIB_SEEK_NEXT_EXACT,    /* advance to the exact requested frame */
  /* these don't use position */
  SLIB_SEEK_NEXT_KEY=0x10, /* advance to the next key (I) frame */
  SLIB_SEEK_NEXT_SUBKEY,   /* advance to the next key (I) or subkey (P) frame */
  SLIB_SEEK_NEXT,          /* advance one frame */
  SLIB_SEEK_RESET=0x100,   /* reset the streams */
  SLIB_SEEK_RESYNC         /* sync up all the streams */
} SlibSeekType_t;

#define SlibSeekTypeUsesPosition(seektype) (seektype<SLIB_SEEK_NEXT_KEY)

typedef struct SlibSeekInfo_s {
  SlibTime_t        VideoTimeStamp;
  SlibTime_t        AudioTimeStamp;
  qword             FramesSkipped;
} SlibSeekInfo_t;

typedef enum {
  /* SLIB Parameters */
  SLIB_PARAM_VERSION=0x00,  /* SLIB version number */
  SLIB_PARAM_VERSION_DATE,  /* SLIB build date */
  SLIB_PARAM_NEEDACCURACY,  /* need accurate frame counts and audio lengths */
  SLIB_PARAM_DEBUG,         /* debug handle */
  SLIB_PARAM_TYPE,          /* stream type */
  SLIB_PARAM_OVERFLOWSIZE,  /* pin overflowing size */
  SLIB_PARAM_KEY,           /* SLIB security key */
  /* Video Parameters */
  SLIB_PARAM_FPS=0x100,
  SLIB_PARAM_WIDTH,
  SLIB_PARAM_HEIGHT,
  SLIB_PARAM_IMAGESIZE,
  SLIB_PARAM_VIDEOBITRATE,
  SLIB_PARAM_VIDEOFORMAT,
  SLIB_PARAM_VIDEOBITS,
  SLIB_PARAM_VIDEOSTREAMS,
  SLIB_PARAM_VIDEOLENGTH,       /* total video length in miliiseconds */
  SLIB_PARAM_VIDEOFRAMES,       /* total video frames */
  SLIB_PARAM_VIDEOQUALITY,      /* video quality */
  SLIB_PARAM_VIDEOASPECTRATIO,  /* video aspect ratio: height/width */
  SLIB_PARAM_NATIVEVIDEOFORMAT, /* native/compressed format */
  SLIB_PARAM_NATIVEWIDTH,       /* native/compressed width */
  SLIB_PARAM_NATIVEHEIGHT,      /* native/compress height */
  SLIB_PARAM_VIDEOPROGRAM,      /* Video Program ID (Transport) */
  SLIB_PARAM_STRIDE,            /* bytes between scan lines */
  SLIB_PARAM_VIDEOFRAME,        /* video frame */
  SLIB_PARAM_FRAMEDURATION,     /* video frame duration in 100-nanosec units */
  SLIB_PARAM_VIDEOMAINSTREAM,   /* Main Video Stream (Systems+Program) */
  SLIB_PARAM_FRAMETYPE,         /* frame type - I, P, B or D */
  /* Audio Parameters */
  SLIB_PARAM_AUDIOFORMAT=0x200,
  SLIB_PARAM_AUDIOBITRATE,
  SLIB_PARAM_AUDIOSTREAMS,
  SLIB_PARAM_AUDIOCHANNELS,
  SLIB_PARAM_AUDIOLENGTH,     /* milliseconds of audio */
  SLIB_PARAM_AUDIOQUALITY,    /* audio quality */
  SLIB_PARAM_SAMPLESPERSEC,
  SLIB_PARAM_BITSPERSAMPLE,
  SLIB_PARAM_NATIVESAMPLESPERSEC,
  SLIB_PARAM_NATIVEBITSPERSAMPLE,
  SLIB_PARAM_AUDIOPROGRAM,    /* Audio Program ID (Transport) */
  SLIB_PARAM_AUDIOMAINSTREAM, /* Main Audio Stream (Systems+Program) */
  /* Common Codec Parameters */
  SLIB_PARAM_FASTENCODE=0x400,/* fast encoding desired */
  SLIB_PARAM_FASTDECODE,      /* fast decoding desired */
  SLIB_PARAM_KEYSPACING,      /* I frames */
  SLIB_PARAM_SUBKEYSPACING,   /* P frames */
  SLIB_PARAM_MOTIONALG=0x420, /* Motion estimation algorithm */
  SLIB_PARAM_MOTIONSEARCH,    /* Motion search limit */
  SLIB_PARAM_MOTIONTHRESH,    /* Motion threshold */
  SLIB_PARAM_ALGFLAGS,        /* Algorithm flags */
  SLIB_PARAM_FORMATEXT,       /* Format Extensions */
  SLIB_PARAM_QUANTI=0x480,    /* Intra-frame Quantization Step */
  SLIB_PARAM_QUANTP,          /* Inter-frame Quantization Step */
  SLIB_PARAM_QUANTB,          /* Bi-directional frame Quantization Step */
  SLIB_PARAM_QUANTD,          /* D (preview) frame Quantization Step */
  /* File/Stream Parameters */
  SLIB_PARAM_BITRATE=0x800,   /* overall bitrate */
  SLIB_PARAM_TIMECODE,        /* actual timecode */
  SLIB_PARAM_CALCTIMECODE,    /* calculated timecode - 0 based */
  SLIB_PARAM_FILESIZE,
  SLIB_PARAM_FILEBUFSIZE,     /* file read/write buffer size */
  SLIB_PARAM_PTIMECODE,       /* presentation timestamp */
  SLIB_PARAM_DTIMECODE,       /* decoding timestamp */
  SLIB_PARAM_PERCENT100,      /* position in 100th of percent units */
  /* Buffering/delay Parameters */
  SLIB_PARAM_VBVBUFFERSIZE=0x1000, /* Video Buffer Verifier buf size in bytes */
  SLIB_PARAM_VBVDELAY,        /* Video Buffer Verifier delay */
  SLIB_PARAM_PACKETSIZE,      /* Packet size (RTP) */
  SLIB_PARAM_MININPUTSIZE,    /* Minimum input sample size */
  SLIB_PARAM_INPUTSIZE,       /* Suggested input sample size */
  SLIB_PARAM_COMPBUFSIZE,     /* Slib Internal compressed buffer size */
  /* Stats Parameters */
  SLIB_PARAM_STATS=0x1800,    /* Turn stats recording on/off */
  SLIB_PARAM_STATS_RESET,     /* Reset stats */
  SLIB_PARAM_STATS_TIME,      /* Ellapsed time */
  SLIB_PARAM_STATS_FRAMES,    /* Frames encoded/decoded/skipped */
  SLIB_PARAM_STATS_FRAMESPROCESSED, /* Frames encoded/decoded */
  SLIB_PARAM_STATS_FRAMESSKIPPED,   /* Frames skipped */
  SLIB_PARAM_STATS_FPS,             /* Frames per second */
  /* Miscellaneous Parameters */
  SLIB_PARAM_CB_IMAGE=0x1C00, /* Turn image callbacks on/off */
  SLIB_PARAM_CB_TIMESTAMP,    /* Turn timestamp callbacks on/off */
} SlibParameter_t;

typedef enum {
  SLIB_CODEC_STATE_NONE,   /* codec is unopened */
  SLIB_CODEC_STATE_OPEN,   /* codec is opened */
  SLIB_CODEC_STATE_INITED, /* codec is opened and inited */
  SLIB_CODEC_STATE_BEGUN,  /* codec is opened, inited and begun */
  SLIB_CODEC_STATE_REPOSITIONING,  /* codec is opened, inited and begun,
                                      but stream is being repositioned */
} SlibCodecState_t;
/*
** Stream selections
*/
#define SLIB_STREAM_ALL       -1
#define SLIB_STREAM_MAINVIDEO  0
#define SLIB_STREAM_MAINAUDIO  1

typedef struct SlibQueryInfo_s {
  SlibType_t    Type;
  dword         HeaderStart;
  dword         HeaderSize;
  dword         Bitrate; /* overall bitrate */
  /* Video info */
  int           VideoStreams;
  short         Width;
  short         Height;
  dword         VideoBitrate;
  float         FramesPerSec;
  qword         VideoLength;
  /* Audio info */
  int           AudioStreams;
  unsigned int  SamplesPerSec;
  int           BitsPerSample;
  int           Channels;
  dword         AudioBitrate;
  qword         AudioLength;
} SlibQueryInfo_t;

#ifdef SLIB_INTERNAL
typedef struct SlibBuffer_s {
  qword          offset;
  unsigned dword size;
  unsigned char *address;
  SlibTime_t     time;
  struct SlibBuffer_s *next;
} SlibBuffer_t;

typedef struct SlibPin_s {
  int           ID;
  char          name[15];
  qword         Offset;
  SlibBuffer_t *Buffers;
  SlibBuffer_t *BuffersTail;
  dword         BufferCount;
  qword         DataSize;   /* total amount of data on pin */
  struct SlibPin_s *next;
} SlibPin_t;

typedef struct SlibStats_s {
  SlibBoolean_t Record;         /* stats recording on/off */
  SlibTime_t    StartTime;
  SlibTime_t    StopTime;
  qword         FramesProcessed;
  qword         FramesSkipped;
} SlibStats_t;

typedef struct SlibInfo_s {
  SlibType_t        Type;
  SlibMode_t        Mode;
  /* Handles */
  SvHandle_t        Svh; /* video */
  SaHandle_t        Sah; /* audio */
  SconHandle_t      Sch; /* conversion */
  SlibBoolean_t     NeedAccuracy;
  dword             TotalBitRate;/* overall bitrate: video+audio+mux */
  dword             MuxBitRate;  /* bitrate required by multiplexing codes */
  SlibTime_t        SystemTimeStamp; /* timestamp for next data on pins */
  int               VideoPID;    /* MPEG II Video Program ID */
  int               VideoMainStream; /* Main Stream used for video */
  SlibType_t        VideoType;   /* Video Stream type */
  /* Audio parameters */
  int               AudioStreams;
  unsigned int      SamplesPerSec;
  int               BitsPerSample;
  int               Channels;
  dword             AudioBitRate;
  int               AudioPID;    /* MPEG II Audio Program ID */
  int               AudioMainStream; /* Main Stream used for audio */
  SlibType_t        AudioType;   /* Audio Stream type */
  /* Video parameters */
  int               VideoStreams;
  word              Width;
  word              Height;
  dword             Stride;
  dword             VideoBitRate;
  float             FramesPerSec;
  /* Data Exchange */
  SlibPin_t        *Pins;
  int               PinCount;
  dword             Offset;
  SlibBoolean_t     IOError;       /* file read/write error - EOF */
  unsigned dword    MaxBytesInput; /* used with slibSetMaxInput */
  unsigned qword    InputMarker;   /* used with slibSetMaxInput */
  /* stream dependent stuff */
  SlibTime_t        VideoLength;
  SlibBoolean_t     VideoLengthKnown;
  SlibTime_t        VideoTimeStamp;     /* current video time */
  SlibTime_t        VideoFrameDuration; /* time between frames in 100th ms */
  qword             VideoFramesProcessed;/* frames processed since key points */
  SlibTime_t        AudioLength;
  SlibBoolean_t     AudioLengthKnown;
  SlibTime_t        AudioTimeStamp;     /* current audio time */
  SlibTime_t        LastAudioTimeStamp; /* used when compressing */
  int               KeySpacing;
  int               SubKeySpacing;
  SlibTime_t        AudioPTimeBase;     /* statring presentation timecode */
  SlibTime_t        AudioPTimeCode;     /* presentation timecode */
  SlibTime_t        AudioDTimeCode;     /* decoding timecode */
  SlibTime_t        LastAudioPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        VideoPTimeBase;     /* starting presentation timecode */
  SlibTime_t        VideoPTimeCode;     /* presentation timecode */
  SlibTime_t        VideoDTimeCode;     /* decoding timecode */
  SlibTime_t        LastVideoPTimeCode; /* last encoded decoding timecode */
  SlibTime_t        LastVideoDTimeCode; /* last encoded decoding timecode */
  SlibTime_t        AvgVideoTimeDiff;   /* video times differences */
  SlibTime_t        VarVideoTimeDiff;   /* video times differences variation */
  unsigned qword    BytesProcessed;     /* bytes input or output */
  /* Encoding info */
  SlibBoolean_t     HeaderProcessed;
  int               PacketCount;
  unsigned qword    BytesSincePack;
  /* Miscellaneous */
  SlibMessage_t (*SlibCB)(SlibHandle_t,   /* Callback to supply Bufs */
             SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *);
  void             *SlibCBUserData;
  int               Fd;            /* file descriptor */
  unsigned qword    FileSize;      /* total file length in bytes */
  unsigned dword    FileBufSize;   /* file read/write buffer size */
  unsigned dword    CompBufSize;   /* compressed buffer size */    
  unsigned dword    PacketSize;    /* RTP */    
  BITMAPINFOHEADER *VideoFormat;
  WAVEFORMATEX     *AudioFormat;
  BITMAPINFOHEADER *CodecVideoFormat;
  BITMAPINFOHEADER *CompVideoFormat;
  WAVEFORMATEX     *CompAudioFormat;
  SlibBoolean_t     VideoCodecState;
  SlibBoolean_t     AudioCodecState;
  unsigned char    *Multibuf;      /* multiple image buffer - MPEG, H261 */
  dword             MultibufSize;
  unsigned char    *Imagebuf;      /* temp image buffer - for conversions */
  dword             ImageSize;
  unsigned char    *CodecImagebuf; /* temp image buffer - for scaling */
  dword             CodecImageSize;
  unsigned char    *IntImagebuf;   /* intermediate image buffer - for scaling */
  dword             IntImageSize;
  unsigned char    *Audiobuf;      /* temp audio buffer - for conversions */
  unsigned dword    AudiobufSize;  /* temp audio buffer - for conversions */
  unsigned dword    AudiobufUsed;  /* byte used in audio buffer */
  unsigned dword    OverflowSize;  /* max number of bytes on a stream */
  unsigned dword    VBVbufSize;    /* video buffer verifier size */
  SlibStats_t      *stats;
  void             *dbg;           /* debug handle */
} SlibInfo_t;

#define slibTimeToFrame(Info,stime) ((qword)((stime)*Info->FramesPerSec)/1000)
#define slibFrameToTime(Info,frame) \
             ((SlibTime_t)((float)(frame*1000)/Info->FramesPerSec))
#define slibFrameToTime100(Info,frame) \
             ((SlibTime_t)((float)(frame*100000)/Info->FramesPerSec))
#define slibHasAudio(Info) (Info->AudioStreams>0 || Info->Sah)
#define slibHasVideo(Info) (Info->VideoStreams>0 || Info->Svh)
#define slibHasTimeCode(Info) (slibHasVideo(Info) && SlibTypeIsMPEG(Info->Type))
#define slibInSyncMode(Info) (Info->Fd<0 && Info->SlibCB==NULL)
#endif /* SLIB_INTERNAL */

/********************** Public Prototypes ***********************/
/*
 * slib_api.c
 */
EXTERN SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                   SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                    void *cbuserdata);
EXTERN SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode, 
                          SlibType_t *stype, void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                                 SlibType_t *stype, char *filename);
EXTERN SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                    void *buffer, unsigned dword bufsize,
                                    void *userdata);
EXTERN SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize);
EXTERN SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword *audiobufsize);
EXTERN SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize);
EXTERN SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                      void *videobuf, unsigned dword videobufsize);
EXTERN SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize);
EXTERN SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream);
EXTERN SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                                  SlibQueryInfo_t *qinfo);

EXTERN SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame);
EXTERN SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t position,
                      SlibUnit_t units, SlibSeekInfo_t *seekinfo);
EXTERN SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibStatus_t SlibClose(SlibHandle_t handle);

EXTERN char *SlibGetErrorText(SlibStatus_t status);
EXTERN SlibList_t *SlibQueryList(SlibQueryType_t qtype);
EXTERN char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval);
EXTERN int   SlibQueryForEnum(SlibQueryType_t qtype, char *name);
EXTERN SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval);
/*
 * slib_param.c
 */
EXTERN qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream);
EXTERN SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream);

EXTERN SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                                     SlibParameter_t param);
EXTERN SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, long value);
EXTERN SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, qword value);
EXTERN SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, float value);
EXTERN SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, 
                                 SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value);
EXTERN SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param,
                                 void *data, unsigned dword datasize);

EXTERN long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param);
EXTERN SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle,
                                 SlibStream_t stream, SlibParameter_t param);
EXTERN char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param);
EXTERN SlibStatus_t SlibValidateParams(SlibHandle_t handle);

/*
 * slib_buffer.c
 */
EXTERN void *SlibAllocBuffer(unsigned int bytes);
EXTERN void *SlibAllocBufferEx(SlibHandle_t handle, unsigned int bytes);
EXTERN void *SlibAllocSharedBuffer(unsigned int bytes, int *shmid);
EXTERN dword SlibGetSharedBufferID(void *address);
EXTERN SlibStatus_t SlibAllocSubBuffer(void *address,
                                        unsigned int bytes);
EXTERN SlibStatus_t SlibFreeBuffer(void *address);
EXTERN SlibStatus_t SlibFreeBuffers(SlibHandle_t handle);
EXTERN unsigned qword SlibMemUsed();

#ifdef SLIB_INTERNAL
/********************** Private Prototypes ***********************/
/*
 * slib_api.c
 */
SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf);
SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly);
void slibAdvancePositions(SlibInfo_t *Info, qword frames);
SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info);


/*
 * slib_render.c
 */
SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels);
SlibStatus_t slibRenderFrame(SlibInfo_t *Info, void *inbuf,
                               unsigned dword informat, void **outbuf);

/*
 * slib_video.c
 */
void SlibUpdateVideoInfo(SlibInfo_t *Info);
SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info);
int slibCalcBits(unsigned dword fourcc, int currentbits);

/*
 * slib_audio.c
 */
void SlibUpdateAudioInfo(SlibInfo_t *Info);
SlibTime_t slibSkipAudio(SlibInfo_t *Info, SlibStream_t stream,
                                           SlibTime_t timems);
SlibStatus_t slibValidateAudioParams(SlibInfo_t *Info);

/*
 * slib_buffer.c
 */
SlibBoolean_t SlibValidBuffer(void *address);
SlibStatus_t slibManageUserBuffer(SlibInfo_t *Info, void *address,
                                   unsigned int bytes, void *userdata);
unsigned char *SlibGetBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *SlibPeekBuffer(SlibInfo_t *Info, int pinid,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibSearchBuffersOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned char *lastbuf, unsigned dword *size,
                                 unsigned int code, int codebytes,
                                 ScBoolean_t discard);
SlibTime_t slibGetNextTimeOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword maxbytes);
void slibSetMaxInput(SlibInfo_t *Info, unsigned dword maxbytes);
SlibPosition_t slibGetPinPosition(SlibInfo_t *Info, int pinid);
SlibPosition_t slibSetPinPosition(SlibInfo_t *Info, int pinid,
                                                    SlibPosition_t pos);

void slibRemovePins(SlibInfo_t *Info);
void slibEmptyPins(SlibInfo_t *Info);
SlibPin_t *slibRenamePin(SlibInfo_t *Info, int oldpinid,
                                           int newpinid, char *newname);
SlibPin_t *slibGetPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibAddPin(SlibInfo_t *Info, int pinid, char *name);
SlibStatus_t slibAddBufferToPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);
SlibStatus_t slibInsertBufferOnPin(SlibPin_t *pin, void *buffer,
                                unsigned dword size, SlibTime_t time);

SlibStatus_t slibRemovePin(SlibInfo_t *Info, int pinid);
SlibStatus_t slibEmptyPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibLoadPin(SlibInfo_t *Info, int pinid);
SlibPin_t *slibPreLoadPin(SlibInfo_t *Info, SlibPin_t *pin);
SlibStatus_t slibPutBuffer(SlibInfo_t *Info, unsigned char *buffer,
                                             unsigned dword bufsize);
qword slibDataOnPin(SlibInfo_t *Info, int pinid);
qword slibDataOnPins(SlibInfo_t *Info);
unsigned char *slibGetBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                                    unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword *size, SlibTime_t *time);
unsigned char *slibPeekNextBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                       unsigned char *lastbuffer,
                                       unsigned dword *size, SlibTime_t *time);
unsigned int slibFillBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                           unsigned char *fillbuf, unsigned dword bufsize,
                           SlibTime_t *time);
word slibGetWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibGetDWordFromPin(SlibInfo_t *Info, SlibPin_t *pin);
dword slibCountCodesOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                        unsigned int code, int codebytes,
                        unsigned dword maxlen);
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position);
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid);
void slibPinFinishReposition(SlibInfo_t *Info, int pinid);
SlibBoolean_t slibCommitBuffers(SlibInfo_t *Info, SlibBoolean_t flush);
void slibValidateBitrates(SlibInfo_t *Info);
qword slibGetSystemTime();
#endif /* SLIB_INTERNAL */

#endif /* _SLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sc_file.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_file.c,v $
 * Revision 1.1.8.6  1996/12/12  20:54:43  Hans_Graves
 * 	Fix some NT warnings (when linking statically).
 * 	[1996/12/12  20:07:58  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/04  22:38:38  Hans_Graves
 * 	Fixed open/closes under NT. File closes weren't always happening.
 * 	[1996/11/04  22:29:53  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/10/28  17:32:18  Hans_Graves
 * 	Replace longs with dwords for NT portability.
 * 	[1996/10/28  16:54:46  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/09/18  23:45:38  Hans_Graves
 * 	Added ScFileClose() for portability
 * 	[1996/09/18  21:53:20  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:45  Hans_Graves
 * 	Fix file creation under NT.
 * 	[1996/05/07  17:11:18  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/04/01  16:23:08  Hans_Graves
 * 	Added ScFileOpen and ScFileRead/Write functions for portability
 * 	[1996/04/01  16:11:56  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/07  23:23:48  Hans_Graves
 * 	Added ScFileSeek().
 * 	[1996/02/07  23:21:55  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/02  18:30:51  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added include files for NT.
 * 	[1996/01/02  15:25:02  Bjorn_Engberg]
 * 
 * Revision 1.1.2.5  1995/09/20  14:59:32  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:12  Bjorn_Engberg]
 * 
 * Revision 1.1.2.4  1995/07/12  19:48:22  Hans_Graves
 * 	Added H261 recognition to ScFileType().
 * 	[1995/07/12  19:33:48  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/22  21:36:00  Hans_Graves
 * 	Moved ScGetFileType() from sv_gentoc.c. Added some Audio file types.
 * 	[1995/06/22  21:33:05  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:49  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:13:00  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/07  18:55:36  Hans_Graves
 * 	Added FileExists()
 * 	[1995/04/07  18:55:13  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  18:34:21  Hans_Graves
 * 	Inclusion in SLIB's Su library
 * 	[1995/04/07  18:33:26  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <fcntl.h>
#include <sys/types.h>
#ifndef WIN32
#include <sys/mman.h>
#endif /* WIN32 */
#include <sys/stat.h>
#include "SC.h"
#include "SC_err.h"

#ifdef WIN32
#include <string.h>
#include <sys/stat.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#endif

/*
** Name:     ScFileExists
** Purpose:  Does this file exist?
**
*/
ScBoolean_t ScFileExists(char *filename)
{
#ifdef WIN32
  struct _stat stat_buf;
  if (_stat(filename, &stat_buf))
#else
  struct stat stat_buf;
  if (stat(filename, &stat_buf))
#endif
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScFileOpenForReading
** Purpose: Open a file for reading.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForReading(char *filename)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  return((int)_open(filename, _O_RDONLY|_O_BINARY));
#else /* OSF */
  return((int)open(filename, O_RDONLY));
#endif
}

/*
** Name:    ScFileOpenForWriting
** Purpose: Open a file for writing.  Creates it if it doesn't already exist.
** Returns: Handle to file.
**          -1 if error
*/
int ScFileOpenForWriting(char *filename, ScBoolean_t truncate)
{
  if (!filename)
    return(-1);
#ifdef WIN32
  if (truncate)
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_TRUNC|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
  else
    return((int)_open(filename, _O_WRONLY|_O_CREAT|_O_BINARY,
                                _S_IREAD|_S_IWRITE));
#else
  if (truncate)
    return((int)open(filename, O_WRONLY|O_CREAT|O_TRUNC,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
  else
    return((int)open(filename, O_WRONLY|O_CREAT,
                           S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH));
#endif
}

/*
** Name:    ScFileSize
** Purpose: Get the size of a file in bytes
*/
ScStatus_t ScFileSize(char *filename, unsigned qword *size)
{
#ifdef WIN32
  struct _stat stat_buf;
#else
  struct stat stat_buf;
#endif

  if (!filename || !size)
    return(ScErrorBadArgument);
#ifdef WIN32
  if (_stat(filename, &stat_buf) < 0)
#else
  if (stat(filename, &stat_buf) < 0)
#endif
  {
    *size=0;
    return(ScErrorFile);
  }
  *size=(unsigned qword)stat_buf.st_size;
  return(NoErrors);
}

/*
** Name: ScFileRead
** Purpose: Read a number of bytes from a file into a buffer
** Return:  Number of bytes read
**          -1 if EOF
*/
dword ScFileRead(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((long)fread(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((long)_read(fd, buffer, bytes));
#else /* UNIX */
   return((long)read(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileWrite
** Purpose: Write a number of bytes from a buffer to a file
** Return:  Number of bytes written
**          0 if error
*/
dword ScFileWrite(int fd, void *buffer, unsigned dword bytes)
{
#ifdef __VMS
   return((dword)fwrite(buffer, 1, bytes, fd));
#elif defined(WIN32)
   return((dword)_write(fd, buffer, bytes));
#else /* UNIX */
   return((dword)write(fd, buffer, bytes));
#endif
}

/*
** Name: ScFileSeek
** Purpose: Seek to a specific position is a file
*/
ScStatus_t ScFileSeek(int fd, qword bytepos)
{
#ifdef __VMS
  if (fseek(fd,bytepos,SEEK_SET)<0)
#elif defined(WIN32)
  if (_lseek(fd,(long)bytepos,SEEK_SET)<0)
#else
  if (lseek(fd,(long)bytepos,SEEK_SET)<0)
#endif
    return(ScErrorFile);
  else
    return(NoErrors);
}

/*
** Name: ScFileClose
** Purpose: Close an opened file
*/
void ScFileClose(int fd)
{
  if (fd>=0)
  {
#ifdef WIN32
   _close(fd);
#else /* UNIX or VMS */
   close(fd);
#endif
  }
}

/*
** Name:    ScFileMap
** Purpose: Map an entire file to memory
**          if fd<0 then the filename is opened for reading
** Returns: buffer = memory pointer to the mapped file
**          size   = size of the buffer (file)
*/
ScStatus_t ScFileMap(char *filename, int *pfd, u_char **buffer, 
                                         unsigned qword *size)
{
#ifdef WIN32

  /*
   * Mapping of files can be supported on NT,
   * but for now return an error and implement
   * file mapping later - BE.
   */
   return(ScErrorMapFile);

#else /* !WIN32 */
  if (!pfd || !filename || !buffer || !size)
    return(ScErrorBadArgument);
  if (ScFileSize(filename, size)!=NoErrors)
    return(ScErrorFile);

  if (*pfd<0)
  {
    if ((*pfd = open (filename, O_RDONLY)) < 0)
      return(ScErrorFile);
  }

  *buffer= (unsigned char *)mmap(0, *size, PROT_READ,
                   MAP_FILE | MAP_VARIABLE | MAP_PRIVATE, *pfd, 0);
  if (*buffer==(u_char *)-1L)
  {
    *buffer=NULL;
    *size=0;
    return(ScErrorMapFile);
  }

#endif /* !WIN32 */
  return(NoErrors);
}

/*
** Name:    ScFileUnMap
** Purpose: UnMap a file mapped to memory
**          if fd>=0 then the file is closed
*/
ScStatus_t ScFileUnMap(int fd, u_char *buffer, unsigned int size)
{
  if (!buffer || !size)
    return(ScErrorBadArgument);
#ifndef WIN32
  if (munmap(buffer, size)<0)
#endif /* !WIN32 */
    return(ScErrorMapFile);
  if (fd>=0)
    ScFileClose(fd);
  return(NoErrors);
}

/*
** Name:    ScGetFileType
** Purpose: Find out the type of a multmedia file.
** Returns: UNKNOWN_FILE, AVI_FILE, JFIF_FILE, QUICKTIME_JPEG_FILE
**          MPEG_VIDEO_FILE, MPEG_AUDIO_FILE, MPEG_SYSTEM_FILE,
**          GSM_FILE
*/
int ScGetFileType(char *filename)
{
  int fd;
  u_char buf[20];
  char *fileext;

  if ((fd = ScFileOpenForReading(filename)) < 0)
    return(ScErrorDevOpen);

  ScFileRead(fd, buf, 11);

  /*
  ** MPEG video file
  */
  if ((buf[0] == 0) &&
      (buf[1] == 0) &&
      (buf[2] == 1) &&
      (buf[3] == 0xb3)) {
    ScFileClose(fd);
    return(MPEG_VIDEO_FILE);
  }
  /*
  ** MPEG system file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x01) &&
      (buf[3] == 0xba)) {
    ScFileClose(fd);
    return(MPEG_SYSTEM_FILE);
  }
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] == 0x00) &&
      (buf[3] == 0x88)) {
    ScFileClose(fd);
    return(H261_FILE);
  }
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if ((buf[0] == 0xff) &&
      (buf[1] == 0xd8)) {
    ScFileClose(fd);
    return(JFIF_FILE);
  }
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff)) {
    ScFileClose(fd);
    return(QUICKTIME_JPEG_FILE);
  }
  /******* use the file's extension to help guess the type ********/
  for (fileext=filename; *fileext; fileext++)
    if (*fileext=='.' && *(fileext+1)!='.')
    {
      fileext++;
      if (strncmp(fileext, "p64", 3)==0)
      {
        ScFileClose(fd);
        return(H261_FILE);
      }
      if (strncmp(fileext, "gsm", 3)==0)
      {
        ScFileClose(fd);
        return(GSM_FILE);
      }
      if (strncmp(fileext, "pcm", 3)==0)
      {
        ScFileClose(fd);
        return(PCM_FILE);
      }
      if (strncmp(fileext, "wav", 3)==0 && strncmp(buf, "RIFF", 4)==0)
      {
        ScFileClose(fd);
        return(WAVE_FILE);
      }
      if (strncmp(fileext, "mp", 2)==0 && buf[0]==0xFF)
      {
        ScFileClose(fd);
        return(MPEG_AUDIO_FILE);
      }
      break;
    }

  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 ) {
    ScFileClose(fd);
    return(AVI_FILE);
  }

  ScFileClose(fd);
  return(UNKNOWN_FILE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\ac3.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: ac3.h,v $
 * Revision 1.1.2.3  1996/11/11  18:21:00  Hans_Graves
 * 	Added AC3_SYNC_WORD_REV define.
 * 	[1996/11/11  17:56:01  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/11/08  21:50:39  Hans_Graves
 * 	Swapped bytes in SYNC_WORD
 * 	[1996/11/08  21:16:07  Hans_Graves]
 * 
 * 	First time under SLIB.
 * 	[1996/11/08  16:23:53  Hans_Graves]
 * 
 * $EndLog$
 */
/*	File: usr_equ.h		$Revision: 1.1.2.3 $	*/

/****************************************************************************
;	Unpublished work.  Copyright 1993-1996 Dolby Laboratories, Inc.
;	All Rights Reserved.
;
;	File:	usr_equ.h
;		Common equates for AC-3 system
;
;	History:
;		8/2/93		Created
;***************************************************************************/

#ifndef _AC3_H_
#define _AC3_H_

/**** General system equates ****/

#define NBLOCKS      6   /* # of time blocks per frame */
#define NCHANS       6   /* max # of discrete channels */
#define N            256 /* # of samples per time block */
#define AC3_FRAME_SIZE (NBLOCKS*N) /* 6 * 256 = 1536 */

/**** Miscellaneous equates ****/

#define NOUTWORDS         (3840 / 2)  /* max # words per frame */
#define NINFOWDS          10          /* # words needed by frame info */

/* Note:  Because of mismatches between the way AC-3 word stream parsing works
**		and the way that it's done for MPEG, you need to be careful using these
**		definitions
*/

#define AC3_SYNC_WORD     0x0B77      /* Byte reversed AC-3 sync word */
#define AC3_SYNC_WORD_REV 0x770B      /* packed data stream sync word */
#define AC3_SYNC_WORD_LEN 16          /* sync word length */
#define PCMCHANSZ         256         /* decoder overlap-add channel size */
#define PCM16BIT          1           /* 16-bit PCM code for Dolby SIP */

#ifdef KCAPABLE
#define NKCAPABLEMODES  4 /* # defined karaoke capable modes */
#define NKCAPABLEVARS   6 /* # karaoke pan/mix parameters */
#endif

#endif /* _AC3_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sv_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_internals.h,v $
 * Revision 1.1.8.2  1996/05/07  19:56:06  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:25:29  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/03/29  22:21:16  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.  Moved JPEG specific data to JpegInfo structures
 * 	[1996/03/29  22:14:34  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:30  Hans_Graves
 * 	Added SvMpegCompressInfo_t pointer
 * 	[1995/12/07  18:27:16  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/09/22  12:58:41  Bjorn_Engberg
 * 	Added MPEG_SUPPORT, H261_SUPPORT and BITSTREAM_SUPPORT.
 * 	[1995/09/22  12:49:37  Bjorn_Engberg]
 * 
 * Revision 1.1.2.6  1995/09/11  18:49:43  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:49:23  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/07/21  17:41:06  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/17  16:12:14  Hans_Graves
 * 	Moved BSIn, BufQ and ImageQ to SvCodecInfo_t structure.
 * 	[1995/07/17  15:54:04  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:17  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:01  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:06  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:43:08  Hans_Graves]
 * 
 * Revision 1.1.2.3  1994/11/18  18:48:17  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:45:08  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:54:06  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:56:29  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*      "%Z% %M% revision %I%; last modified %G%"; */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
                                                                                
/*--------------------------------------------------------------------------
 * Baseline data structure definitions.
 *
 * Modification History: sv_internals.h
 *
 *      08-Sep-94  PSG   Created
 *---------------------------------------------------------------------------*/



#ifndef _SV_INTERNALS_H_
#define _SV_INTERNALS_H_

#include "SV.h"
#ifdef JPEG_SUPPORT
#include "sv_jpeg.h"
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
#include "sv_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
#include "sv_h261.h"
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
#include "sv_h263.h"
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
#include "sv_huff.h"
#endif /* HUFF_SUPPORT */

#if defined(MPEG_SUPPORT) || defined(H261_SUPPORT) || defined(H263_SUPPORT) || defined(HUFF_SUPPORT)
#define BITSTREAM_SUPPORT
#endif /* MPEG_SUPPORT || H261_SUPPORT */

#define  TOC_ENTRIES_INCREMENT 100
#define  TEMP_BUF_SIZE        8192
#define  JBUFSIZE	     16384 
#define  BYTE_BUF_SIZE        8192

/*
** The following structure contains *all* state information pertaining 
** to each individual codec instance. Anything SLIB would ever want
** about the codec configuration is contained in this structure.
** For example:
**	- what is the codec configured for: compression or decompression
**	- source image characteristics
**	- destination image characteristics
**	- characteristics particular to JPEG compression
**	- characteristics particular to JPEG decompression
**	- component specific information
**
*/
typedef struct SvCodecInfo_s {
  /*
  ** what is the CODEC opened for:
  */ 
  SvCodecType_e	mode;		       /* code type, encode or decode */
  ScBoolean_t   started;           /* begin was called? */
  /*
  ** specific CODEC info
  */
  union {
    void *info;
#ifdef JPEG_SUPPORT
    /*
    ** JPEG information is stored here:
    **	modes = SV_JPEG_DECODE, SV_JPEG_ENCODE
    */
    SvJpegDecompressInfo_t *jdcmp;
    SvJpegCompressInfo_t *jcomp;
#endif /* !JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    /*
    ** MPEG specific information is stored here:
    **   modes = SV_MPEG_DECODE, SV_MPEG_ENCODE, SV_MPEG_DECODE, SV_MPEG_ENCODE
    */
    SvMpegDecompressInfo_t *mdcmp;
    SvMpegCompressInfo_t   *mcomp;
#endif /* !MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* Encoding specific information for H.261 is kept in this structure
    ** which is defined in sv_h261.h
    */
    SvH261Info_t *h261;
#endif /* !H261_SUPPORT */
#ifdef H263_SUPPORT
    /*
    ** H263 specific information is stored here:
    */
    SvH263DecompressInfo_t *h263dcmp;
    SvH263CompressInfo_t *h263comp;
#endif /* !MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    /* Encoding specific information for huffman video encoder & decoder
    */
    SvHuffInfo_t  *huff;
#endif /* !HUFF_SUPPORT */
  }; /* union */

  /*
  ** Source image characteristics:
  */
  int Width;			       /* pixels/lines     */
  int Height;			       /* number of lines  */
  unsigned int NumOperations;  /* # codec operations this session */

                                /*
  ** Microsoft specific:
  */
  BITMAPINFOHEADER   InputFormat;	
  DWORD InRedMask;      /* For BI_BITFIELDS */
  DWORD InGreenMask;    /* For BI_BITFIELDS */
  DWORD InBlueMask;     /* For BI_BITFIELDS */

  BITMAPINFOHEADER   OutputFormat;	
  DWORD OutRedMask;      /* For BI_BITFIELDS */
  DWORD OutGreenMask;    /* For BI_BITFIELDS */
  DWORD OutBlueMask;     /* For BI_BITFIELDS */

  /*
  **  Bitstream stuff - Only used by H261, H263 and MPEG
  */
  ScQueue_t      *BufQ;    /* The queue of bitstream data buffers */
  ScQueue_t      *ImageQ;  /* The queue of images (streaming mode only) */
  ScBitstream_t  *BSIn;
  ScBitstream_t  *BSOut;
  /*
  ** Callback function to abort processing & bitstream operations
  */
  int (* CallbackFunction)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *); 
} SvCodecInfo_t;


#endif _SV_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sv_h261.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_h261.h,v $
 * Revision 1.1.2.11  1995/08/15  19:13:52  Karen_Dintino
 * 	fix reentrant problem
 * 	[1995/08/15  18:30:26  Karen_Dintino]
 *
 * Revision 1.1.2.10  1995/08/07  22:09:51  Hans_Graves
 * 	Added MotionEstimationType and MotionThreshold parameters.
 * 	[1995/08/07  22:04:10  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/08/04  16:32:27  Karen_Dintino
 * 	Remove some fields from global struct and add some Me* fields
 * 	[1995/08/04  16:23:47  Karen_Dintino]
 * 
 * Revision 1.1.2.8  1995/07/21  17:41:05  Hans_Graves
 * 	Added CallbackFunction.
 * 	[1995/07/21  17:27:57  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/17  16:12:07  Hans_Graves
 * 	Moved BSIn, BufQ and ImageQ to SvCodecInfo_t structure.
 * 	[1995/07/17  15:55:30  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/13  09:46:42  Jim_Ludwig
 * 	Trying to fix this broken link
 * 	[1995/07/13  09:46:26  Jim_Ludwig]
 * 
 * Revision 1.1.2.5  1995/07/12  22:17:40  Karen_Dintino
 * 	Using common ScCopy routines
 * 	[1995/07/12  22:15:14  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/07/11  22:11:30  Karen_Dintino
 * 	Change size of some structures
 * 	[1995/07/11  21:55:20  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/07/01  18:43:19  Karen_Dintino
 * 	adding support for Decompress
 * 	[1995/07/01  18:14:36  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/06/19  20:30:50  Karen_Dintino
 * 	H.261 Codec Data Structures
 * 	[1995/06/19  19:26:47  Karen_Dintino]
 * 
 * $EndLog$
 */

/*
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:  SV_H261.H
** MODULE NAME:
**
** MODULE DESCRIPTION:
**             Data structures for H.261 Software Video Codec
**
** DESIGN OVERVIEW:
**
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * Baseline H.261 data structure definitions.
 *
 * Modification History: sv_H261.h
 *
 *      04-Jan-95 KED  Created
*---------------------------------------------------------------------------*/
#ifndef _SV_H261_H_
#define _SV_H261_H_
#include "SC.h"
#define ACTIVE_THRESH 96
#define MEBUFSIZE  1024
#define H261_BLOCKSIZE 64
#define H261_BLOCKWIDTH 8
#define H261_BLOCKHEIGHT 8

#define BEGIN(name) static char RoutineName[]= name

/*
** Faster Macro versions of huffman Decode()
*/
#define HUFFMAN_ESCAPE 0x1b01

#define DHUFF struct H261_Modified_Decoder_Huffman
#define EHUFF struct H261_Modified_Encoder_Huffman

DHUFF
{
  int NumberStates;
  int state[512];
};

EHUFF
{
  int n;
  int *Hlen;
  int *Hcode;
};

#define RTP_H261_INTRA_CODED 0x00000001
#define H261_RTP_MAX_PACKETS   64*2

typedef struct SvH261BSInfo_s {
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	MBAP;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV;
	char			VMV;
    char			padding0;
    short			padding1;
} SvH261BSInfo_t;

typedef struct SvH261BSTrailer_s {
	unsigned dword	dwVersion;
	unsigned dword	dwFlags;
	unsigned dword	dwUniqueCode;
	unsigned dword  dwCompressedSize;
	unsigned dword  dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char   TRB;
	unsigned char   DBQ;
} SvH261BSTrailer_t;

typedef struct SvH261RTPInfo_s {
    SvH261BSTrailer_t trailer;
    SvH261BSInfo_t    bsinfo[H261_RTP_MAX_PACKETS];
    ScBSPosition_t last_packet_position;
    ScBSPosition_t pre_MB_position;
    unsigned dword pre_MB_GOB;
    unsigned dword pre_MBAP;
} SvH261RTPInfo_t;

/*
** The following structure contains *all* state information pertaining
** to each individual H261 codec instance. Anything SLIB would ever want
** about the H261 codec configuration is contained in this structure.
**
*/
typedef struct SvH261Info_s
{
  ScBoolean_t inited;  /* was this info initialized yet */
  void *dbg;  /* debug handle */
  /* options */
  int quality;
  int extbitstream;  /* extended bitstream (rtp) */
  int packetsize;    /* packet size (rtp) */
  int makekey;
  int ME_method;
  int ME_search;
  int ME_threshold;
  int bit_rate;
  float frame_rate;
  int FrameRate_Fix;
  int FrameSkip;
  /* dimensions */
  int YWidth;
  int YHeight;
  int ForceCIF;
  int CWidth;
  int CHeight;
  int YW4;
  int CW4;
  int PICSIZE;
  int PICSIZEBY4;
  /* misc */
  int (* CallbackFunction)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *);
  int MeVAR[MEBUFSIZE];
  int MeVAROR[MEBUFSIZE];
  int MeMWOR[MEBUFSIZE];
  int MeX[MEBUFSIZE];
  int MeY[MEBUFSIZE];
  int MeVal[MEBUFSIZE];
  int MeOVal[MEBUFSIZE];
  int PreviousMeOVal[MEBUFSIZE];
  unsigned int CodedFrames;
  unsigned int C_U_Frames;
  float BitsAvailableMB;
  float ACE;
  int ActThr, ActThr2, ActThr3, ActThr4, ActThr5, ActThr6;
  int ChChange;
  int LowerQuant;
  int LowerQuant_FIX;
  int FineQuant;
  int PBUFF;
  int PBUFF_Factor;
  double ZBDecide;
  double VARF;
  double VARORF;
  double VARSQ;
  double VARORSQ;
  int MSmooth;
  int NumberGOB;
  int CurrentGOB;
  ScBSPosition_t Current_MBBits;
  ScBSPosition_t MotionVectorBits;
  ScBSPosition_t MacroAttributeBits;
  ScBSPosition_t CurrentBlockBits;
  ScBSPosition_t CodedBlockBits;
  ScBSPosition_t EOBBits;
  int MType;
  int GQuant;
  int MQuant;
  int QP;			/* for VBR */
  int QPI;
  int MVDH;
  int MVDV;
  int CBP;
  int PSpare;
  int GSpare;
  int GRead;
  int MBA;
  int LastMBA;
  int LastMType;
  double alpha1;
  double alpha2;
  double snr_PastFrame;
  double time_total;
  double timegen;
  double Avg_AC;
  double Global_Avg;
int VYWH;
int VYWBYWH;
int VYWH2;
int VYWHMV;
int VYWBYWHMV;
int VYWHMV2;
ScBSPosition_t NBitsPerFrame;
int MAX_MQUANT;
int MIN_MQUANT;
int OverFlow;
int OverFlow2;
int Buffer_B;
int Big_Buffer;
int AQuant;
ScBSPosition_t Buffer_All;
ScBSPosition_t Buffer_NowPic;
ScBSPosition_t BitsLeft;
ScBSPosition_t NBitsCurrentFrame;
int Pictures_in_Buff;
int All_MType[512];
int TotalCodedMB;
int TT_MB;
int NoSkippedFrame;
int TotalCodedMB_Inter;
int TotalCodedMB_Intra;
int Current_CodedMB[2];
int CodeLength;
int MBpos;
int MQFlag;
int CurrentCBNo;
/* System Definitions */
int ImageType;
int NumberMDU;
int CurrentMDU;
int CurrentFrame;
int StartFrame;
int LastFrame;
int PreviousFrame;
int NumberFrames;
int TransmittedFrames;
/* Stuff for RateControl */
ScBSPosition_t FileSizeBits;
ScBSPosition_t BufferOffset;  /*Number of bits assumed for initial buffer. */
int QDFact;
int QOffs;
int QUpdateFrequency;
int QUse;
int QSum;
int InitialQuant;
int CBPThreshold;  /* abs threshold before we use CBP */
ScBSPosition_t MBBits[2];
int CBPFreq[6];
int TotalMB[2];
int SkipMB;
int TemporalReference;
int TemporalOffset;
int PType;
int Type2;
int VAR;
int VAROR;
int MWOR;
int LastMVDV;
int LastMVDH;
int ParityEnable;
int PSpareEnable;
int GSpareEnable;
int Parity;
  /* Statistics */
  int NumberNZ;
  ScBSPosition_t FirstFrameBits;
  ScBSPosition_t NumberOvfl;
  ScBSPosition_t YCoefBits;
  ScBSPosition_t UCoefBits;
  ScBSPosition_t VCoefBits;
  ScBSPosition_t TotalBits;
  ScBSPosition_t LastBits;
  int MacroTypeFrequency[10];
  int YTypeFrequency[10];
  int UVTypeFrequency[10];
  /* for Decode */
  int UseQuant;
  unsigned int ByteOffset;
  unsigned int TotalByteOffset;
  unsigned int *workloc;
  DHUFF *MBADHuff;
  DHUFF *MVDDHuff;
  DHUFF *CBPDHuff;
  DHUFF *T1DHuff;
  DHUFF *T2DHuff;
  DHUFF *T3DHuff;

  EHUFF *MBAEHuff;
  EHUFF *MVDEHuff;
  EHUFF *CBPEHuff;
  EHUFF *T1EHuff;
  EHUFF *T2EHuff;
  EHUFF *T3EHuff;
  int NumberBitsCoded;
  unsigned char CodedMB[512];
  unsigned char **LastIntra; /* Used for intra forcing (once per 132 frames ) */
  unsigned char *CompData;
  unsigned char *DecompData;
  unsigned char *YREF;
  unsigned char *UREF;
  unsigned char *VREF;
  unsigned char *Y;
  unsigned char *U;
  unsigned char *V;
  unsigned char *YRECON;
  unsigned char *URECON;
  unsigned char *VRECON;
  unsigned char *YDEC;
  unsigned char *UDEC;
  unsigned char *VDEC;
  unsigned char mbRecY[256];
  unsigned char mbRecU[64];
  unsigned char mbRecV[64];

  SvH261RTPInfo_t *RTPInfo;
} SvH261Info_t;


#endif /* _SV_H261_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\avi.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: avi.h,v $
 * Revision 1.1.2.4  1996/01/15  16:26:22  Hans_Graves
 * 	Added Wave stuff
 * 	[1996/01/15  15:43:39  Hans_Graves]
 *
 * Revision 1.1.2.3  1996/01/08  16:41:23  Hans_Graves
 * 	Renamed AVI header structures.
 * 	[1996/01/08  15:45:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/12/07  19:31:26  Hans_Graves
 * 	Creation under SLIB
 * 	[1995/12/07  18:29:05  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _AVI_H_
#define _AVI_H_

/************** AVI parsing definitions **************/
typedef unsigned short twocc_t;
typedef unsigned int fourcc_t;

#ifndef FOURCC
#define FOURCC( ch0, ch1, ch2, ch3 ) \
          ( (fourcc_t)(char)(ch3) | ( (fourcc_t)(char)(ch2) << 8 ) | \
          ( (fourcc_t)(char)(ch1) << 16 ) | ( (fourcc_t)(char)(ch0) << 24 ) )
#endif

/* Macro to make a TWOCC out of two characters */

#ifndef TWOCC
#define TWOCC(ch0, ch1) ((twocc_t)(char)(ch1)|((twocc_t)(char)(ch0)<<8))
#endif

/* form types, list types, and chunk types */
#define AVI_AVI                 FOURCC('A', 'V', 'I', ' ')
#define AVI_AVIHEADERTYPE       FOURCC('h', 'd', 'r', 'l')
#define AVI_MAINHDR             FOURCC('a', 'v', 'i', 'h')
#define AVI_STREAMHEADERTYPE    FOURCC('s', 't', 'r', 'l')
#define AVI_STREAMHEADER        FOURCC('s', 't', 'r', 'h')
#define AVI_STREAMFORMAT        FOURCC('s', 't', 'r', 'f')
#define AVI_STREAMHANDLERDATA   FOURCC('s', 't', 'r', 'd')

#define AVI_MOVIETYPE           FOURCC('m', 'o', 'v', 'i')
#define AVI_RECORDTYPE          FOURCC('r', 'e', 'c', ' ')

#define AVI_NEWINDEX            FOURCC('i', 'd', 'x', '1')

/*
** Stream types for the <fccType> field of the stream header.
*/
#define AVI_VIDEOSTREAM         FOURCC('v', 'i', 'd', 's')
#define AVI_AUDIOSTREAM         FOURCC('a', 'u', 'd', 's')

/* Basic chunk types */
#define AVI_DIBbits           TWOCC('d', 'b')
#define AVI_DIBcompressed     TWOCC('d', 'c')
#define AVI_PALchange         TWOCC('p', 'c')
#define AVI_WAVEbytes         TWOCC('w', 'b')
#define AVI_Indeo             TWOCC('i', 'v')

/* Chunk id to use for extra chunks for padding. */
#define AVI_PADDING             FOURCC('J', 'U', 'N', 'K')

typedef struct
{
  dword dwMicroSecPerFrame;     /* frame display rate */
  dword dwMaxBytesPerSec;       /* max. transfer rate */
  dword dwPaddingGranularity;   /* pad to multiples of this */
                                /* size; normally 2K. */
  dword dwFlags;                /* the ever-present flags */
  dword dwTotalFrames;          /* # frames in file */
  dword dwInitialFrames;
  dword dwStreams;
  dword dwSuggestedBufferSize;

  dword dwWidth;
  dword dwHeight;

  dword dwReserved[4];
} AVI_MainHeader;

typedef struct {
    short left,top,right,bottom;
} DUMMYRECT;

typedef struct {
  fourcc_t  fccType;
  fourcc_t  fccHandler;
  dword     dwFlags;        /* Contains AVITF_* flags */
  dword     dwPriority;
  dword     dwInitialFrames;
  dword     dwScale;
  dword     dwRate; /* dwRate / dwScale == samples/second */
  dword     dwStart;
  dword     dwLength; /* In units above... */
  dword     dwSuggestedBufferSize;
  dword     dwQuality;
  dword     dwSampleSize;
  DUMMYRECT rcFrame;
} AVI_StreamHeader;

typedef struct
{
  dword ckid;
  dword dwFlags;
  dword dwChunkOffset;          /* Position of chunk */
  dword dwChunkLength;          /* Length of chunk */
} AVI_INDEXENTRY;

#define RIFF_WAVE               FOURCC('W', 'A', 'V', 'E')
#define RIFF_FORMAT             FOURCC('f', 'm', 't', ' ')
#define RIFF_DATA               FOURCC('d', 'a', 't', 'a')

typedef struct
{
  word  wFormatTag;
  word  nChannels;
  dword nSamplesPerSec;
  dword nAvgBytesPerSec;
  word  nBlockAlign;
  word  wBitsPerSample;
} WAVE_format;

#endif _AVI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\video.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_video.c,v $
 * Revision 1.1.6.13  1996/12/13  18:19:11  Hans_Graves
 * 	Added initialization of VideoPTimeBase.
 * 	[1996/12/13  18:07:51  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/12/10  19:22:01  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:24  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/11/18  23:07:40  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:05  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/11/11  18:21:11  Hans_Graves
 * 	Moved setting of VideoMainStream to slib_api.c
 * 	[1996/11/11  18:02:11  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/11/08  21:51:09  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:28:03  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/10/28  17:32:36  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/10/12  17:18:59  Hans_Graves
 * 	Seperated TYPE_MPEG2_SYSTEMS into TRANSPORT and PROGRAM.
 * 	[1996/10/12  17:03:19  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/09/29  22:19:45  Hans_Graves
 * 	Added Stride support. YUY2 fixups.
 * 	[1996/09/29  21:32:24  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/09/25  19:16:51  Hans_Graves
 * 	Fix up support for YUY2. Add SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:18  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/09/23  18:04:06  Hans_Graves
 * 	Add reallocation of ScaleBuf if width/height changes.
 * 	[1996/09/23  17:58:27  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/09/18  23:47:25  Hans_Graves
 * 	Added MPEG2 YUV 4:2:2 handling
 * 	[1996/09/18  22:04:18  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:25  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:21:23  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/05/02  17:10:37  Hans_Graves
 * 	Reject a data type when header info is not found. Fixes MME-01234
 * 	[1996/05/02  17:09:53  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/22  15:04:56  Hans_Graves
 * 	Renamed slibVerifyVideoParams() to slibValidateVideoParams()
 * 	[1996/04/22  14:44:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/19  21:52:28  Hans_Graves
 * 	Fix Height and Width checking for H261
 * 	[1996/04/19  21:46:27  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/04/01  19:07:58  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:42  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/29  22:21:37  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:57:04  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:56:00  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:51  Hans_Graves
 * 	Added slibVerifyVideoParams()
 * 	[1996/03/08  18:36:51  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/19  18:04:00  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:50  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/07  23:24:01  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:39  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:06  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:51  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:10  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:45  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:33  Hans_Graves
 * 	No video if SLIB_TYPE_MPEG1_AUDIO or SLIB_TYPE_WAVE
 * 	[1996/01/15  15:47:40  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:36  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:41  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:35  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:10  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:24  Hans_Graves
 * 	Added H.261 compression support.
 * 	[1995/12/08  20:00:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:37  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:12  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:08  Hans_Graves
 * 	Added GetVideoTime()
 * 	[1995/11/09  23:09:19  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:57  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:05  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "mpeg.h"
#include "h261.h"
#include "h263.h"
#include "jpeg.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

int slibCalcBits(unsigned dword fourcc, int currentbits)
{
  switch (fourcc)
  {
      case BI_DECMPEGDIB:
      case BI_DECH261DIB:
      case BI_MSH261DIB:
      case BI_DECH263DIB:
      case BI_MSH263DIB:
      case JPEG_DIB:
          return(24);
      case MJPG_DIB:
      case BI_YU12SEP:         /* YUV 4:1:1 Planar */
          return(24);
      case BI_DECYUVDIB:       /* YUV 4:2:2 Packed */
      case BI_YUY2:            /* YUV 4:2:2 Packed */
          return(16);
      case BI_YU16SEP:         /* YUV 4:2:2 Planar */
          return(24);
      case BI_YVU9SEP:         /* YUV 16:1:1 Planar */
          return(24);
  }
  return(currentbits);
}

static unsigned dword slibCalcImageSize(unsigned dword fourcc, int bits,
                              int width, int height)
{
  unsigned dword imagesize=0;
  if (width<0) width=-width;
  if (height<0) height=-height;
  switch (fourcc)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          imagesize = (width*height*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          imagesize = (width*height*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          imagesize = width*height*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          imagesize = width*height*(bits==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          imagesize = width*height*(bits/8);
          break;
      default:
          imagesize = width*height;
  }
  return(imagesize);
}

static dword slibFOURCCtoVideoType(dword *fourcc)
{
  switch (*fourcc)
  {
    case BI_DECH261DIB:
    case BI_MSH261DIB:
       *fourcc=BI_DECH261DIB;
       return(SLIB_TYPE_H261);
    case BI_DECH263DIB:
    case BI_MSH263DIB:
       *fourcc=BI_DECH263DIB;
       return(SLIB_TYPE_H263);
    case JPEG_DIB:
       return(SLIB_TYPE_JPEG);
    case MJPG_DIB:
       return(SLIB_TYPE_MJPG);
    case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
    case BI_YUY2:      /* YUV 4:2:2 Packed */
    case BI_YU16SEP:   /* YUV 4:2:2 Planar */
    case BI_YU12SEP:   /* YUV 4:1:1 Planar */
    case BI_YVU9SEP:   /* YUV 16:1:1 Planar */
       return(SLIB_TYPE_YUV);
    default:
       _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
  }
  return(0);
}

static void slibUpdateVideoFrames(SlibInfo_t *Info)
{
#ifdef MPEG_SUPPORT
  if (Info->VideoLengthKnown==FALSE && slibDataOnPin(Info, SLIB_DATA_VIDEO) &&
           Info->FileSize>0 && Info->FileSize<Info->OverflowSize)
  {
    if (SlibTypeIsMPEGVideo(Info->Type))
    {
      dword frames = slibCountCodesOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    MPEG_PICTURE_START, 4, 0);
      if (Info->FramesPerSec)
        Info->VideoLength=slibFrameToTime(Info, frames);
      Info->VideoLengthKnown=TRUE;
    }
  }
#endif /* MPEG_SUPPORT */
}

void SlibUpdateVideoInfo(SlibInfo_t *Info)
{
  int inbpp=24, outbpp=24, compformat=0, dcmpformat=0;
  SlibTime_t ptime;
  _SlibDebug(_DEBUG_, printf("SlibUpdateVideoInfo()\n") );

  if (SlibTypeIsAudioOnly(Info->Type)) /* no video? */
    return;
  if (Info->Mode == SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = SIF_WIDTH;
            Info->Height = SIF_HEIGHT;
            Info->FramesPerSec = 25.0F;
            Info->VideoBitRate = 1152000;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 15.0F;
            Info->VideoBitRate = 352000;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = CIF_WIDTH;
            Info->Height = CIF_HEIGHT;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->Width = 320;
            Info->Height = 240;
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            break;
#endif /* HUFF_SUPPORT */
      default:
            break;
    }
  }
  else if (Info->Mode == SLIB_MODE_DECOMPRESS)
  {
    unsigned char *buf;
    unsigned dword size;
    Info->VideoStreams=1;
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
      case SLIB_TYPE_MPEG2_VIDEO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG_TRANSPORT:
      case SLIB_TYPE_MPEG_PROGRAM:
            _SlibDebug(_DEBUG_,
                 printf("SlibUpdateVideoInfo() MPEG1 or MPEG2\n") );
            if (!slibLoadPin(Info, SLIB_DATA_VIDEO))
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() No VIDEO data\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, MPEG_SEQ_HEAD,
                                         MPEG_SEQ_HEAD_LEN/8, FALSE);
            if (buf)
            {
              const float fps[16] = {
               30.0F, 23.976F, 24.0F, 25.0F, 29.97F, 30.0F, 50.0F, 59.94F,
               60.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F, 30.0F
              };
             /*  ScDumpChar(buf, size, 0); */
              Info->Width = ((int)buf[0])*16+(int)(buf[1]>>4);
              Info->Height = ((int)buf[1]&0x0F)*256+(int)buf[2];
              /* must be 16x16 because of Render limitations, round up */
              Info->Width += (Info->Width%16) ? 16-(Info->Width%16) : 0;
              Info->Height += (Info->Height%16) ? 16-(Info->Height%16) : 0;
              Info->FramesPerSec = fps[buf[3]&0x0F];
              Info->VideoBitRate = (((dword)buf[4]&0xFF)<<10) +
                                   (((dword)buf[5])<<2) +
                                    (dword)(buf[6]>>6);
              Info->VideoBitRate *= 400;
              Info->VBVbufSize = ((int)buf[6]&0x1F)<<5 | (int)(buf[7]>>3);
              Info->VBVbufSize *= 2*1024;
              _SlibDebug(_DEBUG_, printf("VBVbufSize=%d\n", Info->VBVbufSize) );
              if (Info->VideoBitRate)
              {
                qword secs=(qword)(((qword)Info->FileSize*80L)
                                                       /Info->VideoBitRate);
                Info->VideoLength = secs*100;
                _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() VideoLength = %ld  Bitrate=%ld\n",
                                Info->VideoLength, Info->VideoBitRate) );
              }
            }
            else /* invalid format */
            {
              _SlibDebug(_DEBUG_,
                printf("SlibUpdateVideoInfo() Didn't find MPEG sequence header\n") );
              Info->Type=SLIB_TYPE_UNKNOWN;
              Info->VideoStreams=0;
              return;
            }
            compformat=BI_DECMPEGDIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_MPEG1_VIDEO;
            /* check to see if this is MPEG 2 */
            _SlibDebug(_DEBUG_,
              printf("Searching for MPEG 2 extensions...\n") );
            do {
              buf = slibSearchBuffersOnPin(Info,
                                           slibGetPin(Info, SLIB_DATA_VIDEO),
                                           buf, &size, MPEG_START_CODE,
                                           MPEG_START_CODE_LEN/8, FALSE);
              if (buf && buf[0]==MPEG_EXT_START_BASE)
              {
                _SlibDebug(_DEBUG_,
                  printf("Found START CODE %X, ID=%d\n", buf[0], buf[1]>>4) );
                if ((buf[1]>>4)==MPEG_SEQ_ID) /* has to be MPEG 2 */
                {
                  if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
                    Info->Type=SLIB_TYPE_MPEG2_VIDEO;
                  else if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS)
                    Info->Type=SLIB_TYPE_MPEG_SYSTEMS_MPEG2;
                  Info->VideoType=SLIB_TYPE_MPEG2_VIDEO;
                  switch ((buf[2]>>1)&0x03)
                  {
                    default:
                    case 1: /* 4:1:1 */ dcmpformat=BI_YU12SEP;
                            _SlibDebug(_DEBUG_, printf("4:1:1\n") );
                            break;
                    case 2: /* 4:2:2 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:2:2\n") );
                            break;
                    case 3: /* 4:4:4 */ dcmpformat=BI_YU16SEP;
                            _SlibDebug(_DEBUG_, printf("4:4:4\n") );
                            break;
                  }
                  break;
                }
              }
              else
                break;
            } while (1);
            _SlibDebug(_DEBUG_,
              printf("Done searching for MPEG 2 extensions.\n") );
            Info->KeySpacing=12;
            Info->SubKeySpacing=3;
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
      case SLIB_TYPE_RTP_H261:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, H261_START_CODE,
                                         H261_START_CODE_LEN/8, FALSE);
            if (buf)
            {
              if ((buf[0]&0xF0)==0) /* picture start code */
              {
                if (buf[1]&0x08)
                {
                  Info->Width = 352;
                  Info->Height = 288;
                }
                else
                {
                  Info->Width = 176;
                  Info->Height = 144;
                }
              }
              Info->FramesPerSec = 15.0F;
            }
            compformat=BI_DECH261DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H261;
            break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
      case SLIB_TYPE_RTP_H263:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info, SLIB_DATA_VIDEO),
                                         NULL, &size, 0x000080,
                                         3, FALSE);
            if (buf)
            {
              switch ((buf[1]>>2)&0x07)
              {
                case H263_SF_SQCIF:
                  Info->Width = SQCIF_WIDTH;
                  Info->Height = SQCIF_HEIGHT;
                  break;
                case H263_SF_QCIF:
                  Info->Width = QCIF_WIDTH;
                  Info->Height = QCIF_HEIGHT;
                  break;
                case H263_SF_4CIF:
                  Info->Width = CIF4_WIDTH;
                  Info->Height = CIF4_HEIGHT;
                  break;
                case H263_SF_16CIF:
                  Info->Width = CIF16_WIDTH;
                  Info->Height = CIF16_HEIGHT;
                  break;
                case H263_SF_CIF:
                default:
                  Info->Width = CIF_WIDTH;
                  Info->Height = CIF_HEIGHT;
              }
              Info->FramesPerSec = 30.0F;
            }
            compformat=BI_DECH263DIB;
            dcmpformat=BI_YU12SEP;
            Info->VideoType=SLIB_TYPE_H263;
            break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf=slibPeekBufferOnPin(Info,
                    slibGetPin(Info,SLIB_DATA_VIDEO), &size, NULL);
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1],
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[3]*256)+(int)buf[4];
              Info->Height = ((int)buf[5]*256)+(int)buf[6];
            }
            Info->FramesPerSec = 30.0F;
            Info->VideoBitRate = 0;
            compformat=BI_DECHUFFDIB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_SHUFF;
            break;
#endif /* HUFF_SUPPORT */
      case SLIB_TYPE_RASTER:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((int)buf[4]<<24)+((int)buf[5]<<16)+((int)buf[6]<<8)+(int)buf[7];
              Info->Height = ((int)buf[8]<<24)+((int)buf[9]<<16)+((int)buf[10]<<8)+(int)buf[11];

              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            compformat=BI_RGB;
            dcmpformat=BI_YU12SEP;
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            Info->VideoType=SLIB_TYPE_RASTER;
            break;
      case SLIB_TYPE_BMP:
            buf=slibPeekBufferOnPin(Info, 
                    slibGetPin(Info,SLIB_DATA_COMPRESSED), &size, NULL);
            Info->FramesPerSec = 30.0F;
            if (buf)
            {
              _SlibDebug(_DEBUG_,
                  printf("%2X %2X %2X %2X %2X %2X\n", buf[0], buf[1], 
                                       buf[2], buf[3],  buf[4], buf[5]) );
              Info->Width = ((dword)buf[15]<<24)+((dword)buf[16]<<16)+((dword)buf[17]<<8)+(dword)buf[18];
              Info->Height = ((dword)buf[19]<<24)+((dword)buf[20]<<16)+((dword)buf[21]<<8)+(dword)buf[22];
              compformat=((dword)buf[30]<<24)+((dword)buf[25]<<16)+((dword)buf[26]<<8)+(dword)buf[27];
              inbpp=(dword)buf[28];
              Info->VideoLength = slibFrameToTime(Info,
                                 (signed qword)Info->FileSize/(Info->Width*Info->Height*3));
            }
            else
              Info->VideoLength = slibFrameToTime(Info, 1);
            Info->VideoBitRate = 0;
            Info->VideoType = slibFOURCCtoVideoType(&compformat);
            dcmpformat=BI_YU16SEP;
            outbpp=slibCalcBits(dcmpformat, outbpp);
            Info->KeySpacing=1;
            Info->SubKeySpacing=1;
            break;

      case SLIB_TYPE_RIFF:
      case SLIB_TYPE_AVI:
            slibLoadPin(Info, SLIB_DATA_COMPRESSED);
            buf = slibSearchBuffersOnPin(Info,
                                         slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                         NULL, &size, AVI_MAINHDR, 4, FALSE);
            if (buf)
            {
              AVI_MainHeader hdr;
              /* printf("%d %d %d %d\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+4, sizeof(AVI_MainHeader));
              Info->Width  = (short)hdr.dwWidth;
              Info->Height = (short)hdr.dwHeight;
              Info->FramesPerSec = 1000000.0F/hdr.dwMicroSecPerFrame;
              if (Info->FramesPerSec==0.0F)
                Info->FramesPerSec = 30.0F;
              Info->VideoLength = slibFrameToTime(Info, hdr.dwTotalFrames);
              Info->VideoLengthKnown = TRUE;
            }
            buf = slibSearchBuffersOnPin(Info,
                                     slibGetPin(Info,SLIB_DATA_COMPRESSED),
                                     NULL, &size, AVI_STREAMFORMAT, 4, FALSE);
            if (buf)
            {
              AVI_StreamHeader hdr;
              /* printf("%c %c %c %c\n", buf[4], buf[5], buf[6], buf[7]); */
              memcpy(&hdr, buf+20, sizeof(AVI_StreamHeader));
              compformat=hdr.fccType;
              Info->VideoType = slibFOURCCtoVideoType(&compformat);
              switch (Info->VideoType)
              {
                case SLIB_TYPE_JPEG:
                  Info->Type = SLIB_TYPE_JPEG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_MJPG:
                  Info->Type = SLIB_TYPE_MJPG_AVI;
                  dcmpformat=BI_YU16SEP;
                  break;
                case SLIB_TYPE_YUV:
                  Info->Type = SLIB_TYPE_YUV_AVI;
                  dcmpformat=compformat;
                  if (IsYUV422Packed(dcmpformat) || IsYUV422Sep(dcmpformat))
                    dcmpformat=BI_YU16SEP;
                  break;
                default:
                  _SlibDebug(_WARN_, printf("Unsupported AVI format\n") );
                  return;
              }
              inbpp=slibCalcBits(compformat, inbpp);
              outbpp=slibCalcBits(dcmpformat, outbpp);
              Info->KeySpacing=1;
              Info->SubKeySpacing=1;
            }
            break;
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG_QUICKTIME:
      case SLIB_TYPE_JFIF:
            /* not supported - need to know how to parse */
            slibLoadPin(Info, SLIB_DATA_VIDEO);
            buf = slibSearchBuffersOnPin(Info,
                                    slibGetPin(Info, SLIB_DATA_VIDEO),
                                    NULL, &size, (JPEG_MARKER<<8)|JPEG_SOF0,
                                    2, FALSE);
            if (buf)
            {
              Info->Width  = ((int)buf[5]<<8) + (int)buf[6];
              Info->Height = ((int)buf[3]<<8) + (int)buf[4];
              Info->FramesPerSec = 30.0F;
            }
            compformat=MJPG_DIB;
            dcmpformat=BI_YU16SEP;
            Info->VideoType = SLIB_TYPE_JPEG;
            break;
#endif /* JPEG_SUPPORT */
    }
    slibUpdateVideoFrames(Info);
  }
  if (SlibTypeHasTimeStamps(Info->Type))
  {
    ptime=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 100*1024);
    if (SlibTimeIsValid(ptime))
      Info->VideoPTimeBase=ptime;
  }
  if (Info->CompVideoFormat==NULL)
    Info->CompVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  _SlibDebug(_VERBOSE_,
         printf("Width=%d Height=%d Stride=%d\n",
              Info->Width, Info->Height, Info->Stride) );
  if (Info->CompVideoFormat!=NULL)
  {
    Info->CompVideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->CompVideoFormat->biWidth         = Info->Width;
    Info->CompVideoFormat->biHeight        = Info->Height;
    Info->CompVideoFormat->biPlanes        = 1;
    Info->CompVideoFormat->biBitCount      = (WORD)inbpp;
    Info->CompVideoFormat->biCompression   = compformat;
    Info->CompVideoFormat->biSizeImage     = 0;
    Info->CompVideoFormat->biXPelsPerMeter = 0;
    Info->CompVideoFormat->biYPelsPerMeter = 0;
    Info->CompVideoFormat->biClrUsed       = 0;
    Info->CompVideoFormat->biClrImportant  = 0;
  }
  if (Info->VideoFormat==NULL)
    Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
  if (Info->VideoFormat!=NULL)
  {
    Info->VideoFormat->biSize          = sizeof(BITMAPINFOHEADER);
    Info->VideoFormat->biWidth         = Info->Width;
    Info->VideoFormat->biHeight        = Info->Height;
    Info->VideoFormat->biPlanes        = 1;
    Info->VideoFormat->biBitCount      = (WORD)outbpp;
    Info->VideoFormat->biCompression   = dcmpformat;
    Info->VideoFormat->biSizeImage     = 0;
    Info->VideoFormat->biXPelsPerMeter = 0;
    Info->VideoFormat->biYPelsPerMeter = 0;
    Info->VideoFormat->biClrUsed       = 0;
    Info->VideoFormat->biClrImportant  = 0;
  }
  if (Info->CodecVideoFormat==NULL)
  {
    Info->CodecVideoFormat=(BITMAPINFOHEADER *)ScAlloc(sizeof(BITMAPINFOHEADER));
    if (Info->CodecVideoFormat!=NULL)
      memcpy(Info->CodecVideoFormat, Info->VideoFormat,
                                     sizeof(BITMAPINFOHEADER));
  }
  slibValidateVideoParams(Info);
}

SlibStatus_t slibValidateVideoParams(SlibInfo_t *Info)
{
  dword oldimagesize, codecwidth, codecheight;
  SlibStatus_t status=SlibErrorNone;
  if (Info->CodecVideoFormat)
  {
    codecwidth=Info->CodecVideoFormat->biWidth;
    codecheight=Info->CodecVideoFormat->biHeight;
  }
  else
  {
    codecwidth=Info->Width;
    codecheight=Info->Height;
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
      case SLIB_TYPE_H261:
            if (Info->Width!=CIF_WIDTH && Info->Width!=QCIF_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=QCIF_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
            }
            break;
      case SLIB_TYPE_H263:
            if (Info->Width!=CIF_WIDTH && Info->Width!=SQCIF_WIDTH && Info->Width!=QCIF_WIDTH &&
                Info->Width!=CIF4_WIDTH && Info->Width!=CIF16_WIDTH)
              status=SlibErrorImageSize;
            if (Info->Height!=CIF_HEIGHT && Info->Height!=SQCIF_HEIGHT && Info->Height!=QCIF_HEIGHT &&
                Info->Height!=CIF4_HEIGHT && Info->Height!=CIF16_HEIGHT)
              status=SlibErrorImageSize;
            if (status!=SlibErrorNone) /* set to closest size */
            {
              if (Info->Width<=168)
              {
                codecwidth=SQCIF_WIDTH;
                codecheight=SQCIF_HEIGHT;
              }
              else if (Info->Width<=300)
              {
                codecwidth=QCIF_WIDTH;
                codecheight=QCIF_HEIGHT;
              }
              else if (Info->Width<=(CIF4_WIDTH+CIF_WIDTH)/2)
              {
                codecwidth=CIF_WIDTH;
                codecheight=CIF_HEIGHT;
              }
              else if (Info->Width<=(CIF16_WIDTH+CIF4_WIDTH)/2)
              {
                codecwidth=CIF4_WIDTH;
                codecheight=CIF4_HEIGHT;
              }
              else
              {
                codecwidth=CIF16_WIDTH;
                codecheight=CIF16_HEIGHT;
              }
            }
            break;
    }
    /* height and width must be mults of 8 */
    if (codecwidth%8 || codecheight%8)
      return(SlibErrorImageSize);
    if (status==SlibErrorImageSize)
    {
      if (Info->CodecVideoFormat)
      {
        Info->CodecVideoFormat->biWidth=codecwidth;
        Info->CodecVideoFormat->biHeight=codecheight;
      }
      if (Info->CompVideoFormat)
      {
        Info->CompVideoFormat->biWidth=codecwidth;
        Info->CompVideoFormat->biHeight=codecheight;
      }
    }
  }
  if (Info->VideoFormat)
  {
    oldimagesize=Info->ImageSize;
    Info->ImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount,
                                      Info->VideoFormat->biWidth,
                                      Info->VideoFormat->biHeight);
    if (Info->ImageSize!=oldimagesize && Info->Imagebuf)
    {
      SlibFreeBuffer(Info->Imagebuf);
      Info->Imagebuf=NULL;
    }
    Info->VideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->VideoFormat->biCompression,
                                      Info->VideoFormat->biBitCount);
    Info->VideoFormat->biSizeImage=Info->ImageSize;
  }
  if (Info->CodecVideoFormat)
  {
    oldimagesize=Info->CodecImageSize;
    Info->CodecImageSize=slibCalcImageSize(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount,
                                      Info->CodecVideoFormat->biWidth,
                                      Info->CodecVideoFormat->biHeight);
    if (Info->CodecImageSize!=oldimagesize && Info->CodecImagebuf)
    {
      SlibFreeBuffer(Info->CodecImagebuf);
      Info->CodecImagebuf=NULL;
    }
    Info->CodecVideoFormat->biBitCount=(WORD)slibCalcBits(
                                      Info->CodecVideoFormat->biCompression,
                                      Info->CodecVideoFormat->biBitCount);
    Info->CodecVideoFormat->biSizeImage=Info->CodecImageSize;
  }
  if (Info->VideoFormat && Info->CodecVideoFormat)
  {
    oldimagesize=Info->IntImageSize;
    Info->IntImageSize=slibCalcImageSize(Info->VideoFormat->biCompression,
                                         Info->VideoFormat->biBitCount,
                                         Info->CodecVideoFormat->biWidth,
                                         Info->CodecVideoFormat->biHeight);
    if (Info->IntImageSize!=oldimagesize && Info->IntImagebuf)
    {
      SlibFreeBuffer(Info->IntImagebuf);
      Info->IntImagebuf=NULL;
    }
  }
  /* close format converter since formats may have changed */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  if (Info->FramesPerSec)
    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sv_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_api.c,v $
 * Revision 1.1.8.11  1996/10/28  17:32:51  Hans_Graves
 * 	MME-01402. Changed SvGet/SetParamInt() to qwords to allow for timestamps.
 * 	[1996/10/28  17:09:33  Hans_Graves]
 *
 * Revision 1.1.8.10  1996/10/12  17:19:24  Hans_Graves
 * 	Added initialization of SV_PARAM_SKIPPEL and SV_PARAM_HALFPEL to MPEG encode.
 * 	[1996/10/12  17:16:28  Hans_Graves]
 * 
 * Revision 1.1.8.9  1996/09/29  22:19:56  Hans_Graves
 * 	Added stride to ScYuv411ToRgb() calls.
 * 	[1996/09/29  21:34:40  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/09/25  19:17:01  Hans_Graves
 * 	Fix up support for YUY2 under MPEG.
 * 	[1996/09/25  19:03:17  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/09/18  23:51:11  Hans_Graves
 * 	Added JPEG 4:1:1 to 4:2:2 conversions. Added BI_YVU9SEP and BI_RGB 24 support in MPEG decode.
 * 	[1996/09/18  22:16:08  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/07/30  20:25:50  Wei_Hsu
 * 	Add Logarithmetic search for motion estimation.
 * 	[1996/07/30  15:57:59  Wei_Hsu]
 * 
 * Revision 1.1.8.5  1996/05/24  22:22:26  Hans_Graves
 * 	Add GetImageSize MPEG support for BI_DECYUVDIB
 * 	[1996/05/24  22:14:20  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/05/08  16:24:32  Hans_Graves
 * 	Put BITSTREAM_SUPPORT around BSIn in SvDecompress
 * 	[1996/05/08  16:24:15  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/05/07  21:24:05  Hans_Graves
 * 	Add missing break in switch statement in SvRegisterCallback
 * 	[1996/05/07  21:19:50  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:56:46  Hans_Graves
 * 	Added HUFF_SUPPORT.  Remove NT warnings.
 * 	[1996/05/07  17:27:18  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/04/23  18:51:10  Karen_Dintino
 * 	Fix the memory alloc for the ref buffer for WIN32
 * 	[1996/04/23  18:49:23  Karen_Dintino]
 * 
 * Revision 1.1.6.11  1996/04/17  23:44:35  Karen_Dintino
 * 	added initializations for H.261/WIN32
 * 	[1996/04/17  23:43:20  Karen_Dintino]
 * 
 * Revision 1.1.6.10  1996/04/11  22:54:43  Karen_Dintino
 * 	added casting for in SetFrameRate
 * 	[1996/04/11  22:52:29  Karen_Dintino]
 * 
 * Revision 1.1.6.9  1996/04/11  14:14:14  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:09:53  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/10  21:48:09  Hans_Graves
 * 	Added SvGet/SetBoolean() functions.
 * 	[1996/04/10  21:28:13  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/09  20:50:44  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:26  Karen_Dintino]
 * 
 * Revision 1.1.6.6  1996/04/09  16:05:00  Hans_Graves
 * 	Add some abs() around height params. SvRegisterCallback() cleanup
 * 	[1996/04/09  15:39:31  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/04  23:35:27  Hans_Graves
 * 	Removed BI_YU16SEP support from MPEG decomp.
 * 	[1996/04/04  23:12:02  Hans_Graves]
 * 
 * 	Fixed up Multibuf size (MPEG) related stuff
 * 	[1996/04/04  23:08:55  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/01  15:17:47  Bjorn_Engberg
 * 	Got rid of a compiler warning.
 * 	[1996/04/01  15:02:35  Bjorn_Engberg]
 * 
 * Revision 1.1.6.3  1996/03/29  22:22:36  Hans_Graves
 * 	-Added JPEG_SUPPORT ifdefs.
 * 	-Changed JPEG related structures to fit naming conventions.
 * 	[1996/03/29  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/16  20:13:51  Karen_Dintino
 * 	Adding NT port changes for H.261
 * 	[1996/03/16  19:48:31  Karen_Dintino]
 * 
 * Revision 1.1.4.12  1996/02/26  18:42:32  Karen_Dintino
 * 	fix PTT 01106 server crash in ICCompress
 * 	[1996/02/26  18:41:33  Karen_Dintino]
 * 
 * Revision 1.1.4.11  1996/02/22  17:35:19  Bjorn_Engberg
 * 	Added support for JPEG Mono to BI_BITFIELDS 16 decompression on NT.
 * 	[1996/02/22  17:34:53  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/02/08  13:48:44  Bjorn_Engberg
 * 	Get rid of int to float compiler warning.
 * 	[1996/02/08  13:48:20  Bjorn_Engberg]
 * 
 * Revision 1.1.4.9  1996/02/07  23:24:08  Hans_Graves
 * 	MPEG Key frame stats initialization
 * 	[1996/02/07  23:14:41  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/02/06  22:54:17  Hans_Graves
 * 	Added SvGet/SetParam functions
 * 	[1996/02/06  22:51:19  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/01/08  20:19:33  Bjorn_Engberg
 * 	Got rid of more compiler warnings.
 * 	[1996/01/08  20:19:13  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1996/01/08  16:42:47  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:41:37  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/01/02  18:32:14  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused variables.
 * 	[1996/01/02  17:26:21  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:40:06  Bjorn_Engberg
 * 	IsSupported() sometimes returned garbage and thus a false match.
 * 	SvDecompressQuery() and SvCompressQuery() were using the
 * 	wrong lookup tables.
 * 	[1995/12/28  18:39:30  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/08  20:01:30  Hans_Graves
 * 	Added SvSetRate() and SvSetFrameRate() to H.261 compression open
 * 	[1995/12/08  19:58:32  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:32:17  Hans_Graves
 * 	Added MPEG I & II Encoding support
 * 	[1995/12/07  18:43:45  Hans_Graves]
 * 
 * Revision 1.1.2.46  1995/11/30  20:17:06  Hans_Graves
 * 	Added BI_DECGRAYDIB handling for JPEG decompression, used with Mono JPEG
 * 	[1995/11/30  20:12:24  Hans_Graves]
 * 
 * Revision 1.1.2.45  1995/11/29  17:53:26  Hans_Graves
 * 	Added JPEG_DIB 8-bit to BI_DECGRAYDIB as supported format
 * 	[1995/11/29  17:53:00  Hans_Graves]
 * 
 * Revision 1.1.2.44  1995/11/28  22:47:33  Hans_Graves
 * 	Added BI_BITFIELDS as supported decompression format for H261 and MPEG
 * 	[1995/11/28  22:39:25  Hans_Graves]
 * 
 * Revision 1.1.2.43  1995/11/17  21:31:28  Hans_Graves
 * 	Added checks on ImageSize in SvDecompress()
 * 	[1995/11/17  21:27:19  Hans_Graves]
 * 
 * 	Query cleanup - Added lookup tables for supportted formats
 * 	[1995/11/17  20:53:54  Hans_Graves]
 * 
 * Revision 1.1.2.42  1995/11/03  16:36:25  Paul_Gauthier
 * 	Reject requests to scale MPEG input during decompression
 * 	[1995/11/03  16:34:01  Paul_Gauthier]
 * 
 * Revision 1.1.2.41  1995/10/25  18:19:22  Bjorn_Engberg
 * 	What was allocated with ScPaMalloc() must be freed with ScPaFree().
 * 	[1995/10/25  18:02:04  Bjorn_Engberg]
 * 
 * Revision 1.1.2.40  1995/10/25  17:38:04  Hans_Graves
 * 	Removed some memory freeing calls on image memory in SvCloseCodec for H261 decoding.  The app allocates the image buffer.
 * 	[1995/10/25  17:37:35  Hans_Graves]
 * 
 * Revision 1.1.2.39  1995/10/13  16:57:19  Bjorn_Engberg
 * 	Added a cast to get rid of a compiler warning.
 * 	[1995/10/13  16:56:29  Bjorn_Engberg]
 * 
 * Revision 1.1.2.38  1995/10/06  20:51:47  Farokh_Morshed
 * 	Enhance to handle BI_BITFIELDS for input to compression
 * 	[1995/10/06  20:49:10  Farokh_Morshed]
 * 
 * Revision 1.1.2.37  1995/10/02  19:31:03  Bjorn_Engberg
 * 	Clarified what formats are supported and not.
 * 	[1995/10/02  18:51:49  Bjorn_Engberg]
 * 
 * Revision 1.1.2.36  1995/09/28  20:40:09  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:39:45  Farokh_Morshed]
 * 
 * Revision 1.1.2.35  1995/09/26  17:49:47  Paul_Gauthier
 * 	Fix H.261 output conversion to interleaved YUV
 * 	[1995/09/26  17:49:20  Paul_Gauthier]
 * 
 * Revision 1.1.2.34  1995/09/26  15:58:44  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:16  Paul_Gauthier]
 * 
 * Revision 1.1.2.33  1995/09/25  21:18:14  Paul_Gauthier
 * 	Added interleaved YUV output to decompression
 * 	[1995/09/25  21:17:42  Paul_Gauthier]
 * 
 * Revision 1.1.2.32  1995/09/22  12:58:50  Bjorn_Engberg
 * 	More NT porting work; Added MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:26:14  Bjorn_Engberg]
 * 
 * Revision 1.1.2.31  1995/09/20  19:35:02  Hans_Graves
 * 	Cleaned-up debugging statements
 * 	[1995/09/20  19:33:07  Hans_Graves]
 * 
 * Revision 1.1.2.30  1995/09/20  18:22:53  Karen_Dintino
 * 	Free temp buffer after convert
 * 	[1995/09/20  18:22:37  Karen_Dintino]
 * 
 * Revision 1.1.2.29  1995/09/20  17:39:22  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.27 **}
 * 		{** Merge revision:	1.1.2.28 **}
 * 	{** End **}
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:41  Karen_Dintino]
 * 
 * Revision 1.1.2.28  1995/09/20  15:00:03  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:43:15  Bjorn_Engberg]
 * 
 * Revision 1.1.2.27  1995/09/13  19:42:44  Paul_Gauthier
 * 	Added TGA2 support (direct 422 interleaved output from JPEG codec
 * 	[1995/09/13  19:15:47  Paul_Gauthier]
 * 
 * Revision 1.1.2.26  1995/09/11  18:53:45  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.24 **}
 * 		{** Merge revision:	1.1.2.25 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:52:08  Farokh_Morshed]
 * 
 * Revision 1.1.2.25  1995/09/05  14:05:01  Paul_Gauthier
 * 	Add ICMODE_OLDQ flag on ICOpen for softjpeg to use old quant tables
 * 	[1995/08/31  20:58:06  Paul_Gauthier]
 * 
 * Revision 1.1.2.24  1995/08/16  19:56:46  Hans_Graves
 * 	Fixed RELEASE_BUFFER callbacks for Images
 * 	[1995/08/16  19:54:40  Hans_Graves]
 * 
 * Revision 1.1.2.23  1995/08/15  19:14:18  Karen_Dintino
 * 	pass H261 struct to inithuff & freehuff
 * 	[1995/08/15  19:10:58  Karen_Dintino]
 * 
 * Revision 1.1.2.22  1995/08/14  19:40:36  Hans_Graves
 * 	Add CB_CODEC_DONE callback. Fixed Memory allocation and freeing under H261.
 * 	[1995/08/14  18:45:22  Hans_Graves]
 * 
 * Revision 1.1.2.21  1995/08/04  17:22:49  Hans_Graves
 * 	Make END_SEQ callback happen after any H261 decompress error.
 * 	[1995/08/04  17:20:55  Hans_Graves]
 * 
 * Revision 1.1.2.20  1995/08/04  16:32:46  Karen_Dintino
 * 	Free Huffman codes on end of Encode and Decode
 * 	[1995/08/04  16:25:59  Karen_Dintino]
 * 
 * Revision 1.1.2.19  1995/07/31  21:11:14  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.17 **}
 * 		{** Merge revision:	1.1.2.18 **}
 * 	{** End **}
 * 	Add 411YUVSEP Support
 * 	[1995/07/31  20:41:28  Karen_Dintino]
 * 
 * Revision 1.1.2.18  1995/07/31  20:19:58  Hans_Graves
 * 	Set Format parameter in Frame callbacks
 * 	[1995/07/31  20:16:06  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/07/28  20:58:40  Hans_Graves
 * 	Added Queue debugging messages.
 * 	[1995/07/28  20:49:15  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/07/28  17:36:10  Hans_Graves
 * 	Fixed up H261 Compression and Decompression.
 * 	[1995/07/28  17:26:17  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/07/27  18:28:55  Hans_Graves
 * 	Fixed AddBuffer() so it works with H261.
 * 	[1995/07/27  18:24:37  Hans_Graves]
 * 
 * Revision 1.1.2.14  1995/07/26  17:49:04  Hans_Graves
 * 	Fixed SvCompressBegin() JPEG initialization.  Added ImageQ support.
 * 	[1995/07/26  17:41:24  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/07/25  22:00:33  Hans_Graves
 * 	     Fixed H261 image size logic in SvCompressQuery().
 * 	     [1995/07/25  21:59:08  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:20  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:26:11  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/18  17:26:56  Hans_Graves
 * 	Fixed QCIF width parameter checking.
 * 	[1995/07/18  17:24:55  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/17  22:01:45  Hans_Graves
 * 	Removed defines for CIF_WIDTH, CIF_HEIGHT, etc.
 * 	[1995/07/17  21:48:51  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/17  16:12:37  Hans_Graves
 * 	H261 Cleanup.
 * 	[1995/07/17  15:50:51  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/12  19:48:30  Hans_Graves
 * 	Fixed up some H261 Queue/Callback bugs.
 * 	[1995/07/12  19:31:51  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/11  22:12:00  Karen_Dintino
 * 	Add SvCompressQuery, SvDecompressQuery support
 * 	[1995/07/11  21:57:21  Karen_Dintino]
 * 
 * Revision 1.1.2.6  1995/07/01  18:43:49  Karen_Dintino
 * 	Add support for H.261 Decompress
 * 	[1995/07/01  18:26:18  Karen_Dintino]
 * 
 * Revision 1.1.2.5  1995/06/19  20:31:51  Karen_Dintino
 * 	Adding support for H.261 Codec
 * 	[1995/06/19  19:25:27  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:34  Hans_Graves
 * 	Added SvGetInputBitstream(). Changed SvDecompressBegin() to handle NULL Image formats.
 * 	[1995/06/09  16:35:29  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/05  21:07:20  Hans_Graves
 * 	Fixed logic in SvRegisterCallback().
 * 	[1995/06/05  20:04:30  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:12:42  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:18:53  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/02/02  19:26:01  Paul_Gauthier
 * 	Fix to blank bottom strip & server crash for softjpeg compress
 * 	[1995/02/02  19:12:58  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/01/20  21:45:57  Jim_Ludwig
 * 	Add support for 16 bit YUV
 * 	[1995/01/20  21:28:49  Jim_Ludwig]
 * 
 * Revision 1.1.2.8  1994/12/12  15:38:54  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:34:21  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/11/18  18:48:36  Paul_Gauthier
 * 	Cleanup & bug fixes
 * 	[1994/11/18  18:44:02  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/10/28  19:56:30  Paul_Gauthier
 * 	Additional Clean Up
 * 	[1994/10/28  19:54:35  Paul_Gauthier]
 * 
 * Revision 1.1.2.5  1994/10/17  19:03:28  Paul_Gauthier
 * 	Fixed reversed Quality scale
 * 	[1994/10/17  19:02:50  Paul_Gauthier]
 * 
 * Revision 1.1.2.4  1994/10/13  20:34:27  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/13  20:23:23  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/10  21:45:50  Tom_Morris
 * 	Rename Status to not conflict with X11
 * 	[1994/10/10  21:44:16  Tom_Morris]
 * 
 * Revision 1.1.2.2  1994/10/07  14:39:25  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:53:40  Paul_Gauthier]
 * 
 * 	******************************************************************
 * 	Changes from original brance merged into this file 11/30/94 PSG
 * 	******************************************************************
 * 	Revision 1.1.2.10  1994/08/11  21:27:24  Leela_Obilichetti
 * 	Added in width and height checks into SvDecompressQuery and SvCompressQuery.
 * 	[1994/08/11  21:03:38  Leela_Obilichetti]
 * 
 * Revision 1.1.2.9  1994/08/09  18:52:40  Ken_Chiquoine
 * 	set mode type in decode as well as encode
 * 	[1994/08/09  18:52:17  Ken_Chiquoine]
 * 
 * Revision 1.1.2.8  1994/08/04  22:06:33  Leela_Obilichetti
 * 	oops, removed fprintf.
 * 	[1994/08/04  21:54:11  Leela_Obilichetti]
 * 
 * Revision 1.1.2.7  1994/08/04  21:34:04  Leela_Obilichetti
 * 	v1 drop.
 * 	[1994/08/04  21:05:01  Leela_Obilichetti]
 * 
 * Revision 1.1.2.6  1994/07/15  23:31:43  Leela_Obilichetti
 * 	added new stuff for compression - v4 of SLIB.
 * 	[1994/07/15  23:29:17  Leela_Obilichetti]
 * 
 * Revision 1.1.2.5  1994/06/08  16:44:28  Leela_Obilichetti
 * 	fixes for YUV_to_RGB for OSF/1.  Haven't tested on Microsoft.
 * 	[1994/06/08  16:42:46  Leela_Obilichetti]
 * 
 * Revision 1.1.2.4  1994/06/03  21:11:14  Leela_Obilichetti
 * 	commment out the code to let in DECYUVDIB
 * 	free memory that is allocated for YUV
 * 	add in code to convert from DECSEPYUV to DECYUV -
 * 		shouldn't get there since se don't allow YUV anymore
 * 	[1994/06/03  21:03:42  Leela_Obilichetti]
 * 
 * Revision 1.1.2.3  1994/05/11  21:02:17  Leela_Obilichetti
 * 	bug fix for NT
 * 	[1994/05/11  20:56:16  Leela_Obilichetti]
 * 
 * Revision 1.1.2.2  1994/05/09  22:06:07  Leela_Obilichetti
 * 	V3 drop
 * 	[1994/05/09  21:51:30  Leela_Obilichetti]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*-------------------------------------------------------------------------
 * Modification History: sv_api.c
 *
 *      08-Sep-94  PSG   Added MPEG decode support
 *	29-Jul-94  VB    Added restrictions for compression
 *      21-Jul-94  VB	 Rewrote/cleaned up sections of JPEG decompression
 *      13-Jul-94  PSG   Added support for encode/decode of grayscale only
 *      07-Jul-94  PSG   Converted to single Info structure (cmp/dcmp)
 *	14-Jun-94  VB	 Added JPEG compression support
 *      08-Jun-94  PSG   Added support for BI_DECXIMAGEDIB (B,G,R,0)
 *      06-Jun-94  PSG   Bring code up to SLIB v0.04 spec
 *	15-Apr-94  VB	 Added support for 24-bit,16-bit and 15-bit RGB output 
 *      24-Feb-94  PSG   Bring code up to SLIB v0.02 spec
 *      20-Jan-94  PSG   added a number of new SLIB routines
 *	12-Jan-94  VB    Created (from SLIB spec.) 
 *	
 *   Author(s):
 *	 VB - Victor Bahl
 *	PSG - Paul Gauthier
 --------------------------------------------------------------------------*/


/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "SV.h"
#include "sv_intrn.h"
#ifdef JPEG_SUPPORT
/*
 *  More JPEG code needs to be moved to sv_jpeg_init file
 */
#include "sv_jpeg_tables.h"
#endif /* JPEG_SUPPORT */
#include "sv_proto.h"
#include "SC.h"
#include "SC_conv.h"
#include "SC_err.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#endif

static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo);

typedef struct SupportList_s {
  int   InFormat;   /* Input format */
  int   InBits;     /* Input number of bits */
  int   OutFormat;  /* Output format */
  int   OutBits;    /* Output number of bits */
} SupportList_t;

/*
** Input & Output Formats supported by SLIB Compression
*/
static SupportList_t _SvCompressionSupport[] = {
  BI_DECYUVDIB,        16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_DECYUVDIB,        16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,             8, /* YUV 4:2:2 Packed */
  BI_S422,             16, JPEG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_S422,             16, MJPG_DIB,            24, /* YUV 4:2:2 Packed */
  BI_BITFIELDS,        32, JPEG_DIB,             8, /* BITFIELDS */
  BI_BITFIELDS,        32, JPEG_DIB,            24, /* BITFIELDS */
  BI_BITFIELDS,        32, MJPG_DIB,            24, /* BITFIELDS */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,             8, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, JPEG_DIB,            24, /* RGB 32 Planar */
  BI_DECSEPRGBDIB,     32, MJPG_DIB,            24, /* RGB 32 Planar */
#ifdef WIN32
  BI_RGB,              24, JPEG_DIB,             8, /* RGB 24 */
  BI_RGB,              24, JPEG_DIB,            24, /* RGB 24 */
  BI_RGB,              24, MJPG_DIB,            24, /* RGB 24 */
  BI_RGB,              32, JPEG_DIB,             8, /* RGB 32 */
  BI_RGB,              32, JPEG_DIB,            24, /* RGB 32 */
  BI_RGB,              32, MJPG_DIB,            24, /* RGB 32 */
#endif /* WIN32 */
#ifndef WIN32
  BI_DECGRAYDIB,        8, JPEG_DIB,             8, /* Gray 8 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,             8, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, JPEG_DIB,            24, /* XIMAGE 24 */
  BI_DECXIMAGEDIB,     24, MJPG_DIB,            24, /* XIMAGE 24 */
#endif /* !WIN32 */
#ifdef H261_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH261DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH261DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH261DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECYUVDIB,        16, BI_DECH263DIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECH263DIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECH263DIB,       24, /* YUV 4:2:2 Planar */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECYUVDIB,        16, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECMPEGDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECMPEGDIB,       24, /* YUV 4:2:2 Planar */
  BI_YVU9SEP,          24, BI_DECMPEGDIB,       24, /* YUV 16:1:1 Planar */
  BI_RGB,              24, BI_DECMPEGDIB,       24, /* RGB 24 */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECYUVDIB,        16, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_DECSEPYUV411DIB,  24, BI_DECHUFFDIB,       24, /* YUV 4:1:1 Planar */
  BI_YU16SEP,          24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
  BI_DECSEPYUVDIB,     24, BI_DECHUFFDIB,       24, /* YUV 4:2:2 Planar */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Input & Output Formats supported by SLIB Decompression
*/
static SupportList_t _SvDecompressionSupport[] = {
#ifdef JPEG_SUPPORT
  JPEG_DIB,             8, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_DECSEPYUVDIB,     24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  MJPG_DIB,            24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  JPEG_DIB,             8, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_DECYUVDIB,    16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  MJPG_DIB,            24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  JPEG_DIB,             8, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  MJPG_DIB,            24, BI_BITFIELDS,        32, /* BITFIELDS */
  JPEG_DIB,             8, BI_DECGRAYDIB,        8, /* Gray 8 */
#endif /* JPEG_SUPPORT */

#ifdef WIN32
  JPEG_DIB,             8, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  MJPG_DIB,            24, BI_RGB,              16, /* RGB 16 */
  JPEG_DIB,             8, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  MJPG_DIB,            24, BI_RGB,              24, /* RGB 24 */
  JPEG_DIB,             8, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  MJPG_DIB,            24, BI_RGB,              32, /* RGB 32 */
  JPEG_DIB,             8, BI_BITFIELDS,        16, /* BITFIELDS */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECH261DIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECH261DIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_RGB,              16, /* RGB 16 */
  BI_DECMPEGDIB,       24, BI_RGB,              24, /* RGB 24 */
  BI_DECMPEGDIB,       24, BI_RGB,              32, /* RGB 32 */
#endif /* MPEG_SUPPORT */
#endif /* WIN32 */

#ifndef WIN32
  JPEG_DIB,             8, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  JPEG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
  MJPG_DIB,            24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* H261_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_DECXIMAGEDIB,     24, /* XIMAGE 24 */
#endif /* MPEG_SUPPORT */
#endif /* !WIN32 */

#ifdef H261_SUPPORT
  BI_DECH261DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH261DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECH261DIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  BI_DECH263DIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECH263DIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECH263DIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
  BI_DECMPEGDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECMPEGDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  BI_DECMPEGDIB,       24, BI_YU16SEP,          24, /* YUV 4:2:2 Planar */
  BI_DECMPEGDIB,       24, BI_BITFIELDS,        32, /* BITFIELDS */
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
  BI_DECHUFFDIB,       24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECSEPYUV411DIB,  24, /* YUV 4:1:1 Planar */
  BI_DECHUFFDIB,       24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
#endif /* HUFF_SUPPORT */
  0, 0, 0, 0
};

/*
** Name: IsSupported
** Desc: Lookup the a given input and output format to see if it
**       exists in a SupportList.
** Note: If OutFormat==-1 and OutBits==-1 then only input format
**          is checked for support.
**       If InFormat==-1 and InBits==-1 then only output format
**          is checked for support.
** Return: NULL       Formats not supported.
**         not NULL   A pointer to the list entry.
*/
static SupportList_t *IsSupported(SupportList_t *list,
                                  int InFormat, int InBits,
                                  int OutFormat, int OutBits)
{
  if (OutFormat==-1 && OutBits==-1) /* Looking up only the Input format */
  {
    while (list->InFormat || list->InBits)
      if (list->InFormat == InFormat && list->InBits==InBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  if (InFormat==-1 && InBits==-1) /* Looking up only the Output format */
  {
    while (list->InFormat || list->InBits)
      if (list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  /* Looking up both Input and Output */
  while (list->InFormat || list->InBits)
    if (list->InFormat == InFormat && list->InBits==InBits &&
         list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
    else
      list++;
  return(NULL);
}

/*
** Name:     SvOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = i.e. SV_JPEG_ENCODE, SV_JPEG_DECODE, etc.
**           Svh = handle to software codec's Info structure.
*/
SvStatus_t SvOpenCodec (SvCodecType_e CodecType, SvHandle_t *Svh)
{
   SvCodecInfo_t *Info = NULL;
   _SlibDebug(_DEBUG_, printf("SvOpenCodec()\n") );

   /* check if CODEC is supported */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
     case SV_JPEG_ENCODE:
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_ENCODE:
     case SV_H261_DECODE:
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_ENCODE:
     case SV_H263_DECODE:
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_ENCODE:
     case SV_MPEG_DECODE:
     case SV_MPEG2_ENCODE:
     case SV_MPEG2_DECODE:
           break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
     case SV_HUFF_ENCODE:
     case SV_HUFF_DECODE:
           break;
#endif /* HUFF_SUPPORT */
     default:
           return(SvErrorCodecType);
   }
     
   if (!Svh)
     return (SvErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SvCodecInfo_t *) ScAlloc(sizeof(SvCodecInfo_t))) == NULL) 
       return (SvErrorMemory);
   memset (Info, 0, sizeof(SvCodecInfo_t));
   Info->BSIn=NULL;
   Info->BSOut=NULL;
   Info->mode = CodecType;
   Info->started = FALSE;

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch (CodecType)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            if ((Info->jdcmp = (SvJpegDecompressInfo_t *) 
	        ScAlloc(sizeof(SvJpegDecompressInfo_t))) == NULL) 
              return(SvErrorMemory);
            memset (Info->jdcmp, 0, sizeof(SvJpegDecompressInfo_t));
            break;

       case SV_JPEG_ENCODE:
            if ((Info->jcomp = (SvJpegCompressInfo_t *)
	                      ScAlloc(sizeof(SvJpegCompressInfo_t))) == NULL) 
              return (SvErrorMemory);
            memset (Info->jcomp, 0, sizeof(SvJpegCompressInfo_t));
            break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            if ((Info->mdcmp = (SvMpegDecompressInfo_t *)
                ScAlloc(sizeof(SvMpegDecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mdcmp, 0, sizeof(SvMpegDecompressInfo_t));
            Info->mdcmp->timecode0 = 0;
            Info->mdcmp->timecode_state = MPEG_TIMECODE_START;
            Info->mdcmp->timecodefps = 0.0F;
            Info->mdcmp->fps = 0.0F;
            Info->mdcmp->twostreams = 0;
            Info->mdcmp->verbose=FALSE;
            Info->mdcmp->quiet=TRUE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_MPEG_ENCODE:
       case SV_MPEG2_ENCODE:
            if ((Info->mcomp = (SvMpegCompressInfo_t *)
                ScAlloc(sizeof(SvMpegCompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->mcomp, 0, sizeof(SvMpegCompressInfo_t));
            Info->mcomp->quiet=1;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTENCODE, FALSE);
            SvSetParamBoolean((SvHandle_t)Info, SV_PARAM_FASTDECODE, FALSE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS,
                                               PARAM_ALGFLAG_HALFPEL);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 1152000);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)25.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 12);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_SUBKEYSPACING, 4);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H261_ENCODE:
            if ((Info->h261 = (SvH261Info_t *)
                  ScAlloc(sizeof(SvH261Info_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h261, 0, sizeof(SvH261Info_t));
            Info->h261->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 100);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, ME_BRUTE);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONSEARCH, 5);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONTHRESH, 600);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 352000);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10); /* for VBR */
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)15.0);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            if ((Info->h263dcmp = (SvH263DecompressInfo_t *)
                  ScAlloc(sizeof(SvH263DecompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263dcmp, 0, sizeof(SvH263DecompressInfo_t));
            Info->h263dcmp->inited=FALSE;
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
       case SV_H263_ENCODE:
            if ((Info->h263comp = (SvH263CompressInfo_t *)
                  ScAlloc(sizeof(SvH263CompressInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->h263comp, 0, sizeof(SvH263CompressInfo_t));
            Info->h263comp->inited=FALSE;
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_MOTIONALG, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_BITRATE, 0);
            SvSetParamFloat((SvHandle_t)Info, SV_PARAM_FPS, (float)30.0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_ALGFLAGS, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_PACKETSIZE, 512);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTI, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUANTP, 10);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_QUALITY, 0);
            SvSetParamInt((SvHandle_t)Info, SV_PARAM_KEYSPACING, 120);
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
       case SV_HUFF_ENCODE:
            if ((Info->huff = (SvHuffInfo_t *)
                  ScAlloc(sizeof(SvHuffInfo_t))) == NULL)
              return(SvErrorMemory);
            memset (Info->huff, 0, sizeof(SvHuffInfo_t));
            ScBufQueueCreate(&Info->BufQ);
            ScBufQueueCreate(&Info->ImageQ);
            break;
#endif /* HUFF_SUPPORT */
   }
   *Svh = (SvHandle_t) Info;        /* Return handle */
   _SlibDebug(_DEBUG_, printf("SvOpenCodec() returns Svh=%p\n", *Svh) );

   return(NoErrors);
}




/*
** Name:     SvCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - needs to change since now we have compression also, i.e.
**       Svh should be handle to the CodecInfo structure.  (VB)
*/
SvStatus_t SvCloseCodec (SvHandle_t Svh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);
   if (Info->BufQ);
     ScBufQueueDestroy(Info->BufQ);
   if (Info->ImageQ);
     ScBufQueueDestroy(Info->ImageQ);

   switch (Info->mode) /* free all associated codec memory */
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE:
           {
             int i;
             for (i = 0; i < 4; i++) {
               if (Info->jdcmp->DcHt[i])
                 ScPaFree(Info->jdcmp->DcHt[i]);
               if (Info->jdcmp->AcHt[i])
                 ScPaFree(Info->jdcmp->AcHt[i]);
             }
             if (Info->jdcmp->compinfo)
               ScFree(Info->jdcmp->compinfo);
             if (Info->jdcmp) {
               if (Info->jdcmp->TempImage)
	         ScPaFree(Info->jdcmp->TempImage);
               if (Info->jdcmp->_SvBlockPtr)
	         ScFree(Info->jdcmp->_SvBlockPtr);
               ScFree(Info->jdcmp);
             }
           }
           break;

      case SV_JPEG_ENCODE:
           {
             int i;
             for (i = 0 ; i < Info->jcomp->NumComponents ; i++) 
               if (Info->jcomp->Qt[i])
                 ScPaFree(Info->jcomp->Qt[i]);
             for (i = 0; i < 4; i++) {
               if (Info->jcomp->DcHt[i])
                 ScPaFree(Info->jcomp->DcHt[i]);
               if (Info->jcomp->AcHt[i])
                 ScPaFree(Info->jcomp->AcHt[i]);
             }
             if (Info->jcomp->compinfo)
               ScFree(Info->jcomp->compinfo);
             if (Info->jcomp) {
               if (Info->jcomp->BlkBuffer)
	         ScPaFree(Info->jcomp->BlkBuffer);
               if (Info->jcomp->BlkTable)
	         ScPaFree(Info->jcomp->BlkTable);
               ScFree(Info->jcomp);
             }
           }
           break;
#endif /* JPEG_SUPPORT */

#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
           if (Info->h261)
           {
             svH261CompressFree(Info);
             ScFree(Info->h261);
           }
           break;
     case SV_H261_DECODE:
           if (Info->h261)
           {
             svH261DecompressFree(Info);
             ScFree(Info->h261);
           }
           break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           if (Info->h263dcmp)
           {
             svH263FreeDecompressor(Info);
             ScFree(Info->h263dcmp);
           }
           break;
     case SV_H263_ENCODE:
           if (Info->h263comp)
           {
             svH263FreeCompressor(Info);
             ScFree(Info->h263comp);
           }
           break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
           if (Info->mdcmp) {
             sv_MpegFreeDecoder(Info);
             ScFree(Info->mdcmp);
           }
           break;
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
           if (Info->mcomp) {
             ScFree(Info->mcomp);
           }
           break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_DECODE:
      case SV_HUFF_ENCODE:
           if (Info->huff) {
             sv_HuffFreeDecoder(Info);
             ScFree(Info->huff);
           }
           break;
           break;
#endif /* HUFF_SUPPORT */
   }

   /*
   ** Free Info structure
   */
   ScFree(Info);
   
   return(NoErrors);
}




/*
** Name:     SvDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SvOpenCodec &
**           before SvDecompress (SvDecompress will call SvDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvDecompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvDecompressBegin()\n") );

   if (!Info)
     return(SvErrorCodecHandle);
   if (Info->started)
     return(SvErrorNone);
   /* if no Image header provided, use previous headers */
   if (!ImgIn)
     ImgIn = &Info->InputFormat;
   if (!ImgOut)
     ImgOut = &Info->OutputFormat;
   stat=SvDecompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->InputFormat.biWidth;
   Info->Height = abs(Info->InputFormat.biHeight);
      
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
       case SV_JPEG_DECODE:
            {
              SvJpegDecompressInfo_t *DInfo;
              /*
              ** Load the default Huffman tablse
              */
              stat = sv_LoadDefaultHTable (Info);
              RETURN_ON_ERROR (stat);

              stat = sv_InitJpegDecoder (Info);
              RETURN_ON_ERROR (stat);

              /*
              ** Video-specific information will be filled in during processing
              ** of first frame
              */
              DInfo = Info->jdcmp;
              DInfo->InfoFilled = 0;
              DInfo->ReInit     = 1;
              DInfo->DecompressStarted = TRUE;
              DInfo->TempImage = NULL; 
              break;
            }
#endif

#ifdef MPEG_SUPPORT
       case SV_MPEG_DECODE:
       case SV_MPEG2_DECODE:
            Info->mdcmp->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_MpegInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
       case SV_H261_DECODE:
            stat = svH261Init(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
       case SV_H263_DECODE:
            stat = svH263InitDecompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
       case SV_HUFF_DECODE:
            Info->huff->DecompressStarted = TRUE;
            /* the default data source is the buffer queue */
            if (Info->BSIn)
              ScBSReset(Info->BSIn);
            else
              stat=SvSetDataSource (Svh, SV_USE_BUFFER_QUEUE, 0, NULL, 0);
            RETURN_ON_ERROR (stat);
            stat = sv_HuffInitDecoder(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */
   }
   Info->started=TRUE;
   return (NoErrors);
}



/*
** Name:     SvGetDecompressSize
** Purpose:  Return minimum data buffer size to receive decompressed data
**           for current settings on codec
**
** Args:     Svh = handle to software codec's Info structure.
**           MinSize = Returns minimum buffer size required
*/
SvStatus_t SvGetDecompressSize (SvHandle_t Svh, int *MinSize)
{
   int pixels,lines;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode) /* check that decompressor was started */
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           if (!Info->jdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           if (!Info->mdcmp->DecompressStarted) 
             return(SvErrorDcmpNotStarted);
           break;
#endif /* MPEG_SUPPORT */
     default:
           break;
   }

   if (!MinSize)
     return(SvErrorBadPointer);

   pixels = Info->OutputFormat.biWidth;
   lines  = Info->OutputFormat.biHeight;
   if (lines < 0) lines = -lines;
   _SlibDebug(_VERBOSE_, 
              printf("OutputFormat.biWidth=%d OutputFormat.biHeight=%d\n",
                      pixels, lines) );

   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
           /*
           ** On output, accept: 8, 16 or 24 bit uncompressed RGB
           ** or YUV formats, 32 bit uncompressed RGB
           */
           if (Info->OutputFormat.biBitCount == 8) 
             *MinSize = pixels * lines;
           else if (Info->OutputFormat.biBitCount == 24) {
             if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 3 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECSEPRGBDIB) 
	       *MinSize = 3 * pixels * lines;
             else if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_DECXIMAGEDIB) 
	       *MinSize = 4 * pixels * lines;
             else if (IsYUV422Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (IsYUV411Sep(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else
	     return(SvErrorUnrecognizedFormat);
           }
           else if (Info->OutputFormat.biBitCount == 16) {
             if (IsYUV422Packed(Info->OutputFormat.biCompression)) 
	       *MinSize = 2 * pixels * lines;
             else if (Info->OutputFormat.biCompression == BI_RGB)
	       *MinSize = 2 * pixels * lines;
           }
           else if (Info->OutputFormat.biBitCount == 32) {
             if (Info->OutputFormat.biCompression == BI_RGB ||
               Info->OutputFormat.biCompression == BI_BITFIELDS)
	       *MinSize = 4 * pixels * lines;
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
           /*
           ** MPEG multibuffer size = 3 pictures*(1Y + 1/4 U + 1/4 V)*imagesize
           */
           if (IsYUV422Sep(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)) ||
               IsYUV422Packed(SvGetParamInt(Svh, SV_PARAM_FINALFORMAT)))
             *MinSize = 3 * pixels * lines * 2;  /* 4:2:2 */
           else
             *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
     case SV_H261_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
     case SV_H263_DECODE:
           *MinSize = 3 * (pixels * lines * 3)/2;  /* 4:1:1 */
           break;
#endif /* H263_SUPPORT */
     default:
           return(SvErrorUnrecognizedFormat);
   }
   return(NoErrors);
}



/*
** Name:     SvDecompressQuery
** Purpose:  Determine if Codec can decompress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvDecompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                              BITMAPINFOHEADER *ImgOut)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!ImgIn && !ImgOut)
    return(SvErrorBadPointer);

  if (!IsSupported(_SvDecompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
    return(SvErrorUnrecognizedFormat);
	 
  if (ImgOut) /* Query output format */
  {
    /*
    ** XXX - check to see if the # of output lines/# of output
    **       pixels/line are a multiple of 8. If not can't decompress
    **	    Note: This is an artifical restriction since the JPEG
    **	          bitream will always be a multiple of 8x8, so we
    **		  should have no problems decoding, only on the
    **		  output will be have to add an extra copy operation
    **	    XXX - will address/remove this restriction in the 
    **		  later release  (VB)
    */ 
    if (ImgOut->biWidth  <= 0 || ImgOut->biHeight == 0)
      return(SvErrorBadImageSize);
    switch (Info->mode)
    {
#ifdef JPEG_SUPPORT
      case SV_JPEG_DECODE: /* 8x8 restriction */
            if ((ImgOut->biWidth%8) || (ImgOut->biHeight%8)) 
              return(SvErrorBadImageSize);
            break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
      case SV_MPEG_DECODE:
      case SV_MPEG2_DECODE:
            /* MPEG 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16)) 
              return(SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_DECODE:
            /* H261 16x16 - because of Software Renderer YUV limitation */
            if ((ImgOut->biWidth%16) || (ImgOut->biHeight%16))
              return(SvErrorBadImageSize);
            if ((ImgOut->biWidth!=CIF_WIDTH && ImgOut->biWidth!=QCIF_WIDTH) ||
                (abs(ImgOut->biHeight)!=CIF_HEIGHT && abs(ImgOut->biHeight)!=QCIF_HEIGHT))
              return (SvErrorBadImageSize);
            /* Reject requests to scale during decompression - renderer's job */
            if (ImgIn && ImgOut &&
                (ImgIn->biWidth  != ImgOut->biWidth) ||
                (abs(ImgIn->biHeight) != abs(ImgOut->biHeight)))
              return (SvErrorBadImageSize);
            break;
#endif /* H261_SUPPORT */
      default:
            break;
    }

    if (ImgOut->biCompression == BI_BITFIELDS && 
         ValidateBI_BITFIELDS(ImgOut) == InvalidBI_BITFIELDS)
            return (SvErrorUnrecognizedFormat);
  }

  if (ImgIn) /* Query input format also */
  {
    if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
      return(SvErrorBadImageSize);
  }
  return(NoErrors);
}

/*
** Name:     SvDecompress
** Purpose:  Decompress a frame CompData -> YUV or RGB
**
** Args:     Svh          = handle to software codec's Info structure.
**           Data         = For JPEG points to compressed data (INPUT)
**                          For MPEG & H261, points to MultiBuf
**           MaxDataSize  = Length of Data buffer
**           Image        = buffer for decompressed data (OUTPUT)
**           MaxImageSize = Size of output image buffer
**
*/
SvStatus_t SvDecompress(SvHandle_t Svh, u_char *Data, int MaxDataSize,
			 u_char *Image, int MaxImageSize)
{
  int stat=NoErrors, UsedQ=FALSE, ImageSize;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  u_char *YData=NULL, *CbData=NULL, *CrData=NULL;
  int pixels, lines;
  SvCallbackInfo_t CB;
  u_char *ReturnImage=NULL;
  _SlibDebug(_VERBOSE_, printf("SvDecompress() In\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);
  if (!Data && !Info->BSIn)
    return(SvErrorBadPointer);

  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
      _SlibDebug(_VERBOSE_, printf("SvDecompress() Got Image %p from Q\n",
                            Image) );
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      _SlibDebug(_VERBOSE_,
                 printf("SvDecompress() Calling callback for Image\n") );
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &MaxImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
        _SlibDebug(_VERBOSE_,
                   printf("SvDecompress() Got Image %p from Q\n", Image) );
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (!Image)
    return(SvErrorNoImageBuffer);
  ImageSize=MaxImageSize;
  pixels = Info->OutputFormat.biWidth;
  lines  = Info->OutputFormat.biHeight;
  if (lines<0) lines=-lines;

  /*
  ** Decompress an image
  */
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
        {
          SvMpegDecompressInfo_t *MDInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_MPEG_DECODE\n") );

          if (!(MDInfo = Info->mdcmp))
            return(SvErrorBadPointer);

          if (!MDInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          if (MaxDataSize < MDInfo->finalbufsize)
            return(SvErrorSmallBuffer);

          if (!Data)
            return(SvErrorBadPointer);

          stat = sv_MpegDecompressFrame(Info, Data, &ReturnImage);
          RETURN_ON_ERROR(stat);
          /*
          ** Because the ReturnImage is a pointer into Data
          ** we need to copy it (do a format conversion if necessary).
          */
          switch (Info->OutputFormat.biCompression)
          {
            case BI_YU12SEP:
                 /* native format is 4:1:1 planar, just copy */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 memcpy(Image, ReturnImage, ImageSize);
                 break;
            case BI_DECYUVDIB:
            case BI_YUY2:
            case BI_S422: /* 4:1:1 planar -> 4:2:2 interleaved */
                 ImageSize=(3 * lines * pixels)/2;
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 ScSepYUVto422i(Image, Image+(lines*pixels), 
                                       Image+(lines*pixels*5)/4, 
	                               ReturnImage, pixels, lines);
                 break;
            default: /* 4:1:1 planar -> RGB */
                 if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                   ImageSize=lines*pixels *
                             (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                 else
                   ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                 if (ImageSize > MaxImageSize)
                   return(SvErrorSmallBuffer);
                 YData  = ReturnImage;
                 CbData = YData + (pixels * lines);
                 CrData = CbData + (pixels * lines)/4;
                 ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                 break;
          }
        }
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
    case SV_H261_DECODE:
        {
          SvH261Info_t *H261 = Info->h261;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H261)
            return(SvErrorBadPointer);
          if (!Data)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("sv_DecompressH261(Data=%p)\n",Data) );
          stat=svH261Decompress(Info, Data, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
          SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_H261_DECODE\n") );
          if (!H263Info)
            return(SvErrorBadPointer);
          _SlibDebug(_DEBUG_, printf("svH263Decompress(Data=%p)\n",Data) );
          stat=svH263Decompress(Info, &ReturnImage);
          if (stat==NoErrors)
          {
            /*
            ** Because the ReturnImage is a pointer into Data
            ** we need to copy it (do a format conversion if necessary).
            */
            switch (Info->OutputFormat.biCompression)
            {
              case BI_YU12SEP:
                   /* native format is 4:1:1 planar, just copy */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   memcpy(Image, ReturnImage, ImageSize);
                   break;
              case BI_DECYUVDIB:
              case BI_YUY2:
              case BI_S422:
                   /* 4:1:1 planar -> 4:2:2 interleaved */
                   ImageSize=(3 * lines * pixels)/2;
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   ScSepYUVto422i(Image, Image+(lines*pixels), 
                                         Image+(lines*pixels*5)/4,
	                                 ReturnImage, pixels, lines);
                   break;
              default:
                   if (Info->OutputFormat.biCompression==BI_DECXIMAGEDIB)
                     ImageSize=lines*pixels *
                               (Info->OutputFormat.biBitCount==24 ? 4 : 1);
                   else
                     ImageSize=lines*pixels * (Info->OutputFormat.biBitCount/8);
                   if (ImageSize > MaxImageSize)
                     return(SvErrorSmallBuffer);
                   YData  = ReturnImage;
                   CbData = YData  + (pixels * lines * sizeof(u_char));
                   CrData = CbData + ((pixels * lines * sizeof(u_char))/4);
                   ScYuv411ToRgb(&Info->OutputFormat, YData, CbData, CrData,
                                 Image, pixels, lines, pixels);
                   break;
            }
          }
          else
          {
            ImageSize=0;
            if (Info->CallbackFunction)
            {
              CB.Message = CB_SEQ_END;
              CB.Data = NULL;
              CB.DataSize = 0;
              CB.DataType = CB_DATA_NONE;
              CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
              CB.Action  = CB_ACTION_CONTINUE;
              (*Info->CallbackFunction)(Svh, &CB, NULL);
              _SlibDebug(_DEBUG_, 
                   printf("H263 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                                        CB.Data, CB.Action) );
              if (CB.Action == CB_ACTION_END)
                return (ScErrorClientEnd);
            }
          }
        }
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SV_JPEG_DECODE:
        {
        SvJpegDecompressInfo_t *DInfo;
        register int i;
        JPEGINFOHEADER *jpegbm;
        int maxMcu;
        EXBMINFOHEADER * exbi;
        _SlibDebug(_DEBUG_, printf("SvDecompress() SV_JPEG_DECODE\n") );

        if (!(DInfo = Info->jdcmp))
          return(SvErrorBadPointer);

        exbi = (EXBMINFOHEADER *)&Info->InputFormat;

        jpegbm = (JPEGINFOHEADER *)(
                (unsigned long)exbi + exbi->biExtDataOffset);
 	
        /*
        ** In case the application forgot to call SvDecompressBegin().
        */
        if (!DInfo->DecompressStarted)
          return(SvErrorDcmpNotStarted);
        /*
        ** If desired output is not separate YUV components, we have to 
        ** convert from Sep. YUV to desired format. Create intermediate image.
        */
        _SlibDebug(_DEBUG_, printf ("JPEGBitsPerSample %d \n",
                            jpegbm->JPEGBitsPerSample) );

        if (lines < 0) lines = -lines;
        _SlibDebug(_DEBUG_, 
           printf ("JPEG_RGB : %d - ", JPEG_RGB);
           if (jpegbm->JPEGColorSpaceID == JPEG_RGB) 
             printf ("Color Space is RGB \n");
           else
             printf ("Color Space is %d \n", jpegbm->JPEGColorSpaceID) );

        if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
            !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
        {
          /*
          ** should be done only once for each instance of the CODEC.
          **    - Note: this forces us to check the size parameters (pixels &
          **            lines)  for  each  image  to be decompressed. Should we
          **	    support sequences that do not have constant frame sizes?
          */
          if (!DInfo->TempImage) {
            DInfo->TempImage = (u_char *)ScPaMalloc (3 * pixels * lines);
	    if (DInfo->TempImage == NULL)
	      return(SvErrorMemory);
          }
          YData  = DInfo->TempImage;
          CbData = YData  + (pixels * lines * sizeof(u_char));
          CrData = CbData + (pixels * lines * sizeof(u_char));
        }
        else {
          /*
          ** For YUV Planar formats, no need to translate.
          ** Get pointers to individual components.
          */
          _SlibDebug(_DEBUG_, printf ("sv_GetYUVComponentPointers\n") );
          stat = sv_GetYUVComponentPointers(Info->OutputFormat.biCompression,
					pixels, lines, Image, MaxImageSize,
					&YData, &CbData, &CrData);
          RETURN_ON_ERROR (stat);
        }

        _SlibDebug(_DEBUG_, printf ("sv_ParseFrame\n") );
        stat = sv_ParseFrame (Data, MaxDataSize, Info);
        RETURN_ON_ERROR (stat);
      
       /*
       ** Fill Info structure with video-specific data on first frame
       */
       if (!DInfo->InfoFilled) {
         _SlibDebug(_DEBUG_, printf ("sv_InitJpegDecoder\n") );
         stat = sv_InitJpegDecoder (Info);
         RETURN_ON_ERROR (stat);
         DInfo->InfoFilled = 1;

         /*
         ** Error checking: 
         **      make the assumption that for MJPEG we need to check for 
         **      valid subsampling only once at the start of the seqence
         */
         _SlibDebug(_DEBUG_, printf ("sv_CheckChroma\n") );
         stat = sv_CheckChroma(Info);
         RETURN_ON_ERROR (stat);
       }

       /*
       ** Decompress everything into MCU's
       */
       if (!DInfo->ReInit) /* Reset the JPEG compressor */
	     sv_ReInitJpegDecoder (Info);
       maxMcu = DInfo->MCUsPerRow * DInfo->MCUrowsInScan;
       if (DInfo->ReInit) 
         DInfo->ReInit = 0; 

       DInfo->CurrBlockNumber = 0;
       /*
       ** Create the BlockPtr array for the output buffers
       */
       if ((YData  != DInfo->Old_YData)  ||
           (CbData != DInfo->Old_CbData) ||
           (CrData != DInfo->Old_CrData)) 
       {
         DInfo->Old_YData =YData;
         DInfo->Old_CbData=CbData;
         DInfo->Old_CrData=CrData;

         stat = sv_MakeDecoderBlkTable (Info);
         RETURN_ON_ERROR (stat);
       }

       CB.Message = CB_PROCESSING;
       for (i = 0; i < maxMcu; i++) {
#if 0
         if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0)) {
	   (*Info->CallbackFunction)(Svh, &CB, &PictureInfo);
	   if (CB.Action == CB_ACTION_END)
	     return(SvErrorClientEnd);
         }
#endif
         _SlibDebug(_DEBUG_, printf ("sv_DecodeJpeg\n") );
         stat = sv_DecodeJpeg (Info);
         RETURN_ON_ERROR (stat);
       }
#if 0
       /*
       ** Check for multiple scans in the JPEG file
       **	  - we do not support multiple scans 
       */
       if (sv_ParseScanHeader (Info) != SvErrorEOI) 
	 _SlibDebug(_DEBUG_ || _WARN_ || _VERBOSE_, 
         printf(" *** Warning ***, Multiple Scans detected, unsupported\n") );
#endif
       if (DInfo->compinfo[0].Vsf==2) /* 4:1:1->4:2:2 */
       {
         if (IsYUV422Packed(Info->OutputFormat.biCompression))
           ScConvert411sTo422i_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV422Sep(Info->OutputFormat.biCompression)
           ScConvert411sTo422s_C(YData, CbData, CrData, Image,
                                 pixels, lines);
         else if IsYUV411Sep(Info->OutputFormat.biCompression)
         {
           if (YData!=Image)
             memcpy(Image, YData, pixels*lines);
           memcpy(Image+pixels*lines, CbData, (pixels*lines)/4);
           memcpy(Image+(pixels*lines*5)/4, CrData, (pixels*lines)/4);
         }
         else
         {
           ScConvert411sTo422s_C(YData, CbData, CrData, YData,
                                 pixels, lines);
           ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
         }
       }
       else if (!IsYUV422Sep(Info->OutputFormat.biCompression) &&
           !IsYUV411Sep(Info->OutputFormat.biCompression) &&
            Info->OutputFormat.biCompression != BI_DECGRAYDIB)
          ScConvertSepYUVToOther(&Info->InputFormat, &Info->OutputFormat, 
                             Image, YData, CbData, CrData);
       }
       break; /* SV_JPEG_DECODE */
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_DECODE:
        {
          SvHuffInfo_t *HInfo;
          _SlibDebug(_DEBUG_, printf("SvDecompress() SV_HUFF_DECODE\n") );

          if (!(HInfo = Info->huff))
            return(SvErrorBadPointer);

          if (!HInfo->DecompressStarted)
            return(SvErrorDcmpNotStarted);

          stat = sv_HuffDecodeFrame(Info, Image);
          RETURN_ON_ERROR(stat);
        }
        break;
#endif /* HUFF_SUPPORT */

    default:
       return(SvErrorCodecType);
  }

  Info->NumOperations++;
  if (Info->CallbackFunction)
  {
    if (ImageSize>0)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
        printf("Decompress Callback: CB_FRAME_READY Addr=0x%x, Action=%d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
    /*
    ** If an Image buffer was taken from the queue, do a callback
    ** to let the client free or re-use the buffer.
    */
    if (UsedQ)
    {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Image;
      CB.DataSize = MaxImageSize;
      CB.DataUsed = ImageSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_,
          printf("Decompress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return(SvErrorClientEnd);
    }
  }
  _SlibDebug(_DEBUG_, printf("SvDecompress() Out\n") );
  return(stat);
}



/*
** Name:     SvDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SvDecompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvDecompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  _SlibDebug(_DEBUG_, printf("SvDecompressEnd()\n") );

  if (!Info)
    return(SvErrorCodecHandle);
  if (!Info->started)
    return(SvErrorDcmpNotStarted);

  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
     case SV_JPEG_DECODE:
        Info->jdcmp->DecompressStarted = FALSE;
        break;
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
        Info->mdcmp->DecompressStarted = FALSE;
        Info->mdcmp->PicturePositioned = FALSE;
        Info->mdcmp->lastI = -1;
        Info->mdcmp->lastP = -1;
        Info->mdcmp->N = 12;
        Info->mdcmp->M = 3;
        Info->mdcmp->framenum = 0;
        break;
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
     case SV_H261_DECODE:
        {
        int status=svH261DecompressFree(Svh);
        RETURN_ON_ERROR(status);
        }
        break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_DECODE:
        {
        int status=svH263FreeDecompressor(Info);
        RETURN_ON_ERROR(status);
        }
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
     case SV_HUFF_DECODE:
/*
	{
        int status=sv_HuffDecompressEnd(Svh);
        RETURN_ON_ERROR(status);
        }
*/
        break;
#endif /* HUFF_SUPPORT */
  }
  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    _SlibDebug(_VERBOSE_, printf("Info->ImageQ exists\n") );
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      _SlibDebug(_VERBOSE_, printf("Removing from ImageQ\n") );
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_,
           printf("SvDecompressEnd: RELEASE_BUFFER. Data = 0x%x, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining compressed buffers */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SvDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  Info->started=FALSE;
  return(NoErrors);
}

/*
** Name:     SvSetDataSource 
** Purpose:  Set the data source used by the MPEG or H261 bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataSource (SvHandle_t Svh, int Source, int Fd, 
			    void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode!=SV_MPEG_DECODE && Info->mode!=SV_MPEG2_DECODE
      && Info->mode!=SV_H261_DECODE && Info->mode!=SV_H263_DECODE
      && Info->mode!=SV_HUFF_DECODE)
    return(SvErrorCodecType);

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Svh, 
                                      CB_DATA_COMPRESSED,
                                      Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataSource(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name:     SvSetDataDestination 
** Purpose:  Set the data destination used by the MPEG or H261 bitstream
**           writing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SvAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Svh    = handle to software codec's Info structure.
**           Source = SV_USE_BUFFER_QUEUE or SV_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SvStatus_t SvSetDataDestination(SvHandle_t Svh, int Dest, int Fd, 
			        void *Buffer_UserData, int BufSize)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int stat=NoErrors;

  if (!Info)
    return(SvErrorCodecHandle);

  if (Info->mode != SV_H261_ENCODE && Info->mode != SV_H263_ENCODE &&
      Info->mode != SV_MPEG_ENCODE &&
      Info->mode != SV_MPEG2_ENCODE && Info->mode != SV_HUFF_ENCODE)
    return(SvErrorCodecType);

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SV_USE_BUFFER:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_BUFFER)\n") );
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize);
       break;

     case SV_USE_BUFFER_QUEUE:
       _SlibDebug(_DEBUG_, 
                  printf("SvSetDataDestination(SV_USE_BUFFER_QUEUE)\n") );
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Svh, 
                                      CB_DATA_COMPRESSED, Info->BufQ,
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SV_USE_FILE:
       _SlibDebug(_DEBUG_, printf("SvSetDataDestination(SV_USE_FILE)\n") );
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SvErrorBadArgument;
   }
   return(stat);
}

/*
** Name: SvGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataSource (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SvGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetDataDestination(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  
  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name: SvGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
**          (currently H.261 and MPEG use a bitstream)
*/
ScBitstream_t *SvGetInputBitstream (SvHandle_t Svh)
{
  return(SvGetDataSource(Svh));
}

/*
** Name:    SvFlush
** Purpose: Flushes out current compressed buffers.
** Return:  status
*/
SvStatus_t SvFlush(SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  if (Info->BSIn)
    ScBSFlush(Info->BSIn);  /* flush out any remaining input compressed buffers */
  if (Info->BSOut)
    ScBSFlush(Info->BSOut); /* flush out any remaining output compressed buffers */
  return(SvErrorNone);
}

/*
** Name:     SvRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Svh          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SvStatus_t SvRegisterCallback (SvHandle_t Svh, 
	   int (*Callback)(SvHandle_t, SvCallbackInfo_t *, SvPictureInfo_t *),
       void *UserData)
{
  SvStatus_t stat=NoErrors;
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  _SlibDebug(_DEBUG_, printf("SvRegisterCallback()\n") );

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Callback)
     return(SvErrorBadPointer);

  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT    
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT    
    case SV_H261_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H261_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->h261) /* copy callback to H261 structure */
             Info->h261->CallbackFunction=Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT    
    case SV_H263_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_H263_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT    
    case SV_HUFF_DECODE:
           Info->CallbackFunction = Callback;
           if (Info->BSIn==NULL)
             stat=SvSetDataSource(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
    case SV_HUFF_ENCODE:
           Info->CallbackFunction = Callback;
           if (Info->BSOut==NULL)
             stat=SvSetDataDestination(Svh, SV_USE_BUFFER_QUEUE, 0, UserData, 0);
           break;
#endif /* HUFF_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(stat);
}

/*
** Name:     SvAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Svh = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SvStatus_t SvAddBuffer (SvHandle_t Svh, SvCallbackInfo_t *BufferInfo)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  ScQueue_t *Q=NULL;
  _SlibDebug(_DEBUG_, printf("SvAddBuffer() length=%d\n",BufferInfo->DataSize));

  if (!Info)
    return(SvErrorCodecHandle);

  if (BufferInfo->DataType != CB_DATA_COMPRESSED &&
      BufferInfo->DataType != CB_DATA_IMAGE)
    return(SvErrorBadArgument);

  /*
  ** Compressed data can only be added for MPEG and H261
  */
  if (BufferInfo->DataType == CB_DATA_COMPRESSED
#ifdef MPEG_SUPPORT
        && Info->mode != SV_MPEG_DECODE 
        && Info->mode != SV_MPEG2_DECODE 
        && Info->mode != SV_MPEG_ENCODE 
        && Info->mode != SV_MPEG2_ENCODE 
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
        && Info->mode != SV_H261_DECODE
        && Info->mode != SV_H261_ENCODE
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
        && Info->mode != SV_H263_DECODE
        && Info->mode != SV_H263_ENCODE
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
        && Info->mode != SV_HUFF_DECODE
        && Info->mode != SV_HUFF_ENCODE
#endif /* HUFF_SUPPORT */
     )
    return(SvErrorCodecType);

  if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
    return(SvErrorBadArgument);

  switch (BufferInfo->DataType)
  {
     case CB_DATA_COMPRESSED:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() COMPRESSED\n") );
            if (Info->BSOut && Info->BSOut->EOI)
              ScBSReset(Info->BSOut);
            if (Info->BSIn && Info->BSIn->EOI)
              ScBSReset(Info->BSIn);
            Q = Info->BufQ;
            break;
     case CB_DATA_IMAGE:
            _SlibDebug(_DEBUG_, printf("SvAddBuffer() IMAGE\n") );
            Q = Info->ImageQ;
            break;
     default:
            return(SvErrorBadArgument);
  }
  if (Q)
    ScBufQueueAdd(Q, BufferInfo->Data, BufferInfo->DataSize);
  else
    _SlibDebug(_DEBUG_, printf("ScBufQueueAdd() no Queue\n") );

  return(NoErrors);
}

/*
** Name:     SvFindNextPicture
** Purpose:  Find the start of the next picture in a bitstream.
**           Return the picture type to the caller.
**
** Args:     Svh = handle to software codec's Info structure.
**           PictureInfo = Structure used to select what type of pictures to
**                         search for and to return information about the
**                         picture that is found
*/
SvStatus_t SvFindNextPicture (SvHandle_t Svh, SvPictureInfo_t *PictureInfo)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   _SlibDebug(_DEBUG_, printf("SvFindNextPicture()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   switch (Info->mode)
   {
#ifdef MPEG_SUPPORT
     case SV_MPEG_DECODE:
     case SV_MPEG2_DECODE:
            if (!Info->mdcmp)
              return(SvErrorBadPointer);
            if (!Info->mdcmp->DecompressStarted)
              return(SvErrorDcmpNotStarted);
            {
		SvStatus_t stat = sv_MpegFindNextPicture(Info, PictureInfo);
		return(stat);
	    }
#endif /* MPEG_SUPPORT */
     default:
            return(SvErrorCodecType);
   }
}

#ifdef MPEG_SUPPORT
/*
** Name:     SvDecompressMPEG
** Purpose:  Decompress the MPEG picture that starts at the current position
**           of the bitstream. If the bitstream is not properly positioned
**           then find the next picture.
**
** Args:     Svh = handle to software codec's Info structure.
**           MultiBuf = Specifies pointer to start of the Multibuffer, an area
**                      large enough to hold 3 decompressed images: the
**                      current image, the past reference image and the
**                      future reference image.
**           MaxMultiSize = Size of the Multibuffer in bytes.
**           ImagePtr = Returns a pointer to the current image. This will be
**                      somewhere within the Multibuffer.
*/
SvStatus_t SvDecompressMPEG (SvHandle_t Svh, u_char *MultiBuf, 
			     int MaxMultiSize, u_char **ImagePtr)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
   SvMpegDecompressInfo_t *MDInfo;
   _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );

   if (!Info)
     return(SvErrorCodecHandle);

   if (!(MDInfo = Info->mdcmp))
     return(SvErrorBadPointer);

   if (!MDInfo->DecompressStarted)
     return(SvErrorDcmpNotStarted);

   return(sv_MpegDecompressFrame(Info, MultiBuf, ImagePtr));
}
#endif /* MPEG_SUPPORT */	

#ifdef H261_SUPPORT
SvStatus_t SvDecompressH261 (SvHandle_t Svh, u_char *MultiBuf,
                             int MaxMultiSize, u_char **ImagePtr)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvH261Info_t *H261;
  ScCallbackInfo_t CB;
  SvStatus_t status;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!(H261 = Info->h261))
    return(SvErrorBadPointer);

  if (Info->BSIn->EOI)
    return(SvErrorEndBitstream);

  status = svH261Decompress(Info, MultiBuf, ImagePtr);
  if (status == SvErrorEndBitstream && Info->CallbackFunction)
  {
    CB.Message = CB_SEQ_END;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
               printf("H261 Callback: CB_SEQ_END Data = 0x%x Action = %d\n",
                          CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
  else if (status==NoErrors)
  {
    *ImagePtr = H261->Y;
    if (Info->CallbackFunction)
    {
      CB.Message = CB_FRAME_READY;
      CB.Data = *ImagePtr;
      CB.DataSize = H261->PICSIZE+(H261->PICSIZE/2);
      CB.DataUsed = CB.DataSize;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSIn?Info->BSIn->UserData:NULL;
      CB.TimeStamp = 0;
      CB.Flags = 0;
      CB.Value = 0;
      CB.Format = (void *)&Info->OutputFormat;
      CB.Action  = CB_ACTION_CONTINUE;
      (*Info->CallbackFunction)(Svh, &CB, NULL);
      _SlibDebug(_DEBUG_, 
            printf("H261 Callback: CB_FRAME_READY Data = 0x%x, Action = %d\n",
                  CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
        return (ScErrorClientEnd);
    }
  }
  return (status);
}
#endif /* H261_SUPPORT */

#ifdef JPEG_SUPPORT
/*---------------------------------------------------------------------
	SLIB routines to Query and return CODEC Tables to caller
 *---------------------------------------------------------------------*/

/*
** From JPEG Spec. :
**    Huffman tables are specified in terms of a 16-byte list (BITS) giving 
**    the number of codes for each code length from 1 to 16. This is 
**    followed by a list of 8-bit symbol values (HUFVAL), each of which is
**    assigned a Huffman code. The symbol values are placed in the list
**    in order of increasing code length.  Code length greater than 16-bits
**    are not allowed. 
*/


/*
** Name:     SvSetDcmpHTables
** Purpose: 
**
** Notes:    Baseline process is the only supported mode:
**		- uses 2 AC tables and 2 DC Tables
**
*/
SvStatus_t SvSetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,stat,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return(SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      *htblptr = (SvHt_t *) ScPaMalloc(sizeof(SvHt_t));
    
    (*htblptr)->bits[0] = 0;
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      (*htblptr)->bits[i] = (u_char)HTab->bits[i-1];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Load Huffman table:
    */
    for (i = 0; i < count; i++)
      (*htblptr)->value[i] = (u_char)HTab->value[i];
  }

  stat = sv_LoadDefaultHTable (Info);
  if (stat) return(stat);
  
  return(NoErrors);
}


/*
** Name:     SvGetDcmpHTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  int i,count;
  SvHt_t **htblptr;
  SvHTable_t *HTab;
  register int j;

  if (!Info)
    return (SvErrorCodecHandle);

  if (!Ht)
    return(SvErrorBadPointer);

  for (j = 0; j < 4; j++) {
    switch(j) {
    case 0: htblptr = &Info->jdcmp->DcHt[0];
      HTab = &Ht->DcY;
      break;
    case 1: htblptr = &Info->jdcmp->AcHt[0];
      HTab = &Ht->AcY;
      break;
    case 2: htblptr = &Info->jdcmp->DcHt[1];
      HTab = &Ht->DcUV;
      break;
    case 3: htblptr = &Info->jdcmp->AcHt[1];
      HTab = &Ht->AcUV;
      break;
    }
      
    if (*htblptr == NULL)
      return(SvErrorHuffUndefined);
    
    count   = 0;
    for (i = 1; i < BITS_LENGTH; i++) {
      HTab->bits[i-1] = (int)(*htblptr)->bits[i];
      count += (*htblptr)->bits[i];
    }
    if (count > 256) 
      return(SvErrorDHTTable);
    
    /*
    ** Copy Huffman table:
    */
    for (i = 0; i < count; i++)
      HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetCompHTables
** Purpose: 
**
*/
SvStatus_t SvSetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   return(SvErrorNotImplemented);
}


/*
** Name:     SvGetCompHTables
** Purpose: 
**
*/
SvStatus_t SvGetCompHTables (SvHandle_t Svh, SvHuffmanTables_t *Ht)
{
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;
   SvHt_t **htblptr;
   SvHTable_t *HTab;
   register int i, j, count;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Ht)
     return (SvErrorBadPointer);

   for (j = 0; j < 4; j++) {
      switch(j) {
      case 0: htblptr = &Info->jcomp->DcHt[0];
        HTab = &Ht->DcY;
        break;
      case 1: htblptr = &Info->jcomp->AcHt[0];
        HTab = &Ht->AcY;
        break;
      case 2: htblptr = &Info->jcomp->DcHt[1];
        HTab = &Ht->DcUV;
        break;
      case 3: htblptr = &Info->jcomp->AcHt[1];
        HTab = &Ht->AcUV;
        break;
      }
      
      if (*htblptr == NULL)
        return (SvErrorHuffUndefined);
    
      /*
      ** Copy the "bits" array (contains number of codes of each size)
      */
      count = 0;		
      for (i = 1; i < BITS_LENGTH; i++) {
         HTab->bits[i-1] = (int)(*htblptr)->bits[i];
         count += (*htblptr)->bits[i];
      }
      if (count > 256) 			
	 /* 
         **  total # of Huffman code words cannot exceed 256
         */
         return (SvErrorDHTTable);
    
      /*
      ** Copy the "value" array (contains values associated with above codes) 
      */
      for (i = 0; i < count; i++)
         HTab->value[i] = (u_int)(*htblptr)->value[i];
  }

  return(NoErrors);
}



/*
** Name:     SvSetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvSetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0] == NULL) 
    if ((DInfo->_SviquantTblPtrs[0] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);
  if (DInfo->_SviquantTblPtrs[1] == NULL) 
    if ((DInfo->_SviquantTblPtrs[1] = (int *) ScAlloc(64*sizeof(int))) ==
	(int *)NULL) return(SvErrorMemory);

  bcopy (Qt->c1,  DInfo->_SviquantTblPtrs[0], 64*sizeof(int));
  bcopy (Qt->c2,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));
  bcopy (Qt->c3,  DInfo->_SviquantTblPtrs[1], 64*sizeof(int));

  return(NoErrors);
}


/*
** Name:     SvGetDcmpQTables
** Purpose: 
**
*/
SvStatus_t SvGetDcmpQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvJpegDecompressInfo_t *DInfo;

  if (!Info)
    return(SvErrorCodecHandle);

  DInfo = (SvJpegDecompressInfo_t *)Info->jdcmp;

  if (!Qt)
    return(SvErrorBadPointer);

  if (DInfo->_SviquantTblPtrs[0])
    bcopy (DInfo->_SviquantTblPtrs[0], Qt->c1, 64*sizeof(int));
  else
    bzero (Qt->c1, 64*sizeof(int));

  if (DInfo->_SviquantTblPtrs[1])
    bcopy(DInfo->_SviquantTblPtrs[1], Qt->c2, 64*sizeof(int));
  else
    bzero(Qt->c2, 64*sizeof(int));

  /*
  ** XXX - when the structure is changed approprately remove the
  **	   above and do the following:
  **
  **  if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3))
  **     return (SvErrorBadPointer);
  **  bcopy ((u_char *)DInfo->Qt, (u_char *)Qt, sizeof(SvQuantTables_t));
  */

  return(NoErrors);
}


/*
** Name:     SvSetCompQTables
** Purpose:  Allows user to set quantization tables directly
**
*/
SvStatus_t SvSetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   /*
   ** Convert SvQuantTables_t structure to internal SvQt_t structure.
   */
   sv_ConvertQTable(Info, Qt);

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*---------------------------------------------------------------------
	SLIB Compression Routines
 *---------------------------------------------------------------------*/

/*
** Name:     SvCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SvOpenCodec &
**           before SvCompress (SvCompress will call SvCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = format of input (uncompressed) image
**           ImgOut = format of output (compressed) image
*/
SvStatus_t SvCompressBegin (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   int stat;
   SvCodecInfo_t *Info  = (SvCodecInfo_t *)Svh;

   /*
   ** Sanity checks:
   */
   if (!Info)
     return (SvErrorCodecHandle);

   if (!ImgIn || !ImgOut)
     return (SvErrorBadPointer);

   stat=SvCompressQuery (Svh, ImgIn, ImgOut);
   RETURN_ON_ERROR(stat);

   /*
   ** Save input & output formats for SvDecompress
   */
   sv_copy_bmh(ImgIn, &Info->InputFormat);
   sv_copy_bmh(ImgOut, &Info->OutputFormat);

   Info->Width = Info->OutputFormat.biWidth;
   Info->Height = abs(Info->OutputFormat.biHeight);
   /*
   **  Initialize -  the encoder structure 
   **  Load       -  the default Huffman Tables
   **  Make       -  the internal Block Table
   */  
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
      case SV_JPEG_ENCODE:
            stat = sv_InitJpegEncoder (Info);
            RETURN_ON_ERROR (stat);
            /*
            ** Set up the default quantization matrices:
            */ 
            stat = SvSetQuality (Svh, DEFAULT_Q_FACTOR);
            Info->jcomp->CompressStarted = TRUE;
            Info->jcomp->Quality = DEFAULT_Q_FACTOR;
            RETURN_ON_ERROR (stat);
            break;

#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SV_H261_ENCODE:
            stat = svH261CompressInit(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
      case SV_H263_ENCODE:
            stat = svH263InitCompressor(Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
      case SV_MPEG_ENCODE:
      case SV_MPEG2_ENCODE:
            stat = sv_MpegInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            sv_MpegEncoderBegin(Info);
            break;
#endif /* MPEG_SUPPORT */

#ifdef HUFF_SUPPORT
      case SV_HUFF_ENCODE:
            stat = sv_HuffInitEncoder (Info);
            RETURN_ON_ERROR (stat);
            break;
#endif /* HUFF_SUPPORT */

      default:
            return(SvErrorCodecType);
   }
   return (NoErrors);
}


/*
** Name:     SvCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SvCompress are done.
**
** Args:     Svh = handle to software codec's Info structure.
*/
SvStatus_t SvCompressEnd (SvHandle_t Svh)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;

  SvStatus_t status=NoErrors;
  _SlibDebug(_VERBOSE_, printf("SvCompressEnd()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
          status=svH261CompressFree(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
          status=svH263FreeCompressor(Svh);
          RETURN_ON_ERROR(status)
          break;
#endif /* H263_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
          sv_MpegEncoderEnd(Info);
          sv_MpegFreeEncoder(Info);
          break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT
    case SV_JPEG_ENCODE:
          if (!Info->jcomp)
            return (SvErrorMemory);
          Info->jcomp->CompressStarted = FALSE;
          break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
          sv_HuffFreeEncoder(Info);
          break;
#endif /* HUFF_SUPPORT */
    default:
          break;
  }

  /* Release any Image Buffers in the queue */
  if (Info->ImageQ)
  {
    int datasize;
    while (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &CB.Data, &datasize);
      ScBufQueueRemove(Info->ImageQ);
      if (Info->CallbackFunction && CB.Data)
      {
        CB.Message = CB_RELEASE_BUFFER;
        CB.DataSize = datasize;
        CB.DataUsed = 0;
        CB.DataType = CB_DATA_IMAGE;
        CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
        CB.Action  = CB_ACTION_CONTINUE;
        (*(Info->CallbackFunction))(Svh, &CB, NULL);
        _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd: RELEASE_BUFFER. Data = 0x%X, Action = %d\n",
                           CB.Data, CB.Action) );
      }
    }
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out the last compressed data */

  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
            printf("SvCompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                  CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }

  return (status);
}


/*
** Name:     SvCompress
** Purpose: 
**
*/
SvStatus_t SvCompress(SvHandle_t Svh, u_char *CompData, int MaxCompLen,
			 u_char *Image, int ImageSize, int *CmpBytes)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  SvCallbackInfo_t CB;
  int stat=NoErrors, UsedQ=FALSE;
  _SlibDebug(_DEBUG_, printf("SvCompress()\n") );

  if (!Info)
    return (SvErrorCodecHandle);
 
  /*
  ** If no image buffer is supplied, see if the Image Queue
  ** has any.  If not do a callback to get a buffer.
  */
  if (Image == NULL && Info->ImageQ)
  {
    if (ScBufQueueGetNum(Info->ImageQ))
    {
      ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
      ScBufQueueRemove(Info->ImageQ);
      UsedQ = TRUE;
    }
    else if (Info->CallbackFunction)
    {
      CB.Message = CB_END_BUFFERS;
      CB.Data  = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = CB_DATA_IMAGE;
      CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(Info->CallbackFunction))(Svh, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
        _SlibDebug(_DEBUG_, 
                   printf("SvDecompress() CB.Action = CB_ACTION_END\n") );
        return(SvErrorClientEnd);
      }
      else if (ScBufQueueGetNum(Info->ImageQ))
      {
        ScBufQueueGetHead(Info->ImageQ, &Image, &ImageSize);
        ScBufQueueRemove(Info->ImageQ);
        UsedQ = TRUE;
      }
      else
        return(SvErrorNoImageBuffer);
    }
  }

  if (Image == NULL)
    return(SvErrorNoImageBuffer);

  switch (Info->mode)
  {
#ifdef H261_SUPPORT
    case SV_H261_ENCODE:
         stat = svH261Compress(Svh, Image);
         if (CmpBytes)
           *CmpBytes = (int)(Info->h261->TotalBits/8);
         break;
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
    case SV_H263_ENCODE:
         stat = svH263Compress(Svh, Image);
         break;
#endif /* H261_SUPPORT */

#ifdef MPEG_SUPPORT
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
         stat = sv_MpegEncodeFrame(Svh, Image);
         break;
#endif /* MPEG_SUPPORT */

#ifdef JPEG_SUPPORT 
    case SV_JPEG_ENCODE:
         {
           SvJpegCompressInfo_t *CInfo;
           u_char *CompBuffer;
           register int i;
           int RetBytes, InLen;

           CInfo = Info->jcomp;
           /*
           ** In case the application forgot to call SvCompressBegin().
           */
           if (!CInfo->CompressStarted) 
             return (SvErrorCompNotStarted);

           if ((u_int)Image%8)
             return (SvErrorNotAligned);

           CompBuffer = CompData;
           /*
           ** Start - add header information
           **       - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegHeader (Svh, CompBuffer, MaxCompLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;

           /*
           ** Separate input image directly into 8x8 blocks.
           ** level shift to go from signed to unsigned representation
           **    - since we support baseline DCT process only (i.e 8-bit
           **      precision) subtract raw data by 128
           */
           sv_JpegExtractBlocks (Info, Image);

           for (i = 0; i < CInfo->NumComponents; i++)
             CInfo->lastDcVal[i] = 0;

           /*
           ** JPEG business loop:
           */
           {
           register int Cid, HQid, blkN, mcuN, mbn, DcVal;
           float *FQt, *FThresh, *FThreshNeg;
           float *RawData;
           SvRLE_t rle;
           const static long Mask = 0xffL;
           float DCTData[64];
           register float tmp,AcVal;

           CB.Message = CB_PROCESSING;
           /*
           ** Processing within a frame is done on a MCU by MCU basis:
           */
           for (blkN = 0, mcuN = 0 ; mcuN < (int) CInfo->NumMCU; mcuN++)
           {
             /*
             ** Callback user routine every now&then to see if we should abort
             */
             if ((Info->CallbackFunction) && ((i % MCU_CALLBACK_COUNT) == 0))
             {
               SvPictureInfo_t DummyPictInfo;
               (*Info->CallbackFunction)(Svh, &CB, &DummyPictInfo);
               if (CB.Action == CB_ACTION_END) 
                 return(SvErrorClientEnd);
             }
             /*
             ** Account for restart interval, emit restart marker if needed
             */
             if (CInfo->restartInterval)
             {
               if (CInfo->restartsToGo == 0)
                 EmitRestart (CInfo);
               CInfo->restartsToGo--;
             }
             /*
             ** Processing within an MCU is done on a block by block basis:
             */
             for (mbn = 0; mbn < (int) CInfo->BlocksInMCU; mbn++, blkN++)
             {
	       /*
	       ** Figure out the component to which the current block belongs:
	       ** -Due to the way input data is processed by "sv_extract_blocks"
	       **  and under the assumption that the input is YCrCb, 
	       **  Cid is 0,0,1,2 for each block in the MCU
	       */
               switch (mbn) {
	         case 0:
	         case 1:  Cid = 0;  HQid = 0;  break;
	         case 2:  Cid = 1;  HQid = 1;  break;
	         case 3:  Cid = 2;  HQid = 1;  break;
	       }

               RawData = CInfo->BlkTable[blkN];

#ifndef _NO_DCT_
               /*
               ** Discrete Cosine Transform:
	       ** Perform the Forward DCT, take the input data from "RawData"
	       ** and place the computed coefficients in "DCTData":
               */
               ScFDCT8x8 (RawData, DCTData);
#ifndef _NO_QUANT_
               /*
               **  Quantization:
	       **
	       ** Identify the quantization tables:
	       */
	       FQt        = (float *) (CInfo->Qt[HQid])->fval;
	       FThresh    = (float *) (CInfo->Qt[HQid])->fthresh;
	       FThreshNeg = (float *) (CInfo->Qt[HQid])->fthresh_neg;

	       /*
	       ** Quantize the DC value first:
	       */
	       tmp = DCTData[0] *FQt[0];
               if (tmp < 0)
	         DcVal = (int) (tmp - 0.5);
               else
	         DcVal = (int) (tmp + 0.5);

	       /* 
	       ** Go after (quantize) the AC coefficients now:
	       */
               for (rle.numAC = 0, i = 1; i < 64; i++)
               {
	         AcVal = DCTData[ZagIndex[i]];
 
	         if (AcVal > FThresh[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] + 0.5);
	         }
	         else if (AcVal < FThreshNeg[i]) {
	           rle.ac[rle.numAC].index = i;
	           rle.ac[rle.numAC++].value = (int) (AcVal * FQt[i] - 0.5);
	         }
               }

               /*
               ** DPCM coding:
	       **
	       ** Difference encoding of the DC value, 
	       */
	       rle.dc = DcVal - CInfo->lastDcVal[Cid];
	       CInfo->lastDcVal[Cid] = DcVal;

#ifndef _NO_HUFF_
               /*
               ** Entropy Coding:
	       **
	       ** Huffman encode the current block
	       */
  	       sv_EncodeOneBlock (&rle, CInfo->DcHt[HQid], CInfo->AcHt[HQid]); 
	       FlushBytes(&CompBuffer);
#endif /* _NO_HUFF_ */
#endif /* _NO_QUANT_ */
#endif /* _NO_DCT_ */
             }
           }
           }
           (void ) sv_HuffEncoderTerm (&CompBuffer);

           Info->OutputFormat.biSize = CompBuffer - CompData;
           InLen = MaxCompLen - Info->OutputFormat.biSize;

           /*
           ** JPEG End:
           ** - add trailer information to the compressed bitstream, 
           **   - needed if we want to conform to the interchange format
           */
           stat = sv_AddJpegTrailer (Svh, CompBuffer, InLen, &RetBytes);
           RETURN_ON_ERROR (stat);
           CompBuffer += RetBytes;
           Info->OutputFormat.biSize += RetBytes;
           if (CmpBytes)
             *CmpBytes = CompBuffer - CompData;
         }
         break;
#endif /* JPEG_SUPPORT */

#ifdef HUFF_SUPPORT
    case SV_HUFF_ENCODE:
         stat = sv_HuffEncodeFrame(Svh, Image);
         break;
#endif /* HUFF_SUPPORT */

    default:
         return(SvErrorCodecType);
  }

  Info->NumOperations++;
  /*
  ** If an Image buffer was taken from the queue, do a callback
  ** to let the client free or re-use the buffer.
  */
  if (Info->CallbackFunction && UsedQ)
  {
    CB.Message = CB_RELEASE_BUFFER;
    CB.Data  = Image;
    CB.DataSize = ImageSize;
    CB.DataUsed = ImageSize;
    CB.DataType = CB_DATA_IMAGE;
    CB.UserData = Info->BSOut?Info->BSOut->UserData:NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*(Info->CallbackFunction))(Svh, &CB, NULL);
    _SlibDebug(_DEBUG_, 
             printf("Compress Callback: RELEASE_BUFFER Addr=0x%x, Action=%d\n",
                 CB.Data, CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return(SvErrorClientEnd);
  }
  return (stat);
}

static SvStatus_t sv_ConvertRGBToSepComponent(u_char *Iimage,
BITMAPINFOHEADER * Bmh, u_char *comp1, u_char *comp2, u_char *comp3, 
int pixels, int lines)
{
  register i;
  int bpp = Bmh->biBitCount;
  u_int *Ip = (u_int *)Iimage;
  u_short *Is = (u_short *)Iimage;

  if (bpp == 24) {
    if (Bmh->biCompression == BI_RGB) {
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
      }
    }
    else if (Bmh->biCompression == BI_DECXIMAGEDIB) {
                             /* RGBQUAD structures: (B,G,R,0) */
      for (i = 0 ; i < pixels*lines ; i++) {
        comp3[i] = *Iimage++; /* Blue */
        comp2[i] = *Iimage++; /* Green */
        comp1[i] = *Iimage++; /* Red */
        Iimage++;             /* Reserved */
      }
    }
  }
  else if (bpp == 32) {      /* RGBQUAD structures: (B,G,R,0) */
    for (i = 0 ; i < pixels*lines ; i++) {
      comp3[i] = (Ip[i] >> 24) & 0xFF;
      comp2[i] = (Ip[i] >> 16) & 0xFF;
      comp1[i] = (Ip[i] >> 8)  & 0xFF;
    }
  }
  else if (bpp == 16) {
    for (i = 0 ; i < pixels*lines ; i++) {
      comp1[i] = (Is[i] >> 7) & 0xf8;
      comp2[i] = (Is[i] >> 2) & 0xf8;
      comp3[i] = (Is[i] << 3) & 0xf8;
    }
  }
  return (NoErrors);
}


/*
** Name:     SvCompressQuery
** Purpose:  Determine if Codec can Compress desired format
**
** Args:     Svh = handle to software codec's Info structure.
**           ImgIn  = Pointer to BITMAPINFOHEADER structure describing format
**           ImgOut = Pointer to BITMAPINFOHEADER structure describing format
*/
SvStatus_t SvCompressQuery (SvHandle_t Svh, BITMAPINFOHEADER *ImgIn,
                                            BITMAPINFOHEADER *ImgOut)
{
   /*
   ** We don't *really* need the Info structures, but we check for
   ** NULL pointers to make sure the CODEC,  whoes ability is being
   ** queried, was at least opened.
   */
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   if (!ImgIn && !ImgOut)
     return(SvErrorBadPointer);

   if (!IsSupported(_SvCompressionSupport,
                    ImgIn ? ImgIn->biCompression : -1, 
                    ImgIn ? ImgIn->biBitCount : -1,
                    ImgOut ? ImgOut->biCompression : -1, 
                    ImgOut ? ImgOut->biBitCount : -1))
     return(SvErrorUnrecognizedFormat);
	 
   /*
   ** For speed we impose a restriction that the image size should be
   ** a multiple of 16x8. This insures that we would have at least one
   ** MCU for a 4:2:2 image
   **
   ** NOTE: This is an artificial restriction from JPEG's perspective.
   **       In the case when the dimesnsions are otherwise, we should
   **       pixel replicate and/or line replicate before compressing.
   */
   if (ImgIn)
   {
     if (ImgIn->biWidth  <= 0 || ImgIn->biHeight == 0)
       return(SvErrorBadImageSize);
     if ((ImgIn->biWidth%16) || (ImgIn->biHeight%8))
       return (SvErrorNotImplemented);
   }

   if (ImgOut) /* Query Output also */
   {
     if (ImgOut->biWidth <= 0 || ImgOut->biHeight == 0)
       return (SvErrorBadImageSize);
     if (ImgOut->biCompression == BI_DECH261DIB)
     {
       if ((ImgOut->biWidth != CIF_WIDTH && ImgOut->biWidth != QCIF_WIDTH) ||
	   (abs(ImgOut->biHeight) != CIF_HEIGHT && abs(ImgOut->biHeight) != QCIF_HEIGHT))
       return (SvErrorBadImageSize);
     }
   }

   return(NoErrors);
}


/*
** Name:    SvGetCompressSize
** Purpose:
**
*/
SvStatus_t SvGetCompressSize (SvHandle_t Svh, int *MaxSize)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!MaxSize)
     return (SvErrorBadPointer);

   /*
   ** We are being extra cautious here, it would reflect poorly on the JPEG 
   ** commitee is the compressed bitstream was so big
   */
   *MaxSize = 2 * Info->InputFormat.biWidth * abs(Info->InputFormat.biHeight);

   return(NoErrors);
}



#ifdef JPEG_SUPPORT
/*
** Name:     SvGetQuality
** Purpose:
**
*/
SvStatus_t SvGetQuality (SvHandle_t Svh, int *Quality)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Quality)
     return (SvErrorBadPointer);

   *Quality = Info->jcomp->Quality;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuality
** Purpose: 
**
*/
SvStatus_t SvSetQuality (SvHandle_t Svh, int Quality)
{
   int stat,ConvertedQuality;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((Quality < 0) || (Quality > 10000))
     return (SvErrorValue);

   Info->jcomp->Quality = Quality;
   ConvertedQuality = 10000 - Quality;
   if (ConvertedQuality < MIN_QUAL)
     ConvertedQuality = MIN_QUAL;
   stat = sv_MakeQTables (ConvertedQuality, Info);
   return (stat);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:     SvGetCompQTables
** Purpose: 
**
*/
SvStatus_t SvGetCompQTables (SvHandle_t Svh, SvQuantTables_t *Qt)
{
   register int i;
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if (!Info->jcomp->CompressStarted)
     return (SvErrorCompNotStarted);

   if (!Qt)
     return (SvErrorBadPointer);

   if ((!Qt->c1) || (!Qt->c2) || (!Qt->c3)) 
     return (SvErrorBadPointer);

   for (i = 0 ; i < 64 ; i++) {
     register int zz = ZigZag[i];
     Qt->c1[i] = (Info->jcomp->Qt[0])->ival[zz];
     Qt->c2[i] = (Info->jcomp->Qt[1])->ival[zz];
     Qt->c3[i] = (Info->jcomp->Qt[1])->ival[zz];
   }

   return(NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name:     SvGetCodecInfo
** Purpose:  Get info about the codec & the data
**
** Args:     Svh = handle to software codec's Info structure.
**
** XXX - does not work for compression, this has to wait for the
**       decompressor to use SvCodecInfo_t struct for this to work
*/
SvStatus_t SvGetInfo (SvHandle_t Svh, SV_INFO_t *lpinfo, BITMAPINFOHEADER *Bmh)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return(SvErrorCodecHandle);

   lpinfo->Version 	     = SLIB_VERSION;
   switch (Info->mode)
   {
#ifdef JPEG_SUPPORT
     case SV_JPEG_ENCODE:
           lpinfo->CodecStarted = Info->jcomp->CompressStarted;
           break;
     case SV_JPEG_DECODE:
           lpinfo->CodecStarted = Info->jdcmp->DecompressStarted;
           break;
#endif /* JPEG_SUPPORT */
     default:
           lpinfo->CodecStarted = 0;
           break;
   }
   lpinfo->NumOperations     = Info->NumOperations;

   *Bmh = Info->InputFormat;
   return(NoErrors);
}



/*
** Name:     sv_GetComponentPointers
** Purpose:  Given a pointer to an image and its size,
**           return pointers to the individual image components
**
** Args:     pixels   = number of pixels in a line.
**           lines    = number of lines in image.
**           Image    = Pointer to start of combined image data
**           MaxLen   = Size of image data in bytes
**           comp1/2/3= pointers to pointers to individual components
*/
static SvStatus_t sv_GetYUVComponentPointers(int biCompression, 
		    int pixels, int lines, u_char *Image, 
		    int MaxLen, u_char **comp1, u_char **comp2, u_char **comp3)
{
  u_int sz1,sz2,sz3,maxlen;

  sz1 = pixels * lines; 
  sz2 = sz3 = (IsYUV411Sep(biCompression)) ? (sz1 / 4) : 
              ((IsYUV1611Sep(biCompression)) ? (pixels * lines / 16) 
                                             : (sz1 / 2));
  maxlen = (MaxLen > 0) ? (u_int) MaxLen : 0 ;
  if (biCompression == BI_DECGRAYDIB) {
    if (sz1 > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = NULL;
    *comp3 = NULL;
  }
  else {
    if ((sz1+sz2+sz3) > maxlen)
      return(SvErrorBadImageSize);
    *comp1 = Image;
    *comp2 = Image + sz1;
    *comp3 = Image + sz1 + sz2;
  }
  return(SvErrorNone);
}



#ifdef JPEG_SUPPORT
/*
** Name:     sv_JpegExtractBlocks 
** Purpose:  
**
** Note:    If we did our job right, memory for all global structures should 
**	    have been allocated by the upper layers, we do not waste time 
**	    checking for NULL pointers at this point
**
*/
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *Info, u_char *RawImage)
{
  SvJpegCompressInfo_t *CInfo = (SvJpegCompressInfo_t *)Info->jcomp;
  int size = Info->Width * Info->Height;
  u_char *TempImage;
  SvStatus_t stat;

  if (IsYUV422Packed(Info->InputFormat.biCompression))
    /*
    ** This will extract chunks of 64 bytes (8x8 blocks) from the uncompressed
    ** 4:2:2 interleaved input video frame and place them in three separate 
    ** linear arrays for later processing.
    **	XXX - should also do level shifting in this routine
    ** 
    */
    ScConvert422iTo422sf_C(RawImage, 16, 
			     (float *)(CInfo->BlkBuffer),
			     (float *)(CInfo->BlkBuffer + size),
			     (float *)(CInfo->BlkBuffer + size + size/2),
			     Info->Width, 
			     Info->Height);

  else if (IsYUV422Sep(Info->InputFormat.biCompression))
    /*
    ** Same but RawImage is not interleaved. Three components are sequential.
    */
    ScConvertSep422ToBlockYUV (RawImage, 16, 
				(float *)(CInfo->BlkBuffer),
				(float *)(CInfo->BlkBuffer + size),
				(float *)(CInfo->BlkBuffer + size + size/2),
				Info->Width, 
				Info->Height);

  else if (Info->InputFormat.biCompression == BI_DECGRAYDIB)
    /*
    ** Grayscale: one component
    */
    ScConvertGrayToBlock (RawImage, 
                          8, 
			  (float *)(CInfo->BlkBuffer),
			  Info->Width, 
			  Info->Height);

  if ((Info->InputFormat.biCompression == BI_RGB) ||
      (Info->InputFormat.biCompression == BI_DECXIMAGEDIB) ||
      (ValidateBI_BITFIELDS(&Info->InputFormat) != InvalidBI_BITFIELDS))
  {
      TempImage = (u_char *)ScPaMalloc (3 * Info->Width * Info->Height);

      if (TempImage == NULL)
	 return(ScErrorMemory);

      stat = ScRgbInterlToYuvInterl(
		 &Info->InputFormat,
		 (int)Info->Width, 
		 (int)Info->Height,
		 RawImage, 
		 (u_short *) TempImage);
      RETURN_ON_ERROR (stat);

      ScConvert422iTo422sf_C(
          TempImage, 
          16,
	  (float *)(CInfo->BlkBuffer),
	  (float *)(CInfo->BlkBuffer + size),
	  (float *)(CInfo->BlkBuffer + size + size/2),
	  Info->Width,
	  Info->Height);

     ScPaFree(TempImage);
  }

  return (NoErrors);
}
#endif /* JPEG_SUPPORT */

#ifdef JPEG_SUPPORT
/*
** Name:    SvSetQuantMode
** Purpose: Used only in the "Q Conversion" program "jpegconvert" to
**          set a flag in the comp & decomp info structures that causes
**          the quantization algorithm to use the new or old versions
**          of JPEG quantization.
**
*/
SvStatus_t SvSetQuantMode (SvHandle_t Svh, int QuantMode)
{
   SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

   if (!Info)
     return (SvErrorCodecHandle);

   if ((QuantMode != SV_JPEG_QUANT_OLD) && (QuantMode != SV_JPEG_QUANT_NEW))
     return (SvErrorValue);

   if (Info->jdcmp)
     Info->jdcmp->QuantMode = QuantMode;
   if (Info->jcomp)
     Info->jcomp->QuantMode = QuantMode;

   return (NoErrors);
}
#endif /* JPEG_SUPPORT */

/*
** Name: SvSetParamBoolean()
** Desc: Generic call used to set specific BOOLEAN (TRUE or FALSE) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamBoolean(SvHandle_t Svh, SvParameter_t param, 
                                             ScBoolean_t value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamBoolean()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamBoolean(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamBoolean(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamInt()
** Desc: Generic call used to set specific INTEGER (qword) parameters
**       of the CODEC.
*/
SvStatus_t SvSetParamInt(SvHandle_t Svh, SvParameter_t param, qword value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamInt()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamInt(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamInt(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamInt(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvSetParamFloat()
** Desc: Generic call used to set specific FLOAT parameters of the CODEC.
*/
SvStatus_t SvSetParamFloat(SvHandle_t Svh, SvParameter_t param, float value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(SvErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SvSetParamFloat()\n") );
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           sv_MpegSetParamFloat(Svh, param, value);
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           svH261SetParamFloat(Svh, param, value);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           svH263SetParamFloat(Svh, param, value);
           break;
#endif /* H263_SUPPORT */
    default:
           return(SvErrorCodecType);
  }
  return(NoErrors);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific BOOLEAN (TRUE or FALSE)
**       parameters of the CODEC.
*/
ScBoolean_t SvGetParamBoolean(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(FALSE);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamBoolean()  */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_BITSTREAMING:
                    return(FALSE);  /* this is a frame-based codecs */
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamBoolean(Svh, param));
           break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamBoolean()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamBoolean(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamBoolean(Svh, param));
           break;
#endif /* H263_SUPPORT */
  }
  return(FALSE);
}

/*
** Name: SvGetParamInt()
** Desc: Generic call used to get the setting of specific INTEGER (qword)
**       parameters of the CODEC.
*/
qword SvGetParamInt(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0);
  switch (Info->mode)
  {
#ifdef JPEG_SUPPORT
    /* this code should be moved into JPEG codec: svJPEGGetParamInt() */
    case SV_JPEG_DECODE:
    case SV_JPEG_ENCODE:
           switch (param)
           {
              case SV_PARAM_NATIVEFORMAT:
                    return(BI_YU16SEP);
           }
           break;
#endif /* JPEG_SUPPORT */
#ifdef H261_SUPPORT
    /* this code should be moved into H261 codec: svH261GetParamInt()  */
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamInt(Svh, param));
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamInt(Svh, param));
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamInt(Svh, param));
#endif /* MPEG_SUPPORT */
  }
  switch (param)
  {
     case SV_PARAM_FINALFORMAT:
           return(Info->OutputFormat.biCompression);
  }
  return(0);
}

/*
** Name: SvGetParamBoolean()
** Desc: Generic call used to get the setting of specific FLOAT
**       parameters of the CODEC.
*/
float SvGetParamFloat(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Info)
    return(0.0f);
  switch (Info->mode)
  {
#ifdef MPEG_SUPPORT
    case SV_MPEG_DECODE:
    case SV_MPEG2_DECODE:
    case SV_MPEG_ENCODE:
    case SV_MPEG2_ENCODE:
           return(sv_MpegGetParamFloat(Svh, param));
#endif
#ifdef H261_SUPPORT
    case SV_H261_DECODE:
    case SV_H261_ENCODE:
           return(svH261GetParamFloat(Svh, param));
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SV_H263_DECODE:
    case SV_H263_ENCODE:
           return(svH263GetParamFloat(Svh, param));
#endif /* H263_SUPPORT */
  }
  return(0.0f);
}

/*
** Name:     sv_copy_bmh
** Purpose:  Copy a BITMAPINFOHEADER struct.  For now, it only knows about the 
**           extra DWORD masks at the end of BI_BITFIELDS bitmapinfoheaders.
**           Otherwise, it treats others (such as 8 bit rgb, or jpeg) the
**           same as a vanilla bitmapinfoheader.
*/
static void sv_copy_bmh (
    BITMAPINFOHEADER *ImgFrom, 
    BITMAPINFOHEADER *ImgTo)
{
    *ImgTo = *ImgFrom;

    if (ImgFrom->biCompression == BI_BITFIELDS)
        bcopy(ImgFrom + 1, ImgTo + 1, 3*sizeof(DWORD));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\sv_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_prototypes.h,v $
 * Revision 1.1.9.6  1996/10/28  17:32:26  Hans_Graves
 * 	Changed sv_MpegGet/SetParamInt() to use qwords.
 * 	[1996/10/28  17:07:11  Hans_Graves]
 *
 * Revision 1.1.9.5  1996/10/02  18:42:52  Hans_Graves
 * 	Added InputFourCC to sv_MpegEncodeFrameInOrder().
 * 	[1996/10/02  18:34:36  Hans_Graves]
 * 
 * Revision 1.1.9.4  1996/07/19  02:11:09  Hans_Graves
 * 	Change 422i motion recon function protos.
 * 	[1996/07/19  01:27:59  Hans_Graves]
 * 
 * Revision 1.1.9.3  1996/05/24  22:21:42  Hans_Graves
 * 	Added MPEG 422i protos
 * 	[1996/05/24  21:55:51  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/05/07  19:56:10  Hans_Graves
 * 	Added HUFF_SUPPORT
 * 	[1996/05/07  17:24:56  Hans_Graves]
 * 
 * Revision 1.1.7.7  1996/04/10  21:47:39  Hans_Graves
 * 	Added Set/GetParamBoolean()
 * 	[1996/04/10  20:39:51  Hans_Graves]
 * 
 * Revision 1.1.7.6  1996/04/09  20:50:35  Karen_Dintino
 * 	Adding WIN32 support
 * 	[1996/04/09  20:47:45  Karen_Dintino]
 * 
 * Revision 1.1.7.5  1996/04/09  16:04:40  Hans_Graves
 * 	Fix protos for sv_MpegIDCTToFrame/AddToFrame()
 * 	[1996/04/09  16:03:24  Hans_Graves]
 * 
 * Revision 1.1.7.4  1996/04/04  23:35:05  Hans_Graves
 * 	Added protos for sv_MpegReconFieldBlock() and sv_MpegReconFrameBlock()
 * 	[1996/04/04  22:59:42  Hans_Graves]
 * 
 * Revision 1.1.7.3  1996/03/29  22:21:21  Hans_Graves
 * 	Added JPEG_SUPPORT ifdefs.
 * 	[1996/03/29  22:14:58  Hans_Graves]
 * 
 * 	Added protos for SvMpegIDCTToFrameP_S() and SvMpegIDCTAddToFrameP_S()
 * 	[1996/03/27  21:54:00  Hans_Graves]
 * 
 * Revision 1.1.7.2  1996/03/08  18:46:37  Hans_Graves
 * 	Added protos for new MPEG assembly
 * 	[1996/03/08  16:25:05  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/06  22:54:03  Hans_Graves
 * 	Added MpegGet/SetParam() prototypes
 * 	[1996/02/06  22:50:20  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/24  19:33:21  Hans_Graves
 * 	Changed DCT block for shorts to ints
 * 	[1996/01/24  18:13:05  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/08  16:41:29  Hans_Graves
 * 	Updated MPEG I and II prototypes for new decoder
 * 	[1996/01/08  15:47:45  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:35  Hans_Graves
 * 	Removed prototype for error()
 * 	[1995/12/07  19:20:55  Hans_Graves]
 * 
 * 	Added MPEG encoder prototypes
 * 	[1995/12/07  18:00:18  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/09/22  12:58:43  Bjorn_Engberg
 * 	Use MPEG_SUPPORT and H261_SUPPORT.
 * 	[1995/09/22  12:50:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.15  1995/09/11  20:36:34  Paul_Gauthier
 * 	Add version string to JPEG header as APP1 segment
 * 	[1995/09/11  20:35:13  Paul_Gauthier]
 * 
 * Revision 1.1.2.14  1995/08/15  19:13:57  Karen_Dintino
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.12 **}
 * 		{** Merge revision:	1.1.2.13 **}
 * 	{** End **}
 * 	fix reentrant problem
 * 	[1995/08/15  18:31:06  Karen_Dintino]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:28  Hans_Graves
 * 	Fixed H261 Init prototypes.
 * 	[1995/08/14  18:43:51  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/08/07  22:09:52  Hans_Graves
 * 	Added prototype for CrawlMotionEstimation()
 * 	[1995/08/07  22:09:31  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/08/04  16:32:28  Karen_Dintino
 * 	Change to SvStatus_t for some low level rtns
 * 	[1995/08/04  16:22:50  Karen_Dintino]
 * 
 * Revision 1.1.2.10  1995/08/03  18:02:07  Karen_Dintino
 * 	Encode/Decode routines need to return SvStatus_t
 * 	[1995/08/03  18:00:02  Karen_Dintino]
 * 
 * Revision 1.1.2.9  1995/08/02  15:27:00  Hans_Graves
 * 	Changed prototype for blockdiff16_C()
 * 	[1995/08/02  15:25:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/28  17:36:05  Hans_Graves
 * 	Added prototype for sv_CompressH261()
 * 	[1995/07/28  17:29:00  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/26  17:48:57  Hans_Graves
 * 	Added prototype for sv_DecompressH261()
 * 	[1995/07/26  17:47:19  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  16:12:17  Hans_Graves
 * 	Added H261 prototypes.
 * 	[1995/07/17  15:54:27  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:27  Hans_Graves
 * 	Removed prototype for sv_RdRunLevel().
 * 	[1995/06/27  13:52:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/20  14:13:39  Karen_Dintino
 * 	Separate H.261 prototypes
 * 	[1995/06/20  13:29:25  Karen_Dintino]
 * 
 * Revision 1.1.2.3  1995/06/19  20:31:18  Karen_Dintino
 * 	Added support for H.261
 * 	[1995/06/19  20:14:23  Karen_Dintino]
 * 
 * Revision 1.1.2.2  1995/05/31  18:10:24  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:51:00  Hans_Graves]
 * 
 * Revision 1.1.2.8  1994/12/14  19:09:54  Paul_Gauthier
 * 	Removed sv_gentoc.c from SLIB
 * 	[1994/12/14  19:07:29  Paul_Gauthier]
 * 
 * Revision 1.1.2.7  1994/12/12  15:39:31  Paul_Gauthier
 * 	Merge changes from other SLIB versions
 * 	[1994/12/12  15:35:04  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1994/11/09  21:33:12  Paul_Gauthier
 * 	Optimizations
 * 	[1994/11/09  15:31:22  Paul_Gauthier]
 * 
 * Revision 1.1.2.3  1994/10/13  20:34:53  Paul_Gauthier
 * 	MPEG cleanup
 * 	[1994/10/12  21:08:55  Paul_Gauthier]
 * 
 * Revision 1.1.2.2  1994/10/07  14:58:16  Paul_Gauthier
 * 	SLIB v3.0 incl. MPEG Decode
 * 	[1994/10/07  13:57:07  Paul_Gauthier]
 * 
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   
** MODULE NAME: 
**
** MODULE DESCRIPTION: 
** 
** DESIGN OVERVIEW: 
** 
**--
*/
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SV.h)
 *
 * Modification History: sv_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SV_PROTOTYPES_H
#define _SV_PROTOTYPES_H

extern void DumpBlock(char *title, short *blk);

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

/*
** sv_codec_api.c
*/
static SvStatus_t sv_GetYUVComponentPointers(int, int, int, u_char *, int,
					     u_char **, u_char **, u_char **);
static SvStatus_t sv_JpegExtractBlocks (SvCodecInfo_t *, u_char *);

#ifdef JPEG_SUPPORT
/*
** sv_jpeg_decode.c
*/
static void sv_FillBitBuffer (int);
static SvStatus_t sv_ProcessRestart (SvCodecInfo_t *);
extern SvStatus_t sv_DecodeJpeg (SvCodecInfo_t *);
extern void sv_ReInitJpegDecoder (SvCodecInfo_t *);

/*
** sv_jpeg_encode.c
*/
extern void WriteJpegData(char *, int, u_char **);
extern void FlushBytes (u_char **);
static void EmitBits(u_short, int);
static void FlushBits (void);
extern void sv_EncodeOneBlock (SvRLE_t *, SvHt_t *, SvHt_t *);
extern void sv_HuffEncoderInit (SvCodecInfo_t *);
extern void EmitRestart (SvJpegCompressInfo_t *);
extern void sv_HuffEncoderTerm (u_char **);


/*
** sv_jpeg_format.c
*/
extern SvStatus_t sv_AddJpegHeader (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_AddJpegTrailer (SvHandle_t, u_char *, int, int *);
extern SvStatus_t sv_FormatJpegData (SvHandle_t, char *, char *, int, int *);
static SvStatus_t sv_AddCompSpecs (int, int, int, int, char **, char *); 
static SvStatus_t sv_AddEntropyData (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrame (SvCodecInfo_t *, char *, char **, char *);
static SvStatus_t sv_AddFrameHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddMarker ();
static SvStatus_t sv_AddScanHeader (SvCodecInfo_t *, char **, char *);
static SvStatus_t sv_AddSLIBHeader (char **, char *);
static SvStatus_t sv_Write16bits (short, char **, char *);
static SvStatus_t sv_Write8bits (int, char **, char *);
static SvStatus_t sv_AddMMSVer (char **, char *);

/*
** sv_jpeg_init.c
*/
static SvStatus_t sv_InitEncoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitDecoderStruct (SvCodecInfo_t *);
static SvStatus_t sv_InitHDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegEncoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitJpegDecoder (SvCodecInfo_t *);
extern SvStatus_t sv_InitInfo (SvCodecInfo_t *);
extern void sv_copyHTable (SvHt_t *, SvHt_t *);
extern SvStatus_t sv_CheckChroma (SvCodecInfo_t *);
static int JroundUp (int, int);
/*
** sv_jpeg_tables.c
*/
extern SvStatus_t sv_MakeQTables (int, SvCodecInfo_t *);
extern SvStatus_t sv_MakeHEncodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeHDecodingTables (SvCodecInfo_t *);
extern SvStatus_t sv_MakeEncoderBlkTable (SvCodecInfo_t *);
extern SvStatus_t sv_MakeDecoderBlkTable (SvCodecInfo_t *);
static void sv_MakeHCodeTables (SvHt_t *, char *, u_short *, u_int *);
extern SvStatus_t sv_ConvertQTable (SvCodecInfo_t *, SvQuantTables_t *);
extern SvStatus_t sv_LoadDefaultHTable (SvCodecInfo_t *);

/*
** sv_jpeg_parse.c
*/
static u_int sv_GetShort (SvCodecInfo_t *);
static int sv_GetNextMarker (void);
static void sv_ProcessBogusMarker (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDHT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDQT (SvCodecInfo_t *);
static SvStatus_t sv_ProcessDRI (SvCodecInfo_t *);
static SvStatus_t sv_ProcessAPP0 (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOF (SvCodecInfo_t *, int);
static SvStatus_t sv_ProcessSOS (SvCodecInfo_t *);
static SvStatus_t sv_ProcessSOI (SvCodecInfo_t *);
/*static int sv_ProcessTables (SvCodecInfo_t *);*/
static SvStatus_t sv_ParseFileHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseScanHeader (SvCodecInfo_t *);
extern SvStatus_t sv_ParseFrame (u_char *, int, SvCodecInfo_t *);
#endif /* JPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              MPEG Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_mpeg_common.c
*/
extern SvStatus_t sv_MpegSetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                                  ScBoolean_t value);
extern SvStatus_t sv_MpegSetParamInt(SvHandle_t Svh, SvParameter_t param,
                                qword value);
extern SvStatus_t sv_MpegSetParamFloat(SvHandle_t Svh, SvParameter_t param,
                                float value);
extern ScBoolean_t sv_MpegGetParamBoolean(SvHandle_t Svh, SvParameter_t param);
extern qword sv_MpegGetParamInt(SvHandle_t Svh, SvParameter_t param);
extern float sv_MpegGetParamFloat(SvHandle_t Svh, SvParameter_t param);

/*
** sv_mpeg_parse.c
*/
extern SvStatus_t sv_MpegGetHeader(SvMpegDecompressInfo_t *MpegInfo,
                                   ScBitstream_t *bs);
extern int sv_MpegGetSliceHdr(SvMpegDecompressInfo_t *MpegInfo,
                              ScBitstream_t *bs,
                              SvMpegLayer_t *layer);
extern SvStatus_t sv_MpegGetImageInfo(int fd, SvImageInfo_t *iminfo);
extern SvStatus_t sv_MpegFindNextPicture(SvCodecInfo_t *Info,
                                         SvPictureInfo_t *PictureInfo);

/*
** sv_mpeg_decode.c
*/
extern SvStatus_t sv_MpegInitDecoder (SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegDecompressFrame(SvCodecInfo_t *, u_char *, u_char **);

/*
** sv_mpeg_block.c
*/
extern ScBoolean_t sv_MpegGetIntraBlock(
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                          int *dc_dct_pred);
extern ScBoolean_t sv_MpegGetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                          ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);
extern ScBoolean_t sv_Mpeg2GetIntraBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp,
                           int *dc_dct_pred);
extern ScBoolean_t sv_Mpeg2GetInterBlock(SvMpegDecompressInfo_t *MpegInfo,
                           ScBitstream_t *bs, SvMpegLayer_t *layer, int comp);

extern ScBoolean_t sv_MpegMotionVectors(ScBitstream_t *bs,
                            int PMV[2][2][2],
                            int dmvector[2], int mv_field_sel[2][2],
                            int s, int mv_count, int mv_format,
                            int h_r_size, int v_r_size, int dmv, int mvscale);
extern ScBoolean_t sv_MpegMotionVector(ScBitstream_t *bs,
                                int *PMV, int *dmvector,
                                int h_r_size, int v_r_size, 
                                int dmv, int mvscale, int full_pel_vector);
extern void sv_MpegCalcDMV(SvMpegDecompressInfo_t *MpegInfo,
                           int DMV[][2], int *dmvector, int mvx, int mvy);
extern int sv_MpegGetDClum_C(ScBitString_t bits, unsigned int *bitsleft);
extern int sv_MpegGetDCchrom_C(ScBitString_t bits, unsigned int *bitsleft);

/*
** sv_mpeg_block2.s
*/
extern void sv_MpegClearBlock_S(int *block);
extern int sv_MpegInterHuffToDCT_S(int *dctblk, unsigned int zzpos, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix);
extern int sv_MpegIntraHuffToDCT_S(int *dctblk, unsigned int comp, 
                        ScBitString_t bits, unsigned int *pbitsleft,
                        int quant_scale, int *quant_matrix,
                        int *dc_dct_pred);
extern int sv_MpegGetDClum_S(ScBitString_t  bits, unsigned int  *bitsleft);
extern int sv_MpegGetDCchrom_S(ScBitString_t bits, unsigned int *bitsleft);


/*
** sv_mpeg_recon.c
*/
extern void sv_MpegReconstruct(SvMpegDecompressInfo_t *MpegInfo,
                       unsigned char **newframe, int bx, int by,
                       int mb_type, int motion_type, int PMV[2][2][2],
                       int mv_field_sel[2][2], int dmvector[2], int stwtype);
extern void sv_MpegReconFieldBlock(int chroma,
                  unsigned char *src[], int sfield,
                  unsigned char *dst[], int dfield, int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);
extern void sv_MpegReconFrameBlock(int chroma,
                  unsigned char *src[], unsigned char *dst[], int lx, int lx2,
                  int w, int h, int x, int y, int dx, int dy, int addflag);


/*
** sv_mpeg_getmb.c
*/
extern int sv_MpegGetMBtype(SvMpegDecompressInfo_t *MpegInfo,
                            ScBitstream_t *bs, SvMpegLayer_t *layer);
extern int sv_MpegGetIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetDMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpIMBtype(SvMpegDecompressInfo_t *MpegInfo,
                             ScBitstream_t *bs);
extern int sv_MpegGetSpPMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSpBMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);
extern int sv_MpegGetSNRMBtype(SvMpegDecompressInfo_t *MpegInfo,
                               ScBitstream_t *bs);

extern int sv_MpegGetCBP(ScBitstream_t *bs);

/*
** sv_mpeg_422recon.c
*/
void sv_CopyCBP_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_C(int *cpbdata, unsigned char *np, unsigned int w);
void sv_MpegFrameCopy411to422i(unsigned char *refframe,
                              unsigned char *newframe,
                              int x, int y, unsigned int w,
                              int dx, int dy, unsigned char *tmpbuf);
void sv_MpegFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, unsigned char *newframe,
                    int x, int y, unsigned int w, int dx, int dy,
                    ScBoolean_t fdct, unsigned char *tmpbuf);
void sv_MpegDFrameMC411to422i(int *block, unsigned int cbp,
                    unsigned char *brefframe, unsigned char *frefframe,
                    unsigned char *newframe,
                    int x, int y, unsigned int w,
                    int bdx, int bdy, int fdx, int fdy, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegDFieldMC411to422i(int *block, unsigned int cbp,
                    unsigned char *refframe, int rfield0, int rfield1,
                    unsigned char *newframe, int x, int y, unsigned int w,
                    int dx0, int dy0, int dx1, int dy1, ScBoolean_t fdct,
                    unsigned char *tmpbuf);
void sv_MpegQFieldMC411to422i(int *blocks, unsigned int cbp,
                unsigned char *bframe, int bfield0, int bfield1,
                unsigned char *fframe, int ffield0, int ffield1,
                unsigned char *newframe, int x, int y, unsigned int w,
                int bdx0, int bdy0, int bdx1, int bdy1,
                int fdx0, int fdy0, int fdx1, int fdy1,
                ScBoolean_t fdct, unsigned char *tmpbuf);

/*
** sv_mpeg_422reconcbp.s
*/
void sv_CopyCBP_S(int *cpbdata, unsigned char *np, unsigned int w);
void sv_CopyCBPf_S(int *cpbdata, unsigned char *np, unsigned int w);

/*
** sv_mpeg_idct.c
*/
void sv_MpegIDCTToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_C(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);
void sv_MpegIDCTAddToFrame2_C(int *inbuf, unsigned char *rfp, int rinc,
                                       unsigned char *ffp, int finc, int comp);

/*
** sv_mpeg_idct2.s
*/
void sv_MpegIDCTToFrame_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrame_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_idct3.s
*/
void sv_MpegIDCTToFrameP_S(int *inbuf, unsigned char *rfp, int incr);
void sv_MpegIDCTAddToFrameP_S(int *inbuf, unsigned char *rfp, int incr);

/*
** sv_mpeg_init.c
*/
extern SvStatus_t sv_MpegInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegFreeEncoder(SvCodecInfo_t *Info);

/*
** sv_mpeg_encode.c
*/
extern SvStatus_t sv_MpegEncoderBegin(SvCodecInfo_t *Info);
extern SvStatus_t sv_MpegEncodeFrame(SvCodecInfo_t *Info, 
                                     unsigned char *InputImage);
extern SvStatus_t sv_MpegEncodeFrameInOrder(SvCodecInfo_t *Info,
                                     unsigned char *InputImage,
                                     unsigned int InputFourCC);
extern SvStatus_t sv_MpegEncoderEnd(SvCodecInfo_t *Info);

/*
** sv_mpeg_putpic.c
*/
extern void sv_MpegPutPict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *BS,
                           unsigned char *frame);

/*
** sv_mpeg_puthdr.c
*/
extern void sv_MpegPutSeqHdr(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqExt(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern void sv_MpegPutSeqDispExt(SvMpegCompressInfo_t *MpegInfo,
                                           ScBitstream_t *bs);
extern void sv_MpegPutUserData(ScBitstream_t *bs, char *userdata);
extern void sv_MpegPutGOPHdr(ScBitstream_t *bs, float frame_rate, int tco,
                       int frame, int closed_gop);
extern void sv_MpegPutSeqEnd(ScBitstream_t *bs);

/*
** sv_mpeg_motion.c
*/
extern void sv_MpegMotionEstimation(SvMpegCompressInfo_t *MpegInfo, 
                       unsigned char *oldorg, unsigned char *neworg,
                       unsigned char *oldref, unsigned char *newref,
                       unsigned char *cur, unsigned char *curref,
                       int sxf, int syf, int sxb, int syb,
                       struct mbinfo *mbi, int secondfield, int ipflag);

/*
** sv_mpeg_quantize.c
*/
int sv_MpegIntraQuant(short *src, short *dst, int dc_prec,
                unsigned char *quant_mat, int mquant, int mpeg1);
int sv_MpegNonIntraQuant(short *src, short *dst,
                    unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegIntraInvQuant(short *src, short *dst, int dc_prec,
                  unsigned char *quant_mat, int mquant, int mpeg1);
void sv_MpegNonIntraInvQuant(short *src, short *dst,
                      unsigned char *quant_mat, int mquant, int mpeg1);

/*
** sv_mpeg_transfrm.c
*/
void sv_MpegTransform(SvMpegCompressInfo_t *MpegInfo,
               unsigned char *pred[], unsigned char *cur[],
               struct mbinfo *mbi, short blocks[][64]);
void sv_MpegInvTransform(SvMpegCompressInfo_t *MpegInfo,
                unsigned char *pred[], unsigned char *cur[],
                struct mbinfo *mbi,short blocks[][64]);
void sv_MpegDCTtypeEstimation(SvMpegCompressInfo_t *MpegInfo,
                         unsigned char *pred, unsigned char *cur,
                         struct mbinfo *mbi);

/*
** sv_mpeg_predict.c
*/
extern void sv_MpegPredict(SvMpegCompressInfo_t *MpegInfo,
             unsigned char *reff[], unsigned char *refb[],
             unsigned char *cur[3], int secondfield, struct mbinfo *mbi);

/*
** sv_mpeg_ratectl.c
*/
extern void rc_init_seq(SvMpegCompressInfo_t *MpegInfo);
extern void rc_init_GOP(SvMpegCompressInfo_t *MpegInfo, int np, int nb);
extern void rc_init_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs,
                         unsigned char *frame);
extern void rc_update_pict(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);
extern int rc_start_mb(SvMpegCompressInfo_t *MpegInfo);
extern int rc_calc_mquant(SvMpegCompressInfo_t *MpegInfo,  ScBitstream_t *bs,
                         int j);
void sv_MpegVBVendofpic(ScBitstream_t *bs);
void sv_MpegVBVcalcdelay(SvMpegCompressInfo_t *MpegInfo, ScBitstream_t *bs);

#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             H.261 Prototypes                              */
/*---------------------------------------------------------------------------*/

/*
** sv_h261_init.c
*/
extern SvStatus_t svH261Init(SvCodecInfo_t *Info);
extern SvStatus_t svH261CompressInit(SvCodecInfo_t *Info);

extern SvStatus_t svH261SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH261GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH261GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH261SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH261GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h261_decompress.c
*/
extern SvStatus_t svH261Decompress(SvCodecInfo_t *Info,
                             u_char *MultiBuf, u_char **ImagePtr);
extern SvStatus_t svH261DecompressFree(SvHandle_t Svh);

/*
** sv_h261_compress.c
*/
extern SvStatus_t svH261Compress(SvCodecInfo_t *Info, u_char *InputImage);
extern SvStatus_t svH261CompressFree(SvHandle_t Svh);
extern SvStatus_t SvSetFrameSkip (SvHandle_t Svh, int FrameSkip);
extern SvStatus_t SvSetFrameCount (SvHandle_t Svh, int FrameCount);
extern SvStatus_t SvSetSearchLimit (SvHandle_t Svh, int SearchLimit);

extern SvStatus_t SvSetImageType (SvHandle_t Svh, int ImageType);
extern SvStatus_t SvGetFrameNumber (SvHandle_t Svh, u_int *FrameNumber);


#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*---------------------------------------------------------------------------*/
/*                              H263 Prototypes                              */
/*---------------------------------------------------------------------------*/
/*
** sv_h263_common.c
*/
extern SvStatus_t svH263SetParamInt(SvHandle_t Svh, SvParameter_t param, qword value);
extern qword      svH263GetParamInt(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamFloat(SvHandle_t Svh, SvParameter_t param, float value);
extern float      svH263GetParamFloat(SvHandle_t Svh, SvParameter_t param);
extern SvStatus_t svH263SetParamBoolean(SvHandle_t Svh, SvParameter_t param, ScBoolean_t value);
extern ScBoolean_t svH263GetParamBoolean(SvHandle_t Svh, SvParameter_t param);

/*
** sv_h263_decode.c
*/
extern SvStatus_t svH263InitDecompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Decompress(SvCodecInfo_t *Info, u_char **ImagePtr);
extern SvStatus_t svH263FreeDecompressor(SvCodecInfo_t *Info);
/*
** sv_h263_encode.c
*/
extern SvStatus_t svH263InitCompressor(SvCodecInfo_t *Info);
extern SvStatus_t svH263Compress(SvCodecInfo_t *Info, u_char *ImagePtr);
extern SvStatus_t svH263FreeCompressor(SvCodecInfo_t *Info);

#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*---------------------------------------------------------------------------*/
/*                             Huff Prototypes                               */
/*---------------------------------------------------------------------------*/

/*
** sv_huff_encode.c
*/
extern SvStatus_t sv_HuffInitEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeEncoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffEncodeFrame(SvCodecInfo_t *Info,
                                      unsigned char *InputImage);
extern SvStatus_t sv_HuffPutHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);


/*
** sv_huff_decode.c
*/
extern SvStatus_t sv_HuffInitDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffFreeDecoder(SvCodecInfo_t *Info);
extern SvStatus_t sv_HuffDecodeFrame(SvCodecInfo_t *Info,
                                     unsigned char *OutputImage);
extern SvStatus_t sv_HuffGetHeader(SvHuffInfo_t *HInfo, ScBitstream_t *bs);

/*
** sv_huff_encode.c
*/

#endif /* HUFF_SUPPORT */

#endif /* _SV_PROTOTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\dech26x.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h26x.h,v $
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0 
** 
** FILE NAME:   h26x.h  
** MODULE NAME: h26x.h
**
** MODULE DESCRIPTION: h261/h263 include file.
** 
** DESIGN OVERVIEW: 
** 
**--
*/
#ifndef _H26X_H_
#define _H26X_H_

#define VIDEO_FORMAT_DIGITAL_H261  mmioFOURCC('D', '2', '6', '1')
#define VIDEO_FORMAT_DIGITAL_H263  mmioFOURCC('D', '2', '6', '3')

/* H.263 encoder controls */
#define DECH26X_CUSTOM_ENCODER_CONTROL  0x6009

#define EC_RTP_HEADER      0
#define EC_RESILIENCY	   1
#define EC_PACKET_SIZE     2
#define EC_PACKET_LOSS     3
#define EC_BITRATE_CONTROL 4
#define EC_BITRATE         5

#define EC_SET_CURRENT                0
#define EC_GET_FACTORY_DEFAULT        1
#define EC_GET_FACTORY_LIMITS         2
#define EC_GET_CURRENT                3
#define EC_RESET_TO_FACTORY_DEFAULTS  4

/***** Settings for EC_RTP_HEADER ******/
#define EC_RTP_MODE_OFF               0
#define EC_RTP_MODE_A                 1
#define EC_RTP_MODE_B                 2
#define EC_RTP_MODE_C                 4

/***** example Custom Encoder call ******
  lRet = ICSendMessage(hIC,
                       DECH26X_CUSTOM_ENCODER_CONTROL,
                       MAKELPARAM(EC_RTP_HEADER, EC_SET_CURRENT),
                       (LPARAM)EC_RTP_MODE_A
                      );
  DWORD retval;
  lRet = ICSendMessage(hIC,
                       DECH26X_CUSTOM_ENCODER_CONTROL,
                       MAKELPARAM(EC_PACKET_SIZE, EC_GET_CURRENT),
                       (LPARAM)&retval
                      );
*****************************************/
#endif /* _H26X_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\audio.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_audio.c,v $
 * Revision 1.1.6.14  1996/12/13  18:19:06  Hans_Graves
 * 	Added initialization of AudioPTimeBase.
 * 	[1996/12/13  18:07:26  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/12/04  22:34:30  Hans_Graves
 * 	Make AC3 detection in audio streams more accurate.
 * 	[1996/12/04  22:19:21  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/11/18  23:07:34  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:36  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/11/11  18:21:06  Hans_Graves
 * 	Added AC3 support for multiplexed streams.
 * 	[1996/11/11  18:00:25  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/11/08  21:51:04  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:28:01  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/10/28  17:32:30  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:01  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/10/15  17:34:11  Hans_Graves
 * 	Added MPEG-2 Program Stream support. Fix MPEG-2 not skipping audio.
 * 	[1996/10/15  17:31:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/09/29  22:19:39  Hans_Graves
 * 	Removed SLIB_MODE_DECOMPRESS_QUERY.
 * 	[1996/09/29  21:33:10  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/09/25  19:16:46  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:51  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/09/18  23:46:37  Hans_Graves
 * 	Use slibSetMaxInput under MPEG
 * 	[1996/09/18  22:03:03  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/05/24  12:39:52  Hans_Graves
 * 	Disable debugging printfs
 * 	[1996/05/24  12:39:37  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/05/23  18:46:37  Hans_Graves
 * 	Merge fixes MME-1292, MME-1293, and MME-1304.
 * 	[1996/05/23  18:45:22  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/10  21:17:20  Hans_Graves
 * 	Fix calculation of audio lengths (NT)
 * 	[1996/05/10  20:44:27  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/04/22  15:04:53  Hans_Graves
 * 	Added slibValidateAudioParams()
 * 	[1996/04/22  14:43:35  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/04/01  16:23:14  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:58  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/29  22:21:33  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:56:58  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/21  22:52:45  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:51:03  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/19  18:03:56  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:40  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/13  18:47:48  Hans_Graves
 * 	Added slibSkipAudio()
 * 	[1996/02/13  18:41:27  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/02/07  23:23:56  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:31  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/02/02  17:36:03  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:46  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/31  14:50:39  Hans_Graves
 * 	Renamed SLIB_TYPE_WAVE to SLIB_TYPE_PCM_WAVE
 * 	[1996/01/31  14:50:27  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/15  16:26:29  Hans_Graves
 * 	Added MPEG 1 Audio compression support
 * 	[1996/01/15  15:46:07  Hans_Graves]
 *
 * Revision 1.1.2.5  1996/01/11  16:17:31  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:35  Hans_Graves]
 *
 * Revision 1.1.2.4  1996/01/08  16:41:32  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:05  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:06  Hans_Graves
 * 	Added MPEG audio decompression
 * 	[1995/11/09  23:08:41  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:55  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:03  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "mpeg.h"
#include "avi.h"
#ifdef AC3_SUPPORT
#include "ac3.h"
#endif /* AC3_SUPPORT */

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#ifdef AC3_SUPPORT
SlibBoolean_t slibParseAC3Header(SlibInfo_t *Info, SlibPin_t *srcpin,
                                 unsigned char *buf, unsigned dword size,
                                 int *channels, int *sps, int *bps)
{
  /*
   * Initial cut at parameters -
   * Update later using header parsing - ***tfm***
   */
  Info->AudioBitRate = 256000;
  *channels = 2;
  *sps = 48000;
  *bps = 16;
  _SlibDebug(_VERBOSE_,
     printf("AC3: bitrate=%d channels=%d sps=%d bps=%s\n",
                   Info->AudioBitRate, channels, sps, bps) );
  return(TRUE);
}
#endif /* AC3_SUPPORT */

void SlibUpdateAudioInfo(SlibInfo_t *Info)
{
  int channels=2, sps=44100, bps=16;
  SlibTime_t ptime=SLIB_TIME_NONE;
  _SlibDebug(_DEBUG_, printf("SlibUpdateAudioInfo()\n") );

  if (SlibTypeIsVideoOnly(Info->Type)) /* no audio? */
    return;
  if (Info->Mode == SLIB_MODE_COMPRESS)
  {
    switch (Info->Type)
    {
      case SLIB_TYPE_G723:
            //Initialize some info
            sps = 8000;
            bps = 16;
            channels =1;
            break;
      default:
            break;
    }
  }
  else if (Info->Mode == SLIB_MODE_DECOMPRESS)
  {
    SlibPin_t *srcpin;
    unsigned char *buf;
    unsigned dword size;

    switch (Info->Type)
    {
      case SLIB_TYPE_RIFF: /* might be WAVE format */
      case SLIB_TYPE_PCM_WAVE: /* might be WAVE format */
            srcpin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
            buf = slibSearchBuffersOnPin(Info, srcpin,
                                         NULL, &size, RIFF_WAVE, 4, FALSE);
            if (buf)
            {
              Info->Type = SLIB_TYPE_PCM_WAVE;
              buf = slibSearchBuffersOnPin(Info, srcpin,
                                           NULL, &size, RIFF_FORMAT, 4, FALSE);
              if (buf)
              {
                dword datasize=((int)buf[3]<<24) | (int)buf[2]<<16 |
                               (int)buf[1]<<8 | (int)buf[0];
                WAVE_format fmt;

                _SlibDebug(_DEBUG_,
                printf("datasize=%d\n", datasize);
                printf("%02X %02X %02X %02X\n", buf[0], buf[1], buf[2], buf[3]);
                printf("WAVE: SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
                     sps, bps, channels) );
                buf+=4; /* skip size */
                memcpy(&fmt, buf, sizeof(fmt));
                channels = fmt.nChannels;
                sps = fmt.nSamplesPerSec;
                if (datasize<sizeof(WAVE_format)) /* not PCM */
                  bps = 8;
                else
                  bps = fmt.wBitsPerSample;
                if ((sps*channels*bps)>800)
                  Info->AudioLength = (qword)(Info->FileSize*10L)/
                                      (qword)((sps*channels*bps)/800);
                if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
                  return;
                Info->AudioType=SLIB_TYPE_PCM;
              }
              else
                return; /* couldn't find format */
            }
            break;

#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_AUDIO:
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG_TRANSPORT:
      case SLIB_TYPE_MPEG_PROGRAM:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              if ((srcpin=slibLoadPin(Info, SLIB_DATA_PRIVATE))==NULL)
              {
                Info->AudioStreams = 0;
                _SlibDebug(_DEBUG_ || _WARN_,
                   printf("SlibUpdateAudioInfo() no private data found\n") );
                slibSetMaxInput(Info, 0); /* no limit to input data */
                return;
              }
              buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
              if (buf && size>=4)
              {
                _SlibDebug(_DEBUG_,
                  printf("AC3 Audio Head: %02X %02X %02X %02X\n",
                     buf[0], buf[1], buf[2], buf[3]));
                /* check for AC3 sync code, may be reverse ordered */
                if ((buf[0]==0x0B && buf[1]==0x77) ||
                    (buf[2]==0x0B && buf[3]==0x77) ||
                    (buf[0]==0x77 && buf[1]==0x0B) ||
                    (buf[2]==0x77 && buf[3]==0x0B))
                {
                  Info->AudioType=SLIB_TYPE_AC3_AUDIO;
                  _SlibDebug(_DEBUG_, printf("AC3 Audio Sync Word found\n") );
                }
              }
            }

            if (Info->AudioType==SLIB_TYPE_UNKNOWN ||
                Info->AudioType==SLIB_TYPE_MPEG1_AUDIO)
            {
              /* search for MPEG audio sync word */
              buf = NULL;
              slibSetMaxInput(Info, 10*1024); /* don't search too much */
              do {
                buf = slibSearchBuffersOnPin(Info, srcpin, buf, &size,
                                           0xFF, 1, FALSE);
              } while (buf && (*buf&0xF0) != 0xF0);
              slibSetMaxInput(Info, 0); /* no limit to input data */
              if (buf)
              {
                const char *mode_names[4] =
                { "stereo", "j-stereo", "dual-ch", "single-ch" };
                const char *layer_names[4] = { "?", "I", "II", "III" };
                const int mpeg_freq[4] = {44100, 48000, 32000, 0};
                const int bitrate[4][15] = {
                  {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
                  {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
                  {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
                  {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}
                };
                int bitrate_index, layer, mode, freq_index;
                _SlibDebug(_DEBUG_,
                  printf("MPEG Audio Head: %02X %02X %02X %02X\n",
                     buf[0], buf[1], buf[2], buf[3]));
                if ((*buf & 0xF0)==0xF0)
                {
                  layer = 4-((*buf>>1) & 0x03);
                  buf++; size--;
                  bitrate_index = *buf >> 4;
                  freq_index = (*buf>>2) & 0x03;
                  buf++; size--;
                  mode = *buf >> 6;

                  Info->AudioBitRate = bitrate[layer][bitrate_index]*1000;
                  channels = mode==3 ? 1 : 2;
                  sps = mpeg_freq[freq_index];
                  bps = 16;
                  if (Info->AudioBitRate>100)
                    Info->AudioLength = (qword)(Info->FileSize*80L)/
                                        (qword)(Info->AudioBitRate/100);
                  _SlibDebug(_VERBOSE_,
                   printf("layer=%d bitrate=%d(%d) mode=%s freq(%d)=%d\n",
                     layer, bitrate[layer][bitrate_index], bitrate_index,
                     mode_names[mode], freq_index, mpeg_freq[freq_index]) );
                  if (layer<=2 && Info->AudioBitRate>0 &&
                                 Info->AudioBitRate<10000000) /* valid header */
                    Info->AudioType=SLIB_TYPE_MPEG1_AUDIO;
                  else
                    Info->AudioBitRate=0;
                }
              }
            }
            if (Info->AudioType==SLIB_TYPE_UNKNOWN ||
                Info->AudioType==SLIB_TYPE_AC3_AUDIO)
            {
#ifdef AC3_SUPPORT
              _SlibDebug(_VERBOSE_,
                 printf("Searching for AC-3 on %s\n", srcpin->name) );
              /* Search for AC-3 sync word */
              slibSetMaxInput(Info, 1000*1024);
              buf = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                               AC3_SYNC_WORD_REV, AC3_SYNC_WORD_LEN/8, FALSE);
              slibSetMaxInput(Info, 0); /* no limit to input data */
              if (buf) /* found sync word */
              {
                Info->AudioType=SLIB_TYPE_AC3_AUDIO;
                _SlibDebug(_VERBOSE_, printf("AC3\n"));
                slibParseAC3Header(Info, srcpin, buf, size,
                                         &channels, &sps, &bps);
                if (srcpin->ID==SLIB_DATA_PRIVATE)
                {
                  /* the private data pin now become the audio pin */
                  slibRenamePin(Info, SLIB_DATA_PRIVATE, SLIB_DATA_AUDIO,
                                        "Audio");
                  /* audio will be pulled from PRIVATE packets */
                  Info->AudioMainStream=MPEG_PRIVATE_STREAM1_BASE;
                }
              }
              else
              {
                slibRemovePin(Info, SLIB_DATA_AUDIO);
                return;
              }
#else /* !AC3_SUPPORT */
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
#endif /* !AC3_SUPPORT */
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
      case SLIB_TYPE_AC3_AUDIO:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              Info->AudioStreams = 0;
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              slibSetMaxInput(Info, 0);
              return;
            }

            /* buf = slibGetBufferFromPin(Info, srcpin, &size, NULL); */
		
            /* Search for AC-3 sync word */
            buf = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                               AC3_SYNC_WORD_REV, AC3_SYNC_WORD_LEN/8, FALSE);
            slibSetMaxInput(Info, 0);
            if (buf)
            {
              slibParseAC3Header(Info, srcpin, buf, size,
                                         &channels, &sps, &bps);
              if (Info->AudioBitRate>100)
                Info->AudioLength = (qword)(Info->FileSize*80L)/
                                    (qword)(Info->AudioBitRate/100);
            }
            else
            {
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
            }
            Info->AudioType=SLIB_TYPE_AC3_AUDIO;
            break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
            slibSetMaxInput(Info, 1000*1024);
            if ((srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO))==NULL)
            {
              Info->AudioStreams = 0;
              _SlibDebug(_DEBUG_ || _WARN_,
                 printf("SlibUpdateAudioInfo() no audio data found\n") );
              slibSetMaxInput(Info, 0);
              return;
            }
            slibSetMaxInput(Info, 0);
            buf = slibPeekBufferOnPin(Info, srcpin, &size, NULL);
            if (buf)
            {
              /* we need to parse the G.723 frame header to
               * get the actual bitrate
               */
              if(buf[0] & 0x1) /* read the rate bit in the G.723 frame header */
                Info->AudioBitRate=5333;
              else
                Info->AudioBitRate=6400;
              if (Info->AudioBitRate>0)
                Info->AudioLength = (qword)(Info->FileSize*80L)/
                                    (qword)(Info->AudioBitRate/100);
            }
            else
            {
              slibRemovePin(Info, SLIB_DATA_AUDIO);
              return;
            }
            //Initialize some info
            sps = 8000;
            bps = 16;
            channels =1;
            Info->AudioType=SLIB_TYPE_G723;
            break;
#endif /*G723_SUPPORT*/
      default:
            return;
    }
  }
  Info->AudioStreams = 1;
  if (SlibTypeHasTimeStamps(Info->Type))
  {
    ptime=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
    if (SlibTimeIsValid(ptime))
      Info->AudioPTimeBase=ptime;
  }
  /* round sample rate to nearest valid rate */
  if (sps<=8000)
    sps=8000;
  else if (sps<=11025)
    sps=11025;
  else if (sps<=22050)
    sps=22050;
  else if (sps<=32000)
    sps=32000;
  else if (sps<=44100)
    sps=44100;
  Info->SamplesPerSec = sps;
  Info->BitsPerSample = bps;
  Info->Channels = channels;
  if (Info->CompAudioFormat==NULL)
    Info->CompAudioFormat=(WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX));
  if (Info->CompAudioFormat!=NULL)
  {
    Info->CompAudioFormat->wFormatTag = WAVE_FORMAT_PCM;
    Info->CompAudioFormat->nChannels = (WORD)channels;
    Info->CompAudioFormat->wBitsPerSample = (WORD)bps;
    Info->CompAudioFormat->nSamplesPerSec = sps;
    Info->CompAudioFormat->nBlockAlign = bps>>3 * channels;
    Info->CompAudioFormat->nAvgBytesPerSec =
                      Info->CompAudioFormat->nBlockAlign * sps;
  }
  if (Info->AudioFormat==NULL)
    Info->AudioFormat=(WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX));
  if (Info->AudioFormat!=NULL)
  {
    Info->AudioFormat->wFormatTag = WAVE_FORMAT_PCM;
    Info->AudioFormat->nChannels = (WORD)channels;
    Info->AudioFormat->wBitsPerSample = (WORD)bps;
    Info->AudioFormat->nSamplesPerSec = sps;
    Info->AudioFormat->nBlockAlign = (bps>>3) * channels;
    Info->AudioFormat->nAvgBytesPerSec =
                      Info->AudioFormat->nBlockAlign * sps;
  }
}

SlibTime_t slibSkipAudio(SlibInfo_t *Info, SlibStream_t stream,
                                           SlibTime_t timems)
{
  dword timeskipped=0, samples=0, frames=0;
  SlibPin_t *srcpin;
  if (Info->AudioStreams<=0)
    return(0);
  srcpin=slibLoadPin(Info, SLIB_DATA_AUDIO);
  if (!srcpin)
    return(0);
  _SlibDebug(_VERBOSE_, printf("slibSkipAudio(stream=%d, %d ms)\n",
                                      stream,timems) );
  switch (Info->AudioType)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
            {
              unsigned char *buf, *bufstart;
              unsigned dword size, sps, channels, layer;
              static const int layer_samples[4] = {384, 384, 1152, 1152};
              static const int mpeg_freq[4] = {44100, 48000, 32000, 0};
              while (timeskipped<timems)
              {
                do {
                  bufstart=buf=slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
                                               0xFF, 1, TRUE);
                  _SlibDebug(_WARN_ && size==0, printf("SkipAudio() size=0\n"));
                  if (!bufstart)
                    return(timeskipped);
                  if ((buf[0]&0xF0)==0xF0 && buf[0]!=0xFF)
                    break;
                  else
                    slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
                } while (1);
                frames++;
                layer = 4-((*buf>>1) & 0x03);
                buf++; size--;
                if (!size)
                {
                  SlibFreeBuffer(bufstart);
                  bufstart=buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
                  if (!bufstart)
                    return(timeskipped);
                }
                sps = mpeg_freq[(*buf>>2) & 0x03];
                buf++; size--;
                if (!size)
                {
                  SlibFreeBuffer(bufstart);
                  bufstart=buf=slibGetBufferFromPin(Info, srcpin, &size, NULL);
                  if (!bufstart)
                    return(timeskipped);
                }
                channels = (*buf >> 6)==3 ? 1 : 2;
                buf++; size--;
                samples+=layer_samples[layer];
                if (sps)
                  timeskipped=(1000*samples)/sps;
                _SlibDebug(_DEBUG_,
                  printf("samples=%d timeskipped=%d\n", samples, timeskipped));
                if (size)
                {
                  SlibAllocSubBuffer(buf, size);
                  slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
                }
                SlibFreeBuffer(bufstart);
              }
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
    case SLIB_TYPE_AC3_AUDIO:
      /* For better audio/video synchronization - add Dolby AC-3 support here */
            break;
#endif /* AC3_SUPPORT */
    default:
            break;
  }
  _SlibDebug(_VERBOSE_,
        printf("slibSkipAudio() frames=%d samples=%d timeskipped=%d ms\n",
                                     frames, samples, timeskipped));
  return(timeskipped);
}


SlibStatus_t slibValidateAudioParams(SlibInfo_t *Info)
{
  return(SlibErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\buffer.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_buffer.c,v $
 * Revision 1.1.6.26  1996/12/13  18:19:07  Hans_Graves
 * 	Check for valid pin pointer in slibGetNextTimeOnPin().
 * 	[1996/12/13  18:08:27  Hans_Graves]
 *
 * Revision 1.1.6.25  1996/12/10  19:21:58  Hans_Graves
 * 	Fix MPEG Systems encoding bug.
 * 	[1996/12/10  19:15:33  Hans_Graves]
 * 
 * Revision 1.1.6.24  1996/12/04  22:34:32  Hans_Graves
 * 	Enable AC3 detection in PRIVATE packets.
 * 	[1996/12/04  22:18:48  Hans_Graves]
 * 
 * Revision 1.1.6.23  1996/12/03  23:15:16  Hans_Graves
 * 	Fixed updating of offset value for buffers on pins.
 * 	[1996/12/03  23:09:51  Hans_Graves]
 * 
 * Revision 1.1.6.22  1996/12/03  00:08:33  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:06:03  Hans_Graves]
 * 
 * Revision 1.1.6.21  1996/11/18  23:07:36  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:40  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/11/13  16:10:56  Hans_Graves
 * 	Skip AC3 header in private packets.
 * 	[1996/11/13  16:03:50  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/11/11  18:21:07  Hans_Graves
 * 	Added AC3 support for multiplexed streams.
 * 	[1996/11/11  18:00:27  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/08  21:51:06  Hans_Graves
 * 	Added AC3 support. Fixed Program Stream demultiplexing.
 * 	[1996/11/08  21:31:43  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/10/31  21:58:09  Hans_Graves
 * 	Turned of debugging code.
 * 	[1996/10/31  21:57:56  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/10/31  21:55:47  Hans_Graves
 * 	Fix bad multiplexing when encoding to MPEG Systems.
 * 	[1996/10/31  21:15:01  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/10/29  17:04:59  Hans_Graves
 * 	Add padding packets support for MPEG Systems Encoding.
 * 	[1996/10/29  17:04:45  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/28  17:32:32  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:03  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/17  00:23:34  Hans_Graves
 * 	Fix buffer problems after SlibQueryData() calls.
 * 	[1996/10/17  00:19:14  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/15  17:34:13  Hans_Graves
 * 	Added MPEG-2 Program Stream support.
 * 	[1996/10/15  17:30:30  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/12  17:18:54  Hans_Graves
 * 	Added parsing of Decode and Presentation timestamps with MPEG Transport.
 * 	[1996/10/12  17:01:55  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/10/03  19:14:24  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:38  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/29  22:19:41  Hans_Graves
 * 	Added debugging printf's
 * 	[1996/09/29  21:30:27  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/25  19:16:48  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:53  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/18  23:46:48  Hans_Graves
 * 	MPEG2 Systems parsing fixes. Added Audio presentation timestamps to MPEG1 Systems writing
 * 	[1996/09/18  22:06:07  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/08/09  20:51:48  Hans_Graves
 * 	Fix callbacks with user buffers
 * 	[1996/08/09  20:11:06  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/07/19  02:11:13  Hans_Graves
 * 	Added support for SLIB_MSG_BUFDONE with user buffers.
 * 	[1996/07/19  02:02:53  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/06/07  18:26:12  Hans_Graves
 * 	Merge MME-01326. Encoded MPEG-1 Systems files now include Presentation timestamps
 * 	[1996/06/07  17:54:11  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/10  21:17:27  Hans_Graves
 * 	Add Callback support.
 * 	[1996/05/10  20:58:39  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/07  19:56:22  Hans_Graves
 * 	Added HUFF_SUPPORT.
 * 	[1996/05/07  17:20:50  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/05/02  17:10:35  Hans_Graves
 * 	Better checking for NULL pointers in ParseMpeg2Systems(). Fixes MME-01234
 * 	[1996/05/02  17:05:46  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/24  22:33:46  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:13  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/23  15:36:42  Hans_Graves
 * 	Added MPEG 1 Systems packet recovery
 * 	[1996/04/23  15:35:23  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/19  21:52:24  Hans_Graves
 * 	MPEG 1 Systems writing enhancements
 * 	[1996/04/19  21:47:53  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/01  19:07:54  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:37  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  16:23:16  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:16:00  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/03/29  22:21:35  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:57:01  Hans_Graves]
 * 
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:55:57  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:52  Hans_Graves
 * 	Changed hard coded File buffer size to param
 * 	[1996/03/12  15:57:23  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:46  Hans_Graves
 * 	Increased Buffer size
 * 	[1996/03/08  18:40:59  Hans_Graves]
 * 
 * Revision 1.1.2.13  1996/02/23  22:17:09  Hans_Graves
 * 	Fixed bad handling of large packets in ParseMpeg1()
 * 	[1996/02/23  21:56:15  Hans_Graves]
 * 
 * Revision 1.1.2.12  1996/02/21  22:52:46  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:51:11  Hans_Graves]
 * 
 * Revision 1.1.2.11  1996/02/19  20:09:29  Hans_Graves
 * 	Debugging message clean-up
 * 	[1996/02/19  20:08:34  Hans_Graves]
 * 
 * Revision 1.1.2.10  1996/02/19  18:03:58  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:43  Hans_Graves]
 * 
 * Revision 1.1.2.9  1996/02/13  18:47:50  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:40:40  Hans_Graves]
 * 
 * Revision 1.1.2.8  1996/02/07  23:23:57  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:34  Hans_Graves]
 * 
 * Revision 1.1.2.7  1996/02/06  22:54:07  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:45:02  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/01/30  22:23:09  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:41  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/15  16:26:31  Hans_Graves
 * 	Reorganized Parsing, Added Wave file support
 * 	[1996/01/15  15:46:56  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/01/11  16:17:32  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:38  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  16:41:34  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:07  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/12/08  20:01:23  Hans_Graves
 * 	Creation. Split off from slib_api.c
 * 	[1995/12/08  19:57:18  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#ifdef WIN32
#include <io.h>
#endif
#include <stdio.h>
#ifdef _SHM_
#include  <sys/ipc.h>  /* shared memory */
#endif
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
#include "mpeg.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"
#define _DEBUG_     0  /* detailed debuging statements: if >1 more detail */
#define _VERBOSE_   0  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior: 2=lower warnings */
#define _MEMORY_    0  /* memory debugging: if >1 more detail */
#define _WRITE_     0  /* data writing debugging */
#define _TIMECODE_  0  /* timecode/timestamp debugging */
#define _PARSE_     0  /* parsing debugging */

#endif

/************************** Memory Allocation ***********************/
typedef struct slibMemory_s {
    unsigned char *address;
    long           shmid;
    unsigned dword   size;
    int            count;
    ScBoolean_t    user;
    SlibInfo_t    *sinfo;
    void          *uinfo; /* userdata */
    struct slibMemory_s *next;
} slibMemory_t;

static slibMemory_t *_slibMemoryList = NULL;
static slibMemory_t *_slibMemoryListTail = NULL;
static dword _slibMemoryCount = 0;
static unsigned qword _slibMemoryUsed = 0L;
#ifdef WIN32
static HANDLE _slibMemoryMutex = NULL;
#define slibInitMemoryMutex()  if (_slibMemoryMutex==NULL) \
                                 _slibMemoryMutex=CreateMutex(NULL, FALSE, NULL)
#define slibFreeMemoryMutex()  if (_slibMemoryMutex!=NULL) \
                               CloseHandle(_slibMemoryMutex); _slibMemoryMutex=NULL
#define slibEnterMemorySection()  WaitForSingleObject(_slibMemoryMutex, 5000);
#define slibExitMemorySection()   ReleaseMutex(_slibMemoryMutex)
#else
#define slibInitMemoryMutex()
#define slibFreeMemoryMutex()
#define slibEnterMemorySection()
#define slibExitMemorySection()
#endif



void slibDumpMemory()
{
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      printf("address: %p  size: %d  count: %d  user: %s\n",
              tmpmem->address, tmpmem->size, tmpmem->count,
              tmpmem->user ? "TRUE" : "FALSE");
      tmpmem = tmpmem->next;
    }
  }
  else
    printf("No memory allocated\n");
}

unsigned qword SlibMemUsed()
{
  return(_slibMemoryUsed);
}

void *SlibAllocBuffer(unsigned dword bytes)
{
  unsigned char *address;
  _SlibDebug(_MEMORY_,
    printf("SlibAllocBuffer(%d) MemoryCount=%d Used=%d\n", 
            bytes, _slibMemoryCount, _slibMemoryUsed));
  if (bytes<=0)
    return(NULL);
  address=ScAlloc(bytes);
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
    {
      ScFree(address);
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = NULL;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocBuffer() couldn't alloc\n") );
  return(address);
}

/*
** Name: SlibAllocBufferEx
** Desc: Allocate a buffer that is associated with a specific handle
*/
void *SlibAllocBufferEx(SlibHandle_t handle, unsigned dword bytes)
{
  unsigned char *address;
  _SlibDebug(_MEMORY_,
    printf("SlibAllocBufferEx(%p, bytes=%d) MemoryCount=%d Used=%d\n", 
            handle, bytes, _slibMemoryCount, _slibMemoryUsed));
  if (bytes<=0)
    return(NULL);
  address=ScAlloc(bytes);
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
    {
      ScFree(address);
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = handle;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocBufferEx() couldn't alloc\n") );
  return(address);
}

void *SlibAllocSharedBuffer(unsigned dword bytes, int *shmid)
{
  unsigned char *address;
  long id;
  _SlibDebug(_MEMORY_, printf("SlibAllocSharedBuffer(%d)\n", bytes) );
  if (bytes<=0)
    return(NULL);
#ifdef _SHM_
  id = shmget(IPC_PRIVATE, bytes, IPC_CREAT|0777);
  if (id < 0)
    return(NULL);
  address = (unsigned char *)shmat(id, 0, 0);
  if (address == ((caddr_t) -1))
    return(NULL);
#else
  address=(unsigned char *)ScPaMalloc(bytes);
  id=0;
#endif

  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    _SlibDebug((_MEMORY_||_WARN_) && (((unsigned dword)address)&0x03),
             printf("SlibAllocSharedBuffer(%d) Unaligned address=%p shmid=%d\n",
                 bytes, address, id) );
    if (!tmpmem)
    {
#ifdef _SHM_
      shmdt (address);
      shmctl(id, IPC_RMID, 0);
#else
      ScPaFree(address);
#endif
      return(NULL);
    }
    tmpmem->address = address;
    tmpmem->shmid = id;
    _SlibDebug(_MEMORY_ && id>=0,
             printf("SlibAllocSharedBuffer(%d) address=%p shmid=%d\n",
                 bytes, address, id) );
    tmpmem->size = bytes;
    tmpmem->count = 1;
    tmpmem->user = FALSE;
    tmpmem->sinfo = NULL;
    tmpmem->uinfo = NULL;
    slibInitMemoryMutex();
    slibEnterMemorySection();
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    slibExitMemorySection();
    if (shmid)
      *shmid = id;
  }
  return(address);
}

dword SlibGetSharedBufferID(void *address)
{
  dword shmid=-1;
  _SlibDebug(_MEMORY_,
    printf("SlibGetSharedBufferID(%p) _slibMemoryCount=%d\n", 
                         address, _slibMemoryCount));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
          (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        shmid=tmpmem->shmid;
        break;
      }
      tmpmem = tmpmem->next;
    }
  }
  slibExitMemorySection();
  return(shmid);
}

/*
** Name: SlibValidBuffer
** Desc: Check if an address is in a SLIB allocated buffer.
*/
SlibBoolean_t SlibValidBuffer(void *address)
{
  SlibBoolean_t isvalid=FALSE;
  _SlibDebug(_MEMORY_,
    printf("SlibValidBuffer(%p) _slibMemoryCount=%d\n", 
                         address, _slibMemoryCount));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
          (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        isvalid=TRUE;
        break;
      }
      tmpmem = tmpmem->next;
    }
  }
  slibExitMemorySection();
  return(isvalid);
}

SlibStatus_t SlibFreeBuffer(void *address)
{
  _SlibDebug(_MEMORY_>1,
    printf("SlibFreeBuffer(%p) MemoryCount=%d Used=%d\n", 
            address, _slibMemoryCount, _slibMemoryUsed));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    slibMemory_t *lastmem = NULL;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address &&
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if (--tmpmem->count>0)  /* memory was allocated more than once */
        {
          slibExitMemorySection();
          return(SlibErrorNone);
        }
        _SlibDebug(_MEMORY_,  
                    printf("SlibFreeBuffer(%p) final free: shmid=%d size=%d\n",
                        tmpmem->address, tmpmem->shmid, tmpmem->size) );
        /* remove memory from mem list */
        if (tmpmem == _slibMemoryList)
          _slibMemoryList = tmpmem->next;
        else
          lastmem->next = tmpmem->next;
        if (tmpmem == _slibMemoryListTail)
          _slibMemoryListTail = lastmem;
        /* now actually free the memory */
        if (tmpmem->user)
        {
          if (tmpmem->sinfo && tmpmem->sinfo->SlibCB)
          {
            slibExitMemorySection();
            _SlibDebug(_VERBOSE_,
              printf("SlibFreeBuffer() SlibCB(SLIB_MSG_BUFDONE, %p, %d)\n",
                     tmpmem->address, tmpmem->size) );
            tmpmem->user=FALSE;
            (*(tmpmem->sinfo->SlibCB))((SlibHandle_t)tmpmem->sinfo,
                        SLIB_MSG_BUFDONE, (SlibCBParam1_t)tmpmem->address, 
                                          (SlibCBParam2_t)tmpmem->size,
                        tmpmem->uinfo?tmpmem->uinfo
                                     :(void *)tmpmem->sinfo->SlibCBUserData);
            slibEnterMemorySection();
          }
        }
        else if (tmpmem->shmid < 0)
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() ScFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScFree(tmpmem->address);
        }
        else  /* shared memory */
#ifdef _SHM_
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() shmdt(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          shmdt (tmpmem->address);
          shmctl(tmpmem->shmid, IPC_RMID, 0);
        }
#else
        {
          _SlibDebug(_MEMORY_,
                printf("SlibFreeBuffer() ScPaFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScPaFree(tmpmem->address);
        }
#endif
        _slibMemoryCount--;
        _slibMemoryUsed-=tmpmem->size;
        ScFree(tmpmem);
        slibExitMemorySection();
        if (_slibMemoryList==NULL) /* last memory in list was freed */
        {
          slibFreeMemoryMutex();
        }
        return(SlibErrorNone);
      }
      lastmem = tmpmem;
      _SlibDebug(_VERIFY_ && (tmpmem == tmpmem->next),
                 printf("SlibFreeBuffer() tmpmem == tmpmem->next\n");
                 return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (tmpmem->next==_slibMemoryList),
                 printf("SlibFreeBuffer() tmpmem->next == _slibMemoryList\n");
                 return(SlibErrorMemory) );
      tmpmem = tmpmem->next;
    }
  }
  _SlibDebug(_WARN_, printf("SlibFreeBuffer(%p) couldn't free\n",address) );
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}

/*
** Name:    SlibFreeBuffers
** Purpose: Free all buffers associated with a handle.
**          If handle==NULL free all memory.
*/
SlibStatus_t SlibFreeBuffers(SlibHandle_t handle)
{
  _SlibDebug(_MEMORY_>1,
    printf("SlibFreeBuffers() MemoryCount=%d Used=%d\n", 
            _slibMemoryCount, _slibMemoryUsed));
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    slibMemory_t *lastmem = NULL, *nextmem=NULL;
    while (tmpmem)
    {
      nextmem = tmpmem->next;
      if (handle==NULL || tmpmem->sinfo==handle)
      {
        _SlibDebug(_MEMORY_,  
                    printf("SlibFreeBuffer(%p) final free: shmid=%d size=%d\n",
                        tmpmem->address, tmpmem->shmid, tmpmem->size) );
        /* remove memory from mem list */
        if (tmpmem == _slibMemoryList)
          _slibMemoryList = tmpmem->next;
        else
          lastmem->next = tmpmem->next;
        if (tmpmem == _slibMemoryListTail)
          _slibMemoryListTail = lastmem;
        /* now actually free the memory */
        if (tmpmem->user)
        {
          if (tmpmem->sinfo && tmpmem->sinfo->SlibCB)
          {
            slibExitMemorySection();
            _SlibDebug(_VERBOSE_,
              printf("SlibFreeBuffer() SlibCB(SLIB_MSG_BUFDONE, %p, %d)\n",
                     tmpmem->address, tmpmem->size) );
            tmpmem->user=FALSE;
            (*(tmpmem->sinfo->SlibCB))((SlibHandle_t)tmpmem->sinfo,
                        SLIB_MSG_BUFDONE, (SlibCBParam1_t)tmpmem->address, 
                                          (SlibCBParam2_t)tmpmem->size,
                        tmpmem->uinfo?tmpmem->uinfo
                                     :(void *)tmpmem->sinfo->SlibCBUserData);
            slibEnterMemorySection();
          }
        }
        else if (tmpmem->shmid < 0)
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() ScFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScFree(tmpmem->address);
        }
        else  /* shared memory */
#ifdef _SHM_
        {
          _SlibDebug(_MEMORY_, printf("SlibFreeBuffer() shmdt(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          shmdt (tmpmem->address);
          shmctl(tmpmem->shmid, IPC_RMID, 0);
        }
#else
        {
          _SlibDebug(_MEMORY_,
                printf("SlibFreeBuffer() ScPaFree(%p) %d bytes\n",
                     tmpmem->address, tmpmem->size) );
          ScPaFree(tmpmem->address);
        }
#endif
        _slibMemoryCount--;
        _slibMemoryUsed-=tmpmem->size;
        ScFree(tmpmem);
        if (_slibMemoryList==NULL) /* last memory in list was freed */
        {
          slibExitMemorySection();
          slibFreeMemoryMutex();
          return(SlibErrorNone);
        }
      }
      lastmem = tmpmem;
      _SlibDebug(_VERIFY_ && (tmpmem == nextmem),
                 printf("SlibFreeBuffer() tmpmem == tmpmem->next\n");
                 return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (nextmem==_slibMemoryList),
                 printf("SlibFreeBuffer() tmpmem->next == _slibMemoryList\n");
                 return(SlibErrorMemory) );
      tmpmem = nextmem;
    }
  }
  slibExitMemorySection();
  return(SlibErrorNone);
}

/*
** Name:    SlibAllocSubBuffer
** Purpose: Allocate a subsection of a buffer.
*/
SlibStatus_t SlibAllocSubBuffer(void *address, unsigned dword bytes)
{
  _SlibDebug(_MEMORY_>1, printf("SlibAllocSubBuffer() _slibMemoryCount=%d\n",
                                                _slibMemoryCount) );
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if ((char *)address+bytes>tmpmem->address+tmpmem->size)
        {
          _SlibDebug(_VERIFY_, 
              printf("SlibAllocSubBuffer(bytes=%d) out of range by %d bytes\n",
                bytes,(unsigned long)(tmpmem->address+tmpmem->size)
                      -(unsigned long)((char *)address+bytes)) );
          slibExitMemorySection();
          return(SlibErrorMemory);
        }
        tmpmem->count++;
        slibExitMemorySection();
        return(SlibErrorNone);
      }
      _SlibDebug(_VERIFY_ && (tmpmem == tmpmem->next),
               printf("SlibAllocSubBuffer() tmpmem == tmpmem->next\n");
               return(SlibErrorMemory) );
      _SlibDebug(_VERIFY_ && (tmpmem->next==_slibMemoryList),
               printf("SlibAllocSubBuffer() tmpmem->next == _slibMemoryList\n");
               return(SlibErrorMemory) );
      tmpmem = tmpmem->next;
    }
  }
  _SlibDebug(_WARN_ && address==NULL, 
                printf("SlibAllocSubBuffer() couldn't alloc\n") );
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}

/*
** Name:    SlibManageUserBuffer
** Purpose: Add a user's buffer to the memory queue, in order to keep
**          track of it.
*/
SlibStatus_t slibManageUserBuffer(SlibInfo_t *Info, void *address, 
                                  unsigned dword bytes, void *userdata)
{
  _SlibDebug(_MEMORY_, printf("slibManageUserBuffer() _slibMemoryCount=%d\n",
                                                _slibMemoryCount) );
  slibEnterMemorySection();
  if (_slibMemoryList)
  {
    slibMemory_t *tmpmem = _slibMemoryList;
    while (tmpmem)
    {
      if ((unsigned char *)address>=tmpmem->address && 
	  (unsigned char *)address<tmpmem->address+tmpmem->size)
      {
        if ((char *)address+bytes>tmpmem->address+tmpmem->size)
        {
          _SlibDebug(_VERIFY_, 
              printf("SlibAllocSubBuffer(bytes=%d) out of range by %d bytes\n",
                bytes,(unsigned long)(tmpmem->address+tmpmem->size)
                      -(unsigned long)((char *)address+bytes)) );
          slibExitMemorySection();
          return(SlibErrorMemory);
        }
        if (tmpmem->user == TRUE) /* already a user buffer */
          tmpmem->count++;
        else
          tmpmem->user = TRUE;
        if (Info)
          tmpmem->sinfo=Info;
        if (userdata)
          tmpmem->uinfo = userdata;
        _SlibDebug(_MEMORY_,
                   printf("slibManageUserBuffer() Allocated by SLIB: %p\n",
                            address) );
        slibExitMemorySection();
        return(SlibErrorNone);
      }
      tmpmem = tmpmem->next;
    }
  }
  if (address)
  {
    slibMemory_t *tmpmem = ScAlloc(sizeof(slibMemory_t));
    if (!tmpmem)
      return(SlibErrorMemory);
    tmpmem->address = address;
    tmpmem->shmid = -1;
    tmpmem->size = bytes;
    tmpmem->count = 1;   /* was not allocated by SLIB */
    tmpmem->user = TRUE;
    tmpmem->sinfo = Info;
    tmpmem->uinfo = userdata;
    tmpmem->next = _slibMemoryList;
    if (_slibMemoryList == NULL)
      _slibMemoryListTail = tmpmem;
    _slibMemoryList = tmpmem;
    _slibMemoryCount++;
    _slibMemoryUsed+=bytes;
    _SlibDebug(_MEMORY_,
                   printf("slibManageUserBuffer() New memory entry\n") );
    slibExitMemorySection();
    return(SlibErrorNone);
  }
  slibExitMemorySection();
  return(SlibErrorBadArgument);
}


/************************** Internal Buffer Stuff ***********************/

#define _getbyte(var) \
     if (top==bot) { \
        var = *buf++; \
        if (--bufsize==0) { \
          if (discard) { \
            SlibFreeBuffer(bufstart); \
            buf=bufstart=slibGetBufferFromPin(Info, pin, &bufsize, NULL); \
          } \
          else \
            buf=slibPeekNextBufferOnPin(Info, pin, buf-1, &bufsize, NULL); \
          if (!buf) return(NULL); \
        } \
     } else var=sbyte[top++];

#define _storebyte(val)  if (top==bot) {top=0; bot=1; sbyte[0]=val; } \
                             else sbyte[bot++]=val;

unsigned char *slibSearchBuffersOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned char *lastbuf, unsigned dword *size,
                                 unsigned dword code, int codebytes,
                                 ScBoolean_t discard)
{
  unsigned char *buf, *bufstart;
  unsigned char abyte, byte0, byte1, byte2, byte3, sbyte[16];
  int bot, top;
  unsigned dword bufsize;
  _SlibDebug(_DEBUG_>1, 
        printf("slibSearchBuffersOnPin(%s, code=0x%08lX, codebytes=%d)\n",
                          pin->name, code, codebytes) );
  if (!Info || !pin)
    return(NULL);
  for (top=codebytes-1; top>=0; top--)
  {
    sbyte[top]=code & 0xFF;
    code>>=8;
  }
  byte0=sbyte[0];
  byte1=sbyte[1];
  byte2=sbyte[2];
  byte3=sbyte[3];
  top=bot=0;
  if (lastbuf)
  {
    buf=bufstart=lastbuf;
    bufsize=*size;
  }
  else if (discard)
  {
    buf=bufstart=slibGetBufferFromPin(Info, pin, &bufsize, NULL);
  }
  else
    buf=slibPeekBufferOnPin(Info, pin, &bufsize, NULL);
  if (!buf || codebytes<=0 || !bufsize)
  {
    _SlibDebug(_WARN_ && buf==lastbuf, 
             printf("slibSearchBuffersOnPin(%s) no search made\n",pin->name) );
    return(buf);
  }
/*
  ScDumpChar(buf,bufsize,0);
*/
  while (buf)
  {
/*
    printf("level=0 top=%d bot=%d\n", top, bot);
    printf("buf=%p abyte=%d\n",buf, abyte);
*/
    _getbyte(abyte);
    if (abyte == byte0)
    {
      if (codebytes==1)
      {
        if (discard)
          { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
        *size=bufsize;
        return(buf);
      }
      _getbyte(abyte);
      if (abyte == byte1)
      {
        if (codebytes==2)
        {
          if (discard)
            { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
          *size=bufsize;
          return(buf);
        }
        _getbyte(abyte);
        if (abyte == byte2)
        {
          if (codebytes==3)
          {
            if (discard)
              { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
            *size=bufsize;
            return(buf);
          }
          _getbyte(abyte);
          if (abyte == byte3)
          {
            if (codebytes==4)
            {
              if (discard)
                { SlibAllocSubBuffer(buf, bufsize); SlibFreeBuffer(bufstart); }
              *size=bufsize;
              return(buf);
            }
          }
          else
          {
            _storebyte(byte1);
            _storebyte(byte2);
            _storebyte(abyte);
          }
        }
        else
        {
          _storebyte(byte1);
          _storebyte(abyte);
        }
      }
      else
        _storebyte(abyte);
    }
  }
  _SlibDebug(_DEBUG_, printf("slibSearchBuffersOnPin() Not found\n") );
  return(NULL);
}

#define _getbyte2(var) \
     if (top==bot) { \
        var = *buf++; totallen++; \
        if (--bufsize==0) { \
          buf=slibPeekNextBufferOnPin(Info, pin, buf-1, &bufsize, NULL); \
          if (!buf) { \
            _SlibDebug(_VERBOSE_,printf("slibCountCodesOnPin() out (EOI)\n")); \
            return(count); } \
        } \
     } else var=sbyte[top++];

/*
** Name: slibCountCodesOnPin
** Description: Count the occurrances of a particular code in a Pin's 
**              data stream.
**     maxlen: 0  counts till end of data
**             -1 counts buffers already loaded on pin
*/
dword slibCountCodesOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                 unsigned dword code, int codebytes, 
                                 unsigned dword maxlen)
{
  unsigned char *buf;
  unsigned char abyte, byte0, byte1, byte2, byte3, sbyte[16];
  int bot, top, count=0;
  unsigned dword bufsize;
  unsigned long totallen=0;
  _SlibDebug((_DEBUG_||_WARN_) && (!pin || !pin->name), 
            printf("slibCountCodesOnPin() bad pin\n") );
  if (!Info || !pin)
    return(count);
  _SlibDebug(_DEBUG_||_VERBOSE_, 
            printf("slibCountCodesOnPin(%s) in\n", pin->name) );
  for (top=codebytes-1; top>=0; top--)
  {
    sbyte[top]=code & 0xFF;
    code>>=8;
  }
  byte0=sbyte[0];
  byte1=sbyte[1];
  byte2=sbyte[2];
  byte3=sbyte[3];
  top=bot=0;
  buf=slibPeekBufferOnPin(Info, pin, &bufsize, NULL);
  if (!buf || codebytes<=0)
    return(count);
  while (buf && (maxlen<=0 || totallen<maxlen))
  {
    _getbyte2(abyte);
    if (abyte == byte0)
    {
      if (codebytes==1)
      {
        count++;
        top=bot=0;
        continue;
      }
      _getbyte2(abyte);
      if (abyte == byte1)
      {
        if (codebytes==2)
        {
          count++;
          top=bot=0;
          continue;
        }
        _getbyte2(abyte);
        if (abyte == byte2)
        {
          if (codebytes==3)
          {
            count++;
            top=bot=0;
            continue;
          }
          _getbyte2(abyte);
          if (abyte == byte3)
          {
            if (codebytes==4)
            {
              count++;
              top=bot=0;
              continue;
            }
          }
          else
          {
            _storebyte(byte1);
            _storebyte(byte2);
            _storebyte(abyte);
          }
        }
        else
        {
          _storebyte(byte1);
          _storebyte(abyte);
        }
      }
      else
        _storebyte(abyte);
    }
  }
  _SlibDebug(_VERBOSE_, printf("slibCountCodesOnPin() out\n") );
  return(count);
}

/*
** Name:    SlibGetBuffer
** Purpose: Read the next buffer from the data source.
*/
unsigned char *SlibGetBuffer(SlibInfo_t *Info, int pinid,
                             unsigned dword *psize, SlibTime_t *ptime)
{
  unsigned char *address=NULL;
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("SlibGetBuffer\n") );
  if (!Info)
    return(NULL);
  if (!psize)
    return(NULL);
  pin=slibLoadPin(Info, pinid);
  if (pin)
    return(slibGetBufferFromPin(Info, pin, psize, ptime));
  else
  {
    if (psize)
      *psize=0;
    if (ptime)
      *ptime=SLIB_TIME_NONE;
    _SlibDebug(_WARN_, 
                printf("SlibGetBuffer(pinid=%d) couldn't get\n",pinid) );
    return(NULL);
  }
}

/*
** Name:    SlibPeekBuffer
** Purpose: Read the next buffer from the data source.
*/
unsigned char *SlibPeekBuffer(SlibInfo_t *Info, int pinid,
                              unsigned dword *psize, SlibTime_t *ptime)
{
  unsigned char *address=NULL;
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("SlibPeekBuffer\n") );
  if (!Info)
    return(NULL);
  pin=slibLoadPin(Info, pinid);
  if (pin)
    return(slibPeekBufferOnPin(Info, pin, psize, ptime));
  else
  {
    if (psize)
      *psize=0;
    if (ptime)
      *ptime=SLIB_TIME_NONE;
    _SlibDebug(_WARN_, 
                printf("SlibPeekBuffer(pinid=%d) couldn't peek\n",pinid) );
    return(NULL);
  }
}

/************************** Pins ***********************/
SlibBoolean_t slibPinOverflowing(SlibInfo_t *Info, SlibPin_t *pin)
{
  if (pin==NULL)
    return(TRUE);
/*
  _SlibDebug(_WARN_ && pin->DataSize>(Info->OverflowSize*2)/3,
        printf("Data almost overflowing: %d bytes\n", pin->DataSize) );
*/
  return(pin->DataSize>(long)Info->OverflowSize ? TRUE : FALSE);
}

void slibRemovePins(SlibInfo_t *Info)
{
  _SlibDebug(_VERBOSE_, printf("slibRemovePins()\n") );
  while (Info->Pins)
    slibRemovePin(Info, Info->Pins->ID);
}

void slibEmptyPins(SlibInfo_t *Info)
{
  SlibPin_t *pin=Info->Pins;
  _SlibDebug(_VERBOSE_, printf("slibEmptyPins()\n") );
  while (pin)
  {
    slibEmptyPin(Info, pin->ID);
    pin = pin->next;
  }
}

SlibPin_t *slibGetPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=Info->Pins;
  while (pin)
  {
    if (pin->ID == pinid)
      return(pin);
    pin = pin->next;
  }
  return(NULL);
}

SlibPin_t *slibRenamePin(SlibInfo_t *Info, int oldpinid,
                                           int newpinid, char *newname)
{
  SlibPin_t *pin=Info->Pins;
  pin=slibGetPin(Info, oldpinid);
  if (pin==NULL) /* pin doesn't exist */
    return(NULL);
  /* if a pin with the new ID already exists, delete it */
  slibRemovePin(Info, newpinid);
  /* rename it */
  pin->ID=newpinid;
  if (newname)
    strcpy(pin->name, newname);
  return(pin);
}

SlibPin_t *slibAddPin(SlibInfo_t *Info, int pinid, char *name)
{
  SlibPin_t *pin=Info->Pins, *newpin;
  int i;
  _SlibDebug(_DEBUG_||_VERBOSE_, printf("slibAddPin(%s)\n",name) );
  while (pin)
  {
    if (pin->ID == pinid)
      return(pin);
    pin = pin->next;
  }
  if ((newpin = ScAlloc(sizeof(SlibPin_t)))==NULL)
    return(NULL);
  newpin->ID = pinid;
  for (i=0; i<(sizeof(newpin->name)-1) && name && *name; i++)
    newpin->name[i]=*name++;
  newpin->name[i]=0;
  newpin->next=Info->Pins;
  newpin->Buffers=NULL;
  newpin->BuffersTail=NULL;
  newpin->BufferCount=0;
  newpin->DataSize=0;
  newpin->Offset=0;
  Info->Pins = newpin;
  Info->PinCount++;
  
  return(newpin);
}

/*
** Name:    slibAddBufferToPin
** Purpose: Add a buffer to data source buffer queue.
*/
SlibStatus_t slibAddBufferToPin(SlibPin_t *pin, 
                     void *buffer, unsigned dword size, SlibTime_t time)
{
  SlibBuffer_t *newbuf;
  _SlibDebug(_DEBUG_,
     printf("slibAddBufferToPin(%s, %d)\n", pin->name, size) );
  _SlibDebug(_WARN_ && size==0,
      printf("slibAddBufferToPin(%s, %p, size=%d)\n", pin->name, buffer, size) );
  if (!pin || !buffer || !size)
    return(SlibErrorBadArgument);
  if ((newbuf = ScAlloc(sizeof(SlibBuffer_t)))==NULL)
    return(SlibErrorMemory);
  newbuf->address = buffer;
  newbuf->size = size;
  if (pin->BuffersTail)
    newbuf->offset = pin->BuffersTail->offset+pin->BuffersTail->size;
  else
    newbuf->offset = pin->Offset;
  newbuf->time = time;
  newbuf->next = NULL;
  if (pin->BuffersTail==NULL)
    pin->Buffers=newbuf;
  else
    pin->BuffersTail->next=newbuf;
  pin->BuffersTail = newbuf;
  pin->BufferCount++;
  pin->DataSize+=newbuf->size;
  return(SlibErrorNone);
}

/*
** Name:    slibInsertBufferOnPin
** Purpose: Add a buffer at the head of a data source's buffer queue.
*/
SlibStatus_t slibInsertBufferOnPin(SlibPin_t *pin, void *buffer,
                                 unsigned dword size, SlibTime_t time)
{
  SlibBuffer_t *newbuf;
  _SlibDebug(_DEBUG_>1, 
      printf("slibInsertBufferOnPin(%s, size=%d)\n", pin->name, size) );
  _SlibDebug((_WARN_ && !_DEBUG_) && size==0, 
      printf("slibInsertBufferOnPin(%s, size=%d)\n", pin->name, size) );
  if (!pin || !buffer || !size)
    return(SlibErrorBadArgument);
  if ((newbuf = ScAlloc(sizeof(SlibBuffer_t)))==NULL)
    return(SlibErrorMemory);
  newbuf->address = buffer;
  newbuf->size = size;
  pin->Offset-=size;
  newbuf->offset = pin->Offset;
  newbuf->time = time;
  newbuf->next = pin->Buffers;
  pin->Buffers=newbuf;
  if (pin->BuffersTail == NULL)
    pin->BuffersTail = newbuf;
  pin->BufferCount++;
  pin->DataSize+=newbuf->size;
  return(SlibErrorNone);
}

qword slibSkipDataOnPin(SlibInfo_t *Info, SlibPin_t *pin, 
                                qword totalbytes)
{
  qword skippedbytes=0;
  _SlibDebug(_VERBOSE_ || 1, printf("slibSkipDataOnPin() in\n") );
  if (pin && totalbytes>0)
  {
    qword startsize;
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time, newtime;
    startsize=pin->DataSize;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    while (buf && skippedbytes+size<totalbytes)
    {
      skippedbytes+=size;
      SlibFreeBuffer(buf);
      buf=slibGetBufferFromPin(Info, pin, &size, &newtime);
      if (newtime!=SLIB_TIME_NONE)
        time=newtime;
    }
    if (buf && skippedbytes+size>=totalbytes)
    {
      size-=(unsigned dword)(totalbytes-skippedbytes);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+totalbytes-skippedbytes, size);
        slibInsertBufferOnPin(pin, buf+totalbytes-skippedbytes, size, time);
      }
      SlibFreeBuffer(buf);
      skippedbytes=totalbytes;
    }
    _SlibDebug(_WARN_ && pin->DataSize+skippedbytes!=startsize,
      printf("slibSkipDataOnPin() Skipped %d bytes, startsize=%d newsize=%d\n",
            skippedbytes, startsize, pin->DataSize) );
  }
  _SlibDebug(_VERBOSE_ || 1, printf("slibSkipDataOnPin() out\n") );
  return(skippedbytes);
}

unsigned dword slibFillBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                           unsigned char *fillbuf, unsigned dword bufsize,
                           SlibTime_t *ptime)
{
  unsigned dword filledbytes=0;
  if (pin && fillbuf)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time, nexttime=SLIB_TIME_NONE;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    while (buf && size<bufsize)
    {
      memcpy(fillbuf, buf, size);
      bufsize-=size;
      filledbytes+=size;
      fillbuf+=size;
      SlibFreeBuffer(buf);
      buf=slibGetBufferFromPin(Info, pin, &size, &nexttime);
      if (time==SLIB_TIME_NONE)
        time=nexttime;
    }
    if (buf && size>=bufsize)
    {
      memcpy(fillbuf, buf, bufsize);
      size-=bufsize;
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+bufsize, size);
        slibInsertBufferOnPin(pin, buf+bufsize, size, nexttime);
      }
      SlibFreeBuffer(buf);
      filledbytes+=bufsize;
    }
    if (ptime)
      *ptime=time;
  }
  return(filledbytes);
}

word slibGetWordFromPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  word value=0;
  if (pin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    if (buf && size>=sizeof(value))
    {
      value=((int)buf[3]<<24) | (int)buf[2]<<16 |
             (int)buf[1]<<8 | (int)buf[0];
      size-=sizeof(value);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+sizeof(value), size);
        slibInsertBufferOnPin(pin, buf+sizeof(value), size, time);
      }
      SlibFreeBuffer(buf);
    }
  }
  return(value);
}

dword slibGetDWordFromPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  dword value=0;
  if (pin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    _SlibDebug(_VERBOSE_, printf("slibGetDWordFromPin(%s)\n", pin->name) );
    buf=slibGetBufferFromPin(Info, pin, &size, &time);
    if (buf && size>=sizeof(value))
    {
      value=((int)buf[3]<<24) | (int)buf[2]<<16 |
             (int)buf[1]<<8 | (int)buf[0];
      size-=sizeof(value);
      if (size) /* put remainer of buffer back on pin */
      {
        SlibAllocSubBuffer(buf+sizeof(value), size);
        slibInsertBufferOnPin(pin, buf+sizeof(value), size, time);
      }
      SlibFreeBuffer(buf);
    }
  }
  return(value);
}

SlibStatus_t slibRemovePin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *lastpin=NULL, *pin=Info->Pins;
  SlibBuffer_t *lastbuf, *buf;
  _SlibDebug(_VERBOSE_, printf("slibRemovePin(%d)\n", pinid) );
  while (pin)
  {
    if (pin->ID == pinid)
    {
      if (lastpin)
        lastpin->next = pin->next;
      else
        Info->Pins = pin->next;
      buf=pin->Buffers;
      while (buf)
      {
        if (buf->address)
          SlibFreeBuffer(buf->address);
        lastbuf=buf;
        buf=lastbuf->next;
        ScFree(lastbuf);
      }
      ScFree(pin);
      Info->PinCount--;
      return(TRUE);
    }
    lastpin = pin;
    pin = pin->next;
  }
  return(FALSE);
}

SlibStatus_t slibEmptyPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=Info->Pins;
  SlibBuffer_t *lastbuf, *buf;
  _SlibDebug(_DEBUG_ || _VERBOSE_, printf("slibEmptyPin(%d)\n",pinid) );
  while (pin)
  {
    if (pin->ID == pinid)
    {
      buf=pin->Buffers;
      while (buf)
      {
        pin->Offset+=buf->size;
        if (buf->address)
          if (SlibFreeBuffer(buf->address))
          {
            _SlibDebug(_WARN_,
               printf("slibEmptyPin(%d) freeing buffer %p failed\n",
                                        pinid, buf->address));
          }
        lastbuf=buf;
        buf=buf->next;
        ScFree(lastbuf);
      }
      pin->Buffers = NULL;
      pin->BuffersTail = NULL;
      pin->BufferCount = 0;
      pin->DataSize = 0;
      return(TRUE);
    }
    pin = pin->next;
  }
  _SlibDebug(_WARN_, printf("slibEmptyPin(%d) Unable to locate pin\n",pinid) );
  return(FALSE);
}

SlibPin_t *slibLoadPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("slibLoadPin(%d)\n",pinid) );
  if ((pin=slibGetPin(Info, pinid))==NULL)
  {
    switch(pinid)
    {
      case SLIB_DATA_COMPRESSED: pin=slibAddPin(Info, pinid, "Input");
                                 break;
      case SLIB_DATA_VIDEO:      pin=slibAddPin(Info, pinid, "Video");
                                 break;
      case SLIB_DATA_AUDIO:      pin=slibAddPin(Info, pinid, "Audio");
                                 break;
    }
  }
  if (pin)
  {
    if (pin->Buffers)
      return(pin);
    else if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      pin=slibPreLoadPin(Info, pin);
      if (pin && pin->Buffers)
        return(pin);
    }
    _SlibDebug(_WARN_, 
         if (Info->Mode!=SLIB_MODE_DECOMPRESS)
           printf("slibLoadPin(%d) Mode is not SLIB_MODE_DECOMPRESS\n", pinid);
         else
           printf("slibLoadPin(%d) Unable to load pin\n", pinid));
    return(NULL);
  }
  return(NULL);
}

qword slibDataOnPin(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin=slibGetPin(Info, pinid);
  if (!pin || pin->Buffers==NULL)
    return((qword)0);
  else
    return(pin->DataSize>0?pin->DataSize:(qword)1);
}

qword slibDataOnPins(SlibInfo_t *Info)
{
  SlibPin_t *pin=Info->Pins;
  qword totalbytes=(qword)0;
  while (pin)
  {
    if (pin->DataSize>0)
     totalbytes+=pin->DataSize;
    pin = pin->next;
  }
  _SlibDebug(_VERBOSE_, printf("slibDataOnPins() returns %d\n", totalbytes) );
  return(totalbytes);
}

/************************** Data Stream helper functions **************/
#ifdef MPEG_SUPPORT
#define PACKET_SIZE         0x8F0
#define PACKET_BUFFER_SIZE  0x8F0+50
#define BYTES_PER_PACK      0x1200
#define PTIME_ADJUST        300
#define AUDIOTIME_ADJUST    10
#endif

void slibValidateBitrates(SlibInfo_t *Info)
{
  if (Info->Svh)
    Info->VideoBitRate=(dword)SvGetParamInt(Info->Svh, SV_PARAM_BITRATE);
  if (Info->Sah)
    Info->AudioBitRate=(dword)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
  _SlibDebug(_VERBOSE_, printf("AudioBitRate=%d VideoBitRate=%d\n",
                     Info->AudioBitRate,Info->VideoBitRate) );
#ifdef MPEG_SUPPORT
  if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS ||
      Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
  {
    qword totalbitrate=Info->AudioBitRate+Info->VideoBitRate;
    if (Info->Mode==SLIB_MODE_COMPRESS)
    {
      Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
      Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING);
    }
    totalbitrate+=(9*(totalbitrate/(PACKET_SIZE-3)))+ /* Packet headers */
                  (qword)(4*8*Info->FramesPerSec)+ /* Presentation timestamps */
                  (qword)(4*8*Info->FramesPerSec*10/  /* Decoding */
                       Info->SubKeySpacing);          /* timestamps */
    Info->MuxBitRate=(dword)(12*(totalbitrate/BYTES_PER_PACK));/*Pack Headers*/
  }
#endif
  Info->TotalBitRate=Info->AudioBitRate+Info->VideoBitRate+Info->MuxBitRate;
}

/************************** Data Stream Writers ***********************/
#ifdef MPEG_SUPPORT
static int slibCreateMpegPackHeader(unsigned char *buf,
                                    unsigned qword sys_clock,
                                    unsigned dword mux_rate)
{
  buf[0]=0x00;
  buf[1]=0x00;
  buf[2]=0x01;
  buf[3]=MPEG_PACK_START_BASE;
  /* store system clock */
  buf[4]=0x21|(unsigned char)(((sys_clock>>30)&0x07)<<1);
  buf[5]=(unsigned char)(sys_clock>>22)&0xFF;
  buf[6]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
  buf[7]=(unsigned char)((sys_clock>>7)&0xFF);
  buf[8]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
  /* store mux rate */
  buf[9]=0x80|(unsigned char)((mux_rate>>15)&0xEF);
  buf[10]=(unsigned char)(mux_rate>>7)&0xFF;
  buf[11]=0x01|(unsigned char)((mux_rate<<1)&0xFE);
  return(12);  /* bytes written */
}

/*
** Function: slibWriteMpeg1Systems()
** Descript: Writes  out MPEG Video & Audio data conatined on Pins.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpeg1Systems(SlibInfo_t *Info, 
                                           SlibBoolean_t flush)
{
  SlibPin_t *audiopin, *videopin;
  unsigned char *buf=NULL;
  unsigned dword size=0, len;
  unsigned char packet_data[PACKET_BUFFER_SIZE];
  unsigned dword header_len;
  SlibTime_t ptimestamp, dtimestamp, timediff=0;
  SlibTime_t atime=SLIB_TIME_NONE, vtime=SLIB_TIME_NONE;
  const unsigned dword std_audio_buf_size=Info->AudioBitRate ?
                                     Info->AudioBitRate/8000 : 32;
  const unsigned dword std_video_buf_size=Info->VideoBitRate ?
                                     Info->VideoBitRate/25000 : 46;
  int i;
  _SlibDebug(_VERBOSE_||_WRITE_,
         printf("slibWriteMpeg1Systems(flush=%d) BytesProcessed=%ld\n",
                                       flush, Info->BytesProcessed) );
  videopin = slibGetPin(Info, SLIB_DATA_VIDEO);
  audiopin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (!videopin && !audiopin)
    return(FALSE);
  if (!Info->HeaderProcessed || Info->BytesSincePack>=BYTES_PER_PACK)
  {
    /* mux_rate is in units of 50 bytes/s rounded up */
    unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
    Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("   TotalBitRate=%d sys_clock=%d (%d ms) BytesSincePack=%d\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, Info->BytesSincePack) );
      len=slibCreateMpegPackHeader(packet_data,
                                   Info->SystemTimeStamp*90, /* 90 Khz clock */
                                   mux_rate);
    if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
    {
      Info->BytesProcessed+=len;
      Info->BytesSincePack+=len;
      if (Info->BytesSincePack>=BYTES_PER_PACK)
        Info->BytesSincePack-=BYTES_PER_PACK;
    }
  }
  if (!Info->HeaderProcessed)
  {
    if (!Info->IOError)
    {
      /* mux_rate is in units of 50 bytes/s rounded up */
      unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
      /******** systems header **********/
      header_len=6+3*(Info->AudioStreams+Info->VideoStreams);
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=(unsigned char)MPEG_SYSTEM_HEADER_START;
      packet_data[4]=header_len>>8;
      packet_data[5]=header_len & 0xFF;
      packet_data[6]=0x80|((mux_rate>>15)&0xEF);
      packet_data[7]=(mux_rate>>7)&0xFF;
      packet_data[8]=0x01|((mux_rate<<1)&0xFE);
      /* audio_bound(6 bits) + fixed_flag(1) + CSPS_falg(1) */
      packet_data[9]=0x05;
      /* sys_audio_lock_flag(1)+sys_video_lock_flag(1)+marker(1)+
         video_bound(5 bits) */
      packet_data[10]=0x80|0x40|0x20|0x01;
      packet_data[11]=0xFF; /* reserved byte */
      len=12;
      for (i=0; i<Info->VideoStreams; i++)
      {
        packet_data[len++]=MPEG_VIDEO_STREAM_BASE+i;
        packet_data[len++]=0xE0 | (std_video_buf_size>>8);
        packet_data[len++]=std_video_buf_size & 0xFF;
      }
      for (i=0; i<Info->AudioStreams; i++)
      {
        packet_data[len++]=MPEG_AUDIO_STREAM_BASE+i;
        packet_data[len++]=0xC0 | (std_audio_buf_size>>8);
        packet_data[len++]=std_audio_buf_size & 0xFF;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of system header\n",
             Info->Fd, len) );
      if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
      {
        Info->BytesProcessed+=len;
        Info->BytesSincePack+=len;
      }
    }
    Info->HeaderProcessed=TRUE;
  }
  atime=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
  vtime=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
  if (SlibTimeIsInValid(atime))
    atime=Info->LastAudioPTimeCode;
  if (SlibTimeIsInValid(vtime))
    vtime=Info->LastVideoPTimeCode;
  if (!flush &&
       (audiopin->DataSize<PACKET_SIZE-3 || videopin->DataSize<PACKET_SIZE-3))
    return(TRUE); /* we need more data before writing */
  if (!flush && audiopin && SlibTimeIsValid(atime) &&
                videopin && SlibTimeIsValid(vtime))
    timediff=atime-vtime-AUDIOTIME_ADJUST;
  else
    timediff=0;
  /* write out complete Audio and/or Video packets */
  while (!Info->IOError &&
          ((audiopin && timediff<=0 && audiopin->DataSize>=PACKET_SIZE-3) ||
           (videopin && timediff>=0 && videopin->DataSize>=PACKET_SIZE-3)))
  {
    Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
    _SlibDebug(_VERBOSE_ || _WRITE_,
      printf(" TotalBitRate=%d sys_clock=%d (%d ms) BytesProcessed=%ld\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, Info->BytesProcessed) );
    if (Info->BytesSincePack>=BYTES_PER_PACK)
    {
      /* mux_rate is in units of 50 bytes/s rounded up */
      unsigned dword mux_rate=Info->TotalBitRate/(50*8) 
                             + ((Info->TotalBitRate%(50*8))?1:0);
      Info->SystemTimeStamp=(Info->BytesProcessed*8000)/Info->TotalBitRate;
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("   TotalBitRate=%d sys_clock=%d (%d ms) mux_rate=%d BytesSincePack=%d\n",
               Info->TotalBitRate, Info->SystemTimeStamp*90, 
               Info->SystemTimeStamp, mux_rate, Info->BytesSincePack) );
      len=slibCreateMpegPackHeader(packet_data,
                                   Info->SystemTimeStamp*90, /* 90 Khz clock */
                                   mux_rate);
      if (slibPutBuffer(Info, packet_data, len)==SlibErrorNone)
      {
        Info->BytesProcessed+=len;
        Info->BytesSincePack+=len;
        Info->BytesSincePack-=BYTES_PER_PACK;
      }
    }
    if ((SlibTimeIsValid(atime) && atime-Info->SystemTimeStamp>300) ||
        (SlibTimeIsValid(vtime) && vtime-Info->SystemTimeStamp>300))
    {
      /* we need a Padding packet */
      _SlibDebug(_WRITE_||_TIMECODE_, printf("Padding\n") );
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_PADDING_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;   /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF; /* packet size - low byte */
      packet_data[6]=0xFF;
      packet_data[7]=0x0F;  /* no presentation or time stamps */
      size=PACKET_SIZE+6;
      for (len=8; len<size; len++)
        packet_data[len]=0xFF;
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    else if (!flush && (atime>0 || vtime>0) &&
                   (atime+300<Info->SystemTimeStamp &&
                    vtime+300<Info->SystemTimeStamp))
    {
      /* we're not able to keep the bitrate low enough */
      /* increase the Mux rate */
      dword oldrate=Info->TotalBitRate;
      SlibTime_t mintime=(vtime<atime) ? atime : vtime;
      if (atime>0 && vtime>0)
        mintime=(vtime<atime) ? vtime : atime;
      Info->TotalBitRate=(dword)((Info->BytesProcessed*8000)/mintime);
      if (Info->TotalBitRate==oldrate)
        Info->TotalBitRate+=50*8;
      Info->MuxBitRate=Info->TotalBitRate-Info->VideoBitRate-Info->AudioBitRate;
      _SlibDebug(_WRITE_||_TIMECODE_, 
      printf("Bad Mux rate: atime=%ld vtime=%ld systime=%ld total=%ld -> %ld\n",
            atime, vtime, Info->SystemTimeStamp, oldrate, Info->TotalBitRate) );
    }
    if (audiopin && timediff<=0 && audiopin->DataSize>=PACKET_SIZE-3)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_AUDIO_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;   /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF; /* packet size - low byte */
      /* 01 + STD_buffer_scale + STD_buffer_size[12..8] */
      packet_data[6]=0x40 | 0x00 | (std_audio_buf_size>>8);
      packet_data[7]=std_audio_buf_size & 0xFF;
      ptimestamp=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
      if (SlibTimeIsValid(ptimestamp))
      {
        unsigned qword sys_clock=ptimestamp*90; /* 90 Khz clock */
        _SlibDebug(_WRITE_||_TIMECODE_,
               printf("LastAudioPTimeCode=%ld\n", Info->LastAudioPTimeCode) );
        _SlibDebug(_WARN_ && (ptimestamp-(qword)Info->SystemTimeStamp>400 ||
                         (qword)Info->SystemTimeStamp-ptimestamp>400),
           printf("Bad MuxRate(%d): SystemTimeStamp=%d ptimestamp=%d\n",
                                    Info->SystemTimeStamp, ptimestamp) );
        Info->LastAudioPTimeCode=ptimestamp;
        sys_clock+=PTIME_ADJUST*90;
        packet_data[8]=0x21|(unsigned char)(((sys_clock>>30)&0x07)<<1);
        packet_data[9]=(unsigned char)(sys_clock>>22)&0xFF;
        packet_data[10]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
        packet_data[11]=(unsigned char)((sys_clock>>7)&0xFF);
        packet_data[12]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
        size=slibFillBufferFromPin(Info, audiopin, packet_data+13,
                                      PACKET_SIZE-7, NULL);
        size+=13;
      }
      else
      {
        packet_data[8]=0x0F;  /* no presentation or time stamps */
        size=slibFillBufferFromPin(Info, audiopin, packet_data+9,
                                      PACKET_SIZE-3, NULL);
        size+=9;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
          printf("slibPutBuffer(%d) %d bytes of audio\n", Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    if (videopin && !Info->IOError && timediff>=0 &&
                              videopin->DataSize>=PACKET_SIZE-3)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_VIDEO_STREAM_BASE;
      packet_data[4]=PACKET_SIZE>>8;    /* packet size - high byte */
      packet_data[5]=PACKET_SIZE&0xFF;  /* packet size - low byte */
      /* 01 + STD_buffer_scale + STD_buffer_size[12..8] */
      packet_data[6]=0x40 | 0x20 | (std_video_buf_size>>8);
      packet_data[7]=std_video_buf_size & 0xFF;
      /* store presentation time stamp */
      ptimestamp=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
      if (SlibTimeIsValid(ptimestamp))
      {
        unsigned qword sys_clock=ptimestamp*90; /* 90 Khz clock */
        _SlibDebug(_WRITE_||_TIMECODE_,
               printf("LastVideoPTimeCode=%ld LastVideoDTimeCode=%ld\n",
                                   Info->LastVideoPTimeCode,
                                   Info->LastVideoDTimeCode) );
        if (SlibTimeIsInValid(Info->LastVideoDTimeCode))
          dtimestamp=ptimestamp-(qword)(1000/Info->FramesPerSec);
        else if (ptimestamp-Info->LastVideoPTimeCode>33*3)
          dtimestamp=Info->LastVideoDTimeCode;
        else
          dtimestamp=SLIB_TIME_NONE;
        Info->LastVideoPTimeCode=ptimestamp;
        sys_clock+=PTIME_ADJUST*90;
        packet_data[8]=(dtimestamp!=SLIB_TIME_NONE)?0x30:0x20;
        packet_data[8]|=0x01|(unsigned char)(((sys_clock>>30)&0x07)<<1);
        packet_data[9]=(unsigned char)(sys_clock>>22)&0xFF;
        packet_data[10]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
        packet_data[11]=(unsigned char)((sys_clock>>7)&0xFF);
        packet_data[12]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
        if (dtimestamp!=SLIB_TIME_NONE)
        {
          sys_clock=dtimestamp*90; /* 90 Khz clock */
          Info->LastVideoDTimeCode=ptimestamp;
          sys_clock+=PTIME_ADJUST*90;
          packet_data[13]=0x01|(unsigned char)(((sys_clock>>30)&0x07)<<1);
          packet_data[14]=(unsigned char)(sys_clock>>22)&0xFF;
          packet_data[15]=0x01|(unsigned char)((sys_clock>>14)&0xFE);
          packet_data[16]=(unsigned char)((sys_clock>>7)&0xFF);
          packet_data[17]=0x01|(unsigned char)((sys_clock<<1)&0xFE);
          size=slibFillBufferFromPin(Info, videopin, packet_data+18,
                                      PACKET_SIZE-12, NULL);
          size+=18;
        }
        else
        {
          size=slibFillBufferFromPin(Info, videopin, packet_data+13,
                                      PACKET_SIZE-7, NULL);
          size+=13;
        }
      }
      else
      {
        packet_data[8]=0x0F;  /* no presentation or time stamps */
        size=slibFillBufferFromPin(Info, videopin, packet_data+9,
                                         PACKET_SIZE-3, NULL);
        size+=9;
      }
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of video\n", Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    /* need to wait until we get enough data on both audio and video pin */
    if (audiopin && videopin && !flush &&
        (audiopin->DataSize<PACKET_SIZE-3 || videopin->DataSize<PACKET_SIZE-3))
    {
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("atime=%d vtime=%ld audiodata=%d videodata=%d\n",
          atime, vtime, audiopin->DataSize, videopin->DataSize) );
      break;
    }
    /* recalculate time differences */
    timediff=slibGetNextTimeOnPin(Info, audiopin, PACKET_SIZE-3);
    if (SlibTimeIsValid(timediff)) atime=timediff;
    timediff=slibGetNextTimeOnPin(Info, videopin, PACKET_SIZE-3);
    if (SlibTimeIsValid(timediff)) vtime=timediff;
    if (!flush && audiopin && SlibTimeIsValid(atime) &&
                  videopin && SlibTimeIsValid(vtime))
      timediff=atime-vtime-AUDIOTIME_ADJUST;
    else
      timediff=0;
  }
  /* flushing: write out remained Audio and/or Video data */
  if (flush && !Info->IOError)
  {
    if (audiopin && audiopin->DataSize)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_AUDIO_STREAM_BASE;
      packet_data[4]=(unsigned char)((audiopin->DataSize+3)>>8);
      packet_data[5]=(unsigned char)((audiopin->DataSize+3)&0xFF);
      packet_data[6]=0x40 | (std_audio_buf_size>>8);
      packet_data[7]=std_audio_buf_size & 0xFF;
      packet_data[8]=0x0F;  /* no presentation or time stamps */
      size=slibFillBufferFromPin(Info, audiopin, packet_data+9,
                                   (unsigned long)audiopin->DataSize, NULL);
      size+=9;
      _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("slibPutBuffer(%d) %d bytes of audio (flush)\n", Info->Fd, size));
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
    if (videopin && videopin->DataSize && !Info->IOError)
    {
      packet_data[0]=0x00;
      packet_data[1]=0x00;
      packet_data[2]=0x01;
      packet_data[3]=MPEG_VIDEO_STREAM_BASE;
      packet_data[4]=(unsigned char)((videopin->DataSize+3)>>8);
      packet_data[5]=(unsigned char)((videopin->DataSize+3)&0xFF);
      packet_data[6]=0x60 | (std_video_buf_size>>8);
      packet_data[7]=std_video_buf_size & 0xFF;
      packet_data[8]=0x0F;  /* no presentation or time stamps */
      size=slibFillBufferFromPin(Info,videopin,packet_data+9,
                                    (unsigned long)videopin->DataSize, NULL);
      size+=9;
      _SlibDebug(_VERBOSE_ || _WRITE_,
                     printf("slibPutBuffer(%d) %d bytes of video (flush)\n",
                               Info->Fd, size) );
      if (slibPutBuffer(Info, packet_data, size)==SlibErrorNone)
      {
        Info->BytesProcessed+=size;
        Info->BytesSincePack+=size;
        Info->PacketCount++;
      }
    }
  }
  if (flush && !Info->IOError) /* write End-Of-Sequence code */
  {
    unsigned char sys_trailer[4] = { 0x00, 0x00, 0x01, 0xB9 };
    if (slibPutBuffer(Info, sys_trailer, sizeof(sys_trailer))==SlibErrorNone)
    {
      Info->BytesProcessed+=sizeof(sys_trailer);
      Info->BytesSincePack+=sizeof(sys_trailer);
    }
  }
  
  return(TRUE);
}
#endif /* MPEG_SUPPORT */


#ifdef MPEG_SUPPORT
/*
** Function: slibWriteMpegAudio()
** Descript: Writes  out MPEG Audio stream data contained on Audio Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpegAudio(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteMpegAudio()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_AUDIO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("==SlibErrorNone(%d) %d bytes\n", Info->Fd, size) );
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* MPEG_SUPPORT */


#ifdef MPEG_SUPPORT
/*
** Function: slibWriteMpegVideo()
** Descript: Writes  out MPEG Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteMpegVideo(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteMpegVideo()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*
** Function: slibWriteH261()
** Descript: Writes out H261 Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteH261(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteH261()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*
** Function: slibWriteH263()
** Descript: Writes out H263 Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteH263(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteH263()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    if (slibPutBuffer(Info, buf, size)==SlibErrorNone)
      Info->HeaderProcessed=TRUE;
  }
  return(TRUE);
}
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*
** Function: slibWriteSlibHuff()
** Descript: Writes out SLIB Huff Video stream data contained on Video Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteSlibHuff(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteSlibHuff()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_VIDEO))==NULL)
    return(FALSE);
  if (!Info->HeaderProcessed)
  {
    if (!Info->IOError)
    {
      char header[] = { 'S','L','I','B','H','U','F','F' };
      _SlibDebug(_VERBOSE_ || _WRITE_,
         printf("slibPutBuffer(%d) %d bytes of header\n",
             Info->Fd, sizeof(header)) );
      slibPutBuffer(Info, header, sizeof(header));
    }
    Info->HeaderProcessed=TRUE;
  }
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
  {
    _SlibDebug(_VERBOSE_ || _WRITE_,
       printf("slibPutBuffer(%d) %d bytes\n", Info->Fd, size) );
    slibPutBuffer(Info, buf, size);
  }
  return(TRUE);
}
#endif /* HUFF_SUPPORT */

#ifdef G723_SUPPORT
/*
** Function: slibWriteG723Audio()
** Descript: Writes  out G723 Audio stream data contained on Audio Pin.
** Returns:  TRUE if data was written, otherwise FALSE.
*/
static SlibBoolean_t slibWriteG723Audio(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;
  _SlibDebug(_VERBOSE_, printf("slibWriteG723Audio()\n") );
  if ((srcpin = slibGetPin(Info, SLIB_DATA_AUDIO))==NULL)
    return(FALSE);
  //MVP: There is no header to write for G723 codec
  //After successful first "Write" set the "headerProcessed to TRUE
  if (!Info->HeaderProcessed)
  {
     if ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
        slibPutBuffer(Info, buf, size);
    //Set Header processed flag to True
    if (!Info->IOError)
      Info->HeaderProcessed=TRUE;
  }
  
  while ((buf=slibGetBufferFromPin(Info, srcpin, &size, NULL))!=NULL)
    slibPutBuffer(Info, buf, size);
  return(TRUE);
}
#endif /* G723_SUPPORT */

/*
** Name: slibCommitBuffers
** Desc: Move buffers queued for output to there destination.
*/
SlibBoolean_t slibCommitBuffers(SlibInfo_t *Info, SlibBoolean_t flush)
{
  SlibPin_t *srcpin=NULL;
  unsigned char *buf=NULL;
  unsigned dword size=0;

  switch (Info->Type)
  {
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
           slibWriteH261(Info, flush);
           break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
           slibWriteH263(Info, flush);
           break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
           slibWriteMpegVideo(Info, flush);
           break;
    case SLIB_TYPE_MPEG1_AUDIO:
           slibWriteMpegAudio(Info, flush);
           break;
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
           slibWriteMpeg1Systems(Info, flush);
           break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
           slibWriteSlibHuff(Info, flush);
           break;
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
           slibWriteG723Audio(Info, flush);
           break;
#endif /* G723_SUPPORT */
    default:
           _SlibDebug(_VERBOSE_ || _WARN_,
                 printf("slibCommitBuffers() Unknown type\n") );
           return(FALSE);
  }
  return(Info->IOError ? FALSE : TRUE);
}

/************************** Data Stream Parsers ***********************/
/*
** Function: slibParseWave()
** Descript: Parse Wave (RIFF) and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseWave(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if (Info->AudioTimeStamp==0)
    {
      /* Discard header data from Compressed Pin */
      buf = slibSearchBuffersOnPin(Info, srcpin,
                              NULL, &size, RIFF_DATA, 4, TRUE);
      if (buf)
      {
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        slibGetDWordFromPin(Info, srcpin); /* discard Chunk size */
        Info->AudioTimeStamp=1;
      }
    }
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      _SlibDebug(_DEBUG_, printf("slibParseWave() adding %d bytes\n", size));
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}

#ifdef AC3_SUPPORT
/*
** Function: slibParseAC3Audio()
** Descript: Parse Dolby AC-3 Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseAC3Audio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                  SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegAudio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseAC3Audio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* AC3_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpegAudio()
** Descript: Parse MPEG Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpegAudio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegAudio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseMpegAudio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpegVideo()
** Descript: Parse MPEG Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpegVideo(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseMpegVideo()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseMpegVideo() added %d bytes\n",
                            size));
      return(TRUE);
    }
    _SlibDebug(_DEBUG_, 
          printf("slibParseMpegVideo() couldn't get COMPRESSED data\n"));
  }
  _SlibDebug(_DEBUG_, printf("slibParseMpegVideo() pins not ready\n"));
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
#define skipbytes(b) if (size<=b) { \
                      oldsize = size; SlibFreeBuffer(bufstart); \
                buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL); \
                      if (!buf) return(FALSE); \
                      buf+=b-oldsize; size-=b-oldsize; \
                     } else { buf+=b; size-=b; }
/*
** Function: slibParseMpeg1Sytems()
** Descript: Parse MPEG I Systems stream and add Video data to Video Pin
**           and Audio to the Audio Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg1Systems(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  _SlibDebug(_DEBUG_ || _PARSE_, printf("slibParseMpeg1Systems()\n"));
  if (srcpin)
  {
    unsigned char abyte, packettype;
    unsigned dword PacketLength;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size, oldsize;
    SlibTime_t ptimestamp=SLIB_TIME_NONE;
    SlibPin_t *dstpin;
    while ((buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_START_CODE, MPEG_START_CODE_LEN/8, TRUE))!=NULL)
    {
      _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #1\n") );
      packettype = *buf;
      skipbytes(1);
      if (packettype > 0xBB) /* it's a packet */
      {
        _SlibDebug(_DEBUG_||_PARSE_, printf("Found Packet size=%d\n", size));
        PacketLength=(unsigned dword)(*buf<<8);
        skipbytes(1);
        PacketLength|=(unsigned dword)*buf;
        skipbytes(1);
        _SlibDebug(_DEBUG_||_PARSE_, printf(" PacketLength=%d\n",PacketLength));
        while (*buf == 0xFF) /* Stuffing bytes */
        {
          skipbytes(1);
          PacketLength--;
        }
        _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #3\n") );
        abyte=*buf;
        if ((abyte & 0xC0)==0x40)  /* STD_buffer stuff */
        {
          skipbytes(2);
          PacketLength-=2;
          abyte=*buf;
        }
        _SlibDebug(_VERIFY_ && size<1, printf("Insufficient bytes #4\n") );
        
        if ((abyte & 0xF0)==0x20 || (abyte & 0xF0)==0x30)
        {
          if (packettype!=Info->VideoMainStream &&
              packettype!=Info->AudioMainStream)
          {
            skipbytes(5); /* skip Presentation Time Stamp */
            PacketLength-=5;
            if ((abyte & 0xF0)==0x30) /* skip Decoding timestamp */
            {
              skipbytes(5);
              PacketLength-=5;
            }
          }
          else
          {
            /* Presentation Time Stamp */
            ptimestamp=(*buf)&0x0E; ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf); ptimestamp<<=8;
            skipbytes(1);
            ptimestamp|=(*buf)&0xFE; ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf); ptimestamp<<=7;
            skipbytes(1);
            ptimestamp|=(*buf)&0xFE;
            skipbytes(1);
            ptimestamp/=90;
            if (packettype==Info->VideoMainStream)
            {
              if (!SlibTimeIsValid(Info->VideoPTimeBase) ||
                     ptimestamp<Info->VideoPTimeBase)
              {
                Info->VideoPTimeBase=ptimestamp;
                _SlibDebug(_PARSE_ || _TIMECODE_,
                  printf("slibParseMpeg1Systems() VideoPTimeBase=%ld\n",
                      Info->VideoPTimeBase));
              }
            }
            else if (packettype==Info->AudioMainStream)
            {
              if (!SlibTimeIsValid(Info->AudioPTimeBase) ||
                     ptimestamp<Info->AudioPTimeBase)
              {
                Info->AudioPTimeBase=ptimestamp;
                _SlibDebug(_PARSE_ || _TIMECODE_,
                  printf("slibParseMpeg1Systems() AudioPTimeBase=%ld\n",
                      Info->AudioPTimeBase));
              }
            }
            PacketLength-=5;
            /* Decoding timestamp */
            if ((abyte & 0xF0)==0x30)
            {
              SlibTime_t dtimestamp;
              dtimestamp=(*buf)&0x0E; dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf); dtimestamp<<=8;
              skipbytes(1);
              dtimestamp|=(*buf)&0xFE; dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf); dtimestamp<<=7;
              skipbytes(1);
              dtimestamp|=(*buf)&0xFE;
              skipbytes(1);
              dtimestamp/=90;
              if (packettype==Info->VideoMainStream)
              {
                _SlibDebug(_TIMECODE_, 
                      printf("Video DTimeCode=%d\n", dtimestamp) );
                Info->VideoDTimeCode=dtimestamp;
              }
              else if (packettype==Info->AudioMainStream)
              {
                _SlibDebug(_TIMECODE_, 
                      printf("Audio DTimeCode=%d\n", dtimestamp) );
                Info->AudioDTimeCode=dtimestamp;
              }
              PacketLength-=5;
            }
          }
        }
        else if (abyte != 0x0F)
        {
          _SlibDebug(_VERIFY_, printf("Last byte before data not 0x0F\n") );
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          _SlibDebug(_VERIFY_, printf("Searching for next packet\n") );
          continue;  /* try to recover */
        }
        else
        {
          skipbytes(1);
          PacketLength--;
        }
        if (packettype==Info->VideoMainStream)
          dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
        else if (packettype==Info->AudioMainStream)
          dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
        else
          dstpin = NULL;
        if (dstpin && slibPinOverflowing(Info, dstpin))
        {
          slibPinPrepareReposition(Info, dstpin->ID);
          _SlibDebug(_WARN_,
                 printf("Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
          if (dstpin->ID == SLIB_DATA_VIDEO)
          {
            dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
            if (Info->FramesPerSec)
              Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
          }
          _SlibDebug(_WARN_,
              printf("new videotime=%ld\n", Info->VideoTimeStamp) );
          slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
          slibPinFinishReposition(Info, dstpin->ID);
          if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
            SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
        }
        if (dstpin && !slibPinOverflowing(Info, dstpin))
        {
          _SlibDebug(_DEBUG_>1, printf("Adding Packet %X\n", packettype) );
          /* add the packet to the destination pin */
          while (PacketLength>size)
          {
            _SlibDebug(_WARN_>1,
                       printf("PacketLength=%d but buffer is %d bytes\n",
                       PacketLength, size) );
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#1 size = %d\n", size));
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              slibAddBufferToPin(dstpin, buf, size, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              PacketLength-=size;
            }
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf)
              return(fillpin==dstpin ? TRUE : FALSE);
          }
          if (PacketLength)
          {
            SlibAllocSubBuffer(buf, PacketLength);
            slibAddBufferToPin(dstpin, buf, PacketLength, ptimestamp);
            ptimestamp=SLIB_TIME_NONE;
            size-=PacketLength;
            buf+=PacketLength;
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                         printf("#3 size = %d\n", size));
          }
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          if (fillpin==dstpin)
            return(TRUE);
          if (fillpin==NULL)
            return(FALSE);
        }
        else /* dump the packet */
        {
          _SlibDebug(_WARN_ && dstpin,
                    printf("Dumping packet %X (Overflow)\n", packettype) );
          _SlibDebug((_WARN_>1 && !dstpin)||packettype==Info->VideoMainStream
                                          ||packettype==Info->AudioMainStream, 
                    printf("Dumping packet %X (No pin)\n", packettype) );
          while (PacketLength>size)
          {
            PacketLength-=size;
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            _SlibDebug(_VERIFY_ && !buf,
                     printf("Dumping Packet: no more buffers\n"));
            if (buf==NULL)
              return(FALSE);
          }
          buf+=PacketLength;
          size-=PacketLength;
          _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                  printf("#5 size = %d\n", size));
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          ptimestamp=SLIB_TIME_NONE;
        }
      } /* packet */
      else /* put buffer back on the input pin */
      {
        _SlibDebug(_DEBUG_, printf("Not a packet %X - putting back buffer\n",
                                  packettype) );
        _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#6 size = %d\n", size));
        if (size)
        {
          SlibAllocSubBuffer(buf, size);
          slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        }
        SlibFreeBuffer(bufstart);
      }
    } /* while */
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
static SlibBoolean_t slibParsePESHeader(SlibInfo_t *Info, SlibPin_t *srcpin,
                           unsigned char **bufferstart, unsigned char **buffer,
                           unsigned dword *buffersize,
                           int *headerlen, unsigned dword *packetlen,
                           int *packettype, SlibTime_t *ptimestamp)
{
  unsigned dword bytesprocessed=0;
  unsigned dword PES_packet_length=0;
  unsigned char *buf, *bufstart;
  unsigned dword size, oldsize, header_len;
  _SlibDebug(_DEBUG_||_VERBOSE_||_PARSE_, printf("slibParsePESHeader()\n"));
  if (*buffer==NULL)
  {
    *packettype=0;
    _SlibDebug(_VERIFY_,
         buf=slibPeekBufferOnPin(Info, srcpin, &size, NULL);
         if (buf && size>=8 && (buf[0]!=0x00 || buf[1]!=0x00 || buf[2]!=0x01))
           ScDebugPrintf(Info->dbg,
              "slibParsePESHeader() lost start code: %02X %02X %02X %02X %02X %02X %02X %02X\n",
                          buf[0], buf[1], buf[2], buf[3],
                          buf[4], buf[5], buf[6], buf[7]) );
    do {
      size=0;
      buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_START_CODE, MPEG_START_CODE_LEN/8, TRUE);
      if (!buf) return(FALSE);
      *packettype=*buf;
      if (*packettype>0xBB) /* useful packet start code */
      {
        skipbytes(1); /* skip packettype */
        break;
      }
      _SlibDebug(_DEBUG_||_PARSE_,
        ScDebugPrintf(Info->dbg,
          "slibParsePESHeader() skipping packettype=%02X\n", *packettype));
      /* put buffer back on the input pin */
      if (size)
      {
        SlibAllocSubBuffer(buf, size);
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
      }
      SlibFreeBuffer(bufstart);
    } while (1);
  }
  else
  {
    buf=*buffer;
    bufstart=*bufferstart;
    size=*buffersize;
    _SlibDebug(_VERIFY_ && size<4, ScDebugPrintf(Info->dbg,"Insufficient bytes #5\n") );
    if (buf[0]==0x00 && buf[1]==0x00 && buf[2]==0x01)
    {
      *packettype=buf[3];
      if (*packettype>0xBB)
      {
        skipbytes(4); /* skip start code */
        bytesprocessed+=4;
      }
    }
    else
      *packettype=0;
  }
  if (*packettype>0xBB) /* useful packet start code */
  {
    unsigned short PTS_DTS_flags;
    _SlibDebug(_DEBUG_||_PARSE_,
            printf("slibParsePESHeader() packettype=%02X\n", *packettype));
    _SlibDebug(_VERIFY_ && size<4, ScDebugPrintf(Info->dbg,"Insufficient bytes #6\n") );
    /* PES_packet_length */
    PES_packet_length=((unsigned dword)buf[0])<<8;
    skipbytes(1);
    PES_packet_length|=buf[0];
    skipbytes(1);
    bytesprocessed+=2;
    if (*packettype==MPEG_PROGRAM_STREAM ||
        *packettype==MPEG_PADDING_STREAM_BASE ||
        *packettype==MPEG_PRIVATE_STREAM2_BASE)
    {
      PTS_DTS_flags=0;
      header_len=0;
      _SlibDebug(_DEBUG_||_PARSE_,
           ScDebugPrintf(Info->dbg,"PES Packet 0x%02X, Length=%d, Header Len=%d\n",
                  *packettype, PES_packet_length, header_len));
    }
    else
    {
      /* PES_packet_length-=18; */
      /* PES header stuff */
      _SlibDebug(_PARSE_ && size>4, ScDebugPrintf(Info->dbg,
          "PES Packet 0x%02X, header stuff: 0x%02X %02X %02X %02X\n",
              *packettype, buf[0], buf[1], buf[2], buf[3]));
      skipbytes(1);
      PTS_DTS_flags=buf[0]>>6;
      skipbytes(1);
      header_len=buf[0];/* get PES header len */
      skipbytes(1); /* PES header len */
      bytesprocessed+=3;
      PES_packet_length-=3;
      PES_packet_length-=header_len;
      _SlibDebug(_DEBUG_||_PARSE_,
       ScDebugPrintf(Info->dbg,
         "PES Packet 0x%02X, Length=%d, Header Len=%d, PTS_DTS_flags=%d\n",
                 *packettype, PES_packet_length, header_len, PTS_DTS_flags ));
      if (header_len>0 && (PTS_DTS_flags==2 || PTS_DTS_flags==3))
      {
        /* Presentation Time Stamp */
        unsigned long timestamp;
        timestamp=(*buf)&0x0E; timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf); timestamp<<=8;
        skipbytes(1);
        timestamp|=(*buf)&0xFE; timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf); timestamp<<=7;
        skipbytes(1);
        timestamp|=(*buf)&0xFE;
        skipbytes(1);
        timestamp/=90;
        *ptimestamp = timestamp;
        bytesprocessed+=5;
        header_len-=5;
        /* Decoding timestamp */
        if (PTS_DTS_flags==3)
        {
          timestamp=(*buf)&0x0E; timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf); timestamp<<=8;
          skipbytes(1);
          timestamp|=(*buf)&0xFE; timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf); timestamp<<=7;
          skipbytes(1);
          timestamp|=(*buf)&0xFE;
          skipbytes(1);
          timestamp/=90;
          if (*packettype==Info->VideoMainStream ||
              (Info->Type==SLIB_TYPE_MPEG_TRANSPORT &&
              *packettype>=MPEG_VIDEO_STREAM_START &&
              *packettype<=MPEG_VIDEO_STREAM_END))
          {
            _SlibDebug(_TIMECODE_,
                   ScDebugPrintf(Info->dbg,"Video DTimeCode=%d\n",timestamp));
            Info->VideoDTimeCode=timestamp;
          }
          else if (*packettype==Info->AudioMainStream ||
                   (Info->Type==SLIB_TYPE_MPEG_TRANSPORT &&
                   *packettype>=MPEG_AUDIO_STREAM_START &&
                   *packettype<=MPEG_AUDIO_STREAM_END))
          {
            _SlibDebug(_TIMECODE_,
                   ScDebugPrintf(Info->dbg,"Audio DTimeCode=%d\n",timestamp));
            Info->AudioDTimeCode=timestamp;
          }
          bytesprocessed+=5;
          header_len-=5;
        }
      } 
    }
    if (header_len>0)
    {
      _SlibDebug(_PARSE_,
       ScDebugPrintf(Info->dbg,"slibParsePESHeader() skipping header: %d bytes\n",
                             header_len));
      while ((int)size<=header_len)
      {
        _SlibDebug(_PARSE_,
         ScDebugPrintf(Info->dbg,"slibParsePESHeader() size=%d <= header_len=%d\n",
                             size, header_len));
        SlibFreeBuffer(bufstart);
        header_len-=size;
        bytesprocessed+=size;
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
        if (!buf) return(FALSE);
      }
      buf+=header_len;
      _SlibDebug(_VERIFY_ && size<(unsigned dword)header_len, 
                   ScDebugPrintf(Info->dbg,"Insufficient bytes\n") );
      size-=header_len;
      bytesprocessed+=header_len;
    }
  }
  
  /* If this is private data containing AC3, skip private header */
  if (*packettype==MPEG_PRIVATE_STREAM1_BASE && (size<=0 || *buf==0x80))
  {
    /* header = 4 bytes = Hex: 80 0X XX XX */
    skipbytes(4);
    bytesprocessed+=4;
    PES_packet_length-=4;
  }
  *buffer=buf;
  *bufferstart=bufstart;
  *buffersize=size;
  if (headerlen)
    *headerlen=bytesprocessed;
  if (packetlen)
    *packetlen=PES_packet_length;
  _SlibDebug(_PARSE_,
   ScDebugPrintf(Info->dbg,"slibParsePESHeader() bytesprocessed=%d packetlen=%d\n",
                            bytesprocessed, PES_packet_length));
  return(TRUE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpeg2Program()
** Descript: Parse MPEG II Program stream and add Video data to Video Pin
**           and Audio to the Audio Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg2Program(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  _SlibDebug(_DEBUG_||_PARSE_, ScDebugPrintf(Info->dbg,"slibParseMpeg2Program()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (srcpin)
  {
    unsigned dword PacketLength;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size;
    SlibTime_t ptimestamp = SLIB_TIME_NONE;
    int header_len, packettype;
    SlibPin_t *dstpin;
    do {
      buf=NULL;
      if (!slibParsePESHeader(Info, srcpin, &bufstart, &buf, &size,
                          &header_len, &PacketLength, &packettype,
                          &ptimestamp))
      {
        _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"slibParsePESHeader() failed\n") );
        return(FALSE);
      }
      if (packettype)
      {
        if (packettype==Info->VideoMainStream)
        {
          _SlibDebug(_PARSE_,
              ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() VIDEO packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
          if (SlibTimeIsValid(ptimestamp) && 
               (!SlibTimeIsValid(Info->VideoPTimeBase) ||
                  ptimestamp<Info->VideoPTimeBase))
          {
            Info->VideoPTimeBase=ptimestamp;
            _SlibDebug(_PARSE_ || _TIMECODE_,
               ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() VideoPTimeBase=%ld\n",
                     Info->VideoPTimeBase));
          }
        }
        else if (packettype==Info->AudioMainStream)
        {
          _SlibDebug(_PARSE_,
              ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() AUDIO packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
          if (SlibTimeIsValid(ptimestamp) && 
               (!SlibTimeIsValid(Info->AudioPTimeBase) ||
                  ptimestamp<Info->AudioPTimeBase))
          {
            Info->AudioPTimeBase=ptimestamp;
            _SlibDebug(_PARSE_ || _TIMECODE_,
               ScDebugPrintf(Info->dbg,"slibParseMpeg2Program() AudioPTimeBase=%ld\n",
                     Info->AudioPTimeBase));
          }
        }
        else if (packettype==MPEG_PRIVATE_STREAM1_BASE)
        {
          _SlibDebug(_PARSE_, printf("slibParseMpeg2Program() PRIVATE packet\n"));
          dstpin = slibGetPin(Info, SLIB_DATA_PRIVATE);
        }
        else
        {
          _SlibDebug(_PARSE_,
            ScDebugPrintf(Info->dbg,
             "slibParseMpeg2Program() unknown packet 0x%02X, %d bytes\n",
                               packettype, PacketLength));
          dstpin = NULL;
        }
        if (dstpin && slibPinOverflowing(Info, dstpin))
        {
          slibPinPrepareReposition(Info, dstpin->ID);
          _SlibDebug(_WARN_,
            ScDebugPrintf(Info->dbg,"Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
          if (dstpin->ID == SLIB_DATA_VIDEO)
          {
            dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
            if (Info->FramesPerSec)
              Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
          }
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"%d\n", Info->VideoTimeStamp) );
          slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
          slibPinFinishReposition(Info, dstpin->ID);
          if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
            SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
        }
        if (dstpin && !slibPinOverflowing(Info, dstpin))
        {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"Adding Packet %X, %d bytes\n",
                     packettype, PacketLength) );
          /* add the packet to the destination pin */
          while (PacketLength>size)
          {
            _SlibDebug(_WARN_>1,
                   ScDebugPrintf(Info->dbg,"PacketLength=%d but buffer is %d bytes\n",
                       PacketLength, size) );
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      printf("#1 size = %d\n", size));
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              /* ScDumpChar(buf, size, 0); */
              slibAddBufferToPin(dstpin, buf, size, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              PacketLength-=size;
            }
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf)
              return(fillpin==dstpin ? TRUE : FALSE);
          }
          if (PacketLength)
          {
            SlibAllocSubBuffer(buf, PacketLength);
            /* ScDumpChar(buf, PacketLength, 0); */
            slibAddBufferToPin(dstpin, buf, PacketLength, ptimestamp);
            ptimestamp=SLIB_TIME_NONE;
            size-=PacketLength;
            buf+=PacketLength;
            _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                         ScDebugPrintf(Info->dbg,"#3 size = %d\n", size));
          }
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
          if (fillpin==dstpin)
            return(TRUE);
          if (fillpin==NULL)
            return(FALSE);
        }
        else /* dump the packet */
        {
          _SlibDebug(_WARN_ && dstpin,
               ScDebugPrintf(Info->dbg,"Dumping packet %X (Overflow)\n", packettype) );
          _SlibDebug((_WARN_>1 && !dstpin)||packettype==Info->VideoMainStream
                                          ||packettype==Info->AudioMainStream, 
               ScDebugPrintf(Info->dbg,"Dumping packet %X (No pin)\n", packettype) );
          while (PacketLength>size)
          {
            PacketLength-=size;
            SlibFreeBuffer(bufstart);
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            _SlibDebug(_VERIFY_ && !buf,
                   ScDebugPrintf(Info->dbg,"Dumping Packet: no more buffers\n"));
            if (buf==NULL)
              return(FALSE);
          }
          buf+=PacketLength;
          size-=PacketLength;
          _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                  ScDebugPrintf(Info->dbg,"#5 size = %d\n", size));
          /* add remaining buffer data back to input pin */
          if (size)
          {
            SlibAllocSubBuffer(buf, size);
            slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
          }
          SlibFreeBuffer(bufstart);
        }
      } /* packet */
      else /* put buffer back on the input pin */
      {
        _SlibDebug(_DEBUG_,
            ScDebugPrintf(Info->dbg,"Not a packet %X - putting back buffer\n",
                                  packettype) );
        _SlibDebug(_VERIFY_ && Info->Fd>=0 && size>Info->FileBufSize,
                      ScDebugPrintf(Info->dbg,"#6 size = %d\n", size));
        if (size)
        {
          SlibAllocSubBuffer(buf, size);
          slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
        }
        SlibFreeBuffer(bufstart);
      }
    } while (1);
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef MPEG_SUPPORT
/*
** Function: slibParseMpeg2Transport()
** Descript: Parse MPEG II Systems stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseMpeg2Transport(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                      SlibPin_t *fillpin)
{
  _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"slibParseMpeg2Transport()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (srcpin)
  {
    int pid, adapt_field, payload_len, header_len, packettype;
    unsigned char *buf, *bufstart=NULL;
    unsigned dword size, oldsize;
    SlibPin_t *dstpin;
    /* SlibTime_t ptimestamp=SLIB_TIME_NONE; */
    while ((buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL,
             &size, MPEG_TSYNC_CODE, MPEG_TSYNC_CODE_LEN/8, TRUE))!=NULL)
    {
      _SlibDebug(_VERIFY_ && size<2, ScDebugPrintf(Info->dbg,"Insufficient bytes #2\n") );
      pid=(int)(buf[0]&0x1F)<<8 | (int)buf[1]; /* 13 bits for PID */
      skipbytes(2);
      _SlibDebug(_VERIFY_ && size<1, ScDebugPrintf(Info->dbg,"Insufficient bytes #3\n") );
      adapt_field=(buf[0]>>4)&0x03; /* 2 bits for adapt_field */
      skipbytes(1);
      payload_len=184; /* PES are 184 bytes */
      if (adapt_field == 2 || adapt_field == 3)
      {
        _SlibDebug(_VERIFY_ && size<1, ScDebugPrintf(Info->dbg,"Insufficient bytes #4\n") );
        header_len=*buf;
        skipbytes(1);
        payload_len--;
        if (header_len) /* skip adaptation_field */
        {
          while ((int)size<=header_len)
          {
            SlibFreeBuffer(bufstart);
            header_len-=size;
            payload_len-=size;
            buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
            if (!buf) return(FALSE);
          }
          _SlibDebug(_VERIFY_ && size<(unsigned dword)header_len, 
                      ScDebugPrintf(Info->dbg,"Insufficient bytes\n") );
          buf+=header_len;
          size-=header_len;
          payload_len-=header_len;
        }
      }
      if ((adapt_field == 1 || adapt_field == 3)
             && (Info->VideoPID<0 || Info->VideoPID==pid ||
                 Info->AudioPID<0 || Info->AudioPID==pid)) /* payload */
      {
        unsigned dword packet_len;
        SlibTime_t ptimestamp = SLIB_TIME_NONE;
        /* see if PES packet header */
        if (slibParsePESHeader(Info, srcpin, &bufstart, &buf, &size,
                          &header_len, &packet_len, &packettype, &ptimestamp))
        {
          payload_len-=header_len;
          _SlibDebug(_VERIFY_ && payload_len<0, 
               ScDebugPrintf(Info->dbg,"payload_len<header_len, header_len=%d\n",
                              header_len) );
          if (pid!=MPEG_PID_NULL)
          {
            if (Info->VideoPID<0 && packettype>=MPEG_VIDEO_STREAM_START &&
                                    packettype<=MPEG_VIDEO_STREAM_END)
            {
              _SlibDebug(_VERBOSE_,
                  ScDebugPrintf(Info->dbg,"Selecting Video PID %d\n", pid) );
              Info->VideoPID=pid;
            }
            else if (Info->AudioPID<0 && packettype>=MPEG_AUDIO_STREAM_START &&
                                         packettype<=MPEG_AUDIO_STREAM_END)
            {
              _SlibDebug(_VERBOSE_,
                  ScDebugPrintf(Info->dbg,"Selecting Audio PID %d\n", pid) );
              Info->AudioPID=pid;
            }
          }
        }
        if (payload_len>0 && (Info->VideoPID==pid || Info->AudioPID==pid))
        {
          if (Info->VideoPID==pid)
            dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
          else
            dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
          if (dstpin && slibPinOverflowing(Info, dstpin))
          {
            slibPinPrepareReposition(Info, dstpin->ID);
            _SlibDebug(_WARN_,
                 ScDebugPrintf(Info->dbg,"Skipped data on Overflowing pin %s: time %d->",
                                     dstpin->name, Info->VideoTimeStamp) );
            if (dstpin->ID == SLIB_DATA_VIDEO)
            {
              dword frames=slibCountCodesOnPin(Info, dstpin,
                                 MPEG_PICTURE_START, 4, Info->OverflowSize/2);
              if (Info->FramesPerSec)
                Info->VideoTimeStamp+=slibFrameToTime(Info, frames);
            }
            _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"%d\n", Info->VideoTimeStamp) );
            slibSkipDataOnPin(Info, dstpin, Info->OverflowSize/2);
            slibPinFinishReposition(Info, dstpin->ID);
            if (dstpin->ID == SLIB_DATA_VIDEO) /* move to key frame */
              SlibSeek((SlibHandle_t *)Info, SLIB_STREAM_MAINVIDEO,
                                           SLIB_SEEK_NEXT_KEY, 0);
          }
          if (dstpin && !slibPinOverflowing(Info, dstpin))
          {
            _SlibDebug(_DEBUG_>1, 
                  ScDebugPrintf(Info->dbg,"Adding Packet: Head=%02X %02X %02X %02X\n",
                             buf[0], buf[1], buf[2], buf[3]) );
            /* add the packet to the destination pin */
            while ((int)size<payload_len)
            {
              _SlibDebug(_DEBUG_,
                         printf("payload_len=%d but buffer is %d bytes\n", 
                              payload_len, size) );
              if (size)
              {
                SlibAllocSubBuffer(buf, size);
                slibAddBufferToPin(dstpin, buf, size, ptimestamp);
                ptimestamp=SLIB_TIME_NONE;
                payload_len-=size;
              }
              SlibFreeBuffer(bufstart);
              buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
              if (!buf) return(fillpin==dstpin?TRUE:FALSE);
            }
            if (payload_len)
            {
              SlibAllocSubBuffer(buf, payload_len);
              slibAddBufferToPin(dstpin, buf, payload_len, ptimestamp);
              ptimestamp=SLIB_TIME_NONE;
              size-=payload_len;
              buf+=payload_len;
            }
            /* add remaining buffer data back to input pin */
            if (size)
            {
              SlibAllocSubBuffer(buf, size);
              _SlibDebug(_WARN_ && buf[0]!=MPEG_TSYNC_CODE, 
                ScDebugPrintf(Info->dbg,
                    "Next code not Transport Sync: %02X %02X %02X %02X\n",
                             buf[0], buf[1], buf[2], buf[3]) );
              slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
            }
            SlibFreeBuffer(bufstart);
            payload_len=0;
            size=0;
            if (fillpin==dstpin)
              return(TRUE);
            else if (fillpin==NULL)
              return(FALSE);
            continue;
          }
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,
             "ParseMpeg2Transport() Data not added: payload_len=%d PID=%d\n",
                                payload_len, pid) );
        }
      }
      if (payload_len>0) /* dump the payload */
      {
        if (payload_len>(int)size)
        {
          payload_len-=size;
          SlibFreeBuffer(bufstart);
          bufstart=slibGetBufferFromPin(Info, srcpin, &size, NULL);
          if (!bufstart)
            return(FALSE);
          buf=bufstart+payload_len;
          size-=payload_len;
        }
        else
        {
          buf+=payload_len;
          size-=payload_len;
        }
      }
      /* add remaining buffer data back to input pin */
      if (size)
      {
        SlibAllocSubBuffer(buf, size);
        _SlibDebug(_WARN_ && buf[0]!=MPEG_TSYNC_CODE, 
             ScDebugPrintf(Info->dbg,
                "Next code not Transport Sync: %02X %02X %02X %02X\n",
                          buf[0], buf[1], buf[2], buf[3]) );
        slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
      }
      SlibFreeBuffer(bufstart);
    } /* while */
  }
  return(FALSE);
}
#endif /* MPEG_SUPPORT */

#ifdef H261_SUPPORT
/*
** Function: slibParseH261()
** Descript: Parse H.261 Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseH261(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseH261()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* H261_SUPPORT */

#ifdef H263_SUPPORT
/*
** Function: slibParseH261()
** Descript: Parse H.261 Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseH263(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseH263()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if (Info->Type==SLIB_TYPE_RTP_H263)
    {
      word  rtp_start, sequence_no;
      dword sync_src, pay_start;
      /* RTP header */
      rtp_start=slibGetWordFromPin(Info, srcpin);
      sequence_no=slibGetWordFromPin(Info, srcpin);
      time=slibGetDWordFromPin(Info, srcpin);
      sync_src=slibGetDWordFromPin(Info, srcpin);
      /* RTP payload header */
      pay_start=slibGetDWordFromPin(Info, srcpin);
      if ((pay_start&0x80000000) == 0) /* Mode A */
      {
        size=Info->PacketSize-16;
        buf=SlibAllocBuffer(size);
      }
      else if ((pay_start&0x40000000) == 0) /* Mode B */
      {
        dword pay_start2=slibGetDWordFromPin(Info, srcpin);
        size=Info->PacketSize-20;
      }
      else /* Mode C */
      {
        dword pay_start2=slibGetDWordFromPin(Info, srcpin);
        size=Info->PacketSize-20;
      }
      buf=SlibAllocBuffer(size);
      if (buf==NULL) return(FALSE);
      size=slibFillBufferFromPin(Info, srcpin, buf, size, NULL);
      if (size)
        slibAddBufferToPin(dstpin, buf, size, time);
    }
    else
    {
      if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
      {
        slibAddBufferToPin(dstpin, buf, size, time);
        return(TRUE);
      }
    }
  }
  return(FALSE);
}
#endif /* H263_SUPPORT */

#ifdef HUFF_SUPPORT
/*
** Function: slibParseSlibHuff()
** Descript: Parse SLIB Huffman Video stream and add Video data to Video Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseSlibHuff(SlibInfo_t *Info, SlibPin_t *srcpin,
                                              SlibPin_t *dstpin)
{
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  _SlibDebug(_DEBUG_, printf("slibParseSlibHuff()\n"));
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    _SlibDebug(_VERBOSE_, printf("slibParseSlibHuff(%s)\n", srcpin->name) );
    if (!Info->HeaderProcessed)
    {
      _SlibDebug(_VERBOSE_, printf("slibParseSlibHuff() Header\n") );
      slibGetDWordFromPin(Info, srcpin); /* SLIB */
      slibGetDWordFromPin(Info, srcpin); /* HUFF */
      Info->HeaderProcessed=TRUE;
    }
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* HUFF_SUPPORT */

#ifdef G723_SUPPORT
/*
** Function: slibParseG723Audio()
** Descript: Parse G723 Audio stream and add Audio data to Audio Pin.
** Returns:  TRUE if data was added to dstpin, otherwise FALSE.
*/
SlibBoolean_t slibParseG723Audio(SlibInfo_t *Info, SlibPin_t *srcpin,
                                                    SlibPin_t *dstpin)
{
  _SlibDebug(_DEBUG_, printf("slibParseG723Audio()\n"));
  if (!srcpin)
    srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED);
  if (!dstpin)
    dstpin = slibGetPin(Info, SLIB_DATA_AUDIO);
  if (srcpin && dstpin)
  {
    unsigned char *buf;
    unsigned dword size;
    SlibTime_t time;
    if ((buf=slibGetBufferFromPin(Info, srcpin, &size, &time))!=NULL)
    {
      slibAddBufferToPin(dstpin, buf, size, time);
      _SlibDebug(_DEBUG_, printf("slibParseG723Audio() added %d bytes\n",
                            size));
      return(TRUE);
    }
  }
  return(FALSE);
}
#endif /* G723_SUPPORT */

/*
** Function: slibParseAVI()
** Descript: Parse AVI data and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseAVI(SlibInfo_t *Info, SlibPin_t *srcpin,
                                             SlibPin_t *fillpin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  SlibTime_t time=SLIB_TIME_NONE;
  SlibPin_t *dstpin;
  _SlibDebug(_DEBUG_, printf("slibParseAVI()\n") );
  if (!srcpin && (srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED))==NULL)
    return(FALSE);
  /* only searching for video, for now */
  dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  do {
    buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
               (('0'<<16) | ('0'<<8) | 'd'), 3, TRUE);
                                  /* AVI_DIBcompressed or AVI_DIBbits */
    if (buf==NULL || *buf=='c' || *buf=='b')
      break;
    /* put buffer back on input to be search again */
    slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
  } while (buf);
  if (buf && dstpin)
  {
    unsigned dword framesize;
    buf++;  /* skip 'c' or 'b' */
    size--;
    framesize=((int)buf[3]<<24)|((int)buf[2]<<16)|
                    ((int)buf[1]<<8)|buf[0];
    buf+=4;
    size-=4;
    if (framesize==0)
      return(FALSE);
    else if (size>=framesize)
    {
      SlibAllocSubBuffer(buf, framesize);
      slibAddBufferToPin(dstpin, buf, framesize, time);
    }
    else
    {
      /* frame data crosses over into next buffer */
      unsigned char *newbuf=SlibAllocBuffer(framesize);
      slibAddBufferToPin(dstpin, newbuf, framesize, time);
      _SlibDebug(_DEBUG_, printf("Copying in sections\n") );
      do {
        _SlibDebug(_DEBUG_,
          printf("Copying %d bytes (framesize=%d)\n", size, framesize) );
        memcpy(newbuf, buf, size);
        newbuf+=size;
        framesize-=size;
        SlibFreeBuffer(bufstart);
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, &time);
        if (buf==NULL)
          return(FALSE);
      } while (size<framesize);
      if (framesize>0)
        memcpy(newbuf, buf, framesize);
    }
    buf+=framesize;
    size-=framesize;
    if (size>0) /* add remaining data back onto src pin */
    {
      SlibAllocSubBuffer(buf, size);
      slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
    }
    SlibFreeBuffer(bufstart);
    if (fillpin==dstpin)
      return(TRUE);
  }
  else
    _SlibDebug(_DEBUG_, printf("Failed to find JPEG frame\n") );
  return(FALSE);
}

/*
** Function: slibParseRaster()
** Descript: Parse Sun Raster data and add Video data to Video Pin.
** Returns:  TRUE if data was added to fillpin, otherwise FALSE.
*/
SlibBoolean_t slibParseRaster(SlibInfo_t *Info, SlibPin_t *srcpin,
                                             SlibPin_t *fillpin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  SlibTime_t time=SLIB_TIME_NONE;
  SlibPin_t *dstpin;
  _SlibDebug(_DEBUG_, printf("slibParseRaster()\n") );
  if (!srcpin && (srcpin = slibLoadPin(Info, SLIB_DATA_COMPRESSED))==NULL)
    return(FALSE);
  /* only searching for video, for now */
  dstpin = slibGetPin(Info, SLIB_DATA_VIDEO);
  buf = bufstart = slibSearchBuffersOnPin(Info, srcpin, NULL, &size,
               0x59a66a95, 4, TRUE);
  if (buf && dstpin)
  {
    unsigned dword framesize;
    buf+=28;  /* skip header */
    size-=28;
    if (Info->CompVideoFormat)
      framesize=Info->CompVideoFormat->biWidth*Info->CompVideoFormat->biHeight*3;
    else
      framesize=Info->Width*Info->Height*3;
    if (size>=framesize)
    {
      SlibAllocSubBuffer(buf, framesize);
      slibAddBufferToPin(dstpin, buf, framesize, time);
    }
    else
    {
      /* frame data crosses over into next buffer */
      unsigned char *newbuf=SlibAllocBuffer(framesize);
      slibAddBufferToPin(dstpin, newbuf, framesize, time);
      _SlibDebug(_DEBUG_, printf("Copying in sections\n") );
      do {
        _SlibDebug(_DEBUG_,
          printf("Copying %d bytes (framesize=%d)\n", size, framesize) );
        memcpy(newbuf, buf, size);
        newbuf+=size;
        framesize-=size;
        SlibFreeBuffer(bufstart);
        buf=bufstart=slibGetBufferFromPin(Info, srcpin, &size, &time);
        if (buf==NULL)
          return(FALSE);
      } while (size<framesize);
      if (framesize>0)
        memcpy(newbuf, buf, framesize);
    }
    buf+=framesize;
    size-=framesize;
    if (size>0) /* add remaining data back onto src pin */
    {
      SlibAllocSubBuffer(buf, size);
      slibInsertBufferOnPin(srcpin, buf, size, SLIB_TIME_NONE);
    }
    SlibFreeBuffer(bufstart);
    if (fillpin==dstpin)
      return(TRUE);
  }
  else
    _SlibDebug(_DEBUG_, printf("Failed to find Raster frame\n") );
  return(FALSE);
}

/*
** Name: slibSetMaxInput
** Desc: Set the maximum number of bytes allowed to be input.
**       Use maxbytes=0 for no limit.
*/
void slibSetMaxInput(SlibInfo_t *Info, unsigned dword maxbytes)
{
  Info->MaxBytesInput=maxbytes;
  if (maxbytes)
  {
    SlibPin_t *pin = slibGetPin(Info, SLIB_DATA_COMPRESSED);
    if (pin)
      Info->InputMarker=pin->Offset;
    else
      Info->MaxBytesInput=0;
  }
}

/*
** Name: slibGetPinPosition
** Desc: Get the current byte position counter for a pin.
** Return: -1 if pin doesn't exist
*/
SlibPosition_t slibGetPinPosition(SlibInfo_t *Info, int pinid)
{
  SlibPin_t *pin;
  _SlibDebug(_DEBUG_>1, printf("slibGetPinPosition(pinid=%d)\n", pinid) );
  if ((pin=slibGetPin(Info, pinid))!=NULL)
    return(pin->Offset);
  else
    return((SlibPosition_t)-1);
}

/*
** Name: slibSetPinPosition
** Desc: Set the byte position counter for a pin.
**       Called when seeking to a new offset.
** Return: old position
**         -1 if pin doesn't exist
*/
SlibPosition_t slibSetPinPosition(SlibInfo_t *Info, int pinid,
                                                    SlibPosition_t pos)
{
  SlibPin_t *pin;
  SlibPosition_t oldpos;
  _SlibDebug(_DEBUG_, printf("slibSetPinPosition(pinid=%d, pos=%ld)\n",
                                     pinid, pos) );
  if ((pin=slibGetPin(Info, pinid))!=NULL)
  {
    oldpos=pin->Offset;
    pin->Offset=pos;
    return(oldpos);
  }
  else
    return((SlibPosition_t)-1);
}

/*
** Name: slibPreLoadPin
** Desc: Load a buffer onto a particular pin (try to get it from the 
**       appropriate source).
*/
SlibPin_t *slibPreLoadPin(SlibInfo_t *Info, SlibPin_t *pin)
{
  unsigned char *buf, *bufstart=NULL;
  unsigned dword size;
  _SlibDebug(_DEBUG_, printf("slibPreLoadPin(%s)\n",pin->name) );
  if (!pin || Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(NULL);
  switch (pin->ID)
  {
      case SLIB_DATA_COMPRESSED:
            _SlibDebug(_DEBUG_ && Info->MaxBytesInput,
                        printf("Offset=%d InputMarker=%d\n",
                             pin->Offset, Info->InputMarker) );
            if (Info->MaxBytesInput && 
                 (pin->Offset-Info->InputMarker)>=Info->MaxBytesInput)
              return(NULL);
            if (Info->SlibCB) /* data source is an application callback */
            {
              SlibMessage_t result;
              _SlibDebug(_VERBOSE_,
                 printf("slibPreLoadPin(%s) SlibCB(SLIB_MSG_ENDOFDATA)\n",
                      pin->name) );
              result=(*(Info->SlibCB))((SlibHandle_t)Info,
                             SLIB_MSG_ENDOFDATA, (SlibCBParam1_t)0, 
                            (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
              switch (result)
              {
                case SLIB_MSG_CONTINUE:
                      return(pin);
                case SLIB_MSG_ENDOFSTREAM:
                case SLIB_MSG_ENDOFDATA:
                case SLIB_MSG_BADPOSITION:
                      Info->IOError=TRUE;
                      break;
                default:
                      return(NULL);
              }
            }
            else if (Info->Fd>=0) /* data source is a file */
            {
              if ((buf=SlibAllocBuffer(Info->FileBufSize))==NULL)
                return(NULL);
              _SlibDebug(_VERBOSE_,
                 printf("slibPreLoadPin(%s) ScFileRead(%d, %d bytes)\n",
                                  pin->name, Info->Fd, Info->FileBufSize) );
              size = ScFileRead(Info->Fd, buf, Info->FileBufSize);
              if (size<Info->FileBufSize)
                Info->IOError=TRUE;
              if (size <= 0)
              {
                SlibFreeBuffer(buf);
                return(NULL);
              }
              else
              {
                slibAddBufferToPin(pin, buf, size, SLIB_TIME_NONE);
                return(pin);
              }
            }
            break;
      case SLIB_DATA_AUDIO:
            switch (Info->Type)
            {
                case SLIB_TYPE_PCM_WAVE:
                      if (slibParseWave(Info, NULL, pin))
                        return(pin);
                      break;
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG1_AUDIO:
                      if (slibParseMpegAudio(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
                case SLIB_TYPE_AC3_AUDIO:
                      if (slibParseAC3Audio(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
                case SLIB_TYPE_G723:
                      if (slibParseG723Audio(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* G723_SUPPORT */
            }
            break;
      case SLIB_DATA_VIDEO:
            switch (Info->Type)
            {
                case SLIB_TYPE_AVI:
                case SLIB_TYPE_YUV_AVI:
                      if (slibParseAVI(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_RASTER:
                      if (slibParseRaster(Info, NULL, pin))
                        return(pin);
                      break;
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG1_VIDEO:
                case SLIB_TYPE_MPEG2_VIDEO:
                      if (slibParseMpegVideo(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
                case SLIB_TYPE_H261:
                case SLIB_TYPE_RTP_H261:
                      if (slibParseH261(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
                case SLIB_TYPE_H263:
                case SLIB_TYPE_RTP_H263:
                      if (slibParseH263(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
                case SLIB_TYPE_JPEG_AVI:
                case SLIB_TYPE_MJPG_AVI:
                      if (slibParseAVI(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* JPEG_SUPPORT */
#ifdef HUFF_SUPPORT
                case SLIB_TYPE_SHUFF:
                      if (slibParseSlibHuff(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* HUFF_SUPPORT */
            }
            break;
      case SLIB_DATA_PRIVATE:
            switch (Info->Type)
            {
#ifdef MPEG_SUPPORT
                case SLIB_TYPE_MPEG_SYSTEMS:
                case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
                      if (slibParseMpeg1Systems(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_PROGRAM:
                      if (slibParseMpeg2Program(Info, NULL, pin))
                        return(pin);
                      break;
                case SLIB_TYPE_MPEG_TRANSPORT:
                      if (slibParseMpeg2Transport(Info, NULL, pin))
                        return(pin);
                      break;
#endif /* MPEG_SUPPORT */
            }
            break;
  }
  return(NULL);
}

/*
** Name:    slibPutBuffer
** Purpose: Send a buffer to the appropriate output.
*/
SlibStatus_t slibPutBuffer(SlibInfo_t *Info, unsigned char *buffer,
                                             unsigned dword bufsize)
{
  _SlibDebug(_VERBOSE_ || _WRITE_,
        printf("slibPutBuffer(%d) %d bytes\n", Info->Fd, bufsize) );
  if (bufsize==0)
    return(SlibErrorNone);
  if (Info->IOError || buffer==NULL)
    return(SlibErrorWriting);
  if (Info->Fd>=0) /* writing to a file */
  {
    if ((unsigned dword)ScFileWrite(Info->Fd, buffer, bufsize)<bufsize)
      Info->IOError=TRUE;
    if (SlibValidBuffer(buffer))
      SlibFreeBuffer(buffer);
  }
  else if (Info->SlibCB) /* sending data back to app through a callback */
  {
    _SlibDebug(_WARN_,
        printf("slibPutBuffer(%d) callbacks not yet supported\n") );
    if (SlibValidBuffer(buffer))
      SlibFreeBuffer(buffer);
  }
  else /* adding buffer to compress data pin */
  {
    unsigned char *bufptr=buffer;
    SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
    if (!SlibValidBuffer(bufptr))
    {
      /* we need to create a SLIB allocated buffer to copy the
       * output to and then add to the compressed data pin
       */
      bufptr=SlibAllocBuffer(bufsize);
      if (!bufptr)
        return(SlibErrorMemory);
      memcpy(bufptr, buffer, bufsize);
    }
    if (slibAddBufferToPin(pin, bufptr, bufsize, SLIB_TIME_NONE)!=SlibErrorNone)
     return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

/*
** Name:    slibGetBufferFromPin
** Purpose: Read the next buffer from the data source.
*/
unsigned char *slibGetBufferFromPin(SlibInfo_t *Info, SlibPin_t *pin,
                                    unsigned dword *size, SlibTime_t *time)
{
  unsigned char *address=NULL;
  _SlibDebug(_DEBUG_>1, printf("slibGetBufferFromPin(%s)\n", pin->name) );
  if (slibLoadPin(Info, pin->ID) != NULL)
  {
    SlibBuffer_t *tmpbuf = pin->Buffers;
    pin->Offset=tmpbuf->offset+tmpbuf->size;
    if (tmpbuf->next == NULL)
      pin->BuffersTail = NULL;
    pin->Buffers = tmpbuf->next;
    address=tmpbuf->address;
    if (size)
      *size = tmpbuf->size;
    if (time)
      *time = tmpbuf->time;
    pin->BufferCount--;
    pin->DataSize-=tmpbuf->size;
    ScFree(tmpbuf);
  }
  else
  {
    _SlibDebug(_WARN_ && pin->DataSize,
     printf("slibGetBufferFromPin() No more buffers on pin, yet DataSize=%d\n",
                     pin->DataSize) );
    if (size)
      *size = 0;
    address=NULL;
  }
  return(address);
}

/*
** Name:    slibGetBufferFromPin
** Purpose: Get a pointer to the next buffer on a pin, but don't
**          remove it.
*/
unsigned char *slibPeekBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword *psize, SlibTime_t *ptime)
{
  _SlibDebug(_DEBUG_, printf("slibPeekBufferOnPin(%s)\n",pin->name) );
  if (slibLoadPin(Info, pin->ID) != NULL)
  {
    if (psize)
      *psize = pin->Buffers->size;
    if (ptime)
      *ptime = pin->Buffers->time;
    return(pin->Buffers->address);
  }
  else
    return(NULL);
}

/*
** Name:    slibGetNextTimeOnPin
** Purpose: Get the next time on a pin.
*/
SlibTime_t slibGetNextTimeOnPin(SlibInfo_t *Info, SlibPin_t *pin,
                                   unsigned dword maxbytes)
{
  unsigned dword bytesread=0, size;
  unsigned char *buf;
  SlibTime_t timefound=SLIB_TIME_NONE;
  _SlibDebug(_DEBUG_,
       printf("slibGetNextTimeOnPin(%s)\n",pin?"NULL":pin->name) );
  if (!pin)
    return(SLIB_TIME_NONE);
  buf=slibPeekBufferOnPin(Info, pin, &size, &timefound);
  bytesread+=size;
  while (buf && timefound==SLIB_TIME_NONE && bytesread<maxbytes)
  {
    buf=slibPeekNextBufferOnPin(Info, pin, buf, &size, &timefound);
    bytesread+=size;
  }
  return(timefound);
}

/*
** Name:    slibPeekNextBufferOnPin
** Purpose: Get a pointer to the next buffer on a pin after the buffer
**          specified by "lastbuffer"; don't remove it.
*/
unsigned char *slibPeekNextBufferOnPin(SlibInfo_t *Info, SlibPin_t *pin, 
                                       unsigned char *lastbuffer,
                                       unsigned dword *size, SlibTime_t *time)
{
  unsigned char *address=NULL;
  SlibBuffer_t *tmpbuf;
  _SlibDebug(_DEBUG_, printf("slibPeekNextBufferOnPin(lastbuffer=%p,pin=%s)\n",
                   lastbuffer, pin->name) );
  /* check the last loaded buffer first */
  tmpbuf=pin->BuffersTail;
  if (tmpbuf &&
      lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size)
  {
    /* load a new buffer onto the pin */
    slibPreLoadPin(Info, pin);
    if (tmpbuf != pin->BuffersTail)
    {
      address=pin->BuffersTail->address;
      if (size)
        *size=pin->BuffersTail->size;
      if (time)
        *time=pin->BuffersTail->time;
      return(address);
    }
    _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() End of data\n") );
    return(NULL);
  }
  /* search through all the buffers on the pin */
  if (pin->Buffers==NULL)
    slibPreLoadPin(Info, pin);
  tmpbuf = pin->Buffers;
  while (tmpbuf)
  {
    if (lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size)
    {
      tmpbuf=tmpbuf->next;
      if (tmpbuf)
      {
        _SlibDebug(_WARN_ && 
         lastbuffer>=tmpbuf->address && lastbuffer<tmpbuf->address+tmpbuf->size,
                 printf("slibPeekNextBufferOnPin() same addresses\n") );
        if (size)
          *size=tmpbuf->size;
        if (time)
          *time=tmpbuf->time;
        return(tmpbuf->address);
      }
      else
      {
        _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() End of bufs\n") );
        return(NULL);
      }
    }
    tmpbuf=tmpbuf->next;
  }
  _SlibDebug(_WARN_, printf("slibPeekNextBufferOnPin() address no found\n") );
  return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\yuv2rgb.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_yuv_to_rgb.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/**********************************************************************/
/**********************************************************************/
/*                                                                    */
/*  Function: YUV_To_RGB_422_Init                                     */
/*  Author:   Bill Hallahan                                           */
/*  Date:     July 29, 1994                                           */
/*                                                                    */
/*  Abstract:                                                         */
/*                                                                    */
/*         This function produces a table that is used by the         */
/*    yuv_to_rgb_422 conversion routines. This table is required      */
/*    by the following routines.                                      */
/*                                                                    */
/*        YUV_To_RGB_422_24_Bit                                       */
/*        YUV_To_RGB_422_555                                          */
/*                                                                    */
/*                                                                    */
/*         YUV to RGB conversion can be described by a 3x3 matrix     */
/*    multiplication:                                                 */
/*                                                                    */
/*         R     | 1   0  VR |  Y                                     */
/*         G  =  | 1  UG  VG |  U                                     */
/*         B     | 1  UB   0 |  V                                     */
/*                                                                    */
/*         where:                                                     */
/*                                                                    */
/*            0 <= Y <= 255                                           */
/*         -128 <= U <= 127    UG = -0.3455    UB =  1.7790           */
/*         -128 <= V <= 127    VR =  1.4075    VG = -0.7169           */
/*                                                                    */
/*         The Red, Green, and Blue output values are obtained in     */
/*    parallel by summing three 64 bit words as shown. Each of the    */
/*    quadwords is obtained from either the Y_Table, the U_Table,     */
/*    or the V_table using the corresponding 8 bit Y, U, or V value   */
/*    as an index. Thus all multiplications are performed by table    */
/*    lookup. Note that the matrix output is ordered as B, R, G	      */
/*    and then B again (starting at the LSB).			      */
/*    This is to allow an efficient conversion to the output format.  */
/*								      */
/*    For 32-bit RGB, the Red and Blue bits are already in the	      */
/*    correct position, the conversion routine only has to shift      */
/*    the Green bits. For General BI-BITFIELDS however, the Red,      */
/*    Green and Blue bits could be anywhere in a 16-bit or 32-bit     */
/*    word (we only support 16-bit for now). To avoid a costly	      */
/*    decicion in the inner loop whether to shift the Blue bits left  */
/*    or right, we maintain a copy of the Blue bits in position 48    */
/*    so a right shift will always work. Each conversion routine can  */
/*    choose whichever set of Blue bits that are fastest to use,      */
/*    they are identical.					      */
/*								      */
/*                                                                    */
/*           MSW                                         LSW          */
/*                                                                    */
/*           63       48 47       32 31       16 15        0    Index */
/*           -----------------------------------------------          */
/*          |          Y|          Y|          Y|          Y|     Y   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*          |         ub|         ug|          0|         ub|     U   */
/*           -----------------------------------------------          */
/*                                                                    */
/*           -----------------------------------------------          */
/*       +  |          0|         vg|         vr|          0|     V   */
/*           -----------------------------------------------          */
/*    __________________________________________________________      */
/*                                                                    */
/*           -----------------------------------------------          */
/*    Total |    0|    0|    x|    G|    x|    R|    x|    B|         */
/*           -----------------------------------------------          */
/*                                                                    */
/*                                                                    */
/*      where:                                                        */
/*                                                                    */
/*          ub = UB * U                                               */
/*          ug = UG * U                                               */
/*          vg = VG * V                                               */
/*          vr = VR * V                                               */
/*                                                                    */
/*                                                                    */
/*         The maximum absolute value for Y is 255 and the maximum    */
/*    for U or V is 128, so 9 bits is the minimum size to represent   */
/*    them together as two's complement values. The maximum           */
/*    chrominance (U or V) magnitude is 128. This is 0.5 as a Q9      */
/*    two's complement fraction. 255 is 1 - 2^-8 in Q9 fraction form. */
/*                                                                    */
/*    The maximum possible bit growth is determined as follows.       */
/*                                                                    */
/*      R_Max = 1 - 2^-8 +                  0.5 * fabs(VR) = 1.6998   */
/*      G_Max = 1 - 2^-8 + 0.5 * fabs(UG) + 0.5 * fabs(VG) = 1.5273   */
/*      B_Max = 1 - 2^-8 + 0.5 * fabs(UB)                  = 1.8856   */
/*                                                                    */
/*                                                                    */
/*         Since B_Max = 1.8856 then the next highest integer         */
/*    greater than or equal to log base 2 of 1.8856 is 1. So 1 bit    */
/*    is required for bit growth. The minimum accumulator size        */
/*    required is 9 + 1 = 10 bits. This code uses 12 bit accumulators */
/*    since there are bits to spare.                                  */
/*                                                                    */
/*         The 11'th bit (starting at bit 0) of each accumulator      */
/*    is the sign bit. This may be tested to determine if there is    */
/*    a negative result. Accumulator overflows are discarded as is    */
/*    normal for two's complement arithmetic. Each R, G, or B result  */
/*    that is over 255 is set to 255. Each R, G, or B result that is  */
/*    less than zero is set to zero.                                  */
/*                                                                    */
/*                                                                    */
/*  Input:                                                            */
/*                                                                    */
/*                                                                    */
/*    bSign     Contains a 32 bit boolean that if non-zero, changes   */
/*              the interpretation of the chrominance (U and V) data  */
/*              from an offset binary format, where the values range  */
/*              from 0 to 255 with 128 representing 0 chrominance,    */
/*              to a signed two's complement format, where the values */
/*              range from -128 to 127.                               */
/*                                                                    */
/*                                                                    */
/*    bBGR      Contains a 32 bit boolean that if non-zero, changes   */
/*              the order of the conversion from RGB to BGR.          */
/*                                                                    */
/*                                                                    */
/*    pTable    The address of the RGB (or BGR) conversion table      */
/*              that is filled in by this function. The table         */
/*              address must be quadword aligned. The table size      */
/*              is 6244 bytes 3 * 256 quadwords.                      */
/*                                                                    */
/*                                                                    */
/*  Output:                                                           */
/*                                                                    */
/*    This function has no return value.                              */
/*                                                                    */
/*                                                                    */
/**********************************************************************/
/**********************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

/*
 * Define NEW_YCBCR to use new YCbCr conversion values.
 */
#define NEW_YCBCR

#define GetRGB555(in16, r, g, b) b = (in16>>7)&0xF8; \
                                 g = (in16>>2)&0xF8; \
                                 r = (in16<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (in16>>7)&0xF8; \
                                 g += (in16>>2)&0xF8; \
                                 r += (in16<<3)&0xF8

#define PutRGB565(r, g, b, out16) out16 = ((r&0xf8)<<8)|((g&0xfC)<<3)|((b&0xf8)>>3)

#define PutRGB555(r, g, b, out16) out16 = ((r&0xf8)<<7)|((g&0xf8)<<2)|((b&0xf8)>>3)

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/********************************** YUV to RGB ***********************************/
/*
 * The YUV to RGB conversion routines
 * generates RGB values in a 64-bit
 * word thus:
 *
 *	63   56	55   48	47   40 39   32	31   24	23   16	15    8	7     0
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 * |     0 |  Blue |     0 | Green |     0 |   Red |     0 |  Blue |
 * +-------+-------+-------+-------+-------+-------+-------+-------+
 *
 * Figure out how many steps to the right are needed to
 * shift the red, green and blue into the correct position.
 */
#define ArrangRGB565(inrgb, outrgb) \
	  outrgb=((inrgb>>8)&0xf800)|((inrgb>>29)&0x07e0)|((inrgb>>51)&0x001f)
#define ArrangRGB888(inrgb, outrgb) \
	  outrgb=(inrgb&0xFF0000)|((inrgb>>24)&0x00FF00)|(inrgb&0x0000FF)


SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info)
{
  qword i, qY, qUV, qSigned;
  SconBoolean_t bBGR=Info->Output.vinfo.Rmask&1; /* BGR vs RGB ordering */
  SconBoolean_t bSign=FALSE; /* U and V are signed values */
  unsigned qword qRed;
  unsigned qword qGreen;
  unsigned qword qBlue;
  unsigned qword qTemp;
  unsigned qword qAccMask = 0xFFF;
  unsigned qword *pTable, *pU_Table, *pV_Table;
  double Chrominance;
#ifdef NEW_YCBCR
  double CF_UB = 2.018;
  double CF_UG = -0.391;
  double CF_VG = -0.813;
  double CF_VR = 1.596;
#else /* !NEW_YCBCR */
  double CF_UB = 1.7790;
  double CF_UG = -0.3455;
  double CF_VG = -0.7169;
  double CF_VR = 1.4075;
#endif /* !NEW_YCBCR */

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  /*
   *  Set constant that determines if the U and V chrominance values
   *  are interpreted as signed or unsigned values.
   */
  if ( !bSign )
    qSigned = 0;
  else
    qSigned = 0xFFFFFFFFFFFFFF80;

  /* Get the U, and V table pointers. */
  pTable = (unsigned qword *)Info->Table;
  pU_Table = pTable + 256;
  pV_Table = pU_Table + 256;

  /* Initialize the Y_Table, the U_Table, and the V_Table. */
  for ( i = 0; i < 256; i++ )
  {
    /******************************************************************/
    /*  Construct the Y array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          Y|          Y|          Y|          Y|     Y = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qY = (qword) ((i-16)*1.164) ;
    qY = (qY < 0) ? 0 : (qY > 255) ? 255 : qY ;
#else /* !NEW_YCBCR */
    qY = i ;
#endif /* !NEW_YCBCR */
    qY |= qY << 16 ;
    *pTable++ = qY | ( qY << 32 ) ;
    /******************************************************************/
    /*  Construct the U array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |         ub|         ug|          0|         ub|     U = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/

#ifdef NEW_YCBCR
    qUV = (i< 16) ? 16
        : (i<240) ?  i
        : 240 ;
#else /* !NEW_YCBCR */
    qUV = i ;
#endif /* !NEW_YCBCR */
         
    Chrominance = (double) (( qUV - 128 ) ^ qSigned );

    qBlue = ((qword)( CF_UB * Chrominance )) & qAccMask;
    qGreen = ((qword)( CF_UG * Chrominance )) & qAccMask;
    qRed = 0;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pU_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 ) | ( qBlue << 48 );
    /******************************************************************/
    /*  Construct the V array value for the current index value.      */
    /*                                                                */
    /*   63       48 47       32 31       16 15        0    Index     */
    /*   -----------------------------------------------              */
    /*  |          0|         vg|         vr|          0|     V = i   */
    /*   -----------------------------------------------              */
    /*                                                                */
    /******************************************************************/
    qBlue = 0;
    qGreen = ((qword)( CF_VG * Chrominance )) & qAccMask;
    qRed = ((qword)( CF_VR * Chrominance )) & qAccMask;
    if ( bBGR )
    {
      qTemp = qBlue;
      qBlue = qRed;
      qRed = qTemp;
    }
    *pV_Table++ = qBlue | ( qRed << 16 ) | ( qGreen << 32 );
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*3)/2);
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23 ;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*3)/2);
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  for (line=height; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *uData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *vData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 & 0xFFFF) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 & 0xFF) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword y4, y5, y6, y7 ;
  unsigned qword u01, v01, u23, v23;
  unsigned qword  *yData=(unsigned qword *)inimage;
  unsigned int *uData=(unsigned int *)(inimage+width*height);
  unsigned int *vData=(unsigned int *)(inimage+(width*height*5)/4);
  unsigned int *puData, *pvData;
  unsigned qword *rgbData=(unsigned qword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned qword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>3; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;	y >>= 8 ;
      y4  = y & 255 ;	y >>= 8 ;
      y5  = y & 255 ;	y >>= 8 ;
      y6  = y & 255 ;	y >>= 8 ;
      y7  = y & 255 ;	y >>= 8 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ; u >>= 8 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ; v >>= 8 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;
      y4  = pTable[y4] ;
      y5  = pTable[y5] ;
      y6  = pTable[y6] ;
      y7  = pTable[y7] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /*
       * Same thing for more pixels.
       * Use u01 for u45 and u23 for u67
       */
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;
      /* Convert to RGB. */
      y4 += u01 + v01 ;
      y5 += u01 + v01 ;
      y6 += u23 + v23 ;
      y7 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3 | y4 | y5 | y6 | y7) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        y = y4 & mask ; y4 &= ~(y - (y>>11)) ;
        y = y5 & mask ; y5 &= ~(y - (y>>11)) ;
        y = y6 & mask ; y6 &= ~(y - (y>>11)) ;
        y = y7 & mask ; y7 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        y = y4 & mask ; y4 |= (y - (y >> 8)) ;
        y = y5 & mask ; y5 |= (y - (y >> 8)) ;
        y = y6 & mask ; y6 |= (y - (y >> 8)) ;
        y = y7 & mask ; y7 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB565(y0, y0);
      ArrangRGB565(y1, y1);
      ArrangRGB565(y2, y2);
      ArrangRGB565(y3, y3);
      ArrangRGB565(y4, y4);
      ArrangRGB565(y5, y5);
      ArrangRGB565(y6, y6);
      ArrangRGB565(y7, y7);
      *rgbData++ = y0 | (y1 << 16) | (y2 << 32) | (y3 << 48) ;
      *rgbData++ = y4 | (y5 << 16) | (y6 << 32) | (y7 << 48) ;
    }
  }
  return(SconErrorNone);
}

SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned qword y, u, v, mask ;
  unsigned qword y0, y1, y2, y3 ;
  unsigned qword u01, v01, u23, v23;
  unsigned dword *yData=(unsigned dword *)inimage;
  unsigned word *uData=(unsigned word *)(inimage+width*height);
  unsigned word *vData=(unsigned word *)(inimage+(width*height*5)/4);
  unsigned word *puData, *pvData;
  unsigned dword *rgbData=(unsigned dword *)outimage;
  unsigned dword x, line;
  if (stride<0) /* flip */
    outimage=outimage+((height-1)*(-stride));
  puData=uData;
  pvData=vData;
  for (line=(height>>1)<<1; line>0; line--, outimage+=stride)
  {
    rgbData=(unsigned dword *)outimage;
    if (line&1) /* odd line, reuse U and V */
    {
      puData=uData;
      pvData=vData;
    }
    else
    {
      uData=puData;
      vData=pvData;
    }
    for (x=width>>2; x>0; x--)
    {
      y   = *yData++ ;
      y0  = y & 255 ; y >>= 8 ;
      y1  = y & 255 ; y >>= 8 ;
      y2  = y & 255 ; y >>= 8 ;
      y3  = y & 255 ;

      u   = *puData++ ;
      u01 = u & 255 ; u >>= 8 ;
      u23 = u & 255 ;

      v   = *pvData++ ;
      v01 = v & 255 ; v >>= 8 ;
      v23 = v & 255 ;

      y0  = pTable[y0] ;
      y1  = pTable[y1] ;
      y2  = pTable[y2] ;
      y3  = pTable[y3] ;

      u01 = pTable[u01+256] ;
      u23 = pTable[u23+256] ;

      v01 = pTable[v01+512] ;
      v23 = pTable[v23+512] ;

      /* Now, convert to RGB */
      y0 += u01 + v01 ;
      y1 += u01 + v01 ;
      y2 += u23 + v23 ;
      y3 += u23 + v23 ;
      /* See if any value is out of range. */
      mask = (unsigned qword)0x0F000F000F000F00L;
      if( (y0 | y1 | y2 | y3) & mask )
      {
	      /* Zero values that are negative */
        mask = (unsigned qword)0x0800080008000800L ;
        y = y0 & mask ; y0 &= ~(y - (y>>11)) ;
        y = y1 & mask ; y1 &= ~(y - (y>>11)) ;
        y = y2 & mask ; y2 &= ~(y - (y>>11)) ;
        y = y3 & mask ; y3 &= ~(y - (y>>11)) ;
        /* Clamp values that are > 255 to 255. */
        mask = (unsigned qword)0x0100010001000100L ;
        y = y0 & mask ; y0 |= (y - (y >> 8)) ;
        y = y1 & mask ; y1 |= (y - (y >> 8)) ;
        y = y2 & mask ; y2 |= (y - (y >> 8)) ;
        y = y3 & mask ; y3 |= (y - (y >> 8)) ;
        /* Stray bits left over will be masked below */
      }
      ArrangRGB888(y0, y0);
      ArrangRGB888(y1, y1);
      ArrangRGB888(y2, y2);
      ArrangRGB888(y3, y3);
      *rgbData++ = (unsigned dword)(y0 | (y1 << 24));
      *rgbData++ = (unsigned dword)((y1 >> 8) | (y2 << 16));
      *rgbData++ = (unsigned dword)((y2 >> 16) | (y3 << 8));
    }
  }
  return(SconErrorNone);
}

/********************************** YUV to RGB ***********************************/
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info)
{
  unsigned dword i, y, u, v ;
  qword *RedToYuyv, *GreenToYuyv, *BlueToYuyv;

  /* allocate memory to hold the lookup table */
  if (Info->Table && Info->TableSize<256*3*8)
  {
    ScPaFree(Info->Table);
    Info->Table=NULL;
  }
  if (Info->Table==NULL)
  {
    if ((Info->Table = ScPaMalloc(256*3*8)) == NULL)
      return(SconErrorMemory);
    Info->TableSize=256*3*8;
  }
  RedToYuyv=(unsigned qword *)Info->Table;
  GreenToYuyv=RedToYuyv+256;
  BlueToYuyv=RedToYuyv+512;

  for( i=0 ; i<256 ; i++ )
  {
    /*
     * Calculate contribution from red.
     * We will also add in the constant here.
     * Pack it into the tables thus: lsb->YUYV<-msb
     */
    y = (unsigned dword) ((float)YC + (float)YR * (float)i) ;
    u = (unsigned dword) ((float)UC + (float)UR * (float)(255-i)) ;
    v = (unsigned dword) ((float)VC + (float)VR * (float)i) ;
    RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from green.
     */
    y = (unsigned dword) ((float)YG * (float)i) ;
    u = (unsigned dword) ((float)UG * (float)(255-i)) ;
    v = (unsigned dword) ((float)VG * (float)(255-i)) ;
    GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
    /*
     * Calculate contribution from blue.
     */
    y = (unsigned dword) ((float)YB * (float)i) ;
    u = (unsigned dword) ((float)UB * (float)i) ;
    v = (unsigned dword) ((float)VB * (float)(255-i)) ;
    BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;
  }
  return(SconErrorNone);
}

/*
** Name:    sconRGB888To420
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable)
{
  unsigned char *yData=(unsigned char *)outimage;
  unsigned char *uData=(unsigned char *)(outimage+width*height);
  unsigned char *vData=(unsigned char *)(outimage+(width*height*5)/4);
  register unsigned dword row, col;
  unsigned dword yuyv, r, g, b;
  unsigned char *tmp, *evl, *odl;
  if (stride<0)
    inimage=inimage+(-stride*(height-1));
  for (row=height; row>0; row--)
  {
    if (row&1)
    {
      tmp=inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
      }
      inimage+=stride;
    }
    else
    {
      tmp = evl = inimage;
      inimage+=stride;
      odl = inimage;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
        *yData++ = (yuyv&0xff);
        /* We only store every fourth value of u and v components */
        if (col & 1)
        {
          /* Compute average r, g and b values */
          r = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b = (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          g += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          b += (unsigned dword)*evl++ + (unsigned dword)*odl++;
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;
          yuyv = (unsigned dword)(pTable[r] + pTable[g+256] + pTable[b+512]);
          *uData++ = (yuyv>>24)& 0xff;       // V
          *vData++ = (yuyv>>8) & 0xff;       // U
        }
      }
    }
  }
  return(SconErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\common.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sv_h263_common.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "SC_err.h"
#include "sv_h263.h"
#include "sv_intrn.h"
#include "sv_proto.h"
#include "proto.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#define _DEBUG_    0  /* detailed debuging statements */
#define _VERBOSE_  0  /* show progress */
#define _VERIFY_   1  /* verify correct operation */
#define _WARN_     1  /* warnings about strange behavior */
#endif

SvStatus_t svH263SetParamInt(SvHandle_t Svh, SvParameter_t param, 
                                qword value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Svh)
    return(SvErrorCodecHandle);
  if (Info->mode == SV_H263_DECODE)
    switch (param)
    {
      case SV_PARAM_QUALITY:
             if (value>99)
               Info->h263dcmp->quality=99;
             else if (value<0)
               Info->h263dcmp->quality=0;
             else
               Info->h263dcmp->quality=(int)value;
             break;
      case SV_PARAM_DEBUG:
             Info->h263dcmp->dbg=(void *)value;
             break;
    }
  else if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_MOTIONALG:
             Info->h263comp->ME_method=(int)value;
             return(SvErrorNone);
      case SV_PARAM_BITRATE:
             if (value>=0)
               Info->h263comp->bit_rate = (int)value;
             sv_H263UpdateQuality(Info);
             break;
      case SV_PARAM_QUALITY:
             if (value>99)
               Info->h263comp->quality=99;
             else if (value<0)
               Info->h263comp->quality=0;
             else
               Info->h263comp->quality=(int)value;
             sv_H263UpdateQuality(Info);
             break;
      case SV_PARAM_DEBUG:
             Info->h263comp->dbg=(void *)value;
             break;
      case SV_PARAM_ALGFLAGS:
             Info->h263comp->pb_frames = (value&PARAM_ALGFLAG_PB) ? TRUE : FALSE;
             Info->h263comp->syntax_arith_coding = (value&PARAM_ALGFLAG_SAC) ? TRUE : FALSE;
             Info->h263comp->unrestricted = (value&PARAM_ALGFLAG_UMV) ? TRUE : FALSE;
             Info->h263comp->advanced = (value&PARAM_ALGFLAG_ADVANCED) ? TRUE : FALSE;
             return(SvErrorNone);
      case SV_PARAM_FORMATEXT:
             Info->h263comp->extbitstream = (int)value;
             return(SvErrorNone);
      case SV_PARAM_QUANTI:
             if (value>0)
               Info->h263comp->QPI=(int)value;
             break;
      case SV_PARAM_QUANTP:
             if (value>0)
             {
               if (value>31) value=31;
               Info->h263comp->QP=Info->h263comp->QP_init=(int)value;
               if (Info->h263comp->bit_rate==0 && Info->h263comp->pic)
                 Info->h263comp->pic->QUANT=(int)value;
             }
             break;
      case SV_PARAM_KEYSPACING:
             Info->h263comp->end = (int)value;
             break;
      case SV_PARAM_FRAMETYPE:
             if (value==FRAME_TYPE_I) /* next key should be key */
               sv_H263RefreshCompressor(Info);
             return(SvErrorNone);
      case SV_PARAM_PACKETSIZE:
             Info->h263comp->packetsize = (int)value*8;
             break;
    }
  return(SvErrorNone);
}

SvStatus_t svH263SetParamFloat(SvHandle_t Svh, SvParameter_t param, 
                                float value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;
  if (!Svh)
    return(SvErrorCodecHandle);
  if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_FPS:
             if (value<1.0)
               Info->h263comp->frame_rate = 1.0F;
             else if (value>30.0)
               Info->h263comp->frame_rate = 30.0F;
             else
               Info->h263comp->frame_rate = value;
             _SlibDebug(_DEBUG_,
                  printf("frame_rate = %f\n", Info->h263comp->frame_rate) );
             sv_H263UpdateQuality(Info);
             return(SvErrorNone);
    }
  return(svH263SetParamInt(Svh, param, (long)value));
}

qword svH263GetParamInt(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return((qword)0);
  if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_BITRATE:
            return((qword)Info->h263comp->bit_rate);
      case SV_PARAM_FPS:
            return((qword)svH263GetParamFloat(Svh, param));
      case SV_PARAM_QUALITY:
            return((qword)Info->h263comp->quality);
      case SV_PARAM_NATIVEFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_FINALFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_ALGFLAGS:
             {
               qword flags=0;
               flags|=Info->h263comp->pb_frames ? PARAM_ALGFLAG_PB : 0;
               flags|=Info->h263comp->syntax_arith_coding ? PARAM_ALGFLAG_SAC : 0;
               flags|=Info->h263comp->unrestricted ? PARAM_ALGFLAG_UMV : 0;
               flags|=Info->h263comp->advanced ? PARAM_ALGFLAG_ADVANCED : 0;
               return(flags);
             }
             break;
      case SV_PARAM_QUANTI:
            return((qword)Info->h263comp->QPI);
      case SV_PARAM_QUANTP:
            return((qword)Info->h263comp->QP);
      case SV_PARAM_KEYSPACING:
            return((qword)Info->h263comp->end);
      case SV_PARAM_PACKETSIZE:
            return((qword)Info->h263comp->packetsize/8);
    }
  else if (Info->mode == SV_H263_DECODE)
    switch (param)
    {
      case SV_PARAM_MOTIONALG:
            return((qword)Info->h263comp->ME_method);
      case SV_PARAM_BITRATE:
            return((qword)Info->h263dcmp->bit_rate);
      case SV_PARAM_FPS:
            return((qword)svH263GetParamFloat(Svh, param));
      case SV_PARAM_WIDTH:
            return((qword)Info->h263dcmp->horizontal_size);
      case SV_PARAM_HEIGHT:
            return((qword)Info->h263dcmp->vertical_size);
      case SV_PARAM_FRAME:
            return((qword)Info->h263dcmp->framenum);
      case SV_PARAM_NATIVEFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_FINALFORMAT:
            return((qword)BI_YU12SEP);
      case SV_PARAM_QUALITY:
            return((qword)Info->h263dcmp->quality);
    }
  return((qword)0);
}

float svH263GetParamFloat(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return((float)0.0);
  if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_FPS:
            return((float)Info->h263comp->frame_rate);
    }
  else if (Info->mode == SV_H263_DECODE)
    switch (param)
    {
      case SV_PARAM_FPS:
            return((float)Info->h263dcmp->frame_rate);
    }
  return((float)svH263GetParamInt(Svh, param));
}

SvStatus_t svH263SetParamBoolean(SvHandle_t Svh, SvParameter_t param,
                                                  ScBoolean_t value)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return(0);
  if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_FASTENCODE:
             return(SvErrorNone);
      case SV_PARAM_FASTDECODE:
             return(SvErrorNone);
  }
  else if (Info->mode == SV_H263_DECODE)
    switch (param)
    {
      case SV_PARAM_FASTDECODE:
             return(SvErrorNone);
    }
  return(SvErrorNone);
}

ScBoolean_t svH263GetParamBoolean(SvHandle_t Svh, SvParameter_t param)
{
  SvCodecInfo_t *Info = (SvCodecInfo_t *)Svh;

  if (!Svh)
    return(0);
#if 0
  if (Info->mode == SV_H263_ENCODE)
    switch (param)
    {
      case SV_PARAM_FASTENCODE:
            return((ScBoolean_t)Info->h263comp->fastencode);
      case SV_PARAM_FASTDECODE:
            return((ScBoolean_t)Info->h263comp->fastdecode);
      case SV_PARAM_MOTIONALG:
            return((ScBoolean_t)Info->h263comp->motionalg);
      case SV_PARAM_HALFPEL:
            return((ScBoolean_t)Info->h263comp->halfpel);
      case SV_PARAM_SKIPPEL:
            return((ScBoolean_t)Info->h263comp->skippel);
    }
  else if (Info->mode == SV_H263_DECODE)
    switch (param)
    {
      case SV_PARAM_FASTDECODE:
            return((ScBoolean_t)Info->h263dcmp->fastdecode);
    }
#endif
  return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\dct.c ===
/* File: sv_h263_dct.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include <math.h>
#include "sv_h263.h"
#include "proto.h"

#define F (float)
#define S (short)

static const unsigned int tdzz[64] = {
     0,  1,  5,  6, 14, 15, 27, 28,
     2,  4,  7, 13, 16, 26, 29, 42,
     3,  8, 12, 17, 25, 30, 41, 43,
     9, 11, 18, 24, 31, 40, 44, 53,
    10, 19, 23, 32, 39, 45, 52, 54,
    20, 22, 33, 38, 46, 51, 55, 60,
    21, 34, 37, 47, 50, 56, 59, 61,
    35, 36, 48, 49, 57, 58, 62, 63};

static const unsigned int ttdzz[64] = {
     0,  2,  3,  9, 10, 20, 21, 35,
     1,  4,  8, 11, 19, 22, 34, 36,
     5,  7, 12, 18, 23, 33, 37, 48,
     6, 13, 17, 24, 32, 38, 47, 49,
    14, 16, 25, 31, 39, 46, 50, 57,
    15, 26, 30, 40, 45, 51, 56, 58,
    27, 29, 41, 44, 52, 55, 59, 62,
    28, 42, 43, 53, 54, 60, 61, 63};

/**********************************************************************
 *
 *	Name:		Dct
 *	Description:	Does dct on an 8x8 block, does zigzag-scanning of
 *			coefficients
 *
 *	Input:		64 pixels in a 1D array
 *	Returns:	64 coefficients in a 1D array
 *	Side effects:	
 *
 **********************************************************************/

/*
** Name:      ScFDCT8x8s_C
** Purpose:   2-d Forward DCT (C version) for (8x8) blocks
**
** update:    Wei-Lien Hsu, store in ZZ order.
*/

static const float W0=(float).7071068, W1=(float).4903926, W2=(float).4619398,
                   W3=(float).4157348, W4=(float).3535534, W5=(float).2777851,
                   W6=(float).1913417, W7=(float).0975452;

int sv_H263DCT( short *block, short *coeff, int QP, int Mode)
{
  int    i;
  register float b0, b1, b2, b3, b4, b5, b6, b7, tmp, t0, t1, t2;
  float tmpbuf[64];
  const unsigned int *ptdzz=ttdzz;

  register short *blockptr, *coeffptr ;
  register float *dptr;

#if 1
  short val, halfQ;

  /* check significant signals in Inter-frame */
  if(!(Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)) {
    halfQ = QP >> 1;
    blockptr = block;
    for (i=0; i < 64; i++) {
	  val = *blockptr++;
	  if((val > halfQ) | (val < -halfQ)) break;
	}
	if(i==64){ memset(coeff,0,128) ; return 0; }
  }
#endif

  /* Horizontal transform */
  dptr = tmpbuf;
  blockptr = block;
  for (i = 0; i < 8; i++)
  {
    t0 =  *blockptr++;
    t1 =  *blockptr++;
    t2 =  *blockptr++;
    tmp=  *blockptr++;
    b4 =  *blockptr++;
    b5 =  *blockptr++;
    b6 =  *blockptr++;
    b7 =  *blockptr++;

    b0  = t0 + b7;
    b7  = t0 - b7;

    b1  = t1 + b6;
    b6  = t1 - b6;

    b2  = t2 + b5;
    b5  = t2 - b5;

    b3  = tmp + b4;
    b4  = tmp - b4;

    t0  = b0 + b3;
    b3  = b0 - b3;

    t1  = b1 + b2;
    b2  = b1 - b2;

	tmp = b5;
    b5 = (b6 - b5) * W0;
    b6 = (b6 + tmp) * W0;

    t2  = b4 + b5;
    b5  = b4 - b5;

    tmp = b7 + b6;
    b6  = b7 - b6;

    *dptr++ = (t0 + t1) * W4;
    *dptr++ = t2 * W7 + tmp * W1;
    *dptr++ = b2 * W6 + b3 * W2;
    *dptr++ = b6 * W3 - b5 * W5;
    *dptr++ = (t0 - t1) * W4;
    *dptr++ = b5 * W3 + b6 * W5;
    *dptr++ = b3 * W6 - b2 * W2;
    *dptr++ = tmp * W7 - t2 * W1;
  }

  /* Vertical transform */
  dptr = tmpbuf;
  coeffptr = coeff;
  for (i = 0; i < 8; i++, dptr++)
  {
    b0  = *dptr;
	tmp = *(dptr + 56) ;
    b7  = b0 - tmp ;
    b0 += tmp;

    b1  = *(dptr + 8);
	tmp = *(dptr + 48) ;
    b6  = b1 - tmp;
	b1 += tmp;

    b2  = *(dptr + 16);
	tmp = *(dptr + 40) ;
    b5  = b2 - tmp;
	b2 += tmp;

    b3  = *(dptr + 24);
	tmp = *(dptr + 32) ;
    b4  = b3 - tmp;
    b3 += tmp;

    t0  = b0 + b3;
    b3  = b0 - b3;

    t1  = b1 + b2;
    b2  = b1 - b2;

	tmp = b5;
    b5  = (b6 - b5)  * W0;
    b6  = (b6 + tmp) * W0;

    t2  = b4 + b5;
    b5  = b4 - b5;

    tmp = b7 + b6;
    b6  = b7 - b6;

    *(coeffptr + *ptdzz++) = S ((t0 + t1) * W4);
    *(coeffptr + *ptdzz++) = S (t2 * W7 + tmp * W1);
    *(coeffptr + *ptdzz++) = S (b2 * W6 + b3 * W2);
    *(coeffptr + *ptdzz++) = S (b6 * W3 - b5 * W5);
    *(coeffptr + *ptdzz++) = S ((t0 - t1) * W4);
    *(coeffptr + *ptdzz++) = S (b5 * W3 + b6 * W5);
    *(coeffptr + *ptdzz++) = S (b3 * W6 - b2 * W2);
    *(coeffptr + *ptdzz++) = S (tmp * W7 - t2 * W1);
  }

  return 1;
}


/**********************************************************************
 *
 *	Description:	Does zone-filter on an 8x8 block-dct,
 *                  does zigzag-scanning of	coefficients
 *
 *	Input:		64 pixels in a 1D array
 *	Returns:	64 coefficients in a 1D array
 *	Side effects:	
 *
 **********************************************************************/

int sv_H263ZoneDCT( short *block, short *coeff, int QP, int Mode)
{
  int    i;
  register float b0, b1, b2, b3, b4, b5, b6, b7, tmp, t0, t1, t2;
  float tmpbuf[64];
  const unsigned int *ptdzz=ttdzz;

  register short *blockptr, *coeffptr ;
  register float *dptr;

#if 1
  short val, halfQ;

  /* check significant signals in Inter-frame */
  if(!(Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)) {
    halfQ = QP >> 1;
    blockptr = block;
    for (i=0; i < 64; i++) {
	  val = *blockptr++;
	  if((val > halfQ) | (val < -halfQ)) break;
	}
	if(i==64){ memset(coeff,0,128) ; return 0; }
  }
#endif

  /* Horizontal transform */
  dptr = tmpbuf;
  blockptr = block;
  for (i = 0; i < 8; i++)
  {
    t0 =  *blockptr++;
    t1 =  *blockptr++;
    t2 =  *blockptr++;
    tmp=  *blockptr++;
    b4 =  *blockptr++;
    b5 =  *blockptr++;
    b6 =  *blockptr++;
    b7 =  *blockptr++;

    b0  = t0 + b7;
    b7  = t0 - b7;

    b1  = t1 + b6;
    b6  = t1 - b6;

    b2  = t2 + b5;
    b5  = t2 - b5;

    b3  = tmp + b4;
    b4  = tmp - b4;

    t0  = b0 + b3;
    b3  = b0 - b3;

    t1  = b1 + b2;
    b2  = b1 - b2;

	tmp = b5;
    b5 = (b6 - b5) * W0;
    b6 = (b6 + tmp) * W0;

    t2  = b4 + b5;
    b5  = b4 - b5;

    tmp = b7 + b6;
    b6  = b7 - b6;

    *dptr++ = (t0 + t1) * W4;
    *dptr++ = t2 * W7 + tmp * W1;
    *dptr++ = b2 * W6 + b3 * W2;
    *dptr++ = b6 * W3 - b5 * W5;
    dptr+= 4;
  }

  /* Vertical transform */
  dptr = tmpbuf;
  coeffptr = coeff;

  memset(coeff,0,128) ;

  for (i = 0; i < 4; i++, dptr++)
  {
    b0  = *dptr;
	tmp = *(dptr + 56) ;
    b7  = b0 - tmp ;
    b0 += tmp;

    b1  = *(dptr + 8);
	tmp = *(dptr + 48) ;
    b6  = b1 - tmp;
	b1 += tmp;

    b2  = *(dptr + 16);
	tmp = *(dptr + 40) ;
    b5  = b2 - tmp;
	b2 += tmp;

    b3  = *(dptr + 24);
	tmp = *(dptr + 32) ;
    b4  = b3 - tmp;
    b3 += tmp;

    t0  = b0 + b3;
    b3  = b0 - b3;

    t1  = b1 + b2;
    b2  = b1 - b2;

	tmp = b5;
    b5  = (b6 - b5)  * W0;
    b6  = (b6 + tmp) * W0;

    t2  = b4 + b5;
    b5  = b4 - b5;

    tmp = b7 + b6;
    b6  = b7 - b6;

    *(coeffptr + *ptdzz++) = S ((t0 + t1) * W4);
    *(coeffptr + *ptdzz++) = S (t2 * W7 + tmp * W1);
    *(coeffptr + *ptdzz++) = S (b2 * W6 + b3 * W2);
    *(coeffptr + *ptdzz++) = S (b6 * W3 - b5 * W5);

    ptdzz+=4;
  }

  return 1;
}

/**********************************************************************
 *
 *	Name:		idct
 *	Description:	inverse dct on 64 coefficients
 *
 *	Input:		64 coefficients, block for 64 pixels
 *	Returns:    	0
 *	Side effects:	
 *
 **********************************************************************/

/*
** Function: ScIDCT8x8s
** Note:     This scheme uses the direct transposition of the forward
**           DCT.  This may not be the preferred way in Hardware
**           Implementations
**      #define W1 2841 */ /* 2048*sqrt(2)*cos(1*pi/16)
**      #define W2 2676 */ /* 2048*sqrt(2)*cos(2*pi/16)
**      #define W5 1609 */ /* 2048*sqrt(2)*cos(5*pi/16)
*/

#define WW3 2408 /* 2048*sqrt(2)*cos(3*pi/16) */
#define WW6 1108 /* 2048*sqrt(2)*cos(6*pi/16) */
#define WW7 565  /* 2048*sqrt(2)*cos(7*pi/16) */

#define AW26 3784
#define DW26 1568
#define AW17 3406
#define DW17 2276
#define AW35 4017
#define DW35 799

#define IDCTSHIFTR  8
#define IDCTSHIFTC  14

#ifndef USE_C
void sv_H263FillX0_S(short *stream, short wd);
#endif

int sv_H263IDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size)
{
  int i;
  const unsigned int *ptdzz=tdzz;
  register int tmp0, tmp1, tmp2, tmp3, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register short *tmpblk;
  short tmpbuf[64];
  int Q2,QP_1;
  int p1, p2, p3, p4, p5, p6, p7;

  /* double quantization step */
  Q2 = QP << 1;
  QP_1 = QP - 1;

  inblk = inbuf;
  tmpblk = tmpbuf;

  if((QP %2) == 0){
    for (i=0; i<8; i++)
    {
      /* read in ZZ order */
      x0 = inblk[*ptdzz++];
      x4 = inblk[*ptdzz++];
      x3 = inblk[*ptdzz++];
      x7 = inblk[*ptdzz++];
      x1 = inblk[*ptdzz++];
      x6 = inblk[*ptdzz++];
      x2 = inblk[*ptdzz++];
      x5 = inblk[*ptdzz++];

  	  /* dequantize DC */
      if (!i && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q))
        x0 = x0 << 3;
	  else
        if(x0) x0 = (x0 > 0) ? Q2*x0+QP-1 : Q2*x0-QP+1 ;

      if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7)) {
        if(!x0) memset(tmpblk, 0, 16) ;
	    else   {
#ifndef USE_C
          sv_H263FillX0_S(tmpblk, (short)(x0 << 3)) ;
#else
          *tmpblk = *(tmpblk+1) =
          *(tmpblk+2) = *(tmpblk+3) =
          *(tmpblk+4) = *(tmpblk+5) =
          *(tmpblk+6) = *(tmpblk+7) = (short)(x0 << 3) ;
#endif
		}
        tmpblk += 8;
	  }
      else
      {
   	    /* dequantize AC */
  	    if(x1) x1 = (x1 > 0) ? Q2*x1+QP_1 : Q2*x1-QP_1 ;
  	    if(x2) x2 = (x2 > 0) ? Q2*x2+QP_1 : Q2*x2-QP_1 ;
  	    if(x3) x3 = (x3 > 0) ? Q2*x3+QP_1 : Q2*x3-QP_1 ;
  	    if(x4) x4 = (x4 > 0) ? Q2*x4+QP_1 : Q2*x4-QP_1 ;
  	    if(x5) x5 = (x5 > 0) ? Q2*x5+QP_1 : Q2*x5-QP_1 ;
  	    if(x6) x6 = (x6 > 0) ? Q2*x6+QP_1 : Q2*x6-QP_1 ;
  	    if(x7) x7 = (x7 > 0) ? Q2*x7+QP_1 : Q2*x7-QP_1 ;

        x1 = x1<<11;

        tmp0 = x4 + x5;
        tmp0 = WW7*tmp0;

        x0 = x0<<11;
        x0 = x0 + 128;
        x8 = x0 + x1;

        tmp1 = x6 + x7;
        x0 = x0 - x1;
        tmp1 = WW3*tmp1;
        tmp2 = AW26*x2;
        tmp3 = DW26*x3;

        x4 = DW17*x4;
        x5 = AW17*x5;

        x4 = tmp0 + x4;
        x1 = x3 + x2;
        x5 = tmp0 - x5;
        x1 = WW6*x1;
        tmp0 = DW35*x6;
        x7 = AW35*x7;
        x2 = x1 - tmp2;
        x3 = x1 + tmp3;
        tmp0 = tmp1 - tmp0;
        x7 = tmp1 - x7;
        x1 = x4 + tmp0;
        x4 = x4 - tmp0;
        x6 = x5 + x7;    /* F */
        x5 = x5 - x7;    /* F */
        tmp0 = x4 + x5;
        tmp0 = 181*tmp0;
        x7 = x8 + x3;    /* F */
        tmp1 = x4 - x5;
        x8 = x8 - x3;    /* F */
        tmp1 = 181*tmp1;
        x3 = x0 + x2;    /* F */
        x0 = x0 - x2;    /* F */
        x2 = tmp0 + 128;
        x4 = tmp1 + 128;
        x2 = x2>>8;      /* F */
        x4 = x4>>8;      /* F */

        tmp0 = x7+x1;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x3+x2;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x0+x4;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x8+x6;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
        tmp0 = x8-x6;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x0-x4;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x3-x2;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x7-x1;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
      }
    }
  }
  else{
    for (i=0; i<8; i++)
    {
      /* read in ZZ order */
      x0 = inblk[*ptdzz++];
      x4 = inblk[*ptdzz++];
      x3 = inblk[*ptdzz++];
      x7 = inblk[*ptdzz++];
      x1 = inblk[*ptdzz++];
      x6 = inblk[*ptdzz++];
      x2 = inblk[*ptdzz++];
      x5 = inblk[*ptdzz++];

  	  /* quantize DC */
      if (!i && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q))
        x0 = x0 << 3;
	  else
        if(x0) x0 = (x0 > 0) ? Q2*x0+QP : Q2*x0-QP ;

      if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7)) {
        if(!x0) memset(tmpblk, 0, 16) ;
	    else  {
#ifndef USE_C
          sv_H263FillX0_S(tmpblk, (short)(x0 << 3)) ;
#else
          *tmpblk = *(tmpblk+1) =
          *(tmpblk+2) = *(tmpblk+3) =
          *(tmpblk+4) = *(tmpblk+5) =
          *(tmpblk+6) = *(tmpblk+7) = (short)(x0 << 3) ;
#endif
		}
        tmpblk += 8;
	  }
      else
      {
   	    /* dequantize AC */
  	    if(x1) x1 = (x1 > 0) ? Q2*x1+QP : Q2*x1-QP ;
  	    if(x2) x2 = (x2 > 0) ? Q2*x2+QP : Q2*x2-QP ;
  	    if(x3) x3 = (x3 > 0) ? Q2*x3+QP : Q2*x3-QP ;
  	    if(x4) x4 = (x4 > 0) ? Q2*x4+QP : Q2*x4-QP ;
  	    if(x5) x5 = (x5 > 0) ? Q2*x5+QP : Q2*x5-QP ;
  	    if(x6) x6 = (x6 > 0) ? Q2*x6+QP : Q2*x6-QP ;
  	    if(x7) x7 = (x7 > 0) ? Q2*x7+QP : Q2*x7-QP ;

        x1 = x1<<11;

        tmp0 = x4 + x5;
        tmp0 = WW7*tmp0;

        x0 = x0<<11;
        x0 = x0 + 128;
        x8 = x0 + x1;

        tmp1 = x6 + x7;
        x0 = x0 - x1;
        tmp1 = WW3*tmp1;
        tmp2 = AW26*x2;
        tmp3 = DW26*x3;

        x4 = DW17*x4;
        x5 = AW17*x5;

        x4 = tmp0 + x4;
        x1 = x3 + x2;
        x5 = tmp0 - x5;
        x1 = WW6*x1;
        tmp0 = DW35*x6;
        x7 = AW35*x7;
        x2 = x1 - tmp2;
        x3 = x1 + tmp3;
        tmp0 = tmp1 - tmp0;
        x7 = tmp1 - x7;
        x1 = x4 + tmp0;
        x4 = x4 - tmp0;
        x6 = x5 + x7;    /* F */
        x5 = x5 - x7;    /* F */
        tmp0 = x4 + x5;
        tmp0 = 181*tmp0;
        x7 = x8 + x3;    /* F */
        tmp1 = x4 - x5;
        x8 = x8 - x3;    /* F */
        tmp1 = 181*tmp1;
        x3 = x0 + x2;    /* F */
        x0 = x0 - x2;    /* F */
        x2 = tmp0 + 128;
        x4 = tmp1 + 128;
        x2 = x2>>8;      /* F */
        x4 = x4>>8;      /* F */

        tmp0 = x7+x1;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x3+x2;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x0+x4;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x8+x6;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
        tmp0 = x8-x6;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x0-x4;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x3-x2;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x7-x1;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
      }
    }
  }

  /* output position */
  p1 = outbuf_size;
  p2 = p1 + outbuf_size;
  p3 = p2 + outbuf_size;
  p4 = p3 + outbuf_size;
  p5 = p4 + outbuf_size;
  p6 = p5 + outbuf_size;
  p7 = p6 + outbuf_size;

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    x0 = tmpblk[0];
    x1 = tmpblk[32];
    x2 = tmpblk[48];
    x3 = tmpblk[16];
    x4 = tmpblk[8];
    x5 = tmpblk[56];
    x6 = tmpblk[40];
    x7 = tmpblk[24];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmp0=(x0+32)>>6;
      outblk[0]=outblk[p1]=outblk[p2]=outblk[p3]=outblk[p4]=outblk[p5]=
      outblk[p6]=outblk[p7]= (short)tmp0 ;
    }
    else
    {
	  x1 = x1 <<8;
      tmp0 = x4+x5;
      x0 = x0<<8;
      tmp0 = WW7*tmp0;
      x0 = x0 + 8192;
      tmp1 = x6+x7;
      tmp0 = tmp0 + 4;
      tmp1 = WW3*tmp1;
      tmp1 = tmp1 + 4;
      x8 = x0 + x1;
      tmp2 = AW26*x2;
      x0 = x0 - x1;
      x1 = x3 + x2;
      x1 = WW6*x1;
      tmp3 = DW26*x3;
      x1 = x1 + 4;
      x4 = DW17*x4;
      x4 = tmp0 + x4;
      x4 = x4>>3;
      x5 = AW17*x5;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      x6 = DW35*x6;
      x2 = x2>>3;
      x5 = tmp0 - x5;
      x5 = x5>>3;
      x6 = tmp1 - x6;
      x6 = x6>>3;
      x7 = AW35*x7;
      x7 = tmp1 - x7;
      x3 = x3>>3;
      x7 = x7>>3;
      x1 = x4 + x6;    /* F */
      x4 = x4 - x6;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp1 = x4 + x5;
      x7 = x8 + x3;    /* F */
      tmp1 = 181*tmp1;
      x8 = x8 - x3;    /* F */
      x3 = x0 + x2;    /* F */
      tmp2 = x4 - x5;
      x0 = x0 - x2;    /* F */
      tmp2 = 181*tmp2;
      x2 = tmp1+128;
      x4 = tmp2+128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */

      /* fourth stage */
      tmp0=x7+x1;
      tmp1=x3+x2;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x0+x4;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x8+x6;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;

      outblk[0] = (short)tmp0;
      outblk[p1] = (short)tmp1;
      outblk[p2] = (short)tmp2;
      outblk[p3] = (short)tmp3;

      tmp0=x8-x6;
      tmp1=x0-x4;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x3-x2;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x7-x1;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;

      outblk[p4] = (short)tmp0;
      outblk[p5] = (short)tmp1;
      outblk[p6] = (short)tmp2;
      outblk[p7] = (short)tmp3;
    }
  }

  return 0;
}

/**********************************************************************
 *
 *	Description:	inverse zone-dct on 64 coefficients
 *
 *	Input:		64 coefficients, block for 64 pixels
 *	Returns:    	0
 *	Side effects:	
 *
 **********************************************************************/

int sv_H263ZoneIDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size)
{
  int i;
  const unsigned int *ptdzz=tdzz;
  register int tmp0, tmp1, tmp2, tmp3, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register short *tmpblk;
  short tmpbuf[64];
  int Q2,QP_1;
  int p1, p2, p3, p4, p5, p6, p7;

  /* double quantization step */
  Q2 = QP << 1;
  QP_1 = QP - 1;

  inblk = inbuf;
  tmpblk = tmpbuf;

  memset(tmpblk, 0, 128) ;

  if((QP %2) == 0){
    for (i=0; i<4; i++)
    {
      /* read in ZZ order */
      x0 = inblk[*ptdzz++];
      x4 = inblk[*ptdzz++];
      x3 = inblk[*ptdzz++];
      x7 = inblk[*ptdzz++];
      x1 = x6 = x2 = x5 = 0;
	  ptdzz += 4;

  	  /* dequantize DC */
      if (!i && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q))
        x0 = x0 << 3;
	  else
        if(x0) x0 = (x0 > 0) ? Q2*x0+QP-1 : Q2*x0-QP+1 ;

      if (!(x3 | x4 | x7)) {
        if(!x0) memset(tmpblk, 0, 16) ;
	    else   {
#ifndef USE_C
          sv_H263FillX0_S(tmpblk, (short)(x0 << 3)) ;
#else
          *tmpblk = *(tmpblk+1) =
          *(tmpblk+2) = *(tmpblk+3) =
          *(tmpblk+4) = *(tmpblk+5) =
          *(tmpblk+6) = *(tmpblk+7) = (short)(x0 << 3) ;
#endif
		}
        tmpblk += 8;
	  }
      else
      {
   	    /* dequantize AC */
  	    if(x3) x3 = (x3 > 0) ? Q2*x3+QP_1 : Q2*x3-QP_1 ;
  	    if(x4) x4 = (x4 > 0) ? Q2*x4+QP_1 : Q2*x4-QP_1 ;
  	    if(x7) x7 = (x7 > 0) ? Q2*x7+QP_1 : Q2*x7-QP_1 ;

        tmp0 = x4;
        tmp0 = WW7*tmp0;

        x0 = x0<<11;
        x0 = x0 + 128;
        x8 = x0;

        tmp1 = WW3*x7;
        tmp3 = DW26*x3;

        x4 = DW17*x4;

        x4 = tmp0 + x4;
        x1 = x3;
        x5 = tmp0;

        x7 = AW35*x7;
        x2 = x1;
        x3 = x1 + tmp3;
        tmp0 = tmp1;
        x7 = tmp1 - x7;
        x1 = x4 + tmp0;
        x4 = x4 - tmp0;
        x6 = x5 + x7;    /* F */
        x5 = x5 - x7;    /* F */
        tmp0 = x4 + x5;
        tmp0 = 181*tmp0;
        x7 = x8 + x3;    /* F */
        tmp1 = x4 - x5;
        x8 = x8 - x3;    /* F */
        tmp1 = 181*tmp1;
        x3 = x0 + x2;    /* F */
        x0 = x0 - x2;    /* F */
        x2 = tmp0 + 128;
        x4 = tmp1 + 128;
        x2 = x2>>8;      /* F */
        x4 = x4>>8;      /* F */

        tmp0 = x7+x1;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x3+x2;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x0+x4;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x8+x6;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
        tmp0 = x8-x6;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x0-x4;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x3-x2;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x7-x1;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
      }
    }
  }
  else{
    for (i=0; i<4; i++)
    {
      /* read in ZZ order */
      x0 = inblk[*ptdzz++];
      x4 = inblk[*ptdzz++];
      x3 = inblk[*ptdzz++];
      x7 = inblk[*ptdzz++];
      x1 = x6 = x2 = x5 = 0;
	  ptdzz += 4;

  	  /* quantize DC */
      if (!i && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q))
        x0 = x0 << 3;
	  else
        if(x0) x0 = (x0 > 0) ? Q2*x0+QP : Q2*x0-QP ;

      if (!(x3 | x4 | x7)) {
        if(!x0) memset(tmpblk, 0, 16) ;
	    else  {
#ifndef USE_C
          sv_H263FillX0_S(tmpblk, (short)(x0 << 3)) ;
#else
          *tmpblk = *(tmpblk+1) =
          *(tmpblk+2) = *(tmpblk+3) =
          *(tmpblk+4) = *(tmpblk+5) =
          *(tmpblk+6) = *(tmpblk+7) = (short)(x0 << 3) ;
#endif
		}
        tmpblk += 8;
	  }
      else
      {
   	    /* dequantize AC */
  	    if(x3) x3 = (x3 > 0) ? Q2*x3+QP : Q2*x3-QP ;
  	    if(x4) x4 = (x4 > 0) ? Q2*x4+QP : Q2*x4-QP ;
  	    if(x7) x7 = (x7 > 0) ? Q2*x7+QP : Q2*x7-QP ;

        tmp0 = x4;
        tmp0 = WW7*tmp0;

        x0 = x0<<11;
        x0 = x0 + 128;
        x8 = x0;

        tmp1 = WW3*x7;
        tmp3 = DW26*x3;

        x4 = DW17*x4;

        x4 = tmp0 + x4;
        x1 = x3;
        x5 = tmp0;
        x1 = WW6*x1;
        tmp0 = 0;
        x7 = AW35*x7;
        x2 = x1 - tmp2;
        x3 = x1 + tmp3;
        tmp0 = tmp1;
        x7 = tmp1 - x7;
        x1 = x4 + tmp0;
        x4 = x4 - tmp0;
        x6 = x5 + x7;    /* F */
        x5 = x5 - x7;    /* F */
        tmp0 = x4 + x5;
        tmp0 = 181*tmp0;
        x7 = x8 + x3;    /* F */
        tmp1 = x4 - x5;
        x8 = x8 - x3;    /* F */
        tmp1 = 181*tmp1;
        x3 = x0 + x2;    /* F */
        x0 = x0 - x2;    /* F */
        x2 = tmp0 + 128;
        x4 = tmp1 + 128;
        x2 = x2>>8;      /* F */
        x4 = x4>>8;      /* F */

        tmp0 = x7+x1;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x3+x2;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x0+x4;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x8+x6;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
        tmp0 = x8-x6;
        tmp0 = tmp0>>IDCTSHIFTR;
        tmp1 = x0-x4;
        tmp1 = tmp1>>IDCTSHIFTR;
        tmp2 = x3-x2;
        tmp2 = tmp2>>IDCTSHIFTR;
        tmp3 = x7-x1;
        tmp3 = tmp3>>IDCTSHIFTR;
        *tmpblk++ = (short)tmp0;
        *tmpblk++ = (short)tmp1;
        *tmpblk++ = (short)tmp2;
        *tmpblk++ = (short)tmp3;
      }
    }
  }

  /* output position */
  p1 = outbuf_size;
  p2 = p1 + outbuf_size;
  p3 = p2 + outbuf_size;
  p4 = p3 + outbuf_size;
  p5 = p4 + outbuf_size;
  p6 = p5 + outbuf_size;
  p7 = p6 + outbuf_size;

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    x0 = tmpblk[0];
    x1 = tmpblk[32];
    x2 = tmpblk[48];
    x3 = tmpblk[16];
    x4 = tmpblk[8];
    x5 = tmpblk[56];
    x6 = tmpblk[40];
    x7 = tmpblk[24];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmp0=(x0+32)>>6;
      outblk[0]=outblk[p1]=outblk[p2]=outblk[p3]=outblk[p4]=outblk[p5]=
      outblk[p6]=outblk[p7]= (short)tmp0 ;
    }
    else
    {
	  x1 = x1 <<8;
      tmp0 = x4+x5;
      x0 = x0<<8;
      tmp0 = WW7*tmp0;
      x0 = x0 + 8192;
      tmp1 = x6+x7;
      tmp0 = tmp0 + 4;
      tmp1 = WW3*tmp1;
      tmp1 = tmp1 + 4;
      x8 = x0 + x1;
      tmp2 = AW26*x2;
      x0 = x0 - x1;
      x1 = x3 + x2;
      x1 = WW6*x1;
      tmp3 = DW26*x3;
      x1 = x1 + 4;
      x4 = DW17*x4;
      x4 = tmp0 + x4;
      x4 = x4>>3;
      x5 = AW17*x5;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      x6 = DW35*x6;
      x2 = x2>>3;
      x5 = tmp0 - x5;
      x5 = x5>>3;
      x6 = tmp1 - x6;
      x6 = x6>>3;
      x7 = AW35*x7;
      x7 = tmp1 - x7;
      x3 = x3>>3;
      x7 = x7>>3;
      x1 = x4 + x6;    /* F */
      x4 = x4 - x6;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp1 = x4 + x5;
      x7 = x8 + x3;    /* F */
      tmp1 = 181*tmp1;
      x8 = x8 - x3;    /* F */
      x3 = x0 + x2;    /* F */
      tmp2 = x4 - x5;
      x0 = x0 - x2;    /* F */
      tmp2 = 181*tmp2;
      x2 = tmp1+128;
      x4 = tmp2+128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */

      /* fourth stage */
      tmp0=x7+x1;
      tmp1=x3+x2;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x0+x4;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x8+x6;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;

      outblk[0] = (short)tmp0;
      outblk[p1] = (short)tmp1;
      outblk[p2] = (short)tmp2;
      outblk[p3] = (short)tmp3;

      tmp0=x8-x6;
      tmp1=x0-x4;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x3-x2;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x7-x1;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;

      outblk[p4] = (short)tmp0;
      outblk[p5] = (short)tmp1;
      outblk[p6] = (short)tmp2;
      outblk[p7] = (short)tmp3;
    }
  }

  return 0;
}

#if 0
/*
** Function: ZigzagMatrix()
** Purpose:  Performs a zig-zag translation on the input imatrix
**           and puts the output in omatrix.
*/
void svH263ZigzagMatrix(short *imatrix, short *omatrix)
{
  const unsigned int *ptdzz=tdzz;
  int k;

  for(k=64; k; k--)
    omatrix[*ptdzz++] = *imatrix++;
}

/*
** Function: InvZigzagMatrix()
** Purpose:  Performs an inverse  zig-zag translation on the input imatrix
**           and puts the output in omatrix.
*/
void svH263InvZigzagMatrix(short *imatrix, short *omatrix)
{
  const unsigned int *ptdzz=tdzz;
  int k;

  for(k=64; k; k--)
    *omatrix++ = imatrix[*ptdzz++];

}
#endif
#ifndef PI
# ifdef M_PI
#  define PI M_PI
# else
#  define PI 3.14159265358979323846
# endif
#endif

int	zigzag[8][8] = {
  {0, 1, 5, 6,14,15,27,28},
  {2, 4, 7,13,16,26,29,42},
  {3, 8,12,17,25,30,41,43},
  {9,11,18,24,31,40,44,53},
  {10,19,23,32,39,45,52,54},
  {20,22,33,38,46,51,55,60},
  {21,34,37,47,50,56,59,61},
  {35,36,48,49,57,58,62,63},
};

/*  Perform IEEE 1180 reference (64-bit floating point, separable 8x1
 *  direct matrix multiply) Inverse Discrete Cosine Transform
*/


/* Here we use math.h to generate constants.  Compiler results may
   vary a little */

/* private data */

/* cosine transform matrix for 8x1 IDCT */
static double c[8][8];

/* initialize DCT coefficient matrix */

void sv_H263init_idctref()
{
  int freq, time;
  double scale;

  for (freq=0; freq < 8; freq++)
  {
    scale = (freq == 0) ? sqrt(0.125) : 0.5;
    for (time=0; time<8; time++)
      c[freq][time] = scale*cos((PI/8.0)*freq*(time + 0.5));
  }
}

/* perform IDCT matrix multiply for 8x8 coefficient block */

void sv_H263idctref(short *coeff, short *block)
{
  int i, j, k, v;
  double partial_product;
  double tmp[64];
  int tmp2[64];
  extern int zigzag[8][8];

  for (i=0; i<8; i++)
    for (j=0; j<8; j++)
      tmp2[j+i*8] = *(coeff + zigzag[i][j]);

  for (i=0; i<8; i++)
    for (j=0; j<8; j++)
    {
      partial_product = 0.0;

      for (k=0; k<8; k++)
        partial_product+= c[k][j]*tmp2[8*i+k];

      tmp[8*i+j] = partial_product;
    }

  /* Transpose operation is integrated into address mapping by switching
     loop order of i and j */

  for (j=0; j<8; j++)
    for (i=0; i<8; i++)
    {
      partial_product = 0.0;

      for (k=0; k<8; k++)
        partial_product+= c[k][i]*tmp[8*k+j];

      v = (int)floor(partial_product+0.5);
      block[8*i+j] = (v<-256) ? -256 : ((v>255) ? 255 : v);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\decode.c ===
/* File: sv_h263_decode.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "sv_proto.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#ifdef USE_TIME
#ifndef WIN32
#include <sys/time.h>
#else
#include <windows.h>
#endif
#endif

#ifdef WIN32
#include <io.h>
#endif

#ifdef WINDOWS
int initDisplay (int pels, int lines);
int closeDisplay ();
#endif

/************************************************************/
/************************************************************/

SvStatus_t svH263Decompress(SvCodecInfo_t *Info, u_char **ImagePtr)
{
  SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
  SvStatus_t status;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263Decompress() bytepos=%ld\n",
                                          ScBSBytePosition(Info->BSIn)) );
  if (H263Info->framenum==0)
  {
    sv_H263GetPicture(Info);
    H263Info->framenum++;
  }
  else
  {
    status=sv_H263GetHeader(H263Info, Info->BSIn, NULL);
    if (status==SvErrorNone)
    {
      sv_H263GetPicture(Info);
      H263Info->framenum++;
    }
    else
	  return(status); /* error */
  }
  if (H263Info->pb_frame)
    *ImagePtr=H263Info->bframe[0];
  else
    *ImagePtr=H263Info->newframe[0];
  	  return(SvErrorNone);
}

/************************************************************/
/************************************************************/

SvStatus_t svH263InitDecompressor(SvCodecInfo_t *Info)
{
  SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
  ScBitstream_t *BSIn = Info->BSIn;
  int i, cc, size;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263InitDecoder()\n") );

  /* svH263Initbits(H263Info->inputfilename); */

  H263Info->temp_ref = 0;

  /*
    verbose : verbose level
    outtype :
	        T_YUV           0 : YUV
            H263_T_SIF      1 : SIF
            H263_T_TGA      2 : TGA
            H263_T_PPM      3 : PPM
            H263_T_X11      4 : X11 Unix Display
            H263_T_YUV_CONC 5 : YUV concatenated
            H263_T_WIN      6 : Windows 95/NT Display
    quiet   : disable warnings to stderr\n\
    refidct : use double precision reference IDCT\n\
    trace   : enable low level tracing\n");
    frame_rate :
                n=0  : as fast as possible\n\
                n=99 : read frame rate from bitstream (default)\n");
  */
  if (!H263Info->inited)
  {
    H263Info->frame_rate = 0;
    H263Info->verbose = 0;
    H263Info->outtype = H263_T_WIN;
    H263Info->refidct = 0;
    H263Info->expand = 0;
    H263Info->trace = 0;
    H263Info->quiet = 1;
    /* pointer to name of output files */
    if (H263Info->outtype==H263_T_X11 || H263Info->outtype == H263_T_WIN)
      H263Info->outputname = "";
    else H263Info->outputname = H263_DEF_OUTPUTNAME;
  }
  /* initial frame number */
  H263Info->framenum = 0;

  if (BSIn && sv_H263GetHeader(H263Info, BSIn, NULL)!=SvErrorNone)
    return(SvErrorEndBitstream);

  /* MPEG-1 = TMN parameters */
  H263Info->matrix_coefficients = 5;

  switch (H263Info->source_format) {
    case (H263_SF_SQCIF):
      H263Info->horizontal_size = 128;
      H263Info->vertical_size = 96;
      break;
    case (H263_SF_QCIF):
      H263Info->horizontal_size = 176;
      H263Info->vertical_size = 144;
      break;
    case (H263_SF_CIF):
      H263Info->horizontal_size = 352;
      H263Info->vertical_size = 288;
      break;
    case (H263_SF_4CIF):
      H263Info->horizontal_size = 704;
      H263Info->vertical_size = 576;
      break;
    case (H263_SF_16CIF):
      H263Info->horizontal_size = 1408;
      H263Info->vertical_size = 1152;
      break;
    default:
      _SlibDebug(_VERBOSE_ || _WARN_,
          ScDebugPrintf(H263Info->dbg, "svH263InitDecompressor() Illegal input format\n") );
      return(ScErrorUnrecognizedFormat);
  }

  H263Info->mb_width = H263Info->horizontal_size/16;
  H263Info->mb_height = H263Info->vertical_size/16;
  H263Info->coded_picture_width = H263Info->horizontal_size;
  H263Info->coded_picture_height = H263Info->vertical_size;
  H263Info->chrom_width =  H263Info->coded_picture_width>>1;
  H263Info->chrom_height = H263Info->coded_picture_height>>1;
  H263Info->blk_cnt = 6;

  if (!H263Info->inited)
  {
    unsigned char *frameptr;
    unsigned int ysize, chromsize;
    ysize = H263Info->coded_picture_width*H263Info->coded_picture_height;
    chromsize = H263Info->chrom_width*H263Info->chrom_height;
    /* clip table */
    if (!(H263Info->clp=(unsigned char *)ScAlloc(1024)))
      return(SvErrorMemory);

    H263Info->clp += 384;

    for (i=-384; i<640; i++)
      H263Info->clp[i] = (i<0) ? 0 : ((i>255) ? 255 : i);
    H263Info->block=(int (*)[66])ScPaMalloc(12*sizeof(int [66]));
    if (H263Info->block==NULL)
      return(SvErrorMemory);
    /* allocate buffers for P, reference, B frames */
    if ((frameptr=(unsigned char *)ScPaMalloc(ysize + chromsize*2))==NULL)
      return(SvErrorMemory);
    H263Info->refframe[0] = frameptr;
    H263Info->refframe[1] = frameptr+ysize;
    H263Info->refframe[2] = frameptr+ysize+chromsize;
    /* initialize image buffer with black */
    memset(H263Info->refframe[0], 16, ysize);
    memset(H263Info->refframe[1], 128, chromsize);
    memset(H263Info->refframe[2], 128, chromsize);
    if ((frameptr=(unsigned char *)ScPaMalloc(ysize + chromsize*2))==NULL)
        return(SvErrorMemory);
    H263Info->oldrefframe[0] = frameptr;
    H263Info->oldrefframe[1] = frameptr+ysize;
    H263Info->oldrefframe[2] = frameptr+ysize+chromsize;
    /* initialize image buffer with black */
    memset(H263Info->oldrefframe[0], 16, ysize);
    memset(H263Info->oldrefframe[1], 128, chromsize);
    memset(H263Info->oldrefframe[2], 128, chromsize);
    if ((frameptr=(unsigned char *)ScPaMalloc(ysize + chromsize*2))==NULL)
        return(SvErrorMemory);
    H263Info->bframe[0] = frameptr;
    H263Info->bframe[1] = frameptr+ysize;
    H263Info->bframe[2] = frameptr+ysize+chromsize;
    /* initialize image buffer with black */
    memset(H263Info->bframe[0], 16, ysize);
    memset(H263Info->bframe[1], 128, chromsize);
    memset(H263Info->bframe[2], 128, chromsize);

    /* allocate buffers for edge frames */
    for (cc=0; cc<3; cc++) {
      if (cc==0) {
        size = (H263Info->coded_picture_width+64)*(H263Info->coded_picture_height+64);
        if (!(H263Info->edgeframeorig[cc] = (unsigned char *)ScAlloc(size)))
          return(SvErrorMemory);
        H263Info->edgeframe[cc] = H263Info->edgeframeorig[cc] + 
		                                   (H263Info->coded_picture_width+64) * 32 + 32;
      }
      else {
        size = (H263Info->chrom_width+32)*(H263Info->chrom_height+32);
        if (!(H263Info->edgeframeorig[cc] = (unsigned char *)ScAlloc(size)))
          return(SvErrorMemory);
        H263Info->edgeframe[cc] = H263Info->edgeframeorig[cc] + (H263Info->chrom_width+32) * 16 + 16;
      }
    }

    if (H263Info->expand) {
      for (cc=0; cc<3; cc++) {
        if (cc==0)
          size = H263Info->coded_picture_width*H263Info->coded_picture_height*4;
        else
          size = H263Info->chrom_width*H263Info->chrom_height*4;
      
        if (!(H263Info->exnewframe[cc] = (unsigned char *)ScAlloc(size)))
          return(SvErrorMemory);
      }
    }
    /* IDCT */
#ifdef H263_C_CODE
    if (H263Info->refidct)
      svH263Init_idctref();
    else
      svH263Init_idct();
#endif
  }
#if 0
  /* Clear output file for concatenated storing */
  if (H263Info->outtype == H263_T_YUV_CONC) {
    FILE *cleared;
    if ((cleared = fopen(H263Info->outputname,"wb")) == NULL) {
      fclose(cleared);
      svH263Error("couldn't clear outputfile\n");
	}
    else
      fclose(cleared);
  }
#ifdef DISPLAY
  if (H263Info->outtype==H263_T_X11) {
    svH263Init_display("");
  }
#endif

#ifdef WINDOWS
  if (H263Info->outtype==H263_T_WIN)
    initDisplay(H263Info->coded_picture_width, H263Info->coded_picture_height);
#endif
#endif
  H263Info->inited=TRUE;
  return(SvErrorNone);
}

/************************************************************/
/************************************************************/

SvStatus_t svH263FreeDecompressor(SvCodecInfo_t *Info)
{
  SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
  int cc;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263FreeDecoder()\n") );
  if (!H263Info->inited)
    return(SvErrorNone);
#ifdef DISPLAY
  if (H263Info->outtype==H263_T_X11)
    svH263Exit_display();
#endif
#ifdef WINDOWS
  if (H263Info->outtype == H263_T_WIN)
    closeDisplay();
#endif

#if 0
#if SC_READ
  svH263Stopbits();  
#else
  /* close input file */
  close(H263Info->base.infile);
#endif
#endif
  /* clip table */
  H263Info->clp -= 384;
  ScFree(H263Info->clp);
  ScPaFree(H263Info->block);
  /* allocate buffers for P, reference, B frames */
  ScPaFree(H263Info->refframe[0]) ;
  ScPaFree(H263Info->oldrefframe[0]);
  ScPaFree(H263Info->bframe[0]);

  /* allocate buffers for edge frames */
  for (cc=0; cc<3; cc++) {
    if (cc==0) ScFree(H263Info->edgeframeorig[cc]);
    else ScFree(H263Info->edgeframeorig[cc]);   
  }

  if (H263Info->expand) 
    for (cc=0; cc<3; cc++) 
      ScFree(H263Info->exnewframe[cc]);

  H263Info->inited=FALSE;
  return(SvErrorNone);
}

/************************************************************/
/************************************************************/

void svH263Error(char *text)
{
  /* fprintf(stderr,text); */
  /* exit(1); */
}

/************************************************************/
/************************************************************/
#if 0
/* trace output */
void svH263Printbits(code,bits,len)
int code,bits,len;
{
  int i;
  for (i=0; i<len; i++) printf("%d",(code>>(bits-1-i))&1);

  return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\edge.c ===
/* File: sv_h263_edge.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"

#define BSIZE 8
#define BSZSHIFT 6
#define EDGE_TH 150


static void lineDetect(int H, int V, int D1, int D2, unsigned char *pe, unsigned char *po);
static void findEdge(int ul, int u, int ur, int l,  int c, int r, int bl, int b, int br,
	            unsigned char *pe, unsigned char *po, char mode);


/***********************************************************************************
 * Function: Sobel
 * Sobel gradient-based edge detector (see Jain, page 349)
 **********************************************************************************/
void Sobel(int ul, int u, int ur, int l,  int c, int r, int bl, int b, int br,
	       unsigned char *pe, unsigned char *po)
{
	int gx, gy, AGX, AGY;

	gx = -ul + ur - (l<<1) + (r<<1) - bl + br;
	gy = -ul + bl - (u<<1) + (b<<1) - ur + br;

	AGX = gx > 0 ? gx : -gx;
	AGY = gy > 0 ? gy : -gy;

	*pe = (AGX+AGY)> EDGE_TH ? 255 : 0;
}

/***********************************************************************************
 * Function: lineDetect
 * Compass-based line detector (see Jain, page 357)
 **********************************************************************************/
void lineDetect(int H, int V, int D1, int D2, unsigned char *pe, unsigned char *po) 
{
	int AH, AV, AD1, AD2, ED;

	AH = (H>0 ? H : -H);
	AV = (V>0 ? V : -V);
	AD1 = (D1>0 ? D1: -D1);
	AD2 = (D2>0 ? D2: -D2);

	if(AH>=AV && AH>=AD1 && AH>=AD2) {
		ED = AH;
		*po = 1;
	} else if (AV>=AH && AV>=AD1 && AV>=AD2) {
		ED = AV;
		*po = 2;
	} else if (AD1>=AH && AD1>=AV && AD1>=AD2) {
		ED = AD1;
		*po = 3;
	} else {
		ED = AD2;
		*po = 4;
	}

	if (ED < EDGE_TH) { *pe = 0; *po = 0;}
	else *pe = 255;
}

/**********************************************************************************
 * Function: findEdge
 * Computes edge magnitude and orientation given the pixel's neighborhood
 *********************************************************************************/
void findEdge(int ul, int u, int ur, int l,  int c, int r, int bl, int b, int br,
	            unsigned char *pe, unsigned char *po, char mode)
{
	  switch(mode) {
	  case 'L': 
		  {
			  int H, V, D1, D2;

			  /* Horizontal gradient */
			  H = -ul -u -ur + (l<<1) + (c<<1) + (r<<1) -bl -b -br;
			  /* Vertical gradient */
			  V = -ul + (u<<1) -ur -l + (c<<1) -r -bl + (b<<1) -br;
			  /* Diagonal gradient 1 */ 
			  D1 = -ul -u + (ur<<1) -l + (c<<1) -r + (bl<<1) -b -br;
			  /* Diagonal gradient 2*/
			  D2 = (ul<<1) -u -ur -l + (c<<1) -r -bl -b +(br<<1);
			  lineDetect(H, V, D1, D2, pe, po);
			  break;
		  }
	  case 'S':
		  {
			  Sobel(ul, u, ur, l, c, r, bl, b, br, pe, po);
			  break;
		  }
	  default:
		  /* printf("Unknown edge finder in findEdge...\n"); */
		  /* exit(0); */
          return;
	  }
}


/***********************************************************************************
 * Function: EdgeMap
 * Computes an edge map for image. Edge magnitude is returned in EdgeMag and
 * orientation in EdgeOrient.
 **********************************************************************************/
void sv_H263EdgeMap(unsigned char *image, unsigned char *EdgeMag, unsigned char *EdgeOrient,
                    int rows, int cols)
{
	unsigned char *pi, *pe, *po;
	int i, j, ul, u, ur, l, c, r, bl, b, br;

	pi = image;
	pe = EdgeMag;
	po = EdgeOrient;
	/* Clear first line */
	for(j=0; j<cols; j++) {
		*(pe++) = 0;
		*(po++) = 0;
	}
	pi = image + cols;
	for(i=1; i<rows-1; i++) {
		/* Clear first pixel */
		*(pe++) = 0; *(po++) = 0; pi++;

		/* Start gathering 3x3 neighberhood */
		ul = *(pi-cols-1); u = *(pi-cols); 
		l  = *(pi-1);      c = *pi;        
		bl = *(pi+cols-1); b = *(pi+cols); 
		
		/* Compute edge map */
		for(j=1; j<cols-1; j++, pi++, pe++, po++) {

			/* finish neighborhood */
			ur = *(pi-cols+1);
			r = *(pi+1);
			br = *(pi+cols+1);

			findEdge(ul, u, ur, l, c, r, bl, b, br, pe, po, 'S');

			/* start next neigborhood */
			ul = u; u = ur;
			l = c; c = r;
			bl = b; b = br;

		}
		/* Clear last pixel */
		*(pe++) = 0; *(po++) = 0; pi++;
	}
	
	/* Clear last line */
	for(j=0; j<cols; j++) {
		*(pe++) = 0;
		*(po++) = 0;
	}
}

/*******************************************************************************************
 * Function EdgeGrow
 * Thickens the edge map by considering as an edge any pixel which has an edge pixel in a
 * neighborhood of dimensions sr, sc
 ******************************************************************************************/
unsigned char *sv_H263EdgeGrow(unsigned char *Edge, int rows, int cols, int sr, int sc)
{
	unsigned char *pse, *pf, *pe, ed, *Fat;
	int du, db, dl, dr, i, j, k, l, sr2, sc2;

	if (!(Fat = (unsigned char *)ScAlloc(rows*cols))) {
	  /* fprintf(stderr,"malloc failed\n"); */
	  /* exit(-1); */
        return(NULL);
	}

	if (!(sr%2) || !(sc%2)) {
		/* printf("Structuring Element must have odd dimensions\n");
		exit(0); */
        return(NULL);
	}

	sr2 = sr >> 1; sc2 = sc >> 1;

	pe = Edge;
	pf = Fat;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pe++, pf++) {

			du = i>sr2 ? sr2 : i;
			db = (rows-1-i) > sr2 ? sr2 : (rows-1-i);
			dl = j > sc2 ? sc2 : j;
			dr = (cols-1-j) > sc2 ? sc2 : (cols-1-j);

			ed = 0;
			for(k=-du; k<=db; k++) {
			    pse = pe + k * cols - dl;
				for(l=-dl; l<=dr; l++, pse++) {
					if (ed = *pse) break;
				}
				if(ed) break;
			}
			*pf = ed;
		}
	}
	return Fat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\encode.c ===
/* File: sv_h263_encode.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <math.h>
#include "sv_h263.h"
#include "proto.h"
#include "SC_err.h"
#include "SC_conv.h"
#ifndef USE_C
#include "perr.h"
#endif

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _SNR_     1  /* calculate SNR */
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    0  /* warnings about strange behavior */
#define _WRITE_   0  /* write DEBUG.IMG */

#include <stdio.h>
int DEBUGIMG = -1;
#endif /* _SLIBDEBUG_ */

#define NTAPS 5

static void SetDefPrefLevel(SvH263CompressInfo_t *H263Info);
static void SetDefThresh(SvH263CompressInfo_t *H263Info);
static void CheckPrefLevel(SvH263CompressInfo_t *H263Info, int depth) ;
static short sv_H263MBDecode(SvH263CompressInfo_t *H263Info, short *qcoeff,
                             H263_MB_Structure *mb_recon, int QP, int I, int CBP,
							 unsigned dword quality);
static int sv_H263MBEncode(H263_MB_Structure *mb_orig, int QP, int I, int *CBP,
						   short *qcoeff, unsigned dword quality);
static int NextTwoPB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *next2, H263_PictImage *next1,
					 H263_PictImage *prev,
	                 int bskip, int pskip, int seek_dist);
static SvStatus_t sv_H263CodeOneOrTwo(SvCodecInfo_t *Info, int QP, int frameskip,
                           H263_Bits *bits, H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2]);
#ifdef _SNR_
static void ComputeSNR(SvH263CompressInfo_t *H263Info,
	                   H263_PictImage *im1, H263_PictImage *im2,
				       int lines, int pels);
static void PrintResult(SvH263CompressInfo_t *H263Info, H263_Bits *bits, int num_units, int num);
#endif

static SvStatus_t sv_H263WriteExtBitstream(SvH263CompressInfo_t *H263Info,
                                           ScBitstream_t *bs);

// #define GOB_RATE_CONTROL

#ifdef GOB_RATE_CONTROL
void sv_H263GOBInitRateCntrl();
void sv_H263GOBUpdateRateCntrl(int bits);
int sv_H263GOBInitQP(float bit_rate, float target_frame_rate, float QP_mean);
int sv_H263GOBUpdateQP(int mb, float QP_mean, float bit_rate,int mb_width, int mb_height, int bitcount,
					   int NOgob, int *VARgob, int pb_frame) ;
#endif


void sv_H263UpdateQuality(SvCodecInfo_t *Info)
{
  if (Info->mode == SV_H263_ENCODE)
  {
    SvH263CompressInfo_t *H263Info=Info->h263comp;
    unsigned dword imagesize=Info->Width*Info->Height;
    unsigned dword bit_rate=H263Info->bit_rate;
    unsigned dword calc_quality;
    if (H263Info->quality==0) /* no quality setting */
    {
      calc_quality=H263_MAX_CALC_QUALITY;
    }
    else if (bit_rate==0 || imagesize==0) /* variable bitrate */
    {
      /* make the quant settings directly proportional to the quality */
      H263Info->QPI=(((100-H263Info->quality)*31)/100)+1;
      if (H263Info->QPI>31)
        H263Info->QPI=31;
      H263Info->QP_init=H263Info->QPI;
      calc_quality=H263_MAX_CALC_QUALITY;
    }
    else /* fixed bitrate */
    {
      /* Using calc_quality you get:
           bitrate     framerate   imagesize   quality     calc_quality  QPI
           --------    ----------  ----------  -------     ------------  ---
           57400           7        352x288     100%            82        9
           57400          15        352x288     100%            38       22
           13300           7        352x288     100%            19       26
           13300          15        352x288     100%             8       28
           13300           7        176x144     100%            79       10
           13300          15        176x144     100%            36       22
      */
      calc_quality=(bit_rate*H263Info->quality)/(unsigned int)(H263Info->frame_rate*100);
      calc_quality/=imagesize/1024;
      if (calc_quality<H263_MIN_CALC_QUALITY)
        calc_quality=H263_MIN_CALC_QUALITY;
      else if (calc_quality>H263_MAX_CALC_QUALITY)
        calc_quality=H263_MAX_CALC_QUALITY;
      /* make the quant settings directly proportional to the calc_quality */
      if (calc_quality>200)
        H263Info->QPI=1;
      else
      {
        H263Info->QPI=(((200-calc_quality)*31)/200)+1;
        if (H263Info->QPI>31)
          H263Info->QPI=31;
      }
      H263Info->QP=H263Info->QP_init=H263Info->QPI;
    }
    H263Info->calc_quality=calc_quality;
  }
}

static SvStatus_t convert_to_411(SvCodecInfo_t *Info,
                                 u_char *dest_buff, u_char *ImagePtr)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  unsigned long size = (Info->InputFormat.biWidth * Info->InputFormat.biHeight) ;

  if (IsYUV422Packed(Info->InputFormat.biCompression))
  {
    SvStatus_t status;
	/* Input is in NTSC format, convert */
	if ((Info->InputFormat.biWidth == NTSC_WIDTH) &&
		(Info->InputFormat.biHeight == NTSC_HEIGHT))
      status = ScConvertNTSC422toCIF411((unsigned char *)ImagePtr,
                        (unsigned char *)(dest_buff),
                        (unsigned char *)(dest_buff + size),
                        (unsigned char *)(dest_buff + size +(size/4)),
                        (int) Info->InputFormat.biWidth);
	
    else
      status = ScConvert422ToYUV_char_C(ImagePtr,
                        (unsigned char *)(dest_buff),               /* Y */
                        (unsigned char *)(dest_buff+size),          /* U */
                        (unsigned char *)(dest_buff+size+(size/4)), /* V */
                        Info->InputFormat.biWidth,Info->InputFormat.biHeight);
    return(status);
  }
  else if (IsYUV411Sep(Info->InputFormat.biCompression))
  {
    /*
     *  If YUV 12 SEP, Not converting, so just copy data to the luminance
     * and chrominance appropriatelyi
     */
    memcpy(dest_buff, ImagePtr, (H263Info->pels*H263Info->lines*3)/2);
  }
  else if (IsYUV422Sep(Info->InputFormat.biCompression))
  {
    _SlibDebug(_DEBUG_, printf("ScConvert422PlanarTo411()\n") );
    ScConvert422PlanarTo411(ImagePtr,
                         dest_buff, dest_buff+size, (dest_buff+size+(size/4)),
                         Info->Width,Info->Height);
  }
  else
  {
    _SlibDebug(_WARN_, printf("Unsupported Video format\n") );
    return(SvErrorUnrecognizedFormat);
  }
  return(SvErrorNone);
}

/**********************************************************************
 *
 *	Name:		InitImage
 *	Description:	Allocates memory for structure of 4:2:0-image
 *	
 *	Input:	        image size
 *	Returns:	pointer to new structure
 *	Side effects:	memory allocated to structure
 *
 ***********************************************************************/

H263_PictImage *sv_H263InitImage(int size)
{
  H263_PictImage *new;
  unsigned char *image;

  if ((new = (H263_PictImage *)ScAlloc(sizeof(H263_PictImage))) == NULL) {
    svH263Error("Couldn't allocate (PictImage *)\n");
    return(NULL);
  }
  if ((image = (unsigned char *)ScPaMalloc((sizeof(char)*size*3)/2)) == NULL) {
    svH263Error("Couldn't allocate image\n");
    return(NULL);
  }
  new->lum = image;
  new->Cb = image+size;
  new->Cr = image+(size*5)/4;

  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL,"sv_H263InitImage() %p\n", new) );
  return new;
}

/**********************************************************************
 *
 *	Name:		FreeImage
 *	Description:	Frees memory allocated to structure of 4:2:0-image
 *	
 *	Input:		pointer to structure
 *	Returns:
 *	Side effects:	memory of structure freed
 *
 ***********************************************************************/

void sv_H263FreeImage(H263_PictImage *image)

{
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL,"sv_H263FreeImage(%p)\n", image) );
  ScPaFree(image->lum);
  /* ScFree(image->Cr);
  ScPaFree(image->Cb); */
  ScFree(image);
}

/******************************************************************
 * Set the PREF_LEVEL matrix to the default values
 ******************************************************************/
static void SetDefPrefLevel(SvH263CompressInfo_t *H263Info)
{
  int i, j;
  unsigned char H263_DEF_PREF_LEVEL[4][3] = {{0, 0, 1},
					  {0, 1, 1},
					  {0, 1, 2},
					  {0, 2, 2}};
  for(i=0; i<4; i++) {
    for(j=0; j<3; j++) {
      H263Info->PREF_LEVEL[i][j] = H263_DEF_PREF_LEVEL[i][j];
    }
  }
}

/*****************************************************************
 * Set the Threshold vectors to the default values
 *****************************************************************/
static void SetDefThresh(SvH263CompressInfo_t *H263Info)
{
  int i;
  unsigned char H263_DEF_MOTRESH[4]= {0, 2, 4, 7};
  int H263_DEF_PETRESH[3]= {2500, 3500, 6000};

  for(i=0; i<4; i++) {
    H263Info->MOTresh[i] = H263_DEF_MOTRESH[i];
  }
  for(i=0; i<3; i++) {
    H263Info->PETresh[i] = H263_DEF_PETRESH[i];
  }

}

/***********************************************************************
 * Cheks if all the selections in PREF_LEVEL are consistent with depth.
 ***********************************************************************/
static void CheckPrefLevel(SvH263CompressInfo_t *H263Info, int depth)
{
  int i, j;

  for(i=0; i<4; i++) {
    for(j=0; j<3; j++) {
      if (H263Info->PREF_LEVEL[i][j]>depth-1) H263Info->PREF_LEVEL[i][j] = depth-1;
    }
  }
}

static int svH263zeroflush(ScBitstream_t *BSOut)
{
    int bits;

	bits = (int)(ScBSBitPosition(BSOut)%8);
	if(bits) {
		bits = 8-bits;
		ScBSPutBits(BSOut, 0, bits) ;
	}
    return bits;
}


/***************************************************/
/***************************************************/
static SvStatus_t sv_H263Compress(SvCodecInfo_t *Info);
extern int arith_used;

SvStatus_t svH263Compress(SvCodecInfo_t *Info, u_char *ImagePtr)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  ScBitstream_t *BSOut=Info->BSOut;

  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg,"sv_H263Compress() bytepos=%ld\n",
                                          ScBSBytePosition(Info->BSOut)) );

  if (H263Info->frame_no == H263Info->start) /* Encode the first frame */
  {
    sv_H263UpdateQuality(Info); /* in case image size has changed */
    /* Intra image */
    /* svH263ReadImage(H263Info->curr_image, H263Info->start, H263Info->video_file); */
    convert_to_411(Info, H263Info->curr_image->lum, ImagePtr);
    H263Info->pic->picture_coding_type = H263_PCT_INTRA;
    H263Info->pic->QUANT = H263Info->QPI;
    if (H263Info->curr_recon==NULL)
      H263Info->curr_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);

    sv_H263CodeOneIntra(Info, H263Info->curr_image, H263Info->curr_recon, H263Info->QPI,
		                                                H263Info->bits, H263Info->pic);
#ifdef _SNR_
    ComputeSNR(H263Info, H263Info->curr_image, H263Info->curr_recon,
		                                        H263Info->lines, H263Info->pels);
#endif

    if (arith_used)
    {
      H263Info->bits->header += sv_H263AREncoderFlush(H263Info, BSOut);
      arith_used = 0;
    }
    H263Info->bits->header += svH263zeroflush(BSOut); /* pictures shall be byte aligned */

    _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Frame %d = I frame\n", H263Info->frames) );

    sv_H263ZeroRes(H263Info->b_res);
    sv_H263AddBitsPicture(H263Info->bits);
    /* PrintResult(H263Info->bits, 1, 1); */
    memcpy(H263Info->intra_bits,H263Info->bits,sizeof(H263_Bits));
    sv_H263ZeroBits(H263Info->total_bits);
    sv_H263ZeroRes(H263Info->total_res);
    sv_H263ZeroRes(H263Info->res);

    H263Info->buffer_fullness = H263Info->intra_bits->total;

    /* number of seconds to encode */
    H263Info->seconds = (H263Info->end - H263Info->start + H263Info->chosen_frameskip)/H263Info->frame_rate;

    H263Info->first_frameskip = H263Info->chosen_frameskip;
    H263Info->distance_to_next_frame = H263Info->first_frameskip;

    _SlibDebug(_WARN_ && H263Info->first_frameskip>256,
        ScDebugPrintf(H263Info->dbg, "Warning: frameskip > 256\n") );

    H263Info->pic->picture_coding_type = H263_PCT_INTER;

    H263Info->pic->QUANT = H263Info->QP;
    H263Info->bdist = H263Info->chosen_frameskip;

    /* always encode the first frame after intra as P frame.
       This is not necessary, but something we chose to make
       the adaptive PB frames calculations a bit simpler */
    if (H263Info->pb_frames) {
      H263Info->pic->PB = 0;
      H263Info->pdist = 2*H263Info->chosen_frameskip - H263Info->bdist;
    }

	/* point to the 2nd frame */
	H263Info->frame_no = H263Info->start + H263Info->first_frameskip;
    H263Info->frames++;

    if (H263Info->extbitstream)
    {
      SvStatus_t status;
	  status = sv_H263WriteExtBitstream(H263Info, BSOut);
      if (status!=SvErrorNone)
        return(status);
    }

  }
  else
  { /* the rest of frames */
    /***** Main loop *****/

    /* Set QP to pic->QUANT from previous encoded picture */
    H263Info->QP = H263Info->pic->QUANT;

    H263Info->next_frameskip = H263Info->distance_to_next_frame;
    if (!H263Info->pb_frames)
    {
      H263_PictImage *tmpimage;
      _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Frame %d = P frame\n", H263Info->frames) );
      if (H263Info->prev_image==NULL)
        H263Info->prev_image = sv_H263InitImage(H263Info->pels*H263Info->lines);
      /* swap current and prev images */
      tmpimage=H263Info->prev_image;
      H263Info->prev_image = H263Info->curr_image;
      H263Info->curr_image = tmpimage;
      /* swap recon images */
      if (H263Info->prev_recon==NULL)
        H263Info->prev_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);
      if (H263Info->curr_recon==NULL)
        H263Info->curr_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);
      tmpimage=H263Info->curr_recon;
      H263Info->curr_recon = H263Info->prev_recon;
      H263Info->prev_recon = tmpimage;
      convert_to_411(Info, H263Info->curr_image->lum, ImagePtr);
      H263Info->frames++;
      H263Info->next_frameskip = H263Info->pdist;
      return(sv_H263Compress(Info)); /* Encode P */
    }
    else if ((H263Info->frames%2)==1) /* this is a B frame */
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Frame %d = B frame\n", H263Info->frames) );
      H263Info->PPFlag = 0;
      H263Info->bdist = H263Info->chosen_frameskip;
      H263Info->pdist = 2*H263Info->chosen_frameskip - H263Info->bdist;
      H263Info->pic->TRB = (int)(H263Info->bdist * H263Info->orig_frameskip);
      _SlibDebug(_WARN_ && H263Info->pic->TRB>8,
         ScDebugPrintf(H263Info->dbg, "distance too large for B-frame\n") );
      /* Read the frame to be coded as B */
      if (H263Info->B_image==NULL)
        H263Info->B_image = sv_H263InitImage(H263Info->pels*H263Info->lines);
      if (H263Info->B_recon==NULL)
        H263Info->B_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);

      /* svH263ReadImage(H263Info->B_image,H263Info->frame_no - H263Info->pdist,H263Info->video_file); */
      convert_to_411(Info, H263Info->B_image->lum, ImagePtr);

      H263Info->first_loop_finished = 1;
      H263Info->pic->PB = 1;
      H263Info->frames++;
      /* need to reorder P+B frames - HWG */
      /* return now, we'll get the B frame on the next Compress call */
      return(SvErrorNone);
    }
    else /* this is a P frame of a PB or PP pair */
    {
      H263_PictImage *tmpimage;
      _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Frame %d = P frame\n", H263Info->frames) );
      if (H263Info->prev_image==NULL)
        H263Info->prev_image = sv_H263InitImage(H263Info->pels*H263Info->lines);
      /* swap current and prev images */
      tmpimage=H263Info->prev_image;
      H263Info->prev_image = H263Info->curr_image;
      H263Info->curr_image = tmpimage;
      /* swap recon images */
      if (H263Info->prev_recon==NULL)
        H263Info->prev_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);
      if (H263Info->curr_recon==NULL)
        H263Info->curr_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);
      tmpimage=H263Info->curr_recon;
      H263Info->curr_recon = H263Info->prev_recon;
      H263Info->prev_recon = tmpimage;

      /* svH263ReadImage(H263Info->curr_image, H263Info->frame_no, H263Info->video_file); */
      convert_to_411(Info, H263Info->curr_image->lum, ImagePtr);
      if (H263Info->pic->TRB > 8 || !NextTwoPB(H263Info, H263Info->curr_image,
                                     H263Info->B_image, H263Info->prev_image,
                                     H263Info->bdist, H263Info->pdist, H263Info->pic->seek_dist))
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Encode PP\n") );
        H263Info->PPFlag = 1;
        /* curr_image and B_image were not suitable to be coded
	         as a PB-frame - encoding as two P-frames instead */
        H263Info->pic->PB = 0;
        H263Info->next_frameskip = H263Info->bdist;

        /* swap B and current images - B_image gets encoded first as P frame */
        tmpimage = H263Info->curr_image;
        H263Info->curr_image = H263Info->B_image;
        H263Info->B_image = tmpimage;
        sv_H263Compress(Info); /* Encode first P */
        H263Info->next_frameskip = H263Info->pdist;

        /* swap current and prev images */
        tmpimage=H263Info->prev_image;
        H263Info->prev_image = H263Info->curr_image;
        H263Info->curr_image = tmpimage;
        /* swap current and B images */
        tmpimage=H263Info->B_image;
        H263Info->B_image = H263Info->curr_image;
        H263Info->curr_image = tmpimage;
        /* swap recon images */
        tmpimage=H263Info->curr_recon;
        H263Info->curr_recon = H263Info->prev_recon;
        H263Info->prev_recon = tmpimage;

        sv_H263Compress(Info); /* Encode second P */
        H263Info->frames++;
        H263Info->PPFlag = 0;
      }
      else
      {
        H263Info->pic->PB=1;
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Encode PB\n") );
        H263Info->frames++;
        return(sv_H263Compress(Info)); /* Encode PB */
      }
    }
  }  /* the rest of frames */
  return(SvErrorNone);
}

static SvStatus_t sv_H263Compress(SvCodecInfo_t *Info)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  ScBitstream_t *BSOut=Info->BSOut;

    H263Info->bframes += (H263Info->pic->PB ? 1 : 0);
    H263Info->pframes++;
    /* Temporal Reference is the distance between encoded frames compared
       the reference picture rate which is 25.0 or 30 fps */
    if (H263Info->next_frameskip*H263Info->orig_frameskip > 256)
      svH263Error("Warning: frameskip > 256\n");
/*    pic->TR += ((H263Info->next_frameskip*(int)H263Info->orig_frameskip) % 256);  */
    H263Info->pic->TR = ((int) ( (int)((float)(H263Info->frame_no-H263Info->start)*H263Info->orig_frameskip) ) % 256);

    if (H263Info->pic->PB) { /* Code two frames as a PB-frame */

      if (H263Info->vsnr && H263Info->B_recon==NULL)
        H263Info->B_recon = sv_H263InitImage(H263Info->pels*H263Info->lines);
/*
      fprintf(stdout,"Coding PB frames %d and %d... ",
	      H263Info->frame_no - H263Info->pdist, H263Info->frame_no);
*/
#if 0
      if(H263Info->prefilter) {
	    if(H263Info->StaticPref)
	      H263Info->B_clean = svH263AdaptClean(H263Info->B_image, H263Info->lines, H263Info->pels, -1, -1);
	    else H263Info->B_clean = H263Info->B_image;

	    if(H263Info->PrefPyrType == H263_GAUSS)
	      H263Info->B_filtd = svH263GaussLayers(H263Info->B_clean, H263_PYR_DEPTH, H263Info->lines, H263Info->pels, NTAPS);
	    else if(H263Info->PrefPyrType == H263_MORPH)
	      H263Info->B_filtd = svH263MorphLayers(H263Info->B_clean, H263_PYR_DEPTH, H263Info->lines, H263Info->pels, 2);

	    if(H263Info->StaticPref) sv_H263FreeImage(H263Info->B_clean);
      }

      fflush(stdout);
#endif
    }
    else { /* Code the next frame as a normal P-frame */
      /* fprintf(stdout,"Coding P frame %d... ", H263Info->frame_no); */
      /* fflush(stdout); */
    }
    /* if (H263Info->curr_recon==NULL)
      H263Info->curr_recon = sv_H263InitImage(H263Info->pels*H263Info->lines); HWG */

    /* changed by Nuno on 06/27/96 to support prefiltering */
#if 0
    if(H263Info->prefilter) {
      int m;

      if(H263Info->StaticPref)
	       H263Info->curr_clean = svH263AdaptClean(H263Info->curr_image, H263Info->lines, H263Info->pels, -1, -1);
      else H263Info->curr_clean = H263Info->curr_image;

      if(H263Info->PrefPyrType == H263_GAUSS)
	H263Info->curr_filtd = svH263GaussLayers(H263Info->curr_clean, H263_PYR_DEPTH, H263Info->lines, H263Info->pels, NTAPS);
      else if(H263Info->PrefPyrType == H263_MORPH)
	H263Info->curr_filtd = svH263MorphLayers(H263Info->curr_clean, H263_PYR_DEPTH, H263Info->lines, H263Info->pels, 2);
		
      if(H263Info->StaticPref) sv_H263FreeImage(H263Info->curr_clean);

      PreFilterLevel = (unsigned char **) ScAlloc(H263Info->lines/H263_MB_SIZE*sizeof(char *));
      for(m=0; m<H263Info->mb_height; m++)
	     PreFilterLevel[m]= (unsigned char *) ScAlloc(H263Info->pels/H263_MB_SIZE);
    }
#endif

    sv_H263CodeOneOrTwo(Info, H263Info->QP,
         (int)(H263Info->next_frameskip*H263Info->orig_frameskip),
		 H263Info->bits, H263Info->MV);

#if 0
    if(H263Info->prefilter) {
      int i, j;

      fprintf(stdout, "Prefiltering level matrix\n");
      for(i=0; i<H263Info->mb_height; i++) {
	    for(j=0; j<H263Info->mb_width; j++) {
	      fprintf(stdout,"%4d ", PreFilterLevel[i][j]);
	    }
	    fprintf(stdout,"\n");
      }
    }
#endif

    /* fprintf(stdout,"done\n"); */
    _SlibDebug(_VERBOSE_ && H263Info->bit_rate != 0,
                  ScDebugPrintf(H263Info->dbg, "Inter QP: %d\n", H263Info->QP) );
    /* fflush(stdout); */

    if (arith_used) {
      H263Info->bits->header += sv_H263AREncoderFlush(H263Info, BSOut);
      arith_used = 0;
    }
    H263Info->bits->header += svH263zeroflush(BSOut);  /* pictures shall be byte aligned */

    sv_H263AddBitsPicture(H263Info->bits);
    sv_H263AddBits(H263Info->total_bits, H263Info->bits);


#ifdef GOB_RATE_CONTROL
    if (H263Info->bit_rate != 0) {
      sv_H263GOBUpdateRateCntrl(H263Info->bits->total);
    }
#else
    /* Aim for the H263_targetrate with a once per frame rate control scheme */
    if (H263Info->bit_rate != 0 &&
        H263Info->frame_no - H263Info->start >
              (H263Info->end - H263Info->start) * H263Info->start_rate_control/100.0)
    {
	  /* when generating the MPEG-4 anchors, rate control was started
	     after 70% of the sequence was finished.
	     Set H263Info->start_rate_control with option "-R <n>" */

      H263Info->buffer_fullness += H263Info->bits->total;
      H263Info->buffer_frames_stored = H263Info->frame_no;

	  H263Info->pic->QUANT = sv_H263FrameUpdateQP(H263Info->buffer_fullness,
				   H263Info->bits->total / (H263Info->pic->PB?2:1),
				   (H263Info->end-H263Info->buffer_frames_stored) / H263Info->chosen_frameskip
				                 + H263Info->PPFlag,
				   H263Info->QP, H263Info->bit_rate, H263Info->seconds);
    }
#endif

    if (H263Info->pic->PB)
    {
#ifdef _SNR_
      if (H263Info->B_recon)
        ComputeSNR(H263Info, H263Info->B_image, H263Info->B_recon,
		                                        H263Info->lines, H263Info->pels);
#endif

  /*  fprintf(stdout,"Results for B-frame:\n");*/
      /* sv_H263FreeImage(H263Info->B_image); HWG */
    }

#if 0
    if(H263Info->prefilter) ScFree(H263Info->B_filtd);
#endif

    H263Info->distance_to_next_frame = (H263Info->PPFlag ? H263Info->pdist :
			      (H263Info->pb_frames ? 2*H263Info->chosen_frameskip:
			       H263Info->chosen_frameskip));

    /* if (H263Info->pb_frames) H263Info->pic->PB = 1; */

    /*  fprintf(stdout,"Results for P-frame:\n"); */
#ifdef _SNR_
    ComputeSNR(H263Info, H263Info->curr_image, H263Info->curr_recon,
		                                        H263Info->lines, H263Info->pels);
#endif

    /* PrintResult(H263Info->bits, 1, 1); */
    /*
    sv_H263FreeImage(H263Info->prev_image);
    H263Info->prev_image=NULL;
    sv_H263FreeImage(H263Info->prev_recon);
    H263Info->prev_recon=NULL; HWG */

#if 0
    if(H263Info->prefilter) {
      int d;

      for(d=0; d<H263_PYR_DEPTH; d++) sv_H263FreeImage(H263Info->curr_filtd[d]);
      ScFree(H263Info->curr_filtd);
      for(d=0; d<H263Info->mb_height; d++) ScFree(PreFilterLevel[d]);
      ScFree(PreFilterLevel);
    }
#endif

  if (H263Info->extbitstream)
  {
    SvStatus_t status;

	status = sv_H263WriteExtBitstream(H263Info, BSOut);
    if (status!=SvErrorNone)
      return(status);
  }

  /* point to next frame */
  H263Info->frame_no += H263Info->distance_to_next_frame;
  if (H263Info->frame_no>=H263Info->end) /* send an I frame */
    return(sv_H263RefreshCompressor(Info));
  return(SvErrorNone);
}


/*
** Purpose:  Writes the RTP payload info out to the stream.
*/
static SvStatus_t sv_H263WriteExtBitstream(SvH263CompressInfo_t *H263Info,
                                           ScBitstream_t *bs)
{
  ScBSPosition_t pic_stop_position;
  int i;
  SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
  /* use this macro to byte reverse words */
#define PutBits32(BS, a)  ScBSPutBits(BS, (a) & 0xff, 8);  \
                          ScBSPutBits(BS, (a>>8)&0xff, 8); \
                          ScBSPutBits(BS, (a>>16)&0xff, 8); \
                          ScBSPutBits(BS, (a>>24)&0xff, 8);

  pic_stop_position=ScBSBitPosition(bs);
  /* round compressed size up to whole byte */
  RTPInfo->trailer.dwCompressedSize=(dword)(((pic_stop_position-RTPInfo->pic_start_position)+7)/8);
  /* Need to bitstuff here to make sure that these structures are DWORD aligned */
  if ((pic_stop_position%32)!=0)
    ScBSPutBits(bs, 0, 32-(unsigned int)(pic_stop_position % 32));  /* align on a DWORD boundary */
  for (i = 0; i < (int)H263Info->RTPInfo->trailer.dwNumberOfPackets; i++)
  {
	ScBSPutBits(bs,0,32) ; /* Flags = 0 */
    PutBits32(bs,RTPInfo->bsinfo[i].dwBitOffset);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].Mode,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].MBA,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].Quant,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].GOBN,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].HMV1,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].VMV1,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].HMV2,8);
    ScBSPutBits(bs,RTPInfo->bsinfo[i].VMV2,8);
  }
  /* write RTP extension trailer */
  PutBits32(bs, RTPInfo->trailer.dwVersion);
  PutBits32(bs, RTPInfo->trailer.dwFlags);
  PutBits32(bs, RTPInfo->trailer.dwUniqueCode);
  PutBits32(bs, RTPInfo->trailer.dwCompressedSize);
  PutBits32(bs, RTPInfo->trailer.dwNumberOfPackets);

  ScBSPutBits(bs, RTPInfo->trailer.SourceFormat, 8);
  ScBSPutBits(bs, RTPInfo->trailer.TR, 8);
  ScBSPutBits(bs, RTPInfo->trailer.TRB, 8);
  ScBSPutBits(bs, RTPInfo->trailer.DBQ, 8);

  return (NoErrors);
}

/***************************************************/
                           /*
                        int start, int end, int source_format, int frameskip,
						int ME_method, int headerlength, char *seqfilename,
						int QP, int QPI, char *streamname, int unrestricted,
						int sac, int advanced, int pb_frame, int bit_rate)
                        */
/***************************************************/
SvStatus_t svH263InitCompressor(SvCodecInfo_t *Info)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  int i,j,k;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263InitCompressor()") );
  if (H263Info->inited)
    return(SvErrorNone);

  if (Info->Width==SQCIF_WIDTH && Info->Height==SQCIF_HEIGHT)
    H263Info->source_format=H263_SF_SQCIF;
  else if (Info->Width==QCIF_WIDTH && Info->Height==QCIF_HEIGHT)
    H263Info->source_format=H263_SF_QCIF;
  else if (Info->Width==CIF_WIDTH && Info->Height==CIF_HEIGHT)
    H263Info->source_format=H263_SF_CIF;
  else if (Info->Width==CIF4_WIDTH && Info->Height==CIF4_HEIGHT)
    H263Info->source_format=H263_SF_4CIF;
  else if (Info->Width==CIF16_WIDTH && Info->Height==CIF16_HEIGHT)
    H263Info->source_format=H263_SF_16CIF;
  else
  {
    _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "sv_H263InitCompressor() Illegal input format\n") );
    return(SvErrorUnrecognizedFormat);
  }
  /* start and stop frame numbers under to calculate rate control;
   * a more advanced rate control is still needed
   */
  H263Info->start = 0;

  H263Info->pdist = H263Info->bdist = 1;
  H263Info->first_loop_finished=0;
  H263Info->PPFlag = 0;

  H263Info->pic = (H263_Pict *)ScAlloc(sizeof(H263_Pict));
  H263Info->bits = (H263_Bits *)ScAlloc(sizeof(H263_Bits));
  H263Info->total_bits = (H263_Bits *)ScAlloc(sizeof(H263_Bits));
  H263Info->intra_bits = (H263_Bits *)ScAlloc(sizeof(H263_Bits));
  H263Info->res = (H263_Results *)ScAlloc(sizeof(H263_Results));
  H263Info->total_res = (H263_Results *)ScAlloc(sizeof(H263_Results));
  H263Info->b_res = (H263_Results *)ScAlloc(sizeof(H263_Results));

  /* woring buffers */
  H263Info->wk_buffers = ScAlloc(sizeof(H263_WORKING_BUFFER));

/*
  fprintf(stdout,"\nH.263 coder (TMN)\n");
  fprintf(stdout,"(C) Digital Equipment Corp.\n");
*/
  H263Info->headerlength = H263_DEF_HEADERLENGTH;

  H263Info->refidct = 0;

  /* Initalize VLC_tables */
  sv_H263InitHuff(H263Info);

  /* allocate buffer for FAST search */
  H263Info->block_subs2    = (unsigned char *)ScAlloc(sizeof(char)*64);
  H263Info->srch_area_subs2=
	    (unsigned char *)ScAlloc(sizeof(char)*H263_SRCH_RANGE*H263_SRCH_RANGE);

  if (H263Info->unrestricted){
	/* note that the Unrestricted Motion Vector mode turns on
	   both long_vectors and mv_outside_frame */
	H263Info->pic->unrestricted_mv_mode = H263Info->unrestricted;
	H263Info->mv_outside_frame = H263_ON;
	H263Info->long_vectors = H263_ON;
  }
  if (H263Info->advanced)
	H263Info->mv_outside_frame = H263_ON;


  /* H263Info->ME_method = ME_method; --- gets set in sv_api.c */
  H263Info->HPME_method = H263_DEF_HPME_METHOD;
  H263Info->DCT_method = H263_DEF_DCT_METHOD;
  H263Info->vsnr = H263_DEF_VSNR;

#if 0
  /*** prefilter ***/
  H263Info->prefilter = H263_NO;
  H263Info->PYR_DEPTH = H263_DEF_PYR_DEPTH;
  H263Info->PrefPyrType = H263_DEF_PREF_PYR_TYPE;
  H263Info->StaticPref = H263_DEF_STAT_PREF_STATE;
#endif

  SetDefPrefLevel(H263Info);
  SetDefThresh(H263Info);

  /* BQUANT parameter for PB-frame coding
  *   (n * QP / 4 )
  *
  *  BQUANT  n
  *   0      5
  *   1      6
  *   2      7
  *   3      8
  */
  H263Info->pic->BQUANT = 2;
  if (H263Info->frame_rate<=1.0F) /* frame_rate not yet initialized */
    H263Info->frame_rate = 30.0F;
  H263Info->ref_frame_rate = H263Info->frame_rate;
  H263Info->orig_frame_rate = H263Info->frame_rate;
  /* default skipped frames between encoded frames (P or B) */
  /* reference is original sequence */
  /* 3 means 8.33/10.0 fps encoded frame rate with 25.0/30.0 fps original */
  /* 1 means 8.33/10.0 fps encoded frame rate with 8.33/10.0 fps original */
  H263Info->chosen_frameskip = 1;
  /* default number of skipped frames in original sequence compared to */
  /* the reference picture rate ( also option "-O <n>" ) */
  /* 4 means that the original sequence is grabbed at 6.25/7.5 Hz */
  /* 1 means that the original sequence is grabbed at 25.0/30.0 Hz */
  H263Info->orig_frameskip = 1.0F;
  H263Info->start_rate_control = 0;


  H263Info->trace = H263_DEF_WRITE_TRACE;
  H263Info->pic->seek_dist = H263_DEF_SEEK_DIST;
  H263Info->pic->use_gobsync = H263_DEF_INSERT_SYNC;

  /* define GOB sync */
  H263Info->pic->use_gobsync = 1;

  /* H263Info->bit_rate = bit_rate;  --- gets set in sv_api.c */
  /* default is variable bit rate (fixed quantizer) will be used */

  H263Info->frames = 0;
  H263Info->pframes = 0;
  H263Info->bframes = 0;
  H263Info->total_frames_passed = 0;
  H263Info->pic->PB = 0;

  H263Info->pic->TR = 0;
  H263Info->QP = H263Info->QP_init;

  H263Info->pic->QP_mean = (float)0.0;

  _SlibDebug(_WARN_ && (H263Info->QP == 0 || H263Info->QPI == 0),
      ScDebugPrintf(H263Info->dbg, "Warning: QP is zero. Bitstream will not be correctly decodable\n") );

  _SlibDebug(_WARN_ && (H263Info->ref_frame_rate != 25.0 && H263Info->ref_frame_rate != 30.0),
      ScDebugPrintf(H263Info->dbg, "Warning: Reference frame rate should be 25 or 30 fps\n") );

  H263Info->pic->source_format = H263Info->source_format;
  H263Info->pels = Info->Width;
  H263Info->lines = Info->Height;

  H263Info->PYR_DEPTH = H263Info->PYR_DEPTH>0 ? H263Info->PYR_DEPTH : 1;
  H263Info->PYR_DEPTH = H263Info->PYR_DEPTH<=H263_MAX_PYR_DEPTH ? H263Info->PYR_DEPTH : H263_MAX_PYR_DEPTH;
  CheckPrefLevel(H263Info, H263Info->PYR_DEPTH);

  H263Info->cpels = H263Info->pels/2;
  H263Info->mb_width = H263Info->pels / H263_MB_SIZE;
  H263Info->mb_height = H263Info->lines / H263_MB_SIZE;

  H263Info->orig_frameskip = H263Info->ref_frame_rate / H263Info->orig_frame_rate;

  H263Info->frame_rate =  H263Info->ref_frame_rate / (float)(H263Info->orig_frameskip * H263Info->chosen_frameskip);

  _SlibDebug(_VERBOSE_,
      ScDebugPrintf(H263Info->dbg, "Encoding frame rate  : %.2f\n", H263Info->frame_rate);
      ScDebugPrintf(H263Info->dbg, "Reference frame rate : %.2f\n", H263Info->ref_frame_rate);
      ScDebugPrintf(H263Info->dbg, "Orig. seq. frame rate: %.2f\n\n",
	           H263Info->ref_frame_rate / (float)H263Info->orig_frameskip) );

  if (H263Info->refidct) sv_H263init_idctref();

  /* Open stream for writing */
  /* svH263mwopen(H263Info->streamname);  */

#if 0
  /* open video sequence */
  if ((H263Info->video_file = fopen(seqfilename,"rb")) == NULL) {
    fprintf(stderr,"Unable to open image_file: %s\n",seqfilename);
    exit(-1);
  }
  svH263RemovHead(H263Info->headerlength,start,H263Info->video_file);
#endif

  /* for Motion Estimation */
  for (j = 0; j < H263Info->mb_height+1; j++)
    for (i = 0; i < H263Info->mb_width+2; i++)
      for (k = 0; k < 6; k++)
	    H263Info->MV[k][j][i] = (H263_MotionVector *)ScAlloc(sizeof(H263_MotionVector));

  /* for Interpolation */
  if (H263Info->mv_outside_frame) {
    if (H263Info->long_vectors)
      H263Info->wk_buffers->ipol_image=(unsigned char *)ScAlloc(sizeof(char)*(H263Info->pels+64)*(H263Info->lines+64)*4);
	else
      H263Info->wk_buffers->ipol_image=(unsigned char *)ScAlloc(sizeof(char)*(H263Info->pels+32)*(H263Info->lines+32)*4);
  }
  else
    H263Info->wk_buffers->ipol_image  =(unsigned char *)ScAlloc(sizeof(char)*H263Info->pels*H263Info->lines*4);

  if ((H263Info->wk_buffers->qcoeff_P=(short *)ScAlloc(sizeof(short)*384)) == 0)
    return(SvErrorMemory);
  /* allocate buffers for curr_image */
  H263Info->curr_image = sv_H263InitImage(H263Info->pels*H263Info->lines);
  if (H263Info->curr_image==NULL)
    return(SvErrorMemory);
  /* Point to the first frame to be coded */
  H263Info->frame_no = H263Info->start;
  /* initialization done */
  H263Info->inited = TRUE;

  H263Info->buffer_fullness = 0;
  H263Info->buffer_frames_stored = 0;

  if (H263Info->extbitstream)
  {
    H263Info->RTPInfo = (SvH263RTPInfo_t *) ScAlloc(sizeof(SvH263RTPInfo_t));
    if (H263Info->RTPInfo==NULL)
      return(SvErrorMemory);
    memset(H263Info->RTPInfo, 0, sizeof(SvH263RTPInfo_t)) ;
  }

#ifdef GOB_RATE_CONTROL
  sv_H263GOBInitRateCntrl();
#endif

  return(SvErrorNone);
}

/***************************************************/
/***************************************************/

SvStatus_t sv_H263RefreshCompressor(SvCodecInfo_t *Info)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "Refresh Compressor()") );
  if (!H263Info->inited)
    return(SvErrorNone);

  H263Info->pdist = H263Info->bdist = 1;
  H263Info->first_loop_finished=0;
  H263Info->PPFlag = 0;

  H263Info->pic->BQUANT = 2;

  H263Info->frames = 0;
  H263Info->pframes = 0;
  H263Info->bframes = 0;
  H263Info->total_frames_passed = 0;
  H263Info->pic->PB = 0;

  H263Info->pic->TR = 0;
  H263Info->QP = H263Info->QP_init;
  H263Info->pic->QP_mean = (float)0.0;

  /* Point to the first frame to be coded */
  H263Info->frame_no = H263Info->start;
  /* initialization done */
  H263Info->inited = TRUE;

  H263Info->buffer_fullness = 0;
  H263Info->buffer_frames_stored = 0;
  /* next frame will be key so we can reset bit positions */
  ScBSResetCounters(Info->BSOut);

  return(SvErrorNone);
}


/***************************************************/
/***************************************************/

void svH263FreeCompressor(SvCodecInfo_t *Info)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  int i,j,k;

  _SlibDebug(_WRITE_, ScFileClose(DEBUGIMG) );

  if (H263Info->inited)
  {
    /* Free memory */
    for (j = 0; j < H263Info->mb_height+1; j++)
      for (i = 0; i < H263Info->mb_width+2; i++)
        for (k = 0; k < 6; k++)
	      ScFree(H263Info->MV[k][j][i]);

    if (H263Info->block_subs2)
      ScFree(H263Info->block_subs2);
    if (H263Info->srch_area_subs2)
      ScFree(H263Info->srch_area_subs2);
    ScFree(H263Info->wk_buffers->qcoeff_P);
    ScFree(H263Info->wk_buffers->ipol_image);
    ScFree(H263Info->wk_buffers);
    if (H263Info->curr_recon==H263Info->prev_recon ||
        H263Info->curr_recon==H263Info->B_recon)
      H263Info->curr_recon=NULL;
    if (H263Info->prev_recon==H263Info->B_recon)
      H263Info->prev_recon=NULL;
    if (H263Info->curr_image==H263Info->prev_image ||
        H263Info->curr_image==H263Info->B_image)
      H263Info->curr_image=NULL;
    if (H263Info->prev_image==H263Info->B_image)
      H263Info->prev_image=NULL;
    if (H263Info->curr_recon)
    {
      sv_H263FreeImage(H263Info->curr_recon);
      H263Info->curr_recon=NULL;
    }
    if (H263Info->curr_image)
    {
      sv_H263FreeImage(H263Info->curr_image);
      H263Info->curr_image=NULL;
    }
    if (H263Info->prev_recon)
    {
      sv_H263FreeImage(H263Info->prev_recon);
      H263Info->prev_recon=NULL;
    }
    if (H263Info->prev_image)
    {
      sv_H263FreeImage(H263Info->prev_image);
      H263Info->prev_image=NULL;
    }
    if (H263Info->B_image)
    {
      sv_H263FreeImage(H263Info->B_image);
      H263Info->B_image=NULL;
    }
    if (H263Info->B_recon)
    {
      sv_H263FreeImage(H263Info->B_recon);
      H263Info->B_recon=NULL;
    }

    sv_H263FreeHuff(H263Info);

    ScFree(H263Info->bits);
    ScFree(H263Info->total_bits);
    ScFree(H263Info->intra_bits);
    ScFree(H263Info->res);
    ScFree(H263Info->total_res);
    ScFree(H263Info->b_res);
    ScFree(H263Info->pic);
    H263Info->inited=FALSE;

    if (H263Info->RTPInfo)
      ScFree(H263Info->RTPInfo);
  }
  return;
}

/**********************************************************************
 *
 *	Name:		NextTwoPB
 *	Description:    Decides whether or not to code the next
 *                      two images as PB
 *      Speed:          This is not a very smart solution considering
 *                      the encoding speed, since motion vectors
 *                      have to be calculation several times. It
 *                      can be done together with the normal
 *                      motion vector search, or a tree search
 *                      instead of a full search can be used.
 *	
 *	Input:	        pointers to previous image, potential B-
 *                      and P-image, frame distances
 *	Returns:        1 for yes, 0 otherwise
 *	Side effects:
 *
 ***********************************************************************/
/* static int NextTwoPB(PictImage *next2, PictImage *next1, PictImage *prev,
	       int bskip, int pskip, int seek_dist) */


static int NextTwoPB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *next2, H263_PictImage *next1, H263_PictImage *prev,
                     int bskip, int pskip, int seek_dist)
{
  int adv_is_on = 0, mof_is_on = 0, lv_is_on = 0;
  int psad1, psad2, bsad, psad;
  int x,y,i,j,tmp;
  int ne2_pr_x, ne2_pr_y, mvbf_x, mvbf_y, mvbb_x, mvbb_y;

  short MVx, MVy, MVer;

  /* Temporarily disable some options to simplify motion estimation */
  if (H263Info->advanced) {
    H263Info->advanced = H263_OFF;
    adv_is_on = H263_ON;
  }
  if (H263Info->mv_outside_frame) {
    H263Info->mv_outside_frame = H263_OFF;
    mof_is_on = H263_ON;
  }
  if (H263Info->long_vectors) {
    H263Info->long_vectors = H263_OFF;
    lv_is_on = H263_ON;
  }

  bsad = psad = psad1 = psad2 = 0;

  /* Integer motion estimation */
  for ( j = 1; j < H263Info->mb_height - 1; j++) {
    for ( i = 1; i < H263Info->mb_width - 1 ; i++) {
      x = i*H263_MB_SIZE;
      y = j*H263_MB_SIZE;

      /* picture order: prev -> next1 -> next2 */
      /* next1 and next2 can be coded as PB or PP */
      /* prev is the previous encoded picture */

      /* computes vectors (prev <- next2) */
#if 1
     /* faster estimation */
      sv_H263FastME(H263Info, next2->lum,prev->lum,x,y,0,0,seek_dist,
		                                         &MVx,&MVy,&MVer,&tmp);
#else
      svH263MotionEstimation(next2->lum,prev->lum,x,y,0,0,seek_dist,MV,&tmp);
#endif
      /* not necessary to prefer zero vector here */
      if (MVx == 0 && MVy == 0){
         psad    += (MVer + H263_PREF_NULL_VEC) ;
		 ne2_pr_x = ne2_pr_y = 0;
	  }
	  else{
	     psad    += MVer ;
		 ne2_pr_x = MVx;
		 ne2_pr_y = MVy;
	  }

      /* computes sad(prev <- next1) */
#if 1
     /* faster estimation */
      sv_H263FastME(H263Info, next1->lum,prev->lum,x,y,0,0,seek_dist,
		                                             &MVx,&MVy,&MVer,&tmp);
#else
      svH263MotionEstimation(next1->lum,prev->lum,x,y,0,0,seek_dist,MV,&tmp);
#endif
      if (MVx == 0 && MVy == 0)
	    psad2 += (MVer + H263_PREF_NULL_VEC);
      else
        psad2 += MVer;


      /* computes vectors for (next1 <- next2) */
#if 1
     /* faster estimation */
      sv_H263FastME(H263Info, next2->lum,next1->lum,x,y,0,0,seek_dist,
		                                             &MVx,&MVy,&MVer,&tmp);
#else
      svH263MotionEstimation(next2->lum,next1->lum,x,y,0,0,seek_dist,MV,&tmp);
#endif
      if (MVx == 0 && MVy == 0)
	    psad1 += (MVer + H263_PREF_NULL_VEC);
	  else
	    psad1 += MVer ;

      /* scales vectors for (prev <- next2 ) */
      mvbf_x =   bskip * ne2_pr_x / (bskip + pskip);
      mvbb_x = - pskip * ne2_pr_x / (bskip + pskip);
      mvbf_y =   bskip * ne2_pr_y / (bskip + pskip);
      mvbb_y = - pskip * ne2_pr_y / (bskip + pskip);

      /* computes sad(prev <- next1 -> next2) */
#ifndef USE_C
      bsad += sv_H263BError16x16_S(next1->lum + x + y*H263Info->pels,
			   next2->lum + x + mvbb_x + (y + mvbb_y)*H263Info->pels,
			   prev->lum  + x + mvbf_x + (y + mvbf_y)*H263Info->pels,
			   H263Info->pels);
#else
      bsad += sv_H263BError16x16_C(next1->lum + x + y*H263Info->pels,
			   next2->lum + x + mvbb_x + (y + mvbb_y)*H263Info->pels,
			   prev->lum  + x + mvbf_x + (y + mvbf_y)*H263Info->pels,
			   H263Info->pels, INT_MAX);
#endif
    }
  }

  /* restore advanced parameters */
  H263Info->advanced = adv_is_on;
  H263Info->mv_outside_frame = mof_is_on;
  H263Info->long_vectors = lv_is_on;

  /* do the decision */
  if (bsad < (psad1+psad2)/2) {
/*
    fprintf(stdout,"Chose PB - bsad %d, psad %d\n", bsad, (psad1+psad2)/2);
*/
	return 1;
  }
  else {
/*
    fprintf(stdout,"Chose PP  - bsad %d, psad %d\n", bsad, (psad1+psad2)/2);
*/
	return 0;
  }
}

#ifdef _SLIBDEBUG_
/**********************************************************************
 *
 *	Name:		PrintResult
 *	Description:	add bits and prints results
 *	
 *	Input:		Bits struct
 *			
 *	Returns:	
 *	Side effects:	
 *
 ***********************************************************************/

 void PrintResult(SvH263CompressInfo_t *H263Info, H263_Bits *bits,
				                                   int num_units, int num)
{
  ScDebugPrintf(H263Info->dbg,"# intra   : %d\n", bits->no_intra/num_units);
  ScDebugPrintf(H263Info->dbg,"# inter   : %d\n", bits->no_inter/num_units);
  ScDebugPrintf(H263Info->dbg,"# inter4v : %d\n", bits->no_inter4v/num_units);
  ScDebugPrintf(H263Info->dbg,"--------------\n");
  ScDebugPrintf(H263Info->dbg,"Coeff_Y: %d\n", bits->Y/num);
  ScDebugPrintf(H263Info->dbg,"Coeff_C: %d\n", bits->C/num);
  ScDebugPrintf(H263Info->dbg,"Vectors: %d\n", bits->vec/num);
  ScDebugPrintf(H263Info->dbg,"CBPY   : %d\n", bits->CBPY/num);
  ScDebugPrintf(H263Info->dbg,"MCBPC  : %d\n", bits->CBPCM/num);
  ScDebugPrintf(H263Info->dbg,"MODB   : %d\n", bits->MODB/num);
  ScDebugPrintf(H263Info->dbg,"CBPB   : %d\n", bits->CBPB/num);
  ScDebugPrintf(H263Info->dbg,"COD    : %d\n", bits->COD/num);
  ScDebugPrintf(H263Info->dbg,"DQUANT : %d\n", bits->DQUANT/num);
  ScDebugPrintf(H263Info->dbg,"header : %d\n", bits->header/num);
  ScDebugPrintf(H263Info->dbg,"==============\n");
  ScDebugPrintf(H263Info->dbg,"Total  : %d\n", bits->total/num);
  ScDebugPrintf(H263Info->dbg,"\n");
  return;
}
#endif

/*****************************************************************
 *
 *  coder.c for H.263 encoder
 *  Wei-Lien Hsu
 *  Date: December 11, 1996
 *
 *****************************************************************/


static void SelectBounds(H263_PictImage *Img, unsigned char **PL, int rows, int cols) ;
static unsigned char LargeMv(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int th) ;
static unsigned char LargePerror(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int th);
static unsigned char BoundaryMB(SvH263CompressInfo_t *H263Info, int i, int j, int pels, int lines) ;
static int GetPrefLevel(SvH263CompressInfo_t *H263Info, H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int rows, int cols) ;

void FillLumBlock(SvH263CompressInfo_t *H263Info, int x, int y, H263_PictImage *image, H263_MB_Structure *data);
void FillChromBlock(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, H263_PictImage *image,
		    H263_MB_Structure *data);
void FillLumPredBlock(SvH263CompressInfo_t *H263Info, int x, int y, PredImage *image, H263_MB_Structure *data);
void FillChromPredBlock(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, PredImage *image,
			H263_MB_Structure *data);
void ZeroMBlock(H263_MB_Structure *data);
void ReconImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, H263_PictImage *recon);
void ReconPredImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, PredImage *recon);
void InterpolateImage(unsigned char *image, unsigned char *ipol_image,
								int width, int height);
void MotionEstimatePicture(SvH263CompressInfo_t *H263Info, unsigned char *curr, unsigned char *prev,
			   unsigned char *prev_ipol, int seek_dist,
			   H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2], int gobsync);
void MakeEdgeImage(unsigned char *src, unsigned char *dst, int width,
		   int height, int edge);

/**************************************************************************
 * Function: SelectBounds
 * Draws a boundary around each MacroBlock with width equal to its assigned
 * prefilter level
 *************************************************************************/

#if 0
void SelectBounds(H263_PictImage *Img, unsigned char **PL, int rows, int cols)
{
	int i, j, l, m, n, r, c;

	for(i=0; i<rows/H263_MB_SIZE; i++) {
		for(j=0; j<cols/H263_MB_SIZE; j++) {
			for(l=0; l<PL[i][j]; l++) {
				r = i*H263_MB_SIZE+l;

				for(n=l; n<H263_MB_SIZE-l; n++) {
					c = j*H263_MB_SIZE+n;
					Img->lum[r*cols+c] = 255;
					Img->lum[(r+H263_MB_SIZE-1-l)*cols+c] = 255;
				}

				c = j*H263_MB_SIZE+l;
				for(m=l; m<H263_MB_SIZE-l; m++) {
					r = i*H263_MB_SIZE+m;
					Img->lum[r*cols+c] = 255;
					Img->lum[r*cols+(c+H263_MB_SIZE-1-l)] = 255;
				}

			}
		}
	}
}
#endif

/**********************************************************************
 * Function: LargeMv
 * Checks if the norm of the integer component of the motion vector
 * of the macroblock i, j is largen than the threshold th. Returns 1 if
 * yes, 0 if not.
 * Added by Nuno on 07/1/96 to support adaptive prefiltering.
 **********************************************************************/
 unsigned char LargeMv(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int th)
 {
	return(sqrt((double) MV[0][j+1][i+1]->x*MV[0][j+1][i+1]->x +
		        (double) MV[0][j+1][i+1]->y*MV[0][j+1][i+1]->y) > th);
 }

 /**********************************************************************
 * Function: LargePerror
 * Checks if the prediction error for macroblock i, j is largen than
 * the threshold th. Returns 1 if yes, 0 if not.
 * Added by Nuno on 07/1/96 to support adaptive prefiltering.
 **********************************************************************/
 unsigned char LargePerror(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int th)
 {
	return(MV[0][j+1][i+1]->min_error > th);
 }

 /**********************************************************************
 * Function: BoundaryMB
 * Returns 1 if a MB is on the boundary of the image, o if not.
 * Added by Nuno on 07/1/96 to support adaptive prefiltering.
 **********************************************************************/
 unsigned char BoundaryMB(SvH263CompressInfo_t *H263Info, int i, int j, int pels, int lines)
 {
	return(j==0 || i==0 || i==(H263Info->mb_width -1) || j==(H263Info->mb_height - 1));
 }

 /***********************************************************************
  * Function: GetPrefLevel
  * Selects the level of the pyramid of prefiltered images that is best
  * suited for the encoding of the MacroBlock (i,j)
  **********************************************************************/
 int GetPrefLevel(SvH263CompressInfo_t *H263Info,
                  H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int i, int j, int rows, int cols)
 {
	 int motbin, pebin;

	 motbin = 0;
	 while(LargeMv(MV, i, j, (int) H263Info->MOTresh[motbin]) && motbin<3) motbin++;

	 pebin = 0;
	 while(LargePerror(MV, i, j, H263Info->PETresh[pebin]) && pebin<2) pebin++;
	
	 if(BoundaryMB(H263Info, i, j, cols, rows) && motbin<3) motbin++;

	 return H263Info->PREF_LEVEL[motbin][pebin];
 }

/**********************************************************************
 *
 *	Name:		sv_H263CodeOneOrTwo
 *	Description:	code one image normally or two images
 *                      as a PB-frame (CodeTwoPB and CodeOnePred merged)
 *	
 *	Input:		pointer to image, prev_image, prev_recon, Q
 *			
 *	Returns:	pointer to reconstructed image
 *	Side effects:	memory is allocated to recon image
 *  changed by Nuno on 06/27/96 to support filtering of the prediction error
 ***********************************************************************/
static SvStatus_t sv_H263CodeOneOrTwo(SvCodecInfo_t *Info, int QP, int frameskip,
          H263_Bits *bits, H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2])
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  ScBitstream_t *BSOut = Info->BSOut;
  H263_Pict *pic=H263Info->pic;
  unsigned char *prev_ipol,*pi_edge=NULL,*orig_lum;
  H263_MotionVector ZERO = {0,0,0,0,0};
  H263_PictImage *prev_recon=NULL, *pr_edge=NULL;
  H263_MB_Structure *recon_data_P = (H263_MB_Structure *)ScAlloc(sizeof(H263_MB_Structure));
  H263_MB_Structure *recon_data_B=NULL;
  H263_MB_Structure *diff=(H263_MB_Structure *)ScAlloc(sizeof(H263_MB_Structure));
  H263_MB_Structure *Bpred=NULL;
  short *qcoeff_P;
  short *qcoeff_B=NULL;
  unsigned char *pi;

  int Mode,B;
  int CBP, CBPB=0;
  int bquant[] = {5,6,7,8};
  int QP_B;
  int newgob;
  int i,j,k;

  /* buffer control vars */
  float QP_cumulative = (float)0.0;
  int abs_mb_num = 0, QuantChangePostponed = 0;
  int QP_new, QP_prev, dquant, QP_xmitted=QP;

  sv_H263ZeroBits(bits);

  pi      = H263Info->wk_buffers->ipol_image;
  qcoeff_P= H263Info->wk_buffers->qcoeff_P;

  if(pic->PB){
    if ((qcoeff_B=(short *)ScAlloc(sizeof(short)*384)) == 0)
      return(SvErrorMemory);
    recon_data_B=(H263_MB_Structure *)ScAlloc(sizeof(H263_MB_Structure));
    Bpred=(H263_MB_Structure *)ScAlloc(sizeof(H263_MB_Structure));
  }
  /* interpolate image */
  if (H263Info->mv_outside_frame) {
    if (H263Info->long_vectors) {
      /* If the Extended Motion Vector range is used, motion vectors
	 may point further out of the picture than in the normal range,
	 and the edge images will have to be made larger */
      B = 16;
    }
    else {
      /* normal range */
      B = 8;
    }
    pi_edge = (unsigned char *)ScAlloc(sizeof(char)*(H263Info->pels+4*B)*(H263Info->lines+4*B));
    if (pi_edge == NULL)
      return(SvErrorMemory);
    MakeEdgeImage(H263Info->prev_recon->lum,pi_edge + (H263Info->pels + 4*B)*2*B+2*B,H263Info->pels,H263Info->lines,2*B);
    InterpolateImage(pi_edge, pi, H263Info->pels+4*B, H263Info->lines+4*B);
    ScFree(pi_edge);
    prev_ipol = pi + (2*H263Info->pels + 8*B) * 4*B + 4*B;

    /* luma of non_interpolated image */
    pr_edge = sv_H263InitImage((H263Info->pels+4*B)*(H263Info->lines+4*B));
    MakeEdgeImage(H263Info->prev_image->lum, pr_edge->lum + (H263Info->pels + 4*B)*2*B+2*B,
		  H263Info->pels,H263Info->lines,2*B);
    orig_lum = pr_edge->lum + (H263Info->pels + 4*B)*2*B+2*B;

    /* non-interpolated image */
    MakeEdgeImage(H263Info->prev_recon->lum,pr_edge->lum + (H263Info->pels+4*B)*2*B + 2*B,H263Info->pels,H263Info->lines,2*B);
    MakeEdgeImage(H263Info->prev_recon->Cr,pr_edge->Cr + (H263Info->pels/2 + 2*B)*B + B,H263Info->pels/2,H263Info->lines/2,B);
    MakeEdgeImage(H263Info->prev_recon->Cb,pr_edge->Cb + (H263Info->pels/2 + 2*B)*B + B,H263Info->pels/2,H263Info->lines/2,B);

    prev_recon = (H263_PictImage *)ScAlloc(sizeof(H263_PictImage));
    prev_recon->lum = pr_edge->lum + (H263Info->pels + 4*B)*2*B + 2*B;
    prev_recon->Cr = pr_edge->Cr + (H263Info->pels/2 + 2*B)*B + B;
    prev_recon->Cb = pr_edge->Cb + (H263Info->pels/2 + 2*B)*B + B;
  }
  else {
    InterpolateImage(H263Info->prev_recon->lum,pi,H263Info->pels,H263Info->lines);
    prev_ipol = pi;
    prev_recon = H263Info->prev_recon;
    orig_lum = H263Info->prev_image->lum;
  }

  /* mark PMV's outside the frame */
  for (i = 1; i < H263Info->mb_width+1; i++) {
    for (k = 0; k < 6; k++) {
      sv_H263MarkVec(MV[k][0][i]);
    }
    MV[0][0][i]->Mode = H263_MODE_INTRA;
  }
  /* zero out PMV's outside the frame */
  for (i = 0; i < H263Info->mb_height+1; i++) {
    for (k = 0; k < 6; k++) {
      sv_H263ZeroVec(MV[k][i][0]);
      sv_H263ZeroVec(MV[k][i][H263Info->mb_width+1]);
    }
    MV[0][i][0]->Mode = H263_MODE_INTRA;
    MV[0][i][H263Info->mb_width+1]->Mode = H263_MODE_INTRA;
  }

  /* Integer and half pel motion estimation */
  MotionEstimatePicture(H263Info, H263Info->curr_image->lum,prev_recon->lum,prev_ipol,
			pic->seek_dist,MV, pic->use_gobsync);

 /*
  fprintf(stdout,"\nMotion Vector Magintudes\n");
  for ( j = 0; j < H263Info->lines/H263_MB_SIZE; j++) {
    for ( i = 0; i < H263Info->pels/H263_MB_SIZE; i++) {
      fprintf(stdout, "%4.0lf ", sqrt((double) MV[0][j+1][i+1]->x*MV[0][j+1][i+1]->x
					+ MV[0][j+1][i+1]->y*MV[0][j+1][i+1]->y));
    }
    fprintf(stdout,"\n");
  }
	  fprintf(stdout,"\nMacroBlock Prediction Error\n");
  for ( j = 0; j < H263Info->lines/H263_MB_SIZE; j++) {
    for ( i = 0; i < H263Info->pels/H263_MB_SIZE; i++) {
      fprintf(stdout, "%4d ", MV[0][j+1][i+1]->min_error);
    }
    fprintf(stdout,"\n");
  }
*/

  /* note: integer pel motion estimation is now based on previous
     reconstructed image, not the previous original image. We have
     found that this works better for some sequences and not worse for
     others.  Note that it can not easily be changed back by
     substituting prev_recon->lum with orig_lum in the line above,
     because SAD for zero vector is not re-calculated in the half
     pel search. The half pel search has always been based on the
     previous reconstructed image */
#ifdef GOB_RATE_CONTROL
  if (H263Info->bit_rate != 0) {
    /* Initialization routine for Rate Control */
    QP_new = sv_H263GOBInitQP((float)H263Info->bit_rate,
               (pic->PB ? H263Info->frame_rate/2 : H263Info->frame_rate),
                                        pic->QP_mean);
    QP_xmitted = QP_prev = QP_new;
  }
  else {
    QP_new = QP_xmitted = QP_prev = QP; /* Copy the passed value of QP */
  }
#else
  QP_new = QP_prev = QP; /* Copy the passed value of QP */
#endif
  dquant = 0;

  /* TRAILER information */

  if (H263Info->extbitstream)
  {
    SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
    RTPInfo->trailer.dwVersion = 0;

    RTPInfo->trailer.dwFlags = 0;
    if(H263Info->syntax_arith_coding)
      RTPInfo->trailer.dwFlags |= RTP_H263_SAC;
    if(H263Info->advanced)
      RTPInfo->trailer.dwFlags |= RTP_H263_AP;
    if(H263Info->pb_frames)
      H263Info->RTPInfo->trailer.dwFlags |= RTP_H263_PB_FRAME;

    RTPInfo->trailer.dwUniqueCode = BI_DECH263DIB;
    RTPInfo->trailer.dwNumberOfPackets = 1;
    RTPInfo->trailer.SourceFormat = (unsigned char)H263Info->source_format;
    RTPInfo->trailer.TR = (unsigned char)pic->TR;
    RTPInfo->trailer.TRB = (unsigned char)pic->TRB;
    RTPInfo->trailer.DBQ = (unsigned char)pic->BQUANT;
    RTPInfo->pre_MB_position = RTPInfo->pre_GOB_position
        = RTPInfo->pic_start_position = RTPInfo->packet_start_position
        = ScBSBitPosition(BSOut); /* HWG - added pre_MB and pre_GOB */

    RTPInfo->packet_id = 0 ;
    RTPInfo->bsinfo[0].dwBitOffset = 0 ;
    RTPInfo->bsinfo[0].Mode =  H263_RTP_MODE_A;
    RTPInfo->pic_start_position = ScBSBitPosition(BSOut);
  }


  for ( j = 0; j < H263Info->mb_height; j++)
  {
    /* If a rate control scheme which updates the quantizer for each
       slice is used, it should be added here like this: */

#ifdef GOB_RATE_CONTROL
    if (H263Info->bit_rate != 0) {
      /* QP updated at the beginning of each row */
      sv_H263AddBitsPicture(H263Info->bits);

      QP_new =  sv_H263GOBUpdateQP(abs_mb_num, pic->QP_mean,
           (float)H263Info->bit_rate, H263Info->pels/H263_MB_SIZE,
		   H263Info->lines/H263_MB_SIZE, H263Info->bits->total,j,VARgob,
           pic->PB);
    }
#endif

    /* In other words: you have to set QP_new with some function, not
       necessarily called UpdateQuantizer. Check the source code for
       version 1.5 if you would like to see how it can be done. Read the
       comment in ratectrl.c to see why we removed this scheme. You mau
       also have to add initializer functions before and after the
       encoding of each frame. Special care has to be taken for the intra
       frame if you are designing a system for fixed bitrate and small
       delay.

       If you calculate QP_new here, the rest of the code in the main
       loop will support this.

       If you think the TMN5 scheme worked well enough for you, and the
       simplified scheme is too simple, you can easily add the TMN5 code
       back. However, this will not work with the adaptive PB-frames at
       all! */

    newgob = 0;

    if (j == 0) {
      pic->QUANT = QP_new;
      bits->header += sv_H263CountBitsPicture(H263Info, BSOut, pic);
      QP_xmitted = QP_prev = QP_new;
    }
    else if (pic->use_gobsync && j%pic->use_gobsync == 0) {
	  /* insert gob sync */
      bits->header += sv_H263CountBitsSlice(H263Info, BSOut, j,QP_new);
      QP_xmitted = QP_prev = QP_new;
      newgob = 1;
    }

    for ( i = 0; i < H263Info->mb_width; i++) {

      /* Update of dquant, check and correct its limit */
      dquant = QP_new - QP_prev;
      if (dquant != 0 && i != 0 && MV[0][j+1][i+1]->Mode == H263_MODE_INTER4V) {
	    /* It is not possible to change the quantizer and at the same
	       time use 8x8 vectors. Turning off 8x8 vectors is not
	       possible at this stage because the previous macroblock
	       encoded assumed this one should use 8x8 vectors. Therefore
	       the change of quantizer is postponed until the first MB
	       without 8x8 vectors */
	    dquant = 0;
	    QP_xmitted = QP_prev;
	    QuantChangePostponed = 1;
      }
      else {
	    QP_xmitted = QP_new;
	    QuantChangePostponed = 0;
      }
      if (dquant > 2)  { dquant =  2; QP_xmitted = QP_prev + dquant;}
      if (dquant < -2) { dquant = -2; QP_xmitted = QP_prev + dquant;}

      pic->DQUANT = dquant;
      /* modify mode if dquant != 0 (e.g. MODE_INTER -> MODE_INTER_Q) */
      Mode = sv_H263ModifyMode(MV[0][j+1][i+1]->Mode,pic->DQUANT);
      MV[0][j+1][i+1]->Mode = (short)Mode;

      pic->MB = i + j * H263Info->mb_width;

      if (Mode == H263_MODE_INTER || Mode == H263_MODE_INTER_Q || Mode==H263_MODE_INTER4V) {
	    /* Predict P-MB */
	    if (H263Info->prefilter) {
	      H263Info->PreFilterLevel[j][i] = (unsigned char)GetPrefLevel(H263Info, MV, i, j, H263Info->lines, H263Info->pels);
	      sv_H263PredictP(H263Info, H263Info->curr_filtd[H263Info->PreFilterLevel[j][i]],prev_recon,prev_ipol,
			                i*H263_MB_SIZE,j*H263_MB_SIZE,MV,pic->PB,diff);
	    }
	    else
	      sv_H263PredictP(H263Info, H263Info->curr_image,prev_recon,prev_ipol, i*H263_MB_SIZE,
		                         j*H263_MB_SIZE,MV,pic->PB,diff);
      }
	  else {
	    if (H263Info->prefilter) {
	      H263Info->PreFilterLevel[j][i] = (unsigned char)GetPrefLevel(H263Info, MV, i, j, H263Info->lines, H263Info->pels);
	      FillLumBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, H263Info->curr_filtd[H263Info->PreFilterLevel[j][i]], diff);
	      FillChromBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, H263Info->curr_filtd[H263Info->PreFilterLevel[j][i]], diff);
	    }
		else {
	      FillLumBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, H263Info->curr_image, diff);
	      FillChromBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, H263Info->curr_image, diff);
	    }
      }

      /* P or INTRA Macroblock DCT + Quantization and IQuant+IDCT*/
      sv_H263MBEncode(diff, QP_xmitted, Mode, &CBP, qcoeff_P, H263Info->calc_quality);

      if (CBP == 0 && (Mode == H263_MODE_INTER || Mode == H263_MODE_INTER_Q))
	       ZeroMBlock(diff);
      else sv_H263MBDecode(H263Info, qcoeff_P, diff, QP_xmitted, Mode, CBP, H263Info->calc_quality);

      sv_H263MBReconP(H263Info, prev_recon, prev_ipol,diff,
				     i*H263_MB_SIZE,j*H263_MB_SIZE,MV,pic->PB,recon_data_P);
      sv_H263Clip(recon_data_P);

      /* Predict B-MB using reconstructed P-MB and prev. recon. image */
      if (pic->PB) {
	    if (H263Info->prefilter) {
	      H263Info->PreFilterLevel[j][i] = (unsigned char)GetPrefLevel(H263Info, MV, i, j, H263Info->lines, H263Info->pels);
	      sv_H263PredictB(H263Info, H263Info->B_filtd[H263Info->PreFilterLevel[j][i]],
			            prev_recon, prev_ipol,i*H263_MB_SIZE,
			   j*H263_MB_SIZE, MV, recon_data_P, frameskip, pic->TRB,
			   diff, Bpred);
	    }
	    else sv_H263PredictB(H263Info, H263Info->B_image, prev_recon, prev_ipol,
			                 i*H263_MB_SIZE, j*H263_MB_SIZE,
			                 MV, recon_data_P, frameskip, pic->TRB,
							 diff, Bpred);
	    if (QP_xmitted == 0) QP_B = 0;  /* (QP = 0 means no quantization) */
	    else QP_B = mmax(1,mmin(31,bquant[pic->BQUANT]*QP_xmitted/4));

	    sv_H263MBEncode(diff, QP_B, H263_MODE_INTER, &CBPB, qcoeff_B, H263Info->calc_quality);

		if(H263Info->vsnr) { /* reconstruction only for performance measurement */

	       if (CBPB) sv_H263MBDecode(H263Info, qcoeff_B, diff, QP_B, H263_MODE_INTER, CBP, H263Info->calc_quality);
	       else      ZeroMBlock(diff);

  	       sv_H263MBReconB(H263Info, prev_recon, diff,prev_ipol,
		 	                i*H263_MB_SIZE, j*H263_MB_SIZE,MV,recon_data_P,
				            frameskip, pic->TRB, recon_data_B, Bpred);
	       sv_H263Clip(recon_data_B);
		}

  	    /* decide MODB */
	    if (CBPB) pic->MODB = H263_PBMODE_CBPB_MVDB;
	    else {
	      if (MV[5][j+1][i+1]->x == 0 && MV[5][j+1][i+1]->y == 0)
	          pic->MODB = H263_PBMODE_NORMAL;
	      else pic->MODB = H263_PBMODE_MVDB;
	    }
      }
      else
	    sv_H263ZeroVec(MV[5][j+1][i+1]); /* Zero out PB deltas */

      /* Entropy coding */
      if ((CBP==0) && (CBPB==0) && (sv_H263EqualVec(MV[0][j+1][i+1],&ZERO)) &&
	      (sv_H263EqualVec(MV[5][j+1][i+1],&ZERO)) &&
	      (Mode == H263_MODE_INTER || Mode == H263_MODE_INTER_Q)) {
	        /* Skipped MB : both CBP and CBPB are zero, 16x16 vector is zero,
	           PB delta vector is zero and Mode = MODE_INTER */
	        if (Mode == H263_MODE_INTER_Q) {
	          /* DQUANT != 0 but not coded anyway */
	          QP_xmitted = QP_prev;
	          pic->DQUANT = 0;
	          Mode = H263_MODE_INTER;
	        }
            if (!H263Info->syntax_arith_coding)
              sv_H263CountBitsMB(BSOut, Mode,1,CBP,CBPB,pic,bits);
           else
              sv_H263CountSACBitsMB(H263Info, BSOut, Mode,1,CBP,CBPB,pic,bits);
      }
	  else { /* Normal MB */
        if (!H263Info->syntax_arith_coding) { /* VLC */
          sv_H263CountBitsMB(BSOut, Mode,0,CBP,CBPB,pic,bits);
	      if (Mode == H263_MODE_INTER  || Mode == H263_MODE_INTER_Q) {
	        bits->no_inter++;
	        sv_H263CountBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
	      }
		  else if (Mode == H263_MODE_INTER4V) {
	        bits->no_inter4v++;
	        sv_H263CountBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
	      }
		  else {
	        /* MODE_INTRA or MODE_INTRA_Q */
	        bits->no_intra++;
	        if (pic->PB)
	          sv_H263CountBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
	      }

	      if (CBP || Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
	        sv_H263CountBitsCoeff(BSOut, qcoeff_P, Mode, CBP, bits, 64);

	      if (CBPB)
	        sv_H263CountBitsCoeff(BSOut, qcoeff_B, H263_MODE_INTER, CBPB, bits, 64);
	    } /* end VLC */
	    else { /* SAC */

          sv_H263CountSACBitsMB(H263Info, BSOut, Mode,0,CBP,CBPB,pic,bits);

          if (Mode == H263_MODE_INTER  || Mode == H263_MODE_INTER_Q) {
            bits->no_inter++;
            sv_H263CountSACBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
          }
          else if (Mode == H263_MODE_INTER4V) {
            bits->no_inter4v++;
            sv_H263CountSACBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
          }
          else {
			/* MODE_INTRA or MODE_INTRA_Q */
            bits->no_intra++;
            if (pic->PB)
              sv_H263CountSACBitsVectors(H263Info, BSOut, MV, bits, i, j, Mode, newgob, pic);
	      }

	      if (CBP || Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
	        sv_H263CountSACBitsCoeff(H263Info, BSOut, qcoeff_P, Mode, CBP, bits, 64);

	      if (CBPB)
	        sv_H263CountSACBitsCoeff(H263Info, BSOut, qcoeff_B, H263_MODE_INTER, CBPB, bits, 64);
	    } /* end SAC */

	    QP_prev = QP_xmitted;

      } /* End Normal Block */

      abs_mb_num++;
      QP_cumulative += QP_xmitted;
	
#ifdef PRINTQ
      /* most useful when quantizer changes within a picture */
      if (QuantChangePostponed) fprintf(stdout,"@%2d",QP_xmitted);
      else                      fprintf(stdout," %2d",QP_xmitted);
#endif

      if (pic->PB && H263Info->vsnr)
          ReconImage(H263Info, i,j,recon_data_B,H263Info->B_recon);

      ReconImage(H263Info, i,j,recon_data_P,H263Info->curr_recon);

      if ((H263Info->extbitstream&PARAM_FORMATEXT_RTPB)!=0)
      {
        SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
        ScBSPosition_t cur_position = ScBSBitPosition(BSOut);

	    /* start a new packet */
	    if((cur_position - RTPInfo->packet_start_position) >= H263Info->packetsize)
	    {
          SvH263BSInfo_t *RTPBSInfo=&RTPInfo->bsinfo[RTPInfo->packet_id];
          if (RTPInfo->pre_MB_position>RTPBSInfo->dwBitOffset)
          {
            RTPBSInfo++; RTPInfo->packet_id++;
            RTPInfo->trailer.dwNumberOfPackets++;
          }
          RTPBSInfo->dwBitOffset = (unsigned dword)H263Info->RTPInfo->packet_start_position;
          RTPInfo->packet_start_position = RTPInfo->pre_MB_position;
          RTPBSInfo->Mode =  H263_RTP_MODE_B;
          RTPBSInfo->Quant =  (unsigned char)QP_xmitted;
          RTPBSInfo->GOBN =  (unsigned char)j;

          if(Mode==H263_MODE_INTER4V) {
            RTPBSInfo->HMV1 =  (char)MV[1][j+1][i+1]->x;
            RTPBSInfo->VMV1 =  (char)MV[1][j+1][i+1]->y;
            RTPBSInfo->HMV2 =  (char)MV[2][j+1][i+1]->x;
            RTPBSInfo->VMV2 =  (char)MV[2][j+1][i+1]->y;
		  }
		  else {
            RTPBSInfo->HMV1 =  (char)MV[0][j+1][i+1]->x;
            RTPBSInfo->VMV1 =  (char)MV[0][j+1][i+1]->y;
            RTPBSInfo->HMV2 =  0;
            RTPBSInfo->VMV2 =  0;
		  }
	    }
	    RTPInfo->pre_MB_position = cur_position;
      }
    } /* end of line of blocks - j loop */

    if ((H263Info->extbitstream&PARAM_FORMATEXT_RTPA)!=0)
    {
      SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
      ScBSPosition_t cur_position = ScBSBitPosition(BSOut);

	  /* start a new packet */
	  if((cur_position - RTPInfo->packet_start_position) >= H263Info->packetsize)
	  {
        SvH263BSInfo_t *RTPBSInfo=&RTPInfo->bsinfo[RTPInfo->packet_id];
        if (RTPInfo->pre_GOB_position>RTPBSInfo->dwBitOffset)
        {
          RTPBSInfo++; RTPInfo->packet_id++;
          RTPInfo->trailer.dwNumberOfPackets++;
        }
        RTPInfo->packet_start_position = RTPInfo->pre_GOB_position;
        RTPBSInfo->dwBitOffset = (unsigned dword)RTPInfo->packet_start_position;
        RTPBSInfo->Mode = H263_RTP_MODE_A;
	  }
	  RTPInfo->pre_GOB_position = cur_position;
    }

#ifdef PRINTQ
    fprintf(stdout,"\n");
#endif

  } /* end of image - i loop */

  pic->QP_mean = QP_cumulative/(float)abs_mb_num;

  /* Free memory */
  ScFree(diff);
  ScFree(recon_data_P);
  if (pic->PB) {
	  ScFree(recon_data_B);
	  ScFree(Bpred);
  }

  if (H263Info->mv_outside_frame)
  {
    ScFree(prev_recon);
    sv_H263FreeImage(pr_edge);
  }

  if(pic->PB) ScFree(qcoeff_B);

  return(SvErrorNone);
}


/**********************************************************************
 *
 *	Name:		CodeOneIntra
 *	Description:	codes one image intra
 *	
 *	Input:		pointer to image, QP
 *			
 *	Returns:	pointer to reconstructed image
 *	Side effects:	memory is allocated to recon image
 *
 ***********************************************************************/

H263_PictImage *sv_H263CodeOneIntra(SvCodecInfo_t *Info, H263_PictImage *curr,
                                    H263_PictImage *recon, int QP, H263_Bits *bits, H263_Pict *pic)
{
  SvH263CompressInfo_t *H263Info = Info->h263comp;
  ScBitstream_t *BSOut=Info->BSOut;
  H263_MB_Structure *data = (H263_MB_Structure *)ScAlloc(sizeof(H263_MB_Structure));
  short *qcoeff;
  int Mode = H263_MODE_INTRA;
  int CBP,COD;
  int i,j;

  if ((qcoeff=(short *)ScAlloc(sizeof(short)*384)) == 0) {
    _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "mb_encode(): Couldn't allocate qcoeff.\n") );
    return(NULL);
  }

  /* TRAILER information */
  if (H263Info->extbitstream)
  {
    /* H263Info->RTPInfo->trailer.dwSrcVersion = 0; */
    H263Info->RTPInfo->trailer.dwVersion = 0;

    H263Info->RTPInfo->trailer.dwFlags = RTP_H263_INTRA_CODED;
    if(H263Info->syntax_arith_coding)
      H263Info->RTPInfo->trailer.dwFlags |= RTP_H263_SAC;
    if(H263Info->advanced)
      H263Info->RTPInfo->trailer.dwFlags |= RTP_H263_AP;
    if(H263Info->pb_frames)
      H263Info->RTPInfo->trailer.dwFlags |= RTP_H263_PB_FRAME;

    H263Info->RTPInfo->trailer.dwUniqueCode = BI_DECH263DIB;
    H263Info->RTPInfo->trailer.dwNumberOfPackets = 1;
    H263Info->RTPInfo->trailer.SourceFormat = (unsigned char)H263Info->source_format;
    H263Info->RTPInfo->trailer.TR = 0;
    H263Info->RTPInfo->trailer.TRB = 0;
    H263Info->RTPInfo->trailer.DBQ = 0;

    H263Info->RTPInfo->pre_GOB_position = H263Info->RTPInfo->pre_MB_position
        = H263Info->RTPInfo->pic_start_position
        = H263Info->RTPInfo->packet_start_position = ScBSBitPosition(BSOut);

    H263Info->RTPInfo->packet_id = 0 ;
    H263Info->RTPInfo->bsinfo[0].dwBitOffset = 0 ;
    H263Info->RTPInfo->bsinfo[0].Mode =  H263_RTP_MODE_A;
  }

  sv_H263ZeroBits(bits);

  pic->QUANT = QP;

  bits->header += sv_H263CountBitsPicture(H263Info, BSOut, pic);

  COD = 0; /* Every block is coded in Intra frame */
  for ( j = 0; j < H263Info->mb_height; j++) {

    /* insert sync in *every* slice if use_gobsync is chosen */
    if (pic->use_gobsync && j != 0)
      bits->header += sv_H263CountBitsSlice(H263Info, BSOut, j,QP);

    for ( i = 0; i < H263Info->mb_width; i++) {

      pic->MB = i + j * H263Info->mb_width;
      bits->no_intra++;

      FillLumBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, curr, data);

      FillChromBlock(H263Info, i*H263_MB_SIZE, j*H263_MB_SIZE, curr, data);

      sv_H263MBEncode(data, QP, Mode, &CBP, qcoeff, H263Info->calc_quality);

      if (!H263Info->syntax_arith_coding) {
        sv_H263CountBitsMB(BSOut, Mode,COD,CBP,0,pic,bits);
        sv_H263CountBitsCoeff(BSOut, qcoeff, Mode, CBP,bits,64);
      } else {
        sv_H263CountSACBitsMB(H263Info, BSOut, Mode,COD,CBP,0,pic,bits);
        sv_H263CountSACBitsCoeff(H263Info, BSOut, qcoeff, Mode, CBP,bits,64);
      }

      sv_H263MBDecode(H263Info, qcoeff, data, QP, Mode, CBP, H263Info->calc_quality);
      sv_H263Clip(data);

      ReconImage(H263Info, i,j,data,recon);

      if ((H263Info->extbitstream&PARAM_FORMATEXT_RTPB)!=0)
      {
        SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
        ScBSPosition_t cur_position = ScBSBitPosition(BSOut);

	    /* start a new packet */
	    if((cur_position - RTPInfo->packet_start_position) >= H263Info->packetsize)
	    {
          SvH263BSInfo_t *RTPBSInfo=&RTPInfo->bsinfo[RTPInfo->packet_id];
          if (RTPInfo->pre_MB_position>RTPBSInfo->dwBitOffset)
          {
            RTPBSInfo++; RTPInfo->packet_id++;
            RTPInfo->trailer.dwNumberOfPackets++;
          }
          RTPInfo->packet_start_position = RTPInfo->pre_MB_position;
          RTPBSInfo->dwBitOffset = (unsigned dword)RTPInfo->packet_start_position;
          RTPBSInfo->Mode =  H263_RTP_MODE_B;
          RTPBSInfo->Quant = (unsigned char)QP;
          RTPBSInfo->GOBN =  (unsigned char)j;
          RTPBSInfo->HMV1 =  0;
          RTPBSInfo->VMV1 =  0;
          RTPBSInfo->HMV2 =  0;
          RTPBSInfo->VMV2 =  0;
	    }
	    RTPInfo->pre_MB_position = cur_position;
      }
    }

    if ((H263Info->extbitstream&PARAM_FORMATEXT_RTPA)!=0)
    {
      SvH263RTPInfo_t *RTPInfo=H263Info->RTPInfo;
      ScBSPosition_t cur_position = ScBSBitPosition(BSOut);

	  /* start a new packet */
	  if((cur_position - RTPInfo->packet_start_position) >= H263Info->packetsize)
	  {
        SvH263BSInfo_t *RTPBSInfo=&RTPInfo->bsinfo[RTPInfo->packet_id];
        if (RTPInfo->pre_GOB_position>RTPBSInfo->dwBitOffset)
        {
          RTPBSInfo++; RTPInfo->packet_id++;
          RTPInfo->trailer.dwNumberOfPackets++;
        }
        RTPInfo->packet_start_position = RTPInfo->pre_GOB_position;
        RTPBSInfo->dwBitOffset = (unsigned dword)RTPInfo->packet_start_position;
        RTPBSInfo->Mode =  H263_RTP_MODE_A;
	  }
	  RTPInfo->pre_GOB_position = cur_position;
    }
  }

  pic->QP_mean = (float)QP;

  ScFree(data);
  ScFree(qcoeff);

  return recon;
}

/**********************************************************************
 *
 *	Name:		MB_Encode
 *	Description:	DCT and quantization of Macroblocks
 *
 *	Input:		MB data struct, mquant (1-31, 0 = no quant),
 *			MB info struct
 *	Returns:	Pointer to quantized coefficients
 *	Side effects:	
 *
 **********************************************************************/


static int sv_H263MBEncode(H263_MB_Structure *mb_orig, int QP, int I, int *CBP,
						   short *qcoeff, unsigned dword quality)
{
  int		i, k, l, row, blkid;
  short		fblock[64];
  short		*coeff_ind;

  coeff_ind = qcoeff;
  *CBP = 0;
  blkid = 0;

  for (k=0;k<16;k+=8) {
    for (l=0;l<16;l+=8) {

      for (i=k,row=0;row<64;i++,row+=8)
        memcpy(fblock + row, &(mb_orig->lum[i][l]), 16) ;
#if 1
      /* DCT in ZZ order */
      if(quality > 40){
        if(sv_H263DCT(fblock,coeff_ind,QP,I))
          if(sv_H263Quant(coeff_ind,QP,I)) *CBP |= (32 >> blkid);
	  }
      else {
        if(sv_H263ZoneDCT(fblock,coeff_ind,QP,I))
          if(sv_H263Quant(coeff_ind,QP,I)) *CBP |= (32 >> blkid);
	  }
#else
      switch (DCT_method) {
      case(H263_DCT16COEFF):
	    svH263Dct16coeff(fblock,coeff_ind);
	    break;
      case(H263_DCT4BY4):
	    svH263Dct4by4(fblock,coeff_ind);
	    break;
      }
      if(sv_H263Quant(coeff_ind,QP,I) != 0) *CBP |= (32 >> blkid);
#endif
      coeff_ind += 64;
	  blkid++;
    }
  }

#if 1
  /* DCT in ZZ order */
  if(quality > 40){
    if(sv_H263DCT(&(mb_orig->Cb[0][0]),coeff_ind,QP,I))
       if(sv_H263Quant(coeff_ind,QP,I)) *CBP |= (32 >> blkid);
  }
  else {
    if(sv_H263ZoneDCT(&(mb_orig->Cb[0][0]),coeff_ind,QP,I))
       if(sv_H263Quant(coeff_ind,QP,I)) *CBP |= (32 >> blkid);
  }
#else
  memcpy(&fblock[0], &(mb_orig->Cb[0][0]), 128);
  switch (DCT_method) {
  case(H263_DCT16COEFF):
    svH263Dct16coeff(fblock,coeff_ind);
    break;
  case(H263_DCT4BY4):
    svH263Dct4by4(fblock,coeff_ind);
    break;
  }
  if(sv_H263Quant(coeff_ind,QP,I) != 0) *CBP |= (32 >> blkid);
#endif

  coeff_ind += 64;
  blkid++;

#if 1
  /* DCT in ZZ order */
  if(quality > 40){
    if(sv_H263DCT( &(mb_orig->Cr[0][0]),coeff_ind,QP,I))
      if(sv_H263Quant(coeff_ind,QP,I) != 0) *CBP |= (32 >> blkid);
  }
  else {
    if(sv_H263ZoneDCT( &(mb_orig->Cr[0][0]),coeff_ind,QP,I))
      if(sv_H263Quant(coeff_ind,QP,I) != 0) *CBP |= (32 >> blkid);
  }
#else
  memcpy(&fblock[0], &(mb_orig->Cr[0][0]),128);
  switch (DCT_method) {
  case(H263_DCT16COEFF):
    svH263Dct16coeff(fblock,coeff_ind);
    break;
  case(H263_DCT4BY4):
    svH263Dct4by4(fblock,coeff_ind);
    break;
  }

  if(sv_H263Quant(coeff_ind,QP,I) != 0) *CBP |= (32 >> blkid);
#endif

  return 1;
}

/**********************************************************************
 *
 *	Name:		MB_Decode
 *	Description:	Reconstruction of quantized DCT-coded Macroblocks
 *
 *	Input:		Quantized coefficients, MB data
 *			QP (1-31, 0 = no quant), MB info block
 *	Returns:	int (just 0)
 *	Side effects:	
 *
 **********************************************************************/

/* de-quantization */

static short sv_H263MBDecode(SvH263CompressInfo_t *H263Info, short *qcoeff,
                             H263_MB_Structure *mb_recon, int QP, int I, int CBP,
							 unsigned dword quality)
{
  int	i, k, l, row, blkid;
  short	*iblock;
  short	*qcoeff_ind;
  short	*rcoeff, *rcoeff_ind;

  if(H263Info->refidct) {
    if ((rcoeff = (short *)ScAlloc(sizeof(short)*64)) == NULL) {
      _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "sv_H263MBDecode() Could not allocate space for rcoeff\n") );
      return(0);
    }
     if ((iblock = (short *)ScAlloc(sizeof(short)*64)) == NULL) {
      _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "sv_H263MBDecode() Could not allocate space for iblock\n") );
      return(0);
    }
  }

  /* Zero data into lum-Cr-Cb, For control purposes */
  memset(&(mb_recon->lum[0][0]), 0 , 768) ;

  qcoeff_ind = qcoeff;

  blkid = 0;
  for (k=0;k<16;k+=8) {
    for (l=0;l<16;l+=8) {

      if((CBP & (32 >> blkid)) || I == H263_MODE_INTRA || I == H263_MODE_INTRA_Q)
	  {
        if (H263Info->refidct)  {
           rcoeff_ind = rcoeff;
           sv_H263Dequant(qcoeff_ind,rcoeff_ind,QP,I);
	       sv_H263idctref(rcoeff_ind,iblock);
           for (i=k,row=0;row<64;i++,row+=8)
              memcpy(&(mb_recon->lum[i][l]), iblock+row, 16) ;
	    }
        else /* IDCT with ZZ and quantization */
		{
          if(quality > 40)
   		     sv_H263IDCT(qcoeff_ind,&(mb_recon->lum[k][l]),QP,I,16);
          else
  		    sv_H263ZoneIDCT(qcoeff_ind,&(mb_recon->lum[k][l]),QP,I,16);
		}
	  }
      else {
        for (i=k,row=0;row<64;i++,row+=8)
          memset(&(mb_recon->lum[i][l]), 0, 16) ;
	  }

      qcoeff_ind += 64;
	  blkid++;
    }
  }

  if((CBP & (32 >> blkid)) || I == H263_MODE_INTRA || I == H263_MODE_INTRA_Q)
  {
    if (H263Info->refidct){
      sv_H263Dequant(qcoeff_ind,rcoeff_ind,QP,I);
	  sv_H263idctref(rcoeff_ind,&(mb_recon->Cb[0][0]));
    }
    else /* IDCT with ZZ and quantization */
	{
      if(quality > 40)
        sv_H263IDCT(qcoeff_ind,&(mb_recon->Cb[0][0]),QP,I,8);
      else
        sv_H263ZoneIDCT(qcoeff_ind,&(mb_recon->Cb[0][0]),QP,I,8);
	}
  }

  blkid++ ;
  qcoeff_ind += 64;

  if((CBP & (32 >> blkid)) || I == H263_MODE_INTRA || I == H263_MODE_INTRA_Q) {

    if (H263Info->refidct) {
      sv_H263Dequant(qcoeff_ind,rcoeff_ind,QP,I);
 	  sv_H263idctref(rcoeff_ind,&(mb_recon->Cr[0][0]));
    }
    else /* IDCT with ZZ and quantization */
	{
      if(quality > 40)
        sv_H263IDCT(qcoeff_ind,&(mb_recon->Cr[0][0]),QP,I,8);
      else
        sv_H263ZoneIDCT(qcoeff_ind,&(mb_recon->Cr[0][0]),QP,I,8);
	}
  }

  if (H263Info->refidct){
	 ScFree(rcoeff);
     ScFree(iblock);
  }

  return 0;
}

/**********************************************************************
 *
 *	Name:		FillLumBlock
 *	Description:   	Fills the luminance of one block of PictImage
 *	
 *	Input:	      	Position, pointer to PictImage, array to fill
 *	Returns:       	
 *	Side effects:	fills array
 *
 ***********************************************************************/
#ifndef USE_C
void FillLumBlock(SvH263CompressInfo_t *H263Info,
                  int x, int y, H263_PictImage *image, H263_MB_Structure *data)
{
  sv_H263FilLumBlk_S((image->lum + x + y*H263Info->pels), &(data->lum[0][0]), H263Info->pels);
  return;
}
#else
void FillLumBlock(SvH263CompressInfo_t *H263Info,
                  int x, int y, H263_PictImage *image, H263_MB_Structure *data)
{
  int n, m, off;
  register short *ptnb;
  unsigned char *ptna ;

  ptna = image->lum + x + y*H263Info->pels ;
  ptnb = &(data->lum[0][0]) ;
  off = H263Info->pels - H263_MB_SIZE;

  for (n = 0; n < H263_MB_SIZE; n++){
    for (m = 0; m < H263_MB_SIZE; m++)
      *(ptnb++) = (short) *(ptna++) ;
	ptna += off;
  }

  return;
}
#endif
/**********************************************************************
 *
 *	Name:		FillChromBlock
 *	Description:   	Fills the chrominance of one block of PictImage
 *	
 *	Input:	      	Position, pointer to PictImage, array to fill
 *	Returns:       	
 *	Side effects:	fills array
 *                      128 subtracted from each
 *
 ***********************************************************************/
#ifndef USE_C
void FillChromBlock(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, H263_PictImage *image,
		    H263_MB_Structure *data)
{
  int off;
  off  = (x_curr>>1) +  (y_curr>>1)* H263Info->cpels;
  sv_H263FilChmBlk_S(image->Cr + off, &(data->Cr[0][0]),
	                 image->Cb + off, &(data->Cb[0][0]), H263Info->cpels) ;
  return;
}
#else
void FillChromBlock(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, H263_PictImage *image,
		    H263_MB_Structure *data)
{
  register int m, n;
  int off;
  short *ptnb, *ptnd;
  unsigned char *ptna, *ptnc;

  off  = (x_curr>>1) +  (y_curr>>1)* H263Info->cpels;
  ptna = image->Cr + off;  ptnb = &(data->Cr[0][0]) ;
  ptnc = image->Cb + off;  ptnd = &(data->Cb[0][0]) ;
  off = H263Info->cpels - 8 ;
  for (n = 0; n < 8; n++){
    for (m = 0; m < 8; m++) {
	  *(ptnb++) = (short)*(ptna++);
	  *(ptnd++) = (short)*(ptnc++);
    }
	ptna += off;
	ptnc += off;
  }
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		FillLumPredBlock
 *	Description:   	Fills the luminance of one block of PredImage
 *	
 *	Input:	      	Position, pointer to PredImage, array to fill
 *	Returns:       	
 *	Side effects:	fills array
 *
 ***********************************************************************/
#if 1
void FillLumPredBlock(SvH263CompressInfo_t *H263Info, int x, int y, PredImage *image,
					                 H263_MB_Structure *data)
{
  int n;
  register short *ptna, *ptnb;

  ptna = image->lum + x + y*H263Info->pels ;
  ptnb = &(data->lum[0][0]) ;
  for (n = 0; n < H263_MB_SIZE; n++){
    memcpy(ptnb,ptna,32);
	ptnb+=16 ; ptna += H263Info->pels ;
  }

  return;
}
#else
void FillLumPredBlock(SvH263CompressInfo_t *H263Info, int x, int y, PredImage *image, H263_MB_Structure *data)
{
  int n;
  register int m;

  for (n = 0; n < H263_MB_SIZE; n++)
    for (m = 0; m < H263_MB_SIZE; m++)
      data->lum[n][m] = *(image->lum + x+m + (y+n)*H263Info->pels);
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		FillChromPredBlock
 *	Description:   	Fills the chrominance of one block of PictImage
 *	
 *	Input:	      	Position, pointer to PictImage, array to fill
 *	Returns:       	
 *	Side effects:	fills array
 *                      128 subtracted from each
 *
 *  Added by Nuno on 06/27/96 to support filtering of the prediction error
 ***********************************************************************/

#if 1
void FillChromPredBlock(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, PredImage *image,
                        H263_MB_Structure *data)
{
  int n, off;
  register short *ptna, *ptnb, *ptnc, *ptnd ;

  off  = (x_curr>>1) +  (y_curr>>1)* H263Info->cpels;
  ptna = image->Cr + off;  ptnb = &(data->Cr[0][0]) ;
  ptnc = image->Cb + off;  ptnd = &(data->Cb[0][0]) ;

  for (n = 0; n < 8; n++){
    memcpy(ptnb,ptna,16);
	ptnb+=8 ; ptna += H263Info->cpels ;

    memcpy(ptnd,ptnc,16);
	ptnd+=8 ; ptnc += H263Info->cpels ;
  }

  return;
}
#else
void FillChromPredBlock(SvH263CompressInfo_t *H263Info,
                        int x_curr, int y_curr, PredImage *image,
                        H263_MB_Structure *data)
{
  int n;
  register int m;

  int x, y;

  x = x_curr>>1;
  y = y_curr>>1;

  for (n = 0; n < (H263_MB_SIZE>>1); n++)
    for (m = 0; m < (H263_MB_SIZE>>1); m++) {
      data->Cr[n][m] = *(image->Cr +x+m + (y+n)*H263Info->cpels);
      data->Cb[n][m] = *(image->Cb +x+m + (y+n)*H263Info->cpels);
    }
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		ZeroMBlock
 *	Description:   	Fills one MB with Zeros
 *	
 *	Input:	      	MB_Structure to zero out
 *	Returns:       	
 *	Side effects:	
 *
 ***********************************************************************/

#if 1
void ZeroMBlock(H263_MB_Structure *data)
{
  memset(&(data->lum[0][0]), 0, 768) ;
  return;
}
#else
void ZeroMBlock(H263_MB_Structure *data)
{
  int n;
  register int m;

  for (n = 0; n < H263_MB_SIZE; n++)
    for (m = 0; m < H263_MB_SIZE; m++)
      data->lum[n][m] = 0;
  for (n = 0; n < (H263_MB_SIZE>>1); n++)
    for (m = 0; m < (H263_MB_SIZE>>1); m++) {
      data->Cr[n][m] = 0;
      data->Cb[n][m] = 0;
    }
  return;
}

#endif

/**********************************************************************
 *
 *	Name:		ReconImage
 *	Description:	Puts together reconstructed image
 *	
 *	Input:		position of curr block, reconstructed
 *			macroblock, pointer to recontructed image
 *	Returns:
 *	Side effects:
 *
 ***********************************************************************/
#ifndef USE_C
void ReconImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, H263_PictImage *recon)
{
  unsigned char *ptna, *ptnb;
  int x_curr, y_curr;

  x_curr = i * H263_MB_SIZE;
  y_curr = j * H263_MB_SIZE;

  /* Fill in luminance data */
  ptna  = recon->lum + x_curr + y_curr*H263Info->pels;
  sv_H263ItoC16A_S(&(data->lum[0][0]), ptna, H263Info->pels) ;

  /* Fill in chrominance data */
  ptna = recon->Cr + (x_curr>>1) + (y_curr>>1)*H263Info->cpels;
  ptnb = recon->Cb + (x_curr>>1) + (y_curr>>1)*H263Info->cpels;
  sv_H263ItoC8B_S(&(data->Cr[0][0]), ptna, &(data->Cb[0][0]), ptnb, H263Info->pels/2) ;

  return;
}
#else
void ReconImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, H263_PictImage *recon)
{
  int n;
  register int m;

  int x_curr, y_curr;

  x_curr = i * H263_MB_SIZE;
  y_curr = j * H263_MB_SIZE;

  /* Fill in luminance data */
  for (n = 0; n < H263_MB_SIZE; n++)
    for (m= 0; m < H263_MB_SIZE; m++) {
      *(recon->lum + x_curr+m + (y_curr+n)*H263Info->pels) = (unsigned char)data->lum[n][m];
    }

  /* Fill in chrominance data */
  for (n = 0; n < H263_MB_SIZE>>1; n++)
    for (m = 0; m < H263_MB_SIZE>>1; m++) {
      *(recon->Cr + (x_curr>>1)+m + ((y_curr>>1)+n)*H263Info->cpels) = (unsigned char) data->Cr[n][m];
      *(recon->Cb + (x_curr>>1)+m + ((y_curr>>1)+n)*H263Info->cpels) = (unsigned char) data->Cb[n][m];
    }

  return;
}
#endif
/**********************************************************************
 *
 *	Name:		ReconPredImage
 *	Description:	Puts together prediction error image
 *	
 *	Input:		position of curr block, reconstructed
 *			macroblock, pointer to recontructed image
 *	Returns:
 *	Side effects:
 *
 *  Added by Nuno on 06/27/96 to support filtering of the prediction error
 ***********************************************************************/

#if 1
void ReconPredImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, PredImage *recon)
{
  int n;
  int x_curr, y_curr;
  register short *pta, *ptb, *ptc, *ptd;

  x_curr = i * H263_MB_SIZE;
  y_curr = j * H263_MB_SIZE;

  /* Fill in luminance data */

  pta = recon->lum + x_curr + y_curr * H263Info->pels ;
  ptb = &(data->lum[0][0]) ;
  for (n = 0; n < H263_MB_SIZE; n++){
    memcpy(ptb,pta,32);
	ptb+=H263_MB_SIZE ; pta += H263Info->pels ;
  }

  /* Fill in chrominance data */
  pta = recon->Cr + (x_curr>>1) + (y_curr>>1)*H263Info->cpels ;
  ptb = recon->Cb + (x_curr>>1) + (y_curr>>1)*H263Info->cpels ;
  ptc = &(data->Cr[0][0]) ;
  ptd = &(data->Cb[0][0]) ;
  for (n = 0; n < H263_MB_SIZE>>1; n++){
    memcpy(ptc,pta,16);
    memcpy(ptd,ptb,16);
  	pta += H263Info->cpels; ptc+=H263_MB_SIZE;
	ptb += H263Info->cpels; ptd+=H263_MB_SIZE;
  }

  return;
}
#else
void ReconPredImage(SvH263CompressInfo_t *H263Info, int i, int j, H263_MB_Structure *data, PredImage *recon)
{
  int n;
  register int m;

  int x_curr, y_curr;

  x_curr = i * H263_MB_SIZE;
  y_curr = j * H263_MB_SIZE;

  /* Fill in luminance data */
  for (n = 0; n < H263_MB_SIZE; n++)
    for (m= 0; m < H263_MB_SIZE; m++) {
      *(recon->lum + x_curr+ m + (y_curr + n)*H263Info->pels) = data->lum[n][m];
    }

  /* Fill in chrominance data */
  for (n = 0; n < H263_MB_SIZE>>1; n++)
    for (m = 0; m < H263_MB_SIZE>>1; m++) {
      *(recon->Cr + (x_curr>>1)+m + ((y_curr>>1)+n)*H263Info->cpels) = data->Cr[n][m];
      *(recon->Cb + (x_curr>>1)+m + ((y_curr>>1)+n)*H263Info->cpels) = data->Cb[n][m];
    }
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		InterpolateImage
 *	Description:    Interpolates a complete image for easier half
 *                      pel prediction
 *	
 *	Input:	        pointer to image structure
 *	Returns:        pointer to interpolated image
 *	Side effects:   allocates memory to interpolated image
 *
 ***********************************************************************/
void InterpolateImage(unsigned char *image, unsigned char *ipol_image,
								int width, int height)
{
  register unsigned char *ii, *oo, *ij, *oi;
  int i,j,w2,w4,w1;
  unsigned char tmp1;
#ifdef USE_C
  unsigned char tmp2, tmp3;
#endif

  ii = ipol_image;
  oo = image;

  w2 = (width<<1);
  w4 = (width<<2);
  w1 = width - 1;

  /* main image */
#ifndef USE_C
  for (j = 0; j < height-1; j++) {
    sv_H263Intrpolt_S(oo, ii, oo + width, ii + w2, width) ;
    ii += w4 ;
    oo += width;
  }
#else
  for (j = 0; j < height-1; j++) {
    oi = oo; ij = ii;
    for (i = 0; i < width-1; i++, ij+=2, oi++) {
      *(ij) = (tmp1 = *oi);
      *(ij + 1)  = (tmp1 + (tmp2 = *(oi + 1)) + 1)>>1;
      *(ij + w2) = (tmp1 + (tmp3 = *(oi + width)) + 1)>>1;
      *(ij + 1 + w2) = (tmp1 + tmp2 + tmp3 + *(oi+1+width) + 2)>>2;
    }
    /* last pels on each line */
    *(ii+ w2 -2) = *(ii+ w2 -1) =  *(oo + w1);
    *(ii+ w4 -2) = *(ii+ w4 -1) = (*(oo+w1) + *(oo+width+w1) + 1)>>1;

    ii += w4 ;
    oo += width;
  }
#endif

  /* last lines */
  ij = ii; oi = oo;
  for (i=0; i < width-1; i++, ij+=2, oi++) {
    *ij       = *(ij+ w2) = (tmp1 = *oi );
    *(ij + 1) = *(ij+ w2 + 1) = (tmp1  + *(oi + 1) + 1)>>1;
  }

  /* bottom right corner pels */
  *(ii+w2-2)= *(ii+w2-1) = *(ii+w4-2) = *(ii+w4-1) = *(oo+w1);

  return ;
}

/**********************************************************************
 *
 *	Name:		MotionEstimatePicture
 *	Description:    Finds integer and half pel motion estimation
 *                      and chooses 8x8 or 16x16
 *	
 *	Input:	       current image, previous image, interpolated
 *                     reconstructed previous image, seek_dist,
 *                     motion vector array
 *	Returns:
 *	Side effects: allocates memory for MV structure
 *
 ***********************************************************************/

void MotionEstimatePicture(SvH263CompressInfo_t *H263Info, unsigned char *curr, unsigned char *prev,
			   unsigned char *prev_ipol, int seek_dist,
			   H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int gobsync)
{
  int i,j,k;
  int pmv0,pmv1,xoff,yoff;
  int sad8 = INT_MAX, sad16, sad0;
  int newgob;
  H263_MotionVector *f0,*f1,*f2,*f3,*f4;

  int VARmb;

  void (*MotionEst_Func)(SvH263CompressInfo_t *H263Info,
              unsigned char *curr, unsigned char *prev,
	          int x_curr, int y_curr, int xoff, int yoff, int seek_dist,
		      H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);

  switch(H263Info->ME_method) {
    default:
    case(H263_FULL_SEARCH):
	   MotionEst_Func = sv_H263MotionEstimation;
 	   break;
    case(H263_TWO_LEVELS_7_1):
	   MotionEst_Func = sv_H263ME_2levels_7_1;
 	   break;
    case(H263_TWO_LEVELS_421_1):
	   MotionEst_Func = sv_H263ME_2levels_421_1;
	   break;
    case(H263_TWO_LEVELS_7_polint):
	   MotionEst_Func = sv_H263ME_2levels_7_polint;
	   break;
    case(H263_TWO_LEVELS_7_pihp):
	   MotionEst_Func = sv_H263ME_2levels_7_pihp;
	   break;
  }

  /* Do motion estimation and store result in array */
  for ( j = 0; j < H263Info->mb_height; j++) {

    newgob = 0;
    if (gobsync && j%gobsync == 0) newgob = 1;

    H263Info->VARgob[j] = 0;

    for ( i = 0; i < H263Info->mb_width; i++) {

      /* Integer pel search */
      f0 = MV[0][j+1][i+1];
      f1 = MV[1][j+1][i+1];
      f2 = MV[2][j+1][i+1];
      f3 = MV[3][j+1][i+1];
      f4 = MV[4][j+1][i+1];


      /* NBNB need to use newgob properly as last parameter */
      sv_H263FindPMV(MV,i+1,j+1,&pmv0,&pmv1,0,newgob,0);
      /* Here the PMV's are found using integer motion vectors */
      /* (NB should add explanation for this )*/

      if (H263Info->long_vectors) {
	     xoff = pmv0/2; /* always divisable by two */
	     yoff = pmv1/2;
      }
      else  xoff = yoff = 0;

	  MotionEst_Func(H263Info, curr, prev, i*H263_MB_SIZE, j*H263_MB_SIZE,
			                               xoff, yoff, seek_dist, MV, &sad0);

      sad16 = f0->min_error;
      if (H263Info->advanced)
	    sad8 = f1->min_error + f2->min_error + f3->min_error + f4->min_error;
	
      f0->Mode = (short)sv_H263ChooseMode(H263Info, curr,i*H263_MB_SIZE,j*H263_MB_SIZE,
		                           mmin(sad8,sad16), &VARmb);

      H263Info->VARgob[j] += VARmb;


      /* Half pel search */
      if (f0->Mode != H263_MODE_INTRA) {

	    if(H263Info->advanced) {

#ifndef USE_C
          /* performance Half-Pel Motion Search on 8x8 blocks */
	      sv_H263AdvHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f0,f1,f2,f3,f4,prev_ipol,curr,16,0);
#else
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f0, prev_ipol, curr, 16, 0);
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f1, prev_ipol, curr, 8, 0);
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f2, prev_ipol, curr, 8, 1);
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f3, prev_ipol, curr, 8, 2);
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f4, prev_ipol, curr, 8, 3);
#endif
	      sad16 = f0->min_error;

	      sad8 = f1->min_error +f2->min_error +f3->min_error +f4->min_error;
	      sad8 += H263_PREF_16_VEC;

	      /* Choose Zero Vector, 8x8 or 16x16 vectors */
	      if (sad0 < sad8 && sad0 < sad16) {
	        f0->x = f0->y = 0;
	        f0->x_half = f0->y_half = 0;
	      }
	      else { if (sad8 < sad16) f0->Mode = H263_MODE_INTER4V; }
	    }
	    else {
          /* performance Half-Pel Motion Search on 16 x 16 blocks */
  	      sv_H263FindHalfPel(H263Info, i*H263_MB_SIZE,j*H263_MB_SIZE,f0, prev_ipol, curr, 16, 0);
	      sad16 = f0->min_error;

	      /* Choose Zero Vector or 16x16 vectors */
	      if (sad0 < sad16) {
	        f0->x = f0->y = 0;
	        f0->x_half = f0->y_half = 0;
	      }
	    }
      }
      else for (k = 0; k < 5; k++) sv_H263ZeroVec(MV[k][j+1][i+1]);
    }

    H263Info->VARgob[j] /= (H263Info->mb_width);
  }

#ifdef PRINTMV
  fprintf(stdout,"Motion estimation\n");
  fprintf(stdout,"16x16 vectors:\n");

  for ( j = 0; j < H263Info->mb_height; j++) {
    for ( i = 0; i < H263Info->pels/H263_MB_SIZE; i++) {
      if (MV[0][j+1][i+1]->Mode != H263_MODE_INTRA)
	fprintf(stdout," %3d%3d",
		2*MV[0][j+1][i+1]->x + MV[0][j+1][i+1]->x_half,
		2*MV[0][j+1][i+1]->y + MV[0][j+1][i+1]->y_half);
      else
	fprintf(stdout,"  .  . ");
    }
    fprintf(stdout,"\n");
  }
  if (H263Info->advanced) {
    fprintf(stdout,"8x8 vectors:\n");
    for (k = 1; k < 5; k++) {
      fprintf(stdout,"Block: %d\n", k-1);
      for ( j = 0; j < H263Info->lines/H263_MB_SIZE; j++) {
	for ( i = 0; i < H263Info->pels/H263_MB_SIZE; i++) {
	  if (MV[0][j+1][i+1]->Mode != H263_MODE_INTRA)
	    fprintf(stdout," %3d%3d",
		    2*MV[k][j+1][i+1]->x + MV[k][j+1][i+1]->x_half,
		    2*MV[k][j+1][i+1]->y + MV[k][j+1][i+1]->y_half);
	  else
	    fprintf(stdout,"  .  . ");
	}
	fprintf(stdout,"\n");
      }
    }
  }
#endif
  return;
}

/**********************************************************************
 *
 *	Name:		MakeEdgeImage
 *	Description:    Copies edge pels for use with unrestricted
 *                      motion vector mode
 *	
 *	Input:	        pointer to source image, destination image
 *                      width, height, edge
 *	Returns:
 *	Side effects:
 *
 ***********************************************************************/

void MakeEdgeImage(unsigned char *src, unsigned char *dst, int width,
		   int height, int edge)
{
  int j;
  unsigned char *p1,*p2,*p3,*p4;
  unsigned char *o1,*o2,*o3,*o4;
  int off, off1, off2;
  unsigned char t1, t2, t3, t4 ;

  /* center image */
  p1 = dst;
  o1 = src;
  off = (edge<<1);
  for (j = 0; j < height;j++) {
    memcpy(p1,o1,width);
    p1 += width + off;
    o1 += width;
  }

  /* left and right edges */
  p1 = dst-1;
  o1 = src;
  off1 = width + 1 ; off2 = width - 1 ;
  for (j = 0; j < height;j++) {
    t1 = *o1 ; t2 = *(o1 + off2);
    memset(p1-edge+1,t1,edge);
    memset(p1+off1,t2,edge);
    p1 += width + off;
    o1 += width;
  }

  /* top and bottom edges */
  p1 = dst;
  p2 = dst + (width + (edge<<1))*(height-1);
  o1 = src;
  o2 = src + width*(height-1);
  off = width + (edge<<1) ;
  for (j = 0; j < edge;j++) {
    p1 -= off;
    p2 += off;
    memcpy(p1,o1,width);
    memcpy(p2,o2,width);
  }

  /* corners */
  p1 = dst - (width+(edge<<1)) - 1;
  p2 = p1 + width + 1;
  p3 = dst + (width+(edge<<1))*(height)-1;
  p4 = p3 + width + 1;

  o1 = src;
  o2 = o1 + width - 1;
  o3 = src + width*(height-1);
  o4 = o3 + width - 1;
  t1 = *o1; t2 = *o2; t3 = *o3; t4 = *o4;
  for (j = 0; j < edge; j++) {
    memset(p1-edge+1,t1,edge);
    memset(p2,t2,edge);
    memset(p3-edge+1,t3,edge);
    memset(p4,t4,edge);
    p1 -= off;
    p2 -= off;
    p3 += off;
    p4 += off;
  }
}


/**********************************************************************
 *
 *	Name:		Clip
 *	Description:    clips recontructed data 0-255
 *	
 *	Input:	        pointer to recon. data structure
 *	Side effects:   data structure clipped
 *
 ***********************************************************************/
void sv_H263Clip(H263_MB_Structure *data)
{
#ifdef USE_C
  int m,n;

  for (n = 0; n < 16; n++) {
    for (m = 0; m < 16; m++) {
      data->lum[n][m] = mmin(255,mmax(0,data->lum[n][m]));
    }
  }
  for (n = 0; n < 8; n++) {
    for (m = 0; m < 8; m++) {
      data->Cr[n][m] = mmin(255,mmax(0,data->Cr[n][m]));
      data->Cb[n][m] = mmin(255,mmax(0,data->Cb[n][m]));
    }
  }
#else
  sv_H263Clp_S(&(data->lum[0][0]), 16);
  sv_H263Clp_S(&(data->Cr[0][0]),   4);
  sv_H263Clp_S(&(data->Cb[0][0]),   4);
#endif
}

#ifdef _SLIBDEBUG_
/**********************************************************************
 *
 *	Description:    calculate SNR
 *
 ***********************************************************************/

static int frame_id=0;
static float avg_SNR_l=0.0F, avg_SNR_Cr=0.0F, avg_SNR_Cb=0.0F;

void ComputeSNR(SvH263CompressInfo_t *H263Info,
				H263_PictImage *im1, H263_PictImage *im2,
				int lines, int pels)
{
  int n;
  register int m;
  int quad, quad_Cr, quad_Cb, diff;
  float SNR_l, SNR_Cr, SNR_Cb;

#if _WRITE_
  if (!frame_id) DEBUGIMG = ScFileOpenForWriting("DEBUG.IMG", TRUE);
#endif

  quad = 0;
  quad_Cr = quad_Cb = 0;
  /* Luminance */
  quad = 0;
  for (n = 0; n < lines; n++)
    for (m = 0; m < pels; m++) {
      diff = *(im1->lum + m + n*pels) - *(im2->lum + m + n*pels);
      quad += diff * diff;
    }

  SNR_l = (float)quad/(float)(pels*lines);
  if (SNR_l) {
    SNR_l = (float)(255*255) / SNR_l;
    SNR_l = (float)(10 * log10(SNR_l));
  }
  else SNR_l = (float) 99.99;

  ScDebugPrintf(H263Info->dbg, "\n Frame %d : SNR of LUM = %f",frame_id++,SNR_l);

  /* Chrominance */
  for (n = 0; n < lines/2; n++)
    for (m = 0; m < pels/2; m++) {
      quad_Cr += (*(im1->Cr+m + n*pels/2) - *(im2->Cr + m + n*pels/2)) *
	(*(im1->Cr+m + n*pels/2) - *(im2->Cr + m + n*pels/2));
      quad_Cb += (*(im1->Cb+m + n*pels/2) - *(im2->Cb + m + n*pels/2)) *
	(*(im1->Cb+m + n*pels/2) - *(im2->Cb + m + n*pels/2));
    }

  SNR_Cr = (float)quad_Cr/(float)(pels*lines/4);
  if (SNR_Cr) {
    SNR_Cr = (float)(255*255) / SNR_Cr;
    SNR_Cr = (float)(10 * log10(SNR_Cr));
  }
  else SNR_Cr = (float) 99.99;

  SNR_Cb = (float)quad_Cb/(float)(pels*lines/4);
  if (SNR_Cb) {
    SNR_Cb = (float)(255*255) / SNR_Cb;
    SNR_Cb = (float)(10 * log10(SNR_Cb));
  }
  else SNR_Cb = (float)99.99;

  ScDebugPrintf(H263Info->dbg, "SNR of Cr = %f Cb = %f \n",SNR_Cr, SNR_Cb);

  avg_SNR_l += SNR_l;
  avg_SNR_Cb += SNR_Cb;
  avg_SNR_Cr += SNR_Cr;

  ScDebugPrintf(H263Info->dbg, "AVG_SNR: lum %f Cr %f Cb %f\n",
	             avg_SNR_l/(float)frame_id,
				 avg_SNR_Cr/(float)frame_id,
				 avg_SNR_Cb/(float)frame_id);

#if _WRITE_
    ScFileWrite(DEBUGIMG, im1->lum, pels*lines);
    ScFileWrite(DEBUGIMG, im1->Cb, pels*lines/4);
    ScFileWrite(DEBUGIMG, im1->Cr, pels*lines/4);
#endif

  return;
}
#endif /* _SLIBDEBUG_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\gethdr.c ===
/* File: sv_h263_gethdr.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
void *dbg=NULL;
#endif

/* private prototypes */
static void getpicturehdr(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);

/*
 * decode headers from one input stream
 * until an End of Sequence or picture start code
 * is found
 */

SvStatus_t sv_H263GetHeader(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int *pgob)
{
  unsigned int code, gob;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263GetHeader() In: bytespos=%ld, EOI=%d\n",
                            ScBSBytePosition(BSIn), BSIn->EOI) );
#ifdef _SLIBDEBUG_
  dbg=H263Info->dbg;
#endif
  /* look for startcode */
  if (sv_H263StartCode(BSIn)!=SvErrorNone) 
    return(SvErrorEndBitstream);

  code = (unsigned int)ScBSGetBits(BSIn, H263_PSC_LENGTH);
  gob = (unsigned int)ScBSGetBits(BSIn, 5);
  if (gob == H263_SE_CODE) 
    return 0;
  if (gob == 0) {
    getpicturehdr(H263Info, BSIn);
    if (H263Info->syntax_arith_coding)        /* reset decoder after receiving */
      sv_H263SACDecoderReset(BSIn);	        /* fixed length PSC string */
  }
  if (pgob)
    *pgob=gob;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263GetHeader() Out: bytespos=%ld, EOI=%d, gob=%d\n",
                            ScBSBytePosition(BSIn), BSIn->EOI, gob) );
  return(SvErrorNone); /*  return gob + 1; */
}


/* align to start of next startcode */

SvStatus_t sv_H263StartCode(ScBitstream_t *BSIn)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263StartCode() In: bytespos=%ld, EOI=%d\n",
                            ScBSBytePosition(BSIn), BSIn->EOI) );
  /* search for new picture start code */
  while (ScBSPeekBits(BSIn, H263_PSC_LENGTH)!=1l && !BSIn->EOI) 
         ScBSSkipBit(BSIn);
  _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263StartCode() Out:  bytespos=%ld, EOI=%d\n",
                            ScBSBytePosition(BSIn), BSIn->EOI) );
  if (BSIn->EOI) return(SvErrorEndBitstream);
  return(SvErrorNone);
}

/* decode picture header */

static void getpicturehdr(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  ScBSPosition_t pos;
  int pei, tmp;
  static int prev_temp_ref; /* Burkhard */

  pos = ScBSBitPosition(BSIn);
  prev_temp_ref = H263Info->temp_ref;
  H263Info->temp_ref = (int)ScBSGetBits(BSIn, 8);
  H263Info->trd = (int)H263Info->temp_ref - prev_temp_ref;

  if (H263Info->trd < 0)
    H263Info->trd += 256;

  tmp = ScBSGetBit(BSIn); /* always "1" */
  if (!tmp)
    if (!H263Info->quiet)
      printf("warning: spare in picture header should be \"1\"\n");
  tmp = ScBSGetBit(BSIn); /* always "0" */
  if (tmp)
    if (!H263Info->quiet)
      printf("warning: H.261 distinction bit should be \"0\"\n");

  tmp = ScBSGetBit(BSIn);  

  if (tmp) {
    if (!H263Info->quiet)
      printf("error: split-screen not supported in this version\n");
    exit (-1);
  }
  tmp = ScBSGetBit(BSIn); /* document_camera_indicator */
  if (tmp)
    if (!H263Info->quiet)
      printf("warning: document camera indicator not supported in this version\n");

  tmp = ScBSGetBit(BSIn); /* freeze_picture_release */
  if (tmp)
    if (!H263Info->quiet)
      printf("warning: frozen picture not supported in this version\n");

  H263Info->source_format = (int)ScBSGetBits(BSIn, 3);
  H263Info->pict_type = ScBSGetBit(BSIn);
  H263Info->mv_outside_frame = ScBSGetBit(BSIn);
  H263Info->long_vectors = (H263Info->mv_outside_frame ? 1 : 0);
  H263Info->syntax_arith_coding = ScBSGetBit(BSIn);
  H263Info->adv_pred_mode = ScBSGetBit(BSIn);
  H263Info->mv_outside_frame = (H263Info->adv_pred_mode ? 1 : H263Info->mv_outside_frame);
  H263Info->pb_frame = ScBSGetBit(BSIn);
  H263Info->quant = (int)ScBSGetBits(BSIn, 5);
  tmp = ScBSGetBit(BSIn);
  if (tmp) {
    if (!H263Info->quiet)
      printf("error: CPM not supported in this version\n");
    exit(-1);
  }

  if (H263Info->pb_frame) {
    H263Info->trb = (int)ScBSGetBits(BSIn, 3);
    H263Info->bquant = (int)ScBSGetBits(BSIn, 2);
  }

/* Burkhard
  else {
    trb = 0;
  }
*/

  pei = ScBSGetBit(BSIn);
pspare:
  if (pei) {
     /* extra info for possible future backward compatible additions */
    ScBSGetBits(BSIn, 8);  /* not used */
    pei = ScBSGetBit(BSIn);
    if (pei) goto pspare; /* keep on reading pspare until pei=0 */
  }

  _SlibDebug(_VERBOSE_,
      ScDebugPrintf(dbg, "******picture header (byte %d)******\n",(pos>>3)-4);
      ScDebugPrintf(dbg, "  temp_ref=%d\n",H263Info->temp_ref);
      ScDebugPrintf(dbg, "  pict_type=%d\n",H263Info->pict_type);
      ScDebugPrintf(dbg, "  source_format=%d\n", H263Info->source_format);
      ScDebugPrintf(dbg, "  quant=%d\n",H263Info->quant);
      if (H263Info->syntax_arith_coding) 
        ScDebugPrintf(dbg, "  SAC coding mode used \n");
      if (H263Info->mv_outside_frame)
        ScDebugPrintf(dbg, "  unrestricted motion vector mode used\n");
      if (H263Info->adv_pred_mode)
        ScDebugPrintf(dbg, "  advanced prediction mode used\n");
      if (H263Info->pb_frame)
      {
        ScDebugPrintf(dbg, "  pb-frames mode used\n");
        ScDebugPrintf(dbg, "  trb=%d\n",H263Info->trb);
        ScDebugPrintf(dbg, "  bquant=%d\n", H263Info->bquant);
      }
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\getpic.c ===
/* File: sv_h263_getpic.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

/* private prototypes*/
static void getMBs(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
static void clearblock(SvH263DecompressInfo_t *H263Info, int comp);
static int motion_decode(SvH263DecompressInfo_t *H263Info, int vec, int pmv);
static int find_pmv(SvH263DecompressInfo_t *H263Info, int x, int y, int block, int comp);
static void addblock(SvH263DecompressInfo_t *H263Info, int comp, int bx, int by, int addflag);
static void reconblock_b(SvH263DecompressInfo_t *H263Info, int comp, int bx, int by,
                                                           int mode, int bdx, int bdy);
static void find_bidir_limits(int vec, int *start, int*stop, int nhv);
static void find_bidir_chroma_limits(int vec, int *start, int*stop);
static void make_edge_image(unsigned char *src, unsigned char *dst, int width, int height, int edge);
void interpolate_image(unsigned char *in, unsigned char *out, int width, int height);

static void IDCT_add(int comp,int bx,int by,int addflag) ;

static int H263_roundtab[16]= {0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2};

static int H263_codtab[2]= {0,1};
static int H263_mcbpctab[21] = {0,16,32,48,1,17,33,49,2,18,34,50,3,19,35,51,4,20,36,52,255};
static int H263_mcbpc_intratab[9] = {3,19,35,51,4,20,36,52,255};
static int H263_modb_tab[3] = {0, 1, 2};
static int H263_ycbpb_tab[2] = {0, 1};
static int H263_uvcbpb_tab[2] = {0, 1};
static int H263_cbpytab[16] = {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0};
static int H263_cbpy_intratab[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
static int H263_dquanttab[4] = {1,0,3,4};
static int H263_mvdtab[64] = {32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};
static int H263_intradctab[254] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,255,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254};

static int H263_cumf_COD[3]={16383, 6849, 0};
static int H263_cumf_MCBPC[22]={16383, 4105, 3088, 2367, 1988, 1621, 1612, 1609, 1608, 496, 353, 195, 77, 22, 17, 12, 5, 4, 3, 2, 1, 0};
static int H263_cumf_MCBPC_intra[10]={16383, 7410, 6549, 5188, 442, 182, 181, 141, 1, 0};
static int H263_cumf_MODB[4]={16383, 6062, 2130, 0};
static int H263_cumf_YCBPB[3]={16383,6062,0};
static int H263_cumf_UVCBPB[3]={16383,491,0};
static int H263_cumf_CBPY[17]={16383, 14481, 13869, 13196, 12568, 11931, 11185, 10814, 9796, 9150, 8781, 7933, 6860, 6116, 4873, 3538, 0};
static int H263_cumf_CBPY_intra[17]={16383, 13619, 13211, 12933, 12562, 12395, 11913, 11783, 11004, 10782, 10689, 9928, 9353, 8945, 8407, 7795, 0};
static int H263_cumf_DQUANT[5]={16383, 12287, 8192, 4095, 0};
static int H263_cumf_MVD[65]={16383, 16380, 16369, 16365, 16361, 16357, 16350, 16343, 16339, 16333, 16326, 16318, 16311, 16306, 16298, 16291, 16283, 16272, 16261, 16249, 16235, 16222, 16207, 16175, 16141, 16094, 16044, 15936, 15764, 15463, 14956, 13924, 11491, 4621, 2264, 1315, 854, 583, 420, 326, 273, 229, 196, 166, 148, 137, 123, 114, 101, 91, 82, 76, 66, 59, 53, 46, 36, 30, 26, 24, 18, 14, 10, 5, 0};
static int H263_cumf_INTRADC[255]={16383, 16380, 16379, 16378, 16377, 16376, 16370, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16343, 16238, 16237, 16236, 16230, 16221, 16220, 16205, 16190, 16169, 16151, 16130, 16109, 16094, 16070, 16037, 16007, 15962, 15938, 15899, 15854, 15815, 15788, 15743, 15689, 15656, 15617, 15560, 15473, 15404, 15296, 15178, 15106, 14992, 14868, 14738, 14593, 14438, 14283, 14169, 14064, 14004, 13914, 13824, 13752, 13671, 13590, 13515, 13458, 13380, 13305, 13230, 13143, 13025, 12935, 12878, 12794, 12743, 12656, 12596, 12521, 12443, 12359, 12278, 12200, 12131, 12047, 12002, 11948, 11891, 11828, 11744, 11663, 11588, 11495, 11402, 11288, 11204, 11126, 11039, 10961, 10883, 10787, 10679, 10583, 10481, 10360, 10227, 10113, 9961, 9828, 9717, 9584, 9485, 9324, 9112, 9019, 8908, 8766, 8584, 8426, 8211, 7920, 7663, 7406, 7152, 6904, 6677, 6453, 6265, 6101, 5904, 5716, 5489, 5307, 5056, 4850, 4569, 4284, 3966, 3712, 3518, 3342, 3206, 3048, 2909, 2773, 2668, 2596, 2512, 2370, 2295, 2232, 2166, 2103, 2022, 1956, 1887, 1830, 1803, 1770, 1728, 1674, 1635, 1599, 1557, 1500, 1482, 1434, 1389, 1356, 1317, 1284, 1245, 1200, 1179, 1140, 1110, 1092, 1062, 1044, 1035, 1014, 1008, 993, 981, 954, 936, 912, 894, 876, 864, 849, 828, 816, 801, 792, 777, 756, 732, 690, 660, 642, 615, 597, 576, 555, 522, 489, 459, 435, 411, 405, 396, 387, 375, 360, 354, 345, 344, 329, 314, 293, 278, 251, 236, 230, 224, 215, 214, 208, 199, 193, 184, 178, 169, 154, 127, 100, 94, 73, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 20, 19, 18, 17, 16, 15, 9, 0};

#define clearblk(comp) memset(H263Info->block[comp], 0, sizeof(int [66]));

/* decode one frame or field picture */

SvStatus_t sv_H263GetPicture(SvCodecInfo_t *Info)
{
  int i;
  unsigned char *tmp;
  SvH263DecompressInfo_t *H263Info = Info->h263dcmp;
  ScBitstream_t *BSIn=Info->BSIn;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263GetPicture()\n") );
  for (i=0; i<3; i++) {
    tmp = H263Info->oldrefframe[i];
    H263Info->oldrefframe[i] = H263Info->refframe[i];
    H263Info->refframe[i] = tmp;
    H263Info->newframe[i] = H263Info->refframe[i];
  }

  if (H263Info->mv_outside_frame && H263Info->framenum > 0) {
    make_edge_image(H263Info->oldrefframe[0],H263Info->edgeframe[0],H263Info->coded_picture_width,
            H263Info->coded_picture_height,32);
    make_edge_image(H263Info->oldrefframe[1],H263Info->edgeframe[1],H263Info->chrom_width, H263Info->chrom_height,16);
    make_edge_image(H263Info->oldrefframe[2],H263Info->edgeframe[2],H263Info->chrom_width, H263Info->chrom_height,16);
  }
  getMBs(H263Info, BSIn);

  if (H263Info->pb_frame) {
    if (H263Info->expand && H263Info->outtype == H263_T_X11) {
      interpolate_image(H263Info->bframe[0], H263Info->exnewframe[0],
        H263Info->coded_picture_width, H263Info->coded_picture_height);
      interpolate_image(H263Info->bframe[1], H263Info->exnewframe[1], H263Info->chrom_width, H263Info->chrom_height);
      interpolate_image(H263Info->bframe[2], H263Info->exnewframe[2], H263Info->chrom_width, H263Info->chrom_height);

      /* svH263Storeframe(H263Info->exnewframe, *framenum); */
    }
    else
      /* svH263Storeframe(H263Info->bframe,*framenum); */

    H263Info->framenum += H263Info->pb_frame;
  }

  if (H263Info->expand && H263Info->outtype == H263_T_X11) {
    interpolate_image(H263Info->newframe[0], H263Info->exnewframe[0],
              H263Info->coded_picture_width, H263Info->coded_picture_height);
    interpolate_image(H263Info->newframe[1], H263Info->exnewframe[1], H263Info->chrom_width, H263Info->chrom_height);
    interpolate_image(H263Info->newframe[2], H263Info->exnewframe[2], H263Info->chrom_width, H263Info->chrom_height);

    /* svH263Storeframe(H263Info->exnewframe, *framenum); */
  }
  else {
    /* svH263Storeframe(H263Info->newframe,*framenum); */
  }
  return(SvErrorNone);
}


/* decode all macroblocks of the current picture */

#ifdef CAMERAMOTION
extern void setwintitle(char *);

#define MOVERIGHT (1<<0)
#define MOVELEFT  (1<<1)
#define MOVEUP    (1<<2)
#define MOVEDOWN  (1<<3)

static int left_x,left_y;
static int top_x,top_y;
static int right_x,right_y;
static int bottom_x,bottom_y;
static int center_x,center_y;
static int strip_width = 3;

static int framewidth;
static int frameheight;

static int startoff;
static int filtermean,havecut;
static int loopstart = 0;
static int loopend;
static int scenenumber = 1;


static void initmotion(int width,int height)
{
  left_x = left_y = 0;
  right_x = right_y = 0;
  bottom_x = bottom_y = 0;
  top_x = top_y = 0;
  center_x = center_y = 0;

  framewidth = width;
  frameheight = height;
  startoff = svH263Tellbits();
}

static void analyzemotion(int xpos,int ypos,int mvx,int mvy)
{
  /* Count Motion Vectors for 4 overlapping strips at the edges */
  /* and the center area between them */
  if (xpos < strip_width) {		/* Left strip */
    left_x += mvx;
    left_y += mvy;
  }
  if (xpos >= (framewidth - strip_width)) {	/* Right strip */
    right_x += mvx;
    right_y += mvy;
  }
  if (ypos < strip_width) {		/* Top strip */
    top_x += mvx;
    top_y += mvy;
  }
  if (ypos >= (frameheight - strip_width)) {	/* Bottom strip */
    bottom_x += mvx;
    bottom_y += mvy;
  }
  if (xpos >=  strip_width && xpos < (framewidth - strip_width)
	&& ypos >= strip_width && ypos < (frameheight - strip_width)) {
    center_x += mvx;
    center_y += mvy;
  }
}

static int last_movement = 0;
static int keepdirection = 15;
static int movestartframe = 0;
static int moveendframe;
static int movesumx;
static int movesumy;

static void summarizemotion(int frameno)
{
  int threshold = 8;
  int striparea;
  int sx,sy;
  char title[128];
  int cur_movement = 0;
  int framesize;


  title[0] = 0;

  framesize = svH263Tellbits() - startoff;
  if (frameno < 1) {
     filtermean = framesize/2;
     havecut = 1;
  } else {
     filtermean = (4*filtermean + framesize)/5;
  }
  if (!havecut && framesize > 1.8 * filtermean && frameno > 5) {
      if (!last_movement) {
	printf("dump %d\n",movestartframe + ((moveendframe-movestartframe)/2));
      }
      printf("mark %d %d %d %d\n",scenenumber,loopstart,frameno-1,filtermean);
      printf("shot %d %d %d\n",scenenumber,loopstart,frameno-1);
      movestartframe = frameno;
      loopstart = frameno;
      havecut = 1;
      scenenumber++;
  } else {
      havecut = 0;
  }
  striparea = strip_width * framewidth;
  top_x = (top_x*10)/striparea;
  top_y = (top_y*10)/striparea;
  bottom_x = (bottom_x*10)/striparea;
  bottom_y = (bottom_y*10)/striparea;

  striparea = strip_width * frameheight;
  left_x = (left_x*10)/striparea;
  left_y = (left_y*10)/striparea;
  right_x = (right_x*10)/striparea;
  right_y = (right_y*10)/striparea;

  striparea = (framewidth - 2 * strip_width) * (frameheight - 2 * strip_width);
  center_x = (center_x*10)/striparea;
  center_y = (center_y*10)/striparea;

  /* Horizontal left motion */
  if (top_x < -threshold && bottom_x < -threshold
	&& right_x < -threshold && left_x < -threshold) {
	strcat(title,"Left ");
	cur_movement |= MOVELEFT;
  }
  /* Horizontal right motion */
  if (top_x > threshold && bottom_x > threshold
	&& left_x >  threshold && right_x > threshold) {
	strcat(title,"Right ");
	cur_movement |= MOVERIGHT;
  }
  /* Vertical up motion */
  if (left_y < -threshold && right_y < -threshold
	&& top_y < -threshold && bottom_y < -threshold) {
	strcat(title,"Up");
	cur_movement |= MOVEUP;
  }
  /* Vertical down motion */
  if (left_y > threshold && right_y > threshold
	 && bottom_y >  threshold && top_y > threshold) {
	strcat(title,"Down ");
	cur_movement |= MOVEDOWN;
  }

  if (last_movement) {
    movesumx += (top_x + bottom_x + right_x +left_x)/4;
    movesumy += (top_y + bottom_y + right_y +left_y)/4;
  }
  if (!cur_movement != !last_movement) {	/* Possible movement change */
    if (--keepdirection < 0) {	/* Seen move several times */
      keepdirection = 10;
      if (last_movement) {	/* Have been in a move */
	int movelength;
	int i,images,fno;

	movesumx = movesumx/(16*framewidth);
	movesumy = movesumy/(16*frameheight);
	movelength = moveendframe - movestartframe;
	if (movelength > 25) {
	  images = ((abs(movesumx) + abs(movesumy)) / 5) + 1;
	  fno = movestartframe + movelength/(2*images);
	  for (i = 0; i < images; i++) {
	   printf("dump %d\n",fno);
	   fno += movelength/images;
	  }
	}
      } else {		/* Last part was fixed */
	if (havecut) {
		/* Do nothing, was already handled */
        } else {
          printf("dump %d\n",movestartframe + ((moveendframe-movestartframe)/2));
          movestartframe = frameno;
        }
      }
      movesumx = 0;
      movesumy = 0;
      movestartframe = moveendframe+1;
      last_movement = cur_movement;
      if (H263Info->outtype == H263_T_X11) {
        if (title[0] != 0) {
          setwintitle(title);
        } else {
          setwintitle("fixed");
        }
      }
    }
  } else {
    moveendframe = frameno;
  }
  fflush(stdout);
}
#endif /* CAMERAMOTION */



static void getMBs(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int comp;
  int MBA, MBAmax;
  int bx, by;

  int COD=0,MCBPC, CBPY, CBP=0, CBPB=0, MODB=0, Mode=0, DQUANT;
  int COD_index, CBPY_index, MODB_index, DQUANT_index, MCBPC_index;
  int INTRADC_index, YCBPB_index, UVCBPB_index, mvdbx_index, mvdby_index;
  int mvx, mvy, mvy_index, mvx_index, pmv0, pmv1, xpos, ypos, gob, i,k;
  int mvdbx=0, mvdby=0, pmvdbx, pmvdby, gfid, YCBPB, UVCBPB, gobheader_read;
  int startmv,stopmv,offset,bsize,last_done=0,pCBP=0,pCBPB=0,pCOD=0;
  int DQ_tab[4] = {-1,-2,1,2};

  register int *bp;

  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs()\n") );
  /* number of macroblocks per picture */
  MBAmax = H263Info->mb_width*H263Info->mb_height;

  MBA = 0; /* macroblock address */
  H263Info->newgob = 0;

  /* mark MV's above the picture */
  for (i = 1; i < H263Info->mb_width+1; i++) {
    for (k = 0; k < 5; k++) {
      H263Info->MV[0][k][0][i] = H263_NO_VEC;
      H263Info->MV[1][k][0][i] = H263_NO_VEC;
    }
    H263Info->modemap[0][i] = H263_MODE_INTRA;
  }
  /* zero MV's on the sides of the picture */
  for (i = 0; i < H263Info->mb_height+1; i++) {
    for (k = 0; k < 5; k++) {
      H263Info->MV[0][k][i][0] = 0;
      H263Info->MV[1][k][i][0] = 0;
      H263Info->MV[0][k][i][H263Info->mb_width+1] = 0;
      H263Info->MV[1][k][i][H263Info->mb_width+1] = 0;
    }
    H263Info->modemap[i][0] = H263_MODE_INTRA;
    H263Info->modemap[i][H263Info->mb_width+1] = H263_MODE_INTRA;
  }

  H263Info->fault = 0;
  gobheader_read = 0;

  for (;;) {

    _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "frame %d, MB %d,  bytepos=%ld\n",
                                     H263Info->framenum,MBA,ScBSBytePosition(BSIn)) );
    /* if (MBA>15) return; */
  resync:

    /* This version of the decoder does not resync on every possible
       error, and it does not do all possible error checks. It is not
       difficult to make it much more error robust, but I do not think
       it is necessary to include this in the freely available
       version. */

    if (H263Info->fault) {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() fault\n") );
      printf("Warning: A Fault Condition Has Occurred - Resyncing \n");
      /* look for startcode */
      if (sv_H263StartCode(BSIn)!=SvErrorNone) /* sync on new startcode */
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() couldn't get startcode\n") );
        return;
      }

      H263Info->fault = 0;
    }

    if (!(ScBSPeekBits(BSIn, 22)>>6)) { /* startcode */
      if (sv_H263StartCode(BSIn)!=SvErrorNone) /* sync on new startcode */
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() couldn't get startcode\n") );
        return;
      }

      /* in case of byte aligned start code, ie. PSTUF, GSTUF or ESTUF
         is used */

      if (ScBSPeekBits(BSIn, 22) == (32|H263_SE_CODE)) { /* end of sequence */
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() end of sequence\n") );
        if (!(H263Info->syntax_arith_coding && MBA < MBAmax))
        {
          return;
        }
      }
      else if ((ScBSPeekBits(BSIn, 22) == H263_PSC<<5) ) { /* new picture */
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() new picture code, bytepos=%ld\n",
                                           ScBSBytePosition(BSIn)) );
        if (!(H263Info->syntax_arith_coding && MBA < MBAmax)) {
#ifdef CAMERAMOTION
     goto summarize_motion;
#else
          return;
#endif
        }
      }
      else {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() new group code, bytepos=%ld\n",
                                           ScBSBytePosition(BSIn)) );
        if (!(H263Info->syntax_arith_coding && MBA%H263Info->mb_width)) {

          if (H263Info->syntax_arith_coding) {   /* SAC hack to finish GOBs which   */
            gob = (int)(ScBSPeekBits(BSIn, 22) & 31); /* end with MBs coded with no bits */
            if (gob * H263Info->mb_width != MBA)
            {
              _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() goto finish_gob\n") );
              goto finish_gob;
            }
          }

          if (sv_H263GetHeader(H263Info, BSIn, &gob)!=SvErrorNone)
          {
            _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() GetHeader failed\n") );
            return;
          }
          /* gob--; */
          if (gob > H263Info->mb_height) {
              _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() GN out of range: gob=%d\n", gob) );
            return;
          }

          /* GFID is not allowed to change unless PTYPE in picture header
             changes */
          gfid = (int)ScBSGetBits(BSIn, 2);
          /* NB: in error-prone environments the decoder can use this
             value to determine whether a picture header where the PTYPE
             has changed, has been lost */

          H263Info->quant = (int)ScBSGetBits(BSIn, 5);
          _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() GQUANT=%d gob=%d\n",
                                      H263Info->quant, gob) );
          xpos = 0;
          ypos = gob;
          MBA = ypos * H263Info->mb_width;

          H263Info->newgob = 1;
          gobheader_read = 1;
          if (H263Info->syntax_arith_coding)
            sv_H263SACDecoderReset(BSIn);	/* init. arithmetic decoder buffer after gob */
        }
      }
    }

  finish_gob:  /* SAC specific label */

    if (!gobheader_read) {
      xpos = MBA%H263Info->mb_width;
      ypos = MBA/H263Info->mb_width;
      if (xpos == 0 && ypos > 0)
        H263Info->newgob = 0;
    }
    else
      gobheader_read = 0;

    if (MBA>=MBAmax)
    {
#ifdef CAMERAMOTION
      goto summarize_motion;
#else
      _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() done MBA=%d\n", MBA) );
      return; /* all macroblocks decoded */
#endif
    }
  read_cod:
    if (H263Info->syntax_arith_coding) {
      if (H263Info->pict_type == H263_PCT_INTER) {
        COD_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_COD);
        COD = H263_codtab[COD_index];
        _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
            "getMBs() Arithmetic Decoding, COD Index: %d COD: %d \n", COD_index, COD) );
      }
      else
        COD = 0;  /* COD not used in I-pictures, set to zero */
    }
    else {
      if (H263Info->pict_type == H263_PCT_INTER)
        COD = (int)ScBSPeekBits(BSIn, 1);
      else
        COD = 0; /* Intra picture -> not skipped */
    }

    if (!COD) {  /* COD == 0 --> not skipped */
      if (H263Info->syntax_arith_coding)  {
        if (H263Info->pict_type == H263_PCT_INTER) {
          MCBPC_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MCBPC);
          MCBPC = H263_mcbpctab[MCBPC_index];
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
              "getMBs() (arith/inter) MCBPC Index: %ld MCBPC: %d \n",MCBPC_index, MCBPC) );
        }	
        else {
          int lastMCBPC=MCBPC;
          MCBPC_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MCBPC_intra);
          MCBPC = H263_mcbpc_intratab[MCBPC_index];
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
              "getMBs() (arith) MCBPC Index: %ld MCBPC: %d \n",MCBPC_index, MCBPC) );
          if (MCBPC==255 && lastMCBPC==255)
            return;
        }
      }
      else {
        if (H263Info->pict_type == H263_PCT_INTER)
          ScBSSkipBit(BSIn); /* flush COD bit */
        if (H263Info->pict_type == H263_PCT_INTRA)
          MCBPC = sv_H263GetMCBPCintra(H263Info, BSIn);
        else
          MCBPC = sv_H263GetMCBPC(H263Info, BSIn);
        _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
            "getMBs() MCBPC: %d \n", MCBPC) );
      }

      if (H263Info->fault) goto resync;

      if (MCBPC == 255) { /* stuffing */
        goto read_cod;   /* read next COD without advancing MB count */
      }

      else {             /* normal MB data */

        Mode = MCBPC & 7;

        /* MODB and CBPB */
        if (H263Info->pb_frame) {
          CBPB = 0;
          if (H263Info->syntax_arith_coding)  {
            MODB_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MODB);
            MODB = H263_modb_tab[MODB_index];
          }
          else
            MODB = sv_H263GetMODB(H263Info, BSIn);
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() MODB: %d\n", MODB) );
          if (MODB == H263_PBMODE_CBPB_MVDB) {
            if (H263Info->syntax_arith_coding)  {
              for(i=0; i<4; i++) {
        YCBPB_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_YCBPB);
        YCBPB = H263_ycbpb_tab[YCBPB_index];
        CBPB |= (YCBPB << (6-1-i));
              }

              for(i=4; i<6; i++) {
        UVCBPB_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_UVCBPB);
        UVCBPB = H263_uvcbpb_tab[UVCBPB_index];
        CBPB |= (UVCBPB << (6-1-i));
              }
            }
            else
              CBPB = (int)ScBSGetBits(BSIn, 6);
            _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() CBPB = %d\n",CBPB) );
          }
        }

        if (H263Info->syntax_arith_coding) {

          if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */
            CBPY_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_CBPY_intra);
            CBPY = H263_cbpy_intratab[CBPY_index];
          }
          else {
            CBPY_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_CBPY);
            CBPY = H263_cbpytab[CBPY_index];

          }
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() CBPY Index: %d CBPY %d \n",CBPY_index, CBPY) );
        }
        else
        {
          CBPY = sv_H263GetCBPY(H263Info, BSIn);
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() CBPY %d \n",CBPY) );
        }

        /* Decode Mode and CBP */


        if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
          {/* Intra */
            if (!H263Info->syntax_arith_coding)	
              CBPY = CBPY^15;        /* needed in huffman coding only */
          }

        CBP = (CBPY << 2) | (MCBPC >> 4);
      }

      if (Mode == H263_MODE_INTER4V && !H263Info->adv_pred_mode)
      {
        _SlibDebug(_VERBOSE_,
           ScDebugPrintf(H263Info->dbg, "getMBs() 8x8 vectors not allowed in normal prediction mode\n") );
        /* Could set fault-flag and resync */
      }


      if (Mode == H263_MODE_INTER_Q || Mode == H263_MODE_INTRA_Q) {
        /* Read DQUANT if necessary */

        if (H263Info->syntax_arith_coding) {
          DQUANT_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_DQUANT);
          DQUANT = H263_dquanttab[DQUANT_index] - 2;
          H263Info->quant +=DQUANT;
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() DQUANT Index: %d DQUANT %d \n",DQUANT_index, DQUANT) );
        }
        else {
          DQUANT = (int)ScBSGetBits(BSIn, 2);
          H263Info->quant += DQ_tab[DQUANT];
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() DQUANT: %d\n", DQUANT) );
#if 0
          if (H263Info->trace) {
            printf("DQUANT (");
            svH263Printbits(DQUANT,2,2);
            printf("): %d = %d\n",DQUANT,DQ_tab[DQUANT]);
          }
#endif
        }

        if (H263Info->quant > 31 || H263Info->quant < 1) {
          _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "GetMBs() Quantizer out of range: clipping\n") );
          H263Info->quant = mmax(1,mmin(31,H263Info->quant));
          /* could set fault-flag and resync here */
        }
      }

      /* motion vectors */
      if (Mode == H263_MODE_INTER || Mode == H263_MODE_INTER_Q ||
          Mode == H263_MODE_INTER4V || H263Info->pb_frame) {

        if (Mode == H263_MODE_INTER4V) { startmv = 1; stopmv = 4;}
        else { startmv = 0; stopmv = 0;}

        for (k = startmv; k <= stopmv; k++) {
          if (H263Info->syntax_arith_coding) {
            mvx_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MVD);
            mvx = H263_mvdtab[mvx_index];
            mvy_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MVD);
            mvy = H263_mvdtab[mvy_index];
            _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg,
                     "GetMBs() mvx_index: %d mvy_index: %d \n", mvx_index, mvy_index) );
          }
          else {
            mvx = sv_H263GetTMNMV(H263Info, BSIn);
            mvy = sv_H263GetTMNMV(H263Info, BSIn);
          }

          pmv0 = find_pmv(H263Info, xpos,ypos,k,0);
          pmv1 = find_pmv(H263Info, xpos,ypos,k,1);
          mvx = motion_decode(H263Info, mvx, pmv0);
          mvy = motion_decode(H263Info, mvy, pmv1);
#ifdef CAMERAMOTION
	      analyzemotion(xpos,ypos,mvx,mvy);
#else
          _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg,
                     "GetMBs() mvx: %d mvy: %d\n", mvx, mvy) );
#endif
          /* Check mv's to prevent seg.faults when error rate is high */
          if (!H263Info->mv_outside_frame) {
            bsize = k ? 8 : 16;
            offset = k ? (((k-1)&1)<<3) : 0;
            /* checking only integer component */
            if ((xpos<<4) + (mvx/2) + offset < 0 ||
                  (xpos<<4) + (mvx/2) + offset > (H263Info->mb_width<<4) - bsize) {
             _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "GetMBs() mvx out of range: searching for sync\n") );
              H263Info->fault = 1;
            }
            offset = k ? (((k-1)&2)<<2) : 0;
            if ((ypos<<4) + (mvy/2) + offset < 0 ||
        (ypos<<4) + (mvy/2) + offset > (H263Info->mb_height<<4) - bsize) {
             _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg, "GetMBs() mvy out of range: searching for sync\n") );
              H263Info->fault = 1;
            }
          }
          H263Info->MV[0][k][ypos+1][xpos+1] = mvx;
          H263Info->MV[1][k][ypos+1][xpos+1] = mvy;
        }

        /* PB frame delta vectors */

        if (H263Info->pb_frame) {
          if (MODB == H263_PBMODE_MVDB || MODB == H263_PBMODE_CBPB_MVDB) {
            if (H263Info->syntax_arith_coding) {
              mvdbx_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MVD);
              mvdbx = H263_mvdtab[mvdbx_index];

              mvdby_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_MVD);
              mvdby = H263_mvdtab[mvdby_index];
            }
            else {
              mvdbx = sv_H263GetTMNMV(H263Info, BSIn);
              mvdby = sv_H263GetTMNMV(H263Info, BSIn);
            }


            mvdbx = motion_decode(H263Info, mvdbx, 0);
            mvdby = motion_decode(H263Info, mvdby, 0);
            /* This will not work if the PB deltas are so large they
               require the second colums of the motion vector VLC
               table to be used.  To fix this it is necessary to
               calculate the MV predictor for the PB delta: TRB*MV/TRD
               here, and use this as the second parameter to
               motion_decode(). The B vector itself will then be
               returned from motion_decode(). This will have to be
               changed to the PB delta again, since it is the PB delta
               which is used later in this program. I don't think PB
               deltas outside the range mentioned above is useful, but
               you never know... */

          }
          else {
            mvdbx = 0;
            mvdby = 0;
          }
          _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
                                 "GetMBs() MVDB x: %d MVDB y: %d\n", mvdbx, mvdby) );
        }
      }

      if (H263Info->fault) goto resync;

    }
    else { /* COD == 1 --> skipped MB */
      if (MBA>=MBAmax)
      {
#ifdef CAMERAMOTION /* Burkhard */
        goto summarize_motion;
#else
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() done MBA=%d\n", MBA) );
        return; /* all macroblocks decoded */
#endif
      }
      if (!H263Info->syntax_arith_coding)
        if (H263Info->pict_type == H263_PCT_INTER)
          ScBSSkipBits(BSIn, 1);

      Mode = H263_MODE_INTER;

      /* Reset CBP */
      CBP = CBPB = 0;

      /* reset motion vectors */
      H263Info->MV[0][0][ypos+1][xpos+1] = 0;
      H263Info->MV[1][0][ypos+1][xpos+1] = 0;
      mvdbx = 0;
      mvdby = 0;
    }

    /* Store Mode*/
    H263Info->modemap[ypos+1][xpos+1] = Mode;

    if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
      if (!H263Info->pb_frame)
        H263Info->MV[0][0][ypos+1][xpos+1]=H263Info->MV[1][0][ypos+1][xpos+1] = 0;


  reconstruct_mb:

    /* pixel coordinates of top left corner of current macroblock */
    /* one delayed because of OBMC */
    if (xpos > 0) {
      bx = 16*(xpos-1);
      by = 16*ypos;
    }
    else {
      bx = H263Info->coded_picture_width-16;
      by = 16*(ypos-1);
    }

    if (MBA > 0) {

      Mode = H263Info->modemap[by/16+1][bx/16+1];

      /* forward motion compensation for B-frame */
      if (H263Info->pb_frame)
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() sv_H263Reconstruct(B-frame)\n") );
        sv_H263Reconstruct(H263Info,bx,by,0,pmvdbx,pmvdby);
      }
      /* motion compensation for P-frame */
      if (Mode == H263_MODE_INTER || Mode == H263_MODE_INTER_Q || Mode == H263_MODE_INTER4V)
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() sv_H263Reconstruct(P-frame)\n") );
        sv_H263Reconstruct(H263Info,bx,by,1,0,0);
      }
      /* copy or add block data into P-picture */
      for (comp=0; comp<H263Info->blk_cnt; comp++) {

        bp = H263Info->block[comp];

		/* inverse DCT */
        if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) {
          addblock(H263Info, comp,bx,by,0);
        }
        else if ( (pCBP & (1<<(H263Info->blk_cnt-1-comp))) ) {
          /* No need to to do this for blocks with no coeffs */
          addblock(H263Info,comp,bx,by,1);
        }
      }


      if (H263Info->pb_frame) {
        /* add block data into B-picture */
        for (comp = 6; comp<H263Info->blk_cnt+6; comp++) {
          if (!pCOD || H263Info->adv_pred_mode)
            reconblock_b(H263Info, comp-6,bx,by,Mode,pmvdbx,pmvdby);
          if ( (pCBPB & (1<<(H263Info->blk_cnt-1-comp%6))) ) {
			bp = H263Info->block[comp];
    		addblock(H263Info,comp,bx,by,1);
          }
        }
      }

    } /* end if (MBA > 0) */

    if (!COD) {

      Mode = H263Info->modemap[ypos+1][xpos+1];

      /* decode blocks */
      for (comp=0; comp<H263Info->blk_cnt; comp++) {

        clearblock(H263Info, comp);
        if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */
          bp = H263Info->block[comp];
          if(H263Info->syntax_arith_coding) {
            INTRADC_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_INTRADC);
            bp[0] = H263_intradctab[INTRADC_index];
            _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg,
                "getMBs() INTRADC Index: %d INTRADC: %d \n", INTRADC_index, bp[0]) );
          }
          else {
            bp[0] = (int)ScBSGetBits(BSIn, 8);
            _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "getMBs() DC: %d \n", (int)bp[0]));
          }

          _SlibDebug(_WARN_ && bp[0] == 128,
               ScDebugPrintf(H263Info->dbg, "getMBs() Illegal DC-coeff: 1000000\n"));
          if (bp[0] == 255)  /* Spec. in H.26P, not in TMN4 */
            bp[0] = 128;
          bp[0] *= 8; /* Iquant */

/* DC scale */
bp[0] *= (int)((float)(1 << 20) * (float)0.125) ;

		  if ( (CBP & (1<<(H263Info->blk_cnt-1-comp))) ) {
            if (!H263Info->syntax_arith_coding)
              sv_H263GetBlock(H263Info,BSIn,comp,0);
            else
              sv_H263GetSACblock(H263Info,BSIn,comp,0);
          }
        }
        else { /* Inter */
          if ( (CBP & (1<<(H263Info->blk_cnt-1-comp))) ) {
            if (!H263Info->syntax_arith_coding)
              sv_H263GetBlock(H263Info,BSIn,comp,1);
            else
              sv_H263GetSACblock(H263Info,BSIn,comp,1);
          }

        }
        if (H263Info->fault) goto resync;
      }

      /* Decode B blocks */
      if (H263Info->pb_frame) {
        for (comp=6; comp<H263Info->blk_cnt+6; comp++) {
          clearblock(H263Info, comp);
          if ( (CBPB & (1<<(H263Info->blk_cnt-1-comp%6))) ) {
            if (!H263Info->syntax_arith_coding)
              sv_H263GetBlock(H263Info,BSIn,comp,1);
            else
              sv_H263GetSACblock(H263Info,BSIn,comp,1);
          }
          if (H263Info->fault) goto resync;
        }
      }
     }

    /* advance to next macroblock */
    MBA++;

    pCBP = CBP; pCBPB = CBPB; pCOD = COD;
    pmvdbx = mvdbx; pmvdby = mvdby;
    /* fflush(stdout); */

    if (MBA >= MBAmax && !last_done) {
      COD = 1;
      xpos = 0;
      ypos++;
      last_done = 1;
      goto reconstruct_mb;
    }

  }
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "getMBs() exiting at MBA=%d\n", MBA) );
/* Burkhard */
#ifdef CAMERAMOTION
summarize_motion:
  summarizemotion(framenum);
#endif
}


/* set block to zero */
static void clearblock(SvH263DecompressInfo_t *H263Info, int comp)
{
  clearblk(comp) ;

#if 0
  qword *bp;
  int i;

  bp = (qword *)H263Info->block[comp];

  for (i=0; i<8; i++)
  {
    bp[0] = bp[1] = 0;
    bp += 2;
  }
#endif
}

/* move/add 8x8-Block from block[comp] to refframe or bframe */
static void addblock(SvH263DecompressInfo_t *H263Info, int comp, int bx, int by, int addflag)
{
  int cc, iincr, P = 1;
  unsigned char *rfp;
#ifdef USE_C
  int i ;
  unsigned qword *lp;
  unsigned qword acc,src;
#endif
  register int *bp;

  bp = H263Info->block[comp];

  if (comp >= 6) {
    /* This is a component for B-frame forward prediction */
    P = 0;
    addflag = 1;
    comp -= 6;
  }

  cc = (comp<4) ? 0 : (comp&1)+1; /* color component index */

  if (cc==0) {
    /* luminance */

    /* frame DCT coding */
    if (P)
      rfp = H263Info->newframe[0]
        + H263Info->coded_picture_width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
    else
      rfp = H263Info->bframe[0]
        + H263Info->coded_picture_width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
    iincr = H263Info->coded_picture_width;
  }
  else {
    /* chrominance */

    /* scale coordinates */
    bx >>= 1;
    by >>= 1;
    /* frame DCT coding */
    if (P)
      rfp = H263Info->newframe[cc] + H263Info->chrom_width*by + bx;
    else
      rfp = H263Info->bframe[cc] + H263Info->chrom_width*by + bx;
    iincr = H263Info->chrom_width;
  }

  if (addflag) {
#ifdef USE_C
    ScScaleIDCT8x8i_C(bp, bp);
    for (i=0; i<8; i++) {
      lp = (unsigned qword *) rfp;
      src = lp[0];
      acc = (unsigned qword) H263Info->clp[bp[0]+(src & 0xff)];
      acc |= (unsigned qword) H263Info->clp[bp[1]+((src >> 8) & 0xff)] << 8;
      acc |= (unsigned qword) H263Info->clp[bp[2]+((src >> 16) & 0xff)] << 16;
      acc |= (unsigned qword) H263Info->clp[bp[3]+((src >> 24) & 0xff)] << 24;
      acc |= (unsigned qword) H263Info->clp[bp[4]+((src >> 32) & 0xff)] << 32;
      acc |= (unsigned qword) H263Info->clp[bp[5]+((src >> 40) & 0xff)] << 40;
      acc |= (unsigned qword) H263Info->clp[bp[6]+((src >> 48) & 0xff)] << 48;
      acc |= (unsigned qword) H263Info->clp[bp[7]+((src >> 56) & 0xff)] << 56;
      lp[0] = acc;
      bp += 8;
      rfp+= iincr;
	}
#else
    sv_H263IDCTAddToFrameP_S(bp,rfp,iincr) ;
#endif
  }
  else  {
#ifdef USE_C
    ScScaleIDCT8x8i_C(bp, bp);
    for (i=0; i<8; i++) {
      lp = (unsigned qword *) rfp;
      acc =  (unsigned qword ) H263Info->clp[bp[0]];
      acc |= (unsigned qword ) H263Info->clp[bp[1]] << 8;
      acc |= (unsigned qword ) H263Info->clp[bp[2]] << 16;
      acc |= (unsigned qword ) H263Info->clp[bp[3]] << 24;
      acc |= (unsigned qword ) H263Info->clp[bp[4]] << 32;
      acc |= (unsigned qword ) H263Info->clp[bp[5]] << 40;
      acc |= (unsigned qword ) H263Info->clp[bp[6]] << 48;
      acc |= (unsigned qword ) H263Info->clp[bp[7]] << 56;
      lp[0] = acc;
      bp += 8;
      rfp += iincr;
    }
#else
    sv_H263IDCTToFrameP_S(bp,rfp,iincr) ;
#endif
  }
}


/* bidirectionally reconstruct 8x8-Block from block[comp] to bframe */
static void reconblock_b(SvH263DecompressInfo_t *H263Info, int comp, int bx, int by,
                                                           int mode, int bdx, int bdy)
{
  int cc,i,j,k, ii;
  register unsigned char *bfr, *ffr;
  int BMVx, BMVy;
  int xa,xb,ya,yb,x,y,xvec,yvec,mvx,mvy;
  int xint,xhalf,yint,yhalf,pel;

  x = bx/16+1;y=by/16+1;

  if (mode == H263_MODE_INTER4V) {
    if (comp < 4) {
      /* luma */
      mvx = H263Info->MV[0][comp+1][y][x];
      mvy = H263Info->MV[1][comp+1][y][x];
      BMVx = (bdx == 0 ? (H263Info->trb-H263Info->trd)* mvx/H263Info->trd : H263Info->trb * mvx/H263Info->trd + bdx - mvx);
      BMVy = (bdy == 0 ? (H263Info->trb-H263Info->trd)* mvy/H263Info->trd : H263Info->trb * mvy/H263Info->trd + bdy - mvy);
    }
    else {
      /* chroma */
      xvec = yvec = 0;
      for (k = 1; k <= 4; k++) {
        mvx = H263Info->MV[0][k][y][x];
        mvy = H263Info->MV[1][k][y][x];
        xvec += (bdx == 0 ? (H263Info->trb-H263Info->trd)* mvx/H263Info->trd : H263Info->trb * mvx/H263Info->trd + bdx - mvx);
        yvec += (bdy == 0 ? (H263Info->trb-H263Info->trd)* mvy/H263Info->trd : H263Info->trb * mvy/H263Info->trd + bdy - mvy);
      }

      /* chroma rounding (table 16/H.263) */
      BMVx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
      BMVy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);
    }
  }
  else {
    if (comp < 4) {
      /* luma */
      mvx = H263Info->MV[0][0][y][x];
      mvy = H263Info->MV[1][0][y][x];
      BMVx = (bdx == 0 ? (H263Info->trb-H263Info->trd)* mvx/H263Info->trd : H263Info->trb * mvx/H263Info->trd + bdx - mvx);
      BMVy = (bdy == 0 ? (H263Info->trb-H263Info->trd)* mvy/H263Info->trd : H263Info->trb * mvy/H263Info->trd + bdy - mvy);
    }
    else {
      /* chroma */
      mvx = H263Info->MV[0][0][y][x];
      mvy = H263Info->MV[1][0][y][x];
      xvec = (bdx == 0 ? (H263Info->trb-H263Info->trd)* mvx/H263Info->trd : H263Info->trb * mvx/H263Info->trd + bdx - mvx);
      yvec = (bdy == 0 ? (H263Info->trb-H263Info->trd)* mvy/H263Info->trd : H263Info->trb * mvy/H263Info->trd + bdy - mvy);
      xvec *= 4;
      yvec *= 4;

      /* chroma rounding (table 16/H.263) */
      BMVx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
      BMVy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);
    }
  }

  cc = (comp<4) ? 0 : (comp&1)+1; /* color component index */

  if (cc==0) {
    /* luminance */
    find_bidir_limits(BMVx,&xa,&xb,comp&1);
    find_bidir_limits(BMVy,&ya,&yb,(comp&2)>>1);
    bfr = H263Info->bframe[0] +
      H263Info->coded_picture_width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
    ffr = H263Info->newframe[0] +
      H263Info->coded_picture_width*(by+((comp&2)<<2)) + bx + ((comp&1)<<3);
    ii = H263Info->coded_picture_width;
  }
  else {
    /* chrominance */
    /* scale coordinates and vectors*/
    bx >>= 1;
    by >>= 1;

    find_bidir_chroma_limits(BMVx,&xa,&xb);
    find_bidir_chroma_limits(BMVy,&ya,&yb);

    bfr = H263Info->bframe[cc]      + H263Info->chrom_width*(by+((comp&2)<<2)) + bx + (comp&8);
    ffr = H263Info->newframe[cc]    + H263Info->chrom_width*(by+((comp&2)<<2)) + bx + (comp&8);
    ii = H263Info->chrom_width;
  }

  xint = BMVx>>1;
  xhalf = BMVx - 2*xint;
  yint = BMVy>>1;
  yhalf = BMVy - 2*yint;

  ffr += xint + (yint+ya)*ii;
  bfr += ya*ii;

  if (!xhalf && !yhalf) {
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) {
        pel = ffr[i];
        bfr[i] = ((unsigned int)(pel + bfr[i]))>>1;
      }
      bfr += ii;
      ffr += ii;
    }
  }
  else if (xhalf && !yhalf) {
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) {
        pel = ((unsigned int)(ffr[i]+ffr[i+1]+1))>>1;
        bfr[i] = ((unsigned int)(pel + bfr[i]))>>1;
      }
      bfr += ii;
      ffr += ii;
    }
  }
  else if (!xhalf && yhalf) {
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) {
        pel = ((unsigned int)(ffr[i]+ffr[ii+i]+1))>>1;
        bfr[i] = ((unsigned int)(pel + bfr[i]))>>1;
      }
      bfr += ii;
      ffr += ii;
    }
  }
  else { /* if (xhalf && yhalf) */
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) {
        pel = ((unsigned int)(ffr[i]+ffr[i+1]+ffr[ii+i]+ffr[ii+i+1]+2))>>2;
        bfr[i] = ((unsigned int)(pel + bfr[i]))>>1;
      }
      bfr += ii;
      ffr += ii;
    }
  }
  return;
}


static int motion_decode(SvH263DecompressInfo_t *H263Info, int vec, int pmv)
{
  if (vec > 31) vec -= 64;
  vec += pmv;
  if (!H263Info->long_vectors) {
    if (vec > 31)
      vec -= 64;
    if (vec < -32)
      vec += 64;
  }
  else {
    if (pmv < -31 && vec < -63)
      vec += 64;
    if (pmv > 32 && vec > 63)
      vec -= 64;
  }
  return vec;
}



static int find_pmv(SvH263DecompressInfo_t *H263Info, int x, int y, int block, int comp)
{
  int p1,p2,p3;
  int xin1,xin2,xin3;
  int yin1,yin2,yin3;
  int vec1,vec2,vec3;
  int l8,o8,or8;

  x++;y++;

  l8 = (H263Info->modemap[y][x-1] == H263_MODE_INTER4V ? 1 : 0);
  o8 =  (H263Info->modemap[y-1][x] == H263_MODE_INTER4V ? 1 : 0);
  or8 = (H263Info->modemap[y-1][x+1] == H263_MODE_INTER4V ? 1 : 0);

  switch (block) {
  case 0:
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 1:
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 2:
    vec1 = 1            ; yin1 = y  ; xin1 = x;
    vec2 = (o8 ? 4 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 3:
    vec1 = (l8 ? 4 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  case 4:
    vec1 = 3            ; yin1 = y  ; xin1 = x;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  default:
    fprintf(stderr,"Illegal block number in find_pmv (getpic.c)\n");
    exit(1);
    break;
  }
  p1 = H263Info->MV[comp][vec1][yin1][xin1];
  p2 = H263Info->MV[comp][vec2][yin2][xin2];
  p3 = H263Info->MV[comp][vec3][yin3][xin3];

  if (H263Info->newgob && (block == 0 || block == 1 || block == 2))
    p2 = H263_NO_VEC;

  if (p2 == H263_NO_VEC) { p2 = p3 = p1; }

  return p1+p2+p3 - mmax(p1,mmax(p2,p3)) - mmin(p1,mmin(p2,p3));
}



void find_bidir_limits(int vec, int *start, int *stop, int nhv)
{
  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2 - nhv*8);
  *stop = mmin(7,15-(vec+1)/2 - nhv*8);

  (*stop)++; /* I use < and not <= in the loop */
}



void find_bidir_chroma_limits(int vec, int *start, int *stop)
{

  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2);
  *stop = mmin(7,7-(vec+1)/2);

  (*stop)++; /* I use < and not <= in the loop */
  return;
}



void make_edge_image(unsigned char *src, unsigned char *dst, int width, int height, int edge)
{
  int i,j,incrp,incro;
  register unsigned char *p1,*p2,*p3,*p4;
  register unsigned char *o1,*o2,*o3,*o4;
  register unsigned int *dp1, *do1 ;

  /* center image */
/*
  p1 = dst;
  o1 = src;
  for (j = 0; j < height;j++) {
    for (i = 0; i < width; i++) {
      *(p1 + i) = *(o1 + i);
    }
    p1 += width + (edge<<1);
    o1 += width;
  }
*/
  dp1 = (unsigned int *)dst ;
  do1 = (unsigned int *)src ;
  incrp = (width + (edge<<1))/4 ;
  incro = width/4 ;
  for (j = 0; j < height;j++) {
    for (i = 0; i < width/4; i++) {
      *(dp1 + i) = *(do1 + i);
    }
    dp1 += incrp;
    do1 += incro;
  }

  /* left and right edges */
  p1 = dst-1;
  o1 = src;
  incrp = width + (edge<<1) ;
  incro = width ;
  for (j = 0; j < height;j++) {
    for (i = 0; i < edge; i++) {
      *(p1 - i) = *o1;
      *(p1 + width + i + 1) = *(o1 + width - 1);
    }
    p1 += incrp;
    o1 += incro;
  }

  /* top and bottom edges */
  p1 = dst;
  p2 = dst + (width + (edge<<1))*(height-1);
  o1 = src;
  o2 = src + width*(height-1);
  incrp = (width + (edge<<1)) ;
  for (j = 0; j < edge;j++) {
    p1 -= incrp ;
    p2 += incrp ;
    for (i = 0; i < width; i++) {
      *(p1 + i) = *(o1 + i);
      *(p2 + i) = *(o2 + i);
    }
  }

  /* corners */
  p1 = dst - (width+(edge<<1)) - 1;
  p2 = p1 + width + 1;
  p3 = dst + (width+(edge<<1))*(height)-1;
  p4 = p3 + width + 1;

  o1 = src;
  o2 = o1 + width - 1;
  o3 = src + width*(height-1);
  o4 = o3 + width - 1;
  incrp = (width + (edge<<1)) ;
  for (j = 0; j < edge; j++) {
    for (i = 0; i < edge; i++) {
      *(p1 - i) = *o1;
      *(p2 + i) = *o2;
      *(p3 - i) = *o3;
      *(p4 + i) = *o4;
    }
    p1 -= incrp ;
    p2 -= incrp ;
    p3 += incrp ;
    p4 += incrp ;
  }
}


/* only used for displayed interpolated frames, not reconstructed ones */
void interpolate_image(unsigned char *in, unsigned char *out, int width, int height)
{
  register int x,xx,y,w2;
  register unsigned char *pp,*ii;

return ;

  w2 = 2*width;

  /* Horizontally */
  pp = out;
  ii = in;
  for (y = 0; y < height-1; y++) {
    for (x = 0,xx=0; x < width-1; x++,xx+=2) {
      *(pp + xx) = *(ii + x);
      *(pp + xx+1) = ((unsigned int)(*(ii + x)  + *(ii + x + 1)))>>1;
      *(pp + w2 + xx) = ((unsigned int)(*(ii + x) + *(ii + x + width)))>>1;
      *(pp + w2 + xx+1) = ((unsigned int)(*(ii + x) + *(ii + x + 1) +
           *(ii + x + width) + *(ii + x + width + 1)))>>2;

    }
    *(pp + w2 - 2) = *(ii + width - 1);
    *(pp + w2 - 1) = *(ii + width - 1);
    *(pp + w2 + w2 - 2) = *(ii + width + width - 1);
    *(pp + w2 + w2 - 1) = *(ii + width + width - 1);
    pp += w2<<1;
    ii += width;
  }

  /* last lines */
  for (x = 0,xx=0; x < width-1; x++,xx+=2) {
    *(pp+ xx) = *(ii + x);
    *(pp+ xx+1) = ((unsigned int)(*(ii + x) + *(ii + x + 1) + 1))>>1;
    *(pp+ w2+ xx) = *(ii + x);
    *(pp+ w2+ xx+1) = ((unsigned int)(*(ii + x) + *(ii + x + 1) + 1))>>1;
  }

  /* bottom right corner pels */
  *(pp + (width<<1) - 2) = *(ii + width -1);
  *(pp + (width<<1) - 1) = *(ii + width -1);
  *(pp + (width<<2) - 2) = *(ii + width -1);
  *(pp + (width<<2) - 1) = *(ii + width -1);

  return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\h261.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h261.h,v $
 * Revision 1.1.2.2  1995/11/06  18:47:40  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:27  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _H261_H_
#define _H261_H_

/************** MPEG 1 parsing definitions **************/
#define H261_START_CODE              0x0001
#define H261_START_CODE_LEN          16
#define H261_GOB_START_CODE          0x0001
#define H261_GOB_START_CODE_LEN      16

#define H261_PICTURE_START_CODE      0x00010
#define H261_PICTURE_START_CODE_LEN  20

#endif _H261_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\h263.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _H263_H_
#define _H263_H_

/************** H263 parsing definitions **************/
#define H263_PSC                             1
#define H263_PSC_LENGTH                      17

#define H263_MODE_INTER                      0
#define H263_MODE_INTER_Q                    1
#define H263_MODE_INTER4V                    2
#define H263_MODE_INTRA                      3
#define H263_MODE_INTRA_Q                    4

#define H263_PBMODE_NORMAL                   0
#define H263_PBMODE_MVDB                     1
#define H263_PBMODE_CBPB_MVDB                2

#define H263_ESCAPE                          7167

#define H263_PCT_INTER                       1
#define H263_PCT_INTRA                       0

#define H263_SF_SQCIF                        1  /* 001 */
#define H263_SF_QCIF                         2  /* 010 */
#define H263_SF_CIF                          3  /* 011 */
#define H263_SF_4CIF                         4  /* 100 */
#define H263_SF_16CIF                        5  /* 101 */

/* From sim.h */
#define H263_SE_CODE                         31
#define H263_ESCAPE_INDEX                    102

#endif /* _H263_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\dispatch.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263_dispatch.c,v $
  * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:   h263_dispatch.c
** MODULE NAME: h263_dispatch.c
**
** MODULE DESCRIPTION:
**    H.263 ICM driver message dispatch routine.
**
**    Functions
**
**      DriverProc              (Entry point into codec)
**      ICH263Message           (ICM message handler. Calls routines in h263.c)
**      ICH263ClientThread      (Thread for processing most messages)
**      ICH263ProcessThread     (Thread for processing compress/decompress)
**
**    Private functions:
**
** DESIGN OVERVIEW:
** 	Accept the DriverProc message and dispatch to the proper
**      handler.
**
**--
*/
#include <stdio.h>
#include <windows.h>
#include "h26x_int.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

static CRITICAL_SECTION h263CritSect; /* Critical section for multi-thread protection */
static HMODULE ghModule=NULL;         /* Global handle to Module */

#define BOGUS_DRIVER_ID -1	/* Used during open on NT */

#ifdef WIN32
#define CHECKANDLOCK(x) if (((void *)lParam1==NULL) || (int)lParam2<sizeof(x)) \
	                        return ((unsigned int)ICERR_BADPARAM);
#define UNLOCK
#else
#define CHECKANDLOCK(x) { \
      int size = lParam2; \
      if (noChecklParam2 && size < sizeof(x)) \
	size = sizeof(x); \
      if (((void *)lParam1 == NULL) || size < sizeof(x)) \
	return ((unsigned int)ICERR_BADPARAM); \
}
#define UNLOCK
#endif


/***************************************************************************
 ***************************************************************************/

MMRESULT CALLBACK ICH263Message(DWORD_PTR driverHandle,
				    UINT      uiMessage,
				    LPARAM    lParam1,
				    LPARAM    lParam2,
				    H26XINFO *info)
{
    ICINFO *icinfo;
    LPBITMAPINFOHEADER lpbiIn;
    LPBITMAPINFOHEADER lpbiOut;
    ICDECOMPRESS *icDecompress;

    DWORD biSizeIn;
    DWORD biSizeOut;
    MMRESULT ret;

    _SlibDebug(_DEBUG_,
		ScDebugPrintf("ICH263Message(DriverID=%p, message=%d, lParam1=%p,lParam1=%p, info=%p)\n",
             driverHandle, uiMessage, lParam1, lParam2, info) );

    switch (uiMessage)
    {
        /*********************************************************************

	  ICM messages

	 *********************************************************************/	
    case ICM_CONFIGURE:
	/*
	 *  return ICERR_OK if you will do a configure box, error otherwise
	 */
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_CONFIGURE:\n") );
	if (lParam1 == -1)
	    return ICH263QueryConfigure(info) ? ICERR_OK :
		ICERR_UNSUPPORTED;
	else
	    return ICH263Configure(info);

    case ICM_ABOUT:
	/*
	 *  return ICERR_OK if you will do a about box, error otherwise
	 */
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_ABOUT::\n") );
	if (lParam1 == -1)
	    return ICH263QueryAbout(info) ? ICERR_OK :
		ICERR_UNSUPPORTED;
	else
	    return ICH263About(info);

    case ICM_GETSTATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETSTATE::\n") );
    if ((LPVOID)lParam1!=NULL) /* getting state size */
    {
      char *stateinfo=(char *)lParam1;  /* for debugging break point */
      memset(stateinfo, 0, 0x60);
    }
    return (0x60);

    case ICM_SETSTATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_SETSTATE::\n") );
    if ((LPVOID)lParam1!=NULL) /* getting state size */
    {
      char *stateinfo=(char *)lParam1; /* for debugging break point */
      int i=0;
      i=i+1;
    }
    if (info->dwRTP==EC_RTP_MODE_OFF) /* must be NetMeeting, turn on RTP */
      info->dwRTP=EC_RTP_MODE_A;
    return (0x60);

    case ICM_GETINFO:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETINFO::\n") );
	icinfo = (ICINFO FAR *)lParam1;
	if (icinfo == NULL)
	    return sizeof(ICINFO);

	if ((DWORD)lParam2 < sizeof(ICINFO))
	    return 0;
	ret = ICH263GetInfo(info, icinfo, (DWORD)lParam2);

	UNLOCK;
	return ret;

    case ICM_GETDEFAULTQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETDEFAULTQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263GetDefaultQuality(info, (DWORD *)lParam1);
	UNLOCK;
	return ret;

    case ICM_GETQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263GetQuality(info, (DWORD *)lParam1);
	UNLOCK;
	return ret;

	case ICM_SETQUALITY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_SETQUALITY::\n") );
	CHECKANDLOCK(DWORD);
	ret = ICH263SetQuality(info, (DWORD)lParam1);
	UNLOCK;
	return ret;

    case ICM_GETDEFAULTKEYFRAMERATE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_GETDEFAULTKEYFRAMERATE:::\n") );
	return ((unsigned int)ICERR_UNSUPPORTED);


    case DECH26X_CUSTOM_ENCODER_CONTROL:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------DECH26X_CUSTOM_ENCODER_CONTROL:::\n") );
    return(ICH263CustomEncoder(info, (DWORD)lParam2, (WORD)lParam2));
	

	/*********************************************************************

	  compression messages

    *********************************************************************/

    case ICM_COMPRESS_QUERY:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS_QUERY::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );

	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	if (lpbiOut)
	    biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (lpbiOut && biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;
	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (lpbiOut && (biSizeOut < sizeof(BITMAPINFOHEADER))))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263CompressQuery(info, lpbiIn, lpbiOut);

	UNLOCK;
	return ret;

    case ICM_COMPRESS_BEGIN:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_BEGIN::\n") );
	lpbiIn = (LPBITMAPINFOHEADER)lParam1;
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );
	if (lpbiIn == NULL || lpbiOut  == NULL)
	   return ((unsigned int)ICERR_BADPARAM);

	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	biSizeOut = lpbiOut->biSize;
	if (biSizeIn != sizeof(BITMAPINFOHEADER) ||
	    biSizeOut != sizeof(BITMAPINFOHEADER))
	{
      _SlibDebug(_VERBOSE_,
	 	ScDebugPrintf("biSizeIn or biSizeOut > sizeof(BITMAPINFOHEADER)\n") );
	  UNLOCK;
	  if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (biSizeOut < sizeof(BITMAPINFOHEADER)))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263CompressBegin(info, lpbiIn, lpbiOut);
	UNLOCK;
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_BEGIN:: Done\n") );
	return ret;

    case ICM_COMPRESS_GET_FORMAT:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS_GET_FORMAT::\n") );
	/* Nobody uses lpbiIn in this function.  Don't lock anything,
	* the lower layers will have to do any necessary locking.
	*/
	return ICH263CompressGetFormat(info,
				       (LPBITMAPINFOHEADER)lParam1,
				       (LPBITMAPINFOHEADER)lParam2);

    case ICM_COMPRESS_GET_SIZE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_GET_SIZE::\n") );
	lpbiIn = (LPBITMAPINFOHEADER)lParam1;
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    return(ICH263CompressGetSize(lpbiIn));

    case ICM_COMPRESS:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_COMPRESS::\n") );
	ret = ICH263Compress(info, (ICCOMPRESS *) lParam1, (DWORD)lParam2);
	return ret;

    case ICM_COMPRESS_END:
    _SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_END::\n") );
	return ICH263CompressEnd(info);
     /*********************************************************************

	  decompress messages

	 *********************************************************************/

    case ICM_DECOMPRESS_GET_FORMAT:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_GET_FORMAT::\n") );
	/* Nobody uses lpbiIn in this function.  Don't lock anything,
	* the lower layers will have to do any necessary locking.
	*/
	return ICH263DecompressGetFormat(info,
					     (LPBITMAPINFOHEADER)lParam1,
					     (LPBITMAPINFOHEADER)lParam2);

    case ICM_DECOMPRESS_GET_PALETTE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_GET_PALETTE::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	if ((biSizeIn = lpbiIn->biSize) != sizeof(BITMAPINFOHEADER)) {
	    UNLOCK;
	    if (biSizeIn < sizeof(BITMAPINFOHEADER))
		return (unsigned int)ICERR_BADPARAM;
	}

	/*ret = ICH263DecompressGetPalette(info,
					 (LPBITMAPINFOHEADER)lParam1,
					 (LPBITMAPINFOHEADER)lParam2);
	*/
    ret = (MMRESULT)ICERR_BADPARAM;
	UNLOCK;
	return ret;

    case ICM_DECOMPRESS_SET_PALETTE:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_SET_PALETTE::\n") );
    return ((unsigned int)ICERR_UNSUPPORTED);

    case ICM_DECOMPRESS_QUERY:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_QUERY::\n") );
	if ((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	    return ((unsigned int)ICERR_BADPARAM);
	lpbiOut = (LPBITMAPINFOHEADER)lParam2;
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiIn: %s\n", BMHtoString(lpbiIn)) );
    _SlibDebug(_VERBOSE_, ScDebugPrintf(" lpbiOut: %s\n", BMHtoString(lpbiOut)) );
	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	if (lpbiOut)
	    biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (lpbiOut && biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;

	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (lpbiOut && (biSizeOut < sizeof(BITMAPINFOHEADER))))
		return (unsigned int)ICERR_BADPARAM;
	}

	ret = ICH263DecompressQuery(info, lpbiIn, lpbiOut);

	UNLOCK;
	return ret;

    case ICM_DECOMPRESS_BEGIN:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_BEGIN::\n") );
	if (((lpbiIn = (LPBITMAPINFOHEADER)lParam1) == NULL)
	||  ((lpbiOut = (LPBITMAPINFOHEADER)lParam2) == NULL))
	    return ((unsigned int)ICERR_BADPARAM);
	/* Lock the memory - have to lock the structure first, and iff
	* that works, lock the rest
	*/
	biSizeIn = lpbiIn->biSize;
	biSizeOut = lpbiOut->biSize;
	if ((biSizeIn != sizeof(BITMAPINFOHEADER))
	||  (biSizeOut != sizeof(BITMAPINFOHEADER))) {
	    UNLOCK;
	    if ((biSizeIn < sizeof(BITMAPINFOHEADER))
	    ||  (biSizeOut < sizeof(BITMAPINFOHEADER)))
		return ((unsigned int)ICERR_BADPARAM);
	}

	ret = ICH263DecompressBegin(info, lpbiIn, lpbiOut);
	UNLOCK;
	return ret;

    case ICM_DECOMPRESS:
	_SlibDebug(_DEBUG_, ScDebugPrintf("------ICM_DECOMPRESS::\n") );
	icDecompress = (ICDECOMPRESS *)(void *)lParam1;
    if ((void *)lParam1==NULL && (void *)lParam2==NULL)
      return (unsigned int)ICERR_BADPARAM;
	ret = ICH263Decompress(info, (ICDECOMPRESS *) lParam1, (DWORD)lParam2);
	return ret;

    case ICM_DECOMPRESS_END:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_DECOMPRESS_END::\n") );
    ret = ICH263DecompressEnd(info);
	return ret;

    case ICM_COMPRESS_FRAMES_INFO:
	_SlibDebug(_VERBOSE_, ScDebugPrintf("------ICM_COMPRESS_FRAMES_INFO\n") );
    if ((LPVOID)lParam1==NULL ||
		lParam2<sizeof(ICCOMPRESSFRAMES))
		return (unsigned int)ICERR_BADPARAM;
    {
      ICCOMPRESSFRAMES *cf=(ICCOMPRESSFRAMES*)lParam1;
      _SlibDebug(_VERBOSE_,
		 ScDebugPrintf("Start=%ld, Count=%ld, Quality=%ld, DataRate=%ld (%5.1f Kb/s), KeyRate=%ld, FPS=%4.1f\n",
		  cf->lStartFrame,cf->lFrameCount,cf->lQuality,
		  cf->lDataRate, cf->lDataRate*8.0/1000, cf->lKeyRate, cf->dwRate*1.0/cf->dwScale) );
      /* info->dwBitrate=cf->lDataRate*8; */
      info->dwQuality=cf->lQuality;
      /* info->fFrameRate=(float)(cf->dwRate*1.0/cf->dwScale); */
    }
	return (unsigned int)ICERR_OK;
}
_SlibDebug(_VERBOSE_,
		ScDebugPrintf("ICH263Message(DriverID=%p, message=%d, lParam1=%p,lParam1=%p, info=%p) Unsupported\n",
             driverHandle, uiMessage, lParam1, lParam2, info) );
return ((unsigned int)ICERR_UNSUPPORTED);
}

/*
**++
**  FUNCTIONAL_NAME:            DriverProc
**
**  FUNCTIONAL_DESCRIPTION:
**      main and only entry point for the server into this driver
**
**  FORMAL PARAMETERS:
**      client pointer
**      driverHandle, returned by us on a DRV_OPEN message
**      driverID allocated and passed by the server
**      message to handle
**      parameters
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

#define DLLEXPORT

MMRESULT DLLEXPORT APIENTRY
DriverProc(
        DWORD_PTR       dwDriverID,
        HDRVR	        hDriver,
        UINT            message,
        LPARAM          lParam1,
        LPARAM          lParam2
)

{
  MMRESULT ret = DRV_OK;
  BOOL notfound = FALSE;
  H26XINFO *info = NULL;
  void     *client = 0;  /* Dummy client pointer for other calls. */
  /*
   * On NT, use __try {} __except() {} to catch
   * error conditions.
   */
#ifdef HANDLE_EXCEPTIONS
 __try { /* try..except */
  __try { /* try..finally */
#endif
    /*
     * Protect threads from interfering with each other.
     * To protect against a crash at shutdown, make sure
     * that the critical section has not been deleted.
     */
  if( h263CritSect.DebugInfo )
      EnterCriticalSection( &h263CritSect ) ;
  _SlibDebug(_DEBUG_,
	  ScDebugPrintf("DriverProc(DriverID=%p,hDriver=%p,message=%d,lParam1=%p,lParam2=%p)\n",
           dwDriverID, hDriver, message, lParam1, lParam2) );
	

  switch (message) {
    case DRV_LOAD:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_LOAD returns %d\n", ret) );
        break;

    case DRV_ENABLE:
	    ret = 0;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_ENABLE returns %d\n", ret) );
        break;

    case DRV_DISABLE:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_DISABLE returns %d\n", ret) );
        break;

    case DRV_FREE:
        ret = DRV_OK;
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_FREE returns %d\n", ret) );
        break;

    case DRV_OPEN:
	    /* If lParam2 is NULL, then the app is trying to do a CONFIGURE.
         * Return BOGUS_DRIVER_ID, since we don't support CONFIGURE.
	     */
	    if( lParam2 == (LONG_PTR) NULL )
	    	ret = (MMRESULT)BOGUS_DRIVER_ID;
	    else /* lParam2 is an ICOPEN structure, let's really open */
	        ret = (MMRESULT)((ULONG_PTR)ICH263Open((void *) lParam2));
	    _SlibDebug(_VERBOSE_, ScDebugPrintf("------DRV_OPEN returns %d\n", ret) );
	    break;

	case DRV_CLOSE:
	    _SlibDebug(_VERBOSE_,
			ScDebugPrintf("------DRV_CLOSE. client %d DriverID %p\n",
                 client, dwDriverID) );
        ret = 0 ;
        if ((INT_PTR)dwDriverID != BOGUS_DRIVER_ID)
        {
          info = IChic2info((HIC)dwDriverID);
          if (info)
	    	ICH263Close(info, FALSE);
          else
            ret = ((unsigned int)ICERR_BADHANDLE);
        }
		break;

    case DRV_QUERYCONFIGURE:
	    /*
	     * this is a GLOBAL query configure
	     */
	    ret = ICH263QueryConfigure(info);
		break;

    case DRV_CONFIGURE:
	    /*
	     * this is a GLOBAL configure ('cause we don't get a configure
	     * for each of our procs, we must have just one configure)
	     */

	    ret = ICH263Configure(info);
		break;

    case DRV_INSTALL:
    case DRV_REMOVE:
    case DRV_EXITSESSION:
        break;

    default:
        info = IChic2info((HIC)dwDriverID);
        if (info)
	      ret = ICH263Message(dwDriverID,
                              message,
                              lParam1,
                              lParam2,
                              info ) ;
        else
	      ret = ((unsigned int)ICERR_BADHANDLE) ;
   }

#ifdef HANDLE_EXCEPTIONS
} __finally {
#endif /* HANDLE_EXCEPTIONS */
    /*
     * Leave the critical section, so we don't
     * deadlock.
     */
  if( h263CritSect.DebugInfo )
      LeaveCriticalSection( &h263CritSect );
#ifdef HANDLE_EXCEPTIONS
} /* try..finally */
} __except(EXCEPTION_EXECUTE_HANDLER) {
 /*
  * NT exception handler. If anything went
  * wrong in the __try {} section, we will
  * end up here.
  */
#if defined(EXCEPTION_MESSAGES) && defined(H263_SUPPORT)
    // MessageBox(NULL, "Exception in H263 DriverProc", "Warning", MB_OK);
#elif defined(EXCEPTION_MESSAGES)
    // MessageBox(NULL, "Exception in H261 DriverProc", "Warning", MB_OK);
#endif
    /*
     * Return an error code.
     */
    return((MMRESULT)ICERR_INTERNAL);
} /* try..except */
#endif /* HANDLE_EXCEPTIONS */
  _SlibDebug(_DEBUG_||_VERBOSE_, ScDebugPrintf("return is %d\n", ret) );
  return ret;
}


/*
 * Dummy DriverPostReply routine, it does nothing.
 * It should never be called on NT.
 */

DriverPostReply(void *client,
		DWORD ret,
		DWORD arg )
{
    return 0;
}

#ifndef INITCRT
#define INITCRT
#endif
#ifdef INITCRT
BOOL WINAPI     _CRT_INIT(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved);
#endif

/*
 * This DllEntryPoint is needed on NT in order for
 * an application to connect to a dll properly.
 */

DLLEXPORT BOOL WINAPI
DllEntryPoint(
	      HINSTANCE hinstDLL,
	      DWORD fdwReason,
	      LPVOID lpReserved)
{

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:

      /*
       * We're being loaded - save our handle in a global.
       */

      ghModule = (HMODULE) hinstDLL;

      /*
       * Initialize the Critical Section that we use
       * to ensure Threads don't stomp on each other.
       */

      InitializeCriticalSection( &h263CritSect ) ;

      /*
       * A Process is also a thread, so deliberately
       * fall into DLL_THREAD_ATTACH.
       */

    case DLL_THREAD_ATTACH:

      /*
       * A Thread have been created that may
       * be calling this DLL.
       * Initialize the C run_time library.
       */

#ifdef INITCRT

      if( !_CRT_INIT( hinstDLL, fdwReason, lpReserved ) )
	return FALSE ;

#endif /* INITCRT */

      break;

    case DLL_PROCESS_DETACH:

      /*
       * We are shutting down. Perform some cleanup
       * so that lingering threads won't try to work
       * and maybe access violate.
       */

      TerminateH263() ;

      /*
       * Delete the Critical Section that we created
       * at load time.
       */

      DeleteCriticalSection( &h263CritSect ) ;

      /*
       * A Process is also a thread so deliberately
       * fall through to DLL_THREAD_DETACH.
       */

    case DLL_THREAD_DETACH:

      /*
       * Close down the C run-time library.
       */

#ifdef INITCRT

      if( !_CRT_INIT( hinstDLL, fdwReason, lpReserved ) )
	return FALSE ;

#endif /* INITCRT */

      break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\getblk.c ===
/* File: sv_h263_getblk.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#include <stdlib.h>
#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

static int H263_bquant_tab[] = {5,6,7,8};

typedef struct {
  char run, level, len;
} DCTtab;
typedef struct {
  int val, len;
} VLCtabI;
typedef struct {
  int val, run, sign;
} RunCoef;

/* local prototypes */
RunCoef vlc_word_decode(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int symbol_word, int *last); 
RunCoef Decode_Escape_Char(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int intra, int *last);
int DecodeTCoef(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int position, int intra);


extern VLCtabI DCT3Dtab0[],DCT3Dtab1[],DCT3Dtab2[];

/* zig-zag scan */
static unsigned char zig_zag_scan[64]=
{ 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,
  12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
  35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,
  58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63 };

static int H263_tcoeftab[103] = {1,2,3,4,5,6,7,8,9,10,11,12,17,18,19,20,21,22,33,34,35,36,49,50,51,65,66,67,81,82,83,97,98,99,113,114,129,130,145,146,161,162,177,193,209,225,241,257,273,289,305,321,337,353,369,385,401,417,4097,4098,4099,4113,4114,4129,4145,4161,4177,4193,4209,4225,4241,4257,4273,4289,4305,4321,4337,4353,4369,4385,4401,4417,4433,4449,4465,4481,4497,4513,4529,4545,4561,4577,4593,4609,4625,4641,4657,4673,4689,4705,4721,4737,7167};
static int H263_signtab[2] = {0,1};
static int H263_lasttab[2] = {0,1};
static int H263_last_intratab[2] = {0,1};
static int H263_runtab[64] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};
static int H263_leveltab[254] = {129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127};

static int H263_cumf_SIGN[3]={16383, 8416, 0};
static int H263_cumf_LAST[3]={16383, 9469, 0};
static int H263_cumf_LAST_intra[3]={16383, 2820, 0};
static int H263_cumf_RUN[65]={16383, 15310, 14702, 13022, 11883, 11234, 10612, 10192, 9516, 9016, 8623, 8366, 7595, 7068, 6730, 6487, 6379, 6285, 6177, 6150, 6083, 5989, 5949, 5922, 5895, 5828, 5774, 5773, 5394, 5164, 5016, 4569, 4366, 4136, 4015, 3867, 3773, 3692, 3611, 3476, 3341, 3301, 2787, 2503, 2219, 1989, 1515, 1095, 934, 799, 691, 583, 435, 300, 246, 206, 125, 124, 97, 57, 30, 3, 2, 1, 0};
static int H263_cumf_RUN_intra[65]={16383, 10884, 8242, 7124, 5173, 4745, 4246, 3984, 3034, 2749, 2607, 2298, 966, 681, 396, 349, 302, 255, 254, 253, 206, 159, 158, 157, 156, 155, 154, 153, 106, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
static int H263_cumf_LEVEL[255]={16383, 16382, 16381, 16380, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16310, 16309, 16308, 16307, 16306, 16305, 16304, 16303, 16302, 16301, 16300, 16299, 16298, 16297, 16296, 16295, 16294, 16293, 16292, 16291, 16290, 16289, 16288, 16287, 16286, 16285, 16284, 16283, 16282, 16281, 16280, 16279, 16278, 16277, 16250, 16223, 16222, 16195, 16154, 16153, 16071, 15989, 15880, 15879, 15878, 15824, 15756, 15674, 15606, 15538, 15184, 14572, 13960, 10718, 7994, 5379, 2123, 1537, 992, 693, 611, 516, 448, 421, 380, 353, 352, 284, 257, 230, 203, 162, 161, 160, 133, 132, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
static int H263_cumf_LEVEL_intra[255]={16383, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16268, 16267, 16224, 16223, 16180, 16179, 16136, 16135, 16134, 16133, 16132, 16131, 16130, 16129, 16128, 16127, 16126, 16061, 16018, 16017, 16016, 16015, 16014, 15971, 15970, 15969, 15968, 15925, 15837, 15794, 15751, 15750, 15749, 15661, 15618, 15508, 15376, 15288, 15045, 14913, 14781, 14384, 13965, 13502, 13083, 12509, 12289, 12135, 11892, 11738, 11429, 11010, 10812, 10371, 9664, 9113, 8117, 8116, 8028, 6855, 5883, 4710, 4401, 4203, 3740, 3453, 3343, 3189, 2946, 2881, 2661, 2352, 2132, 1867, 1558, 1382, 1250, 1162, 1097, 1032, 967, 835, 681, 549, 439, 351, 350, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 255, 212, 211, 210, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 115, 114, 113, 112, 111, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};


#define F (float) 
static const float dct_constants[64] = {
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.09011998,   F 0.06497288,   F 0.06897485,   F 0.07664075,
       F 0.09011998,   F 0.11470097,   F 0.16652001,   F 0.32664075,
   F 0.09567086,   F 0.06897485,   F 0.07322331,   F 0.08136138,
       F 0.09567086,   F 0.12176590,   F 0.17677669,   F 0.34675997,
   F 0.10630377,   F 0.07664074,   F 0.08136138,   F 0.09040392,
       F 0.10630377,   F 0.13529903,   F 0.19642374,   F 0.38529903,
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.15909483,   F 0.11470097,   F 0.12176590,   F 0.13529903,
       F 0.15909483,   F 0.20248929,   F 0.29396889,   F 0.57664073,
   F 0.23096988,   F 0.16652001,   F 0.17677669,   F 0.19642374,
       F 0.23096988,   F 0.29396892,   F 0.42677671,   F 0.83715260,
   F 0.45306373,   F 0.32664075,   F 0.34675995,   F 0.38529903,
       F 0.45306373,   F 0.57664073,   F 0.83715260,   F 1.64213395
};


#ifndef USE_C
#define SetExtraBlockInfo(bp) *((unsigned qword *)&bp[64])=cpattern;
#define UpdateBlockInfo(i) cpattern |=(((unsigned qword)1)<<((i/8)+(i%8)*8));
#endif

void sv_H263GetBlock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int mode)
{
  register int val, i, j, sign;
  register unsigned int code;
  VLCtabI *tab;
  register int run, last, level, QP;

  int *qval;
  int *bp;
#ifndef USE_C
  register unsigned qword cpattern;

  cpattern = (mode == 0) ? 1 : 1 ;
#endif

  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263GetBlock()\n") );
  bp = H263Info->block[comp];   

  /* decode AC coefficients */
  for (i=(mode==0); !BSIn->EOI || BSIn->shift; i++) /* HWG */
  { 
    code = (unsigned int)ScBSPeekBits(BSIn, 12);
    if (code>=512)
      tab = &DCT3Dtab0[(code>>5)-16];
    else if (code>=128)
      tab = &DCT3Dtab1[(code>>2)-32];
    else if (code>=8)
      tab = &DCT3Dtab2[(code>>0)-8];
    else {
      _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg,
                   "sv_H263GetBlock() invalid Huffman code\n") );
      H263Info->expand = 1;
      return;
    }

    ScBSSkipBits(BSIn, tab->len);

    run = (tab->val >> 4) & 255;
    level = tab->val & 15;
    last = (tab->val >> 12) & 1;


   if (tab->val==H263_ESCAPE) { /* escape */
#if 0
      if (H263Info->trace) {
        putchar(' ');
        svH263Printbits((int)ScBSPeekBits(BSIn, 1),1,1);
      }
#endif
      last = ScBSGetBit(BSIn);
#if 0
      if (H263Info->trace) {
        putchar(' ');
        svH263Printbits((int)ScBSPeekBits(BSIn, 6),6,6);
      }
#endif
      i += run = (int)ScBSGetBits(BSIn, 6);
#if 0
      if (H263Info->trace) {
        putchar(' ');
        svH263Printbits((int)ScBSPeekBits(BSIn, 8),8,8);
      }
#endif
      level = (int)ScBSGetBits(BSIn, 8);

      if ((sign = (level>=128)))
        val = 256 - level;
      else 
        val = level;
    }
    else {
      i+= run;
      val = level;
      sign = (int)ScBSGetBits(BSIn, 1);
    }

    if (i >= 64)
    {
      _SlibDebug(_WARN_, ScDebugPrintf(H263Info->dbg,
                            "sv_H263GetBlock() DCT coeff index (i=%d) out of bounds\n", i) );
      H263Info->expand = 1;
      return;
    }

    if (H263Info->trace)
      printf("): %d/%d\n",run,sign ? -val : val);


    j = zig_zag_scan[i];
    qval = &bp[j];
    if (comp >= 6)
      QP = mmax (1, mmin( 31, (H263_bquant_tab[H263Info->bquant] * H263Info->quant ) >> 2 ));
    else 
      QP = H263Info->quant;
      
    /* TMN3 dequantization */
    if ((QP % 2) == 1)
      *qval = ( sign ? -(QP * (2* val+1))  : QP * (2* val+1) );
    else
      *qval = ( sign ? -(QP * (2* val+1)-1): QP * (2* val+1)-1 );

    /* scale */
    (*qval) *= (int)(dct_constants[j] * H263_SCALED_IDCT_MULT); 
#ifndef USE_C
    UpdateBlockInfo(j) ;
#endif

    if (last)
    { /* That's it */
#ifndef USE_C
      SetExtraBlockInfo(bp) ;
#endif
      _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
                            "sv_H263GetBlock() done: EOI=%d\n", BSIn->EOI) );
      return;
    }
  }
}


/*********************************************************************
 *
 *        Name:        get_sac_block
 *
 *	Description:	Decodes blocks of Arithmetic Encoded DCT Coeffs.
 *        and performs Run Length Decoding and Coefficient        
 *        Dequantisation.
 *
 *	Input:        Picture block type and number.
 *
 *	Returns:	Nothing.
 *
 *	Side Effects:	
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/


void sv_H263GetSACblock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int ptype)
{
  register int position=0;
  register int TCOEF_index, symbol_word;
  int last=0, QP, i, j;
  RunCoef DCTcoef;

  int *qval;
  int *bp;
#ifndef USE_C
  register unsigned qword cpattern;

  cpattern = (ptype == 0) ? (unsigned qword) 1 : (unsigned qword)1 ;
#endif
  _SlibDebug(_VERBOSE_, ScDebugPrintf(H263Info->dbg, "sv_H263GetSACblock()\n") );

  bp = H263Info->block[comp];

  i = (ptype==0);
  /* HWG */
  while (!last && (!BSIn->EOI || BSIn->shift)) /* while there are DCT coefficients remaining */
  {
    position++;	/* coefficient counter relates to Coeff. model */
    TCOEF_index = DecodeTCoef(H263Info,BSIn,position, !ptype);

    if (TCOEF_index == H263_ESCAPE_INDEX) {        /* ESCAPE code encountered */
      DCTcoef = Decode_Escape_Char(H263Info,BSIn,!ptype, &last);
      _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg, "sv_H263GetSACblock() ESC\n") );
    }
    else {
      symbol_word = H263_tcoeftab[TCOEF_index];

      DCTcoef = vlc_word_decode(H263Info,BSIn,symbol_word,&last);
    }

    _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
             "sv_H263GetSACblock() val: %d, run: %d, sign: %d, last: %d\n", 
               DCTcoef.val, DCTcoef.run, DCTcoef.sign, last) );
    i += DCTcoef.run;

    j = zig_zag_scan[i];

    qval = &bp[j];

    i++;

    if (comp >= 6)
      QP = mmax (1, mmin( 31, (H263_bquant_tab[H263Info->bquant] * H263Info->quant ) >> 2 ));
    else 
      QP = H263Info->quant;

    if ((QP % 2) == 1)
      *qval = ( (DCTcoef.sign) ? -(QP * (2* (DCTcoef.val)+1))  : 
        QP * (2* (DCTcoef.val)+1) );
    else
      *qval = ( (DCTcoef.sign) ? -(QP * (2* (DCTcoef.val)+1)-1): 
        QP * (2* (DCTcoef.val)+1)-1 );

    /* scale */
    (*qval) *= (int)(dct_constants[j] * H263_SCALED_IDCT_MULT); 
#ifndef USE_C
    UpdateBlockInfo(j) ;
#endif
  }	

#ifndef USE_C
  SetExtraBlockInfo(bp) ;
#endif
  _SlibDebug(_DEBUG_, ScDebugPrintf(H263Info->dbg,
        "sv_H263GetSACblock() done: EOI=%d\n", BSIn->EOI) );
	
  return;
}

/*********************************************************************
 *
 *        Name:        vlc_word_decode
 *
 *	Description:	Fills Decoder FIFO after a fixed word length
 *        string has been detected.
 *
 *	Input:        Symbol to be decoded, last data flag.
 *
 *	Returns:	Decoded Symbol via the structure DCTcoeff.
 *
 *	Side Effects:	Updates last flag.
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

RunCoef vlc_word_decode(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int symbol_word, int *last)
{
  int sign_index;
  RunCoef DCTcoef;

  *last = (symbol_word >> 12) & 01;
 
  DCTcoef.run = (symbol_word >> 4) & 255; 

  DCTcoef.val = (symbol_word) & 15;

  sign_index = sv_H263SACDecode_a_symbol(BSIn, H263_cumf_SIGN);	

  DCTcoef.sign = H263_signtab[sign_index];
        
  return (DCTcoef);
} 

/*********************************************************************
 *
 *        Name:        Decode_Escape_Char
 *
 *	Description:	Decodes all components for a Symbol when an 
 *        ESCAPE character has been detected.
 *
 *	Input:        Picture Type and last data flag.
 *
 *	Returns:	Decoded Symbol via the structure DCTcoeff.
 *
 *	Side Effects:	Modifies last data flag.
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

RunCoef Decode_Escape_Char(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int intra, int *last)
{
  int last_index, run, run_index, level, level_index;
  RunCoef DCTcoef;

  if (intra) {
    last_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_LAST_intra);
    *last = H263_last_intratab[last_index];
  }
  else {
    last_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_LAST);
    *last = H263_lasttab[last_index];
  }

  if (intra) 
    run_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_RUN_intra);
  else
    run_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_RUN);

  run = H263_runtab[run_index];

  /*$if (mrun) run|=64;$*/

  DCTcoef.run = run;

  if (intra)
    level_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_LEVEL_intra);
  else
    level_index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_LEVEL);

  if (H263Info->trace)
    printf("level_idx: %d ",level_index);

  level = H263_leveltab[level_index];

  if (level >128) 
    level -=256;

  if (level < 0) {
    DCTcoef.sign = 1;
    DCTcoef.val = abs(level);
  }

  else {	
    DCTcoef.sign = 0;
    DCTcoef.val = level;
  }

  return (DCTcoef);
        
}
/*********************************************************************
 *
 *        Name:        DecodeTCoef
 *
 *	Description:	Decodes a.c DCT Coefficients using the        
 *        relevant arithmetic decoding model.
 *
 *	Input:        DCT Coeff count and Picture Type.	
 *
 *	Returns:	Index to LUT
 *
 *	Side Effects:	None
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/
static int H263_cumf_TCOEF1[104]={16383, 13455, 12458, 12079, 11885, 11800, 11738, 11700, 11681, 11661, 11651, 11645, 11641, 10572, 10403, 10361, 10346, 10339, 10335, 9554, 9445, 9427, 9419, 9006, 8968, 8964, 8643, 8627, 8624, 8369, 8354, 8352, 8200, 8192, 8191, 8039, 8036, 7920, 7917, 7800, 7793, 7730, 7727, 7674, 7613, 7564, 7513, 7484, 7466, 7439, 7411, 7389, 7373, 7369, 7359, 7348, 7321, 7302, 7294, 5013, 4819, 4789, 4096, 4073, 3373, 3064, 2674, 2357, 2177, 1975, 1798, 1618, 1517, 1421, 1303, 1194, 1087, 1027, 960, 890, 819, 758, 707, 680, 656, 613, 566, 534, 505, 475, 465, 449, 430, 395, 358, 335, 324, 303, 295, 286, 272, 233, 215, 0};
static int H263_cumf_TCOEF2[104]={16383, 13582, 12709, 12402, 12262, 12188, 12150, 12131, 12125, 12117, 12113, 12108, 12104, 10567, 10180, 10070, 10019, 9998, 9987, 9158, 9037, 9010, 9005, 8404, 8323, 8312, 7813, 7743, 7726, 7394, 7366, 7364, 7076, 7062, 7060, 6810, 6797, 6614, 6602, 6459, 6454, 6304, 6303, 6200, 6121, 6059, 6012, 5973, 5928, 5893, 5871, 5847, 5823, 5809, 5796, 5781, 5771, 5763, 5752, 4754, 4654, 4631, 3934, 3873, 3477, 3095, 2758, 2502, 2257, 2054, 1869, 1715, 1599, 1431, 1305, 1174, 1059, 983, 901, 839, 777, 733, 683, 658, 606, 565, 526, 488, 456, 434, 408, 380, 361, 327, 310, 296, 267, 259, 249, 239, 230, 221, 214, 0};
static int H263_cumf_TCOEF3[104]={16383, 13532, 12677, 12342, 12195, 12112, 12059, 12034, 12020, 12008, 12003, 12002, 12001, 10586, 10297, 10224, 10202, 10195, 10191, 9223, 9046, 8999, 8987, 8275, 8148, 8113, 7552, 7483, 7468, 7066, 7003, 6989, 6671, 6642, 6631, 6359, 6327, 6114, 6103, 5929, 5918, 5792, 5785, 5672, 5580, 5507, 5461, 5414, 5382, 5354, 5330, 5312, 5288, 5273, 5261, 5247, 5235, 5227, 5219, 4357, 4277, 4272, 3847, 3819, 3455, 3119, 2829, 2550, 2313, 2104, 1881, 1711, 1565, 1366, 1219, 1068, 932, 866, 799, 750, 701, 662, 605, 559, 513, 471, 432, 403, 365, 336, 312, 290, 276, 266, 254, 240, 228, 223, 216, 206, 199, 192, 189, 0};
static int H263_cumf_TCOEFr[104]={16383, 13216, 12233, 11931, 11822, 11776, 11758, 11748, 11743, 11742, 11741, 11740, 11739, 10203, 9822, 9725, 9691, 9677, 9674, 8759, 8609, 8576, 8566, 7901, 7787, 7770, 7257, 7185, 7168, 6716, 6653, 6639, 6276, 6229, 6220, 5888, 5845, 5600, 5567, 5348, 5327, 5160, 5142, 5004, 4900, 4798, 4743, 4708, 4685, 4658, 4641, 4622, 4610, 4598, 4589, 4582, 4578, 4570, 4566, 3824, 3757, 3748, 3360, 3338, 3068, 2835, 2592, 2359, 2179, 1984, 1804, 1614, 1445, 1234, 1068, 870, 739, 668, 616, 566, 532, 489, 453, 426, 385, 357, 335, 316, 297, 283, 274, 266, 259, 251, 241, 233, 226, 222, 217, 214, 211, 209, 208, 0};
static int H263_cumf_TCOEF1_intra[104]={16383, 13383, 11498, 10201, 9207, 8528, 8099, 7768, 7546, 7368, 7167, 6994, 6869, 6005, 5474, 5220, 5084, 4964, 4862, 4672, 4591, 4570, 4543, 4397, 4337, 4326, 4272, 4240, 4239, 4212, 4196, 4185, 4158, 4157, 4156, 4140, 4139, 4138, 4137, 4136, 4125, 4124, 4123, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 3043, 2897, 2843, 1974, 1790, 1677, 1552, 1416, 1379, 1331, 1288, 1251, 1250, 1249, 1248, 1247, 1236, 1225, 1224, 1223, 1212, 1201, 1200, 1199, 1198, 1197, 1196, 1195, 1194, 1193, 1192, 1191, 1190, 1189, 1188, 1187, 1186, 1185, 1184, 1183, 1182, 1181, 1180, 1179, 0};
static int H263_cumf_TCOEF2_intra[104]={16383, 13242, 11417, 10134, 9254, 8507, 8012, 7556, 7273, 7062, 6924, 6839, 6741, 6108, 5851, 5785, 5719, 5687, 5655, 5028, 4917, 4864, 4845, 4416, 4159, 4074, 3903, 3871, 3870, 3765, 3752, 3751, 3659, 3606, 3580, 3541, 3540, 3514, 3495, 3494, 3493, 3474, 3473, 3441, 3440, 3439, 3438, 3425, 3424, 3423, 3422, 3421, 3420, 3401, 3400, 3399, 3398, 3397, 3396, 2530, 2419, 2360, 2241, 2228, 2017, 1687, 1576, 1478, 1320, 1281, 1242, 1229, 1197, 1178, 1152, 1133, 1114, 1101, 1088, 1087, 1086, 1085, 1072, 1071, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 0};
static int H263_cumf_TCOEF3_intra[104]={16383, 12741, 10950, 10071, 9493, 9008, 8685, 8516, 8385, 8239, 8209, 8179, 8141, 6628, 5980, 5634, 5503, 5396, 5327, 4857, 4642, 4550, 4481, 4235, 4166, 4151, 3967, 3922, 3907, 3676, 3500, 3324, 3247, 3246, 3245, 3183, 3168, 3084, 3069, 3031, 3030, 3029, 3014, 3013, 2990, 2975, 2974, 2973, 2958, 2943, 2928, 2927, 2926, 2925, 2924, 2923, 2922, 2921, 2920, 2397, 2298, 2283, 1891, 1799, 1591, 1445, 1338, 1145, 1068, 1006, 791, 768, 661, 631, 630, 615, 592, 577, 576, 561, 546, 523, 508, 493, 492, 491, 476, 475, 474, 473, 472, 471, 470, 469, 468, 453, 452, 451, 450, 449, 448, 447, 446, 0};
static int H263_cumf_TCOEFr_intra[104]={16383, 12514, 10776, 9969, 9579, 9306, 9168, 9082, 9032, 9000, 8981, 8962, 8952, 7630, 7212, 7053, 6992, 6961, 6940, 6195, 5988, 5948, 5923, 5370, 5244, 5210, 4854, 4762, 4740, 4384, 4300, 4288, 4020, 3968, 3964, 3752, 3668, 3511, 3483, 3354, 3322, 3205, 3183, 3108, 3046, 2999, 2981, 2974, 2968, 2961, 2955, 2949, 2943, 2942, 2939, 2935, 2934, 2933, 2929, 2270, 2178, 2162, 1959, 1946, 1780, 1651, 1524, 1400, 1289, 1133, 1037, 942, 849, 763, 711, 591, 521, 503, 496, 474, 461, 449, 442, 436, 426, 417, 407, 394, 387, 377, 373, 370, 367, 366, 365, 364, 363, 362, 358, 355, 352, 351, 350, 0};

int DecodeTCoef(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int position, int intra)
{
  int index;

  switch (position) {
  case 1:
    {
      if (intra) 
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF1_intra);
      else 
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF1); 
      break; 
    }
  case 2:
    {
      if (intra) 
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF2_intra);
      else
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF2);
      break; 
    }
  case 3:
    {
      if (intra) 
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF3_intra);
      else
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEF3);
      break; 
    }
  default: 
    {
      if (intra) 
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEFr_intra);
      else
        index = sv_H263SACDecode_a_symbol(BSIn,H263_cumf_TCOEFr);
      break; 
    }
  }

  return (index);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\jpeg.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: jpeg.h,v $
 * Revision 1.1.2.2  1995/12/07  19:35:59  Hans_Graves
 * 	Created under SLIB
 * 	[1995/12/07  19:34:59  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _JPEG_H_
#define _JPEG_H_

/************** MPEG 1 parsing definitions **************/
#define JPEG_MARKER                  0xFF
#define JPEG_MARKER_LEN              8
#define JPEG_SOF0                    0xC0 /* Baseline DCT */
#define JPEG_SOF1                    0xC1 /* Extended sequential DCT */
#define JPEG_SOF2                    0xC2 /* Progressive DCT */
#define JPEG_SOF3                    0xC3 /* Lossless (sequential) */

#endif _JPEG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\getvlc.c ===
/* File: sv_h263_getvlc.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#include <stdio.h>
#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

/* From getvlc.h */

typedef struct {
  int val, len;
} VLCtab;

typedef struct {
  char run, level, len;
} DCTtab;


static VLCtab TMNMVtab0[] = {
{3,4}, {61,4}, {2,3}, {2,3}, {62,3}, {62,3}, 
{1,2}, {1,2}, {1,2}, {1,2}, {63,2}, {63,2}, {63,2}, {63,2}
};

static VLCtab TMNMVtab1[] = {
{12,10}, {52,10}, {11,10}, {53,10}, {10,9}, {10,9}, 
{54,9}, {54,9}, {9,9}, {9,9}, {55,9}, {55,9}, 
{8,9}, {8,9}, {56,9}, {56,9}, {7,7}, {7,7}, 
{7,7}, {7,7}, {7,7}, {7,7}, {7,7}, {7,7}, 
{57,7}, {57,7}, {57,7}, {57,7}, {57,7}, {57,7}, 
{57,7}, {57,7}, {6,7}, {6,7}, {6,7}, {6,7}, 
{6,7}, {6,7}, {6,7}, {6,7}, {58,7}, {58,7}, 
{58,7}, {58,7}, {58,7}, {58,7}, {58,7}, {58,7}, 
{5,7}, {5,7}, {5,7}, {5,7}, {5,7}, {5,7}, 
{5,7}, {5,7}, {59,7}, {59,7}, {59,7}, {59,7}, 
{59,7}, {59,7}, {59,7}, {59,7}, {4,6}, {4,6}, 
{4,6}, {4,6}, {4,6}, {4,6}, {4,6}, {4,6}, 
{4,6}, {4,6}, {4,6}, {4,6}, {4,6}, {4,6}, 
{4,6}, {4,6}, {60,6}, {60,6},{60,6},{60,6},
{60,6},{60,6},{60,6},{60,6},{60,6},{60,6},
{60,6},{60,6},{60,6},{60,6},{60,6},{60,6}
};

static VLCtab TMNMVtab2[] = {
{32,12}, {31,12}, {33,12}, {30,11}, {30,11}, {34,11}, 
{34,11}, {29,11}, {29,11}, {35,11}, {35,11}, {28,11}, 
{28,11}, {36,11}, {36,11}, {27,11}, {27,11}, {37,11}, 
{37,11}, {26,11}, {26,11}, {38,11}, {38,11}, {25,11}, 
{25,11}, {39,11}, {39,11}, {24,10}, {24,10}, {24,10}, 
{24,10}, {40,10}, {40,10}, {40,10}, {40,10}, {23,10}, 
{23,10}, {23,10}, {23,10}, {41,10}, {41,10}, {41,10}, 
{41,10}, {22,10}, {22,10}, {22,10}, {22,10}, {42,10}, 
{42,10}, {42,10}, {42,10}, {21,10}, {21,10}, {21,10}, 
{21,10}, {43,10}, {43,10}, {43,10}, {43,10}, {20,10}, 
{20,10}, {20,10}, {20,10}, {44,10}, {44,10}, {44,10}, 
{44,10}, {19,10}, {19,10}, {19,10}, {19,10}, {45,10}, 
{45,10}, {45,10}, {45,10}, {18,10}, {18,10}, {18,10}, 
{18,10}, {46,10}, {46,10}, {46,10}, {46,10}, {17,10}, 
{17,10}, {17,10}, {17,10}, {47,10}, {47,10}, {47,10}, 
{47,10}, {16,10}, {16,10}, {16,10}, {16,10}, {48,10}, 
{48,10}, {48,10}, {48,10}, {15,10}, {15,10}, {15,10}, 
{15,10}, {49,10}, {49,10}, {49,10}, {49,10}, {14,10}, 
{14,10}, {14,10}, {14,10}, {50,10}, {50,10}, {50,10}, 
{50,10}, {13,10}, {13,10}, {13,10}, {13,10}, {51,10}, 
{51,10}, {51,10}, {51,10}
};


static VLCtab MCBPCtab[] = {
{-1,0},
{255,9}, {52,9}, {36,9}, {20,9}, {49,9}, {35,8}, {35,8}, {19,8}, {19,8}, 
{50,8}, {50,8}, {51,7}, {51,7}, {51,7}, {51,7}, {34,7}, {34,7}, {34,7}, 
{34,7}, {18,7}, {18,7}, {18,7}, {18,7}, {33,7}, {33,7}, {33,7}, {33,7}, 
{17,7}, {17,7}, {17,7}, {17,7}, {4,6}, {4,6}, {4,6}, {4,6}, {4,6}, 
{4,6}, {4,6}, {4,6}, {48,6}, {48,6}, {48,6}, {48,6}, {48,6}, {48,6}, 
{48,6}, {48,6}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, 
{3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, {3,5}, 
{32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, 
{32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, 
{32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {32,4}, 
{32,4}, {32,4}, {32,4}, {32,4}, {32,4}, {16,4}, {16,4}, {16,4}, {16,4}, 
{16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, 
{16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, 
{16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, {16,4}, 
{16,4}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, {2,3}, 
{2,3}, {2,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, {1,3}, 
{1,3}, {1,3}, {1,3}, 
};



static VLCtab MCBPCtabintra[] = {
{-1,0},
{20,6}, {36,6}, {52,6}, {4,4}, {4,4}, {4,4}, 
{4,4}, {19,3}, {19,3}, {19,3}, {19,3}, {19,3}, 
{19,3}, {19,3}, {19,3}, {35,3}, {35,3}, {35,3}, 
{35,3}, {35,3}, {35,3}, {35,3}, {35,3}, {51,3}, 
{51,3}, {51,3}, {51,3}, {51,3}, {51,3}, {51,3}, 
{51,3},
};



static VLCtab CBPYtab[48] =
{ {-1,0}, {-1,0}, {9,6}, {6,6}, {7,5}, {7,5}, {11,5}, {11,5},
  {13,5}, {13,5}, {14,5}, {14,5}, {15,4}, {15,4}, {15,4}, {15,4}, 
  {3,4}, {3,4}, {3,4}, {3,4}, {5,4},{5,4},{5,4},{5,4},
  {1,4}, {1,4}, {1,4}, {1,4}, {10,4}, {10,4}, {10,4}, {10,4},
  {2,4}, {2,4}, {2,4}, {2,4}, {12,4}, {12,4}, {12,4}, {12,4}, 
  {4,4}, {4,4}, {4,4}, {4,4}, {8,4}, {8,4}, {8,4}, {8,4}, 
};


VLCtab DCT3Dtab0[] = {
{4225,7}, {4209,7}, {4193,7}, {4177,7}, {193,7}, {177,7}, 
{161,7}, {4,7}, {4161,6}, {4161,6}, {4145,6}, {4145,6}, 
{4129,6}, {4129,6}, {4113,6}, {4113,6}, {145,6}, {145,6}, 
{129,6}, {129,6}, {113,6}, {113,6}, {97,6}, {97,6}, 
{18,6}, {18,6}, {3,6}, {3,6}, {81,5}, {81,5}, 
{81,5}, {81,5}, {65,5}, {65,5}, {65,5}, {65,5}, 
{49,5}, {49,5}, {49,5}, {49,5}, {4097,4}, {4097,4}, 
{4097,4}, {4097,4}, {4097,4}, {4097,4}, {4097,4}, {4097,4}, 
{1,2}, {1,2}, {1,2}, {1,2}, {1,2}, {1,2}, 
{1,2}, {1,2}, {1,2}, {1,2}, {1,2}, {1,2}, 
{1,2}, {1,2}, {1,2}, {1,2}, {1,2}, {1,2}, 
{1,2}, {1,2}, {1,2}, {1,2}, {1,2}, {1,2}, 
{1,2}, {1,2}, {1,2}, {1,2}, {1,2}, {1,2}, 
{1,2}, {1,2}, {17,3}, {17,3}, {17,3}, {17,3}, 
{17,3}, {17,3}, {17,3}, {17,3}, {17,3}, {17,3}, 
{17,3}, {17,3}, {17,3}, {17,3}, {17,3}, {17,3}, 
{33,4}, {33,4}, {33,4}, {33,4}, {33,4}, {33,4}, 
{33,4}, {33,4}, {2,4}, {2,4},{2,4},{2,4},
{2,4}, {2,4},{2,4},{2,4},
};


VLCtab DCT3Dtab1[] = {
{9,10}, {8,10}, {4481,9}, {4481,9}, {4465,9}, {4465,9}, 
{4449,9}, {4449,9}, {4433,9}, {4433,9}, {4417,9}, {4417,9}, 
{4401,9}, {4401,9}, {4385,9}, {4385,9}, {4369,9}, {4369,9}, 
{4098,9}, {4098,9}, {353,9}, {353,9}, {337,9}, {337,9}, 
{321,9}, {321,9}, {305,9}, {305,9}, {289,9}, {289,9}, 
{273,9}, {273,9}, {257,9}, {257,9}, {241,9}, {241,9}, 
{66,9}, {66,9}, {50,9}, {50,9}, {7,9}, {7,9}, 
{6,9}, {6,9}, {4353,8}, {4353,8}, {4353,8}, {4353,8}, 
{4337,8}, {4337,8}, {4337,8}, {4337,8}, {4321,8}, {4321,8}, 
{4321,8}, {4321,8}, {4305,8}, {4305,8}, {4305,8}, {4305,8}, 
{4289,8}, {4289,8}, {4289,8}, {4289,8}, {4273,8}, {4273,8}, 
{4273,8}, {4273,8}, {4257,8}, {4257,8}, {4257,8}, {4257,8}, 
{4241,8}, {4241,8}, {4241,8}, {4241,8}, {225,8}, {225,8}, 
{225,8}, {225,8}, {209,8}, {209,8}, {209,8}, {209,8}, 
{34,8}, {34,8}, {34,8}, {34,8}, {19,8}, {19,8}, 
{19,8}, {19,8}, {5,8}, {5,8}, {5,8}, {5,8}, 
};

VLCtab DCT3Dtab2[] = {
{4114,11}, {4114,11}, {4099,11}, {4099,11}, {11,11}, {11,11}, 
{10,11}, {10,11}, {4545,10}, {4545,10}, {4545,10}, {4545,10}, 
{4529,10}, {4529,10}, {4529,10}, {4529,10}, {4513,10}, {4513,10}, 
{4513,10}, {4513,10}, {4497,10}, {4497,10}, {4497,10}, {4497,10}, 
{146,10}, {146,10}, {146,10}, {146,10}, {130,10}, {130,10}, 
{130,10}, {130,10}, {114,10}, {114,10}, {114,10}, {114,10}, 
{98,10}, {98,10}, {98,10}, {98,10}, {82,10}, {82,10}, 
{82,10}, {82,10}, {51,10}, {51,10}, {51,10}, {51,10}, 
{35,10}, {35,10}, {35,10}, {35,10}, {20,10}, {20,10}, 
{20,10}, {20,10}, {12,11}, {12,11}, {21,11}, {21,11}, 
{369,11}, {369,11}, {385,11}, {385,11}, {4561,11}, {4561,11}, 
{4577,11}, {4577,11}, {4593,11}, {4593,11}, {4609,11}, {4609,11}, 
{22,12}, {36,12}, {67,12}, {83,12}, {99,12}, {162,12}, 
{401,12}, {417,12}, {4625,12}, {4641,12}, {4657,12}, {4673,12}, 
{4689,12}, {4705,12}, {4721,12}, {4737,12}, {7167,7}, 
{7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, 
{7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, 
{7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, 
{7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, 
{7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, {7167,7}, 
{7167,7}, };




int sv_H263GetTMNMV(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int code;

  if (H263Info->trace)
    printf("motion_code (");

  if (ScBSGetBit(BSIn))
  {
    if (H263Info->trace)
      printf("1): 0\n");
    return 0;
  }

  if ((code = (int)ScBSPeekBits(BSIn, 12))>=512)
  {
    code = (code>>8) - 2;
    ScBSSkipBits(BSIn, TMNMVtab0[code].len);
#if 0
    if (H263Info->trace)
    {
      printf("0");
      svH263Printbits(code+2,4,TMNMVtab0[code].len);
      printf("): %d\n", TMNMVtab0[code].val);
    }
#endif
    return TMNMVtab0[code].val;
  }

  if (code>=128)
  {
    code = (code>>2) -32;
    ScBSSkipBits(BSIn, TMNMVtab1[code].len);

#if 0
    if (H263Info->trace)
    {
      printf("0");
      svH263Printbits(code+32,10,TMNMVtab1[code].len);
      printf("): %d\n",TMNMVtab1[code].val);
    }
#endif
    return TMNMVtab1[code].val;
  }

  if ((code-=5)<0)
  {
    if (!H263Info->quiet)
      fprintf(stderr,"Invalid motion_vector code\n");
    H263Info->expand=1;
    return 0;
  }

  ScBSSkipBits(BSIn, TMNMVtab2[code].len);
#if 0
  if (H263Info->trace)
  {
    printf("0");
    svH263Printbits(code+5,12,TMNMVtab2[code].len);
    printf("): %d\n",TMNMVtab2[code].val);
  }
#endif
  return TMNMVtab2[code].val;
}


int sv_H263GetMCBPC(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int code;

  if (H263Info->trace)
    printf("MCBPC (");

  code = (int)ScBSPeekBits(BSIn, 9);

  if (code == 1) {
    /* macroblock stuffing */
    if (H263Info->trace)
      printf("000000001): stuffing\n");
    ScBSSkipBits(BSIn, 9);
    return 255;
  }

  if (code == 0) {
    if (!H263Info->quiet) 
      fprintf(stderr,"Invalid MCBPC code\n");
    H263Info->expand = 1;
    return 0;
  }
    
  if (code>=256)
  {
    ScBSSkipBits(BSIn, 1);
    if (H263Info->trace)
      printf("1): %d\n",0);
    return 0;
  }
    
  ScBSSkipBits(BSIn, MCBPCtab[code].len);
#if 0
  if (H263Info->trace)
  {
    svH263Printbits(code,9,MCBPCtab[code].len);
    printf("): %d\n",MCBPCtab[code].val);
  }
#endif
  return MCBPCtab[code].val;
}

int sv_H263GetMODB(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int code;
  int MODB;

  if (H263Info->trace)
    printf("MODB (");

  code = (int)ScBSPeekBits(BSIn, 2);

  if (code < 2) {
    if (H263Info->trace)
      printf("0): MODB = 0\n");
    MODB = 0;
    ScBSSkipBits(BSIn, 1);
  }
  else if (code == 2) {
    if (H263Info->trace)
      printf("10): MODB = 1\n");
    MODB = 1;
    ScBSSkipBits(BSIn, 2);
  }
  else { /* code == 3 */
    if (H263Info->trace)
      printf("11): MODB = 2\n");
    MODB = 2;
    ScBSSkipBits(BSIn, 2);
  }
  return MODB;
}


int sv_H263GetMCBPCintra(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int code;

  if (H263Info->trace)
    printf("MCBPCintra (");

  code = (int)ScBSPeekBits(BSIn, 9);

  if (code == 1) {
    /* macroblock stuffing */
    if (H263Info->trace)
      printf("000000001): stuffing\n");
    ScBSSkipBits(BSIn, 9);
    return 255;
  }

  if (code < 8) {
    if (!H263Info->quiet) 
      fprintf(stderr,"Invalid MCBPCintra code\n");
    H263Info->expand = 1;
    return 0;
  }

  code >>= 3;
    
  if (code>=32)
  {
    ScBSSkipBits(BSIn, 1);
    if (H263Info->trace)
      printf("1): %d\n",3);
    return 3;
  }

  ScBSSkipBits(BSIn, MCBPCtabintra[code].len);
#if 0
  if (H263Info->trace)
  {
    svH263Printbits(code,6,MCBPCtabintra[code].len);
    printf("): %d\n",MCBPCtabintra[code].val);
  }
#endif
  return MCBPCtabintra[code].val;
}

int sv_H263GetCBPY(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn)
{
  int code;

  if (H263Info->trace)
    printf("CBPY (");

  code = (int)ScBSPeekBits(BSIn, 6);
  if (code < 2) {
    if (!H263Info->quiet) 
      fprintf(stderr,"Invalid CBPY code\n");
    H263Info->expand = 1;
    return -1;
  }
    
  if (code>=48)
  {
    ScBSSkipBits(BSIn, 2);
    if (H263Info->trace)
      printf("11): %d\n",0);
    return 0;
  }

  ScBSSkipBits(BSIn, CBPYtab[code].len);
#if 0
  if (H263Info->trace)
  {
    svH263Printbits(code,6,CBPYtab[code].len);
    printf("): %d\n",CBPYtab[code].val);
  }
#endif
  return CBPYtab[code].val;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech261\slib_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_api.c,v $
 * Revision 1.1.6.35  1996/12/13  18:19:04  Hans_Graves
 * 	Update Audio and Video timestamp correctly.
 * 	[1996/12/13  18:09:02  Hans_Graves]
 *
 * Revision 1.1.6.34  1996/12/12  20:54:44  Hans_Graves
 * 	Timestamp fixes after seek to Key frames.
 * 	[1996/12/12  20:52:06  Hans_Graves]
 *
 * Revision 1.1.6.33  1996/12/10  19:46:02  Hans_Graves
 * 	Fix floating division error when audio only.
 * 	[1996/12/10  19:45:03  Hans_Graves]
 *
 * Revision 1.1.6.32  1996/12/10  19:21:55  Hans_Graves
 * 	Made calculate video positions more accurate using slibFrameToTime100().
 * 	[1996/12/10  19:16:20  Hans_Graves]
 *
 * Revision 1.1.6.31  1996/12/05  20:10:15  Hans_Graves
 * 	Add gradual increase or decrease of framerates according to timestamps.
 * 	[1996/12/05  20:06:57  Hans_Graves]
 *
 * Revision 1.1.6.30  1996/12/04  22:34:28  Hans_Graves
 * 	Put limit on data used by Sv/SaDecompressBegin().
 * 	[1996/12/04  22:14:33  Hans_Graves]
 *
 * Revision 1.1.6.29  1996/12/03  23:15:13  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:43  Hans_Graves]
 *
 * Revision 1.1.6.28  1996/12/03  00:08:31  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:05:59  Hans_Graves]
 *
 * Revision 1.1.6.27  1996/11/21  23:34:21  Hans_Graves
 * 	Handle MPEG B frames better when seeking.
 * 	[1996/11/21  23:28:18  Hans_Graves]
 *
 * Revision 1.1.6.26  1996/11/20  02:15:09  Hans_Graves
 * 	Added SEEK_AHEAD.  Removed old code.
 * 	[1996/11/20  02:10:43  Hans_Graves]
 *
 * Revision 1.1.6.25  1996/11/18  23:07:21  Hans_Graves
 * 	Remove MaxVideoLength usage.
 * 	[1996/11/18  22:55:56  Hans_Graves]
 *
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:47:30  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/11/14  21:49:26  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:43:20  Hans_Graves]
 *
 * Revision 1.1.6.23  1996/11/13  16:10:54  Hans_Graves
 * 	AC3 recognition of byte reversed streams in slibGetDataFormat().
 * 	[1996/11/13  16:03:14  Hans_Graves]
 *
 * Revision 1.1.6.22  1996/11/11  18:21:03  Hans_Graves
 * 	More AC3 support changes.
 * 	[1996/11/11  17:59:01  Hans_Graves]
 *
 * Revision 1.1.6.21  1996/11/08  21:51:02  Hans_Graves
 * 	Added AC3 support. Better seperation of stream types.
 * 	[1996/11/08  21:27:57  Hans_Graves]
 *
 * Revision 1.1.6.20  1996/10/31  00:08:51  Hans_Graves
 * 	Fix skipping data after RESET with MPEG video only streams.
 * 	[1996/10/31  00:07:08  Hans_Graves]
 *
 * Revision 1.1.6.19  1996/10/28  23:16:42  Hans_Graves
 * 	MME-0145?, Fix artifacts when using SlibReadData() at a new position. Jump to first GOP.
 * 	[1996/10/28  23:13:01  Hans_Graves]
 *
 * Revision 1.1.6.18  1996/10/28  17:32:28  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:22:58  Hans_Graves]
 *
 * Revision 1.1.6.17  1996/10/17  00:23:32  Hans_Graves
 * 	Fix buffer problems after SlibQueryData() calls.
 * 	[1996/10/17  00:19:05  Hans_Graves]
 *
 * Revision 1.1.6.16  1996/10/15  17:34:09  Hans_Graves
 * 	Added MPEG-2 Program Stream support.
 * 	[1996/10/15  17:30:26  Hans_Graves]
 *
 * Revision 1.1.6.15  1996/10/12  17:18:51  Hans_Graves
 * 	Fixed some seeking problems. Moved render code to slib_render.c
 * 	[1996/10/12  17:00:49  Hans_Graves]
 *
 * Revision 1.1.6.14  1996/10/03  19:14:21  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:35  Hans_Graves]
 *
 * Revision 1.1.6.13  1996/09/29  22:19:37  Hans_Graves
 * 	Added stride support. Added SlibQueryData().
 * 	[1996/09/29  21:29:44  Hans_Graves]
 *
 * Revision 1.1.6.12  1996/09/25  19:16:44  Hans_Graves
 * 	Added DECOMPRESS_QUERY. Fix up support for YUY2.
 * 	[1996/09/25  19:00:45  Hans_Graves]
 *
 * Revision 1.1.6.11  1996/09/23  18:04:03  Hans_Graves
 * 	Added stats support. Scaleing and negative height fixes.
 * 	[1996/09/23  17:59:31  Hans_Graves]
 *
 * Revision 1.1.6.10  1996/09/18  23:46:32  Hans_Graves
 * 	Seek fixes. Added SlibReadData() and SlibAddBufferEx().
 * 	[1996/09/18  22:04:57  Hans_Graves]
 *
 * Revision 1.1.6.9  1996/08/09  20:51:42  Hans_Graves
 * 	Fix handle arg for SlibRegisterVideoBuffer()
 * 	[1996/08/09  20:10:11  Hans_Graves]
 *
 * Revision 1.1.6.8  1996/07/19  02:11:11  Hans_Graves
 * 	Added SlibRegisterVideoBuffer. Added YUV422i to RGB 16 rendering.
 * 	[1996/07/19  02:01:11  Hans_Graves]
 *
 * Revision 1.1.6.7  1996/06/03  21:41:12  Hans_Graves
 * 	Fix file seeking.  Always seeked to position 0.
 * 	[1996/06/03  21:40:44  Hans_Graves]
 *
 * Revision 1.1.6.6  1996/05/24  22:21:44  Hans_Graves
 * 	Merge MME-1221. Last SlibReadAudio() returned EndOfStream even if data read.
 * 	[1996/05/24  20:58:42  Hans_Graves]
 *
 * Revision 1.1.6.5  1996/05/23  18:46:35  Hans_Graves
 * 	Seperate global audio and video SInfo variables, to help multi-threaded apps
 * 	[1996/05/23  18:35:14  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/05/23  18:16:31  Hans_Graves
 * 	Added more YUV Conversions. MPEG audio buffering fix.
 * 	[1996/05/23  18:16:11  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/05/10  21:17:00  Hans_Graves
 * 	Added callback support. Also fill entire buffers when calling SlibReadAudio()
 * 	[1996/05/10  20:26:08  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/05/07  19:56:16  Hans_Graves
 * 	Added SlibOpen() and SlibAddBuffer() framework. Added HUFF_SUPPORT.
 * 	[1996/05/07  17:20:12  Hans_Graves]
 *
 * Revision 1.1.4.16  1996/05/02  17:10:33  Hans_Graves
 * 	Be more specific about checking for MPEG-2 Systems file type. Fixes MME-01234
 * 	[1996/05/02  17:04:44  Hans_Graves]
 *
 * Revision 1.1.4.15  1996/04/24  22:33:44  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:09  Hans_Graves]
 *
 * Revision 1.1.4.14  1996/04/23  21:22:31  Hans_Graves
 * 	Added description for SlibErrorSettingNotEqual
 * 	[1996/04/23  21:16:09  Hans_Graves]
 *
 * Revision 1.1.4.13  1996/04/22  15:04:51  Hans_Graves
 * 	Fix bad frame counts and seeking under NT caused by int overflows
 * 	[1996/04/22  15:02:26  Hans_Graves]
 *
 * Revision 1.1.4.12  1996/04/19  21:52:22  Hans_Graves
 * 	MPEG 1 Systems writing enhancements
 * 	[1996/04/19  21:47:48  Hans_Graves]
 *
 * Revision 1.1.4.11  1996/04/15  14:18:37  Hans_Graves
 * 	Handle any audio buffer size during encoding.
 * 	[1996/04/15  14:16:11  Hans_Graves]
 *
 * Revision 1.1.4.10  1996/04/12  19:25:20  Hans_Graves
 * 	Add MPEG2_VIDEO type to Commit
 * 	[1996/04/12  19:24:19  Hans_Graves]
 *
 * Revision 1.1.4.9  1996/04/10  21:47:41  Hans_Graves
 * 	Fix in SlibIsEnd().
 * 	[1996/04/10  21:39:37  Hans_Graves]
 *
 * Revision 1.1.4.8  1996/04/09  16:04:42  Hans_Graves
 * 	Remove NT warnings
 * 	[1996/04/09  14:42:48  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/04/04  23:35:07  Hans_Graves
 * 	Format conversion cleanup
 * 	[1996/04/04  23:16:20  Hans_Graves]
 *
 * Revision 1.1.4.6  1996/04/01  19:07:52  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:33  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/04/01  16:23:12  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:54  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/03/29  22:21:30  Hans_Graves
 * 	Added MPEG/JPEG/H261_SUPPORT ifdefs
 * 	[1996/03/29  21:56:55  Hans_Graves]
 *
 * 	Added MPEG-I Systems encoding support
 * 	[1996/03/27  21:55:54  Hans_Graves]
 *
 * Revision 1.1.4.3  1996/03/12  16:15:45  Hans_Graves
 * 	Added seperate streams to SlibIsEnd()
 * 	[1996/03/12  15:56:28  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:42  Hans_Graves
 * 	YUV conversions moved to slibRenderFrame()
 * 	[1996/03/08  18:14:47  Hans_Graves]
 *
 * Revision 1.1.2.18  1996/02/22  23:30:24  Hans_Graves
 * 	Update FPS on seeks
 * 	[1996/02/22  23:29:27  Hans_Graves]
 *
 * Revision 1.1.2.17  1996/02/22  22:23:56  Hans_Graves
 * 	Update frame numbers with timecode more often
 * 	[1996/02/22  22:23:07  Hans_Graves]
 *
 * Revision 1.1.2.16  1996/02/21  22:52:43  Hans_Graves
 * 	Fixed MPEG 2 systems stuff
 * 	[1996/02/21  22:50:55  Hans_Graves]
 *
 * Revision 1.1.2.15  1996/02/19  20:09:28  Hans_Graves
 * 	Debugging message clean-up
 * 	[1996/02/19  20:08:31  Hans_Graves]
 *
 * Revision 1.1.2.14  1996/02/19  18:03:54  Hans_Graves
 * 	Fixed a number of MPEG related bugs
 * 	[1996/02/19  17:57:36  Hans_Graves]
 *
 * Revision 1.1.2.13  1996/02/13  18:47:46  Hans_Graves
 * 	Fix some Seek related bugs
 * 	[1996/02/13  18:40:36  Hans_Graves]
 *
 * Revision 1.1.2.12  1996/02/07  23:23:54  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:29  Hans_Graves]
 *
 * Revision 1.1.2.11  1996/02/06  22:54:05  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:44:56  Hans_Graves]
 *
 * Revision 1.1.2.10  1996/02/02  17:36:02  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:44  Hans_Graves]
 *
 * Revision 1.1.2.9  1996/01/30  22:23:08  Hans_Graves
 * 	Added AVI YUV support
 * 	[1996/01/30  22:21:38  Hans_Graves]
 *
 * Revision 1.1.2.8  1996/01/15  16:26:27  Hans_Graves
 * 	Removed debuging message
 * 	[1996/01/15  16:02:47  Hans_Graves]
 *
 * 	Added MPEG 1 Audio compression and SlibWriteAudio()
 * 	[1996/01/15  15:45:46  Hans_Graves]
 *
 * Revision 1.1.2.7  1996/01/11  16:17:29  Hans_Graves
 * 	Added MPEG II Systems decode support
 * 	[1996/01/11  16:12:33  Hans_Graves]
 *
 * Revision 1.1.2.6  1996/01/08  16:41:31  Hans_Graves
 * 	Added MPEG II decoding support
 * 	[1996/01/08  15:53:02  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/12/08  20:01:20  Hans_Graves
 * 	Fixed SlibSetParam(). Added H.261 compression support.
 * 	[1995/12/08  19:53:52  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/12/07  19:31:36  Hans_Graves
 * 	Added JPEG Decoding and MPEG encoding support
 * 	[1995/12/07  18:30:10  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/11/09  23:14:05  Hans_Graves
 * 	Added MPEG audio decompression
 * 	[1995/11/09  23:08:33  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/11/06  18:47:52  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:36:01  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/


#include <fcntl.h>
#include <sys/stat.h>
#ifdef WIN32
#include <io.h>
#endif
#ifdef _SHM_
#include  <sys/ipc.h>  /* shared memory */
#endif
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
/* #include "SC_convert.h" */
#include "mpeg.h"
#include "ac3.h"
#include "avi.h"

#ifdef _SLIBDEBUG_
#include <stdio.h>
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#define _SEEK_      1  /* seek, frame counts/timecode info: 2=more detail */
#define _CALLBACK_  0  /* callback debugging */
#define _DUMP_      0  /* dump data in hex format */
#define _TIMECODE_  1  /* debug timecodes */
#endif

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype);

/*
** Lists
*/
static SlibList_t _listTypes [] = {
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG2_AUDIO,   "MPEG2_AUDIO", "MPEG-2 Audio Stream",0,0,
  SLIB_TYPE_AC3_AUDIO,     "AC3", "Dolby Digital(AC-3) Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,  "MPEG_SYSTEMS", "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG_SYSTEMS_MPEG2", "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,"MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,  "MPEG_PROGRAM", "MPEG Program Stream",0,0,
  SLIB_TYPE_H261,          "H261", "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
  SLIB_TYPE_H263,          "H263", "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_JFIF,          "JFIF",  "JPEG (JFIF) Stream",0,0,
  SLIB_TYPE_JPEG_QUICKTIME,"JPEG_QUICKTIME","JPEG (Quicktime) Stream",0,0,
  SLIB_TYPE_JPEG,          "JPEG",  "JPEG Stream",0,0,
  SLIB_TYPE_MJPG,          "MJPG",  "MJPG Stream",0,0,
  SLIB_TYPE_YUV,           "YUV",   "YUV Data",0,0,
  SLIB_TYPE_RGB,           "RGB",   "RGB Data",0,0,
  SLIB_TYPE_PCM,           "PCM",   "PCM Audio",0,0,
  SLIB_TYPE_SLIB,          "SLIB",  "SLIB Stream",0,0,
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
  0, NULL, "End of List",0,0
};

static SlibList_t _listCompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,        "MPEG1_VIDEO",   "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,        "MPEG1_AUDIO",   "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,        "MPEG2_VIDEO",   "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",  "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS", "MPEG Systems (MPEG-2)",0,0,
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",  "H.263 Video Stream",0,0,
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listDecompressTypes [] = {
#ifdef MPEG_SUPPORT
  SLIB_TYPE_MPEG1_VIDEO,   "MPEG1_VIDEO", "MPEG-1 Video Stream",0,0,
  SLIB_TYPE_MPEG1_AUDIO,   "MPEG1_AUDIO", "MPEG-1 Audio Stream",0,0,
  SLIB_TYPE_MPEG2_VIDEO,   "MPEG2_VIDEO", "MPEG-2 Video Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS,       "MPEG_SYSTEMS",   "MPEG Systems Stream",0,0,
  SLIB_TYPE_MPEG_SYSTEMS_MPEG2, "MPEG2_SYSTEMS",  "MPEG Systems (MPEG-2)",0,0,
  SLIB_TYPE_MPEG_TRANSPORT,     "MPEG_TRANSPORT", "MPEG Transport Stream",0,0,
  SLIB_TYPE_MPEG_PROGRAM,       "MPEG_PROGRAM",   "MPEG Program Stream",0,0,
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
  SLIB_TYPE_AC3_AUDIO,     "AC3",         "Dolby Digital(AC-3) Stream",0,0,
#endif /* AC3_SUPPORT */
#ifdef H261_SUPPORT
  SLIB_TYPE_H261,          "H261",  "H.261 Video Stream",0,0,
  SLIB_TYPE_RTP_H261,      "RTP_H261", "RTP (H.261) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
  SLIB_TYPE_H263,          "H263",     "H.263 Video Stream",0,0,
  SLIB_TYPE_RTP_H263,      "RTP_H263", "RTP (H.263) Stream",0,0,
#endif /* H261_SUPPORT */
#ifdef JPEG_SUPPORT
  SLIB_TYPE_JPEG_AVI,      "JPEG_AVI", "AVI (JPEG) Stream",0,0,
  SLIB_TYPE_MJPG_AVI,      "MJPG_AVI", "AVI (MJPG) Stream",0,0,
#endif /* JPEG_SUPPORT */
  SLIB_TYPE_RIFF,          "RIFF", "RIFF File Format",0,0,
  SLIB_TYPE_AVI,           "AVI", "AVI File Format",0,0,
  SLIB_TYPE_PCM_WAVE,      "PCM_WAVE", "WAVE (PCM) File Format",0,0,
  SLIB_TYPE_YUV_AVI,       "YUV_AVI", "AVI (YUV) File Format",0,0,
  SLIB_TYPE_RASTER,        "RASTER","Sun Raster",0,0,
  SLIB_TYPE_BMP,           "BMP",   "Windows Bitmap",0,0,
#ifdef HUFF_SUPPORT
  SLIB_TYPE_SHUFF,         "SHUFF", "SLIB Huffman Stream",0,0,
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
  SLIB_TYPE_G723,          "G723",  "G.723 Audio Stream",0,0,
#endif /* G723_SUPPORT */
  0, NULL, "End of List",0,0
};

static SlibList_t _listErrors[] = {
  SlibErrorNone,        "SlibErrorNone",
                        "No Error",0,0,
  SlibErrorInternal,    "SlibErrorInternal",
                        "Internal SLIB error",0,0,
  SlibErrorMemory,      "SlibErrorMemory",
                        "Unable to allocated memory",0,0,
  SlibErrorBadArgument, "SlibErrorBadArgument",
                        "Invalid argument to function",0,0,
  SlibErrorBadHandle,   "SlibErrorBadHandle",
                        "Invalid SLIB handle",0,0,
  SlibErrorBadMode,     "SlibErrorBadMode",
                        "Invalid SLIB mode",0,0,
  SlibErrorUnsupportedFormat, "SlibErrorUnsupportedFormat",
                        "Unsupported format",0,0,
  SlibErrorReading,     "SlibErrorReading",
                        "Error reading from file",0,0,
  SlibErrorWriting,     "SlibErrorWriting",
                        "Error writing to file",0,0,
  SlibErrorBufSize,     "SlibErrorBufSize",
                        "Buffer size is too small",0,0,
  SlibErrorEndOfStream, "SlibErrorEndOfStream",
                        "End of data stream",0,0,
  SlibErrorForwardOnly, "SlibErrorForwardOnly",
                        "The decompressor can work only forward",0,0,
  SlibErrorUnsupportedParam, "SlibErrorUnsupportedParam",
                        "The parameter is invalid or unsupported",0,0,
  SlibErrorImageSize,   "SlibErrorImageSize",
                        "Invalid image height and/or width size",0,0,
  SlibErrorSettingNotEqual, "SlibErrorSettingNotEqual",
                        "The exact parameter setting was not used",0,0,
  SlibErrorInit,        "SlibErrorInit",
                        "Initializing CODEC failed",0,0,
  SlibErrorFileSize,    "SlibErrorFileSize",
                        "Error in file size",0,0,
  SlibErrorBadPosition, "SlibErrorBadPosition",
                        "Error in seek position",0,0,
  SlibErrorBadUnit,     "SlibErrorBadUnit",
                        "Error in seek units",0,0,
  SlibErrorNoData,      "SlibErrorNoData",
                        "No data available",0,0,
  0, NULL, "End of List",0,0
};

SlibList_t *SlibFindEnumEntry(SlibList_t *list, int enumval)
{
  if (!list)
    return(NULL);
  while (list->Name)
  {
    if (list->Enum==enumval)
      return(list);
    list++;
  }
  return(NULL);
}

char *SlibGetErrorText(SlibStatus_t status)
{
  SlibList_t *entry=SlibFindEnumEntry(_listErrors, status);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int VCompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                      SvPictureInfo_t *pinfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VCompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VCompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              status=SvAddBuffer(Svh, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SvAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VCompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_VIDEO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->VideoPTimeCode);
                Info->VideoPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
                break;
              }
            }
            if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
               printf("VCompress CB_FRAME_START: TimeCode=%ld TemporalRef=%d\n",
                        pinfo->TimeCode, pinfo->TemporalRef) );
            Info->VideoPTimeCode=pinfo->TimeCode;
#if 0
            if (pinfo->Type==SV_I_PICTURE || pinfo->Type==SV_P_PICTURE)
            {
              if (!SlibTimeIsValid(Info->LastVideoDTimeCode))
                Info->VideoDTimeCode=-1000/(long)Info->FramesPerSec;
              else
                Info->VideoDTimeCode=Info->LastVideoDTimeCode;
              Info->LastVideoDTimeCode=pinfo->TimeCode;
              _SlibDebug(_CALLBACK_||_TIMECODE_,
                printf("CB_FRAME_START: LastVideoDTimeCode=%ld VideoDTimeCode=%ld\n",
                           Info->LastVideoDTimeCode, Info->VideoDTimeCode));
            }
            else
              Info->VideoDTimeCode=-1;
#endif
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int VDecompressCallback(SvHandle_t Svh, SvCallbackInfo_t *CB,
                                       SvPictureInfo_t *PictInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("VDecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_SEQ_END: /* reset presentation timestamps at end-of-sequence */
            _SlibDebug(_CALLBACK_ || _TIMECODE_,
              printf("VDecompressCallback received CB_SEQ_END message\n") );
            Info->VideoPTimeCode=SLIB_TIME_NONE;
            Info->AudioPTimeCode=SLIB_TIME_NONE;
            Info->VideoTimeStamp=SLIB_TIME_NONE;
            Info->AudioTimeStamp=SLIB_TIME_NONE;
            break;
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 1500*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_VIDEO, &size,
                                        &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(Info->AudioPTimeCode))
              {
                timediff=ptimestamp-Info->AudioPTimeCode;
                if (timediff>6000)
                {
                  /* Make sure a NEW audio time is not way out of
                   * sync with video time.
                   * This can happen after an End of Sequence.
                   */
                  /* assign audio time to video time */
                  Info->VideoPTimeCode=SLIB_TIME_NONE;
                  Info->VideoPTimeBase=Info->AudioPTimeBase;
                  ptimestamp=Info->AudioPTimeCode;
                }
              }
              if (SlibTimeIsValid(ptimestamp) &&
                  ptimestamp>Info->VideoPTimeCode)
              {
                SlibTime_t lasttime=Info->VideoPTimeCode;
                Info->VideoPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("VideoPTimeCode=%ld\n", Info->VideoPTimeCode) );
                ptimestamp-=Info->VideoPTimeBase;
                timediff=ptimestamp-Info->VideoTimeStamp;
                if (SlibTimeIsInValid(lasttime) ||
                    SlibTimeIsInValid(Info->VideoTimeStamp))
                {
                  _SlibDebug(_TIMECODE_,
                     printf("Updating VideoTimeStamp none->%ld\n",
                           ptimestamp) );
                  Info->VideoTimeStamp=ptimestamp;
                  Info->AvgVideoTimeDiff=0;
                  Info->VarVideoTimeDiff=0;
                }
                else /* see if times are far off */
                {
                  SlibTime_t lastavg=Info->AvgVideoTimeDiff;
                  Info->AvgVideoTimeDiff=(lastavg*14+timediff)/15;
                  Info->VarVideoTimeDiff=(Info->VarVideoTimeDiff*3+
                        lastavg-Info->AvgVideoTimeDiff)/4;
                  _SlibDebug(_CALLBACK_||_TIMECODE_,
                    printf("Video timediff: Cur=%ld Avg=%ld Var=%ld\n",
                              timediff, Info->AvgVideoTimeDiff,
                                        Info->VarVideoTimeDiff));
                  if (Info->VarVideoTimeDiff==0)
                  {
                    _SlibDebug(_TIMECODE_,
                      printf("Updating VideoTimeStamp %ld->%ld (diff=%ld)\n",
                           Info->VideoTimeStamp, ptimestamp,
                           ptimestamp-Info->VideoTimeStamp) );
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                  else if (Info->AvgVideoTimeDiff>=100
                           || Info->AvgVideoTimeDiff<=-100)
                  {
                    /* calculated time and timestamps are too far off */
                    float fps=Info->FramesPerSec;
                    if (Info->VarVideoTimeDiff>1 && fps>=15.5F)
                      fps-=0.25F;  /* playing too fast, slow frame rate */
                    else if (Info->VarVideoTimeDiff<-1 && fps<=59.0F)
                      fps+=0.25F;  /* playing too slow, speed up frame rate */
                    _SlibDebug(_WARN_ || _CALLBACK_||_TIMECODE_,
                        printf("Updating fps from %.4f -> %.4f\n",
                                 Info->FramesPerSec, fps) );
                    Info->FramesPerSec=fps;
                    Info->VideoFrameDuration=slibFrameToTime100(Info, 1);
                    Info->VideoTimeStamp=ptimestamp;
                    Info->AvgVideoTimeDiff=0;
                  }
                }
                Info->VideoFramesProcessed=0; /* reset frames processed */
              }
              if (CB->DataSize>0)
              {
                _SlibDebug(_DUMP_,
                  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_VIDEO);
                    printf("VDecompressCallback() Adding buffer of length %d\n",
                             CB->DataSize);
                  ScDumpChar(CB->Data, (int)CB->DataSize, (int)pin->Offset-CB->DataSize));
                CB->DataType = CB_DATA_COMPRESSED;
                _SlibDebug(_CALLBACK_,
                  printf("VDecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                status = SvAddBuffer(Svh, CB);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("VDecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("VDecompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_PROCESSING message\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("VDecompressCallback received CB_CODEC_DONE message\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

int ACompressCallback(SaHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_CALLBACK_, printf("ACompressCallback()\n") );

  CB->Action = CB_ACTION_CONTINUE;
  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ACompressCallback received CB_END_BUFFER message\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              CB->DataSize=Info->CompBufSize;
              CB->Data=SlibAllocBuffer(CB->DataSize);
              _SlibDebug(_CALLBACK_,
                printf("ACompressCallback() Adding buffer of length %d\n",
                             CB->DataSize) );
              status=SaAddBuffer(Sah, CB);
              _SlibDebug(_WARN_ && status!=NoErrors,
                        printf("SaAddBuffer() %s\n", ScGetErrorStr(status)) );
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ACompressCallback received CB_RELEASE_BUFFER message\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data && CB->DataUsed)
            {
              SlibPin_t *dstpin=slibGetPin(Info, SLIB_DATA_AUDIO);
              if (dstpin)
              {
                slibAddBufferToPin(dstpin, CB->Data, CB->DataUsed,
                                           Info->AudioPTimeCode);
                Info->AudioPTimeCode=SLIB_TIME_NONE;
                if (!slibCommitBuffers(Info, FALSE))
                  CB->Action = CB_ACTION_END;
              }
            }
            else if (CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_FRAME_START:
            _SlibDebug(_CALLBACK_||_TIMECODE_,
                 printf("ACompress CB_FRAME_START: TimeStamp=%ld Frame=%d\n",
                                   CB->TimeStamp, Info->VideoFramesProcessed
                                     ) );
            if (SlibTimeIsInValid(Info->AudioPTimeCode))
            {
              Info->AudioPTimeCode=CB->TimeStamp;
              _SlibDebug(_TIMECODE_,
                 printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
              _SlibDebug(_WARN_ && (Info->AudioTimeStamp-CB->TimeStamp>400 ||
                                    CB->TimeStamp-Info->AudioTimeStamp>400),
               printf("Bad Audio Time: AudioPTimeCode=%ld AudioTimestamp=%ld\n",
                     Info->AudioPTimeCode, Info->AudioTimeStamp) );
            }
            break;
  }
  return(NoErrors);
}

int ADecompressCallback(SvHandle_t Sah, SaCallbackInfo_t *CB, SaInfo_t *SaInfo)
{
  int status;
  unsigned dword size;
  SlibInfo_t *Info=(SlibInfo_t *)CB->UserData;
  _SlibDebug(_DEBUG_, printf("ADecompressCallback()\n") );

  switch (CB->Message)
  {
     case CB_END_BUFFERS:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_END_BUFFER\n") );
            if (CB->DataType==CB_DATA_COMPRESSED)
            {
              SlibTime_t ptimestamp, timediff;
              slibSetMaxInput(Info, 2000*1024); /* set limit for input data */
              CB->Data = SlibGetBuffer(Info, SLIB_DATA_AUDIO, &size,
                                                                &ptimestamp);
              slibSetMaxInput(Info, 0); /* clear limit */
              CB->DataSize = size;
              if (SlibTimeIsValid(ptimestamp))
              {
                Info->AudioPTimeCode=ptimestamp;
                _SlibDebug(_CALLBACK_||_TIMECODE_,
                  printf("AudioPTimeCode=%ld\n", Info->AudioPTimeCode) );
                ptimestamp-=Info->AudioPTimeBase;
                timediff=ptimestamp-Info->AudioTimeStamp;
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=ptimestamp;
                else if (timediff<-300 || timediff>300) /* time is far off */
                {
                  _SlibDebug(_WARN_||_TIMECODE_,
                    printf("Updating AudioTimeStamp %ld->%ld (diff=%ld)\n",
                         Info->AudioTimeStamp, ptimestamp,timediff) );
                  Info->AudioTimeStamp=ptimestamp;
                  if (SlibTimeIsValid(Info->VideoTimeStamp))
                  {
                    /* Make sure a NEW audio time is not way out of
                     * sync with video time.
                     * This can happen after an End of Sequence.
                     */
                    timediff=ptimestamp-Info->VideoTimeStamp;
                    if (timediff<-6000)
                    {
                      /* assign audio time to video time */
                      Info->VideoPTimeCode=SLIB_TIME_NONE;
                      Info->VideoPTimeBase=Info->AudioPTimeBase;
                      Info->VideoTimeStamp=ptimestamp;
                    }
                  }
                }
              }
              if (CB->Data)
              {
                if (CB->DataSize>0)
                {
                  CB->DataType = CB_DATA_COMPRESSED;
                  _SlibDebug(_CALLBACK_,
                    printf("ADecompressCallback() Adding buffer of length %d\n",
                               CB->DataSize) );
                  status = SaAddBuffer(Sah, CB);
                }
                else
                  SlibFreeBuffer(CB->Data);
              }
              else
              {
                _SlibDebug(_WARN_ || _CALLBACK_,
                   printf("ADecompressCallback() got no data\n") );
                CB->Action = CB_ACTION_END;
                return(NoErrors);
              }
            }
            break;
     case CB_RELEASE_BUFFER:
            _SlibDebug(_CALLBACK_,
            printf("ADecompressCallback() CB_RELEASE_BUFFER\n"));
            if (CB->DataType==CB_DATA_COMPRESSED && CB->Data)
              SlibFreeBuffer(CB->Data);
            break;
     case CB_PROCESSING:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_PROCESSING\n") );
            break;
     case CB_CODEC_DONE:
            _SlibDebug(_CALLBACK_,
              printf("ADecompressCallback() CB_CODEC_DONE\n") );
            break;
  }
  CB->Action = CB_ACTION_CONTINUE;
  return(NoErrors);
}

static void slibInitInfo(SlibInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("slibInitInfo()\n") );
  Info->Type = SLIB_TYPE_UNKNOWN;
  Info->Mode = SLIB_MODE_NONE;
  Info->Svh = NULL;
  Info->Sah = NULL;
  Info->Sch = NULL;
  Info->NeedAccuracy = FALSE;
  Info->TotalBitRate = 0;
  Info->MuxBitRate = 0;
  Info->SystemTimeStamp = 0;
  /* Audio parameters */
  Info->AudioStreams = 0;
  Info->SamplesPerSec = 0;
  Info->BitsPerSample = 0;
  Info->Channels = 0;
  Info->AudioBitRate = 0;
  Info->AudioMainStream = 0;
  Info->AudioType = SLIB_TYPE_UNKNOWN;
  /* Video parameters */
  Info->VideoStreams = 0;
  Info->Width = 0;
  Info->Height = 0;
  Info->Stride = 0;
  Info->VideoBitRate = 0;
  Info->FramesPerSec = 0.0F;
  Info->ImageSize = 0;
  Info->AudioPID = -1;
  Info->VideoPID = -1;
  Info->VideoMainStream = 0;
  Info->VideoType = SLIB_TYPE_UNKNOWN;
  /* Data Exchange */
  Info->Offset = 0;
  Info->Pins = NULL;
  Info->PinCount = 0;
  Info->IOError = FALSE;
  Info->MaxBytesInput = 0;
  Info->BytesProcessed = 0;
  /* stream dependent stuff */
  Info->VideoLength = 0;
  Info->VideoLengthKnown = FALSE;
  Info->VideoTimeStamp = SLIB_TIME_NONE;
  Info->VideoFrameDuration = 0;
  Info->AudioLength = 0;
  Info->AudioLengthKnown = FALSE;
  Info->AudioTimeStamp = SLIB_TIME_NONE;
  Info->LastAudioTimeStamp = SLIB_TIME_NONE;
  Info->KeySpacing = 0;
  Info->SubKeySpacing = 0;
  Info->VideoPTimeBase = SLIB_TIME_NONE;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->LastAudioPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoPTimeCode = SLIB_TIME_NONE;
  Info->LastVideoDTimeCode = SLIB_TIME_NONE;
  Info->AvgVideoTimeDiff = 0;
  Info->VarVideoTimeDiff = 0;
  Info->AudioPTimeBase = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  Info->VideoFramesProcessed=0;
  /* Encoding info */
  Info->HeaderProcessed = FALSE;
  Info->PacketCount = 0;
  Info->BytesSincePack = 0;
  /* Miscellaneous */
  Info->SlibCB = NULL;
  Info->SlibCBUserData = NULL;
  Info->Fd = -1;
  Info->FileSize = 0;
  Info->FileBufSize = 50*1024;
  Info->CompBufSize = 2*1024;
  Info->PacketSize = 512;
  Info->AudioFormat = NULL;
  Info->VideoFormat = NULL;
  Info->CompAudioFormat = NULL;
  Info->CompVideoFormat = NULL;
  Info->CodecVideoFormat = NULL;
  Info->VideoCodecState = SLIB_CODEC_STATE_NONE;
  Info->AudioCodecState = SLIB_CODEC_STATE_NONE;
  Info->Imagebuf = NULL;
  Info->IntImagebuf = NULL;
  Info->IntImageSize = 0;
  Info->CodecImagebuf = NULL;
  Info->CodecImageSize = 0;
  Info->Multibuf = NULL;
  Info->MultibufSize = 0;
  Info->Audiobuf = NULL;
  Info->AudiobufSize = 0;
  Info->AudiobufUsed = 0;
  Info->OverflowSize = 1500*1024;
  Info->VBVbufSize = 0;
  Info->stats = NULL;
  Info->dbg = NULL;
}

/*
** Name:    slibGetDataFormat
** Purpose: Find out the type of some multmedia data.
*/
static SlibType_t slibGetDataFormat(unsigned char *buf, int size,
                                             dword *headerstart,
                                             dword *headersize)
{
  dword i, count;
  unsigned char *bufptr;
  if (headersize)
    *headersize=0;
  if (size<4 || !buf)
    return(SLIB_TYPE_UNKNOWN);
  /*
  ** H261 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x01) &&
      (buf[2] & 0xF0)==0x00)
    return(SLIB_TYPE_H261);
  /*
  ** H263 video stream file
  */
  if ((buf[0] == 0x00) &&
      (buf[1] == 0x00) &&
      (buf[2] == 0x80) &&
      (buf[3] & 0xF8)==0x00)
    return(SLIB_TYPE_H263);
  /*
  ** JFIF file (ffd8 = Start-Of-Image marker)
  */
  if (buf[0] == 0xff && buf[1] == 0xd8)
    return(SLIB_TYPE_JFIF);
  /*
  ** QUICKTIME JPEG file (4 ignored bytes, "mdat", ff, d8, ff)
  */
  if ((strncmp(&buf[4], "mdat", 4) == 0 ) &&
      (buf[8]  == 0xff) &&
      (buf[9]  == 0xd8) &&
      (buf[10] == 0xff))
    return(SLIB_TYPE_JPEG_QUICKTIME);
  /*
  ** AVI RIFF file
  */
  if ( strncmp(buf, "RIFF", 4) == 0 )
  {
    if (strncmp(&buf[8], "WAVE",4) == 0)
      return(SLIB_TYPE_PCM_WAVE);
    else if (strncmp(&buf[8], "AVI ",4) == 0)
      return(SLIB_TYPE_AVI);
    else
      return(SLIB_TYPE_RIFF);
  }
  /*
  ** BMP file
  */
  if (buf[0] == 'B' && buf[1]=='M')
    return(SLIB_TYPE_BMP);
  /*
  ** Dolby AC-3 stream
  */
  if ((buf[0]==0x77 && buf[1] == 0x0B) ||  /* may be byte reversed */
      (buf[0]==0x0B && buf[1] == 0x77))
    return(SLIB_TYPE_AC3_AUDIO);

  /*
  ** Sun Raster file
  */
  if ((buf[0]==0x59 && buf[1] == 0xA6) ||  /* may be byte reversed */
      (buf[0]==0x6A && buf[1] == 0x95))
    return(SLIB_TYPE_RASTER);

  /*
  ** SLIB file
  */
  if ((buf[0] == 'S') && (buf[1] == 'L') &&
      (buf[2] == 'I') && (buf[3] == 'B'))
  {
    if ((buf[4] == 'H') && (buf[5] == 'U') &&  /* SLIB Huffman Stream */
        (buf[6] == 'F') && (buf[7] == 'F'))
      return(SLIB_TYPE_SHUFF);
    else
      return(SLIB_TYPE_SLIB);
  }
  /*
  ** MPEG II Transport Stream
  */
  if (buf[0] == MPEG_TSYNC_CODE &&
        (buf[3]&0x30)!=0) /* adaptation field value is not reserved */
    return(SLIB_TYPE_MPEG_TRANSPORT);
  if (buf[0] == MPEG_TSYNC_CODE && buf[1] == 0x1F &&
        buf[2]==0xFF) /* NULL PID */
    return(SLIB_TYPE_MPEG_TRANSPORT);

  /* search for mpeg startcode 000001 */
  bufptr=buf;
  for (i=4, count=size;
          i<count && (bufptr[0]!=0x00 || bufptr[1]!=0x00 || bufptr[2]!=0x01); i++)
    bufptr++;
  count-=i-4;
  if (headerstart)
    *headerstart=i-4;
  /*
  ** MPEG video file
  */
  if (bufptr[0] == 0x00 && bufptr[1] == 0x00 &&
      bufptr[2] == 0x01 && bufptr[3] == 0xB3)
  {
    if (headersize) /* calculate the header size */
    {
      *headersize=12;  /* minimum size is twelve bytes */
      if (count>11 && (bufptr[11]&0x02)) /* load_intra_quantizer_matrixe */
      {
        *headersize+=64;
        if (count>75 && bufptr[64+11]&0x01) /* load_non_intra_quantizer_matrix */
          *headersize+=64;
      }
      else if (count>11 && (bufptr[11]&0x01)) /* load_non_intra_quant_matrix */
        *headersize+=64;
    }
    return(SLIB_TYPE_MPEG1_VIDEO);
  }
  /*
  ** MPEG I Systems file
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xF0) == 0x20))
    return(SLIB_TYPE_MPEG_SYSTEMS);
  /*
  ** MPEG II Program Stream
  */
  if ((bufptr[0] == 0x00) && (bufptr[1] == 0x00) &&
      (bufptr[2] == 0x01) && (bufptr[3] == 0xba) &&
      ((bufptr[4]&0xC0) == 0x40))
    return(SLIB_TYPE_MPEG_PROGRAM);
  /*
  ** H263 video stream file
  */
  /* search for H.263 picture startcode 000000000000000100000 */
  for (bufptr=buf, i=0, count=size-4; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x00) &&
        (bufptr[2] == 0x80) &&
        (bufptr[3] & 0xF8)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H263 : SLIB_TYPE_H263);
  }
  /*
  ** H261 video stream file
  */
  /* search for H.261 picture startcode 00000000000000010000 */
  for (bufptr=buf, i=0, count=size-3; i<count; i++, bufptr++)
  {
    if ((bufptr[0] == 0x00) &&
        (bufptr[1] == 0x01) &&
        (bufptr[2] & 0xF0)==0x00)
      return(i>=12 ? SLIB_TYPE_RTP_H261 : SLIB_TYPE_H261);
  }
  /*
  ** MPEG audio stream file
  */
  if (buf[0]==0xFF && (buf[1] & 0xF0)==0xF0)
    return(SLIB_TYPE_MPEG1_AUDIO);

#ifdef G723_SUPPORT
  //Detect the RATEFLAG and VADFLAG in each frame in this
  //buffer.
  {
     int i,iFrameSize,iNoOfFrames;
     BOOL bRateFlag; //0 for High rate(6.3K 24bit), 1 for low rate(5.3K,20bit)
     BOOL bVADflag;  // 0 for Active speech  1 for Non-speech
     BOOL bTypeG723 = TRUE; //Initialized to say that it's a g723 media stream

     if(buf[0] & 0x1)
     {
        bRateFlag = TRUE; //Low rate 5.3K
        iFrameSize = 20;
     }
     else
     {
        bRateFlag = FALSE; //High Rate 6.3K
        iFrameSize = 24;
     }
     if(buf[0] & 0x2)
        bVADflag =TRUE;    //Non-Speech
     else
        bVADflag = FALSE;  //Active-Speech

     iNoOfFrames = size/iFrameSize;
     if (iNoOfFrames>15) iNoOfFrames=15; /* just check first 15 frames */
     //Leave the first frame.The first frame is used to extract
     // the above information.Check for this info in the remaining
     // frames.If it exists in all frames,the audio is G723 ,otherwise
     // audio type is Unknown.
     for(i =1; i < iNoOfFrames;i++)
     {
       //Search for RateFlag and bVADflag for each frame
       if(((buf[i*iFrameSize] & 0x1) == bRateFlag) &&
          ((buf[i*iFrameSize] & 0x2) == bVADflag))
         continue;
       //type is Unknown ,Set the flag to false and
       //break from the for loop
       bTypeG723 = FALSE;
       break;
     }
     if(bTypeG723)
       return(SLIB_TYPE_G723);
  }
#endif /* G723_SUPPORT */
  _SlibDebug(_WARN_, printf("slibGetDataFormat() Unknown file format\n") );
  return(SLIB_TYPE_UNKNOWN);
}

SlibStatus_t SlibQueryData(void *databuf, unsigned dword databufsize,
                              SlibQueryInfo_t *qinfo)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  if (!databuf)
    return(SlibErrorBadArgument);
  if (databufsize==0)
    return(SlibErrorBufSize);
  qinfo->Bitrate=0;
  qinfo->VideoStreams=0;
  qinfo->Width=0;
  qinfo->Height=0;
  qinfo->VideoBitrate=0;
  qinfo->FramesPerSec=0.0F;
  qinfo->VideoLength=0;
  qinfo->AudioStreams=0;
  qinfo->SamplesPerSec=0;
  qinfo->BitsPerSample=0;
  qinfo->Channels=0;
  qinfo->AudioBitrate=0;
  qinfo->AudioLength=0;
  qinfo->Type = slibGetDataFormat(databuf, databufsize,
                                  &qinfo->HeaderStart, &qinfo->HeaderSize);
  if (qinfo->Type!=SLIB_TYPE_UNKNOWN)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
      return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Mode = SLIB_MODE_DECOMPRESS;
    Info->Type = qinfo->Type;
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
    status=slibManageUserBuffer(NULL, databuf, databufsize, NULL);
    if (status==SlibErrorNone)
      status=slibAddBufferToPin(slibGetPin(Info, SLIB_DATA_COMPRESSED),
                                       databuf, databufsize, SLIB_TIME_NONE);
    if (status!=SlibErrorNone)
    {
      SlibClose((SlibHandle_t)Info);
      return(status);
    }
    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->TotalBitRate==0)
      qinfo->Bitrate=Info->AudioBitRate+
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    else
      qinfo->Bitrate=Info->TotalBitRate;
    qinfo->VideoStreams=Info->VideoStreams;
    qinfo->Width=Info->Width;
    qinfo->Height=Info->Height;
    qinfo->VideoBitrate=Info->VideoBitRate;
    qinfo->FramesPerSec=Info->FramesPerSec;
    qinfo->VideoLength=Info->VideoLength;
    qinfo->AudioStreams=Info->AudioStreams;
    qinfo->SamplesPerSec=Info->SamplesPerSec;
    qinfo->BitsPerSample=Info->BitsPerSample;
    qinfo->Channels=Info->Channels;
    qinfo->AudioBitrate=Info->AudioBitRate;
    qinfo->AudioLength=Info->AudioLength;
    SlibClose((SlibHandle_t)Info);
    return(SlibErrorNone);
  }
  return(SlibErrorUnsupportedFormat);
}
/************************** The Main Slib API ***********************/

SlibStatus_t SlibOpen(SlibHandle_t *handle, SlibMode_t smode,
                   SlibType_t *stype, SlibMessage_t (*slibCB)(SlibHandle_t,
                         SlibMessage_t, SlibCBParam1_t, SlibCBParam2_t, void *),
                         void *cbuserdata)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpen()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!slibCB)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  Info->SlibCB = slibCB;
  Info->SlibCBUserData = cbuserdata;
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenSync(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, void *buffer, unsigned dword bufsize)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenSync()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    /* for decompression we need the first buffer to open the codecs */
    if (!buffer || bufsize==0)
      return(SlibErrorBadArgument);
  }
  if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
     return(SlibErrorMemory);
  slibInitInfo(Info);
  Info->Mode=smode;
  slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  if (smode == SLIB_MODE_DECOMPRESS)
  {
    status=SlibAddBuffer((SlibHandle_t *)Info, SLIB_DATA_COMPRESSED, buffer, bufsize);
    if (status!=SlibErrorNone)
      return(status);
  }
  *handle=(SlibHandle_t)Info;
  if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
    *handle = NULL;
  return(status);
}

SlibStatus_t SlibOpenFile(SlibHandle_t *handle, SlibMode_t smode,
                          SlibType_t *stype, char *filename)
{
  SlibInfo_t *Info=NULL;
  SlibStatus_t status;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  *handle = NULL;
  if (!stype)
    return(SlibErrorBadArgument);
  if (!filename)
    return(SlibErrorBadArgument);
  if (smode == SLIB_MODE_COMPRESS)
  {
    if (SlibFindEnumEntry(_listCompressTypes, *stype)==NULL)
      return(SlibErrorUnsupportedFormat);
    if ((Info = (SlibInfo_t *) ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForWriting(filename, TRUE);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorWriting);
    }
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    if ((Info = (SlibInfo_t *)ScAlloc(sizeof(SlibInfo_t))) == NULL)
       return(SlibErrorMemory);
    slibInitInfo(Info);
    Info->Fd = ScFileOpenForReading(filename);
    if (Info->Fd<0)
    {
      ScFree(Info);
      return(SlibErrorReading);
    }
    ScFileSize(filename, &Info->FileSize);
    *handle=(SlibHandle_t)Info;
    if ((status=slibOpen(handle, smode, stype))!=SlibErrorNone)
      *handle = NULL;
    return(status);
  }
  else
    return(SlibErrorBadMode);
}

static SlibStatus_t slibOpen(SlibHandle_t *handle, SlibMode_t smode,
                             SlibType_t *stype)
{
  SlibInfo_t *Info=(SlibInfo_t *)*handle;
  unsigned char *buf;
  unsigned dword size;
  _SlibDebug(_VERBOSE_,printf("SlibOpenFile()\n") );
  if (!Info)
    return(SlibErrorMemory);
  if (!stype)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("slibOpen() SlibCB(SLIB_MSG_OPEN)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                      SLIB_MSG_OPEN, (SlibCBParam1_t)0,
                    (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
  }
  if (smode == SLIB_MODE_COMPRESS)
  {
    Info->Mode = smode;
    Info->Type = *stype;
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    switch (Info->Type)
    {
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG_SYSTEMS:
      case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
      case SLIB_TYPE_MPEG1_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2 ?
                               SV_MPEG2_ENCODE : SV_MPEG_ENCODE,
                               &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             if (Info->Type==SLIB_TYPE_MPEG1_VIDEO)
               break;
      case SLIB_TYPE_MPEG1_AUDIO:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_MPEG_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_MPEG2_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H261_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_H263_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             Info->VideoStreams = 1;
             if (SvOpenCodec (SV_HUFF_ENCODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
             break;
#endif /* HUFF_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             Info->AudioStreams = 1;
             if (SaOpenCodec (SA_G723_ENCODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
             break;

#endif /*G723_SUPPORT*/
      default:
             return(SlibErrorUnsupportedFormat);
    }
    slibAddPin(Info, SLIB_DATA_COMPRESSED, "Compressed");
  }
  else if (smode == SLIB_MODE_DECOMPRESS)
  {
    Info->Mode = smode;
    /*
    ** Determine the input data type
    */
    if (slibLoadPin(Info, SLIB_DATA_COMPRESSED)==NULL)
      return(SlibErrorReading);
    if ((buf=SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, &size, NULL))==NULL
             || size<=0)
    {
      /* couldn't get any compressed data */
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorReading);
    }
    Info->Type = slibGetDataFormat(buf, size, NULL, NULL);
    /* if we can't determine the type, use stype as the type */
    if (Info->Type==SLIB_TYPE_UNKNOWN && stype)
      Info->Type=*stype;
    if (SlibFindEnumEntry(_listDecompressTypes, Info->Type)==NULL)
    {
      SlibClose((SlibHandle_t)Info);
      return(SlibErrorUnsupportedFormat);
    }

    slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
    slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
    if (SlibTypeIsMPEGMux(Info->Type))
    {
      /* need to select main streams for multiplexed streams */
      Info->AudioMainStream=MPEG_AUDIO_STREAM_START;
      Info->VideoMainStream=MPEG_VIDEO_STREAM_START;
      /* private data may be needed - i.e. AC3 */
      slibAddPin(Info, SLIB_DATA_PRIVATE, "Private");
    }
    SlibUpdateAudioInfo(Info);
    SlibUpdateVideoInfo(Info);
    if (Info->AudioStreams<=0)
      slibRemovePin(Info, SLIB_DATA_AUDIO);
    if (Info->VideoStreams<=0)
      slibRemovePin(Info, SLIB_DATA_VIDEO);

    slibRemovePin(Info, SLIB_DATA_PRIVATE); /* only used in init */
    if (Info->AudioBitRate && Info->VideoBitRate)
    {
      if (!Info->VideoLengthKnown)
      {
        qword ms=((qword)Info->FileSize*80L)/
                   (Info->AudioBitRate+Info->VideoBitRate);
        ms = (ms*75)/80; /* adjust for systems data */
        Info->AudioLength = Info->VideoLength = (SlibTime_t)ms*100;
        _SlibDebug(_SEEK_||_VERBOSE_,
            ScDebugPrintf(Info->dbg,"slibOpen() FileSize=%ld VideoLength=%ld\n",
                    Info->FileSize, Info->VideoLength) );
      }
      else if (Info->VideoLengthKnown && Info->FramesPerSec)
        Info->AudioLength = Info->VideoLength;
    }
    if (Info->TotalBitRate==0)
      Info->TotalBitRate=Info->AudioBitRate +
                     ((Info->VideoBitRate>100000000)?0:Info->VideoBitRate);
    _SlibDebug(_SEEK_||_VERBOSE_,
               ScDebugPrintf(Info->dbg,"AudioLength=%ld VideoLength=%ld %s\n",
                   Info->AudioLength, Info->VideoLength,
                   Info->VideoLengthKnown?"(known)":"") );

    if (Info->AudioType==SLIB_TYPE_UNKNOWN &&
        Info->VideoType==SLIB_TYPE_UNKNOWN)
      return(SlibErrorUnsupportedFormat);
    switch (Info->AudioType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_AUDIO:
             if (SaOpenCodec (SA_MPEG_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
             if (SaOpenCodec (SA_GSM_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
	  case SLIB_TYPE_AC3_AUDIO:
             if (SaOpenCodec (SA_AC3_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
      case SLIB_TYPE_G723:
             if (SaOpenCodec (SA_G723_DECODE, &Info->Sah)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->AudioCodecState=SLIB_CODEC_STATE_OPEN;
             break;
#endif /* G723_SUPPORT */
    } /* AudioType */
    switch (Info->VideoType)
    {
      case SLIB_TYPE_UNKNOWN:
             break;
#ifdef MPEG_SUPPORT
      case SLIB_TYPE_MPEG1_VIDEO:
             if (SvOpenCodec (SV_MPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
      case SLIB_TYPE_MPEG2_VIDEO:
             if (SvOpenCodec (SV_MPEG2_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
      case SLIB_TYPE_H261:
             if (SvOpenCodec (SV_H261_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
      case SLIB_TYPE_H263:
             if (SvOpenCodec (SV_H263_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* H263_SUPPORT */
#ifdef HUFF_SUPPORT
      case SLIB_TYPE_SHUFF:
             if (SvOpenCodec (SV_HUFF_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* HUFF_SUPPORT */
#ifdef JPEG_SUPPORT
      case SLIB_TYPE_JPEG:
      case SLIB_TYPE_MJPG:
             if (SvOpenCodec (SV_JPEG_DECODE, &Info->Svh)!=SvErrorNone)
             {
               SlibClose((SlibHandle_t)Info);
               return(SlibErrorUnsupportedFormat);
             }
             Info->VideoCodecState=SLIB_CODEC_STATE_OPEN;
             _SlibDebug(_DEBUG_,printf("VideoCodecState=OPEN\n"));
             break;
#endif /* JPEG_SUPPORT */
    } /* VideoType */
  }
  else
    return(SlibErrorBadMode);
  *stype = Info->Type;
  return(SlibErrorNone);
}

SlibStatus_t SlibAddBuffer(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  if (Info->SlibCB)
  {
    status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
    if (status!=SlibErrorNone)
      return(status);
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  }
  else if (!SlibValidBuffer(buffer))
  {
    /* we need to create a SLIB allocated buffer to copy the
     * output to and then add to the compressed data pin
     */
    unsigned char *bufptr=SlibAllocBuffer(bufsize);
    if (!bufptr)
      return(SlibErrorMemory);
    memcpy(bufptr, buffer, bufsize);
    status=slibAddBufferToPin(dstpin, bufptr, bufsize, SLIB_TIME_NONE);
  }
  else
    status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    ScBitstream_t *BS;
    Info->IOError=FALSE;
    /* reset end-of-input flags in bitstream objects */
    if (Info->Svh)
    {
      BS=SvGetDataSource(Info->Svh);
      if (BS && BS->EOI) ScBSReset(BS);
    }
    if (Info->Sah)
    {
      BS=SaGetDataSource(Info->Sah);
      if (BS && BS->EOI) ScBSReset(BS);
    }
  }
  return(status);
}

SlibStatus_t SlibAddBufferEx(SlibHandle_t handle, SlibDataType_t dtype,
                                void *buffer, unsigned dword bufsize,
                                void *userdata)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibPin_t *dstpin;
  if (!handle)
    return(SlibErrorBadHandle);
  dstpin = slibGetPin(Info, dtype);
  if (dstpin==NULL || buffer==NULL)
    return(SlibErrorBadArgument);
  status=slibManageUserBuffer(Info, buffer, bufsize, userdata);
  if (status!=SlibErrorNone)
    return(status);
  status=slibAddBufferToPin(dstpin, buffer, bufsize, SLIB_TIME_NONE);
  return(status);
}

SlibStatus_t slibStartVideo(SlibInfo_t *Info, SlibBoolean_t fillbuf)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartVideo()\n") );
  if (Info->VideoCodecState==SLIB_CODEC_STATE_NONE ||
      Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) %s\n",
      fillbuf,Info->VideoCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"slibStartVideo(filebuf=%d) OPEN\n",
                                                      fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else if (Info->Svh)
      {
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback()\n") );
        status = SvRegisterCallback(Info->Svh, VDecompressCallback, (void *)Info);
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataSource(Info->Svh)==NULL)
        {
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"SvRegisterCallback(NULL)\n") );
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        }
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                           ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                             ScGetErrorStr(status)) );
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("VideoCodecState=INITED\n"));
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS)
    {
      if (Info->TotalBitRate==0)
      {
#ifdef MPEG_SUPPORT
        if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS || /* default to 1XCDROM rate */
            Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
          SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
        slibValidateBitrates(Info);  /* update bitrates */
      }
      if (Info->Svh)
      {
        status = SvRegisterCallback(Info->Svh, VCompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SvErrorNone,
                      ScDebugPrintf(Info->dbg,"SvRegisterCallback() %s\n",
                           ScGetErrorStr(status)) );
        /* if codec is not bitstreaming, don't use callbacks */
        if (status==SlibErrorNone && SvGetDataDestination(Info->Svh)==NULL)
          status = SvRegisterCallback(Info->Svh, NULL, NULL);
        Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_INITED ||
      Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,
           "slibStartVideo(fillbuf=%d) INITED || REPOSITIONING\n",fillbuf));
    if (Info->Mode==SLIB_MODE_DECOMPRESS)
    {
      if (Info->Type==SLIB_TYPE_YUV_AVI)
      {
        if (Info->CompVideoFormat->biCompression !=
             Info->VideoFormat->biCompression &&
             Info->Multibuf==NULL)
        {
          Info->MultibufSize=Info->ImageSize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
      else if (Info->Svh)
      {
        int mbufsize;
        if (1) /* fillbuf && Info->CodecVideoFormat) */
        {
          Info->CodecVideoFormat->biCompression=
            SlibGetParamInt((SlibHandle_t)Info, SLIB_STREAM_MAINVIDEO,
                                       SLIB_PARAM_NATIVEVIDEOFORMAT);
          if (Info->CodecVideoFormat->biCompression==0)
            Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
        }
        else
        {
          Info->CodecVideoFormat->biCompression=
                       Info->VideoFormat->biCompression;
          Info->CodecVideoFormat->biBitCount=
                       Info->VideoFormat->biBitCount;
        }
        slibValidateVideoParams(Info);
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,
                    "SvDecompressBegin(%c%c%c%c/%d bits,%c%c%c%c/%d bits)\n",
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount) );
        status=SvDecompressBegin(Info->Svh, Info->CompVideoFormat,
                          Info->CodecVideoFormat);
        if (status==SvErrorNone)
        {
          Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
          Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
          Info->HeaderProcessed=TRUE; /* we must have processed header info */
          _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
        }
        else if (status==SvErrorEndBitstream)
          return(SlibErrorNoBeginning);
        else
        {
          _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvDecompressBegin() %s\n",
                                ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvGetDecompressSize\n") );
        SvGetDecompressSize(Info->Svh, &mbufsize);
        if (Info->Multibuf==NULL || Info->MultibufSize<mbufsize)
        {
          if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
          Info->MultibufSize=mbufsize;
          Info->Multibuf = SlibAllocSharedBuffer(Info->MultibufSize, NULL);
        }
      }
    }
    else if (Info->Mode==SLIB_MODE_COMPRESS && Info->Svh)
    {
      status=SvCompressBegin(Info->Svh, Info->CodecVideoFormat,
                             Info->CompVideoFormat);
      if (status==SvErrorNone)
      {
        Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
        Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
        Info->VideoCodecState=SLIB_CODEC_STATE_BEGUN;
        _SlibDebug(_DEBUG_,ScDebugPrintf(Info->dbg,"VideoCodecState=BEGUN\n"));
      }
      else
      {
        _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SvCompressBegin() %s\n",
                                 ScGetErrorStr(status)) );
        return(SlibErrorUnsupportedFormat);
      }
    }
  }
  if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    return(SlibErrorNone);
  else
    return(SlibErrorInit);
}

static SlibStatus_t slibStartAudio(SlibInfo_t *Info)
{
  SvStatus_t status=SvErrorNone;
  _SlibDebug(_VERBOSE_,printf("slibStartAudio()\n") );
  if (Info->AudioCodecState==SLIB_CODEC_STATE_NONE ||
      Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() %s\n",
      Info->AudioCodecState==SLIB_CODEC_STATE_NONE ? "NONE" : "BEGUN") );
    return(SlibErrorNone);
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_OPEN)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() OPEN\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        status = SaRegisterCallback(Info->Sah, ADecompressCallback, (void *)Info);
        if (status!=SaErrorNone)
        {
          _SlibDebug(_WARN_, printf("SaRegisterCallback() ",
                         ScGetErrorStr(status)) );
          return(SlibErrorInternal);
        }
        status = SaSetDataSource(Info->Sah, SA_USE_BUFFER_QUEUE, 0, (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                       printf("SaSetDataSource() ", ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        if (Info->TotalBitRate==0)
        {
#ifdef MPEG_SUPPORT
          /* default to 1X CDROM rate */
          if (Info->Type==SLIB_TYPE_MPEG_SYSTEMS ||
              Info->Type==SLIB_TYPE_MPEG_SYSTEMS_MPEG2)
            SlibSetParamInt((SlibHandle_t)Info, SLIB_STREAM_ALL,
                          SLIB_PARAM_BITRATE, 44100*16*2);
#endif
          slibValidateBitrates(Info);  /* update bitrates */
        }
        status = SaRegisterCallback(Info->Sah, ACompressCallback, (void *)Info);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                  printf("SaRegisterCallback() %s\n", ScGetErrorStr(status)) );
        status = SaSetDataDestination(Info->Sah, SA_USE_BUFFER_QUEUE, 0,
                                      (void *)Info, 0);
        _SlibDebug(_WARN_ && status!=SaErrorNone,
                        printf("SaSetDataDestination() %s\n",
                           ScGetErrorStr(status)) );
        Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
        _SlibDebug(_DEBUG_,printf("AudioCodecState=INITED\n"));
      }
    }
  }
  if (Info->AudioCodecState==SLIB_CODEC_STATE_INITED ||
      Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING)
  {
    _SlibDebug(_DEBUG_,printf("slibStartAudio() INITED || REPOSITIONING\n"));
    if (Info->Sah)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
      {
        Info->AudiobufUsed=0;
        /* don't want codec to search through to much data for start */
        status=SaDecompressBegin(Info->Sah, Info->CompAudioFormat,
                                 Info->AudioFormat);
        if (status==SaErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else if (status==SlibErrorNoBeginning)
          return(SlibErrorEndOfStream);
        else
        {
          _SlibDebug(_WARN_, printf("SaDecompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
      else if (Info->Mode==SLIB_MODE_COMPRESS)
      {
        status=SaCompressBegin(Info->Sah, Info->AudioFormat,
                          Info->CompAudioFormat);
        if (status==SvErrorNone)
        {
          Info->AudioCodecState=SLIB_CODEC_STATE_BEGUN;
          _SlibDebug(_DEBUG_,printf("AudioCodecState=BEGUN\n"));
        }
        else
        {
          _SlibDebug(_WARN_, printf("SaCompressBegin() %s\n",
                               ScGetErrorStr(status)) );
          return(SlibErrorUnsupportedFormat);
        }
      }
    }
  }
  return(SlibErrorNone);
}


SlibStatus_t SlibRegisterVideoBuffer(SlibHandle_t handle,
                                void *buffer, unsigned dword bufsize)
{
  SvStatus_t status;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  dword mbufsize;
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Multibuf) SlibFreeBuffer(Info->Multibuf);
  Info->MultibufSize=bufsize;
  Info->Multibuf = buffer;
  status=slibManageUserBuffer(Info, buffer, bufsize, NULL);
  if (Info->Svh)
  {
    SvGetDecompressSize(Info->Svh, &mbufsize);
    if (bufsize<(unsigned dword)mbufsize)
      return(SlibErrorBufSize);
  }
  return(status);
}

SlibStatus_t SlibReadData(SlibHandle_t handle, SlibStream_t stream,
                          void **databuf, unsigned dword *databufsize,
                          SlibStream_t *readstream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  int pinid;
  SlibPin_t *pin;
  SlibTime_t ptimestamp;
  _SlibDebug(_VERBOSE_, printf("SlibReadDATA()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!databuf) /* we're querying to find out how much data is queued */
  {
    if (!databufsize)
      return(SlibErrorBadArgument);
    if (Info->Mode==SLIB_MODE_COMPRESS)
      pinid=SLIB_DATA_COMPRESSED;
    else if (stream==SLIB_STREAM_MAINVIDEO)
      pinid=SLIB_DATA_VIDEO;
    else if (stream==SLIB_STREAM_MAINAUDIO)
      pinid=SLIB_DATA_AUDIO;
    else
    {
      *databufsize=(unsigned dword)slibDataOnPins(Info); /* get amount of data on all pins */
      return(SlibErrorNone);
    }
    *databufsize=(unsigned dword)slibDataOnPin(Info, SLIB_DATA_COMPRESSED);
    return(SlibErrorNone);
  }
  if (Info->Mode==SLIB_MODE_COMPRESS)
  {
    pinid=SLIB_DATA_COMPRESSED;
    stream=SLIB_STREAM_ALL;
    /* flush out all compressed data */
    if (Info->Sah)
      ScBSFlush(SaGetDataDestination(Info->Sah));
    if (Info->Svh)
      ScBSFlush(SvGetDataDestination(Info->Svh));
  }
  else /* SLIB_MODE_DECOMPRESS */
  {
    if (stream==SLIB_STREAM_ALL && (Info->AudioStreams || Info->VideoStreams))
    {
      if (Info->AudioStreams==0) /* there's only video */
        stream=SLIB_STREAM_MAINVIDEO;
      else if (Info->VideoStreams==0) /* there's only audio */
        stream=SLIB_STREAM_MAINAUDIO;
      else if (slibDataOnPin(Info, SLIB_DATA_AUDIO)>
               slibDataOnPin(Info, SLIB_DATA_VIDEO)) /* more audio than video */
        stream=SLIB_STREAM_MAINAUDIO;
      else
        stream=SLIB_STREAM_MAINVIDEO;
    }
    switch (stream) /* translate stream to pin */
    {
      case SLIB_STREAM_MAINVIDEO:
          pinid=SLIB_DATA_VIDEO;
          break;
      case SLIB_STREAM_MAINAUDIO:
          pinid=SLIB_DATA_AUDIO;
          break;
      default:
          return(SlibErrorBadStream);
    }
  }
  if (readstream)
    *readstream=stream;
  pin=slibLoadPin(Info,  pinid);
  if (pin==NULL)
    return(Info->Mode==SLIB_MODE_COMPRESS?SlibErrorNoData:SlibErrorBadStream);
  if (stream==SLIB_STREAM_MAINVIDEO && Info->Mode==SLIB_MODE_DECOMPRESS &&
      Info->VideoPTimeCode==SLIB_TIME_NONE &&
      SlibTypeIsMPEG(Info->Type))
  {
    /* search from GOP start */
    dword i, iend;
    SlibTime_t nexttime;
    unsigned char *tmpbuf, *prevbuf=NULL;
    unsigned dword tmpsize, bytessearched=0;
    tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &ptimestamp);
    if (tmpbuf==NULL)
      return(SlibErrorEndOfStream);
    do {
      for (i=0, iend=tmpsize-3; i<iend; i++)
        if (tmpbuf[i]==0&&tmpbuf[i+1]==0&&tmpbuf[i+2]==1&&
                      (tmpbuf[i+3]==0xB8||tmpbuf[i+3]==0xB3))
          break;
      if (i<iend)
      {
        slibInsertBufferOnPin(pin, tmpbuf+i, tmpsize-i, ptimestamp);
        tmpbuf=NULL;
        break;
      }
      else if (tmpbuf[i]==0 && tmpbuf[i+1]==0 && tmpbuf[i+2]==1)
      {
        prevbuf=tmpbuf+tmpsize-3;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0xB8||tmpbuf[0]==0xB3)
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 3, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+1]==0 && tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-2;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==1 && (tmpbuf[1]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 2, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else if (tmpbuf[i+2]==0)
      {
        prevbuf=tmpbuf+tmpsize-1;
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
        if (tmpbuf[0]==0 && tmpbuf[1]==1 && (tmpbuf[2]==0xB8||tmpbuf[0]==0xB3))
        {
          slibInsertBufferOnPin(pin, tmpbuf, tmpsize, nexttime);
          slibInsertBufferOnPin(pin, prevbuf, 1, ptimestamp);
          tmpbuf=NULL;
          break;
        }
        else
          SlibFreeBuffer(prevbuf);
      }
      else
      {
        SlibFreeBuffer(tmpbuf);
        tmpbuf=SlibGetBuffer(Info, pinid, &tmpsize, &nexttime);
        if (tmpbuf==NULL)
          return(SlibErrorEndOfStream);
        if (nexttime!=SLIB_TIME_NONE)
          ptimestamp=nexttime;
      }
      bytessearched+=tmpsize;
    } while (tmpbuf && bytessearched<512*1024);
  }
  if (*databuf==NULL)
    *databuf=SlibGetBuffer(Info, pinid, databufsize, &ptimestamp);
  else
    *databufsize=slibFillBufferFromPin(Info, pin, *databuf, *databufsize,
                          &ptimestamp);
  if (Info->Mode==SLIB_MODE_DECOMPRESS)
  {
    if (ptimestamp!=SLIB_TIME_NONE)
      switch (stream) /* set presentation timecodes */
      {
        case SLIB_STREAM_MAINVIDEO:
            Info->VideoPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() VideoPTimeCode=%ld\n", ptimestamp) );
            break;
        case SLIB_STREAM_MAINAUDIO:
            Info->AudioPTimeCode=ptimestamp;
            _SlibDebug(_TIMECODE_ || _VERBOSE_,
               printf("SlibReadData() AudioPTimeCode=%ld\n", ptimestamp) );
            break;
      }
    else if (stream==SLIB_STREAM_MAINVIDEO &&
             Info->VideoPTimeCode==SLIB_TIME_NONE)
      Info->VideoPTimeCode=SLIB_TIME_UNKNOWN;
  }
  if (*databuf==NULL || *databufsize==0)
  {
    if (!slibDataOnPin(Info, pinid))
      return(SlibErrorEndOfStream);
    else
      return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadVideo(SlibHandle_t handle, SlibStream_t stream,
                      void **videobuf, unsigned dword *videobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SvErrorNone;
  unsigned char *imagebuf=NULL;
  SlibTime_t startvideotime;
  _SlibDebug(_VERBOSE_, printf("SlibReadVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
/*
  imagesize=(Info->Width*Info->Height*3)/2;
  if (videobufsize<imagesize)
    return(SlibErrorBufSize);
*/
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CodecVideoFormat==NULL ||
               Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartVideo(Info, (SlibBoolean_t)((*videobuf==NULL)?FALSE:TRUE)))
                  !=SlibErrorNone)
    return(status);
  startvideotime=Info->VideoTimeStamp;
  switch(Info->VideoType)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
        do {
          _SlibDebug(_DEBUG_, printf("SvDecompressMPEG()\n") );
          status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                             Info->MultibufSize, &imagebuf);
          _SlibDebug(_WARN_ && status!=SvErrorNone,
                             printf("SvDecompressMPEG() %s\n",
                               ScGetErrorStr(status)) );
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        _SlibDebug(_SEEK_>1, printf("timecode=%d ms  framenum=%d\n",
                SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                SvGetParamInt(Info->Svh, SV_PARAM_FRAME) ) );
        break;
#endif /* MPEG_SUPPORT */
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompressH261()\n") );
          status = SvDecompressH261(Info->Svh, Info->Multibuf,
                                    Info->MultibufSize,
                                    &imagebuf);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", Info->MultibufSize) );
        status=SvDecompress(Info->Svh, NULL, 0,
                                 Info->Multibuf, Info->MultibufSize);
        imagebuf=Info->Multibuf;
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* H263_SUPPORT */
#ifdef JPEG_SUPPORT
    case SLIB_TYPE_JPEG:
    case SLIB_TYPE_MJPG:
        {
          unsigned dword bufsize;
          unsigned char *buf;
          buf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, &bufsize, NULL);
          if (buf)
          {
            /* ScDumpChar(buf, 10000, 0); */
            _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress(%d bytes)\n", bufsize) );
            status=SvDecompress(Info->Svh, buf, bufsize,
                                 Info->Multibuf, Info->MultibufSize);
            imagebuf=Info->Multibuf;
            SlibFreeBuffer(buf);
          }
          else
            status=SvErrorForeign;
          if (status==SvErrorNone)
            SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        }
        break;
#endif /* JPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        if (*videobuf==NULL)
        {
          if (Info->Imagebuf==NULL &&
              (Info->Imagebuf=SlibAllocBuffer(Info->ImageSize))==NULL)
            return(SlibErrorMemory);
          imagebuf=Info->Imagebuf;
        }
        else
          imagebuf=*videobuf;
        do {
          _SlibDebug(_DEBUG_, ScDebugPrintf(Info->dbg,"SvDecompress()\n") );
          status=SvDecompress(Info->Svh, NULL, 0,
                               imagebuf,  Info->CodecVideoFormat->biSizeImage);
        } while(status == SvErrorNotDecompressable);
        if (status==SvErrorNone)
          SlibAllocSubBuffer(imagebuf,  Info->CodecVideoFormat->biSizeImage);
        break;
#endif /* HUFF_SUPPORT */
    case SLIB_TYPE_RASTER:
    case SLIB_TYPE_YUV:
        if (*videobuf && videobufsize && *videobufsize==0)
          return(SlibErrorBadArgument);
        imagebuf=SlibGetBuffer(Info, SLIB_DATA_VIDEO, videobufsize, NULL);

        if (*videobufsize==0)
          status=SvErrorEndBitstream;
        _SlibDebug(_DEBUG_,
               ScDebugPrintf(Info->dbg,"Video frame size = %d ImageSize=%d\n",
                     *videobufsize, Info->ImageSize) );
        break;
    default:
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SvErrorNone)
  {
    /* format conversion */
    if (Info->Sch==NULL) /* start the format converter */
    {
      if (Info->Svh) /* compressed video format */
      {
        unsigned dword fourcc=(unsigned dword)SvGetParamInt(Info->Svh, SV_PARAM_FINALFORMAT);
        if (fourcc)
        {
          Info->CodecVideoFormat->biCompression=fourcc;
          Info->CodecVideoFormat->biBitCount=
                (WORD)slibCalcBits(fourcc, Info->CodecVideoFormat->biBitCount);
        }
      }
      else /* uncompressed video format */
        memcpy(Info->CodecVideoFormat, Info->CompVideoFormat, sizeof(BITMAPINFOHEADER));
      if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->CodecVideoFormat, (void *)Info->VideoFormat)
           !=SconErrorNone)
        return(SlibErrorUnsupportedFormat);
      if (Info->Stride)
        SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);

    }
    if (SconIsSame(Info->Sch) && *videobuf == NULL) /* no conversion */
      *videobuf=imagebuf;
    else
    {
      if (*videobuf == NULL && (*videobuf=SlibAllocBuffer(Info->ImageSize))==NULL)
        return(SlibErrorMemory);
      if (SconConvert(Info->Sch, imagebuf, Info->CodecVideoFormat->biSizeImage,
                      *videobuf, Info->ImageSize) != SconErrorNone)
      {
        SlibFreeBuffer(imagebuf); /* free decompressed image */
        return(SlibErrorUnsupportedFormat);
      }
      SlibFreeBuffer(imagebuf); /* free decompressed image */
    }
    *videobufsize = Info->ImageSize;
    /* update stats */
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    if (startvideotime==Info->VideoTimeStamp) /* video time hasn't changed */
      slibAdvancePositions(Info, 1);
  }
  else
  {
    if (status==ScErrorEndBitstream ||
        !slibDataOnPin(Info, SLIB_DATA_VIDEO))
    {
      if (Info->FileSize>0 && !Info->VideoLengthKnown)
        slibUpdateLengths(Info);
      _SlibDebug(_WARN_, ScDebugPrintf(Info->dbg,"SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
      return(SlibErrorEndOfStream);
    }
    _SlibDebug(_WARN_, printf("SlibReadVideo() %s\n",
                           ScGetErrorStr(status)) );
    return(SlibErrorReading);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibReadAudio(SlibHandle_t handle, SlibStream_t stream,
                     void *audiobuf, unsigned dword *audiobufsize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SaErrorNone;
  unsigned dword totalbytes=0, bytes_since_timeupdate=0;
  SlibTime_t startaudiotime;
#ifdef _SLIBDEBUG_
  SlibTime_t calcaudiotime;
#endif

  _SlibDebug(_VERBOSE_, printf("SlibReadAudio(audiobufsize=%d, time=%d)\n",
                                  *audiobufsize, Info->AudioTimeStamp) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
#ifdef _SLIBDEBUG_
  calcaudiotime=Info->AudioTimeStamp;
#endif
  startaudiotime=Info->AudioTimeStamp;
  switch(Info->AudioType)
  {
    case SLIB_TYPE_PCM:
        totalbytes=slibFillBufferFromPin(Info,
                                   slibGetPin(Info, SLIB_DATA_AUDIO),
                                   (unsigned char *)audiobuf, *audiobufsize,
                                   NULL);
        if (totalbytes==0)
          status=ScErrorEndBitstream;
        *audiobufsize = totalbytes;
        bytes_since_timeupdate = totalbytes;
        break;
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
	{
	  unsigned dword bytes;
          /* see if some bytes of audio are left in the temp audio buffer */
          if (Info->Audiobuf && Info->AudiobufUsed>0)
          {
            _SlibDebug(_DEBUG_,
                 printf("SlibReadAudio() Audiobuf contains %d bytes\n",
                      Info->AudiobufUsed) );
            if (*audiobufsize>=Info->AudiobufUsed)
            {
              memcpy(audiobuf, Info->Audiobuf, Info->AudiobufUsed);
              totalbytes=Info->AudiobufUsed;
              Info->AudiobufUsed=0;
            }
            else
            {
              memcpy(audiobuf, Info->Audiobuf, *audiobufsize);
              totalbytes=*audiobufsize;
              Info->AudiobufUsed-=*audiobufsize;
              memcpy(Info->Audiobuf, Info->Audiobuf+*audiobufsize,
                                 Info->AudiobufUsed);
            }
          }
          /* need to alloc a temp audio buffer? */
          if (!Info->Audiobuf || Info->AudiobufSize<
                     *audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned char *newbuf;
            /* enlarge Audiobuf or alloc it for the first time */
            _SlibDebug(_DEBUG_,
                printf("SlibReadAudio() enlarging Audiobuf: %d->%d bytes\n",
                 Info->AudiobufSize,*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4) );
            newbuf=SlibAllocBuffer(*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4);
            if (!newbuf)
              return(SlibErrorMemory);
            Info->AudiobufSize=*audiobufsize+MPEG1_AUDIO_FRAME_SIZE*4;
            if (Info->Audiobuf)
              SlibFreeBuffer(Info->Audiobuf);
            Info->Audiobuf=newbuf;
            Info->AudiobufUsed=0;
          }
          if (*audiobufsize>=MPEG1_AUDIO_FRAME_SIZE*4)
          {
            unsigned dword stopbytes=*audiobufsize-(MPEG1_AUDIO_FRAME_SIZE*4)+1;
            while (status==SaErrorNone && totalbytes<stopbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_,
                  printf("SaDecompress(bytes=%d) in totalbytes=%d\n",
                                        bytes, totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                           (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out: bytes=%d\n",
                                            bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
          }
          if (totalbytes<*audiobufsize && status==SaErrorNone)
          {
            unsigned dword neededbytes=*audiobufsize-totalbytes;
            while (status==SaErrorNone && Info->AudiobufUsed<neededbytes)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                          totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                  (unsigned char *)Info->Audiobuf+Info->AudiobufUsed, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
              Info->AudiobufUsed += bytes;
            }
            if (Info->AudiobufUsed>0)
            {
              if (Info->AudiobufUsed>neededbytes) /* complete buffer returned */
              {
                memcpy((unsigned char*)audiobuf+totalbytes,
                        Info->Audiobuf, neededbytes);
                Info->AudiobufUsed-=neededbytes;
                memcpy(Info->Audiobuf, Info->Audiobuf+neededbytes,
                                   Info->AudiobufUsed);
                totalbytes+=neededbytes;
                bytes_since_timeupdate+=neededbytes;
              }
              else  /* partially filled buffer */
              {
                memcpy((unsigned char*)audiobuf+totalbytes, Info->Audiobuf,
                       Info->AudiobufUsed);
                totalbytes+=Info->AudiobufUsed;
                Info->AudiobufUsed=0;
              }
            }
          }
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
    case SLIB_TYPE_AC3_AUDIO:
	{
	  unsigned dword bytes;
	  unsigned int framesize;
	  unsigned int buffersize;
	  int samplesize;
	  int buffers;
	  unsigned char *pointers[3];
	  int i;

	  if (Info->Channels>2)
	  {
            framesize = AC3_FRAME_SIZE*((Info->BitsPerSample+7)/8)
                                      *Info->Channels;
            samplesize=Info->Channels*((Info->BitsPerSample+7)/8);
            buffers = (Info->Channels+1)/2;
            buffersize = (*audiobufsize/samplesize/buffers)*samplesize;

            for(i=0; i<buffers; i++)
              pointers[i]=(unsigned char *)audiobuf+buffersize*i;

            if (*audiobufsize>=framesize)
            {
              while (status==SaErrorNone && totalbytes<buffersize)
              {
                bytes = buffersize - totalbytes;
                _SlibDebug(_DEBUG_,printf("SaDecompressEx() in totalbytes=%d\n",
                                   totalbytes) );
                status = SaDecompressEx(Info->Sah, NULL, 0, pointers, &bytes);
                _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                            bytes) );
                for(i=0;i<buffers;i++)
                  pointers[i]+=bytes;
                totalbytes += bytes;
                if (Info->AudioTimeStamp!=startaudiotime)
                {
                  startaudiotime=Info->AudioTimeStamp;
                  bytes_since_timeupdate=bytes;
                }
                else
                  bytes_since_timeupdate+=bytes;
              }
            }
	  }
	  else
	  {
            while (status==SaErrorNone && totalbytes<*audiobufsize)
            {
              bytes = *audiobufsize - totalbytes;
              _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                   totalbytes) );
              status = SaDecompress(Info->Sah, NULL, 0,
                             (unsigned char *)audiobuf+totalbytes, &bytes);
              _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
              totalbytes += bytes;
              if (Info->AudioTimeStamp!=startaudiotime)
              {
                startaudiotime=Info->AudioTimeStamp;
                bytes_since_timeupdate=bytes;
              }
              else
                bytes_since_timeupdate+=bytes;
            }
	  }
          /*
          ** NOTE: The semantics are different here
          **       we return the size of just one stereo pair's buffer
          */
          *audiobufsize = totalbytes;
          _SlibDebug(_WARN_>1 && totalbytes>0 &&
                       totalbytes!=*audiobufsize,
             printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
	}
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    //G723 decompresses in multiples of 480 samples.
    //To eliminate cumbersome buffer calculations,
    // Always fill the output buffer up to multiples
    // of 480 samples.To do this we iterate basically
    // the below "while" loop "audiobufsize/480 times.
    {
      int iTimes = (int)*audiobufsize/480;
      int iLoop =0;
	  unsigned dword bytes;
      if (slibInSyncMode(Info))
      {
        /* in synchronous mode we can't decompress past last frame
         * otherwise we may lose a frame
         */
        int iMaxTimes=(int)(slibDataOnPin(Info, SLIB_DATA_COMPRESSED)+
                           slibDataOnPin(Info, SLIB_DATA_AUDIO))/
                       SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
        if (iTimes>iMaxTimes)
          iTimes=iMaxTimes;
      }
      while (status==SaErrorNone && iLoop<iTimes)
      {
         bytes = *audiobufsize - totalbytes;
         _SlibDebug(_DEBUG_, printf("SaDecompress() in totalbytes=%d\n",
                                totalbytes) );
         status = SaDecompress(Info->Sah, NULL, 0,
            (unsigned char *)audiobuf+totalbytes, &bytes);
         _SlibDebug(_DEBUG_, printf("SaDecompress() out, %d bytes\n",
                                    bytes) );
         totalbytes += bytes;
         iLoop++;
         if (Info->AudioTimeStamp!=startaudiotime)
         {
            startaudiotime=Info->AudioTimeStamp;
            bytes_since_timeupdate=bytes;
         }
         else
            bytes_since_timeupdate+=bytes;
      }
      *audiobufsize = totalbytes;

      _SlibDebug(_WARN_>1 && totalbytes>0 &&
                  totalbytes!=*audiobufsize,
       printf("SlibReadAudio(audiobufsize=%d bytes) totalbytes=%d\n",
                   *audiobufsize, totalbytes) );
    }
    break;
#endif /* G723_SUPPORT */
    default:
        *audiobufsize = 0;
        return(SlibErrorUnsupportedFormat);
  }
  /* as we're decompressing audiotime may be updated with timecodes */
  if (Info->AudioTimeStamp==startaudiotime)
    Info->AudioTimeStamp = startaudiotime + (bytes_since_timeupdate*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
  _SlibDebug(_TIMECODE_||_VERBOSE_,
              calcaudiotime += (*audiobufsize*8000)/
                 (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
              printf("AudioTimeStamp=%ld calcaudiotime=%ld (diff=%ld)\n",
                               Info->AudioTimeStamp, calcaudiotime,
                               calcaudiotime-Info->AudioTimeStamp);
              Info->AudioTimeStamp = calcaudiotime );

  _SlibDebug(_VERBOSE_||_TIMECODE_,
   printf("ReadAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         totalbytes,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  /* Info->SystemTimeStamp=Info->AudioTimeStamp; */
  if (status==SaErrorNone)
    return(SlibErrorNone);
  else if (status==ScErrorEndBitstream || status==ScErrorEOI)
  {
    if (*audiobufsize!=0)
      return(SlibErrorNone);
    else
      return(SlibErrorEndOfStream);
  }
  else
  {
    _SlibDebug(_WARN_ && status!=ScErrorEndBitstream
                      && status!=ScErrorEOI,
              printf("SlibReadAudio() %s\n", ScGetErrorStr(status)) );
    if (SlibIsEnd(handle, stream))
      return(SlibErrorEndOfStream);
    return(SlibErrorReading);
  }
}


SlibStatus_t SlibWriteVideo(SlibHandle_t handle, SlibStream_t stream,
                            void *videobuf, unsigned dword videobufsize)
{
  int compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibWriteVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!videobuf)
    return(SlibErrorBadArgument);
  if (videobufsize<(unsigned dword)Info->ImageSize)
    return(SlibErrorBufSize);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->VideoFormat==NULL || Info->CompVideoFormat==NULL)
    return(SlibErrorUnsupportedFormat);
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
    return(status);
  if (Info->Sch==NULL) /* start the format converter */
  {
    if (SconOpen(&Info->Sch, SCON_MODE_VIDEO, (void *)Info->VideoFormat, (void *)Info->CodecVideoFormat)
         !=SconErrorNone)
      return(SlibErrorUnsupportedFormat);
  }
  if (!SconIsSame(Info->Sch)) /* need a conversion */
  {
    unsigned char *tmpbuf=NULL;
    if (Info->CodecImagebuf==NULL &&
        (Info->CodecImagebuf=SlibAllocBuffer(Info->CodecImageSize))==NULL)
      return(SlibErrorMemory);
    if (SconConvert(Info->Sch, videobuf, Info->ImageSize,
                      Info->CodecImagebuf, Info->CodecImageSize) != SconErrorNone)
      return(SlibErrorUnsupportedFormat);
    videobuf=Info->CodecImagebuf;
    videobufsize=Info->CodecImageSize;
  }
  switch(Info->Type)
  {
#ifdef H261_SUPPORT
    case SLIB_TYPE_H261:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H261_SUPPORT */
#ifdef H263_SUPPORT
    case SLIB_TYPE_H263:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* H263_SUPPORT */
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_VIDEO:
    case SLIB_TYPE_MPEG2_VIDEO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* MPEG_SUPPORT */
#ifdef HUFF_SUPPORT
    case SLIB_TYPE_SHUFF:
        status = SvCompress(Info->Svh, NULL, 0, videobuf, videobufsize, &compsize);
        break;
#endif /* HUFF_SUPPORT */
    default:
        return(SlibErrorUnsupportedFormat);
  }


  if (status==SvErrorNone && !Info->IOError)
  {
    if (Info->stats && Info->stats->Record)
      Info->stats->FramesProcessed++;
    slibAdvancePositions(Info, 1);
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteVideo() %s\n",
                         ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibWriteAudio(SlibHandle_t handle, SlibStream_t stream,
                      void *audiobuf, unsigned dword audiobufsize)
{
  unsigned dword compsize=0;
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status;
  _SlibDebug(_DEBUG_, printf("SlibAudioVideo()\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  if (!audiobuf)
    return(SlibErrorBadArgument);
  if (Info->Mode!=SLIB_MODE_COMPRESS)
    return(SlibErrorBadMode);
  if (Info->AudioFormat==NULL || Info->CompAudioFormat==NULL)
  {
    _SlibDebug(_VERBOSE_ || _WARN_,
          printf("SlibWriteAudio() Audio Formats not setup\n") );
    return(SlibErrorUnsupportedFormat);
  }
  if (Info->IOError)
    return(SlibErrorWriting);
  if ((status=slibStartAudio(Info))!=SlibErrorNone)
    return(status);
  switch(Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SLIB_TYPE_MPEG1_AUDIO:
    case SLIB_TYPE_MPEG_SYSTEMS:
    case SLIB_TYPE_MPEG_SYSTEMS_MPEG2:
        {
          unsigned dword audiobytes;
          void *audiooutbuf=NULL;
          status=slibConvertAudio(Info, audiobuf, audiobufsize,
                              Info->SamplesPerSec, Info->BitsPerSample,
                              &audiooutbuf, &audiobytes,
                              Info->AudioFormat->nSamplesPerSec,
                              Info->AudioFormat->wBitsPerSample,
                              Info->Channels);
          if (status!=SlibErrorNone)
              return(status);
          audiobuf=audiooutbuf;
          audiobufsize=audiobytes;
          if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
          {
            if (Info->AudiobufSize<Info->AudiobufUsed+audiobufsize)
            {
              unsigned char *newbuf;
              /* enlarge Audiobuf */
              _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                        Info->AudiobufSize,audiobufsize+4608) );
              newbuf=SlibAllocBuffer(audiobufsize+4608);
              if (!newbuf)
                return(SlibErrorMemory);
              memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
              SlibFreeBuffer(Info->Audiobuf);
              Info->AudiobufSize+=audiobufsize;
              Info->Audiobuf=newbuf;
            }
            _SlibDebug(_DEBUG_,
               printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                                 Info->AudiobufUsed) );
            memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
            audiobuf=Info->Audiobuf;
            audiobufsize+=Info->AudiobufUsed;
            audiobytes=audiobufsize;
            Info->AudiobufUsed=0;
          }
          status = SaCompress(Info->Sah, (unsigned char *)audiobuf,
                                        &audiobytes, NULL, &compsize);
          if (audiobytes<audiobufsize) /* save audio data not compressed */
          {
            _SlibDebug(_DEBUG_,
              printf("audiobytes(%d)<audiobufsize(%d)\n",
                                  audiobytes,audiobufsize) );
            if (!Info->Audiobuf)
            {
              Info->AudiobufSize=audiobufsize+(audiobufsize-audiobytes);
              Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
              if (!Info->Audiobuf)
              {
                Info->AudiobufSize=0;
                return(SlibErrorMemory);
              }
            }
            memcpy(Info->Audiobuf, (unsigned char *)audiobuf+audiobytes,
                                   audiobufsize-audiobytes);
            Info->AudiobufUsed=audiobufsize-audiobytes;
          }
          audiobufsize=audiobytes; /* actual amount written */
          if (audiooutbuf)
            SlibFreeBuffer(audiooutbuf);
        }
        break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SLIB_TYPE_G723:
    {
      unsigned int iNumBytesUnProcessed =0;
      unsigned int iNumBytesCompressed = 0;
      //You always compress in terms of frames (Frame is 480 bytes)
      //So,the files with sizes which are not exactly divisible by
      // 480 always leave some bytes at the end Unprocessed,Which is O.K

      //Check for any Unprocessed Audio stored in Temp buff
      //from the previous call to SlibWriteAudio.
      if (Info->AudiobufUsed && Info->Audiobuf) /* left over audio data */
      {
         if (Info->AudiobufSize < Info->AudiobufUsed+audiobufsize)
         {
            unsigned char *newbuf;
            /* enlarge Audiobuf to new Size (Current size + left over audio)*/
            _SlibDebug(_DEBUG_, printf("enlarging Audiobuf: %d->%d bytes\n",
                      Info->AudiobufSize,audiobufsize+Info->AudiobufUsed) );
            newbuf=SlibAllocBuffer(Info->AudiobufUsed+audiobufsize);
            if (!newbuf)
               return(SlibErrorMemory);
            memcpy(newbuf, Info->Audiobuf, Info->AudiobufUsed);
            SlibFreeBuffer(Info->Audiobuf);
            //Info->AudiobufSize+=audiobufsize;
            Info->Audiobuf=newbuf;
         }
         _SlibDebug(_DEBUG_,
           printf("Appending audio data: Info->AudiobufUsed=%d\n",
                                            Info->AudiobufUsed) );
         memcpy(Info->Audiobuf+Info->AudiobufUsed, audiobuf, audiobufsize);
         audiobuf=Info->Audiobuf;
         audiobufsize+=Info->AudiobufUsed;
         Info->AudiobufUsed=0;
      }

      iNumBytesCompressed = audiobufsize;
      status = SaCompress(Info->Sah,(unsigned char *)audiobuf,
                           &iNumBytesCompressed, NULL,&compsize);
      iNumBytesUnProcessed = audiobufsize - iNumBytesCompressed;
      //Store the Unprocessed Bytes into temp buffer
      if(iNumBytesUnProcessed)
      {
         //Allocate temp buff and store this audio.
         if (!Info->Audiobuf)
         {
            //MVP:To reduce ReAllocations and copying of memory
            //while checking for Unprocessed data (above),Allocate
            // now (normal audio buff size + Unprocessed bytes) more
            // memory upfront.
            Info->AudiobufSize=audiobufsize + iNumBytesUnProcessed;
            Info->Audiobuf=SlibAllocBuffer(Info->AudiobufSize);
            if (!Info->Audiobuf)
            {
               Info->AudiobufSize=0;
               return(SlibErrorMemory);
            }
         }
         memcpy(Info->Audiobuf, (unsigned char *)audiobuf+iNumBytesCompressed,
                                   iNumBytesUnProcessed);
         Info->AudiobufUsed=iNumBytesUnProcessed;
      }
      audiobufsize=iNumBytesCompressed; /* actual amount written */
    }
       break;
#endif /* G723_SUPPORT */
    default:
        _SlibDebug(_VERBOSE_ || _WARN_,
           printf("SlibWriteAudio() Unsupported Format\n") );
        return(SlibErrorUnsupportedFormat);
  }

  if (status==SaErrorNone && !Info->IOError)
  {
    if (Info->AudioFormat)
      Info->AudioTimeStamp += (audiobufsize*8000)/
        (Info->AudioFormat->nSamplesPerSec*Info->AudioFormat->wBitsPerSample*
             Info->Channels);
    else
      Info->AudioTimeStamp += (audiobufsize*8000)/
           (Info->SamplesPerSec*Info->BitsPerSample*Info->Channels);
    _SlibDebug(_VERBOSE_||_TIMECODE_,
    printf("WriteAudio(%d) Time=%ld SamplesPerSec=%d BitsPerSample=%d Channels=%d\n",
         audiobufsize,
         Info->AudioTimeStamp, Info->SamplesPerSec, Info->BitsPerSample,
         Info->Channels) );
  }
  else
  {
    _SlibDebug(_WARN_, printf("SlibWriteAudio() %s\n", ScGetErrorStr(status)) );
    if (status==ScErrorEndBitstream || Info->IOError)
      return(SlibErrorEndOfStream);
    return(SlibErrorWriting);
  }
  return(SlibErrorNone);
}

/*
** Name: slibPinReposition
** Purpose: Called when input data stream is to be repositioned.
*/
SlibStatus_t slibReposition(SlibInfo_t *Info, SlibPosition_t position)
{
  SlibPin_t *pin=slibGetPin(Info, SLIB_DATA_COMPRESSED);
  _SlibDebug(_DEBUG_, printf("slibReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  if (pin) pin->Offset=position;
  Info->VideoPTimeCode = SLIB_TIME_NONE;
  Info->VideoDTimeCode = SLIB_TIME_NONE;
  Info->AudioPTimeCode = SLIB_TIME_NONE;
  Info->AudioDTimeCode = SLIB_TIME_NONE;
  if (Info->Fd >= 0)
  {
    _SlibDebug(_SEEK_, printf("ScFileSeek(%d, %d)\n", Info->Fd, position) );
    if (ScFileSeek(Info->Fd, position)!=NoErrors)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  else if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
        printf("slibReposition() SlibCB(SLIB_MSG_REPOSITION, %d)\n",
                                   position) );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_REPOSITION, (SlibCBParam1_t)position,
                        (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    if (result!=SLIB_MSG_CONTINUE)
      return(SlibErrorEndOfStream);
    return(SlibErrorNone);
  }
  return(SlibErrorForwardOnly);
}

/*
** Name: slibPinPrepareReposition
** Purpose: Should be called when a stream is about to be repositioned (a seek).
**          This will empty any remaining buffers being used by the
**          CODECs and restart them.
*/
void slibPinPrepareReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinPrepareReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN && Info->Svh &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
             {
               SvDecompressEnd(Info->Svh); /* this will reset the bitstream */
               Info->VideoCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("VideoCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->VideoPTimeCode = SLIB_TIME_NONE;
             Info->VideoDTimeCode = SLIB_TIME_NONE;
             Info->VideoTimeStamp = SLIB_TIME_NONE;
             Info->AvgVideoTimeDiff = 0;
             Info->VarVideoTimeDiff = 0;
             Info->VideoFramesProcessed=0; /* reset frames processed */
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN && Info->Sah)
             {
               SaDecompressEnd(Info->Sah); /* this will reset the bitstream */
               Info->AudioCodecState=SLIB_CODEC_STATE_REPOSITIONING;
               _SlibDebug(_DEBUG_, printf("AudioCodecState=REPOSITIONING\n"));
               Info->IOError=FALSE;
             }
             Info->AudioPTimeCode = SLIB_TIME_NONE;
             Info->AudioDTimeCode = SLIB_TIME_NONE;
             Info->AudioTimeStamp = SLIB_TIME_NONE;
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinPrepareReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinPrepareReposition(%d) out\n",
                                         pinid) );
}

void slibPinFinishReposition(SlibInfo_t *Info, int pinid)
{
  _SlibDebug(_DEBUG_, printf("slibPinFinishReposition() VideoCodecState=%d\n",
                                                   Info->VideoCodecState));
  switch(pinid)
  {
     case SLIB_DATA_VIDEO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Video) in\n") );
             if (Info->VideoCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                   Info->Svh && slibGetPin(Info, SLIB_DATA_VIDEO) &&
#ifdef JPEG_SUPPORT
                 Info->Type != SLIB_TYPE_JPEG_AVI &&
                 Info->Type != SLIB_TYPE_MJPG_AVI &&
#endif /* JPEG_SUPPORT */
                 Info->Type != SLIB_TYPE_YUV_AVI)
               slibStartVideo(Info, FALSE);
             break;
     case SLIB_DATA_AUDIO:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(Audio) in\n") );
             if (Info->AudioCodecState==SLIB_CODEC_STATE_REPOSITIONING &&
                  Info->Sah && slibGetPin(Info, SLIB_DATA_AUDIO))
               slibStartAudio(Info);
             break;
     default:
             _SlibDebug(_VERBOSE_||_SEEK_>1,
                    printf("slibPinFinishReposition(%d) in\n", pinid) );
  }
  _SlibDebug(_VERBOSE_||_SEEK_>1, printf("slibPinFinishReposition(%d) out\n",
                                         pinid) );
}

SlibBoolean_t slibUpdateLengths(SlibInfo_t *Info)
{
  if (Info->FileSize>0 && !Info->VideoLengthKnown &&
       (SlibTimeIsValid(Info->VideoPTimeCode) ||
        SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1000)
     )
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    Info->VideoLengthKnown=TRUE;
    _SlibDebug(_SEEK_ || _TIMECODE_,
    printf("slibUpdateLengths() AudioLength=%ld VideoLength=%ld\n",
                  Info->AudioLength, Info->VideoLength) );
    return(TRUE);
  }
  return(FALSE);
}

SlibBoolean_t slibUpdatePositions(SlibInfo_t *Info, SlibBoolean_t exactonly)
{
  SlibBoolean_t updated=FALSE;

  if (!exactonly)
  {
    if (SlibTimeIsValid(Info->VideoTimeStamp))
      updated=TRUE;
    else if (SlibTimeIsValid(Info->AudioTimeStamp))
    {
      if (slibHasVideo(Info))
        Info->VideoTimeStamp=Info->AudioTimeStamp;
      updated=TRUE;
    }
    else if (slibHasVideo(Info))
    {
      Info->VideoTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_VIDEO), 500*1024);
      if (SlibTimeIsValid(Info->VideoTimeStamp))
      {
        Info->VideoTimeStamp-=Info->VideoPTimeBase;
        updated=TRUE;
      }
    }
  }
  if (!updated && (!exactonly || SlibTimeIsInValid(Info->VideoPTimeBase)) &&
           SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE)>=1500 &&
            SvGetParamInt(Info->Svh, SV_PARAM_FRAME)>24)
  {
    _SlibDebug(_TIMECODE_, printf("slibUpdatePositions() using video time\n") );
    Info->VideoTimeStamp=SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE);
    updated=TRUE;
  }
  if (updated)
  {
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    if (SlibTimeIsInValid(Info->AudioTimeStamp) && slibHasAudio(Info))
    {
      /* need to update audio time */
      Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
      if (SlibTimeIsInValid(Info->AudioTimeStamp))
        Info->AudioTimeStamp=Info->VideoTimeStamp;
      else
        Info->AudioTimeStamp-=Info->AudioPTimeBase;
    }
    if (SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoFramesProcessed=slibTimeToFrame(Info, Info->VideoTimeStamp);
  }
  _SlibDebug(_SEEK_ || _TIMECODE_,
     printf("slibUpdatePositions() AudioTimeStamp=%ld VideoTimeStamp=%ld %s\n",
         Info->AudioTimeStamp, Info->VideoTimeStamp, updated?"updated":"") );
  return(updated);
}

void slibAdvancePositions(SlibInfo_t *Info, qword frames)
{
  Info->VideoFramesProcessed+=frames;
  if (Info->FramesPerSec)
  {
    if (Info->Mode==SLIB_MODE_COMPRESS ||
        SlibTimeIsInValid(Info->VideoPTimeCode))
      Info->VideoTimeStamp=slibFrameToTime(Info, Info->VideoFramesProcessed);
    else
      Info->VideoTimeStamp=Info->VideoPTimeCode - Info->VideoPTimeBase +
                           slibFrameToTime(Info, Info->VideoFramesProcessed);
    /* Info->VideoTimeStamp+=slibFrameToTime(Info, frames); */
    if (Info->VideoTimeStamp>Info->VideoLength)
      Info->VideoLength=Info->VideoTimeStamp;
    _SlibDebug(_TIMECODE_,
          printf("slibAdvancePositions(frames=%d) VideoTimeStamp=%ld\n",
             frames, Info->VideoTimeStamp) );
  }
}

SlibStatus_t SlibSeek(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t frame)
{
  return(SlibSeekEx(handle, stream, seektype, frame, SLIB_UNIT_FRAMES, NULL));
}

SlibStatus_t SlibSeekEx(SlibHandle_t handle, SlibStream_t stream,
                      SlibSeekType_t seektype, SlibPosition_t seekpos,
                      SlibUnit_t seekunits, SlibSeekInfo_t *seekinfo)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SvStatus_t status=SlibErrorNone;
  SlibTime_t seektime, timediff;
  unsigned int tries=0;
  _SlibDebug(_SEEK_,
      printf("SlibSeekEx(stream=%d,seektype=%d,pos=%ld,units=%d)\n",
                     stream,seektype,seekpos,seekunits) );
  if (!handle)
    return(SlibErrorBadHandle);
  if (Info->Mode!=SLIB_MODE_DECOMPRESS && seektype!=SLIB_SEEK_RESET)
    return(SlibErrorBadMode);
  if (SlibSeekTypeUsesPosition(seektype))
  {
    switch (seekunits)
    {
      case SLIB_UNIT_FRAMES: /* frames */
            /* we need to convert the frame to the time */
            if (Info->FramesPerSec)
              seektime=slibFrameToTime(Info, seekpos);
            else
              seektime=SLIB_TIME_NONE;
            break;
      case SLIB_UNIT_MS:  /* milliseconds */
            seektime=(seekpos<0) ? 0 : seekpos;
            break;
      case SLIB_UNIT_PERCENT100:  /* 100th of a percent */
            if (seekpos<0 || seekpos>10000)
              return(SlibErrorBadPosition);
            if (Info->VideoStreams==0 || stream==SLIB_STREAM_MAINAUDIO)
              seektime=(seekpos * Info->AudioLength)/(SlibPosition_t)10000;
            else
              seektime=(seekpos * Info->VideoLength)/(SlibPosition_t)10000;
            break;
      default:
            return(SlibErrorBadUnit);
    }
    /* see if the new position is past the end of the file */
    if (Info->VideoLengthKnown && seektime>Info->VideoLength)
      return(SlibErrorBadPosition);
  }
  else
    seektime=(seekpos<0) ? 0 : seekpos;
  if (seekinfo)
    seekinfo->FramesSkipped=0;
  switch(seektype)
  {
    case SLIB_SEEK_AHEAD:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,AHEAD,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (seektime<=0)
            return(SlibErrorNone);
          if (stream==SLIB_STREAM_MAINAUDIO || Info->VideoStreams<=0)
            seektime+=Info->AudioTimeStamp;
          else
            seektime+=Info->VideoTimeStamp;
          return(SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_NEAR, seektime,
                       SLIB_UNIT_MS, seekinfo));
    case SLIB_SEEK_NEXT_NEAR:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_NEAR,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          status=slibStartVideo(Info, FALSE);
          if (status==SlibErrorNone)
          {
            qword framesskipped=0;
            SlibBoolean_t atkey=FALSE; /* key's must be decoded */
            if (Info->Svh) /* update key spacing */
            {
              Info->KeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_KEYSPACING);
              Info->SubKeySpacing=(int)SvGetParamInt(Info->Svh,
                                                        SV_PARAM_SUBKEYSPACING);
            }
            timediff=seektime-Info->VideoTimeStamp;
            while (status==SlibErrorNone &&
               (timediff>500 ||
                timediff>(Info->VideoFrameDuration*Info->KeySpacing*6)/1000))
            {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_KEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
              if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
              timediff=seektime-Info->VideoTimeStamp;
              atkey=TRUE;
            }
            if (!atkey && status==SlibErrorNone &&
               (timediff>150 ||
                timediff>(Info->VideoFrameDuration*Info->SubKeySpacing*6)/1000))
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_I &&
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)!=FRAME_TYPE_P)
              {
                /* we're seeking past more than one frame */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT_SUBKEY, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              atkey=TRUE;
            }
            while (!atkey && status==SlibErrorNone &&
                   timediff>Info->VideoFrameDuration/100)
            {
              if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_B ||
                  SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_NONE)
              {
                /* we can skip B frames without decompressing them */
                status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                SLIB_UNIT_NONE, seekinfo);
                if (seekinfo) framesskipped+=seekinfo->FramesSkipped;
                timediff=seektime-Info->VideoTimeStamp;
              }
              else
                atkey=TRUE;
            }
            if (seekinfo) seekinfo->FramesSkipped=framesskipped;
          }
          return(status);
    case SLIB_SEEK_NEXT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN
              && Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            else
            {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE|SV_B_PICTURE;
              _SlibDebug(_VERBOSE_||_SEEK_>1,
                        printf("SvFindNextPicture(I|P|B)\n") );
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                   printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
            }
            if (status==NoErrors)
            {
              slibAdvancePositions(Info, 1);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped++;
              if (seekinfo) seekinfo->FramesSkipped++;
            }
            else if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            return(SlibErrorNone);
          }
#endif /* MPEG_SUPPORT */
          return(SlibErrorReading);
    case SLIB_SEEK_EXACT:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,EXACT,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seektime==0 || Info->VideoStreams<=0)
            return(SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0, SLIB_UNIT_MS,
                                                                seekinfo));
          timediff=seektime-Info->VideoTimeStamp;
          if ((stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
             (timediff>=-20 && timediff<=20)) /* we're already near the frame */
            return(SlibErrorNone);
          if (Info->Svh) /* update key spacing */
            Info->KeySpacing=(int)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING);
          if (timediff>(Info->KeySpacing*Info->VideoFrameDuration)/100 ||
                  timediff<0 ||
             (stream!=SLIB_STREAM_MAINVIDEO && Info->AudioStreams>0))
          {
            if (Info->KeySpacing>1)
            {
              const SlibTime_t keytime=
                   (Info->VideoFrameDuration*Info->KeySpacing)/100;
              if (seektime>=0 && seektime<keytime)
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY, 0,
                                                SLIB_UNIT_MS, seekinfo);
              else
                status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                  seektime-(keytime*2), SLIB_UNIT_MS, seekinfo);
            }
            else
              status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
                                seektime-1000, SLIB_UNIT_MS, seekinfo);
            if (status!=NoErrors) return(status);
            timediff=seektime-Info->VideoTimeStamp;
          }
#if 0
          if (SvGetParamFloat(Info->Svh, SV_PARAM_FPS)>0)
            Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
          if (status==SlibErrorNone && timediff>=Info->VideoFrameDuration/100)
          {
            dword framesskipped=0;
            do {
              status=SlibSeekEx(handle, stream, SLIB_SEEK_NEXT, 0,
                                                SLIB_UNIT_NONE, seekinfo);
              framesskipped++;
              timediff=seektime-Info->VideoTimeStamp;
            } while (timediff>0 && status==SlibErrorNone);
            if (seekinfo) seekinfo->FramesSkipped+=framesskipped;
            /* if we skipped some frames, skip some audio too */
            if (framesskipped>5 && stream==SLIB_STREAM_ALL &&
                        Info->AudioStreams>0)
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          framesskipped)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            }
          }
          return(status);
    case SLIB_SEEK_NEXT_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            SlibTime_t vtime=Info->VideoTimeStamp;
            do {
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (status==NoErrors && mpegPictureInfo.Type==SV_I_PICTURE)
              {
                if (Info->stats && Info->stats->Record)
                  Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
                if (vtime==Info->VideoTimeStamp)
                  /* timecode didn't update time */
                  slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                vtime=Info->VideoTimeStamp;
                if (seekinfo)
                {
                  seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while (status==NoErrors);
            if (seekinfo)
            {
              seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
              seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                               ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+1000,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_NEXT_SUBKEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
          printf("SlibSeekEx(stream=%d,NEXT_SUBKEY,time=%d) VideoTime=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
            return(status);
#ifdef MPEG_SUPPORT
          if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
          {
            SvPictureInfo_t mpegPictureInfo;
            unsigned char *videobuf;
            SlibTime_t vtime=Info->VideoTimeStamp;
            /* cannot skip I or B frames without decompressing them */
            if (SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_I ||
                SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE)==FRAME_TYPE_P)
            {
              _SlibDebug(_DEBUG_||_SEEK_, printf("SvDecompressMPEG()\n") );
              status = SvDecompressMPEG(Info->Svh, Info->Multibuf,
                                        Info->MultibufSize, &videobuf);
              if (vtime==Info->VideoTimeStamp  /* timecode didn't update time */
                  && status==SvErrorNone)
                slibAdvancePositions(Info, 1);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              _SlibDebug(_WARN_ && status!=SvErrorNone,
                    printf("SvDecompressMPEG() %s\n", ScGetErrorStr(status)) );
            }
            do {
              mpegPictureInfo.Type = SV_I_PICTURE|SV_P_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              if (Info->stats && Info->stats->Record)
                Info->stats->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (vtime==Info->VideoTimeStamp) /* timecode didn't update time */
                slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
              vtime=Info->VideoTimeStamp;
              if (seekinfo)
                seekinfo->FramesSkipped+=mpegPictureInfo.TemporalRef;
              if (mpegPictureInfo.Type == SV_I_PICTURE ||
                  mpegPictureInfo.Type == SV_P_PICTURE)
              {
                /* found a subkey frame */
                if (seekinfo)
                {
                  seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                  seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
                }
                return(SlibErrorNone);
              }
            } while(status==NoErrors);
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              if (seekinfo)
              {
                seekinfo->VideoTimeStamp=Info->VideoTimeStamp;
                seekinfo->AudioTimeStamp=Info->AudioTimeStamp;
              }
              return(SlibErrorEndOfStream);
            }
          }
          _SlibDebug(_WARN_, printf("SvFindNextPicture() %s\n",
                             ScGetErrorStr(status)) );
#endif /* MPEG_SUPPORT */
          /* do an absolute seek */
          status=SlibSeekEx(handle, stream, SLIB_SEEK_KEY,
              (Info->VideoStreams<=0?Info->AudioTimeStamp
                                    :Info->VideoTimeStamp)+500,
              SLIB_UNIT_MS, seekinfo);
          return(status);
    case SLIB_SEEK_KEY:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,KEY,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (!Info->HeaderProcessed)
          {
            /* At very start of file we must Start the codecs since they
             * may need crucial header info
             */
            status=slibStartVideo(Info, FALSE);
            if (status!=SlibErrorNone) return(status);
          }
          if (Info->FileSize<=0)
            return(SlibErrorFileSize);
          if (seekpos!=0 && seekunits!=SLIB_UNIT_PERCENT100 &&
              (stream==SLIB_STREAM_MAINVIDEO || Info->AudioStreams==0) &&
               SlibTimeIsValid(Info->VideoTimeStamp))
          {
            /* see if we're already near the frame */
            timediff=seektime-Info->VideoTimeStamp;
            if (timediff>=-33 && timediff<=33)
              return(SlibErrorNone);
          }
          if ((seekunits==SLIB_UNIT_PERCENT100 && seekpos<=50)
                || seektime<=slibTimeToFrame(Info, 6))
          {
            /* close to beginning */
            if (seektime<=(Info->VideoFrameDuration*2)/100 &&
                  stream==SLIB_STREAM_MAINVIDEO) /* already close enough */
              return(SlibErrorNone);
seek_to_beginning:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, 0))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            Info->VideoTimeStamp = slibHasVideo(Info) ? 0 : SLIB_TIME_NONE;
            Info->AudioTimeStamp = slibHasAudio(Info) ? 0 : SLIB_TIME_NONE;
            return(SlibErrorNone);
          }
          else
          {
	    qword skippedframes=0;
            unsigned qword filepos;
            SlibTime_t vtime;
            const qword length=(Info->VideoStreams<=0) ? Info->AudioLength
                                                       : Info->VideoLength;
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              unsigned qword bytes_between_keys=Info->TotalBitRate/(8*2);
              filepos = (seekpos*Info->FileSize)/10000;
              /* seek a little before the desired point */
              if (bytes_between_keys>filepos)
                goto seek_to_beginning;
              else
                filepos-=bytes_between_keys;
            }
            else if (length==0)
              goto seek_to_beginning;
            else if (Info->FileSize<0x100000000)/* be careful of mul overflow */
              filepos = (seektime*Info->FileSize)/length;
            else
              filepos = ((seektime/100)*Info->FileSize)/(length/100);
seek_to_key:
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibEmptyPin(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibEmptyPin(Info, SLIB_DATA_AUDIO);
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            if ((status=slibReposition(Info, filepos))!=SlibErrorNone)
              return(status);
            Info->IOError=FALSE;
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
              slibPinFinishReposition(Info, SLIB_DATA_VIDEO);
            if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
            vtime=Info->VideoTimeStamp;
#ifdef MPEG_SUPPORT
            if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
            {
              SvPictureInfo_t mpegPictureInfo;
              if ((status=slibStartVideo(Info, FALSE))!=SlibErrorNone)
                return(status);
              mpegPictureInfo.Type = SV_I_PICTURE;
              status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
              _SlibDebug(_WARN_ && status!=NoErrors,
                            printf("SvFindNextPicture() %s\n",
                              ScGetErrorStr(status)) );
              if (status!=NoErrors)
                return(SlibErrorEndOfStream);
              skippedframes=mpegPictureInfo.TemporalRef;
            }
#endif /* MPEG_SUPPORT */
            if (seekunits==SLIB_UNIT_PERCENT100)
            {
              /* See if we seeked to far ahead */
              SlibPosition_t posdiff=
                SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100)
                  -seekpos;
              if (filepos>0 && posdiff>0 && tries<2)
              {
                tries++;
                /* we're ahead by one percent or more */
                /* move filepos back in the proportion that we're off by */
                filepos-=(posdiff*Info->FileSize)/8000;
                if (filepos<0)
                  goto seek_to_beginning;
                goto seek_to_key;
              }
            }
            if (slibUpdatePositions(Info, FALSE)) /* timecoded */
            {
              /* timecoded */
              /*
               * See if we seeked to far ahead
               * Note: if times are way off then we should ignore them.
               */
              if (seekunits==SLIB_UNIT_PERCENT100) /* ignore times */
                timediff=0;
              else
              {
                timediff=seektime-Info->VideoTimeStamp;
                if (timediff>-5000 && timediff<-100 && tries<3)
                {
                  /* move filepos back in the proportion that we're off by */
                  filepos=(filepos*seektime)/Info->VideoTimeStamp;
                  if (filepos<0)
                    filepos=0;
                  tries++;
                  goto seek_to_key;
                }
              }
#ifdef MPEG_SUPPORT
              if (Info->Svh && SlibTypeIsMPEGVideo(Info->Type))
              {
                SvPictureInfo_t mpegPictureInfo;
                mpegPictureInfo.Type = SV_I_PICTURE;
                while (timediff>Info->VideoFrameDuration/100 &&status==NoErrors)
                {
                  _SlibDebug(_SEEK_>1,
                     printf("SlibSeekEx(KEY, %d) Find next I frame (%d/%d)\n",
                      seektime, SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE),
                      Info->VideoTimeStamp) );
                  status = SvFindNextPicture(Info->Svh, &mpegPictureInfo);
                  _SlibDebug(_WARN_ && status!=NoErrors,
                    printf("SvFindNextPicture() %s\n", ScGetErrorStr(status)) );
                  skippedframes+=mpegPictureInfo.TemporalRef;
                  if (vtime==Info->VideoTimeStamp)
                    /* timecode didn't update time */
                    slibAdvancePositions(Info, mpegPictureInfo.TemporalRef);
                  vtime=Info->VideoTimeStamp;
                  timediff=seektime-Info->VideoTimeStamp;
                }
              }
#endif /* MPEG_SUPPORT */
            }
            else
            {
              _SlibDebug(_SEEK_, printf("SlibSeekEx(KEY, %d) no timecode\n",
                                       seektime) );
              if (slibHasVideo(Info))
              {
                Info->VideoTimeStamp=seektime;
                Info->VideoFramesProcessed=slibTimeToFrame(Info, seektime);
              }
              if (slibHasAudio(Info))
                Info->AudioTimeStamp=seektime;
              slibAdvancePositions(Info, skippedframes);
              timediff=seektime-Info->VideoTimeStamp;
            }
            if (Info->stats && Info->stats->Record)
              Info->stats->FramesSkipped+=skippedframes;
            if (seekinfo) seekinfo->FramesSkipped=skippedframes;
#if 0
            if (Info->Svh)
              Info->FramesPerSec=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
#endif
            /* if we skipped some frames, skip some audio too */
            if (skippedframes>5 && stream==SLIB_STREAM_ALL && slibHasAudio(Info))
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibSkipAudio(Info, stream, (Info->VideoFrameDuration*
                                          skippedframes)/100);
              slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
              if (SlibTimeIsInValid(Info->AudioTimeStamp))
              {
                Info->AudioTimeStamp=slibGetNextTimeOnPin(Info, slibGetPin(Info, SLIB_DATA_AUDIO), 100*1024);
                if (SlibTimeIsInValid(Info->AudioTimeStamp))
                  Info->AudioTimeStamp=Info->VideoTimeStamp;
                else
                  Info->AudioTimeStamp-=Info->AudioPTimeBase;
              }
            }
            if (status==ScErrorEndBitstream)
            {
              if (Info->FileSize>0 && !Info->VideoLengthKnown)
                slibUpdateLengths(Info);
              return(SlibErrorEndOfStream);
            }
            else if (status!=NoErrors)
              return(SlibErrorReading);
            return(SlibErrorNone);
          }
          break;
    case SLIB_SEEK_RESET:
          _SlibDebug(_VERBOSE_||_SEEK_,
            printf("SlibSeekEx(stream=%d,RESET,time=%d) VideoTimeStamp=%ld\n",
                        stream,seektime,Info->VideoTimeStamp) );
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINVIDEO)
            slibEmptyPin(Info, SLIB_DATA_VIDEO);
          if (stream==SLIB_STREAM_ALL || stream==SLIB_STREAM_MAINAUDIO)
            slibEmptyPin(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_MAINAUDIO)
            slibPinFinishReposition(Info, SLIB_DATA_AUDIO);
          if (stream==SLIB_STREAM_ALL)
          {
            slibEmptyPin(Info, SLIB_DATA_COMPRESSED);
            Info->BytesProcessed = 0;
          }
          Info->HeaderProcessed = FALSE;
          return(SlibErrorNone);
      case SLIB_SEEK_RESYNC:
          seekpos=SlibGetParamInt(Info, SLIB_STREAM_ALL, SLIB_PARAM_PERCENT100);
          if (seekpos<0 ||
              (SlibTimeIsValid(Info->VideoTimeStamp) &&
               Info->VideoTimeStamp<slibFrameToTime(Info, 6)))
            seekpos=0;
          _SlibDebug(_VERBOSE_||_SEEK_,
             printf("SlibSeekEx(stream=%d,RESYNC) seekpos=%ld\n",
                        stream, seekpos) );
          return(SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, seekpos,
                             SLIB_UNIT_PERCENT100, seekinfo));
      default:
          _SlibDebug(_VERBOSE_||_SEEK_||_WARN_,
             printf("SlibSeekEx(stream=%d,seektype=%d,time=%d) VideoTimeStamp=%ld Bad seek type\n",
                        stream,seektype,seektime,Info->VideoTimeStamp) );
  }
  return(SlibErrorForwardOnly);
}


SlibList_t *SlibQueryList(SlibQueryType_t qtype)
{
  switch(qtype)
  {
    case SLIB_QUERY_TYPES:        return(_listTypes);
    case SLIB_QUERY_COMP_TYPES:   return(_listCompressTypes);
    case SLIB_QUERY_DECOMP_TYPES: return(_listDecompressTypes);
    case SLIB_QUERY_ERRORS:       return(_listErrors);
    default:                      return(NULL);
  }
}

char *SlibQueryForDesc(SlibQueryType_t qtype, int enumval)
{
  SlibList_t *entry=SlibQueryList(qtype);
  if (entry)
    entry=SlibFindEnumEntry(entry, enumval);
  if (entry)
    return(entry->Desc);
  else
    return(NULL);
}

int SlibQueryForEnum(SlibQueryType_t qtype, char *name)
{
  SlibList_t *list=SlibQueryList(qtype);
  if (!list)
    return(-1);
  while (list->Name)
  {
    if (strcmp(list->Name, name)==0)
      return(list->Enum);
    list++;
  }
  return(-1);
}

SlibBoolean_t SlibIsEnd(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibBoolean_t isend=FALSE;
  if (!handle)
    isend=TRUE;
  else if (stream==SLIB_STREAM_MAINAUDIO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      ScBitstream_t *bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (stream==SLIB_STREAM_MAINVIDEO)
  {
    isend=SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL?TRUE:FALSE;
    if (isend && Info->Svh) /* see if the video codec still has data */
    {
      ScBitstream_t *bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  else if (SlibPeekBuffer(Info, SLIB_DATA_AUDIO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_VIDEO, NULL, NULL)==NULL &&
           SlibPeekBuffer(Info, SLIB_DATA_COMPRESSED, NULL, NULL)==NULL)
  {
    ScBitstream_t *bs;
    isend=TRUE;
    if (Info->Svh) /* see if the video codec still has data */
    {
      bs=SvGetDataSource(Info->Svh);
      if (bs && !bs->EOI) isend=FALSE;
    }
    if (isend && Info->Sah) /* see if the audio codec still has data */
    {
      bs=SaGetDataSource(Info->Sah);
      if (bs && !bs->EOI) isend=FALSE;
    }
  }
  _SlibDebug(_VERBOSE_,
      printf("SlibIsEnd() %s\n",isend?"TRUE":"FALSE"));
  return(isend);
}

SlibStatus_t SlibClose(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  _SlibDebug(_DEBUG_, printf("SlibClose\n") );
  if (!handle)
    return(SlibErrorBadHandle);
  /* close video codec */
  if (Info->Svh)
  {
    if (Info->VideoCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      _SlibDebug(_DEBUG_, printf("SvDecompress/CompressEnd()\n") );
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SvDecompressEnd(Info->Svh);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SvCompressEnd(Info->Svh);
      Info->VideoCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SvCloseCodec()\n") );
    SvCloseCodec(Info->Svh);
  }
  Info->VideoCodecState=SLIB_CODEC_STATE_NONE;
  /* close audio codec */
  if (Info->Sah)
  {
    if (Info->AudioCodecState==SLIB_CODEC_STATE_BEGUN)
    {
      if (Info->Mode==SLIB_MODE_DECOMPRESS)
        SaDecompressEnd(Info->Sah);
      else if (Info->Mode==SLIB_MODE_COMPRESS)
        SaCompressEnd(Info->Sah);
      Info->AudioCodecState=SLIB_CODEC_STATE_INITED;
    }
    _SlibDebug(_DEBUG_, printf("SaCloseCodec()\n") );
    SaCloseCodec(Info->Sah);
  }
  Info->AudioCodecState=SLIB_CODEC_STATE_NONE;
  if (Info->Mode==SLIB_MODE_COMPRESS && Info->HeaderProcessed)
    slibCommitBuffers(Info, TRUE);
  /* close format converter */
  if (Info->Sch)
  {
    SconClose(Info->Sch);
    Info->Sch=NULL;
  }
  /* close data sources */
  if (Info->Fd>=0)
  {
    _SlibDebug(_DEBUG_, printf("ScFileClose(%d)\n",Info->Fd) );
    ScFileClose(Info->Fd);
    Info->Fd=-1;
  }
  slibRemovePins(Info);
  /* slibDumpMemory(); */
  if (Info->SlibCB)
  {
    SlibMessage_t result;
    _SlibDebug(_VERBOSE_,
      printf("SlibClose() SlibCB(SLIB_MSG_CLOSE)\n") );
    result=(*(Info->SlibCB))((SlibHandle_t)Info,
                        SLIB_MSG_CLOSE, (SlibCBParam1_t)0,
                      (SlibCBParam2_t)0, (void *)Info->SlibCBUserData);
    Info->SlibCB=NULL;
  }
  /* free memory */
  if (Info->stats)  ScFree(Info->stats);
  if (Info->CompVideoFormat) ScFree(Info->CompVideoFormat);
  if (Info->CodecVideoFormat) ScFree(Info->CodecVideoFormat);
  if (Info->VideoFormat)  ScFree(Info->VideoFormat);
  if (Info->AudioFormat) ScFree(Info->AudioFormat);
  if (Info->CompAudioFormat) ScFree(Info->CompAudioFormat);
  if (Info->Imagebuf) SlibFreeBuffer(Info->Imagebuf);
  if (Info->CodecImagebuf) SlibFreeBuffer(Info->CodecImagebuf);
  if (Info->IntImagebuf) SlibFreeBuffer(Info->IntImagebuf);
  if (Info->Audiobuf) SlibFreeBuffer(Info->Audiobuf);
  if (Info->Multibuf) /* free all outstanding allocations on Multibuf */
    while (SlibFreeBuffer(Info->Multibuf)==SlibErrorNone);
  ScFree(Info);
  _SlibDebug(_WARN_ && SlibMemUsed()>0, printf("SlibClose() mem used=%d\n",
                     SlibMemUsed()) );
  return(SlibErrorNone);
}

/*
SlibStatus_t SlibGetInfo(SlibHandle_t handle, SlibInfo_t *info)
{
  if (!handle)
    return(SlibErrorBadHandle);
  if (!info)
    return(SlibErrorBadArgument);
  memcpy(info, handle, sizeof(SlibInfo_t));
  return(SlibErrorNone);
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\idct.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_idct.c,v $
 * Revision 1.1.4.3  1996/03/20  22:32:42  Hans_Graves
 * 	Moved ScScaleIDCT8x8i_C to sc_idct_scaled.c
 * 	[1996/03/20  22:13:55  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/08  18:46:17  Hans_Graves
 * 	Changed ScScaleIDCT8x8i_C() back to 20-bit
 * 	[1996/03/08  18:31:42  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/02/21  22:52:40  Hans_Graves
 * 	Changed precision of ScScaleIDCT8x8i_C() from 20 to 19 bits
 * 	[1996/02/21  22:45:34  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/01/26  19:01:34  Hans_Graves
 * 	Fix bug in ScScaleIDCT8x8i_C()
 * 	[1996/01/26  18:59:08  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/01/24  19:33:15  Hans_Graves
 * 	Optimization of ScScaleIDCT8x8i_C
 * 	[1996/01/24  18:09:55  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  20:19:31  Bjorn_Engberg
 * 	Removed unused local variable to get rid of a warning on NT.
 * 	[1996/01/08  20:17:34  Bjorn_Engberg]
 * 
 * Revision 1.1.2.2  1996/01/08  16:41:17  Hans_Graves
 * 	Moved IDCT routines from sc_dct.c
 * 	[1996/01/08  15:30:46  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_idct.c
** Inverse DCT related functions.
*/


/*
#define _SLIBDEBUG_
*/

#include <math.h>
#include "SC.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define F (float)
#define RSQ2    F 0.7071067811865
#define COSM1P3 F 1.3065629648764
#define COS1M3  F 0.5411961001462
#define COS3    F 0.3826834323651

#define Point 14

/*
** Name:      ScIDCT8x8
** Purpose:   2-d Inverse DCT.  Customized for (8x8) blocks
**
** Note:      This scheme uses the direct transposition of the forward
**            DCT. This may not be the preferred way in Hardware
**            Implementations
**
** Reference: FEIGs
**
*/
void ScIDCT8x8(int *outbuf)
{
        register int *outptr, itmp, *spptr, *interptr;
        register int t0, t1, t2, t3, t4, t5, t6, t7, tmp, mtmp;
        int i;
        static int tempptr[64];

        spptr    = outbuf;
        interptr = tempptr;

        /*
        ** Row Computations:
        */
        for (i = 0; i < 8; i++) {
           /*
           ** Check for zeros:
           */
           t0 = spptr[0];
                t1 = spptr[32];
                t2 = spptr[16];
                t3 = spptr[48];

                t4 = spptr[40];
                t5 = spptr[8];
                t6 = spptr[56];
                t7 = spptr[24];

                if (!(t1|t2|t3|t4|t5|t6|t7))  {
                    interptr[0]  = t0;
                    interptr[1]  = t0;
                    interptr[2]  = t0;
                    interptr[3]  = t0;
                    interptr[4]  = t0;
                    interptr[5]  = t0;
                    interptr[6]  = t0;
                    interptr[7]  = t0;
                    interptr += 8;
                }
                else {
                /* Compute B1-t P'     */
                tmp  = t4;
                t4  -= t7;
                t7  += tmp;

                tmp = t6;
                t6  = t5 -t6;
                t5 += tmp;

                /* Compute B2-t  */
                tmp = t3;
                t3 += t2;
                t2 -= tmp;

                tmp = t7;
                t7 += t5;
                t5 -= tmp;

                /* Compute M  */
                tmp = t2 + (t2 >> 2);
                tmp += (tmp >> 3);
                t2 = (tmp + (t2 >> 7)) >> 1;

                tmp = t5 + (t5 >> 2);
                tmp += (tmp >> 3);
                t5 = (tmp + (t5 >> 7)) >> 1;

                tmp = t6 - t4;
                mtmp = tmp + (tmp >> 1) + (tmp >> 5) - (tmp >> 11);
                tmp = mtmp >> 2;

                mtmp = t4 + (t4 >> 2) + (t4 >> 4) - (t4 >> 7) + (t4 >> 9);
                t4 = -mtmp - tmp;

                mtmp = (t6 + (t6 >> 4) + (t6 >> 6) + (t6 >> 8)) >> 1;
                t6 = mtmp + tmp;

                /* Compute A1-t  */
                tmp = t0;
                t0 += t1;
                t1  = tmp - t1;
                t3  = t2 + t3;

                /* Compute A2-t  */
                tmp = t0;
                t0 += t3;
                t3  = tmp - t3;

                tmp = t1;
                t1 += t2;
                t2  = tmp - t2;

                t7 += t6;
                t6 += t5;
                t5 -= t4;

                /* Compute A3-t  */
                 interptr[0]  = t0 + t7;
                interptr[1]  = t1 + t6;
                interptr[2]  = t2 + t5;
                interptr[3]  = t3 - t4;  /* Note in the prev. stage no
                                            t4 = -t4  */
                interptr[4]  = t3 + t4;
                interptr[5]  = t2 - t5;
                interptr[6]  = t1 - t6;
                interptr[7]  = t0 - t7;
                interptr += 8;
                }
                spptr++;
        }

        spptr = tempptr;
        outptr = outbuf;

        /*
        ** Column Computations
        */
        for (i = 0; i < 8; i++) {
                /* Check for zeros  */
                t0 = spptr[0];
                t1 = spptr[32];
                t2 = spptr[16];
                t3 = spptr[48];

                t4 = spptr[40];
                t5 = spptr[8];
                t6 = spptr[56];
                t7 = spptr[24];

                if (!(t1|t2|t3|t4|t5|t6|t7))  {
                     itmp = (t0 >> Point) + 128;
                     outptr[0]  = itmp;
                     outptr[1]  = itmp;
                     outptr[2]  = itmp;
                     outptr[3]  = itmp;
                     outptr[4]  = itmp;
                     outptr[5]  = itmp;
                     outptr[6]  = itmp;
                     outptr[7]  = itmp;
                     outptr += 8;
                }
                else
                {
                /* Compute B1-t P'     */
                tmp = t4;
                t4  -= t7;
                t7  += tmp;

                tmp = t6;
                t6  = t5 -t6;
                t5 += tmp;

                /* Compute B2-tilde  */
                tmp = t3;
                t3 += t2;
                t2 -= tmp;

                tmp = t7;
                t7 += t5;
                t5 -= tmp;

                /* Compute M-Tilde  */
                tmp = t2 + (t2 >> 2);
                tmp += (tmp >> 3);
                t2 = (tmp + (t2 >> 7)) >> 1;

                tmp = t5 + (t5 >> 2);
                tmp += (tmp >> 3);
                t5 = (tmp + (t5 >> 7)) >> 1;

                tmp = t6 - t4;
                mtmp = tmp + (tmp >> 1) + (tmp >> 5) - (tmp >> 11);
                tmp = mtmp >> 2;

                mtmp = t4 + (t4 >> 2) + (t4 >> 4) - (t4 >> 7) + (t4 >> 9);
                t4 = -mtmp - tmp;

                mtmp = (t6 + (t6 >> 4) + (t6 >> 6) + (t6 >> 8)) >> 1;
                t6 = mtmp + tmp;

                /* Compute A1-t  */
                tmp = t0;
                t0 += t1;
                t1  = tmp - t1;
                t3  = t2 + t3;

                /* Compute A2-t  */
                tmp = t0;
                t0 += t3;
                t3  = tmp - t3;

                tmp = t1;
                t1 += t2;
                t2  = tmp - t2;

                t7 += t6;
                t6 += t5;
                t5 -= t4;

                /* Compute A3-t  */

                outptr[0]  = ((t0 + t7) >> Point) + 128;
                outptr[1]  = ((t1 + t6) >> Point) + 128;
                outptr[2]  = ((t2 + t5) >> Point) + 128;
                outptr[3]  = ((t3 - t4) >> Point) + 128;
                outptr[4]  = ((t3 + t4) >> Point) + 128;
                outptr[5]  = ((t2 - t5) >> Point) + 128;
                outptr[6]  = ((t1 - t6) >> Point) + 128;
                outptr[7]  = ((t0 - t7) >> Point) + 128;

                outptr += 8;
                }
                spptr++;
        }
}


/*
** Function: ScScaleIDCT8x8
** Note:     This scheme uses the direct transposition of the forward
**           DCT.  This may not be the preferred way in Hardware 
**           Implementations
*/
void ScScaleIDCT8x8_C(float *ipbuf, int *outbuf)
{
  int i;
  int *outptr;
  register int itmp;
  register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
  float *spptr, *interptr;
  float tempptr[64];

  spptr = ipbuf;
  interptr = tempptr;

  /* Perform Row Computations  */
  for (i=0; i<8; i++)
  {
    /* Check for zeros  */
    t0 = spptr[0];
    t1 = spptr[4];
    t2 = spptr[2];
    t3 = spptr[6];

    t4 = spptr[5];
    t5 = spptr[1];
    t6 = spptr[7];
    t7 = spptr[3];

    if (!(t1||t2||t3||t4||t5||t6||t7))
    {
      interptr[0]  = t0;
      interptr[8]  = t0;
      interptr[16] = t0;
      interptr[24] = t0;
      interptr[32] = t0;
      interptr[40] = t0;
      interptr[48] = t0;
      interptr[56] = t0;
    }
    else
    {
      /* Compute B1-t P'     */
      tmp = t4;
      t4  -= t7;
      t7  += tmp;

      tmp = t6;
      t6  = t5 -t6;
      t5 += tmp;

      /* Compute B2-t  */
      tmp = t3;
      t3 += t2;
      t2 -= tmp;

      tmp = t7;
      t7 += t5;
      t5 -= tmp;

      /* Compute M  */
      t2  = t2*RSQ2;
      t5  = t5*RSQ2;
      tmp = (t6 - t4)*COS3;
      t4  = -t4*COSM1P3 - tmp;
      t6  = COS1M3*t6 + tmp;

      /* Compute A1-t  */
      tmp = t0;
      t0 += t1;
      t1  = tmp - t1;
      t3  = t2 + t3;

      /* Compute A2-t  */
      tmp = t0;
      t0 += t3;
      t3  = tmp - t3;

      tmp = t1;
      t1 += t2;
      t2  = tmp - t2;

      t7 += t6;
      t6 += t5;
      t5 -= t4;

      /* Compute A3-t  */
      interptr[0]  = t0 + t7;
      interptr[56] = t0 - t7;
      interptr[8]  = t1 + t6;
      interptr[48] = t1 - t6;
      interptr[16] = t2 + t5;
      interptr[40] = t2 - t5;
      interptr[24] = t3 - t4;  /* Note in the prev. stage no
                                            t4 = -t4  */
      interptr[32] = t3 + t4;
    }
    spptr  += 8;
    interptr++;
  }

  spptr = tempptr;
  outptr = outbuf;

  /* Perform Column Computations  */
  for (i=0; i<8; i++)
  {
    /* Check for zeros  */
    t0 = spptr[0];
    t1 = spptr[4];
    t2 = spptr[2];
    t3 = spptr[6];

    t4 = spptr[5];
    t5 = spptr[1];
    t6 = spptr[7];
    t7 = spptr[3];

    if (!(t1||t2||t3||t4||t5||t6||t7))
    {
      itmp = (int) (t0);
      outptr[0]  = itmp;
      outptr[8]  = itmp;
      outptr[16] = itmp;
      outptr[24] = itmp;
      outptr[32] = itmp;
      outptr[40] = itmp;
      outptr[48] = itmp;
      outptr[56] = itmp;
    }
    else
    {
      /* Compute B1-t P'     */
      tmp = t4;
      t4  -= t7;
      t7  += tmp;

      tmp = t6;
      t6  = t5 -t6;
      t5 += tmp;

      /* Compute B2-tilde  */
      tmp = t3;
      t3 += t2;
      t2 -= tmp;

      tmp = t7;
      t7 += t5;
      t5 -= tmp;

      /* Compute M-Tilde  */
      t2  = t2*RSQ2 ;
      t5  = t5*RSQ2 ;
      tmp = (t6 - t4)*COS3;
      t4  = -t4*COSM1P3 - tmp;
      t6  = COS1M3*t6 + tmp ;

      /* Compute A1-t  */
      tmp = t0;
      t0 += t1;
      t1  = tmp - t1;
      t3  = t2 + t3;

      /* Compute A2-t  */
      tmp = t0;
      t0 += t3;
      t3  = tmp - t3;
      tmp = t1;
      t1 += t2;
      t2  = tmp - t2;

      t7 += t6;
      t6 += t5;
      t5 -= t4;

      /* Compute A3-t  */
      outptr[0]  = (int)(t0+t7);
      outptr[56] = (int)(t0-t7);
      outptr[8]  = (int)(t1+t6);
      outptr[48] = (int)(t1-t6);
      outptr[16] = (int)(t2+t5);
      outptr[40] = (int)(t2-t5);
      outptr[24] = (int)(t3-t4);
      outptr[32] = (int)(t3+t4);
    }
    outptr++;
    spptr  += 8;
  }
}

/*
** Function: ScIDCT8x8s
** Note:     This scheme uses the direct transposition of the forward
**           DCT.  This may not be the preferred way in Hardware 
**           Implementations
*/
#define W1 2841 /* 2048*sqrt(2)*cos(1*pi/16) */
#define W2 2676 /* 2048*sqrt(2)*cos(2*pi/16) */
#define W3 2408 /* 2048*sqrt(2)*cos(3*pi/16) */
#define W5 1609 /* 2048*sqrt(2)*cos(5*pi/16) */
#define W6 1108 /* 2048*sqrt(2)*cos(6*pi/16) */
#define W7 565  /* 2048*sqrt(2)*cos(7*pi/16) */

#define IDCTSHIFTR  8
#define IDCTSHIFTC  (14+0)
#if 1
#define limit(var, min, max)  (var<=min ? min : (var>=max ? max : var))
#else
#define limit(var, min, max)  var
#endif

void ScIDCT8x8s_C(short *inbuf, short *outbuf)
{
  int i;
  register tmp0, tmp1, tmp2, tmp3, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register int *tmpblk;
  int tmpbuf[64];

  inblk = inbuf;
  tmpblk = tmpbuf;
  for (i=0; i<8; i++, inblk+=8, tmpblk+=8)
  {
    x0 = inblk[0];
    x1 = inblk[4];
    x1 = x1<<11;
    x2 = inblk[6];
    x3 = inblk[2];
    x4 = inblk[1];
    x5 = inblk[7];
    x6 = inblk[5];
    x7 = inblk[3];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmpblk[0]=tmpblk[1]=tmpblk[2]=tmpblk[3]=tmpblk[4]=tmpblk[5]=tmpblk[6]=
        tmpblk[7]=x0<<3;
    }
    else
    {
      tmp0 = x4 + x5;
      tmp0 = W7*tmp0;
      x0 = x0<<11;
      x0 = x0 + 128;
      x8 = x0 + x1;
      tmp1 = x6 + x7;
      x0 = x0 - x1;
      tmp1 = W3*tmp1;
      tmp2 = (W2+W6)*x2;
      tmp3 = (W2-W6)*x3;
      x4 = (W1-W7)*x4;
      x5 = (W1+W7)*x5;
      x4 = tmp0 + x4;
      x1 = x3 + x2;
      x5 = tmp0 - x5;
      x1 = W6*x1;
      tmp0 = (W3-W5)*x6;
      x7 = (W3+W5)*x7;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      tmp0 = tmp1 - tmp0;
      x7 = tmp1 - x7;
      x1 = x4 + tmp0;
      x4 = x4 - tmp0;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp0 = x4 + x5;
      tmp0 = 181*tmp0;
      x7 = x8 + x3;    /* F */
      tmp1 = x4 - x5;
      x8 = x8 - x3;    /* F */
      tmp1 = 181*tmp1;
      x3 = x0 + x2;    /* F */
      x0 = x0 - x2;    /* F */
      x2 = tmp0 + 128;
      x4 = tmp1 + 128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */
      tmp0 = x7+x1;
      tmp0 = tmp0>>IDCTSHIFTR;
      tmp1 = x3+x2;
      tmp1 = tmp1>>IDCTSHIFTR;
      tmp2 = x0+x4;
      tmp2 = tmp2>>IDCTSHIFTR;
      tmp3 = x8+x6;
      tmp3 = tmp3>>IDCTSHIFTR;
      tmpblk[0] = tmp0;
      tmpblk[1] = tmp1;
      tmpblk[2] = tmp2;
      tmpblk[3] = tmp3;
      tmp0 = x8-x6;
      tmp0 = tmp0>>IDCTSHIFTR;
      tmp1 = x0-x4;
      tmp1 = tmp1>>IDCTSHIFTR;
      tmp2 = x3-x2;
      tmp2 = tmp2>>IDCTSHIFTR;
      tmp3 = x7-x1;
      tmp3 = tmp3>>IDCTSHIFTR;
      tmpblk[4] = tmp0;
      tmpblk[5] = tmp1;
      tmpblk[6] = tmp2;
      tmpblk[7] = tmp3;
    }
  }

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    x0 = tmpblk[8*0];
    x1 = tmpblk[4*8]<<8;
    x2 = tmpblk[6*8];
    x3 = tmpblk[2*8];
    x4 = tmpblk[1*8];
    x5 = tmpblk[7*8];
    x6 = tmpblk[5*8];
    x7 = tmpblk[3*8];
    if (!(x1 | x2 | x3 | x4 | x5 | x6 | x7))
    {
      tmp0=(x0+32)>>6;
      outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
       outblk[8*6]=outblk[8*7]=limit(tmp0, -256, 255);
    }
    else
    {
      x0 = tmpblk[8*0];
      tmp0 = x4+x5;
      x0 = x0<<8;
      tmp0 = W7*tmp0;
      x0 = x0 + 8192;
      tmp1 = x6+x7;
      tmp0 = tmp0 + 4;
      tmp1 = W3*tmp1;
      tmp1 = tmp1 + 4;
      x8 = x0 + x1;
      tmp2 = (W2+W6)*x2;
      x0 = x0 - x1;
      x1 = x3 + x2;
      x1 = W6*x1;
      tmp3 = (W2-W6)*x3;
      x1 = x1 + 4;
      x4 = (W1-W7)*x4;
      x4 = tmp0 + x4;
      x4 = x4>>3;
      x5 = (W1+W7)*x5;
      x2 = x1 - tmp2;
      x3 = x1 + tmp3;
      x6 = (W3-W5)*x6;
      x2 = x2>>3;
      x5 = tmp0 - x5;
      x5 = x5>>3;
      x6 = tmp1 - x6;
      x6 = x6>>3;
      x7 = (W3+W5)*x7;
      x7 = tmp1 - x7;
      x3 = x3>>3;
      x7 = x7>>3;
      x1 = x4 + x6;    /* F */
      x4 = x4 - x6;
      x6 = x5 + x7;    /* F */
      x5 = x5 - x7;    /* F */
      tmp1 = x4 + x5;
      x7 = x8 + x3;    /* F */
      tmp1 = 181*tmp1;
      x8 = x8 - x3;    /* F */
      x3 = x0 + x2;    /* F */
      tmp2 = x4 - x5;
      x0 = x0 - x2;    /* F */
      tmp2 = 181*tmp2;
      x2 = tmp1+128;
      x4 = tmp2+128;
      x2 = x2>>8;      /* F */
      x4 = x4>>8;      /* F */

      /* fourth stage */
      tmp0=x7+x1;
      tmp1=x3+x2;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x0+x4;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x8+x6;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;
      outblk[8*0] = limit(tmp0, -256, 255);
      outblk[8*1] = limit(tmp1, -256, 255);
      outblk[8*2] = limit(tmp2, -256, 255);
      outblk[8*3] = limit(tmp3, -256, 255);
      tmp0=x8-x6;
      tmp1=x0-x4;
      tmp0=tmp0>>IDCTSHIFTC;
      tmp2=x3-x2;
      tmp1=tmp1>>IDCTSHIFTC;
      tmp3=x7-x1;
      tmp2=tmp2>>IDCTSHIFTC;
      tmp3=tmp3>>IDCTSHIFTC;
      outblk[8*4] = limit(tmp0, -256, 255);
      outblk[8*5] = limit(tmp1, -256, 255);
      outblk[8*6] = limit(tmp2, -256, 255);
      outblk[8*7] = limit(tmp3, -256, 255);
    }
  }
}

#if 0
void ScIDCT8x8s_C(short *inbuf, short *outbuf)
{
  register int i, tmp, x0, x1, x2, x3, x4, x5, x6, x7, x8;
  register short *inblk, *outblk;
  register int *tmpblk;
  int tmpbuf[64];

  inblk = inbuf;
  tmpblk = tmpbuf;
  for (i=0; i<8; i++, inblk+=8, tmpblk+=8)
  {
    if (!((x1 = inblk[4]<<11) | (x2 = inblk[6]) | (x3 = inblk[2]) |
        (x4 = inblk[1]) | (x5 = inblk[7]) | (x6 = inblk[5]) | (x7 = inblk[3])))
    {
      tmpblk[0]=tmpblk[1]=tmpblk[2]=tmpblk[3]=tmpblk[4]=tmpblk[5]=tmpblk[6]=
        tmpblk[7]=inblk[0]<<3;
    }
    else
    {
      x0 = (inblk[0]<<11) + 128; /* for proper rounding in the fourth stage */

      /* first stage */
      x8 = W7*(x4+x5);
      x4 = x8 + (W1-W7)*x4;
      x5 = x8 - (W1+W7)*x5;
      x8 = W3*(x6+x7);
      x6 = x8 - (W3-W5)*x6;
      x7 = x8 - (W3+W5)*x7;

      /* second stage */
      x8 = x0 + x1;
      x0 -= x1;
      x1 = W6*(x3+x2);
      x2 = x1 - (W2+W6)*x2;
      x3 = x1 + (W2-W6)*x3;
      x1 = x4 + x6;
      x4 -= x6;
      x6 = x5 + x7;
      x5 -= x7;

      /* third stage */
      x7 = x8 + x3;
      x8 -= x3;
      x3 = x0 + x2;
      x0 -= x2;
      x2 = (181*(x4+x5)+128)>>8;
      x4 = (181*(x4-x5)+128)>>8;

      /* fourth stage */
      tmpblk[0] = (x7+x1)>>8;
      tmpblk[1] = (x3+x2)>>8;
      tmpblk[2] = (x0+x4)>>8;
      tmpblk[3] = (x8+x6)>>8;
      tmpblk[4] = (x8-x6)>>8;
      tmpblk[5] = (x0-x4)>>8;
      tmpblk[6] = (x3-x2)>>8;
      tmpblk[7] = (x7-x1)>>8;
    }
  }

  tmpblk = tmpbuf;
  outblk = outbuf;
  for (i=0; i<8; i++, tmpblk++, outblk++)
  {
    /* shortcut */
    if (!((x1 = (tmpblk[4*8]<<8)) | (x2 = tmpblk[6*8]) | (x3 = tmpblk[2*8]) |
          (x4 = tmpblk[1*8]) | (x5 = tmpblk[7*8]) | (x6 = tmpblk[5*8]) |
          (x7 = tmpblk[3*8])))
    {
      tmp=(tmpblk[8*0]+32)>>6;
      if (tmp<-256) tmp=-256; else if (tmp>255) tmp=255;
      outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
       outblk[8*6]=outblk[8*7]=tmp;
    }
    else
    {
      x0 = (tmpblk[8*0]<<8) + 8192;

      /* first stage */
      x8 = W7*(x4+x5) + 4;
      x4 = (x8+((W1-W7)*x4))>>3;
      x5 = (x8-((W1+W7)*x5))>>3;
      x8 = W3*(x6+x7) + 4;
      x6 = (x8-((W3-W5)*x6))>>3;
      x7 = (x8-((W3+W5)*x7))>>3;

      /* second stage */
      x8 = x0 + x1;
      x0 -= x1;
      x1 = W6*(x3+x2) + 4;
      x2 = (x1-((W2+W6)*x2))>>3;
      x3 = (x1+((W2-W6)*x3))>>3;
      x1 = x4 + x6;
      x4 -= x6;
      x6 = x5 + x7;
      x5 -= x7;

      /* third stage */
      x7 = x8 + x3;
      x8 -= x3;
      x3 = x0 + x2;
      x0 -= x2;
      x2 = ((181*(x4+x5))+128)>>8;
      x4 = ((181*(x4-x5))+128)>>8;

      /* fourth stage */
      outblk[8*0] = ((tmp=(x7+x1)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*1] = ((tmp=(x3+x2)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*2] = ((tmp=(x0+x4)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*3] = ((tmp=(x8+x6)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*4] = ((tmp=(x8-x6)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*5] = ((tmp=(x0-x4)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*6] = ((tmp=(x3-x2)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
      outblk[8*7] = ((tmp=(x7-x1)>>14)<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
    }
  }
}
#endif
#if 0
/* row (horizontal) IDCT
 *
 *           7                       pi         1
 * dst[k] = sum c[l] * src[l] * cos( -- * ( k + - ) * l )
 *          l=0                      8          2
 *
 * where: c[0]    = 128
 *        c[1..7] = 128*sqrt(2)
 */
static void idctrow(short *inblk, short *outblk)
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  /* shortcut */
  if (!((x1 = inblk[4]<<11) | (x2 = inblk[6]) | (x3 = inblk[2]) |
        (x4 = inblk[1]) | (x5 = inblk[7]) | (x6 = inblk[5]) | (x7 = inblk[3])))
  {
    outblk[0]=outblk[1]=outblk[2]=outblk[3]=outblk[4]=outblk[5]=outblk[6]=
      outblk[7]=inblk[0]<<3;
    return;
  }

  x0 = (inblk[0]<<11) + 128; /* for proper rounding in the fourth stage */

  /* first stage */
  x8 = W7*(x4+x5);
  x4 = x8 + (W1-W7)*x4;
  x5 = x8 - (W1+W7)*x5;
  x8 = W3*(x6+x7);
  x6 = x8 - (W3-W5)*x6;
  x7 = x8 - (W3+W5)*x7;

  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2);
  x2 = x1 - (W2+W6)*x2;
  x3 = x1 + (W2-W6)*x3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;

  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;

  /* fourth stage */
  outblk[0] = (x7+x1)>>8;
  outblk[1] = (x3+x2)>>8;
  outblk[2] = (x0+x4)>>8;
  outblk[3] = (x8+x6)>>8;
  outblk[4] = (x8-x6)>>8;
  outblk[5] = (x0-x4)>>8;
  outblk[6] = (x3-x2)>>8;
  outblk[7] = (x7-x1)>>8;
}

/* column (vertical) IDCT
 *
 *             7                         pi         1
 * dst[8*k] = sum c[l] * src[8*l] * cos( -- * ( k + - ) * l )
 *            l=0                        8          2
 *
 * where: c[0]    = 1/1024
 *        c[1..7] = (1/1024)*sqrt(2)
 */
static void idctcol(short *inblk, short *outblk)
{
  int tmp, x0, x1, x2, x3, x4, x5, x6, x7, x8;

  /* shortcut */
  if (!((x1 = (inblk[8*4]<<8)) | (x2 = inblk[8*6]) | (x3 = inblk[8*2]) |
        (x4 = inblk[8*1]) | (x5 = inblk[8*7]) | (x6 = inblk[8*5]) |
        (x7 = inblk[8*3])))
  {
    tmp=(inblk[8*0]+32)>>6;
    if (tmp<-256) tmp=-256; else if (tmp>255) tmp=255;
    outblk[8*0]=outblk[8*1]=outblk[8*2]=outblk[8*3]=outblk[8*4]=outblk[8*5]=
     outblk[8*6]=outblk[8*7]=tmp;
    return;
  }

  x0 = (inblk[8*0]<<8) + 8192;

  /* first stage */
  x8 = W7*(x4+x5) + 4;
  x4 = (x8+(W1-W7)*x4)>>3;
  x5 = (x8-(W1+W7)*x5)>>3;
  x8 = W3*(x6+x7) + 4;
  x6 = (x8-(W3-W5)*x6)>>3;
  x7 = (x8-(W3+W5)*x7)>>3;

  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6*(x3+x2) + 4;
  x2 = (x1-(W2+W6)*x2)>>3;
  x3 = (x1+(W2-W6)*x3)>>3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;

  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181*(x4+x5)+128)>>8;
  x4 = (181*(x4-x5)+128)>>8;

  /* fourth stage */
  tmp=(x7+x1)>>14;
  outblk[8*0] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x3+x2)>>14;
  outblk[8*1] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x0+x4)>>14;
  outblk[8*2] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x8+x6)>>14;
  outblk[8*3] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x8-x6)>>14;
  outblk[8*4] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x0-x4)>>14;
  outblk[8*5] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x3-x2)>>14;
  outblk[8*6] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
  tmp=(x7-x1)>>14;
  outblk[8*7] = (tmp<=-256 ? -256 : (tmp>=255 ? 255 : tmp));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\idct_scl.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_idct_scaled.c,v $
 * Revision 1.1.2.3  1996/04/03  21:41:08  Hans_Graves
 * 	Fix bug in 8x8 IDCT
 * 	[1996/04/03  21:40:19  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/03/20  22:32:44  Hans_Graves
 * 	Moved ScScaleIDCT8x8i_C from sc_idct.c; Added 1x1,2x1,1x2,3x3,4x4,6x6
 * 	[1996/03/20  22:14:59  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_idct_scaled.c
** Scaled Inverse DCT related functions.
*/

/*
#define _SLIBDEBUG_
*/

#include <math.h>
#include "SC.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_   1  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define USE_MUL          0  /* Use multiplies vs. shift and adds */
#define CHECK_FOR_ZEROS  1  /* check for zero rows/columns */

#define BSHIFT  10
#define B1      (759250125L>>(30-BSHIFT))
#define B3      B1
#define B2      (-1402911301L>>(30-BSHIFT))
#define B4      (581104888L>>(30-BSHIFT))
#define B5      (410903207L>>(30-BSHIFT))


#define POINT      20
#define POINTROUND (0x101 << (POINT - 1))

#define IDCTAdjust(val)  (((val + POINTROUND) >> POINT) - 128)

/*   printf("In: %d,%d\n", inbuf[0*8],inbuf[1*8]);
     printf("Out: %d,%d,%d,%d,%d,%d,%d,%d\n", inbuf[0*8],inbuf[1*8],
       inbuf[2*8],inbuf[3*8],inbuf[4*8],inbuf[5*8],inbuf[6*8],inbuf[7*8]);
  */

/* Function: ScScaleIDCT8x8i_C()
** Purpose:  Used by MPEG video decompression.
**           20 Bit precision.
*/
void ScScaleIDCT8x8i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2, tmp3;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT8x8i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    x6 = inblk[6*8];
    x7 = inblk[7*8];
#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;

        inblk[0*8] = tmp1;
        inblk[1*8] = tmp2;
        inblk[2*8] = tmp2;
        inblk[3*8] = tmp1;
        inblk[4*8] = tmp1;
        inblk[5*8] = tmp2;
        inblk[6*8] = tmp2;
        inblk[7*8] = tmp1;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;
        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2 = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        inblk[0*8] = x0;
        inblk[1*8] = x4;
        inblk[2*8] = x2;
        inblk[3*8] = x6;
        inblk[4*8] = x6;
        inblk[5*8] = x2;
        inblk[6*8] = x4;
        inblk[7*8] = x0;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1 = x5 + x3;
      x5 = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      inblk[0*8] = x0 + x3;
      inblk[1*8] = x4 + x7;
      inblk[2*8] = x2 + x1;
      inblk[3*8] = x6 - x5;
      inblk[4*8] = x6 + x5;
      inblk[5*8] = x2 - x1;
      inblk[6*8] = x4 - x7;
      inblk[7*8] = x0 - x3;
    }
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    x6 = inblk[6];
    x7 = inblk[7];

#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;
        x1 = IDCTAdjust(tmp1);
        x0 = IDCTAdjust(tmp2);
        outbuf[0]  = x0;
        outbuf[1]  = x1;
        outbuf[2]  = x1;
        outbuf[3]  = x0;
        outbuf[4]  = x0;
        outbuf[5]  = x1;
        outbuf[6]  = x1;
        outbuf[7]  = x0;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;

        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2  = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        tmp1 = IDCTAdjust(x0);
        outbuf[0] = tmp1;
        outbuf[7] = tmp1;

        tmp2 = IDCTAdjust(x4);
        outbuf[1] = tmp2;
        outbuf[6] = tmp2;

        tmp3 = IDCTAdjust(x2);
        outbuf[2] = tmp3;
        outbuf[5] = tmp3;

        tmp1 = IDCTAdjust(x6);
        outbuf[3] = tmp1;
        outbuf[4] = tmp1;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1  = x5 + x3;
      x5  = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      outbuf[0] = IDCTAdjust(x0 + x3);
      outbuf[1] = IDCTAdjust(x4 + x7);
      outbuf[2] = IDCTAdjust(x2 + x1);
      outbuf[3] = IDCTAdjust(x6 - x5);
      outbuf[4] = IDCTAdjust(x6 + x5);
      outbuf[5] = IDCTAdjust(x2 - x1);
      outbuf[6] = IDCTAdjust(x4 - x7);
      outbuf[7] = IDCTAdjust(x0 - x3);
    }
    outbuf+=8;
    inblk+=8;
  }
}

#define IDCTAdjust128(val)  ((val + POINTROUND) >> POINT)

/* Function: ScScaleIDCT8x8i128_C()
** Purpose:  Used by H263 video decompression.
**           20 Bit precision.
*/
void ScScaleIDCT8x8i128_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2, tmp3;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT8x8i128_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    x6 = inblk[6*8];
    x7 = inblk[7*8];
#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;

        inblk[0*8] = tmp1;
        inblk[1*8] = tmp2;
        inblk[2*8] = tmp2;
        inblk[3*8] = tmp1;
        inblk[4*8] = tmp1;
        inblk[5*8] = tmp2;
        inblk[6*8] = tmp2;
        inblk[7*8] = tmp1;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;
        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2 = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        inblk[0*8] = x0;
        inblk[1*8] = x4;
        inblk[2*8] = x2;
        inblk[3*8] = x6;
        inblk[4*8] = x6;
        inblk[5*8] = x2;
        inblk[6*8] = x4;
        inblk[7*8] = x0;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1 = x5 + x3;
      x5 = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      inblk[0*8] = x0 + x3;
      inblk[1*8] = x4 + x7;
      inblk[2*8] = x2 + x1;
      inblk[3*8] = x6 - x5;
      inblk[4*8] = x6 + x5;
      inblk[5*8] = x2 - x1;
      inblk[6*8] = x4 - x7;
      inblk[7*8] = x0 - x3;
    }
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    /* Check for zeros  */
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    x6 = inblk[6];
    x7 = inblk[7];

#if CHECK_FOR_ZEROS
    if(!(x1|x3|x5|x7))
    {
      if(!(x2|x6))
      {
        tmp1 = x0 + x4;
        tmp2 = x0 - x4;
        x1 = IDCTAdjust128(tmp1);
        x0 = IDCTAdjust128(tmp2);
        outbuf[0]  = x0;
        outbuf[1]  = x1;
        outbuf[2]  = x1;
        outbuf[3]  = x0;
        outbuf[4]  = x0;
        outbuf[5]  = x1;
        outbuf[6]  = x1;
        outbuf[7]  = x0;
      }
      else
      {
        /* Stage 2 */
        x8 = x2 - x6;
        x6 = x2 + x6;

        /* Stage 3 */
#if USE_MUL
        x2=(x8*B1)>>BSHIFT;
#else
        tmp1 = x8 + (x8 >> 2);  /* x2=x8*B1 */
        tmp1 += (tmp1 >> 3);
        x2 = (tmp1 + (x8 >> 7)) >> 1;
#endif
        /* Stage 5 */
        tmp1 = x0 - x4;
        x0 = x0 + x4;
        tmp2  = x2 + x6;
        /* Stage 6 */
        x6 = x0 - tmp2;
        x0 = x0 + tmp2;
        x4 = tmp1 + x2;
        x2 = tmp1 - x2;
        /* Final Stage */
        tmp1 = IDCTAdjust128(x0);
        outbuf[0] = tmp1;
        outbuf[7] = tmp1;

        tmp2 = IDCTAdjust128(x4);
        outbuf[1] = tmp2;
        outbuf[6] = tmp2;

        tmp3 = IDCTAdjust128(x2);
        outbuf[2] = tmp3;
        outbuf[5] = tmp3;

        tmp1 = IDCTAdjust128(x6);
        outbuf[3] = tmp1;
        outbuf[4] = tmp1;
      }
    }
    else
#endif
    {
      /* Stage 1 */
      tmp1  = x5 + x3;
      x5  = x5 - x3;
      tmp2 = x1 + x7;
      x7 = x1 - x7;
      /* Stage 2 */
      tmp3 = x2 - x6;
      x6 = x2 + x6;
      x3 = tmp2 + tmp1;
      x1 = tmp2 - tmp1;
      x8 = x7 - x5;
      /* Stage 3 */
#if USE_MUL
      x5=(x5*B2)>>BSHIFT;
      x1=(x1*B3)>>BSHIFT;
      x2=(tmp3*B1)>>BSHIFT;
      x7=(x7*B4)>>BSHIFT;
      x8=(x8*B5)>>BSHIFT;
#else
      x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
      x5 = -x5;
      tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
      tmp1 += (tmp1 >> 3);
      x1 = (tmp1 + (x1 >> 7)) >> 1;
      tmp1 = tmp3 + (tmp3 >> 2);  /* x2=tmp3*B1 */
      tmp1 += (tmp1 >> 3);
      x2 = (tmp1 + (tmp3 >> 7)) >> 1;
      x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
      x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
#endif /* USE_MUL */
      /* Stage 4 */
      x5=x5 - x8;
      x7=x7 + x8;
      /* Stage 5  */
      tmp3 = x0 - x4;
      x0 = x0 + x4;
      tmp2 = x2 + x6;
      x3 = x3 + x7;
      x7 = x1 + x7;
      x1 = x1 - x5;
      /* Stage 6 */
      x6 = x0 - tmp2;
      x0 = x0 + tmp2;
      x4 = tmp3 + x2;
      x2 = tmp3 - x2;
      /* Final Stage */
      outbuf[0] = IDCTAdjust128(x0 + x3);
      outbuf[1] = IDCTAdjust128(x4 + x7);
      outbuf[2] = IDCTAdjust128(x2 + x1);
      outbuf[3] = IDCTAdjust128(x6 - x5);
      outbuf[4] = IDCTAdjust128(x6 + x5);
      outbuf[5] = IDCTAdjust128(x2 - x1);
      outbuf[6] = IDCTAdjust128(x4 - x7);
      outbuf[7] = IDCTAdjust128(x0 - x3);
    }
    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT1x1i_C(int *inbuf, int *outbuf)
{
  register int x0;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x1i_C()\n") );

  x0=inbuf[0];
  x0=((x0 + POINTROUND) >> POINT) - 128;
  for (i=0; i<64; i++)
    outbuf[i]=x0;
}

void ScScaleIDCT1x2i_C(int *inbuf, int *outbuf)
{
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x2i_C()\n") );

  x0 = inbuf[0*8];
  x1 = inbuf[1*8];
  /* Stage 2 */
  x3=x1;
  /* Stage 3 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  /* Stage 4 */
  x5=-x8;
  x7+=x8;
  /* Stage 5 */
  x3+=x7;
  x8=x1;
  x1-=x5;
  x7+=x8;
  /* Final Stage */
  outbuf[0*8+0]=outbuf[0*8+1]=outbuf[0*8+2]=outbuf[0*8+3]=
    outbuf[0*8+4]=outbuf[0*8+5]=outbuf[0*8+6]=outbuf[0*8+7]=IDCTAdjust(x0 + x3);
  outbuf[1*8+0]=outbuf[1*8+1]=outbuf[1*8+2]=outbuf[1*8+3]=
    outbuf[1*8+4]=outbuf[1*8+5]=outbuf[1*8+6]=outbuf[1*8+7]=IDCTAdjust(x0 + x7);
  outbuf[2*8+0]=outbuf[2*8+1]=outbuf[2*8+2]=outbuf[2*8+3]=
    outbuf[2*8+4]=outbuf[2*8+5]=outbuf[2*8+6]=outbuf[2*8+7]=IDCTAdjust(x0 + x1);
  outbuf[3*8+0]=outbuf[3*8+1]=outbuf[3*8+2]=outbuf[3*8+3]=
    outbuf[3*8+4]=outbuf[3*8+5]=outbuf[3*8+6]=outbuf[3*8+7]=IDCTAdjust(x0 - x5);
  outbuf[4*8+0]=outbuf[4*8+1]=outbuf[4*8+2]=outbuf[4*8+3]=
    outbuf[4*8+4]=outbuf[4*8+5]=outbuf[4*8+6]=outbuf[4*8+7]=IDCTAdjust(x0 + x5);
  outbuf[5*8+0]=outbuf[5*8+1]=outbuf[5*8+2]=outbuf[5*8+3]=
    outbuf[5*8+4]=outbuf[5*8+5]=outbuf[5*8+6]=outbuf[5*8+7]=IDCTAdjust(x0 - x1);
  outbuf[6*8+0]=outbuf[6*8+1]=outbuf[6*8+2]=outbuf[6*8+3]=
    outbuf[6*8+4]=outbuf[6*8+5]=outbuf[6*8+6]=outbuf[6*8+7]=IDCTAdjust(x0 - x7);
  outbuf[7*8+0]=outbuf[7*8+1]=outbuf[7*8+2]=outbuf[7*8+3]=
    outbuf[7*8+4]=outbuf[7*8+5]=outbuf[7*8+6]=outbuf[7*8+7]=IDCTAdjust(x0 - x3);
}

void ScScaleIDCT2x1i_C(int *inbuf, int *outbuf)
{
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT1x2i_C()\n") );

  x0 = inbuf[0];
  x1 = inbuf[1];
  /* Stage 2 */
  x3=x1;
  /* Stage 3 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  /* Stage 4 */
  x5=-x8;
  x7+=x8;
  /* Stage 5 */
  x3+=x7;
  x8=x1;
  x1-=x5;
  x7+=x8;
  /* Final Stage */
  outbuf[0*8+0]=outbuf[1*8+0]=outbuf[2*8+0]=outbuf[3*8+0]=
    outbuf[4*8+0]=outbuf[5*8+0]=outbuf[6*8+0]=outbuf[7*8+0]=IDCTAdjust(x0 + x3);
  outbuf[0*8+1]=outbuf[1*8+1]=outbuf[2*8+1]=outbuf[3*8+1]=
    outbuf[4*8+1]=outbuf[5*8+1]=outbuf[6*8+1]=outbuf[7*8+1]=IDCTAdjust(x0 + x7);
  outbuf[0*8+2]=outbuf[1*8+2]=outbuf[2*8+2]=outbuf[3*8+2]=
    outbuf[4*8+2]=outbuf[5*8+2]=outbuf[6*8+2]=outbuf[7*8+2]=IDCTAdjust(x0 + x1);
  outbuf[0*8+3]=outbuf[1*8+3]=outbuf[2*8+3]=outbuf[3*8+3]=
    outbuf[4*8+3]=outbuf[5*8+3]=outbuf[6*8+3]=outbuf[7*8+3]=IDCTAdjust(x0 - x5);
  outbuf[0*8+4]=outbuf[1*8+4]=outbuf[2*8+4]=outbuf[3*8+4]=
    outbuf[4*8+4]=outbuf[5*8+4]=outbuf[6*8+4]=outbuf[7*8+4]=IDCTAdjust(x0 + x5);
  outbuf[0*8+5]=outbuf[1*8+5]=outbuf[2*8+5]=outbuf[3*8+5]=
    outbuf[4*8+5]=outbuf[5*8+5]=outbuf[6*8+5]=outbuf[7*8+5]=IDCTAdjust(x0 - x1);
  outbuf[0*8+6]=outbuf[1*8+6]=outbuf[2*8+6]=outbuf[3*8+6]=
    outbuf[4*8+6]=outbuf[5*8+6]=outbuf[6*8+6]=outbuf[7*8+6]=IDCTAdjust(x0 - x7);
  outbuf[0*8+7]=outbuf[1*8+7]=outbuf[2*8+7]=outbuf[3*8+7]=
    outbuf[4*8+7]=outbuf[5*8+7]=outbuf[6*8+7]=outbuf[7*8+7]=IDCTAdjust(x0 - x3);
}

void ScScaleIDCT2x2i_C(int *inbuf, int *outbuf)
{
#if 1
  register unsigned int i;
  register int x0, x1, x3, x5, x7, x8, tmp1;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT2x2i_C()\n") );

  /* Column 1 */
  x0 = inbuf[0*8];
  x1 = inbuf[1*8];
  x3=x1;              /* Stage 2 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  x5=-x8;             /* Stage 4 */
  x7+=x8;
  x3+=x7;             /* Stage 5 */
  x8=x1;
  x1-=x5;
  x7+=x8;
  inbuf[0*8]=x0 + x3;
  inbuf[1*8]=x0 + x7;
  inbuf[2*8]=x0 + x1;
  inbuf[3*8]=x0 - x5;
  inbuf[4*8]=x0 + x5;
  inbuf[5*8]=x0 - x1;
  inbuf[6*8]=x0 - x7;
  inbuf[7*8]=x0 - x3;
  /* Column 2 */
  x0 = inbuf[0*8+1];
  x1 = inbuf[1*8+1];
  x3=x1;              /* Stage 2 */
#if USE_MUL
  x7=(x1*B4)>>BSHIFT;
  x8=(x1*B5)>>BSHIFT;
  x1=(x1*B3)>>BSHIFT;
#else
  x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
  x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
  tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
  tmp1 += (tmp1 >> 3);
  x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
  x5=-x8;             /* Stage 4 */
  x7+=x8;
  x3+=x7;             /* Stage 5 */
  x8=x1;
  x1-=x5;
  x7+=x8;
  inbuf[0*8+1]=x0 + x3;
  inbuf[1*8+1]=x0 + x7;
  inbuf[2*8+1]=x0 + x1;
  inbuf[3*8+1]=x0 - x5;
  inbuf[4*8+1]=x0 + x5;
  inbuf[5*8+1]=x0 - x1;
  inbuf[6*8+1]=x0 - x7;
  inbuf[7*8+1]=x0 - x3;

  /* Rows */
  for (i=0; i<8; i++)
  {
    x0 = inbuf[0];
    x1 = inbuf[1];
    x3=x1;              /* Stage 2 */
#if USE_MUL
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    x5=-x8;             /* Stage 4 */
    x7+=x8;
    x3+=x7;             /* Stage 5 */
    x8=x1;
    x1-=x5;
    x7+=x8;
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x0 + x7);
    outbuf[2] = IDCTAdjust(x0 + x1);
    outbuf[3] = IDCTAdjust(x0 - x5);
    outbuf[4] = IDCTAdjust(x0 + x5);
    outbuf[5] = IDCTAdjust(x0 - x1);
    outbuf[6] = IDCTAdjust(x0 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);
    outbuf+=8;
    inbuf+=8;
  }
#else
  /* Register only version */
  register int x3, x5, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8;
  register int x0a, x1a, x3a, x5a, x7a;
  register int x0b, x1b, x3b, x5b, x7b;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT2x2i_C()\n") );

#define Calc2x2(col, x0_calc, x1_calc, x0, x1, x3, x5, x7, x8) \
  x0 = x0_calc; \
  x1 = x1_calc; \
  x3=x1;              /* Stage 2 */ \
  x7=(x1*B4)>>BSHIFT; /* Stage 3 */ \
  x8=(x1*B5)>>BSHIFT; \
  x1=(x1*B3)>>BSHIFT; \
  x5=-x8;             /* Stage 4 */ \
  x7+=x8; \
  x3+=x7;             /* Stage 5 */ \
  x8=x1; \
  x1-=x5; \
  x7+=x8; \
  outbuf[0+col*8] = IDCTAdjust(x0 + x3); \
  outbuf[1+col*8] = IDCTAdjust(x0 + x7); \
  outbuf[2+col*8] = IDCTAdjust(x0 + x1); \
  outbuf[3+col*8] = IDCTAdjust(x0 - x5); \
  outbuf[4+col*8] = IDCTAdjust(x0 + x5); \
  outbuf[5+col*8] = IDCTAdjust(x0 - x1); \
  outbuf[6+col*8] = IDCTAdjust(x0 - x7); \
  outbuf[7+col*8] = IDCTAdjust(x0 - x3);

  /****** Row 0 ******/
  x0a = inbuf[0*8];
  x1a = inbuf[1*8];
  x3a=x1a;              /* Stage 2 */
  x7a=(x1a*B4)>>BSHIFT; /* Stage 3 */
  tmp1=(x1a*B5)>>BSHIFT;
  x1a=(x1a*B3)>>BSHIFT;
  x5a=-tmp1;            /* Stage 4 */
  x7a+=tmp1;
  x3a+=x7a;             /* Stage 5 */
  tmp1=x1a;
  x1a-=x5a;
  x7a+=tmp1;
  /****** Row 1 ******/
  x0b = inbuf[0*8+1];
  x1b = inbuf[1*8+1];
  x3b=x1b;              /* Stage 2 */
  x7b=(x1b*B4)>>BSHIFT; /* Stage 3 */
  tmp2=(x1b*B5)>>BSHIFT;
  x1b=(x1b*B3)>>BSHIFT;
  x5b=-tmp2;            /* Stage 4 */
  x7b+=tmp2;
  x3b+=x7b;             /* Stage 5 */
  tmp2=x1b;
  x1b-=x5b;
  x7b+=tmp2;

  Calc2x2(0, x0a+x3a, x0b+x3b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(1, x0a+x7a, x0b+x7b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(2, x0a+x1a, x0b+x1b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(3, x0a-x5a, x0b-x5b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(4, x0a+x5a, x0b+x5b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(5, x0a-x1a, x0b-x1b, tmp5, tmp6, x3, x5, tmp7, tmp8);
  Calc2x2(6, x0a-x7a, x0b-x7b, tmp1, tmp2, x3, x5, tmp3, tmp4);
  Calc2x2(7, x0a-x3a, x0b-x3b, tmp5, tmp6, x3, x5, tmp7, tmp8);
#endif
}

void ScScaleIDCT3x3i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1;
  register int x0, x1, x2, x3, x4, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT3x3i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<3; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    /* Stage 2 */
    x6=x2;
    x3=x1;
    /* Stage 3 */
#if USE_MUL
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x1*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1+=x8;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    inblk[0*8]  = x0 + x3;
    inblk[1*8]  = x4 + x7;
    inblk[2*8]  = x2 + x1;
    inblk[3*8]  = x6 + x8;
    inblk[4*8]  = x6 - x8;
    inblk[5*8]  = x2 - x1;
    inblk[6*8]  = x4 - x7;
    inblk[7*8]  = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    /* Stage 2 */
    x6=x2;
    x3=x1;
    /* Stage 3 */
#if USE_MUL
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x1*B5)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
#else
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x1 + (x1 >> 1) + (x1 >> 5) - (x1 >> 11)) >> 2; /* x8=x1*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1+=x8;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 + x8);
    outbuf[4] = IDCTAdjust(x6 - x8);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT4x4i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1, tmp2;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT4x4i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<4; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    /* Stage 1 */
    x5=-x3;
    /* Stage 2 */
    x6=x2;
    tmp1=x1-x3;
    x3=x1+x3;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x3*B5)>>BSHIFT;
    x1=(tmp1*B3)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp2 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp2 += (tmp2 >> 3);
    x2 = (tmp2 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x3 + (x3 >> 1) + (x3 >> 5) - (x3 >> 11)) >> 2; /* x8=x3*B5 */
    tmp2 = tmp1 + (tmp1 >> 2);  /* x1=tmp1*B3 */
    tmp2 += (tmp2 >> 3);
    x1 = (tmp2 + (tmp1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    inblk[0*8] = x0 + x3;
    inblk[1*8] = x4 + x7;
    inblk[2*8] = x2 + x1;
    inblk[3*8] = x6 - x5;
    inblk[4*8] = x6 + x5;
    inblk[5*8] = x2 - x1;
    inblk[6*8] = x4 - x7;
    inblk[7*8] = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    /* Stage 1 */
    x5=-x3;
    /* Stage 2 */
    x6=x2;
    tmp1=x1-x3;
    x3=x1+x3;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x7=(x1*B4)>>BSHIFT;
    x8=(x3*B5)>>BSHIFT;
    x1=(tmp1*B3)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp2 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp2 += (tmp2 >> 3);
    x2 = (tmp2 + (x2 >> 7)) >> 1;
    x7 = (x1 + (x1 >> 4) + (x1 >> 6) + (x1 >> 8)) >> 1; /* x7=x1*B4 */
    x8 = (x3 + (x3 >> 1) + (x3 >> 5) - (x3 >> 11)) >> 2; /* x8=x3*B5 */
    tmp2 = tmp1 + (tmp1 >> 2);  /* x1=tmp1*B3 */
    tmp2 += (tmp2 >> 3);
    x1 = (tmp2 + (tmp1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    tmp1=x6+x2;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    x4=x0+x2;
    x2=x0-x2;
    x6=x0-tmp1;
    x0=x0+tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 - x5);
    outbuf[4] = IDCTAdjust(x6 + x5);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}

void ScScaleIDCT6x6i_C(int *inbuf, int *outbuf)
{
  register int *inblk;
  register int tmp1;
  register int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int i;
  _SlibDebug(_DEBUG_, printf("ScScaleIDCT6x6i_C()\n") );

  /* Perform Row Computations  */
  inblk = inbuf;
  for(i=0; i<6; i++)
  {
    x0 = inblk[0*8];
    x1 = inblk[1*8];
    x2 = inblk[2*8];
    x3 = inblk[3*8];
    x4 = inblk[4*8];
    x5 = inblk[5*8];
    /* Stage 1 */
    x7=x1;
    tmp1=x5;
    x5-=x3;
    x3+=tmp1;
    /* Stage 2 */
    x6=x2;
    tmp1=x3;
    x3+=x1;
    x1-=tmp1;
    x8=x7-x5;
    /* Stage 3 */
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
    x7=(x7*B4)>>BSHIFT;
    x8=(x8*B5)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    x6+=x2;
    tmp1=x4;
    x4=x0-x4;
    x0+=tmp1;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    tmp1=x0;
    x0+=x6;
    x6=tmp1-x6;
    tmp1=x2;
    x2=x4-x2;
    x4+=tmp1;
    /* Final Stage */
    inblk[0*8] = x0 + x3;
    inblk[1*8] = x4 + x7;
    inblk[2*8] = x2 + x1;
    inblk[3*8] = x6 - x5;
    inblk[4*8] = x5 + x6;
    inblk[5*8] = x2 - x1;
    inblk[6*8] = x4 - x7;
    inblk[7*8] = x0 - x3;
    inblk++;
  }

  /* Perform Column Computations  */
  inblk = inbuf;
  for(i=0; i<8; i++)
  {
    x0 = inblk[0];
    x1 = inblk[1];
    x2 = inblk[2];
    x3 = inblk[3];
    x4 = inblk[4];
    x5 = inblk[5];
    /* Stage 1 */
    x7=x1;
    tmp1=x5;
    x5-=x3;
    x3+=tmp1;
    /* Stage 2 */
    x6=x2;
    tmp1=x3;
    x3+=x1;
    x1-=tmp1;
    x8=x7-x5;
#if USE_MUL
    x5=(x5*B2)>>BSHIFT;
    x2=(x2*B1)>>BSHIFT;
    x1=(x1*B3)>>BSHIFT;
    x7=(x7*B4)>>BSHIFT;
    x8=(x8*B5)>>BSHIFT;
#else
    x5 = x5 + (x5 >> 2) + (x5 >> 4) - (x5 >> 7) + (x5 >> 9); /* x5=x5*B2 */
    x5 = -x5;
    tmp1 = x2 + (x2 >> 2);  /* x2=x2*B1 */
    tmp1 += (tmp1 >> 3);
    x2 = (tmp1 + (x2 >> 7)) >> 1;
    x7 = (x7 + (x7 >> 4) + (x7 >> 6) + (x7 >> 8)) >> 1; /* x7=x7*B4 */
    x8 = (x8 + (x8 >> 1) + (x8 >> 5) - (x8 >> 11)) >> 2; /* x8=x8*B5 */
    tmp1 = x1 + (x1 >> 2);  /* x1=x1*B3 */
    tmp1 += (tmp1 >> 3);
    x1 = (tmp1 + (x1 >> 7)) >> 1;
#endif /* USE_MUL */
    /* Stage 4 */
    x5-=x8;
    x7+=x8;
    /* Stage 5 */
    x6+=x2;
    tmp1=x4;
    x4=x0-x4;
    x0+=tmp1;
    x3+=x7;
    x7+=x1;
    x1-=x5;
    /* Stage 6 */
    tmp1=x0;
    x0+=x6;
    x6=tmp1-x6;
    tmp1=x2;
    x2=x4-x2;
    x4+=tmp1;
    /* Final Stage */
    outbuf[0] = IDCTAdjust(x0 + x3);
    outbuf[1] = IDCTAdjust(x4 + x7);
    outbuf[2] = IDCTAdjust(x2 + x1);
    outbuf[3] = IDCTAdjust(x6 - x5);
    outbuf[4] = IDCTAdjust(x6 + x5);
    outbuf[5] = IDCTAdjust(x2 - x1);
    outbuf[6] = IDCTAdjust(x4 - x7);
    outbuf[7] = IDCTAdjust(x0 - x3);

    outbuf+=8;
    inblk+=8;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\h26x_int.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h26x_int.h,v $
  * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:    h26x_int.h
** MODULE NAME:  h26x_int.h
**
** MODULE DESCRIPTION: Internal H.261/H.263 header - used by h26x.c
**
** DESIGN OVERVIEW:
**
**--
*/
#ifndef _H26X_INT_H_
#define _H26X_INT_H_
#if !defined(_DEBUG) && defined(WIN32)
#define HANDLE_EXCEPTIONS
// #define EXCEPTION_MESSAGES /* dialog boxes appear on critical exceptions */
#endif

#ifdef __osf__ /* NOT needed for NT */
/*
 * For loading .so.
 */
#include <stdlib.h>
#include <dlfcn.h>
#endif

#define _huge
#define _loadds	
	
#include <windows.h>
#include <VFW.H>
// #include "cmm.h"
#include "slib.h"
// #include "SR.h"
#include "dech26x.h"



#ifdef H261_SUPPORT
#define H26X_FOURCC         VIDEO_FORMAT_DIGITAL_H261
#ifdef WIN32
#define H26X_NAME           L"Digital H.261"
#define H26X_DESCRIPTION    L"Digital H261 Video CODEC"
#define H26X_DRIVER         L"dech261.dll"
#else  /* !WIN32 */
#define H26X_NAME           "Digital H.261"
#define H26X_DESCRIPTION    "Digital H.261 Video CODEC"
#define H26X_DRIVER         "libh261.so"
#endif
#define H26X_KEYNAME        "vidc.d261"
#define H26X_KEYNAME_PRE    "vidc"
#define H26X_KEYNAME_POST   "d261"
#else /* H263 */
#define H26X_FOURCC         VIDEO_FORMAT_DIGITAL_H263
#ifdef WIN32
#define H26X_NAME           L"Digital H.263"
#define H26X_DESCRIPTION    L"Digital H263 Video CODEC"
#define H26X_DRIVER         L"dech263.dll"
#else  /* !WIN32 */
#define H26X_NAME           "Digital H.263"
#define H26X_DESCRIPTION    "Digital H.263 Video CODEC"
#define H26X_DRIVER         "libh263.so"
#endif
#define H26X_KEYNAME        "vidc.d263"
#define H26X_KEYNAME_PRE    "vidc"
#define H26X_KEYNAME_POST   "d263"
#endif /* H263 */

#define H26X_VERSION	        0x001
#define H26X_DEFAULT_SATURATION	5000.0
#define H26X_DEFAULT_CONTRAST	5000.0
#define H26X_DEFAULT_BRIGHTNESS	5000.0
#define H26X_DEFAULT_QUALITY    5000
#define H26X_DEFAULT_FRAMERATE  15.0F
#define H26X_DEFAULT_BITRATE    0 /* 57344*2 */
#define H26X_DEFAULT_MODE       0 /* PARAM_ALGFLAG_UMV|PARAM_ALGFLAG_ADVANCED */
#define H26X_DEFAULT_PACKETSIZE 512
#define H26X_DEFAULT_RTP        EC_RTP_MODE_OFF
#define H26X_DEFAULT_SQCIF_QI   8
#define H26X_DEFAULT_SQCIF_QP   8
#define H26X_DEFAULT_QCIF_QI    9
#define H26X_DEFAULT_QCIF_QP    9
#define H26X_DEFAULT_CIF_QI     14
#define H26X_DEFAULT_CIF_QP     14

#define IsH263Codec(h) ((_ICMGetType(h) == VIDEO_FORMAT_DIGITAL_H263) ? TRUE : FALSE)
#define IsH261Codec(h) ((_ICMGetType(h) == VIDEO_FORMAT_DIGITAL_H261) ? TRUE : FALSE)

/*
 * For the loading of the .so (H26X_DRIVER)
 */
#define H26X_LDLIB_PATH_COMP  	"mmeserver"
#define H26X_DRIVERPROC_ENTRY  	"ICH263Message"
#define H26X_OPENPROC_ENTRY  	"ICH263Open"

/*
** Standard Image sizes
*/
#define FULL_WIDTH      640
#define FULL_HEIGHT     480
#define NTSC_WIDTH      320
#define NTSC_HEIGHT     240
#define SIF_WIDTH       352
#define SIF_HEIGHT      240
#define CIF_WIDTH       352
#define CIF_HEIGHT      288
#define SQCIF_WIDTH     128
#define SQCIF_HEIGHT    96
#define QCIF_WIDTH      176
#define QCIF_HEIGHT     144
#define CIF4_WIDTH      (CIF_WIDTH*2)
#define CIF4_HEIGHT     (CIF_HEIGHT*2)
#define CIF16_WIDTH     (CIF_WIDTH*4)
#define CIF16_HEIGHT    (CIF_HEIGHT*4)

typedef struct SvH261_T_BSINFO_TRAILER{
	unsigned dword	dwVersion;
	unsigned dword	dwFlags;
	unsigned dword	dwUniqueCode;
	unsigned dword  dwCompressedSize;
	unsigned dword  dwNumberOfPackets;
	unsigned char	SourceFormat;
	unsigned char	TR;
	unsigned char   TRB;
	unsigned char   DBQ;
} RTPTRAILER_t;

typedef struct SvH263_T_EX_BITSTREAM_INFO{
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	Mode;
	unsigned char	MBA;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV1;
	char			VMV1;
	char			HMV2;
	char			VMV2;
} SvH263BITSTREAM_INFO;

typedef struct SvH261_T_EX_BITSTREAM_INFO{
	unsigned dword	dwFlag;
	unsigned dword	dwBitOffset;
	unsigned char	MBAP;
	unsigned char	Quant;
	unsigned char	GOBN;
	char			HMV;
	char			VMV;
    char			padding0;
    short			padding1;
} SvH261BITSTREAM_INFO;


typedef struct _h26Xinfo
{
    struct _h26Xinfo    *next;
    HIC                 hic;
    BOOL                bCompressBegun;
    BOOL                bDecompressBegun;
    BOOL                bPaletteInitialized;
    BOOL                bUsesCodec;
    BOOL                bUsesRender;
    DWORD               fccType;
    DWORD               fccHandler;
    SlibHandle_t        Sh;
    LPBITMAPINFOHEADER  lpbiOut;
    LPBITMAPINFOHEADER  lpbiIn;
    void               *client;
    BOOL                clientGone;
    DWORD               openFlags;
    DWORD               dwMaxCompBytes;
    /****** Frame-by-frame Modified Params ******/
    DWORD		dwMaxQuality;
    DWORD		dwMaxQi;
    DWORD		dwMaxQp;
    DWORD		dwQi;
    DWORD		dwQp;
    /********* Custom Settings ******/
    float		fFrameRate;
    long        lastFrameNum;
    DWORD       lastCompBytes;
    DWORD		dwQuality;
    DWORD		dwBitrate;
    DWORD		dwPacketSize;
    DWORD       dwRTP;
    DWORD		dwBrightness;
    DWORD		dwContrast;
    DWORD		dwSaturation;
} H26XINFO;

extern H26XINFO  *IChic2info(HIC hic);
extern H26XINFO  *ICclient2info(void *client);
extern BOOL	     ICclientGone(void *client);
extern MMRESULT  CALLBACK ICH263Message(DWORD_PTR driverHandle,
					UINT uiMessage,
					LPARAM lParam1,
					LPARAM lParam2,
					H26XINFO *info);
extern HIC	     ICH263Open(void *client);
extern void      ICH263Close(H26XINFO *info, BOOL postreply);
extern BOOL      ICH263QueryConfigure(H26XINFO *info);
extern MMRESULT  ICH263Configure(H26XINFO *info);
extern BOOL      ICH263QueryAbout(H26XINFO *info);
extern MMRESULT  ICH263About(H26XINFO *info);
extern MMRESULT  ICH263GetInfo(H26XINFO *info, ICINFO * pic, DWORD dwSize);
extern MMRESULT	 ICH263GetDefaultQuality(H26XINFO *info, DWORD *lParam1);
extern MMRESULT	 ICH263GetQuality(H26XINFO *info, DWORD *lParam1);
extern MMRESULT	 ICH263SetQuality(H26XINFO *info, DWORD lParam1);

extern MMRESULT  ICH263CompressQuery(H26XINFO *info,
				     LPBITMAPINFOHEADER lpbiIn,
				     LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263CompressBegin(H26XINFO *info,
				     LPBITMAPINFOHEADER lpbiIn,
				     LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263CompressGetFormat(H26XINFO *info,
					 LPBITMAPINFOHEADER lpbiIn,
					 LPBITMAPINFOHEADER lpbiOut);
extern DWORD ICH263CompressGetSize(LPBITMAPINFOHEADER lpbiIn);
extern MMRESULT  ICH263Compress(H26XINFO *info,
				ICCOMPRESS  *icCompress,
				DWORD   dwSize);
extern MMRESULT  ICH263CompressEnd(H26XINFO *info);

extern MMRESULT  ICH263DecompressQuery(H26XINFO *info,
				       LPBITMAPINFOHEADER lpbiIn,
				       LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263DecompressBegin(H26XINFO *info,
				       LPBITMAPINFOHEADER lpbiIn,
				       LPBITMAPINFOHEADER lpbiOut);
extern MMRESULT  ICH263DecompressGetFormat(H26XINFO *info,
					   LPBITMAPINFOHEADER lpbiIn,
					   LPBITMAPINFOHEADER lpbiOut);


extern MMRESULT  ICH263DecompressGetSize(H26XINFO *info,
					 LPBITMAPINFOHEADER lpbiIn,
					 LPBITMAPINFOHEADER lpbiOut);

extern MMRESULT  ICH263Decompress(H26XINFO *info,
				  ICDECOMPRESS  *icDecompress,
				  DWORD dwSize);

extern MMRESULT  ICH263DecompressEnd(H26XINFO *info);
extern MMRESULT  ICH263PrepareHeader(H26XINFO *info,
				     ICDECOMPRESS  *icDecompress,
				     DWORD dwSize);
extern MMRESULT  ICH263UnprepareHeader(H26XINFO *info,
				       ICDECOMPRESS  *icDecompress,
				       DWORD dwSize);
extern MMRESULT  ICH263SetQuality(H26XINFO *info, DWORD dwValue);

extern MMRESULT  ICH263CustomEncoder (H26XINFO *info, DWORD lParam1, DWORD lParam2);


extern void      WaitMsec(long waitTimeInMsec);
extern int TerminateH263();
extern int DriverPostReply(void *client, DWORD ret, DWORD arg);

/*
 * Windows NT debugging.
 */
#ifdef _SLIBDEBUG_
#include <stdio.h>
static int ScDebugPrintf(char *fmtstr, ...)
{
  int cnt;
  if (fmtstr)
  {
	char text[255];
    va_list argptr;
    va_start(argptr, fmtstr);
    cnt=vsprintf(text, fmtstr, argptr);
    va_end(argptr);
    OutputDebugString(text);
  }
  return(cnt);
}

static char *BMHtoString(LPBITMAPINFOHEADER lpbi)
{
  static char text[255];
  if (lpbi)
  {
    DWORD format=lpbi->biCompression;
    if (format==BI_RGB)
      sprintf(text, "%dx%d,%d bits (RGB)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount);
    else if (format==BI_BITFIELDS)
      sprintf(text, "%dx%d,%d bits (BITFIELDS)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount);
    else
      sprintf(text, "%dx%d,%d bits (%c%c%c%c)",
            lpbi->biWidth, lpbi->biHeight, lpbi->biBitCount,
            (char)(format&0xFF), (char)((format>>8)&0xFF),
            (char)((format>>16)&0xFF), (char)((format>>24)&0xFF));
  }
  else
    sprintf(text, "NULL");
  return(text);
}

#define DPF ScDebugPrintf
#define DPF2 ScDebugPrintf
#else
#define DPF
#define DPF2
#endif

#endif /* _H26X_INT_H_ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\me1.c ===
/* File: sv_h263_me1.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_7_1(SvH263CompressInfo_t *H263Info,
                          unsigned char *curr, unsigned char *prev, int x_curr,
                          int y_curr, int xoff, int yoff, int seek_dist,
                          H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{
  int Min_FRAME[5];
  H263_MotionVector MVframe[5];
  unsigned char *act_block,*aa,*ii;
  unsigned char *search_area, *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  unsigned char *act_block_subs2, *search_area_subs2;
  int h_lenby2,v_lenby2;
  int xlevel1,ylevel1,sxylevel1,sxylevel0;
  int level0_x_curr,level0_y_curr;

  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
    xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif
    /* in case xoff or yoff is odd */
    xoff= 2 * ((xoff)>>1);
    yoff= 2 * ((yoff)>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }


  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

#if 1
  act_block   = curr + x_curr + y_curr * H263Info->pels;
  search_area = prev + ilow + jlow * lx;
#else
  act_block = svH263LoadArea(curr, x_curr, y_curr, 16, 16, H263Info->pels);
  search_area = svH263LoadArea(prev, ilow, jlow, h_length, v_length, lx);
#endif

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
#if 1
  act_block_subs2   = H263Info->block_subs2;
  search_area_subs2 = H263Info->srch_area_subs2;
  sv_H263LdSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels, act_block_subs2, 8);
  sv_H263LdSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx,
	                                  search_area_subs2, H263_SRCH_RANGE);
#else
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);
#endif

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVframe[k].x = 0;
    MVframe[k].y = 0;
    MVframe[k].x_half = 0;
    MVframe[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
#ifndef USE_C
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
  Min_FRAME[0] = sv_H263PEr8_init_S(ii,act_block_subs2,H263_SRCH_RANGE,8);
#else
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
  Min_FRAME[0] = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,INT_MAX);
#endif

  MVframe[0].x = (short)xoff;
  MVframe[0].y = (short)yoff;

  /*** Spiral search (+-7) on subsampled images ***/

  sxylevel1 = (sxy-1)>>1;

  for (l = 1; l <= sxylevel1; l++) {
    i = x_curr + xoff - 2*l;
    j = y_curr + yoff - 2*l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

  	   /* 8x8 integer pel MV */
#ifndef USE_C
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#else
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#endif

	   if (sad < Min_FRAME[0]) {
	     MVframe[0].x = i - x_curr;
	     MVframe[0].y = j - y_curr;
	     Min_FRAME[0] = sad;
	   }
      }
      if      (k<2*l) i+=2;
      else if (k<4*l) j+=2;
      else if (k<6*l) i-=2;
      else            j-=2;
    }
  }

  /* motion vectors after level1 */
  xlevel1=MVframe[0].x;
  ylevel1=MVframe[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVframe[0].x = 0;
  MVframe[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */
#ifndef USE_C
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263PError16x16_S(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263SADMacroblock(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }
  else {
    /* the zero vector is within search_area */
#ifndef USE_C
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }

  if (xoff == 0 && yoff == 0) {
    Min_FRAME[0] = *SAD_0;
    MVframe[0].x = 0;
    MVframe[0].y = 0;
  }

  if (xlevel1 == 0 && ylevel1 == 0) {
    Min_FRAME[0] = *SAD_0;
    MVframe[0].x = 0;
    MVframe[0].y = 0;
  }
  else {
#ifndef USE_C
    ii = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*lx;
    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
    ii = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*lx;
    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
    if (sad < Min_FRAME[0]) {
      MVframe[0].x = (short)xlevel1;
      MVframe[0].y = (short)ylevel1;
      Min_FRAME[0] = sad;
    }
  }

  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /*** +-1 search on full-resolution images ***/
  level0_x_curr = x_curr + xlevel1;
  level0_y_curr = y_curr + ylevel1;

  sxylevel0=1;
  for (l = 1; l <= sxylevel0; l++) {

    i = level0_x_curr - l;
    j = level0_y_curr - l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

   	    /* 16x16 integer pel MV */
#ifndef USE_C
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
	    if (sad < Min_FRAME[0]) {
	      MVframe[0].x = i - x_curr;
	      MVframe[0].y = j - y_curr;
	      Min_FRAME[0] = sad;
	    }
      }
      if      (k<2*l) i++;
      else if (k<4*l) j++;
      else if (k<6*l) i--;
      else            j--;
    }
  }


  if (H263Info->advanced) {

    xvec = MVframe[0].x;
    yvec = MVframe[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

#if 1
    adv_search_area = prev + adv_ilow + adv_jlow * lx;
#else
    adv_search_area = svH263LoadArea(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);
#endif

    for (block = 0; block < 4; block++) {
#ifndef USE_C
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*lx;
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263PError8x8_S(ii,aa,lx,H263Info->pels,Min_FRAME[block+1]);
#else
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*lx;
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263MySADBlock(ii,aa,lx,H263Info->pels,Min_FRAME[block+1]);
#endif
      MVframe[block+1].x = MVframe[0].x;
      MVframe[block+1].y = MVframe[0].y;
    }

    /* Spiral Full search */
    for (l = 1; l <= sxy; l++) {
      i = adv_x_curr - l;
      j = adv_y_curr - l;
      for (k = 0; k < 8*l; k++) {
	    if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	      /* 8x8 integer pel MVs */
	      for (block = 0; block < 4; block++) {
#ifndef USE_C
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*lx;
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263PError8x8_S(ii, aa, lx, H263Info->pels, Min_FRAME[block+1]);
#else
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*lx;
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263MySADBlock(ii, aa, lx, H263Info->pels, Min_FRAME[block+1]);
#endif

	        if (sad < Min_FRAME[block+1]) {
	          MVframe[block+1].x = i - x_curr;
	          MVframe[block+1].y = j - y_curr;
	          Min_FRAME[block+1] = sad;
	        }
	      }	
	    }
	    if      (k<2*l) i++;
	    else if (k<4*l) j++;
	    else if (k<6*l) i--;
	    else            j--;
      }
    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVframe[0].x;
    MV[0][j][i]->y = MVframe[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVframe[k].x;
      MV[k][j][i]->y = MVframe[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

#if 0
  ScFree(act_block);
  ScFree(search_area);
  ScFree(act_block_subs2);
  ScFree(search_area_subs2);
  if (H263Info->advanced)  ScFree(adv_search_area);
#endif

  return;
}

/**********************************************************************
 *
 *	Name:		LoadArea
 *	Description:    fills array with a square of image-data
 *	
 *	Input:	       pointer to image and position, x and y size
 *	Returns:       pointer to area
 *	Side effects:  memory allocated to array
 *
 *
 ***********************************************************************/
unsigned char *sv_H263LoadSubs2Area(unsigned char *im, int x, int y,
			int x_size, int y_size, int lx)
{
  unsigned char *res = (unsigned char *)ScAlloc(sizeof(char)*x_size*y_size);
  register unsigned char *in, *out;
  register int increas, i;

  x = ((x+1)>>1) << 1;  /* subsampled images always correspond to pixels*/
  y = ((y+1)>>1) << 1;  /* of even coordinates in the original image */

  in = im + (y*lx) + x;
  out = res;

#ifdef USE_C
  increas = (lx - x_size) << 1;
  while (y_size--) {
    i = x_size;
    while (i--) {
      *out++ = *in;
      in+=2;
    }
    in += increas;
  };
#else
  if(x_size == 8){
    sv_H263Subsamp8_S(in, out, y_size, (lx << 1)) ;
  }
  else {
    increas = (lx - x_size) << 1;
    while (y_size--) {
      i = x_size;
      while (i--) {
        *out++ = *in;
        in+=2;
      }
      in += increas;
    };
  }
#endif
  return res;
}


void svH263LdSubs2Area(unsigned char *im, int x, int y,
  	                    int x_size, int y_size, int lx,
						unsigned char *srch_area, int area_length)
{
  register unsigned char *in, *out;
  register int incrs1, incrs2, i;

  x = ((x+1)>>1) << 1;  /* subsampled images always correspond to pixels*/
  y = ((y+1)>>1) << 1;  /* of even coordinates in the original image */

  in = im + (y*lx) + x;
  out = srch_area;

#ifdef USE_C
  incrs1 = (lx - x_size) << 1;
  incrs2 = area_length - x_size;
  while (y_size--) {
    i = x_size;
    while (i--) {
      *out++ = *in;
      in+=2;
    }
    in += incrs1;
    out += incrs2;
  };
#else
  if(area_length == 8){
    sv_H263Subsamp8_S(in, out, y_size, (lx << 1)) ;
  }
  else {
    incrs1 = (lx - x_size) << 1;
    incrs2 = area_length - x_size;
    while (y_size--) {
      i = x_size;
      while (i--) {
        *out++ = *in;
        in+=2;
      }
      in += incrs1;
	  out += incrs2;
    };
  }
#endif

  return ;
}

int sv_H263MySADSubBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int min_sofar)
{
#ifdef USE_C
  int i;
  int sad = 0;
  unsigned char *kk;

  kk = act_block;
  i = 4;
  while (i--) {
    sad += ( abs(*ii- *kk) +
		     abs(*(ii+1) - *(kk+1)) +
	         abs(*(ii+2) - *(kk+2)) +
			 abs(*(ii+3 ) - *(kk+3) ));
    ii += h_length;
    kk += 8;
    if (sad > min_sofar)
      return INT_MAX;
  }
  return sad;
#else
  return sv_H263MyError4_S(ii,act_block,h_length,min_sofar);
#endif /* USE_C */
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\h26x.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: h263.c,v $
 * $EndLog$
 */
/*
**++
** FACILITY:  Workstation Multimedia  (WMM)  v1.0
**
** FILE NAME:   h263.c
** MODULE NAME: h263.c
**
** MODULE DESCRIPTION:
**    H.263ICM driver
**
**    Microsoft file I/O functions
**	Implemented as functions:
**	H263Close
**	H263Compress
**	H263Decompress
**	H263DecompressEnd
**	H263DecompressGetPalette
**	H263DecompressGetSize
**	H263DecompressQuery
**	H263GetInfo
**	H263Info
**	H263Locate
**	H263Open
**	H263SendMessage
**
**    Private functions:
**
** DESIGN OVERVIEW:
**
**--
*/
/*-------------------------------------------------------------------------
**  Modification History: sc_mem.c
**      04-15-97  HWG          Added debug statements to help with checking
**                               for memory leaks
--------------------------------------------------------------------------*/

#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>
#include "h26x_int.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#define _MEMORY_    0  /* memory debugging */

dword scMemDump();
#endif


/* For shared mem */
static H26XINFO    *pValidHandles = NULL;
static int          NextH263Hic = 1;
static int          OpenCount = 0;
static HANDLE       InfoMutex = NULL;

#define InitInfoMutex()  if (InfoMutex==NULL) InfoMutex=CreateMutex(NULL, FALSE, NULL)
#define FreeInfoMutex()  if (InfoMutex!=NULL) \
                               CloseHandle(InfoMutex); InfoMutex=NULL
#define LockInfo()      WaitForSingleObject(InfoMutex, 5000);
#define ReleaseInfo()   ReleaseMutex(InfoMutex)

/*
 * Macros
 */
#define _ICH263CheckFlags(info, flag) ((info->openFlags & flag) ? TRUE : FALSE)
#define FREE_AND_CLEAR(s)      if (s) {ScFree(s); (s)=NULL;}
#define FREE_AND_CLEAR_PA(s)   if (s) {ScPaFree(s); (s)=NULL;}

/*
 *   Default LPBI format
 */
static BITMAPINFOHEADER __defaultDecompresslpbiOut =
{
   sizeof(BITMAPINFOHEADER),		// DWORD  biSize;
   0,					// LONG   biWidth;
   0, 					// LONG   biHeight;
   1,					// WORD   biPlanes;
   24,					// WORD   biBitCount
   BI_RGB,				// DWORD  biCompression;
   0,					// DWORD  biSizeImage;
   0,					// LONG   biXPelsPerMeter;
   0,					// LONG   biYPelsPerMeter;
   0,					// DWORD  biClrUsed;
   0					// DWORD  biClrImportant;
};

static BITMAPINFOHEADER __defaultCompresslpbiOut =
{
   sizeof(BITMAPINFOHEADER),		// DWORD  biSize;
   0,					// LONG   biWidth;
   0, 					// LONG   biHeight;
   1,					// WORD   biPlanes;
   24,					// WORD   biBitCount
#ifdef H261_SUPPORT
   VIDEO_FORMAT_DIGITAL_H261, // DWORD  biCompression;
#else
   VIDEO_FORMAT_DIGITAL_H263, // DWORD  biCompression;
#endif
   0,					// DWORD  biSizeImage;
   0,					// LONG   biXPelsPerMeter;
   0,					// LONG   biYPelsPerMeter;
   0,					// DWORD  biClrUsed;
   0					// DWORD  biClrImportant;
};

typedef struct SupportList_s {
  int   InFormat;   /* Input format */
  int   InBits;     /* Input number of bits */
  int   OutFormat;  /* Output format */
  int   OutBits;    /* Output number of bits */
} SupportList_t;

/*
** Input & Output Formats supported by H.261 Compression
*/
static SupportList_t _ICCompressionSupport[] = {
  BI_DECYUVDIB,        16, H26X_FOURCC,   24, /* YUV 4:2:2 Packed */
  BI_YUY2,             16, H26X_FOURCC,   24, /* YUV 4:2:2 Packed */
  BI_YU12SEP,          24, H26X_FOURCC,   24, /* YUV 4:1:1 Planar */
  BI_YVU9SEP,          9,  H26X_FOURCC,   24, /* YUV 16:1:1 Planar */
  BI_RGB,              16, H26X_FOURCC,   24, /* RGB 16 */
  BI_RGB,              24, H26X_FOURCC,   24, /* RGB 24 */
  0, 0, 0, 0
};

/*
** Input & Output Formats supported by H.261 Decompression
*/
static SupportList_t _ICDecompressionSupport[] = {
  H26X_FOURCC,   24, BI_DECYUVDIB,        16, /* YUV 4:2:2 Packed */
  H26X_FOURCC,   24, BI_YUY2,             16, /* YUV 4:2:2 Packed */
  H26X_FOURCC,   24, BI_YU12SEP,          24, /* YUV 4:1:1 Planar */
  H26X_FOURCC,   24, BI_YVU9SEP,          9, /* YUV 16:1:1 Planar */
  H26X_FOURCC,   24, BI_BITFIELDS,        32, /* BITFIELDS */
  H26X_FOURCC,   24, BI_RGB,              16, /* RGB 16 */
  H26X_FOURCC,   24, BI_RGB,              24, /* RGB 24 */
  H26X_FOURCC,   24, BI_RGB,              32, /* RGB 32 */
  H26X_FOURCC,   24, BI_RGB,              8,  /* RGB 8 */
  0, 0, 0, 0
};


/*
** Name: IsSupported
** Desc: Lookup the a given input and output format to see if it
**       exists in a SupportList.
** Note: If OutFormat==-1 and OutBits==-1 then only input format
**          is checked for support.
**       If InFormat==-1 and InBits==-1 then only output format
**          is checked for support.
** Return: NULL       Formats not supported.
**         not NULL   A pointer to the list entry.
*/
static SupportList_t *IsSupported(SupportList_t *list,
                                  int InFormat, int InBits,
                                  int OutFormat, int OutBits)
{
  if (OutFormat==-1 && OutBits==-1) /* Looking up only the Input format */
  {
    while (list->InFormat || list->InBits)
      if (list->InFormat == InFormat && list->InBits==InBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  if (InFormat==-1 && InBits==-1) /* Looking up only the Output format */
  {
    while (list->InFormat || list->InBits)
      if (list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
      else
        list++;
    return(NULL);
  }
  /* Looking up both Input and Output */
  while (list->InFormat || list->InBits)
    if (list->InFormat == InFormat && list->InBits==InBits &&
         list->OutFormat == OutFormat && list->OutBits==OutBits)
        return(list);
    else
      list++;
  return(NULL);
}

unsigned int CalcImageSize(unsigned int fourcc, int w, int h, int bits)
{
  if (h<0) h=-h;
  if (IsYUV411Sep(fourcc))
    return((w * h * 3) / 2);
  else if (IsYUV422Sep(fourcc) || IsYUV422Packed(fourcc))
    return(w * h * 2);
  else if (IsYUV1611Sep(fourcc))
    return((w * h * 9) / 8);
#ifdef BICOMP_DECXIMAGEDIB
  else if (fourcc==BICOMP_DECXIMAGEDIB)
    return(bits<=8 ? w * h : (w * h * 4));
#endif
  else /* RGB */
    return(w * h * (bits+7)/8);
}

/*
**++
**  FUNCTIONAL_NAME: InitBitmapinfo
**
**  FUNCTIONAL_DESCRIPTION:
**	Allocate and copy our local copies of the input and output
**      BITMAPINFOHEADERs
**
**  FORMAL PARAMETERS:
**	info        pointer to the driver handle
**      lpbiIn      pointer to the input BITMAPINFOHEADER
**      lpbiOut     pointer to the output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**      ICERR_OK        Success
**      ICERR_MEMORY    Malloc failed
**
**  COMMENTS:
**
**  DESIGN:
**
**/

static MMRESULT InitBitmapinfo(H26XINFO *info,
			       LPBITMAPINFOHEADER lpbiIn,
			       LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_DEBUG_,
		ScDebugPrintf("In InitBitmapinfo(), IN: 0x%x, OUT: 0x%x\n", lpbiIn, lpbiOut));

    if (info->lpbiIn == NULL)
    {
        if ((info->lpbiIn = (VOID *)ScAlloc(lpbiIn->biSize)) == NULL)
            return(unsigned int)(ICERR_MEMORY);
    }
    bcopy(lpbiIn, info->lpbiIn, lpbiIn->biSize);

    if (info->lpbiOut == NULL)
    {
        if ((info->lpbiOut = (VOID *)ScAlloc(lpbiOut->biSize)) == NULL)
	    return(unsigned int)(ICERR_MEMORY);
    }
    bcopy(lpbiOut, info->lpbiOut, lpbiOut->biSize);

    _SlibDebug(_DEBUG_, ScDebugPrintf("Out InitBitmapinfo()\n"));
    return(ICERR_OK);
}

/*
**++
**  FUNCTIONAL_NAME: ICclient2info
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the client pointer to an H26XINFO pointer
**
**  FORMAL PARAMETERS:
**	client  the client ptr to look up
**
**  RETURN VALUE:
**
**      pointer to the H26XINFO structure or NULL
**
**  COMMENTS:
**
**  DESIGN:
**
**/

H26XINFO *ICclient2info(void *client)
{
   return (H26XINFO *) NULL;
}


/*
**++
**  FUNCTIONAL_NAME: IChic2info
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the HIC integer to an H26XINFO pointer
**
**  FORMAL PARAMETERS:
**	hic     the hic managed by icm.c
**
**  RETURN VALUE:
**
**      pointer to the H26XINFO structure or NULL
**
**  COMMENTS:
**
**  DESIGN:
**
**/

H26XINFO *IChic2info(HIC hic)
{
  H26XINFO *retptr=NULL, *ptr;

  InitInfoMutex();
  LockInfo();

#ifdef HANDLE_EXCEPTIONS
  __try {
    /* pointers go wrong when driver closes */
#endif /* HANDLE_EXCEPTIONS */
  for (ptr = pValidHandles; ptr; ptr=ptr->next)
    if (ptr->hic == hic)
    {
      retptr=ptr;
      break;
    }
#ifdef HANDLE_EXCEPTIONS
  } __finally {
#endif /* HANDLE_EXCEPTIONS */
    ReleaseInfo();
#ifdef HANDLE_EXCEPTIONS
    return(retptr);
  } /* try..except */
#endif /* HANDLE_EXCEPTIONS */
  return(retptr);
}


/*
**++
**  FUNCTIONAL_NAME: ICHandle2hic
**
**  FUNCTIONAL_DESCRIPTION:
**	Translate the SLIB codec handle to an ICM HIC value
**
**  FORMAL PARAMETERS:
**	Sh     SLIB handle returned on the SlibOpen call
**
**  RETURN VALUE:
**
**      hic     the hic managed by icm.c
**
**  COMMENTS:
**
**  DESIGN:
**
**/
HIC ICHandle2hic(SlibHandle_t Sh)
{
    H26XINFO *ptr;

    InitInfoMutex();
    LockInfo();
    for (ptr = pValidHandles; ptr; ptr=ptr->next)
        if (ptr->Sh == Sh)
	    break;
    ReleaseInfo();

    return(ptr->hic);
}


/*
**++
**  FUNCTIONAL_NAME: ICclientGone
**
**  FUNCTIONAL_DESCRIPTION:
**	Sets the clientGone flag in client's H26XINFO
**
**  FORMAL PARAMETERS:
**	client  the client ptr to look up
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL ICclientGone(void *client)
{
    H26XINFO    *ptr;

    LockInfo();
    for (ptr = pValidHandles; ptr; ptr = ptr->next) {
        if (ptr->client == client)
	  ptr->clientGone = TRUE;
    }
    ReleaseInfo();
    return(ptr != NULL);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Open
**
**  FUNCTIONAL_DESCRIPTION:
**	Open the Software CODEC
**
**  FORMAL PARAMETERS:
**	client
**
**  RETURN VALUE:
**      driverHandle
**
**  COMMENTS:
**
**  DESIGN:
**
**/

HIC  ICH263Open(void *client)
{
  H26XINFO    *info;

  ICOPEN *icopen =(ICOPEN *) client;
  DWORD fccType = icopen->fccType;
  UINT  dwFlags = icopen->dwFlags;

  _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open()\n") );

  /*
   * fccType must be 'vidc'
   */
  if (fccType != ICTYPE_VIDEO)
    return(0);

  /*
   * We don't support draw operations.
   */
  if ( dwFlags & ICMODE_DRAW )
    return 0;

  /*
   * We don't support compress and decompress
   * with the same handler.
   */
  if ( (dwFlags & ICMODE_COMPRESS) &&
       (dwFlags & ICMODE_DECOMPRESS) )
    return 0;

  /*
   * At least one of these flags must be set:
   * COMPRESS, DECOMPRESS or QUERY.
   */
  if ( !(dwFlags & ICMODE_COMPRESS) &&
       !(dwFlags & ICMODE_DECOMPRESS) &&
       !(dwFlags & ICMODE_QUERY) )
    return 0;
  info = (H26XINFO *) ScAlloc(sizeof(H26XINFO));
  if (info)
  {
    InitInfoMutex();
    LockInfo();
    OpenCount++;
    bzero(info, sizeof(H26XINFO));
    info->next = pValidHandles;
    pValidHandles = info;
    info->hic = (HANDLE) NextH263Hic++;  /* !!! check for used entry! */
    info->client = client;
    info->fFrameRate=H26X_DEFAULT_FRAMERATE;
    info->dwBitrate=H26X_DEFAULT_BITRATE;
    info->dwPacketSize=H26X_DEFAULT_PACKETSIZE;
    info->dwRTP=H26X_DEFAULT_RTP;

    info->dwQuality=H26X_DEFAULT_QUALITY;
    info->dwMaxQuality=H26X_DEFAULT_QUALITY;
    info->dwQi=H26X_DEFAULT_CIF_QI;
    info->dwQp=H26X_DEFAULT_CIF_QP;
    info->dwMaxQi=H26X_DEFAULT_CIF_QI;
    info->dwMaxQp=H26X_DEFAULT_CIF_QP;

    info->openFlags = dwFlags;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open() info=%p hic=%d\n", info, info->hic) );
    ReleaseInfo();
    return(info->hic);
  }
  else
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Open() alloc failed\n") );
    return(NULL);
  }
}

/*
**++
**  FUNCTIONAL_NAME: H263Close
**
**  FUNCTIONAL_DESCRIPTION:
**	Close the Software CODEC
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**	Does it's own post reply.
**
**  DESIGN:
**
**/

void ICH263Close(H26XINFO *info, BOOL postreply)
{
    H26XINFO *ptr;
    int status;

    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Close() In: info=%p\n", info) );
    if (info==NULL)
      return;
    if (info->Sh)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
      status=SlibClose(info->Sh);
      info->Sh = NULL;
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
    }

    _SlibDebug(_VERBOSE_, ScDebugPrintf("Freeing memory\n") );
    FREE_AND_CLEAR(info->lpbiIn);
    FREE_AND_CLEAR(info->lpbiOut);
    LockInfo();
    if (pValidHandles == info)
        pValidHandles = info->next;
    else
    {
      for (ptr = pValidHandles; ptr && ptr->next; ptr = ptr->next)
        if (ptr->next == info) /* found info, remove from linked list */
        {
          ptr->next = info->next;
          break;
        }
    }
    OpenCount--;
    if (pValidHandles==NULL) /* all instances closed, reset driver ID */
    {
      NextH263Hic=1;
      ReleaseInfo();
      FreeInfoMutex();
    }
    else
    {
      ptr = pValidHandles;
      ReleaseInfo();
    }
    _SlibDebug(_VERBOSE_, ScDebugPrintf("DriverPostReply\n") );
    if (postreply &&  !info->clientGone)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("DriverPostReply\n") );
      DriverPostReply(info->client, ICERR_OK, 0);
    }
    ScFree(info);
    _SlibDebug(_MEMORY_, scMemDump() );
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Close() Out\n") );
}


/*
**++
**  FUNCTIONAL_NAME: ICH263QueryConfigure
**
**  FUNCTIONAL_DESCRIPTION:
**	We don't do configure.  Say so.
**
**  FORMAL PARAMETERS:
**	Handle
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL     ICH263QueryConfigure(H26XINFO *info)
{
    return(FALSE);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Configure
**
**  FUNCTIONAL_DESCRIPTION:
**	Unsupported function
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263Configure(H26XINFO *info)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}

MMRESULT ICH263CustomEncoder(H26XINFO *info, DWORD param1, DWORD param2)
{
  SlibHandle_t Sh;
  SlibStream_t stream=SLIB_STREAM_ALL;
  WORD task=HIWORD(param1);
  WORD control=LOWORD(param1);
  Sh = info->Sh;
  if (task==EC_SET_CURRENT)
  {
    switch (control)
    {
	  case EC_RTP_HEADER: /* Turn on/off RTP */
        info->dwRTP=param2;
        switch (info->dwRTP)
        {
          case EC_RTP_MODE_OFF:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, 0);
            break;
          default:
          case EC_RTP_MODE_A:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPA);
            break;
          case EC_RTP_MODE_B:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPB);
            break;
          case EC_RTP_MODE_C:
		    SlibSetParamInt (Sh, stream, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPC);
            break;
        }
		return (ICERR_OK);
	  case EC_PACKET_SIZE: /* Set Packet Size */
        info->dwPacketSize=param2;
 		SlibSetParamInt (Sh, stream, SLIB_PARAM_PACKETSIZE, info->dwPacketSize);
		return (ICERR_OK);
      case EC_BITRATE: /* Set Bitrate */
        info->dwBitrate=param2;
		SlibSetParamInt (Sh, stream, SLIB_PARAM_BITRATE, info->dwBitrate);
		return (ICERR_OK);
      case EC_BITRATE_CONTROL: /* Turn constant bitrate on/off */
        if (param2==0)
          info->dwBitrate=0;
        else if (info->dwBitrate)
          info->dwBitrate=H26X_DEFAULT_BITRATE;
		SlibSetParamInt (Sh, stream, SLIB_PARAM_BITRATE, info->dwBitrate);
		return (ICERR_OK);
    }
  }
  else if (task==EC_GET_CURRENT)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    switch (control)
    {
	  case EC_RTP_HEADER:
        *pval=info->dwRTP;
		return (ICERR_OK);
	  case EC_PACKET_SIZE:
        *pval=info->dwPacketSize;
		return (ICERR_OK);
      case EC_BITRATE:
        *pval=info->dwBitrate;
		return (ICERR_OK);
      case EC_BITRATE_CONTROL: /* Turn constant bitrate on/off */
        *pval=info->dwBitrate?1:0;
		return (ICERR_OK);
    }
  }
  else if (task==EC_GET_FACTORY_DEFAULT)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    *pval=0;
    return (ICERR_OK);
  }
  else if (task==EC_GET_FACTORY_LIMITS)
  {
    DWORD *pval=(DWORD *)param2;
    if (pval==NULL)
      return((MMRESULT)ICERR_BADPARAM);
    *pval=0;
    return (ICERR_OK);
  }
  else if (task==EC_RESET_TO_FACTORY_DEFAULTS)
  {
    return (ICERR_OK);
  }
  return((MMRESULT)ICERR_UNSUPPORTED);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263QueryAbout
**
**  FUNCTIONAL_DESCRIPTION:
**	Tell 'em we don't do about
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

BOOL    ICH263QueryAbout(H26XINFO *info)
{
    return(FALSE);
}

/*
**++
**  FUNCTIONAL_NAME: ICH263About
**
**  FUNCTIONAL_DESCRIPTION:
**	About box
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263About (H26XINFO *info)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}
/*
**++
**  FUNCTIONAL_NAME: ICH263GetInfo
**
**  FUNCTIONAL_DESCRIPTION:
**	Return info about codec
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263GetInfo(H26XINFO *info, ICINFO *icinfo, DWORD dwSize)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In H263GetInfo\n") );

    icinfo->dwSize = sizeof(ICINFO);
    icinfo->fccType = ICTYPE_VIDEO;
    icinfo->fccHandler = H26X_FOURCC;
    icinfo->dwFlags = VIDCF_QUALITY|VIDCF_CRUNCH|VIDCF_TEMPORAL|VIDCF_FASTTEMPORALC;

    icinfo->dwVersion = H26X_VERSION;
    icinfo->dwVersionICM = ICVERSION;

    wcscpy(icinfo->szDescription, H26X_DESCRIPTION);
    wcscpy(icinfo->szName, H26X_NAME);
#if 0
    /* we shouldn't change the szDriver field */
    wcscpy(icinfo->szDriver, _wgetenv(L"SystemRoot"));
    if( icinfo->szDriver[0] != 0 )
        wcscat(icinfo->szDriver, L"\\System32\\" );
    wcscat(icinfo->szDriver, H26X_DRIVER);
#endif
    return (dwSize);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263CompressQuery
**
**  FUNCTIONAL_DESCRIPTION:
**	Determine compression capability
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressQuery(H26XINFO *info,
                             LPBITMAPINFOHEADER lpbiIn,
                             LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressQuery\n") );

    if (
		(!_ICH263CheckFlags(info, ICMODE_QUERY)) &&
		(
		(!_ICH263CheckFlags(info, ICMODE_COMPRESS)) ||
		(!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS))
		)
	   )
	return (MMRESULT)ICERR_BADHANDLE;

    /*
     * Must query at least an input or an output format
     */
    if (!lpbiIn && !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);

    if (!IsSupported(_ICCompressionSupport,
                    lpbiIn ? lpbiIn->biCompression : -1,
                    lpbiIn ? lpbiIn->biBitCount : -1,
                    lpbiOut ? lpbiOut->biCompression : -1,
                    lpbiOut ? lpbiOut->biBitCount : -1))
      return(MMRESULT)(ICERR_BADFORMAT);

    return ICERR_OK;
}


/*
**++
**  FUNCTIONAL_NAME: ICH263CompressBegin
**
**  FUNCTIONAL_DESCRIPTION:
**	Prepare to start a Compression operation
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressBegin(H26XINFO *info,
                             LPBITMAPINFOHEADER lpbiIn,
                             LPBITMAPINFOHEADER lpbiOut)
{
    MMRESULT            status;
    SlibStatus_t        sstatus;
#ifdef H261_SUPPORT
	SlibType_t stype = SLIB_TYPE_H261;
#else
	SlibType_t stype = SLIB_TYPE_H263;
#endif
	SlibHandle_t Sh;

    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressBegin\n") );

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS)) || (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
      return (MMRESULT)ICERR_BADHANDLE;

    if (!lpbiIn || !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);
    if ((status = ICH263CompressQuery(info, lpbiIn, lpbiOut)) != ICERR_OK)
      return status;
    if ((status = InitBitmapinfo(info, lpbiIn, lpbiOut)) != ICERR_OK)
      return status;
    info->bUsesCodec = TRUE;
    lpbiIn=info->lpbiIn;
    lpbiOut=info->lpbiOut;

    lpbiIn->biHeight=-lpbiIn->biHeight; /* SLIB assume first line is top */

    info->dwMaxQuality=H26X_DEFAULT_QUALITY;
    if (lpbiIn->biWidth<168) /* Sub-QCIF */
    {
      info->dwMaxQi=H26X_DEFAULT_SQCIF_QI;
      info->dwMaxQp=H26X_DEFAULT_SQCIF_QP;
    }
    if (lpbiIn->biWidth<300) /* QCIF */
    {
      info->dwMaxQi=H26X_DEFAULT_QCIF_QI;
      info->dwMaxQp=H26X_DEFAULT_QCIF_QP;
    }
    else /* CIF */
    {
      info->dwMaxQi=H26X_DEFAULT_CIF_QI;
      info->dwMaxQp=H26X_DEFAULT_CIF_QP;
    }
    info->lastFrameNum=0;
    info->lastCompBytes=0;
    /* Synchronized SLIB SYSTEMS calls */
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (before SlibOpen)\n", SlibMemUsed()) );
	sstatus = SlibOpenSync (&Sh, SLIB_MODE_COMPRESS, &stype, NULL, 0);
    if (sstatus!=SlibErrorNone) return((MMRESULT)ICERR_BADPARAM);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_WIDTH, lpbiIn->biWidth);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_HEIGHT, lpbiIn->biHeight);
#if 0
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiIn->biCompression);
	SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOBITS, lpbiIn->biBitCount);
#else
	SlibSetParamStruct(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiIn, lpbiIn->biSize);
#endif
//    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOQUALITY, info->dwQuality/100);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTI, info->dwQi);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTP, info->dwQp);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_BITRATE, info->dwBitrate);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_PACKETSIZE, info->dwPacketSize);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_ALGFLAGS, H26X_DEFAULT_MODE);
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_KEYSPACING, 132);
#ifdef H261_SUPPORT
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_MOTIONALG, 1);
#else
    SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_MOTIONALG, 2);
#endif
    SlibSetParamFloat(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FPS, info->fFrameRate);
    switch (info->dwRTP)
    {
      case EC_RTP_MODE_OFF:
            break;
      case EC_RTP_MODE_A:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPA);
            break;
      case EC_RTP_MODE_B:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPB);
            break;
      case EC_RTP_MODE_C:
	        SlibSetParamInt(Sh, SLIB_STREAM_ALL, SLIB_PARAM_FORMATEXT, PARAM_FORMATEXT_RTPC);
            break;
    }
	info->Sh = Sh;
	lpbiIn->biSizeImage = SlibGetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_IMAGESIZE);
    info->dwMaxCompBytes = ICH263CompressGetSize(lpbiIn);
    info->bCompressBegun = TRUE;

	return ICERR_OK;
}


DWORD ICH263CompressGetSize(LPBITMAPINFOHEADER lpbiIn)
{
  if (lpbiIn==NULL)
    return(0);
  else if (lpbiIn->biWidth<=168)
    return(0x1800); /* Sub-QCIF */
  else if (lpbiIn->biWidth<=300)
    return(0x2000); /* QCIF */
  else
    return(0x8000); /* CIF */
}

/*
**++
**  FUNCTIONAL_NAME: ICH263CompressGetFormat
**
**  FUNCTIONAL_DESCRIPTION:
**	Get the format for compression
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressGetFormat(H26XINFO *info,
                                          LPBITMAPINFOHEADER lpbiIn,
                                          LPBITMAPINFOHEADER lpbiOut)
{

    _SlibDebug(_DEBUG_, ScDebugPrintf("In ICH263CompressGetFormat\n") );

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS)) &&
        (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)) &&
        (!_ICH263CheckFlags(info, ICMODE_QUERY)))

		return (MMRESULT)ICERR_BADHANDLE;

    if (lpbiIn == NULL)
	return (MMRESULT)ICERR_BADPARAM;

    if (lpbiOut == NULL)
        return (sizeof(BITMAPINFOHEADER));

    bcopy(&__defaultCompresslpbiOut, lpbiOut, sizeof(BITMAPINFOHEADER));
    lpbiOut->biWidth = lpbiIn->biWidth;
    lpbiOut->biHeight= lpbiIn->biHeight;
    lpbiOut->biSizeImage = ICH263CompressGetSize(lpbiIn);
    _SlibDebug(_DEBUG_, ScDebugPrintf(" lpbiOut filled: %s\n",
		                     BMHtoString(lpbiOut)) );
    return(ICERR_OK);
}





/*
**++
**  FUNCTIONAL_NAME: ICH263CompressEnd
**
**  FUNCTIONAL_DESCRIPTION:
**	Terminate the compression cycle
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263CompressEnd(H26XINFO *info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263CompressEnd\n") );

  if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS))
      || (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
    return (MMRESULT)ICERR_BADHANDLE;

  if (info->Sh)
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
    SlibClose (info->Sh);
    info->Sh=NULL;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
  }
  info->bCompressBegun = FALSE;
  return(ICERR_OK);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressQuery
**
**  FUNCTIONAL_DESCRIPTION:
**	Query the codec to determine if it can decompress specified formats
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressQuery(H26XINFO *info,
                               LPBITMAPINFOHEADER lpbiIn,
                               LPBITMAPINFOHEADER lpbiOut)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressQuery\n") );

    if (!_ICH263CheckFlags(info, ICMODE_QUERY) &&
	!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	return (MMRESULT)ICERR_BADHANDLE;

    /*
     * Must query at least an input or an output format
     */
    if (!lpbiIn && !lpbiOut)
      return (MMRESULT)(ICERR_BADPARAM);

    if (!IsSupported(_ICDecompressionSupport,
                    lpbiIn ? lpbiIn->biCompression : -1,
                    lpbiIn ? lpbiIn->biBitCount : -1,
                    lpbiOut ? lpbiOut->biCompression : -1,
                    lpbiOut ? lpbiOut->biBitCount : -1))
      return(MMRESULT)(ICERR_BADFORMAT);

    _SlibDebug(_VERBOSE_, ScDebugPrintf("Out ICH263DecompressQuery\n") );
    return ICERR_OK;
}



/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressBegin
**
**  FUNCTIONAL_DESCRIPTION:
**	Begin the decompression process
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  ICERR_OK            No error
**  ICERR_MEMORY        Insufficient memory
**  ICERR_BADFORMAT     Invalid image format
**  ICERR_BADPARAM      Invalid image size
**
**  COMMENTS:
**
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressBegin(H26XINFO *info,
                               LPBITMAPINFOHEADER lpbiIn,
                               LPBITMAPINFOHEADER lpbiOut)
{
    MMRESULT            status;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressBegin\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	  return (MMRESULT)ICERR_BADHANDLE;

	if ((status = ICH263DecompressQuery(info, lpbiIn, lpbiOut))
        != ICERR_OK)
       return status;

    if (lpbiIn && lpbiOut)
    {
      if ((status = InitBitmapinfo(info, lpbiIn, lpbiOut)) != ICERR_OK)
	    return status;

      info->bUsesCodec = TRUE;
      info->bUsesRender = ((lpbiOut->biBitCount == 8) &&
			     ((lpbiOut->biCompression == BI_DECXIMAGEDIB)||
			      (lpbiOut->biCompression == BI_DECGRAYDIB) ||
			      (lpbiOut->biCompression == BI_RGB)
			      )
			     );

      if (!info->bUsesCodec && !info->bUsesRender)
	    return (MMRESULT)ICERR_BADFORMAT;

      /* SLIB expects first pixel to be top line */
      info->lpbiOut->biHeight=-info->lpbiOut->biHeight;
    }
	info->bDecompressBegun = TRUE;
    _SlibDebug(_VERBOSE_, ScDebugPrintf("Out ICH263DecompressBegin\n") );
    return ICERR_OK;
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressGetFormat
**
**  FUNCTIONAL_DESCRIPTION:
**	Get the recommended decompressed format of the codec
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressGetFormat(H26XINFO *info,
                                            LPBITMAPINFOHEADER lpbiIn,
                                            LPBITMAPINFOHEADER lpbiOut)
{

    _SlibDebug(_DEBUG_, ScDebugPrintf("In ICH263DecompressGetFormat\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS) &&
        (!_ICH263CheckFlags(info, ICMODE_QUERY)))
      return((MMRESULT)ICERR_BADHANDLE);

    if (lpbiIn == NULL)
      return((MMRESULT)ICERR_BADPARAM);

    if (lpbiOut == NULL)
        return (sizeof(BITMAPINFOHEADER));

    _SlibDebug(_DEBUG_,
		ScDebugPrintf("lpbiOut is being filled in DecompressGetFormat\n") );
    bcopy(&__defaultDecompresslpbiOut, lpbiOut, sizeof(BITMAPINFOHEADER));
    lpbiOut->biWidth = lpbiIn->biWidth;
    lpbiOut->biHeight= lpbiIn->biHeight;
    /*
    ** Return biSizeImage = 1.5 * width * height to let application know
    ** how big the image buffers must be when passed to ICAddBuffer.
    ** Internal to the codec, they are used to first store a YUV image,
    ** then the ICM layer renders it (if rendered data is what's called for
    */
    lpbiOut->biSizeImage = CalcImageSize(lpbiOut->biCompression,
                           lpbiOut->biWidth, lpbiOut->biHeight, lpbiOut->biBitCount);
    if (lpbiOut->biCompression==BI_RGB && lpbiOut->biBitCount==8)
      lpbiOut->biClrUsed = 1<<lpbiOut->biBitCount;
    else
      lpbiOut->biClrUsed = 0;
    return(0);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressGetSize
**
**  FUNCTIONAL_DESCRIPTION:
**
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressGetSize(H26XINFO *info,
                                 LPBITMAPINFOHEADER lpbiIn,
								 LPBITMAPINFOHEADER lpbiOut)
{
    return(MMRESULT)(ICERR_UNSUPPORTED);
}



/*
**++
**  FUNCTIONAL_NAME: ICH263DecompressEnd
**
**  FUNCTIONAL_DESCRIPTION:
**	End the decompression process
**
**  FORMAL PARAMETERS:
**	driverID
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263DecompressEnd(H26XINFO *info)
{
    _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263DecompressEnd\n") );

    if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
	return (MMRESULT)ICERR_BADHANDLE;

	if (info->Sh)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibClose()\n") );
	  SlibClose(info->Sh);
      info->Sh=NULL;
      _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (after SlibClose)\n", SlibMemUsed()) );
    }
    info->bDecompressBegun = FALSE;
    return(ICERR_OK);
}



MMRESULT ICH263GetDefaultQuality(H26XINFO *info, DWORD * quality)
{
  *quality = H26X_DEFAULT_QUALITY;
  return((MMRESULT)ICERR_OK);
}

MMRESULT ICH263GetQuality(H26XINFO *info, DWORD * quality)
{
  *quality = info->dwQuality;
  return((MMRESULT)ICERR_OK);
}

MMRESULT ICH263SetQuality(H26XINFO *info, DWORD quality)
{
  if (quality>10000)
    info->dwQuality=10000;
  else
    info->dwQuality=quality;
  // SlibSetParamInt(info->Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOQUALITY,
  //                info->dwQuality/100);
  return((MMRESULT)ICERR_OK);
}


/*
**++
**  FUNCTIONAL_NAME: ICH263Compress
**
**  FUNCTIONAL_DESCRIPTION:
**	Compress a frame
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/
MMRESULT ICH263Compress(H26XINFO *info,
                            ICCOMPRESS  *icCompress,
                            DWORD   dwSize)
{
    MMRESULT            status;
    LPBITMAPINFOHEADER  lpbiIn;
    LPBITMAPINFOHEADER  lpbiOut;
    LPVOID              lpIn;
    LPVOID              lpOut;
	SlibHandle_t		Sh;
    int			        compBytes, reqBytes;
    DWORD               newQi, newQp;
    RTPTRAILER_t       *ptrail;
    BOOL                keyframe=icCompress->dwFlags&ICCOMPRESS_KEYFRAME;

    if (icCompress->dwFrameSize==0 || icCompress->dwFrameSize>64*1024)
      reqBytes = info->dwMaxCompBytes;
    else
      reqBytes = icCompress->dwFrameSize;

#ifdef H261_SUPPORT
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH261Compress() FrameNum=%d FrameSize=%d Quality=%d reqBytes=%d\n",
                        icCompress->lFrameNum, icCompress->dwFrameSize, icCompress->dwQuality,
                        reqBytes) );
#else
    _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() FrameNum=%d FrameSize=%d Quality=%d reqBytes=%d\n",
                        icCompress->lFrameNum, icCompress->dwFrameSize, icCompress->dwQuality,
                        reqBytes) );
#endif

    if ((!_ICH263CheckFlags(info, ICMODE_COMPRESS))
		|| (!_ICH263CheckFlags(info, ICMODE_FASTCOMPRESS)))
      return (MMRESULT)ICERR_BADHANDLE;

    status = ICERR_OK;

    lpbiIn = icCompress->lpbiInput;
    lpbiOut = icCompress->lpbiOutput;
    lpIn = icCompress->lpInput;
    lpOut = icCompress->lpOutput;
    lpbiOut->biSizeImage = 0;

	
	/* Synchronized SLIB SYSTEMS calls */
	Sh = info->Sh;
compress_frame:
    newQi=newQp=(((10000-icCompress->dwQuality)*30)/10000)+1;
    if (info->dwRTP!=EC_RTP_MODE_OFF) /* if using RTP, check Quant limits */
    {
      if (newQi<info->dwMaxQi)
        newQi=info->dwMaxQi;
      if (newQp<info->dwMaxQp)
        newQp=info->dwMaxQp;
    }
    if (info->dwQi!=newQi)
    {
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTI, newQi);
      info->dwQi=newQi;
    }
    if (info->dwQp!=newQp)
    {
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_QUANTP, newQp);
      info->dwQp=newQp;
    }
	if (keyframe)
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() I Frame: Qi=%d\n", newQi) );
      SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FRAMETYPE, FRAME_TYPE_I);
    }
    else
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() P Frame: Qp=%d\n", newQp) );
    }
#ifdef HANDLE_EXCEPTIONS
  __try {
#endif /* HANDLE_EXCEPTIONS */
      status=SlibErrorWriting; /* in case there's an exception */
	  status = SlibWriteVideo (Sh, SLIB_STREAM_MAINVIDEO, lpIn, lpbiIn->biSizeImage);
#ifdef HANDLE_EXCEPTIONS
    } __finally {
#endif /* HANDLE_EXCEPTIONS */
      if (status != SlibErrorNone)
      {
#if defined(EXCEPTION_MESSAGES) && defined(H263_SUPPORT)
        // MessageBox(NULL, "Error in H263 SlibWriteVideo", "Warning", MB_OK);
#elif defined(EXCEPTION_MESSAGES)
        // MessageBox(NULL, "Error in H261 SlibWriteVideo", "Warning", MB_OK);
#endif
        /* make the next frame a key */
        SlibSetParamInt(Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_FRAMETYPE, FRAME_TYPE_I);
        status=(MMRESULT)ICERR_INTERNAL;
	    goto bail;
      }
#ifdef HANDLE_EXCEPTIONS
    }
#endif /* HANDLE_EXCEPTIONS */
	info->lastFrameNum=icCompress->lFrameNum;
    compBytes=reqBytes;
	status = SlibReadData(Sh, SLIB_STREAM_ALL, &lpOut, &compBytes, NULL);
	if (status != SlibErrorNone)
    {
      info->lastCompBytes=0;
      status=(MMRESULT)ICERR_BADSIZE;
	  goto bail;
    }
    else /* check the amount of compressed data */
    {
      int extraBytes=0;
      /* query to see if any more data is left in the codec
       * if there is then the quant step was too high, reduce it and try again
       */
	  status = SlibReadData(Sh, SLIB_STREAM_ALL, NULL, &extraBytes, NULL);
      if (extraBytes)
      {
        _SlibDebug(_VERBOSE_, ScDebugPrintf("ICH263Compress() Too much data: extraBytes=%d\n",
                    extraBytes) );
        if (newQi==31 && newQp==31) /* can't compress to any fewer bytes */
          return((MMRESULT)ICERR_BADSIZE);
        info->dwMaxQi+=1+(newQi/4); /* decrease I frame quality */
        if (info->dwMaxQi>31) info->dwMaxQi=31;
        info->dwMaxQp+=1+(newQp/4); /* decrease P frame quality */
        if (info->dwMaxQp>31) info->dwMaxQp=31;
        /* empty out the compressed data */
        SlibSeekEx(Sh, SLIB_STREAM_ALL, SLIB_SEEK_RESET, 0, 0, NULL);
        /* try to compress again, but make it a key frame */
        keyframe=TRUE;
        goto compress_frame;
      }
      /* we have compressed data less than or equal to request size */
      info->lastCompBytes=compBytes;
      lpbiOut->biSizeImage = compBytes;
      status = ICERR_OK;
    }
    if (info->dwRTP!=EC_RTP_MODE_OFF) /* RTP is on */
    {
      ptrail=(RTPTRAILER_t *)((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
      /* check for valid RTP trailer */
      if (compBytes<sizeof(RTPTRAILER_t) || ptrail->dwUniqueCode!=H26X_FOURCC)
        return((MMRESULT)ICERR_INTERNAL);
    }
    if (icCompress->dwFlags&ICCOMPRESS_KEYFRAME) /* I frame */
    {
      if (compBytes>(reqBytes>>2))
      {
        info->dwMaxQi+=1+(newQi>>2); /* decrease quality */
        if (info->dwMaxQi>31) info->dwMaxQi=31;
      }
      else if (newQi==info->dwMaxQi && compBytes<=(reqBytes>>2) && info->dwMaxQi>0)
        info->dwMaxQi--;  /* increase quality */
    }
    else /* P frame */
    {
      if (compBytes>(reqBytes>>1))
      {
        info->dwMaxQp+=1+(newQp>>2); /* decrease max quality */
        if (info->dwMaxQp>31) info->dwMaxQp=31;
        /* also decrease I quality, since P limits are based on I limits */
        info->dwMaxQi+=1+(newQi>>2);
        if (info->dwMaxQi>31) info->dwMaxQi=31;
      }
      else if (newQp==info->dwMaxQp && compBytes<(reqBytes>>1)
                && info->dwMaxQp>(info->dwMaxQi+3)/2)
        info->dwMaxQp--;  /* increase max quality */
    }
#ifdef H261_SUPPORT
    _SlibDebug(_VERBOSE_||_WARN_,
      ScDebugPrintf("ICH261Compress(%c) lpOut=%p reqBytes=%d compBytes=%d Qi=%d Qp=%d MaxQi=%d MaxQp=%d\n",
                          (icCompress->dwFlags&ICCOMPRESS_KEYFRAME)?'I':'P',
                          lpOut, reqBytes, compBytes,
                          newQi, newQp, info->dwMaxQi, info->dwMaxQp) );
#else
    _SlibDebug(_VERBOSE_||_WARN_,
      ScDebugPrintf("ICH263Compress(%c) lpOut=%p reqBytes=%d compBytes=%d Qi=%d Qp=%d MaxQi=%d MaxQp=%d\n",
                          (icCompress->dwFlags&ICCOMPRESS_KEYFRAME)?'I':'P',
                          lpOut, reqBytes, compBytes,
                          newQi, newQp, info->dwMaxQi, info->dwMaxQp) );
#endif
    _SlibDebug(_DEBUG_,
    {
      RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
        ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
      ScDebugPrintf("  Trailer: \n"
                    "           dwVersion=%d\n"
                    "           dwFlags=0x%04X\n"
                    "           dwUniqueCode=%c%c%c%c\n"
                    "           dwCompressedSize=%d\n"
                    "           dwNumberOfPackets=%d\n"
                    "           SourceFormat=%d\n"
                    "           TR=%d TRB=%d DBQ=%d\n",
	                ptrail->dwVersion,
                    ptrail->dwFlags,
	                ptrail->dwUniqueCode&0xFF, (ptrail->dwUniqueCode>>8)&0xFF,
	                (ptrail->dwUniqueCode>>16)&0xFF, (ptrail->dwUniqueCode>>24)&0xFF,
	                 ptrail->dwCompressedSize,
	                 ptrail->dwNumberOfPackets,
	                 ptrail->SourceFormat,
	                 ptrail->TR,ptrail->TRB,ptrail->DBQ);
    }
    ); /* _SlibDebug */
#ifdef H261_SUPPORT
    _SlibDebug((_DEBUG_ || _WARN_) && (info->dwRTP!=EC_RTP_MODE_OFF),
      {
        RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
              ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
        SvH261BITSTREAM_INFO *pinfo;
        BOOL rtperror=FALSE;
        unsigned int i;
        pinfo=(SvH261BITSTREAM_INFO *)((unsigned char *)ptrail
                                    -(ptrail->dwNumberOfPackets*16));
        if (ptrail->dwNumberOfPackets==0 || pinfo[0].dwBitOffset!=0)
        {
          // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
          rtperror=TRUE;
        }
        /* check for sequential BitOffsets */
        for (i=1; i<ptrail->dwNumberOfPackets; i++)
          if (pinfo[i-1].dwBitOffset>=pinfo[i].dwBitOffset)
          {
            // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
            rtperror=TRUE;
            break;
          }
        if (pinfo[ptrail->dwNumberOfPackets-1].dwBitOffset>ptrail->dwCompressedSize*8)
        {
          // MessageBox(NULL, "Critical Error in H.261", "Warning", MB_OK);
          rtperror=TRUE;
        }
        if (_DEBUG_ || rtperror)
        {
          if (ptrail->dwNumberOfPackets>64*2)
            ptrail->dwNumberOfPackets=32;
          for (i=0; i<ptrail->dwNumberOfPackets; i++)
          {
            ScDebugPrintf("  H261 Packet %2d: dwFlag=0x%04X  dwBitOffset=%d\n"
                          "                   MBAP=%d Quant=%d\n"
                          "                   GOBN=%d HMV=%d VMV=%d\n",
                    i, pinfo[i].dwFlag, pinfo[i].dwBitOffset,
                       pinfo[i].MBAP, pinfo[i].Quant,
                       pinfo[i].GOBN, pinfo[i].HMV, pinfo[i].VMV);
          }
        }
      }
    ); /* _SlibDebug */
#else /* H263 */
    _SlibDebug((_DEBUG_ || _WARN_) && (info->dwRTP!=EC_RTP_MODE_OFF),
      {
        RTPTRAILER_t *ptrail=(RTPTRAILER_t *)
              ((unsigned char *)lpOut+compBytes-sizeof(RTPTRAILER_t));
        SvH263BITSTREAM_INFO *pinfo;
        BOOL rtperror=FALSE;
        unsigned int i;
        pinfo=(SvH263BITSTREAM_INFO *)((unsigned char *)ptrail
                                    -(ptrail->dwNumberOfPackets*16));
        if (ptrail->dwNumberOfPackets==0 || pinfo[0].dwBitOffset!=0)
        {
          // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
          rtperror=TRUE;
        }
        /* check for sequential BitOffsets */
        for (i=1; i<ptrail->dwNumberOfPackets; i++)
          if (pinfo[i-1].dwBitOffset>=pinfo[i].dwBitOffset)
          {
            // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
            rtperror=TRUE;
            break;
          }
        if (pinfo[ptrail->dwNumberOfPackets-1].dwBitOffset>ptrail->dwCompressedSize*8)
        {
          // MessageBox(NULL, "Critical Error in H.263", "Warning", MB_OK);
          rtperror=TRUE;
        }
        if (_DEBUG_ || rtperror)
        {
          if (ptrail->dwNumberOfPackets>64*2)
            ptrail->dwNumberOfPackets=32;
          for (i=0; i<ptrail->dwNumberOfPackets; i++)
          {
            ScDebugPrintf("  H263 Packet %2d: dwFlag=0x%04X  dwBitOffset=%d Mode=%d\n"
                          "                   MBA=%d Quant=%d\n"
                          "                   GOBN=%d HMV1=%d VMV1=%d HMV2=%d VMV2=%d\n",
                    i, pinfo[i].dwFlag, pinfo[i].dwBitOffset, pinfo[i].Mode,
                       pinfo[i].MBA, pinfo[i].Quant,
                       pinfo[i].GOBN, pinfo[i].HMV1, pinfo[i].VMV1,
                       pinfo[i].HMV2, pinfo[i].VMV2);
          }
        }
      }
    ); /* _SlibDebug */
#endif
bail:
    return status;
}
/*
**++
**  FUNCTIONAL_NAME: ICH263Decompress
**
**  FUNCTIONAL_DESCRIPTION:
**	Open the Software CODEC
**
**  FORMAL PARAMETERS:
**	driverID
**      lpbiIn          input BITMAPINFOHEADER
**      lpbiOut         output BITMAPINFOHEADER
**
**  RETURN VALUE:
**
**  COMMENTS:
**
**  DESIGN:
**
**/

MMRESULT ICH263Decompress(H26XINFO *info,
                          ICDECOMPRESS  *icDecompress,
                          DWORD dwSize)

{
  MMRESULT            result=(MMRESULT)ICERR_OK;
  LPBITMAPINFOHEADER  lpbiIn;
  LPBITMAPINFOHEADER  lpbiOut;
  LPVOID              lpIn;
  LPVOID              lpOut;
  SlibHandle_t		Sh;
  SlibStatus_t		status;
#ifdef H261_SUPPORT
  SlibType_t stype = SLIB_TYPE_H261;
#else
  SlibType_t stype = SLIB_TYPE_H263;
#endif

  _SlibDebug(_VERBOSE_, ScDebugPrintf("In ICH263Decompress lpIn is %d\n",lpIn) );

  if (!_ICH263CheckFlags(info, ICMODE_DECOMPRESS))
    return((MMRESULT)ICERR_BADHANDLE);

  lpIn = icDecompress->lpInput;
  lpOut = icDecompress->lpOutput;

  lpbiIn = icDecompress->lpbiInput;
  lpbiOut = icDecompress->lpbiOutput;
  if (!info->bDecompressBegun &&
	  (result = ICH263DecompressBegin(info, lpbiIn, lpbiOut))!=ICERR_OK)
    return(result);

  if (icDecompress->dwFlags & ICDECOMPRESS_HURRYUP)
    return((MMRESULT)ICERR_OK);

  info->lpbiIn->biSizeImage = lpbiIn->biSizeImage;
  info->lpbiOut->biClrImportant = lpbiOut->biClrImportant;
  info->lpbiOut->biSizeImage = lpbiOut->biSizeImage; // they don't set it

  lpbiIn=info->lpbiIn;
  lpbiOut=info->lpbiOut;
  if (!info->Sh)
  {
    _SlibDebug(_VERBOSE_, ScDebugPrintf("SlibMemUsed = %ld (before SlibOpen)\n", SlibMemUsed()) );
    status = SlibOpenSync (&Sh, SLIB_MODE_DECOMPRESS, &stype, lpIn, icDecompress->lpbiInput->biSizeImage);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_HEIGHT, lpbiOut->biHeight);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_WIDTH, lpbiOut->biWidth);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOFORMAT, lpbiOut->biCompression);
    SlibSetParamInt (Sh, SLIB_STREAM_MAINVIDEO, SLIB_PARAM_VIDEOBITS, lpbiOut->biBitCount);
    info->Sh = Sh;
    _SlibDebug(_WARN_ && status!=SlibErrorNone,
       ScDebugPrintf("ICH263Decompress() SlibOpenSync: %s\n", SlibGetErrorText(status)) );
  }
  else
  {
    DWORD dwPadding=0xFFFFFFFF;
	status=SlibAddBuffer (info->Sh, SLIB_DATA_COMPRESSED, lpIn, icDecompress->lpbiInput->biSizeImage);
    _SlibDebug(_WARN_ && status!=SlibErrorNone,
       ScDebugPrintf("ICH263Decompress() SlibAddBuffer(%p, %d): %s\n",
	       lpIn, lpbiIn->biSizeImage, SlibGetErrorText(status)) );
    /* Add some padding bits to the end because the codecs try to peek
     * forward past the very last bits of the buffer
     */
	status=SlibAddBuffer (info->Sh, SLIB_DATA_COMPRESSED, (char *)&dwPadding, sizeof(DWORD));
  }
  if (status==SlibErrorNone)
  {
#ifdef HANDLE_EXCEPTIONS
  __try {
#endif /* HANDLE_EXCEPTIONS */
    status = SlibErrorReading;  /* in case there's an exception */
    status = SlibReadVideo(info->Sh, SLIB_STREAM_MAINVIDEO, &lpOut, &lpbiOut->biSizeImage);
#ifdef HANDLE_EXCEPTIONS
    } __finally {
#endif /* HANDLE_EXCEPTIONS */
	  if (status!=SlibErrorNone)
      {
        _SlibDebug(_WARN_ && status!=SlibErrorNone,
         ScDebugPrintf("ICH263Decompress() SlibReadVideo: %s\n", SlibGetErrorText(status)) );
	    status=(MMRESULT)ICERR_BADFORMAT;
	  }
      else
        status=(MMRESULT)ICERR_OK;
      goto bail;
#ifdef HANDLE_EXCEPTIONS
    }
#endif /* HANDLE_EXCEPTIONS */
  }
  else
    status=(MMRESULT)ICERR_BADFORMAT;
bail:
  return(status);
}





/*
 * This routine just nulls out the pValidHandles
 * pointer so that no lingering threads will be
 * able to use it. It's only called at dll
 * shutdown on NT.
 */

int TerminateH263()
{
    pValidHandles = NULL;
	return 0;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\mpeg.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: mpeg.h,v $
 * Revision 1.1.4.2  1996/11/08  21:50:41  Hans_Graves
 * 	Added MPEG1_AUDIO_FRAME_SIZE
 * 	[1996/11/08  21:17:44  Hans_Graves]
 *
 * Revision 1.1.2.4  1996/01/11  16:17:24  Hans_Graves
 * 	Added more MPEG II System codes
 * 	[1996/01/11  16:14:20  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/08  16:41:24  Hans_Graves
 * 	Added MPEG II codes
 * 	[1996/01/08  15:44:39  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/11/06  18:47:43  Hans_Graves
 * 	First time under SLIB
 * 	[1995/11/06  18:34:29  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _MPEG_H_
#define _MPEG_H_

#define MPEG1_AUDIO_FRAME_SIZE       1152

/************** MPEG I parsing definitions **************/
#define MPEG_SYNC_WORD               0xfff
#define MPEG_SYNC_WORD_LEN           12
#define MPEG_PACK_START              0x000001ba
#define MPEG_PACK_START_LEN          32
#define MPEG_SYSTEM_HEADER_START     0x000001bb
#define MPEG_SYSTEM_HEADER_START_LEN 32
#define MPEG_SEQ_HEAD                0x000001b3
#define MPEG_SEQ_HEAD_LEN            32
#define MPEG_EXT_START               0x000001b5
#define MPEG_EXT_START_LEN           32
#define MPEG_PICTURE_START           0x00000100
#define MPEG_GROUP_START             0x000001b8
#define MPEG_VIDEO_PACKET            0x000001e0
#define MPEG_AUDIO_PACKET            0x000001c0

#define MPEG_START_CODE              0x000001
#define MPEG_START_CODE_LEN          24

#define MPEG_PICTURE_START_BASE      0x00
#define MPEG_PACK_START_BASE         0xba
#define MPEG_SYSTEM_HEADER_BASE      0xbb
#define MPEG_PRIVATE_STREAM1_BASE    0xbd
#define MPEG_PADDING_STREAM_BASE     0xbe
#define MPEG_PRIVATE_STREAM2_BASE    0xbf
#define MPEG_AUDIO_STREAM_BASE       0xc0
#define MPEG_VIDEO_STREAM_BASE       0xe0
#define MPEG_USER_DATA_BASE          0xb2
#define MPEG_SEQ_HEAD_BASE           0xb3
#define MPEG_EXT_START_BASE          0xb5
#define MPEG_SEQ_END_BASE            0xb7
#define MPEG_GROUP_START_BASE        0xb8
#define MPEG_END_BASE                0xb9

#define MPEG_AUDIO_STREAM_START      0xC0
#define MPEG_AUDIO_STREAM_END        0xDF
#define MPEG_VIDEO_STREAM_START      0xE0
#define MPEG_VIDEO_STREAM_END        0xEF

/************** MPEG II parsing definitions **************/
/* stream id's - all reserved in MPEG I */
#define MPEG_PROGRAM_STREAM           0xBC
#define MPEG_ECM_STREAM               0xF0
#define MPEG_EMM_STREAM               0xF1
#define MPEG_DSM_CC_STREAM            0xF1
#define MPEG_13522_STREAM             0xF2
#define MPEG_PROGRAM_DIRECTORY_STREAM 0xFF

/* program id's */
#define MPEG_PID_NULL                 0x1FFF

/* transport codes */
#define MPEG_TSYNC_CODE         0x47
#define MPEG_TSYNC_CODE_LEN     8

/* extension start code IDs */
#define MPEG_SEQ_ID       1
#define MPEG_DISP_ID      2
#define MPEG_QUANT_ID     3
#define MPEG_SEQSCAL_ID   5
#define MPEG_PANSCAN_ID   7
#define MPEG_CODING_ID    8
#define MPEG_SPATSCAL_ID  9
#define MPEG_TEMPSCAL_ID 10

/* picture coding type */
#define MPEG_I_TYPE 1
#define MPEG_P_TYPE 2
#define MPEG_B_TYPE 3
#define MPEG_D_TYPE 4

#endif /* _MPEG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\me2.c ===
/* File: sv_h263_me2.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif


/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector imformation in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_421_1(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
                             int y_curr, int xoff, int yoff, int seek_dist,
                             H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{
  int Min_FRAME[5];
  H263_MotionVector MVFrame[5];
  unsigned char *act_block,*aa,*ii;
  unsigned char *search_area, *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  int h_lenby2,v_lenby2;
  unsigned char *act_block_subs2, *search_area_subs2;
  int xlevel1,ylevel1;
  int level1_x_curr,level1_y_curr;
  int level0_x_curr,level0_y_curr;

  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
    xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif
    /* in case xoff or yoff is odd */
    xoff= 2 * (xoff>>1);
    yoff= 2 * (yoff>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;
#if 1
  act_block   = curr + x_curr + y_curr * H263Info->pels;
  search_area = prev + ilow   + jlow * lx;
#else
  act_block = svH263LoadArea(curr, x_curr, y_curr, 16, 16, H263Info->pels);
  search_area = svH263LoadArea(prev, ilow, jlow, h_length, v_length, lx);
#endif

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
#if 1
  act_block_subs2   = H263Info->block_subs2;
  search_area_subs2 = H263Info->srch_area_subs2;
  sv_H263LdSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels, act_block_subs2, 8);
  sv_H263LdSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx,
	                                  search_area_subs2, H263_SRCH_RANGE);
#else
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);
#endif

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVFrame[k].x = 0;
    MVFrame[k].y = 0;
    MVFrame[k].x_half = 0;
    MVFrame[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
#ifndef USE_C
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
  Min_FRAME[0] = sv_H263PEr8_init_S(ii,act_block_subs2,H263_SRCH_RANGE,8);
#else
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
  Min_FRAME[0] = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,INT_MAX);
#endif

  MVFrame[0].x = (short)xoff;
  MVFrame[0].y = (short)yoff;

  /*** +-7 search on subsampled images: ***
   *** three-step +-4, +-2, +-1         ***/

  /* first step: +- 4 */
  /* sxylevel1 = 4; */
  i = x_curr + xoff - 8;
  j = y_curr + yoff - 8;
  for (k = 0; k < 32; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
#ifndef USE_C
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#else
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#endif
      if (sad < Min_FRAME[0]) {
	    MVFrame[0].x = i - x_curr;
	    MVFrame[0].y = j - y_curr;
	    Min_FRAME[0] = sad;
      }
    }
    if      (k<8)  i+=2;
    else if (k<16) j+=2;
    else if (k<24) i-=2;
    else           j-=2;
  }

  /* motion vectors after step1 - level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* second step: +- 2 */
  /* sxylevel1 = 2; */

  level1_x_curr = x_curr + xlevel1;
  level1_y_curr = y_curr + ylevel1;

  i = level1_x_curr - 4;
  j = level1_y_curr - 4;

  for (k = 0; k < 16; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
#ifndef USE_C
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#else
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#endif
      if (sad < Min_FRAME[0]) {
	    MVFrame[0].x = i - x_curr;
	    MVFrame[0].y = j - y_curr;
	    Min_FRAME[0] = sad;
      }
    }
    if      (k<4)  i+=2;
    else if (k<8)  j+=2;
    else if (k<12) i-=2;
    else           j-=2;
  }

  /* motion vectors after step2 - level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* third step: +- 1 */
  /*  sxylevel1 = 1; */

  level1_x_curr = x_curr + xlevel1;
  level1_y_curr = y_curr + ylevel1;

  i = level1_x_curr - 2;
  j = level1_y_curr - 2;

  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
#ifndef USE_C
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#else
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME[0]);
#endif
      if (sad < Min_FRAME[0]) {
	    MVFrame[0].x = i - x_curr;
	    MVFrame[0].y = j - y_curr;
 	    Min_FRAME[0] = sad;
      }
    }
    if      (k<2) i+=2;
    else if (k<4) j+=2;
    else if (k<6) i-=2;
    else          j-=2;
  }

  /* motion vectors after step3 - level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVFrame[0].x = 0;
  MVFrame[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */
#ifndef USE_C
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263PError16x16_S(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#else
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263SADMacroblock(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#endif
  }
  else {
    /* the zero vector is within search_area */
#ifndef USE_C
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }

  if (xoff == 0 && yoff == 0) {
    Min_FRAME[0] = *SAD_0;
    MVFrame[0].x = 0;
    MVFrame[0].y = 0;
  }

  if (xlevel1 == 0 && ylevel1 == 0) {
    Min_FRAME[0] = *SAD_0;
    MVFrame[0].x = 0;
    MVFrame[0].y = 0;
  }
  else {
#ifndef USE_C
    ii = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*lx;
    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]) ;
#else
    ii = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*lx;
    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]) ;
#endif
    if (sad < Min_FRAME[0]) {
      MVFrame[0].x = (short)xlevel1;
      MVFrame[0].y = (short)ylevel1;
      Min_FRAME[0] = sad;
    }
  }

  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /*** +-1 search on full-resolution images ***/
  level0_x_curr = x_curr + xlevel1;
  level0_y_curr = y_curr + ylevel1;
  /*  sxylevel0=1; */
  i = level0_x_curr - 1;
  j = level0_y_curr - 1;
  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 16x16 integer pel MV */
#ifndef USE_C
      ii = search_area + (i-ilow) + (j-jlow)*lx;
      sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]) ;
#else
      ii = search_area + (i-ilow) + (j-jlow)*lx;
      sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]) ;
#endif
	  if (sad < Min_FRAME[0]) {
	    MVFrame[0].x = i - x_curr;
	    MVFrame[0].y = j - y_curr;
	    Min_FRAME[0] = sad;
	  }
    }
    if      (k<2) i++;
    else if (k<4) j++;
    else if (k<6) i--;
    else          j--;
  }


  if (H263Info->advanced) {

    xvec = MVFrame[0].x;
    yvec = MVFrame[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

#if 1
    adv_search_area = prev + adv_ilow + adv_jlow * lx;
#else
    adv_search_area = svH263LoadArea(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);
#endif

    for (block = 0; block < 4; block++) {
#ifndef USE_C
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*lx;
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263PError8x8_S(ii,aa,lx,H263Info->pels,Min_FRAME[block+1]);
#else
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*lx;
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263MySADBlock(ii,aa,lx,H263Info->pels,Min_FRAME[block+1]);
#endif
      MVFrame[block+1].x = MVFrame[0].x;
      MVFrame[block+1].y = MVFrame[0].y;
    }

    /* Spiral Full search */
    for (l = 1; l <= sxy; l++) {
      i = adv_x_curr - l;
      j = adv_y_curr - l;
      for (k = 0; k < 8*l; k++) {
	    if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	      /* 8x8 integer pel MVs */
	      for (block = 0; block < 4; block++) {
#ifndef USE_C
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*lx;
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263PError8x8_S(ii, aa, lx, H263Info->pels, Min_FRAME[block+1]);
#else
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*lx;
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263MySADBlock(ii, aa, lx, H263Info->pels, Min_FRAME[block+1]);
#endif
	        if (sad < Min_FRAME[block+1]) {
	          MVFrame[block+1].x = i - x_curr;
	          MVFrame[block+1].y = j - y_curr;
	          Min_FRAME[block+1] = sad;
	        }
	      }	
	    }
	    if      (k<2*l) i++;
	    else if (k<4*l) j++;
	    else if (k<6*l) i--;
	    else            j--;
      }
    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVFrame[0].x;
    MV[0][j][i]->y = MVFrame[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVFrame[k].x;
      MV[k][j][i]->y = MVFrame[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

#if 0
  ScFree(act_block);
  ScFree(search_area);
  ScFree(act_block_subs2);
  ScFree(search_area_subs2);
  if (H263Info->advanced)  ScFree(adv_search_area);
#endif

  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\me3.c ===
/* File: sv_h263_me3.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#define THREEBYEIGHT .375
#define THREEBYFOUR .75
#define MINUSONEBYEIGHT -0.125

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_7_polint(SvH263CompressInfo_t *H263Info,
                                unsigned char *curr, unsigned char *prev, int x_curr,
                                int y_curr, int xoff, int yoff, int seek_dist,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{

  int Min_FRAME[5];
  H263_MotionVector MVFrame[5];
  unsigned char *aa,*ii;
  unsigned char *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  unsigned char *act_block_subs2, *search_area_subs2, *adv_search_area_subs2;
  int h_lenby2,v_lenby2,adv_h_lenby2,adv_v_lenby2;
  int xlevel1,ylevel1,sxylevel1;
  int xlevel1_block[4], ylevel1_block[4];
  /*
  int level0_x_curr,level0_y_curr,sxylevel0;
*/
  int start_x, start_y, stop_x, stop_y, new_x, new_y;
  int AE[5];
  H263_Point search[5];
  int p1,p2,p3,p4;
  int AE_minx, AE_miny, min_posx, min_posy;


  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
    xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif

    /* in case xoff or yoff is odd */
    xoff= 2 * ((xoff)>>1);
    yoff= 2 * ((yoff)>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }


  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVFrame[k].x = 0;
    MVFrame[k].y = 0;
    MVFrame[k].x_half = 0;
    MVFrame[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 + ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*h_lenby2;
#ifdef USE_C
  Min_FRAME[0] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
  Min_FRAME[0] = sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#endif
  MVFrame[0].x = (short)xoff;
  MVFrame[0].y = (short)yoff;

  /*** Spiral search (+-7) on subsampled images ***/

  sxylevel1 = (sxy-1)>>1;

  for (l = 1; l <= sxylevel1; l++) {
    i = x_curr + xoff - 2*l;
    j = y_curr + yoff - 2*l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	sad = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
	sad = sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#endif
	if (sad < Min_FRAME[0]) {
	  MVFrame[0].x = i - x_curr;
	  MVFrame[0].y = j - y_curr;
	  Min_FRAME[0] = sad;
	}

      }
      if      (k<2*l) i+=2;
      else if (k<4*l) j+=2;
      else if (k<6*l) i-=2;
      else            j-=2;
    }
  }

  /* motion vectors after level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVFrame[0].x = 0;
  MVFrame[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */

    zero_area = sv_H263LoadSubs2Area(prev, x_curr, y_curr, 8, 8, lx);
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */

    ii = search_area_subs2 + ((x_curr-ilow)>>1) + ((y_curr-jlow)>>1)*h_lenby2;
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif	
  }

  /*** +-1 search on full-resolution images done by polynomial interpolation ***/

  start_x = -1;
  stop_x = 1;
  start_y = -1;
  stop_y = 1;

  new_x = x_curr + xlevel1;
  new_y = y_curr + ylevel1;

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= (ilow+1))
      start_x = 0;
    if ((new_y) <= (jlow+1))
      start_y = 0;
    if ((new_x) >= (ihigh-1))
      stop_x = 0;
    if ((new_y) >= (jhigh-1))
      stop_y = 0;
  }

 /*     1     */
 /*   2 0 3   */
 /*     4     */

  search[0].x = 0; 		search[0].y = 0;
  search[1].x = 0; 		search[1].y = (short)start_y;
  search[2].x = (short)start_x;     	search[2].y = 0;
  search[3].x = (short)stop_x;     	search[3].y = 0;
  search[4].x = 0; 	       	search[4].y = (short)stop_y;

  for (l = 0; l < 5 ; l++) {
    AE[l] = INT_MAX;
    i =  new_x + 2*search[l].x;
    j =  new_y + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	AE[l] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, INT_MAX);
#else
	AE[l] = sv_H263PEr8_init_S(ii, act_block_subs2, h_lenby2, 8);
#endif
  }

  /* 1D polynomial interpolation along x and y respectively */

  AE_minx = AE[0];
  min_posx = 0;

  p2 = (int)( THREEBYEIGHT * (double) AE[2]
            + THREEBYFOUR * (double) AE[0]
            + MINUSONEBYEIGHT * (double) AE[3]);

  if (p2<AE_minx) {
    AE_minx = p2;
    min_posx = 2;
  }

  p3 = (int)(MINUSONEBYEIGHT * (double) AE[2]
           + THREEBYFOUR * (double) AE[0]
           + THREEBYEIGHT * (double) AE[3]);

  if (p3<AE_minx) {
    AE_minx = p3;
    min_posx = 3;
  }

  AE_miny = AE[0];
  min_posy = 0;

  p1 = (int)(THREEBYEIGHT * (double) AE[1]
           + THREEBYFOUR * (double) AE[0]
           + MINUSONEBYEIGHT * (double) AE[4]);

  if (p1<AE_miny) {
    AE_miny = p1;
    min_posy = 1;
  }

  p4 = (int)(MINUSONEBYEIGHT * (double) AE[1]
           + THREEBYFOUR * (double) AE[0]
           + THREEBYEIGHT * (double) AE[4]);

  if (p4<AE_miny) {
    AE_miny = p4;
    min_posy = 4;
  }

  /* Store optimal values */
  Min_FRAME[0] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
  MVFrame[0].x = new_x + search[min_posx].x - x_curr;
  MVFrame[0].y = new_y + search[min_posy].y - y_curr;

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVFrame[0].x;
    yvec = MVFrame[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

/*  BUG
    adv_h_lenby2 = (adv_h_length-1)>>1;
    adv_v_lenby2 = (adv_v_length-1)>>1;
*/
    adv_h_lenby2 = (adv_h_length)>>1;
    adv_v_lenby2 = (adv_v_length)>>1;
/*  must load entire macroblock
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_lenby2, adv_v_lenby2, lx);
*/
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area_subs2 + ((adv_x_curr-adv_ilow)>>1) + ((block&1)<<2) +
	(((adv_y_curr-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
      aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_lenby2,Min_FRAME[block+1]);
*/
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_length,Min_FRAME[block+1]);

      MVFrame[block+1].x = MVFrame[0].x;
      MVFrame[block+1].y = MVFrame[0].y;
    }

    /* Spiral search */
    sxylevel1 = (sxy-1)>>1;

    for (l = 1; l <= sxylevel1; l++) {
      i = adv_x_curr - 2*l;
      j = adv_y_curr - 2*l;
      for (k = 0; k < 8*l; k++) {
	if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	  /* 8x8 integer pel MVs */
	  for (block = 0; block < 4; block++) {
	    ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	      (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	    aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, Min_FRAME[block+1]);
*/
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_length, Min_FRAME[block+1]);

	    if (sad < Min_FRAME[block+1]) {
	      MVFrame[block+1].x = i - x_curr;
	      MVFrame[block+1].y = j - y_curr;
	      Min_FRAME[block+1] = sad;
	    }
	  }
	
	}
	if      (k<2*l) i++;
	else if (k<4*l) j++;
	else if (k<6*l) i--;
	else            j--;
      }
    }

    for (block = 0; block < 4; block++) {
      xlevel1_block[block] = MVFrame[block+1].x;
      ylevel1_block[block] = MVFrame[block+1].y;

      /* reset */
      Min_FRAME[block+1] = INT_MAX;
      MVFrame[block+1].x = 0;
      MVFrame[block+1].y = 0;
    }

    /* +-1 search on full resolution on full-resolution images */
    /* by polynomial interpolation */

    for (block = 0; block < 4; block++) {
      start_x = -1;
      stop_x = 1;
      start_y = -1;
      stop_y = 1;

      adv_x_curr = x_curr + xlevel1_block[block];
      adv_y_curr = y_curr + ylevel1_block[block];

      /*     1     */
      /*   2 0 3   */
      /*     4     */

      search[0].x = 0; 		search[0].y = 0;
      search[1].x = 0; 		search[1].y = (short)start_y;
      search[2].x = (short)start_x;    search[2].y = 0;
      search[3].x = (short)stop_x;     search[3].y = 0;
      search[4].x = 0; 	       	search[4].y = (short)stop_y;

      for (l = 0; l < 5 ; l++) {
	AE[l] = INT_MAX;
	i =  adv_x_curr + 2*search[l].x;
	j =  adv_y_curr + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	  (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, INT_MAX);
*/
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_length, INT_MAX);
      }

      /* 1D polynomial interpolation along x and y respectively */

      AE_minx = AE[0];
      min_posx = 0;

      p2 = (int)(THREEBYEIGHT * (double) AE[2]
	           + THREEBYFOUR * (double) AE[0]
	           + MINUSONEBYEIGHT * (double) AE[3]);

      if (p2<AE_minx) {
	AE_minx = p2;
	min_posx = 2;
      }

      p3 = (int)(MINUSONEBYEIGHT * (double) AE[2]
	           + THREEBYFOUR * (double) AE[0]
	           + THREEBYEIGHT * (double) AE[3]);

      if (p3<AE_minx) {
	AE_minx = p3;
	min_posx = 3;
      }

      AE_miny = AE[0];
      min_posy = 0;

      p1 = (int)(THREEBYEIGHT * (double) AE[1]
	           + THREEBYFOUR * (double) AE[0]
	           + MINUSONEBYEIGHT * (double) AE[4]);

      if (p1<AE_miny) {
	AE_miny = p1;
	min_posy = 1;
      }

      p4 = (int)(MINUSONEBYEIGHT * (double) AE[1]
	           + THREEBYFOUR * (double) AE[0]
	           + THREEBYEIGHT * (double) AE[4]);

      if (p4<AE_miny) {
	AE_miny = p4;
	min_posy = 4;
      }

      /* Store optimal values */
      Min_FRAME[block+1] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
      MVFrame[block+1].x = adv_x_curr + search[min_posx].x - x_curr;
      MVFrame[block+1].y = adv_y_curr + search[min_posy].y - y_curr;

    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVFrame[0].x;
    MV[0][j][i]->y = MVFrame[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVFrame[k].x;
      MV[k][j][i]->y = MVFrame[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

  ScFree(act_block_subs2);
  ScFree(search_area_subs2);

  if (H263Info->advanced)
    ScFree(adv_search_area);
  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\motion.c ===
/* File: sv_h263_motion.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"
/*
#define USE_C
*/
#ifndef USE_C
#include "perr.h"
#endif

static unsigned char *sv_H263LoadArea(unsigned char *im, int x, int y,
                                     int x_size, int y_size, int lx);
/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector imformation in MB changed
 *
 ***********************************************************************/


void sv_H263MotionEstimation(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
		      int y_curr, int xoff, int yoff, int seek_dist,
		      H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{

  int Min_FRAME[5];
  H263_MotionVector MVframe[5];
  unsigned char *act_block,*aa,*ii;
  unsigned char *search_area, *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
    xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;
#if 1
  act_block   = curr + x_curr + y_curr * H263Info->pels;
  search_area = prev + ilow + jlow * lx;
#else
  act_block = sv_H263LoadArea(curr, x_curr, y_curr, 16, 16, H263Info->pels);
  search_area = sv_H263LoadArea(prev, ilow, jlow, h_length, v_length, lx);
#endif

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVframe[k].x = 0;
    MVframe[k].y = 0;
    MVframe[k].x_half = 0;
    MVframe[k].y_half = 0;
  }

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */
#ifndef USE_C
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263PError16x16_S(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    zero_area = prev + x_curr + y_curr * lx;
    *SAD_0 = sv_H263SADMacroblock(zero_area, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }
  else {
    /* the zero vector is within search_area */
#ifndef USE_C
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*lx;
    *SAD_0 = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }

  if (xoff == 0 && yoff == 0) {
    Min_FRAME[0] = *SAD_0;
    MVframe[0].x = 0;
    MVframe[0].y = 0;
  }
  else {
#ifndef USE_C
    ii = search_area + (x_curr+xoff-ilow) + (y_curr+yoff-jlow)*lx;
    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
    ii = search_area + (x_curr+xoff-ilow) + (y_curr+yoff-jlow)*lx;
    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
    MVframe[0].x = (short)xoff;
    MVframe[0].y = (short)yoff;
  }
  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /* Spiral search */
  for (l = 1; l <= sxy; l++) {
    i = x_curr + xoff - l;
    j = y_curr + yoff - l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
  	    /* 16x16 integer pel MV */
#ifndef USE_C
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263PError16x16_S(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#else
	    ii = search_area + (i-ilow) + (j-jlow)*lx;
	    sad = sv_H263SADMacroblock(ii, act_block, lx, H263Info->pels, Min_FRAME[0]);
#endif
	    if (sad < Min_FRAME[0]) {
	      MVframe[0].x = i - x_curr;
	      MVframe[0].y = j - y_curr;
	      Min_FRAME[0] = sad;
	    }

      }
      if      (k<2*l) i++;
      else if (k<4*l) j++;
      else if (k<6*l) i--;
      else            j--;
    }
  }

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVframe[0].x;
    yvec = MVframe[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

    adv_search_area = sv_H263LoadArea(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area + (adv_x_curr-adv_ilow) + ((block&1)<<3) +
	       (adv_y_curr-adv_jlow + ((block&2)<<2) )*adv_h_length;
#ifndef USE_C
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263PError8x8_S(ii,aa,adv_h_length,H263Info->pels,Min_FRAME[block+1]);
#else
      aa = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
      Min_FRAME[block+1] = sv_H263MySADBlock(ii,aa,adv_h_length,H263Info->pels,Min_FRAME[block+1]);
#endif
      MVframe[block+1].x = MVframe[0].x;
      MVframe[block+1].y = MVframe[0].y;
    }

    /* Spiral search */
    for (l = 1; l <= sxy; l++) {
      i = adv_x_curr - l;
      j = adv_y_curr - l;
      for (k = 0; k < 8*l; k++) {
	    if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	      /* 8x8 integer pel MVs */
	      for (block = 0; block < 4; block++) {
	        ii = adv_search_area + (i-adv_ilow) + ((block&1)<<3) +
	             (j-adv_jlow + ((block&2)<<2) )*adv_h_length;
#ifndef USE_C
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263PError8x8_S(ii, aa, adv_h_length, H263Info->pels, Min_FRAME[block+1]);
#else
	        aa  = act_block + ((block&1)<<3) + ((block&2)<<2)*H263Info->pels;
            sad = sv_H263MySADBlock(ii, aa, adv_h_length, H263Info->pels, Min_FRAME[block+1]);
#endif
	        if (sad < Min_FRAME[block+1]) {
	          MVframe[block+1].x = i - x_curr;
	          MVframe[block+1].y = j - y_curr;
	          Min_FRAME[block+1] = sad;
	        }
	      }	
	    }
	    if      (k<2*l) i++;
	    else if (k<4*l) j++;
	    else if (k<6*l) i--;
	    else            j--;
      }
    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVframe[0].x;
    MV[0][j][i]->y = MVframe[0].y;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVframe[k].x;
      MV[k][j][i]->y = MVframe[k].y;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }
#if 0
  ScFree(act_block);
  ScFree(search_area);
#endif
  if (H263Info->advanced) ScFree(adv_search_area);
  return;
}

/**********************************************************************
 *
 *	Name:		LoadArea
 *	Description:    fills array with a square of image-data
 *	
 *	Input:	       pointer to image and position, x and y size
 *	Returns:       pointer to area
 *	Side effects:  memory allocated to array
 *
 ***********************************************************************/
#if 1
static unsigned char *sv_H263LoadArea(unsigned char *im, int x, int y,
                                     int x_size, int y_size, int lx)
{
  unsigned char *res = (unsigned char *)ScAlloc(sizeof(char)*x_size*y_size);
  register unsigned char *in, *out;

  in = im + (y*lx) + x;
  out = res;

  while (y_size--) {
    memcpy(out,in,x_size) ;
	in += lx ;
	out += x_size;
  };
  return res;
}
#else
static unsigned char *svH263LoadArea(unsigned char *im, int x, int y,
                                     int x_size, int y_size, int lx)
{
  unsigned char *res = (unsigned char *)ScAlloc(sizeof(char)*x_size*y_size);
  unsigned char *in;
  unsigned char *out;
  int i = x_size;
  int j = y_size;

  in = im + (y*lx) + x;
  out = res;

  while (j--) {
    while (i--)
      *out++ = *in++;
    i = x_size;
    in += lx - x_size;
  };
  return res;
}
#endif

/**********************************************************************
 *
 *	Name:		SAD_Macroblock
 *	Description:    fast way to find the SAD of one vector
 *	
 *	Input:	        pointers to search_area and current block,
 *                      Min_F1/F2/FR
 *	Returns:        sad_f1/f2
 *	Side effects:
 *
 ***********************************************************************/

#ifdef USE_C /* replaced by sv_H263PError16x16_S */
int sv_H263SADMacroblock(unsigned char *ii, unsigned char *act_block,
                               int h_length, int lx2, int Min_FRAME)
{
  unsigned char *kk;
  int i;
  int sad = 0;

  kk = act_block;
  i = 16;
  while (i--) {
    sad += (abs(*ii     - *kk     ) +abs(*(ii+1 ) - *(kk+1) )
  	    +abs(*(ii+2) - *(kk+2) ) +abs(*(ii+3 ) - *(kk+3) )
	    +abs(*(ii+4) - *(kk+4) ) +abs(*(ii+5 ) - *(kk+5) )
	    +abs(*(ii+6) - *(kk+6) ) +abs(*(ii+7 ) - *(kk+7) )
	    +abs(*(ii+8) - *(kk+8) ) +abs(*(ii+9 ) - *(kk+9) )
	    +abs(*(ii+10)- *(kk+10)) +abs(*(ii+11) - *(kk+11))
	    +abs(*(ii+12)- *(kk+12)) +abs(*(ii+13) - *(kk+13))
	    +abs(*(ii+14)- *(kk+14)) +abs(*(ii+15) - *(kk+15)) );

    ii += h_length;
    kk += lx2;

    if (sad > Min_FRAME)
      return INT_MAX;
  }

  return sad;
}
#endif

#ifdef USE_C /* replaced by  sv_H263PError8x8_S */
int svH263SAD_Block(unsigned char *ii, unsigned char *act_block,
	                int h_length, int min_sofar)
{
  unsigned char *kk;
  int i;
  int sad = 0;

  kk = act_block;
  i = 8;
  while (i--) {
    sad += (abs(*ii  - *kk     ) +abs(*(ii+1 ) - *(kk+1) )
	    +abs(*(ii+2) - *(kk+2) ) +abs(*(ii+3 ) - *(kk+3) )
	    +abs(*(ii+4) - *(kk+4) ) +abs(*(ii+5 ) - *(kk+5) )
	    +abs(*(ii+6) - *(kk+6) ) +abs(*(ii+7 ) - *(kk+7) ));

    ii += h_length;
    kk += 16;
    if (sad > min_sofar)
      return INT_MAX;
  }

  return sad;
}
#endif

int sv_H263BError16x16_C(unsigned char *ii, unsigned char *aa, unsigned char *bb,
                         int width, int min_sofar)
{
  unsigned char *ll, *kk;

  int i, sad = 0;

  kk = aa;
  ll = bb;
  i = 16;
  while (i--) {
    sad += (abs(*ii  - ((*kk    + *ll    )>>1)) +
	    abs(*(ii+1)  - ((*(kk+1)+ *(ll+1))>>1)) +
	    abs(*(ii+2)  - ((*(kk+2)+ *(ll+2))>>1)) +
	    abs(*(ii+3)  - ((*(kk+3)+ *(ll+3))>>1)) +
	    abs(*(ii+4)  - ((*(kk+4)+ *(ll+4))>>1)) +
	    abs(*(ii+5)  - ((*(kk+5)+ *(ll+5))>>1)) +
	    abs(*(ii+6)  - ((*(kk+6)+ *(ll+6))>>1)) +
	    abs(*(ii+7)  - ((*(kk+7)+ *(ll+7))>>1)) +
	    abs(*(ii+8)  - ((*(kk+8)+ *(ll+8))>>1)) +
	    abs(*(ii+9)  - ((*(kk+9)+ *(ll+9))>>1)) +
	    abs(*(ii+10) - ((*(kk+10)+ *(ll+10))>>1)) +
	    abs(*(ii+11) - ((*(kk+11)+ *(ll+11))>>1)) +
	    abs(*(ii+12) - ((*(kk+12)+ *(ll+12))>>1)) +
	    abs(*(ii+13) - ((*(kk+13)+ *(ll+13))>>1)) +
	    abs(*(ii+14) - ((*(kk+14)+ *(ll+14))>>1)) +
	    abs(*(ii+15) - ((*(kk+15)+ *(ll+15))>>1)));

    ii += width;
    kk += width;
    ll += width;
    if (sad > min_sofar)
      return INT_MAX;
  }
  return sad;
}

/**********************************************************************
 *
 *	Name:		FindMB
 *	Description:	Picks out one MB from picture
 *	
 *	Input:		position of MB to pick out,
 *			pointer to frame data, empty 16x16 array	
 *	Returns:	
 *	Side effects:	fills array with MB data
 *
 ***********************************************************************/

void sv_H263FindMB(SvH263CompressInfo_t *H263Info, int x, int y, unsigned char *image, short MB[16][16])
{
#ifndef USE_C
  sv_H263CtoI16_S((image + y*H263Info->pels + x), &(MB[0][0]), H263Info->pels);
#else
  register int m, n;

 int xdiff = H263Info->pels - H263_MB_SIZE;
  unsigned char *in;
  short *out;

  in = image + y*H263Info->pels + x;
  out = &(MB[0][0]);

  m = H263_MB_SIZE;
  while (m--) {
    n = H263_MB_SIZE;
    while (n--) *out++ = *in++;
    in += xdiff ;
  };
#endif
}

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/

void sv_H263FastME(SvH263CompressInfo_t *H263Info,
                   unsigned char *curr, unsigned char *prev, int x_curr,
		           int y_curr, int xoff, int yoff, int seek_dist,
		           short *MVx, short *MVy, short *MVer, int *SAD_0)
{
  int Min_FRAME;
  H263_MotionVector MVframe;
  int sxy,i,k,j;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  unsigned char *act_block,*ii,*search_area, *zero_area = NULL;
  int h_lenby2,v_lenby2;
  unsigned char *act_block_subs2, *search_area_subs2;
  int xmax,ymax,sad;
  int xlevel1,ylevel1;
  int level1_x_curr,level1_y_curr;
  int level0_x_curr,level0_y_curr;

  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;

  sxy = mmin(15, sxy);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (ilow<0) ilow = 0;
  if (ihigh>xmax-16) ihigh = xmax-16;
  if (jlow<0) jlow = 0;
  if (jhigh>ymax-16) jhigh = ymax-16;

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  act_block   = curr + x_curr +  y_curr * H263Info->pels;
  search_area = prev + ilow   +  jlow   * H263Info->pels;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2   = H263Info->block_subs2;
  search_area_subs2 = H263Info->srch_area_subs2;
  sv_H263LdSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels, act_block_subs2, 8);
  sv_H263LdSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, H263Info->pels,
	                                  search_area_subs2, H263_SRCH_RANGE);

  Min_FRAME = INT_MAX;
  MVframe.x = 0;
  MVframe.y = 0;
  MVframe.x_half = 0;
  MVframe.y_half = 0;

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 +
	      ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*H263_SRCH_RANGE;
#ifndef USE_C
  Min_FRAME = sv_H263PEr8_init_S(ii,act_block_subs2,H263_SRCH_RANGE,8);
#else
  Min_FRAME = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,INT_MAX);
#endif
  MVframe.x = (short)xoff;
  MVframe.y = (short)yoff;

  /*** +-7 search on subsampled images: ***
   *** three-step +-4, +-2, +-1         ***/

  /* first step: +- 4 */
  /* sxylevel1 = 4; */
  i = x_curr + xoff - 8;
  j = y_curr + yoff - 8;
  for (k = 0; k < 32; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1)*H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
      }
    }
    if      (k<8)  i+=2;
    else if (k<16) j+=2;
    else if (k<24) i-=2;
    else           j-=2;
  }

  /* second step: +- 2 */
  /* sxylevel1 = 2; */
  level1_x_curr = x_curr + MVframe.x;
  level1_y_curr = y_curr + MVframe.y;

  i = level1_x_curr - 4;
  j = level1_y_curr - 4;

  for (k = 0; k < 16; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
      }
    }
    if      (k<4)  i+=2;
    else if (k<8)  j+=2;
    else if (k<12) i-=2;
    else           j-=2;
  }

  /* third step: +- 1 */
  /*  sxylevel1 = 1; */
  level1_x_curr = x_curr + MVframe.x;
  level1_y_curr = y_curr + MVframe.y;

  i = level1_x_curr - 2;
  j = level1_y_curr - 2;

  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 8x8 integer pel MV */
      ii  = search_area_subs2+((i-ilow)>>1) + ((j-jlow)>>1) * H263_SRCH_RANGE;
#ifndef USE_C
      sad = sv_H263PError8x8_S(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#else
      sad = sv_H263MySADBlock(ii,act_block_subs2,H263_SRCH_RANGE,8,Min_FRAME);
#endif
      if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
 	    Min_FRAME = sad;
      }
    }
    if      (k<2) i+=2;
    else if (k<4) j+=2;
    else if (k<6) i-=2;
    else          j-=2;
  }

  /* motion vectors after step3 - level1 */
  xlevel1=MVframe.x;
  ylevel1=MVframe.y;

  /* reset */
  Min_FRAME = INT_MAX;
  MVframe.x = 0;
  MVframe.y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */
    zero_area = sv_H263LoadArea(prev, x_curr, y_curr, 16, 16, H263Info->pels);

#ifndef USE_C
    *SAD_0 = sv_H263PError16x16_S(zero_area, act_block, 16, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#else
    *SAD_0 = sv_H263SADMacroblock(zero_area, act_block, 16, H263Info->pels, INT_MAX) -
             H263_PREF_NULL_VEC;
#endif

    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */
    ii = search_area + (x_curr-ilow) + (y_curr-jlow)*H263Info->pels;

#ifndef USE_C
    *SAD_0 = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, INT_MAX) -
       H263_PREF_NULL_VEC;
#endif
  }

  if (xoff == 0 && yoff == 0) {
    Min_FRAME = *SAD_0;
    MVframe.x = 0;
    MVframe.y = 0;
  }

  if (xlevel1 == 0 && ylevel1 == 0) {
    Min_FRAME = *SAD_0;
    MVframe.x = 0;
    MVframe.y = 0;
  }
  else {
    ii  = search_area + (x_curr+xlevel1-ilow) + (y_curr+ylevel1-jlow)*H263Info->pels;

#ifndef USE_C
    sad = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#else
    sad = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#endif
    if (sad < Min_FRAME) {
      MVframe.x = (short)xlevel1;
      MVframe.y = (short)ylevel1;
      Min_FRAME = sad;
    }
  }

  /* NB: if xoff or yoff != 0, the Extended MV Range is used. If we
     allow the zero vector to be chosen prior to the half pel search
     in this case, the half pel search might lead to a
     non-transmittable vector (on the wrong side of zero). If SAD_0
     turns out to be the best SAD, the zero-vector will be chosen
     after half pel search instead.  The zero-vector can be
     transmitted in all modes, no matter what the MV predictor is */

  /*** +-1 search on full-resolution images ***/
  level0_x_curr = x_curr + xlevel1;
  level0_y_curr = y_curr + ylevel1;
  /*  sxylevel0=1; */
  i = level0_x_curr - 1;
  j = level0_y_curr - 1;
  for (k = 0; k < 8; k++) {
    if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {
      /* 16x16 integer pel MV */
      ii  = search_area + (i-ilow) + (j-jlow)*H263Info->pels;
#ifndef USE_C
      sad = sv_H263PError16x16_S(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#else
      sad = sv_H263SADMacroblock(ii, act_block, H263Info->pels, H263Info->pels, Min_FRAME) ;
#endif
	  if (sad < Min_FRAME) {
	    MVframe.x = i - x_curr;
	    MVframe.y = j - y_curr;
	    Min_FRAME = sad;
	  }
    }
    if      (k<2) i++;
    else if (k<4) j++;
    else if (k<6) i--;
    else          j--;
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  *MVx  = MVframe.x;
  *MVy  = MVframe.y;
  *MVer = (short)Min_FRAME;

  return;
}


#ifdef USE_C
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int lx2, int min_sofar)
{
/*
  return sv_H263PError8x8_S(ii,act_block,h_length,8,min_sofar);
*/
  int i;
  int sad = 0;
  unsigned char *kk;

  kk = act_block;
  i = 8;
  while (i--) {
    sad += (abs(*ii     - *kk     ) +
		    abs(*(ii+1 ) - *(kk+1) ) +
	        abs(*(ii+2) - *(kk+2) ) +
			abs(*(ii+3 ) - *(kk+3) ) +
	        abs(*(ii+4) - *(kk+4) ) +
		    abs(*(ii+5 ) - *(kk+5) ) +
	        abs(*(ii+6) - *(kk+6) ) +
			abs(*(ii+7 ) - *(kk+7) ));

    ii += h_length;
    kk += lx2;
    if (sad > min_sofar)
      return INT_MAX;
  }
  return sad;
}

#endif

/**********************************************************************
 *
 *	Name:		LoadArea
 *	Description:    fills array with a square of image-data
 *	
 *	Input:	       pointer to image and position, x and y size
 *	Returns:       pointer to area
 *	Side effects:  memory allocated to array
 *
 *
 ***********************************************************************/

void sv_H263LdSubs2Area(unsigned char *im, int x, int y,
  	                    int x_size, int y_size, int lx,
						unsigned char *srch_area, int area_length)
{
  register unsigned char *in, *out;
  register int incrs1, incrs2, i;

  x = ((x+1)>>1) << 1;  /* subsampled images always correspond to pixels*/
  y = ((y+1)>>1) << 1;  /* of even coordinates in the original image */

  in = im + (y*lx) + x;
  out = srch_area;

#ifdef USE_C
  incrs1 = (lx - x_size) << 1;
  incrs2 = area_length - x_size;
  while (y_size--) {
    i = x_size;
    while (i--) {
      *out++ = *in;
      in+=2;
    }
    in += incrs1;
    out += incrs2;
  };
#else
  if(area_length == 8){
    sv_H263Subsamp8_S(in, out, y_size, (lx << 1)) ;
  }
  else {
    incrs1 = (lx - x_size) << 1;
    incrs2 = area_length - x_size;
    while (y_size--) {
      i = x_size;
      while (i--) {
        *out++ = *in;
        in+=2;
      }
      in += incrs1;
	  out += incrs2;
    };
  }
#endif

  return ;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\mres.c ===
/* File: sv_h263_mres.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"

static void hfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols) ;
static void hfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols) ;
static void vfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols) ;
static void vfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols) ;
 static void lowpass(unsigned char *img, unsigned char *lp, 
	                 int rows, int cols, int ntaps) ;
 static void reduce(unsigned char *img, unsigned char *red, 
	                int rows, int cols, int ntaps) ;
 static void hpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode) ;
static void Expand(unsigned char *img, unsigned char *exp, 
	               int rows, int cols, char mode, int ntaps) ;
 static void gaussp(unsigned char *img, unsigned char **pyr, 
	                int depth, int rows, int cols, int ntaps) ;
 static unsigned char **palloc(int depth, int rows, int cols) ;
 static H263_PictImage **PictPyr(H263_PictImage *img, int depth, int rows, 
                                            int cols, int ntaps); 
 static void expyr(unsigned char **pyr, unsigned char **filtd, 
	               int depth, int rows, int cols, 
				   char mode, int ntaps);
 static H263_PictImage **GaussFilt(H263_PictImage *img, int depth, int rows, 
	                                          int cols, int ntaps);



/******************************************************************
 * Function hfilt121
 * Filters img horizontally with a 1:2:1 filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void hfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j;

	pf = filtd;
	pimg = img;
	for(i=0; i<rows; i++) {
		/* Do first pixel */
		conv = (float)gain * ((float)*pimg * (float)2.0 + (float)*(pimg+1) * (float)2.0) / (float)4.0;
		tmp = (conv > 255 ? 255 : conv);
		*(pf++) = (unsigned char) (tmp < 0 ? 0 : tmp);
		pimg+=s;
		
		/* Do line */
		for(j=s; j<cols-1; j+=s, pimg+=s) {
			conv = (float) gain * ((float)*(pimg-1) + (float)*pimg * (float)2 + (float)*(pimg+1)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}

		/* Do last pixel if s equals one */
		if(s==1) {
			conv = (float)gain * ((float)*pimg * (float)2.0 + (float)*(pimg-1) * (float)2.0) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		    pimg+=s;
		}
	}
}

/******************************************************************
 * Function hfilt5
 * Filters img horizontally with a 5 tap gaussian filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void hfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j;

	pf = filtd;
	pimg = img;
	for(i=0; i<rows; i++) {
		/* Do line */
		for(j=0; j<cols; j+=s, pimg+=s) {
			if (j==0) 
				conv = (float)gain * ((float)6.0 * (float)*pimg + (float)8.0 * (float)*(pimg+1) + (float)2.0 * *(pimg+2)) / (float)16.0;
			else if(j==1)
				conv = (float)gain * ((float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1) + (float)2.0 * (float)*(pimg+2)) / (float)16.0;
			else if (j==cols-2)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-2) + (float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1)) / (float)16.0;
			else if (j==cols-1)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-2) + (float)8.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg) / (float)16.0;
			else
				conv = (float)gain * ((float)*(pimg-2) + (float)4.0 * (float)*(pimg-1) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+1) + (float)*(pimg+2)) / (float)16.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
	}
}


/******************************************************************
 * Function vfilt121
 * Filters img vertically with a 1:2:1 filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void vfilt121(unsigned char *img, unsigned char *filtd, 
					 unsigned char s, unsigned char gain, 
					 int rows, int cols)
{

	unsigned char *pimg, *pf;
	float tmp, conv;
	int i, j;

	pf = filtd;
	pimg = img;

	/* Do first line */
	for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float) *pimg * (float)2 + (float)2 * (float)*(pimg+cols)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
	}
	pimg+= (s-1)*cols;
		
	/* Do image center */
	for(i=s; i<rows-1; i+=s) { 
		for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float)*(pimg-cols) + (float)*pimg * (float)2 + (float)*(pimg+cols)) / (float)4.0;
			tmp = (conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
		pimg+=(s-1)*cols;
	}

	/* Do last line if s equals one */
	if(s==1) {
		for(j=0; j<cols; j++, pimg++) {
			conv = (float)gain * ((float)*pimg * (float)2 + (float)2 * (float)*(pimg-cols)) / (float)4.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
	}
}

/******************************************************************
 * Function vfilt5
 * Filters img vertically with a 5 tap gaussian filter, subsampling by s.
 * rows, cols are the dimensions of img
 *****************************************************************/
static void vfilt5(unsigned char *img, unsigned char *filtd, 
				   unsigned char s, unsigned char gain, 
				   int rows, int cols)
{

	unsigned char *pimg, *pf;
	float conv, tmp;
	int i, j, tcols;

	pf = filtd;
	pimg = img;
	tcols = 2*cols;

	for(i=0; i<rows; i+=s) {
		for(j=0; j<cols; j++, pimg++) {
			if (i==0)
				conv = (float)gain * ((float)6.0 * (float)*pimg + (float)8.0 * (float)*(pimg+cols) + (float)2.0 * (float)*(pimg+tcols)) / (float)16.0;
			else if (i==1) 
				conv = (float)gain * ((float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+cols) + (float)2.0 * (float)*(pimg+tcols)) / (float)16.0;
			else if (i==rows-2)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-tcols) + (float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + (float)4.0 * (float)*(pimg+cols)) / (float)16.0;
			else if (i==rows-1)
				conv = (float)gain * ((float)2.0 * (float)*(pimg-tcols) + (float)8.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg) / (float)16.0;
			else
				conv = (float)gain * (float)(*(pimg-tcols) + (float)4.0 * (float)*(pimg-cols) + (float)6.0 * (float)*pimg + 
					           (float)4.0 * (float)*(pimg+cols) + (float)*(pimg+tcols)) / (float)16.0;
			tmp = (float)(conv > 255 ? 255 : conv);
			*(pf++) = (unsigned char)(tmp < 0 ? 0 : tmp);
		}
		pimg+=(s-1)*cols;
	}
}

/******************************************************************
 * Function lowpass
 * 2D low pass filtering of img into lp. rows,
 * cols are the dimensions of img.
 ******************************************************************/
 static void lowpass(unsigned char *img, unsigned char *lp, 
	                 int rows, int cols, int ntaps)
 {
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(img, tmp, 1, 1, rows, cols);
		vfilt121(tmp, lp, 1, 1, rows, cols);
		break;
	case 5:
		hfilt5(img, tmp, 1, 1, rows, cols);
		vfilt5(tmp, lp, 1, 1, rows, cols);
		break;
	default:
		/* printf("Unknown filter in lowpass\n");
		  exit(0); */
	    ScFree(tmp);
        return;
	}
	ScFree(tmp);
 }


/******************************************************************
 * Function reduce
 * 2D low pass filtering and subsampling by two of img into red. rows,
 * cols are the dimensions of img.
 ******************************************************************/
 static void reduce(unsigned char *img, unsigned char *red, 
	                int rows, int cols, int ntaps)
 {
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols/2))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
        return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(img, tmp, 2, 1, rows, cols);
		vfilt121(tmp, red, 2, 1, rows, cols>>1);
		break;
	case 5:
		hfilt5(img, tmp, 2, 1, rows, cols);
		vfilt5(tmp, red, 2, 1, rows, cols>>1);
		break;
	default:
        /* 
		printf("Unknown filter in reduce\n");
		exit(0); */
	    ScFree(tmp);
        return;
	}

	ScFree(tmp);
 }

/******************************************************************
 * Function hpad
 * Zero-pads img horizontaly by the factor s. Returns zero-paded
 * image in zp. rows, cols are the dimensions of img
 *****************************************************************/
 static void hpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode)
 {
	 int i, j;
	 unsigned char *pf, *pimg, fill;

	 switch (mode) {
	 case 'l':
		 fill = 0;
		 break;
	 case 'c':
		 fill = 0;
		 break;
	 default:
         /*
		 printf("Unknown fill mode in hpad\n");
		 exit(0);
         */
         return;
	 }

	 pimg = img;
	 pf = zp;
	 for(i=0; i<rows; i++) 
		 for(j=0; j<cols*s; j++) 
			 *(pf++) = (j%s ? fill: *(pimg++));
 }

 /******************************************************************
 * Function vpad
 * Zero-pads img verticaly by the factor s. Returns zero-paded
 * image in zp. rows, cols are the dimensions of img
 *****************************************************************/
 static void vpad(unsigned char *img, unsigned char *zp, 
	              unsigned char s,
		          int rows, int cols, char mode)
 {
 	 int i, j;
	 unsigned char *pf, *pimg, fill;

	 switch (mode) {
	 case 'l':
		 fill = 0;
		 break;
	 case 'c':
		 fill = 0;
		 break;
	 default:
         /*
		 printf("Unknown fill mode in hpad\n");
		 exit(0); */
         return;
	 }

	 pimg = img;
	 pf = zp;
	 for(i=0; i<rows*s; i++) 
		 for(j=0; j<cols; j++) 
			 *(pf++) = (i%s ? fill: *(pimg++));
 }

 /******************************************************************
 * Function Expand
 * 2D upsampling by two and low pass filtering of img into exp. rows,
 * cols are the dimensions of img.
 ******************************************************************/
static void Expand(unsigned char *img, unsigned char *exp, 
	               int rows, int cols, char mode, int ntaps)
 {
	unsigned char *tmp, *tmp2, *tmp3;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols*2))) {
        /*
	  fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	hpad(img, tmp, 2, rows, cols, mode);
	if (!(tmp2 = (unsigned char *)ScAlloc(rows*cols*2))) {
	  /* fprintf(stderr,"ScAlloc failed\n");
	  exit(-1); */
      return;
	}
	switch (ntaps) {
	case 3:
		hfilt121(tmp, tmp2, 1, 2, rows, cols<<1);
		break;
	case 5:
		hfilt5(tmp, tmp2, 1, 2, rows, cols<<1);
		break;
	default:
        /*
		printf("Unknown filter in Expand\n");
		exit(0); */
        return;
	}

	if (!(tmp3 = (unsigned char *)ScAlloc(rows*cols*4))) {
        /*
	  fprintf(stderr,"ScAlloc failed\n");
	  exit(-1);
      */
      return;
	}
	vpad(tmp2, tmp3, 2, rows, cols<<1, mode);
	switch (ntaps) {
	case 3:
		vfilt121(tmp3, exp, 1, 2, rows<<1, cols<<1);
		break;
	case 5:
		vfilt5(tmp3, exp, 1, 2, rows<<1, cols<<1);
		break;
	default:
        /*
		printf("Unknown filter in Expand\n");
		exit(0); */
        return;
	}
	ScFree(tmp); ScFree(tmp2); ScFree(tmp3);
 }

 /*****************************************************************
 * Function gaussp
 * Builds a Gaussian pyramid of depth levels.
 *****************************************************************/
 static void gaussp(unsigned char *img, unsigned char **pyr, 
	                int depth, int rows, int cols, int ntaps)
 {
	int d;

	memcpy(pyr[0], img, rows*cols);
	for(d=1; d<depth; d++) {
		reduce(pyr[d-1], pyr[d], rows, cols, ntaps);
		rows /= 2;
		cols /= 2;
	}
 }

 /*****************************************************************
 * Function palloc
 * Allocates memory for a Gaussian pyramid of depth levels.
 * Higher resolution is level 0, with dimensions rows, cols.
 *****************************************************************/
 static unsigned char **palloc(int depth, int rows, int cols)
 {
	 int d;
	 unsigned char **pyr;
	 
	 if (!(pyr = (unsigned char **)ScAlloc(depth*sizeof(unsigned char *)))) {
       /*
	   fprintf(stderr,"ScAlloc failed\n");
	   exit(-1);
       */
       return(NULL);
	 }
	 for(d=0; d<depth; d++) {
		 if (!(pyr[d] = (unsigned char *)ScAlloc(rows*cols))) {
           /*
		   fprintf(stderr,"ScAlloc failed\n");
		   exit(-1);
           */
           return(NULL);
		 }
		 rows /= 2;
		 cols /= 2;
	 }
	 return pyr;
 }

 /****************************************************************
 * Function PictPyr
 * Buids a Gaussian pyramid of picture images with depth levels.
 ****************************************************************/
 static H263_PictImage **PictPyr(H263_PictImage *img, int depth, int rows, int cols, int ntaps) 
 {
	 unsigned char **tmp;
	 H263_PictImage ** PictPyr;
	 int d;

	 if (!(PictPyr = (H263_PictImage **)ScAlloc(depth*sizeof(H263_PictImage *)))) {
       /*
	   fprintf(stderr,"ScAlloc failed\n");
	   exit(-1);
       */
       return(NULL);
	 }
	 for(d=0; d< depth; d++) {
		 if ((PictPyr[d] = (H263_PictImage *)ScAlloc(sizeof(H263_PictImage))) == NULL) {
            /*
			fprintf(stderr,"Couldn't allocate (PictImage *)\n");
			exit(-1);
            */
            return(NULL);
		 }
	 }

	 /* Luminance */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->lum, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->lum = tmp[d];

	 rows/=2; cols/=2;
	 /* Chroma 1 */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cr, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->Cr = tmp[d];

 	 /* Chroma 2 */
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cb, tmp, depth, rows, cols, ntaps);
	 for(d=0; d<depth; d++) PictPyr[d]->Cb = tmp[d];

	 ScFree(tmp);
	 return PictPyr;
 }

 /*****************************************************************
 * Function expyr
 * Expands the pyramid channels to full resolution. rows, cols
 * are the dimensions of the expanded images, and the full resolution
 * layer of the pyramid.
 *****************************************************************/
 static void expyr(unsigned char **pyr, unsigned char **filtd, 
	               int depth, int rows, int cols, 
				   char mode, int ntaps)
 {
	 int d, l, r, c;

	 r = rows; c = cols;
	 memcpy(filtd[0], pyr[0], rows*cols);
	 for(d=1; d<depth; d++) {
		 r /= 2;
		 c /= 2;
		 for(l=d; l>0; l--) Expand(pyr[d], pyr[d-1], r, c, mode, ntaps);
		 memcpy(filtd[d], pyr[0], rows*cols);
	 }
 }

 /*****************************************************************
 * Function GaussFilt
 * Builds an array of successively more low pass filtered images
 * by constructing a gaussian pyramid and expanding each level
 * to full resolution
 *****************************************************************/
 static H263_PictImage **GaussFilt(H263_PictImage *img, int depth, int rows, 
	                                          int cols, int ntaps)
 {
	 int d;
	 H263_PictImage **PictFiltd;
	 unsigned char **tmp, **filtd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->lum, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'l', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->lum, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree(tmp);
	 ScFree(filtd);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cr, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'c', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->Cr, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree((void *) tmp);
	 ScFree((void *) filtd);

 	 /* Chroma 2 */
	 filtd = (unsigned char **) ScAlloc(depth*sizeof(unsigned char *));
	 for(d=0; d<depth; d++) filtd[d] = (unsigned char *) ScAlloc(rows * cols);
	 tmp = palloc(depth, rows, cols);
	 gaussp(img->Cb, tmp, depth, rows, cols, ntaps);
	 expyr(tmp, filtd, depth, rows, cols, 'c', ntaps);
 	 for(d=0; d<depth; d++) memcpy(PictFiltd[d]->Cb, filtd[d], rows*cols);
	 for(d=0; d<depth; d++) {
		 ScFree(tmp[d]);
		 ScFree(filtd[d]);
	 }
	 ScFree((void *) tmp);
	 ScFree((void *) filtd);

	 return PictFiltd;
 }

 /*****************************************************************
 * Function GaussLayers
 * Builds an array of successively more low pass filtered images
 *****************************************************************/
 H263_PictImage **svH263GaussLayers(H263_PictImage *img, int depth, int rows, int cols, int ntaps)
 {
	 int d;
	 H263_PictImage **PictFiltd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 memcpy(PictFiltd[0]->lum, img->lum, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->lum, PictFiltd[d]->lum, rows, cols, ntaps);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 memcpy(PictFiltd[0]->Cr, img->Cr, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->Cr, PictFiltd[d]->Cr, rows, cols, ntaps);

	 /* Chroma 2 */
	 memcpy(PictFiltd[0]->Cb, img->Cb, rows*cols);
	 for(d=1; d<depth; d++) 
		 lowpass(PictFiltd[d-1]->Cb, PictFiltd[d]->Cb, rows, cols, ntaps);


	 return PictFiltd;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\perr.h ===
extern unsigned int sv_H263PError16x16_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2, unsigned int error_limit);
extern unsigned int sv_H263PError8x8_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2, unsigned int error_limit);
extern unsigned int sv_H263PEr8_init_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2);
extern unsigned int sv_H263MyError4_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int error_limit);
extern void sv_H263Clp_S(short *fm, unsigned int count);
extern unsigned int sv_H263HalfPerr16_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2, unsigned int error_limit);
extern void sv_H263HalfPerr4_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2, unsigned int *error);
extern unsigned int sv_H263BError16x16_S(unsigned char *fb, unsigned char *ref1, unsigned char *ref2, unsigned int w);
extern void sv_H263ItoC16A_S(short *fm1, unsigned char *fm2, unsigned int pels);
extern void sv_H263ItoC8B_S(short *fm1, unsigned char *fm2, short *fm3, unsigned char *fm4, unsigned int halfpels);
extern void sv_H263Intrpolt_S(unsigned char *fm1, unsigned char *fm2, unsigned char *pt1, unsigned char *pt2, unsigned int width);
extern void sv_H263FilLumBlk_S(unsigned char *fma, short *fmb, int pels);
extern void sv_H263FilChmBlk_S(unsigned char *fma, short *fmb, unsigned char *fmc, short *fmd, int cpels);
extern unsigned int sv_H263Ierr16_S(short *fm1, short *fm2, unsigned int hi, unsigned int error_limiover_limit, unsigned int over_limit);
extern void sv_H263CtoI16_S(unsigned char *fm1, short *fm2, unsigned int pels);
extern unsigned short sv_H263VAR_S(unsigned char *fm1, unsigned int pels, unsigned int min_SAD);
extern void sv_H263Intpix16_S(unsigned char *fm1, short *fm2, unsigned int w1, unsigned int w2);
extern void sv_H263Add16Skp_S(unsigned char *fm1, short *fm2, unsigned int lx2);
extern void sv_H263Sub256_S(short *fm1, short *fm2, short *fm3, unsigned int count);
extern void sv_H263Sub16_S(unsigned char *fm1, short *fm2, short *fm3, unsigned int pels);
extern void sv_H263Sub8_S(unsigned char *fm1, short *fm2, short *fm3, unsigned int cpels);
extern void sv_H263FillX0_S(short *stream, short X0);
extern void sv_H263Subsamp8_S(unsigned char *fm1, unsigned char *fm2, unsigned int count, unsigned int lx);
extern unsigned int sv_H263HalfPerr8_S(unsigned char *framep1, unsigned char *framep2, unsigned int w1, unsigned int w2, unsigned int error_limit);
extern void sv_H263Add_S(unsigned char *fm1, short *fm2, unsigned char *fm3, short *fm4, unsigned int lx);
extern void sv_H263Avg4Add_S(unsigned char *fm1, unsigned char *fm2, unsigned char *fm3, unsigned char *fm4, short *fm5, unsigned int lx);
extern void sv_H263Avg2Add_S(unsigned char *fm1, unsigned char *fm2, short *fm3, unsigned char *fm4, unsigned char *fm5, short *fm6, unsigned int lx);
extern void sv_H263Cpy_S(unsigned char *fm1, short *fm2, unsigned char *fm3, short *fm4, unsigned int lx);
extern void sv_H263Avg4Cpy_S(unsigned char *fm1, unsigned char *fm2, unsigned char *fm3, unsigned char *fm4, short *fm5, unsigned int lx);
extern void sv_H263SubCpy_S(unsigned char *fm1, unsigned char *fm2, short *fm3, unsigned int cpels, unsigned int lx);
extern void sv_H263Sub2Cpy_S(unsigned char *fm1, unsigned char *fm2, unsigned char *fm3, short *fm4, unsigned int cpels, unsigned int lx);
extern void sv_H263Sub4Cpy_S(unsigned char *fm1, unsigned char *fm2, unsigned char *fm3, unsigned char *fm4, unsigned char *fm5, short *fm6, unsigned int cpels, unsigned int lx);
extern void sv_H263Add256_S(short *fm1, short *fm2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\morph.c ===
/* File: sv_h263_morph.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif


static unsigned char min5(unsigned char a, unsigned char b,
						  unsigned char c, unsigned char d, 
						  unsigned char e) ;
static unsigned char max5(unsigned char a, unsigned char b, 
						  unsigned char c, unsigned char d, 
						  unsigned char e) ;
static void ErodeX(unsigned char *image, unsigned char *out, 
				   int rows, int cols);
static void DilateX(unsigned char *image, unsigned char *out, 
					int rows, int cols);
static void ErodeS(unsigned char *image, unsigned char *out, 
				   int rows, int cols, int sr, int sc);
static void DilateS(unsigned char *image, unsigned char *out, 
					int rows, int cols, int sr, int sc);
static void Dilate(unsigned char *image, unsigned char *out, 
				   int rows, int cols, int sr, int sc);
static void Erode(unsigned char *image, unsigned char *out, 
				  int rows, int cols, int sr, int sc);
static void Open(unsigned char *image, unsigned char *out, 
				 int rows, int cols, int sr, int sc);


static void EdgeSelect(H263_PictImage *input, H263_PictImage *filtd, 
					   unsigned char *edge, 
					   H263_PictImage *output, int rows, int cols) ;


/*****************************************************************************************************
 * Function min5
 * Computes the min of the five elements
 ****************************************************************************************************/
static unsigned char min5(unsigned char a, unsigned char b,
						  unsigned char c, unsigned char d, unsigned char e) 
{
	unsigned char out;

	out = a;
	if(b<out) out=b;
	if(c<out) out=c;
	if(d<out) out=d;
	if(e<out) out=e;
	return out;
}

/*****************************************************************************************************
 * Function max5
 * Computes the max of the five elements
 ****************************************************************************************************/
static unsigned char max5(unsigned char a, unsigned char b, unsigned char c, 
						  unsigned char d, unsigned char e) 
{
	unsigned char out;

	out = a;
	if(b>out) out=b;
	if(c>out) out=c;
	if(d>out) out=d;
	if(e>out) out=e;
	return out;
}


/*****************************************************************************************************
 * Function: ErodeX 
 * Erosion of image (dimensions rows, cols) by a "+" structuring element
 ****************************************************************************************************/
static void ErodeX(unsigned char *image, unsigned char *out, int rows, int cols)
{
	int i, j;
	unsigned char *pi, *po;

	pi = image;
	po = out;

	/**** First line ****/ 
	/* First pixel */
	*po = min5(*pi, *pi, *(pi+1), *pi, *(pi+cols));
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = min5(*(pi-1), *pi, *(pi+1), *pi, *(pi+cols));
	}
	/* Last pixel */
	*po = min5(*(pi-1), *pi, *pi, *pi, *(pi+cols));
	pi++; po++;

	/**** Center lines ****/
	for(i=1; i<rows-1; i++) {
		/* First pixel */
		*po = min5(*pi, *pi, *(pi+1), *(pi-cols), *(pi+cols));
		pi++; po++;
		/* Center pixels */
		for(j=1; j<cols-1; j++, pi++, po++) {
			*po = min5(*(pi-1), *pi, *(pi+1), *(pi-cols), *(pi+cols));
		}
		/* Last pixel */
		*po = min5(*(pi-1), *pi, *pi, *(pi-cols), *(pi+cols));
		pi++; po++;
	}


	/**** Last line ****/ 
	/* First pixel */
	*po = min5(*pi, *pi, *(pi+1), *(pi-cols), *pi);
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = min5(*(pi-1), *pi, *(pi+1), *(pi-cols), *pi);
	}
	/* Last pixel */
	*po = min5(*(pi-1), *pi, *pi, *(pi-cols), *pi);
	pi++; po++;
}

/*****************************************************************************************************
 * Function: ErodeX 
 * Erosion of image (dimensions rows, cols) by a "+" structuring element
 ****************************************************************************************************/
static void DilateX(unsigned char *image, unsigned char *out, int rows, int cols)
{
	int i, j;
	unsigned char *pi, *po;

	pi = image;
	po = out;

	/**** First line ****/ 
	/* First pixel */
	*po = max5(*pi, *pi, *(pi+1), *pi, *(pi+cols));
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = max5(*(pi-1), *pi, *(pi+1), *pi, *(pi+cols));
	}
	/* Last pixel */
	*po = max5(*(pi-1), *pi, *pi, *pi, *(pi+cols));
	pi++; po++;

	/**** Center lines ****/
	for(i=1; i<rows-1; i++) {
		/* First pixel */
		*po = max5(*pi, *pi, *(pi+1), *(pi-cols), *(pi+cols));
		pi++; po++;
		/* Center pixels */
		for(j=1; j<cols-1; j++, pi++, po++) {
			*po = max5(*(pi-1), *pi, *(pi+1), *(pi-cols), *(pi+cols));
		}
		/* Last pixel */
		*po = max5(*(pi-1), *pi, *pi, *(pi-cols), *(pi+cols));
		pi++; po++;
	}


	/**** Last line ****/ 
	/* First pixel */
	*po = max5(*pi, *pi, *(pi+1), *(pi-cols), *pi);
	pi++; po++;
	/* Center pixels */
	for(j=1; j<cols-1; j++, pi++, po++) {
		*po = max5(*(pi-1), *pi, *(pi+1), *(pi-cols), *pi);
	}
	/* Last pixel */
	*po = max5(*(pi-1), *pi, *pi, *(pi-cols), *pi);
	pi++; po++;
}

/*****************************************************************************************************
 * Function: ErodeS 
 * Erosion of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void ErodeS(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int i, j, k, l, du, db, dl, dr, sr2, sc2;
	unsigned char *pi, *po, *pse, min, odd;

	odd = 1;
	if (!(sr%2) || !(sc%2)) odd = 0;

	sr2 = sr >> 1; sc2 = sc >> 1;

	pi = image;
	po = out;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, po++) {

			du = i>sr2 ? sr2 : i;
			dl = j > sc2 ? sc2 : j;

			if(odd) {
				db = (rows-1-i) > sr2 ? sr2 : (rows-1-i);
				dr = (cols-1-j) > sc2 ? sc2 : (cols-1-j);
			} else {
				db = (rows-1-i) > sr2-1 ? sr2-1 : (rows-1-i);
				dr = (cols-1-j) > sc2-1 ? sc2-1 : (cols-1-j);
			}


			min = 255;
			for(k=-du; k<=db; k++) {
			    pse = pi + k * cols - dl;
				for(l=-dl; l<=dr; l++, pse++) {
					min = *pse < min ? *pse : min;
				}
			}
			*po = min;
		}
	}
}

/*****************************************************************************************************
 * Function: DilateS
 * Dilation of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void DilateS(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int i, j, k, l, du, db, dl, dr, sr2, sc2;
	unsigned char *pi, *po, *pse, max, odd;

	odd = 1;
	if (!(sr%2) || !(sc%2)) odd = 0;

	sr2 = sr >> 1; sc2 = sc >> 1;

	pi = image;
	po = out;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, po++) {

			du = i>sr2 ? sr2 : i;
			dl = j > sc2 ? sc2 : j;

			if(odd) {
				db = (rows-1-i) > sr2 ? sr2 : (rows-1-i);
				dr = (cols-1-j) > sc2 ? sc2 : (cols-1-j);
			} else {
				db = (rows-1-i) > sr2-1 ? sr2-1 : (rows-1-i);
				dr = (cols-1-j) > sc2-1 ? sc2-1 : (cols-1-j);
			}

			max = 0;
			for(k=-du; k<=db; k++) {
				for(l=-dl; l<=dr; l++, pse++) {
					pse = pi + k * cols + l;
					max = (*pse > max) ? *pse : max;
				}
			}
			*po = max;
		}
	}
}

/*****************************************************************************************************
 * Function: Dilate
 * Dilation of image (dimensions rows, cols) by a structuring element of dimensions (sr, sc).
 * If (sr, sc) are positive the structuring element is positive. If they are -1 it is
 * the cross '+'
 ****************************************************************************************************/
static void Dilate(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	if(sr > 0 && sc > 0) {
		DilateS(image, out, rows, cols, sr, sc);
	} else if(sr==-1 && sc ==-1) {
		DilateX(image, out, rows, cols);
	} else {
		_SlibDebug(_WARN_, printf("Dilate() Unknown structuring element\n") );
		return;
	}
}

/*****************************************************************************************************
 * Function: Erode
 * Erosion of image (dimensions rows, cols) by a structuring element of dimensions (sr, sc).
 * If (sr, sc) are positive the structuring element is positive. If they are -1 it is
 * the cross '+'
 ****************************************************************************************************/
static void Erode(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	if(sr > 0 && sc > 0) {
		ErodeS(image, out, rows, cols, sr, sc);
	} else if(sr==-1 && sc ==-1) {
		ErodeX(image, out, rows, cols);
	} else {
		_SlibDebug(_WARN_, printf("Erode() Unknown structuring element\n") );
        return;
	}
}

/*****************************************************************************************************
 * Function: Open 
 * Opening of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
static void Open(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("Open() ScAlloc failed\n") );
      return;
	}
	Erode(image, tmp, rows, cols, sr, sc);
	Dilate(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: Close 
 * Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void Close(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("Close() ScAlloc failed\n") );
      return;
	}
	Dilate(image, tmp, rows, cols, sr, sc);
	Erode(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: OpenClose 
 * Open/Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void OpenClose(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("OpenClose() ScAlloc failed\n") );
      return;
	}
	Open(image, tmp, rows, cols, sr, sc);
	Close(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: CloseOpen 
 * Open/Closing of image (dimensions rows, cols) by a square structuring element of dimensions (sr, sc)
 ****************************************************************************************************/
void CloseOpen(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	unsigned char *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("CloseOpen() ScAlloc failed\n") );
      return;
	}
	Close(image, tmp, rows, cols, sr, sc);
	Open(tmp, out, rows, cols, sr, sc);
	ScFree(tmp);
}


/*****************************************************************************************************
 * Function: GeoDilate 
 * Geodesic dilation of size one of image with respect to reference
 ****************************************************************************************************/
void GeoDilate(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, j;
	unsigned char *pi, *pr, *pt, *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("GeoDilate() ScAlloc failed\n") );
      return;
	}
	Dilate(image, tmp, rows, cols, sr, sc);

	pi = image;
	pr = reference;
	pt = tmp;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pr++, pt++) {
			*pi = *pr < *pt ? *pr : *pt;
		}
	}
	ScFree(tmp);
}

/*****************************************************************************************************
 * Function: GeoErode 
 * Geodesic erosion of size one of image with respect to reference
 ****************************************************************************************************/
void GeoErode(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, j;
	unsigned char *pi, *pr, *pt, *tmp;

	if (!(tmp = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("GeoErode() ScAlloc failed\n") );
      return;
	}
	Erode(image, tmp, rows, cols, sr, sc);

	pi = image;
	pr = reference;
	pt = tmp;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pr++, pt++) {
			*pi = (-(*pr) < (-*pt)) ? *pr : *pt;
		}
	}
	ScFree(tmp);
}

/****************************************************************************************************
 * Function: RecDilate
 * Reconstruction by dilation of image with respect to reference using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void RecDilate(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, sz;
	unsigned char *prevImg, *pi, *Pi, differ;

	sz = rows * cols;
	if (!(prevImg = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("RecDilate() ScAlloc failed\n") );
      return;
	}
	do {
		memcpy(prevImg, image, rows*cols);
		GeoDilate(image, reference, rows, cols, sr, sc);
		pi = image;	Pi = prevImg;
		differ = 0;
		for(i=0; i<sz; i++) if(*(pi++) != *(Pi++)) { differ = 1; break;}
	} while (differ);
	ScFree(prevImg);
}

/****************************************************************************************************
 * Function: RecErode
 * Reconstruction by erosion of image with respect to reference using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void RecErode(unsigned char *image, unsigned char *reference, int rows, int cols, int sr, int sc)
{
	int i, sz;
	unsigned char *prevImg, *pi, *Pi, differ;

	sz = rows * cols;
	if (!(prevImg = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("RecErode() ScAlloc failed\n") );
      return;
	}
	do {
		memcpy(prevImg, image, rows*cols);
		GeoErode(image, reference, rows, cols, sr, sc);
		pi = image;	Pi = prevImg;
		differ = 0;
		for(i=0; i<sz; i++) if(*(pi++) != *(Pi++)) { differ = 1; break;}
	} while (differ);
	ScFree(prevImg);
}

/****************************************************************************************************
 * Function: OpenRecErode
 * Open by reconstruction of erosion of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void OpenRecErode(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;

	sz = rows * cols;
	Erode(image, out, rows, cols, sr, sc);
	RecDilate(out, image, rows, cols, sr, sc);
}


/****************************************************************************************************
 * Function: CloseRecDilate
 * Closing by reconstruction of dilation of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void CloseRecDilate(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;

	sz = rows * cols;
	Dilate(image, out, rows, cols, sr, sc);
	RecErode(out, image, rows, cols, sr, sc);
}

/****************************************************************************************************
 * Function: OpenCloseRec
 * Open-closing by reconstruction of image using a structural element of 
 * dimenions (sr, sc).
 ****************************************************************************************************/
void OpenCloseRec(unsigned char *image, unsigned char *out, int rows, int cols, int sr, int sc)
{
	int sz;
	unsigned char *opened;

	sz = rows * cols;
	if (!(opened = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("OpenCloseRec() ScAlloc failed\n") );
      return;
	}
	OpenRecErode(image, opened, rows, cols, sr, sc);
	CloseRecDilate(opened, out, rows, cols, sr, sc);
	ScFree(opened);
}

/****************************************************************************************************
 * Function: PredOpenCloseRec
 * Open-closing by reconstruction of image using a structural element of 
 * dimenions (sr, sc), for prediction images.
 ****************************************************************************************************/
void PredOpenCloseRec(int *predimage, int *predout, int rows, int cols, int sr, int sc)
{
	int sz, i;
	unsigned char *opened, *image, *out;

	sz = rows * cols;
	if (!(image = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	if (!(out = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	for(i=0; i<sz; i++) image[i] = (unsigned char) predimage[i] + 128;

	if (!(opened = (unsigned char *)ScAlloc(sz))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return;
	}
	OpenRecErode(image, opened, rows, cols, sr, sc);
	CloseRecDilate(opened, out, rows, cols, sr, sc);

	for(i=0; i<sz; i++) predout[i] = (int) out[i] - 128;

	ScFree(opened);
	ScFree(image);
	ScFree(out);
}

/**************************************************************************************************
 * Function: EdgeSelect
 * Given the edge map, copies to the output: pixels from the input image if edge points,
 * pixels form the filtered image if not edge points.
 *************************************************************************************************/
static void EdgeSelect(H263_PictImage *input, H263_PictImage *filtd, unsigned char *edge, 
					   H263_PictImage *output, int rows, int cols)
{
	unsigned char *pi, *po, *pf, *pe;
	int i, j;

	/* Luminance */
	pi = input->lum; pf = filtd->lum;
	po = output->lum; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe++, po++) {
			*po = (*pe ? *pi : *pf);
		}
	}

	rows /=2; cols /=2;

	/* Color 1 */
	pi = input->Cr; pf = filtd->Cr;
	po = output->Cr; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe+=2, po++) {
			*po = (*pe ? *pi : *pf); 
		}
		pe += cols;
	}

	/* Color 2 */
	pi = input->Cb; pf = filtd->Cb;
	po = output->Cb; pe = edge;
	for(i=0; i<rows; i++) {
		for(j=0; j<cols; j++, pi++, pf++, pe+=2, po++) {
			*po = (*pe ? *pi : *pf);	
		}
		pe += cols;
	}
}

/**************************************************************************************************
 * Function: AdaptClean
 * Adaptly cleans curr_image, by filtering it by open/close by reconstruction at the pixels
 * where there is no edge info. The edge map is grown by the size of the morphological
 * operator, to avoid oversmoothing of details. sr, sc are the dimensions of the structuring
 * element for the morphologic operations
 *************************************************************************************************/
H263_PictImage *sv_H263AdaptClean(SvH263CompressInfo_t *H263Info, 
                                  H263_PictImage *curr_image, int rows, int cols, int sr, int sc)
{
	H263_PictImage *morph, *clean;
    unsigned char *Edge, *Orient, *CleanEmap;

	if (!(Edge = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}
	if (!(Orient = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}
	sv_H263EdgeMap(curr_image->lum, Edge, Orient, rows, cols);
	
	morph = sv_H263InitImage(H263Info->pels*H263Info->lines);

	OpenCloseRec(H263Info->curr_image->lum, morph->lum, rows, cols, sr, sc);
	OpenCloseRec(H263Info->curr_image->Cr, morph->Cr, rows >> 1, cols >> 1, sr, sc);
	OpenCloseRec(H263Info->curr_image->Cb, morph->Cb, rows >> 1, cols >> 1, sr, sc); 

	clean = sv_H263InitImage(rows*cols);

	if (!(CleanEmap = (unsigned char *)ScAlloc(rows*cols))) {
      _SlibDebug(_WARN_, printf("PredOpenCloseRec() ScAlloc failed\n") );
      return(NULL);
	}

	CloseOpen(Edge, CleanEmap, rows, cols, sr, sc);
	EdgeSelect(H263Info->curr_image, morph, CleanEmap, clean, rows, cols);

	sv_H263FreeImage(morph);
	ScFree(CleanEmap);
	ScFree(Orient);
	ScFree(Edge);

	return clean;
}

 /*****************************************************************
 * Function MorphLayers
 * Builds an array of successively more morphologically low pass 
 * filtered images. sz is the size of the structuring element (-1 for
 * the cross '+').
 *****************************************************************/
 H263_PictImage **sv_H263MorphLayers(H263_PictImage *img, int depth, int rows, int cols, int sz)
 {
	 int d;
	 H263_PictImage **PictFiltd;

	 PictFiltd = (H263_PictImage **) ScAlloc(depth*sizeof(H263_PictImage *));
	 for(d=0; d<depth; d++) {
		PictFiltd[d] = sv_H263InitImage(rows*cols);
	 }

	 /* Luminance */
	 memcpy(PictFiltd[0]->lum, img->lum, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->lum, PictFiltd[d]->lum, rows, cols, sz, sz);

	 rows/=2; cols/=2;

	 /* Chroma 1 */
	 memcpy(PictFiltd[0]->Cr, img->Cr, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->Cr, PictFiltd[d]->Cr, rows, cols, sz, sz);

	 /* Chroma 2 */
	 memcpy(PictFiltd[0]->Cb, img->Cb, rows*cols);
	 for(d=1; d<depth; d++) 
		 OpenCloseRec(PictFiltd[d-1]->Cb, PictFiltd[d]->Cb, rows, cols, sz, sz);


	 return PictFiltd;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\me4.c ===
/* File: sv_h263_me4.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#define THREEBYEIGHT .375
#define THREEBYFOUR .75
#define MINUSONEBYEIGHT -0.125

#define FIVEBY32 0.15625
#define FIFTEENBY16 0.9375
#define MINUSTHREEBY32 -0.09375

#define SEVENBY16 0.4375
#define TWENTYONEBY32 0.65625

/**********************************************************************
 *
 *	Name:		MotionEstimation
 *	Description:	Estimate all motionvectors for one MB
 *	
 *	Input:		pointers to current an previous image,
 *			pointers to current slice and current MB
 *	Returns:	
 *	Side effects:	motion vector information in MB changed
 *
 ***********************************************************************/


void sv_H263ME_2levels_7_pihp(SvH263CompressInfo_t *H263Info,
                              unsigned char *curr, unsigned char *prev, int x_curr,
                              int y_curr, int xoff, int yoff, int seek_dist,
                              H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0)
{

  int Min_FRAME[5];
  H263_MotionVector MVFrame[5];
  unsigned char *aa,*ii;
  unsigned char *adv_search_area = NULL, *zero_area = NULL;
  int sxy,i,k,j,l;
  int ihigh,ilow,jhigh,jlow,h_length,v_length;
  int adv_ihigh,adv_ilow,adv_jhigh,adv_jlow,adv_h_length,adv_v_length;
  int xmax,ymax,block,sad,lx;
  int adv_x_curr, adv_y_curr,xvec,yvec;

  unsigned char *act_block_subs2, *search_area_subs2, *adv_search_area_subs2;
  int h_lenby2,v_lenby2,adv_h_lenby2,adv_v_lenby2;
  int xlevel1,ylevel1,sxylevel1;
  int xlevel1_block[4], ylevel1_block[4];
/*
  int level0_x_curr,level0_y_curr,sxylevel0;
*/
  int start_x, start_y, stop_x, stop_y, new_x, new_y;
  int AE[5];
  H263_Point search[5];
  H263_Point half[5];
  int pym1,pxm1,pxp1,pyp1;
  int pym05,pxm05,pxp05,pyp05;
  int AE_minx, AE_miny, min_posx, min_posy, min_hposx, min_hposy;


  xmax = H263Info->pels;
  ymax = H263Info->lines;
  sxy = seek_dist;
  if (!H263Info->long_vectors) {
    /* Maximum normal search range centered around _zero-vector_ */
    sxy = mmin(15, sxy);
  }
  else {
    /* Maximum extended search range centered around _predictor_ */
    sxy = mmin(15 - (2*H263_DEF_8X8_WIN+1), sxy);

    /* NB! */

    /* It is only possible to transmit motion vectors within
       a 15x15 window around the motion vector predictor
       for any 8x8 or 16x16 block */

    /* The reason for the search window's reduction above with
       2*DEF_8X8_WIN+1 is that the 8x8 search may change the MV
       predictor for some of the blocks within the macroblock. When we
       impose the limitation above, we are sure that any 8x8 vector we
       might find is possible to transmit */

    /* We have found that with OBMC, DEF_8X8_WIN should be quite small
       for two reasons: (i) a good filtering effect, and (ii) not too
       many bits used for transferring the vectors. As can be seen
       above this is also useful to avoid a large limitation on the MV
       search range */

    /* It is possible to make sure the motion vectors found are legal
       in other less limiting ways than above, but this would be more
       complicated as well as time-consuming. Any good suggestions for
       improvement is welcome, though */
#ifdef USE_C
    xoff = mmin(16,mmax(-16,xoff));
    yoff = mmin(16,mmax(-16,yoff));
#else
	xoff = sv_H263lim_S(xoff,-16,16);
    yoff = sv_H263lim_S(yoff,-16,16);
#endif

    /* in case xoff or yoff is odd */
    xoff= 2 * ((xoff)>>1);
    yoff= 2 * ((yoff)>>1);

    /* There is no need to check if (xoff + x_curr) points outside
       the picture, since the Extended Motion Vector Range is
       always used together with the Unrestricted MV mode */
  }


  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  ilow = x_curr + xoff - sxy;
  ihigh = x_curr + xoff + sxy;

  jlow = y_curr + yoff - sxy;
  jhigh = y_curr + yoff + sxy;

  if (!H263Info->mv_outside_frame) {
    if (ilow<0) ilow = 0;
    if (ihigh>xmax-16) ihigh = xmax-16;
    if (jlow<0) jlow = 0;
    if (jhigh>ymax-16) jhigh = ymax-16;
  }

  h_length = ihigh - ilow + 16;
  v_length = jhigh - jlow + 16;

  /* subsampled version for ME level 1 */
  h_lenby2 = (h_length-1)>>1;
  v_lenby2 = (v_length-1)>>1;
  act_block_subs2 = sv_H263LoadSubs2Area(curr, x_curr, y_curr, 8, 8, H263Info->pels);
  search_area_subs2 = sv_H263LoadSubs2Area(prev, ilow, jlow, h_lenby2, v_lenby2, lx);

  for (k = 0; k < 5; k++) {
    Min_FRAME[k] = INT_MAX;
    MVFrame[k].x = 0;
    MVFrame[k].y = 0;
    MVFrame[k].x_half = 0;
    MVFrame[k].y_half = 0;
  }

  /* match for zero (or [xoff,yoff]) motion vector on subsampled images */
  ii = search_area_subs2 + ((x_curr+xoff-ilow)>>1) + ((y_curr+yoff-jlow)>>1)*h_lenby2;
#ifdef USE_C
  Min_FRAME[0] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
  Min_FRAME[0] = sv_H263PError8x8_S(ii,act_block_subs2,h_lenby2,8,Min_FRAME[0]);
#endif

  MVFrame[0].x = (short)xoff;
  MVFrame[0].y = (short)yoff;

  /*** Spiral search (+-7) on subsampled images ***/

  sxylevel1 = (sxy-1)>>1;

  for (l = 1; l <= sxylevel1; l++) {
    i = x_curr + xoff - 2*l;
    j = y_curr + yoff - 2*l;
    for (k = 0; k < 8*l; k++) {
      if (i>=ilow && i<=ihigh && j>=jlow && j<=jhigh) {

	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	sad = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]);
#else
      sad = sv_H263PError8x8_S(ii,act_block_subs2,h_lenby2,8,Min_FRAME[0]);
#endif
	if (sad < Min_FRAME[0]) {
	  MVFrame[0].x = i - x_curr;
	  MVFrame[0].y = j - y_curr;
	  Min_FRAME[0] = sad;
	}

      }
      if      (k<2*l) i+=2;
      else if (k<4*l) j+=2;
      else if (k<6*l) i-=2;
      else            j-=2;
    }
  }

  /* motion vectors after level1 */
  xlevel1=MVFrame[0].x;
  ylevel1=MVFrame[0].y;

  /* reset */
  Min_FRAME[0] = INT_MAX;
  MVFrame[0].x = 0;
  MVFrame[0].y = 0;

  /* Zero vector search*/
  if (x_curr-ilow         < 0        || y_curr-jlow         < 0        ||
      x_curr-ilow+H263_MB_SIZE > h_length || y_curr-jlow+H263_MB_SIZE > v_length) {
    /* in case the zero vector is outside the loaded area in search_area */

    zero_area = sv_H263LoadSubs2Area(prev, x_curr, y_curr, 8, 8, lx);
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(zero_area, act_block_subs2, 8, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
    ScFree(zero_area);
  }
  else {
    /* the zero vector is within search_area */

    ii = search_area_subs2 + ((x_curr-ilow)>>1) + ((y_curr-jlow)>>1)*h_lenby2;
#ifdef USE_C
    *SAD_0 = 4*sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#else
    *SAD_0 = 4*sv_H263PError8x8_S(ii, act_block_subs2, h_lenby2, 8, Min_FRAME[0]) -
       H263_PREF_NULL_VEC;
#endif
  }

  /*** +-1 search on full-resolution images done by polynomial interpolation ***/

  start_x = -1;
  stop_x = 1;
  start_y = -1;
  stop_y = 1;

  new_x = x_curr + xlevel1;
  new_y = y_curr + ylevel1;

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= (ilow+1))
      start_x = 0;
    if ((new_y) <= (jlow+1))
      start_y = 0;
    if ((new_x) >= (ihigh-1))
      stop_x = 0;
    if ((new_y) >= (jhigh-1))
      stop_y = 0;
  }

 /*     1     */
 /*   2 0 3   */
 /*     4     */

  search[0].x = 0; 		search[0].y = 0;
  search[1].x = 0; 		search[1].y = (short)start_y;
  search[2].x = (short)start_x;     	search[2].y = 0;
  search[3].x = (short)stop_x;     	search[3].y = 0;
  search[4].x = 0; 	       	search[4].y = (short)stop_y;

  half[0].x = 0; 		half[0].y = 0;
  half[1].x = 0; 		half[1].y = (short)start_y;
  half[2].x = (short)start_x;     	half[2].y = 0;
  half[3].x = (short)stop_x;     	half[3].y = 0;
  half[4].x = 0; 	       	half[4].y = (short)stop_y;

  for (l = 0; l < 5 ; l++) {
    AE[l] = INT_MAX;
    i =  new_x + 2*search[l].x;
    j =  new_y + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = search_area_subs2 + ((i-ilow)>>1) + ((j-jlow)>>1)*h_lenby2;
#ifdef USE_C
	AE[l] = sv_H263MySADBlock(ii, act_block_subs2, h_lenby2, 8, INT_MAX);
#else
	AE[l] = sv_H263PEr8_init_S(ii, act_block_subs2, h_lenby2, 8);
#endif
  }

  /* 1D polynomial interpolation along x and y respectively */

  AE_minx = AE[0];
  min_posx = 0;
  min_hposx = 0;

  pxm1 = (int)(THREEBYEIGHT * (double) AE[2]
             + THREEBYFOUR * (double) AE[0]
             + MINUSONEBYEIGHT * (double) AE[3]) ;

  if (pxm1<AE_minx) {
    AE_minx = pxm1;
    min_posx = 2;
  }

  pxp1 = (int)(MINUSONEBYEIGHT * (double) AE[2]
             + THREEBYFOUR * (double) AE[0]
             + THREEBYEIGHT * (double) AE[3]);

  if (pxp1<AE_minx) {
    AE_minx = pxp1;
    min_posx = 3;
  }

  switch(min_posx) {

  case 0:  /* now check +- 1/2 */
    pxm05 = (int)( FIVEBY32 * (double) AE[2]
                 + FIFTEENBY16 * (double) AE[0]
                 + MINUSTHREEBY32 * (double) AE[3]);

    if (pxm05<AE_minx) {
      AE_minx = pxm05;
      min_hposx = 2;
    }

    pxp05 = (int)( MINUSTHREEBY32 * (double) AE[2]
                 + FIFTEENBY16 * (double) AE[0]
                 + FIVEBY32 * (double) AE[3]);

    if (pxp05<AE_minx) {
      AE_minx = pxp05;
      min_hposx = 3;
    }
    break;

  case 2:  /* now check -3/2 -1/2 */
    pxp05 = (int)(FIVEBY32 * AE[2]
                + FIFTEENBY16 * AE[0]
 	            + MINUSTHREEBY32 * AE[3]);

    if (pxp05<AE_minx) {
      AE_minx = pxp05;
      min_hposx = 3;
    }
    break;

  case 3:  /* now check +1/2 +3/2 */
    pxm05 = (int)( MINUSTHREEBY32 * (double)AE[2]
                   + FIFTEENBY16 * (double)AE[0]
	               + FIVEBY32 * (double)AE[3]);

    if (pxm05<AE_minx) {
      AE_minx = pxm05;
      min_hposx = 2;
    }
    break;
  }

  /* along y */

  AE_miny = AE[0];
  min_posy = 0;
  min_hposy = 0;

  pym1 = (int)(THREEBYEIGHT * (double)AE[1]
             + THREEBYFOUR * (double)AE[0]
             + MINUSONEBYEIGHT * (double)AE[4]);

  if (pym1<AE_miny) {
    AE_miny = pym1;
    min_posy = 1;
  }

  pyp1 = (int)( MINUSONEBYEIGHT * (double)AE[1]
                + THREEBYFOUR * (double)AE[0]
                + THREEBYEIGHT * (double)AE[4]);

  if (pyp1<AE_miny) {
    AE_miny = pyp1;
    min_posy = 4;
  }

  switch(min_posy) {

  case 0:  /* +- 1/2 */
    pym05 = (int)( FIVEBY32 * (double)AE[1]
                 + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[4]);

    if (pym05<AE_miny) {
      AE_miny = pym05;
      min_hposy = 1;
    }

    pyp05 = (int)(MINUSTHREEBY32 * (double)AE[1]
                + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

    if (pyp05<AE_miny) {
      AE_miny = pyp05;
      min_hposy = 4;
    }
    break;

  case 1:  /*  -3/2 -1/2 */
    pyp05 = (int)(FIVEBY32 * (double)AE[1]
                + FIFTEENBY16 * (double)AE[0]
	            + MINUSTHREEBY32 * (double)AE[4]);

    if (pyp05<AE_miny) {
      AE_miny = pyp05;
      min_hposy = 4;
    }
    break;

  case 4:  /* +1/2 +3/2 */
    pym05 = (int)( MINUSTHREEBY32 * (double)AE[1]
                 + FIFTEENBY16 * (double)AE[0]
	             + FIVEBY32 * (double)AE[4]);

    if (pym05<AE_miny) {
      AE_miny = pym05;
      min_hposy = 1;
    }
    break;

  }

  /* Store optimal values */
  Min_FRAME[0] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
  MVFrame[0].x = new_x + search[min_posx].x - x_curr;
  MVFrame[0].y = new_y + search[min_posy].y - y_curr;
  MVFrame[0].x_half = half[min_hposx].x;
  MVFrame[0].y_half = half[min_hposy].y;

  if (H263Info->advanced) {

    /* Center the 8x8 search around the 16x16 vector.  This is
       different than in TMN5 where the 8x8 search is also a full
       search. The reasons for this is: (i) it is faster, and (ii) it
       generally gives better results because of a better OBMC
       filtering effect and less bits spent for vectors, and (iii) if
       the Extended MV Range is used, the search range around the
       motion vector predictor will be less limited */

    xvec = MVFrame[0].x;
    yvec = MVFrame[0].y;

    if (!H263Info->long_vectors) {
      if (xvec > 15 - H263_DEF_8X8_WIN) { xvec =  15 - H263_DEF_8X8_WIN ;}
      if (yvec > 15 - H263_DEF_8X8_WIN) { yvec =  15 - H263_DEF_8X8_WIN ;}

      if (xvec < -15 + H263_DEF_8X8_WIN) { xvec =  -15 + H263_DEF_8X8_WIN ;}
      if (yvec < -15 + H263_DEF_8X8_WIN) { yvec =  -15 + H263_DEF_8X8_WIN ;}
    }

    adv_x_curr = x_curr  + xvec;
    adv_y_curr = y_curr  + yvec;

    sxy = H263_DEF_8X8_WIN;

    adv_ilow = adv_x_curr - sxy;
    adv_ihigh = adv_x_curr + sxy;

    adv_jlow = adv_y_curr - sxy;
    adv_jhigh = adv_y_curr + sxy;

    adv_h_length = adv_ihigh - adv_ilow + 16;
    adv_v_length = adv_jhigh - adv_jlow + 16;

/*  BUG
    adv_h_lenby2 = (adv_h_length-1)>>1;
    adv_v_lenby2 = (adv_v_length-1)>>1;
*/
    adv_h_lenby2 = (adv_h_length)>>1;
    adv_v_lenby2 = (adv_v_length)>>1;
/*
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_lenby2, adv_v_lenby2, lx);
*/
    adv_search_area_subs2 = sv_H263LoadSubs2Area(prev, adv_ilow, adv_jlow,
			       adv_h_length, adv_v_length, lx);

    for (block = 0; block < 4; block++) {
      ii = adv_search_area_subs2 + ((adv_x_curr-adv_ilow)>>1) + ((block&1)<<2) +
	(((adv_y_curr-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
      aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_lenby2,Min_FRAME[block+1]);
*/
      Min_FRAME[block+1] = sv_H263MySADSubBlock(ii,aa,adv_h_length,Min_FRAME[block+1]);

      MVFrame[block+1].x = MVFrame[0].x;
      MVFrame[block+1].y = MVFrame[0].y;
    }

    /* Spiral search */
    sxylevel1 = (sxy-1)>>1;

    for (l = 1; l <= sxylevel1; l++) {
      i = adv_x_curr - 2*l;
      j = adv_y_curr - 2*l;
      for (k = 0; k < 8*l; k++) {
	if (i>=adv_ilow && i<=adv_ihigh && j>=adv_jlow && j<=adv_jhigh) {
	
	  /* 8x8 integer pel MVs */
	  for (block = 0; block < 4; block++) {
	    ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	      (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	    aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, Min_FRAME[block+1]);
*/
	    sad = sv_H263MySADSubBlock(ii, aa, adv_h_length, Min_FRAME[block+1]);

	    if (sad < Min_FRAME[block+1]) {
	      MVFrame[block+1].x = i - x_curr;
	      MVFrame[block+1].y = j - y_curr;
	      Min_FRAME[block+1] = sad;
	    }
	  }
	
	}
	if      (k<2*l) i++;
	else if (k<4*l) j++;
	else if (k<6*l) i--;
	else            j--;
      }
    }

    for (block = 0; block < 4; block++) {
      xlevel1_block[block] = MVFrame[block+1].x;
      ylevel1_block[block] = MVFrame[block+1].y;

      /* reset */
      Min_FRAME[block+1] = INT_MAX;
      MVFrame[block+1].x = 0;
      MVFrame[block+1].y = 0;
    }

    /* +-1 search on full resolution on full-resolution images */
    /* by polynomial interpolation */

    for (block = 0; block < 4; block++) {
      start_x = -1;
      stop_x = 1;
      start_y = -1;
      stop_y = 1;

      adv_x_curr = x_curr + xlevel1_block[block];
      adv_y_curr = y_curr + ylevel1_block[block];

      /*     1     */
      /*   2 0 3   */
      /*     4     */

      search[0].x = 0; 		search[0].y = 0;
      search[1].x = 0; 		search[1].y = (short)start_y;
      search[2].x = (short)start_x;    search[2].y = 0;
      search[3].x = (short)stop_x;     search[3].y = 0;
      search[4].x = 0; 	       	search[4].y = (short)stop_y;

      half[0].x = 0; 		half[0].y = 0;
      half[1].x = 0; 		half[1].y = (short)start_y;
      half[2].x = (short)start_x;     	half[2].y = 0;
      half[3].x = (short)stop_x;     	half[3].y = 0;
      half[4].x = 0; 	       	half[4].y = (short)stop_y;

      for (l = 0; l < 5 ; l++) {
	AE[l] = INT_MAX;
	i =  adv_x_curr + 2*search[l].x;
	j =  adv_y_curr + 2*search[l].y;
	/* 8x8 integer pel MV */
	ii = adv_search_area_subs2 + ((i-adv_ilow)>>1) + ((block&1)<<2) +
	  (((j-adv_jlow)>>1) + ((block&2)<<1) )*adv_h_lenby2;
	aa = act_block_subs2 + ((block&1)<<2) + ((block&2)<<1)*8;
/*
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_lenby2, INT_MAX);
*/
	AE[l] = sv_H263MySADSubBlock(ii, aa, adv_h_length, INT_MAX);

      }

      /* 1D polynomial interpolation along x and y respectively */

      AE_minx = AE[0];
      min_posx = 0;
      min_hposx = 0;

      pxm1 = (int)( THREEBYEIGHT * (double)AE[2]
	              + THREEBYFOUR * (double)AE[0]
	              + MINUSONEBYEIGHT * (double)AE[3]);

      if (pxm1<AE_minx) {
	AE_minx = pxm1;
	min_posx = 2;
      }

      pxp1 = (int)( MINUSONEBYEIGHT * (double)AE[2]
	              + THREEBYFOUR * (double)AE[0]
	              + THREEBYEIGHT * (double)AE[3]);

      if (pxp1<AE_minx) {
	AE_minx = pxp1;
	min_posx = 3;
      }

      switch(min_posx) {

      case 0:  /* now check +- 1/2 */
	pxm05 = (int) (FIVEBY32 * (double)AE[2]
	             + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[3]);

	if (pxm05<AE_minx) {
	  AE_minx = pxm05;
	  min_hposx = 2;
	}

	pxp05 = (int)(MINUSTHREEBY32 * (double)AE[2]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[3]);

	if (pxp05<AE_minx) {
	  AE_minx = pxp05;
	  min_hposx = 3;
	}
	break;

      case 2:  /* now check -3/2 -1/2 */
	pxp05 = (int)( FIVEBY32 * (double)AE[2]
	             + FIFTEENBY16 * (double)AE[0]
	             + MINUSTHREEBY32 * (double)AE[3]);

	if (pxp05<AE_minx) {
	  AE_minx = pxp05;
	  min_hposx = 3;
	}
	break;

      case 3:  /* now check +1/2 +3/2 */
	pxm05 = (int)(MINUSTHREEBY32 * (double)AE[2]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[3]);

	if (pxm05<AE_minx) {
	  AE_minx = pxm05;
	  min_hposx = 2;
	}
	break;
      }

      /* along y */

      AE_miny = AE[0];
      min_posy = 0;
      min_hposy = 0;

      pym1 = (int)(THREEBYEIGHT * (double)AE[1]
	             + THREEBYFOUR * (double)AE[0]
	             + MINUSONEBYEIGHT * (double)AE[4]);

      if (pym1<AE_miny) {
	AE_miny = pym1;
	min_posy = 1;
      }

      pyp1 = (int)(MINUSONEBYEIGHT * (double)AE[1] +
  	             + THREEBYFOUR * (double)AE[0]
	             + THREEBYEIGHT * (double)AE[4]);

      if (pyp1<AE_miny) {
	AE_miny = pyp1;
	min_posy = 4;
      }

      switch(min_posy) {

      case 0:  /* +- 1/2 */
	pym05 = (int)(FIVEBY32 * (double)AE[1]
	            + FIFTEENBY16 * (double)AE[0]
	            + MINUSTHREEBY32 * (double)AE[4]);

	if (pym05<AE_miny) {
	  AE_miny = pym05;
	  min_hposy = 1;
	}

	pyp05 = (int)(MINUSTHREEBY32 * (double)AE[1]
	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

	if (pyp05<AE_miny) {
	  AE_miny = pyp05;
	  min_hposy = 4;
	}
	break;

      case 1:  /*  -3/2 -1/2 */
	pyp05 = (int)(FIVEBY32 * (double)AE[1]
	           + FIFTEENBY16 * (double)AE[0]
	           + MINUSTHREEBY32 * (double)AE[4]);

	if (pyp05<AE_miny) {
	  AE_miny = pyp05;
	  min_hposy = 4;
	}
	break;

      case 4:  /* +1/2 +3/2 */
	pym05 = (int)(MINUSTHREEBY32 * (double)AE[1]
  	            + FIFTEENBY16 * (double)AE[0]
	            + FIVEBY32 * (double)AE[4]);

	if (pym05<AE_miny) {
	  AE_miny = pym05;
	  min_hposy = 1;
	}
	break;

      }

      /* Store optimal values */
      Min_FRAME[block+1] = (AE_minx<AE_miny ? 4*AE_minx : 4*AE_miny);
      MVFrame[block+1].x = adv_x_curr + search[min_posx].x - x_curr;
      MVFrame[block+1].y = adv_y_curr + search[min_posy].y - y_curr;
      MVFrame[block+1].x_half = half[min_hposx].x;
      MVFrame[block+1].y_half = half[min_hposy].y;

    }
  }

  i = x_curr/H263_MB_SIZE+1;
  j = y_curr/H263_MB_SIZE+1;

  if (!H263Info->advanced) {
    MV[0][j][i]->x = MVFrame[0].x;
    MV[0][j][i]->y = MVFrame[0].y;
    MV[0][j][i]->x_half = MVFrame[0].x_half;
    MV[0][j][i]->y_half = MVFrame[0].y_half;
    MV[0][j][i]->min_error = (short)Min_FRAME[0];
  }
  else {
    for (k = 0; k < 5; k++) {
      MV[k][j][i]->x = MVFrame[k].x;
      MV[k][j][i]->y = MVFrame[k].y;
      MV[k][j][i]->x_half = MVFrame[k].x_half;
      MV[k][j][i]->y_half = MVFrame[k].y_half;
      MV[k][j][i]->min_error = (short)Min_FRAME[k];
    }
  }

  ScFree(act_block_subs2);
  ScFree(search_area_subs2);

  if (H263Info->advanced)
    ScFree(adv_search_area);
  return;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\param.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_param.c,v $
 * Revision 1.1.6.25  1996/12/13  18:19:09  Hans_Graves
 * 	Adjust file size in NEED_ACCURACY, if end of file is bad.
 * 	[1996/12/13  18:13:11  Hans_Graves]
 *
 * Revision 1.1.6.24  1996/12/12  20:54:47  Hans_Graves
 * 	Fixed NT compile warning with use of ftime.
 * 	[1996/12/12  20:51:38  Hans_Graves]
 * 
 * Revision 1.1.6.23  1996/12/05  20:10:18  Hans_Graves
 * 	Change max choosen MPEG audio bitrate to 192kbits
 * 	[1996/12/05  20:09:25  Hans_Graves]
 * 
 * Revision 1.1.6.22  1996/12/04  22:34:34  Hans_Graves
 * 	Make seeking in NEEDACCURACY quicker when seeks fail.
 * 	[1996/12/04  22:20:18  Hans_Graves]
 * 
 * Revision 1.1.6.21  1996/12/03  23:15:18  Hans_Graves
 * 	MME-1498: Made seeks with PERCENT100 more accurate
 * 	[1996/12/03  23:10:48  Hans_Graves]
 * 
 * Revision 1.1.6.20  1996/12/03  00:08:36  Hans_Graves
 * 	Handling of End Of Sequence points. Added PERCENT100 support.
 * 	[1996/12/03  00:06:06  Hans_Graves]
 * 
 * Revision 1.1.6.19  1996/11/18  23:07:38  Hans_Graves
 * 	Make use of presentation timestamps. Make seeking time-based.
 * 	[1996/11/18  22:48:00  Hans_Graves]
 * 
 * Revision 1.1.6.18  1996/11/14  22:32:10  Hans_Graves
 * 	AUDIOCHANNELS can only be changed under AC3 decompression.
 * 	[1996/11/14  22:31:39  Hans_Graves]
 * 
 * Revision 1.1.6.17  1996/11/14  21:49:29  Hans_Graves
 * 	Multichannel setting using AUDIOCHANNELS param.
 * 	[1996/11/14  21:44:44  Hans_Graves]
 * 
 * Revision 1.1.6.16  1996/11/11  18:21:10  Hans_Graves
 * 	Added SlibGetParamString() support for SLIB_PARAM_TYPE.
 * 	[1996/11/11  18:01:25  Hans_Graves]
 * 
 * Revision 1.1.6.15  1996/11/08  21:51:08  Hans_Graves
 * 	Added new PARAMs VIDEOMAINSTREAM, AUDIOMAINSTREAM and TYPE
 * 	[1996/11/08  21:31:08  Hans_Graves]
 * 
 * Revision 1.1.6.14  1996/10/28  17:32:34  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:07  Hans_Graves]
 * 
 * Revision 1.1.6.13  1996/10/17  00:23:36  Hans_Graves
 * 	Added SLIB_PARAM_VIDEOFRAME and SLIB_PARAM_FRAMEDURATION.
 * 	[1996/10/17  00:19:44  Hans_Graves]
 * 
 * Revision 1.1.6.12  1996/10/12  17:18:56  Hans_Graves
 * 	Added SLIB_PARAM_SKIPPEL and SLIB_PARAM_HALFPEL support.
 * 	[1996/10/12  17:02:37  Hans_Graves]
 * 
 * Revision 1.1.6.11  1996/10/03  19:14:26  Hans_Graves
 * 	Added Presentation and Decoding timestamp support.
 * 	[1996/10/03  19:10:42  Hans_Graves]
 * 
 * Revision 1.1.6.10  1996/09/29  22:19:44  Hans_Graves
 * 	Added STRIDE param.
 * 	[1996/09/29  21:31:34  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/09/25  19:16:50  Hans_Graves
 * 	Added SLIB_INTERNAL define.
 * 	[1996/09/25  19:01:56  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/09/23  18:04:05  Hans_Graves
 * 	Added STATS params.
 * 	[1996/09/23  17:58:54  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/09/18  23:47:17  Hans_Graves
 * 	Added new PARAMs: VBV, ASPECTRATIO, TIMECODE, VERSION
 * 	[1996/09/18  22:07:17  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/08/09  20:51:53  Hans_Graves
 * 	Allows deselecting of SLIB_PARAM_VIDEOSTREAMS and SLIB_PARAM_AUDIOSTREAMS
 * 	[1996/08/09  20:12:16  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/07/30  20:25:38  Wei_Hsu
 * 	Add motion algorithm param.
 * 	[1996/07/30  15:59:07  Wei_Hsu]
 * 
 * Revision 1.1.6.4  1996/07/19  02:11:17  Hans_Graves
 * 	Added SLIB_PARAM_DEBUG support
 * 	[1996/07/19  01:59:50  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/05/23  18:46:38  Hans_Graves
 * 	Merge MME-1220 & MME-1221 - Multiply MPEG audio bitrates by 1000 instead of 1024
 * 	[1996/05/23  18:46:09  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/05/10  21:17:47  Hans_Graves
 * 	Allow FILESIZE param to be set, for callbacks.
 * 	[1996/05/10  20:46:23  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/04/30  17:05:35  Hans_Graves
 * 	Report SlibErrorSettingNotEqual correctly under SetParamFloat(). Fixes MME-01173
 * 	[1996/04/30  16:49:06  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/04/24  22:33:48  Hans_Graves
 * 	MPEG encoding bitrate fixups.
 * 	[1996/04/24  22:27:16  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/04/23  21:01:42  Hans_Graves
 * 	Fix SlibValidateParams(). Add error checking for SlibErrorSettingNotEqual
 * 	[1996/04/23  20:59:03  Hans_Graves]
 * 
 * Revision 1.1.4.10  1996/04/22  15:04:54  Hans_Graves
 * 	Added SlibValidateParams()
 * 	[1996/04/22  14:43:04  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/04/19  21:52:26  Hans_Graves
 * 	Fix BITRATE parameter settings
 * 	[1996/04/19  21:47:01  Hans_Graves]
 * 
 * Revision 1.1.4.8  1996/04/11  14:14:12  Hans_Graves
 * 	Fix NT warnings
 * 	[1996/04/11  14:10:21  Hans_Graves]
 * 
 * Revision 1.1.4.7  1996/04/10  21:47:43  Hans_Graves
 * 	Added params: FASTENCODE, FASTDECODE, and QUALITY
 * 	[1996/04/10  21:40:18  Hans_Graves]
 * 
 * Revision 1.1.4.6  1996/04/09  16:04:43  Hans_Graves
 * 	Handle setting negative Height
 * 	[1996/04/09  14:42:13  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/04/01  19:07:57  Hans_Graves
 * 	And some error checking
 * 	[1996/04/01  19:04:40  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/04/01  16:23:17  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:16:03  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/03/12  16:15:54  Hans_Graves
 * 	Added SLIB_PARAM_FILEBUFSIZE param
 * 	[1996/03/12  15:54:22  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/03/08  18:46:49  Hans_Graves
 * 	Added SlibGetParamString()
 * 	[1996/03/08  18:34:51  Hans_Graves]
 * 
 * Revision 1.1.2.6  1996/02/07  23:23:59  Hans_Graves
 * 	Added SEEK_EXACT. Fixed most frame counting problems.
 * 	[1996/02/07  23:20:37  Hans_Graves]
 * 
 * Revision 1.1.2.5  1996/02/06  22:54:08  Hans_Graves
 * 	Seek fix-ups. More accurate MPEG frame counts.
 * 	[1996/02/06  22:45:21  Hans_Graves]
 * 
 * Revision 1.1.2.4  1996/02/02  17:36:05  Hans_Graves
 * 	Enhanced audio info. Cleaned up API
 * 	[1996/02/02  17:29:49  Hans_Graves]
 * 
 * Revision 1.1.2.3  1996/01/15  16:26:32  Hans_Graves
 * 	Added Audio Params
 * 	[1996/01/15  15:48:20  Hans_Graves]
 * 
 * Revision 1.1.2.2  1996/01/11  16:17:35  Hans_Graves
 * 	First time under SLIB
 * 	[1996/01/11  16:11:45  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include <stdio.h>
#ifdef WIN32
#include  <time.h>
#include  <sys/timeb.h>
#else
#include  <sys/time.h>
#endif /* WIN32 */
#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"

#ifdef _SLIBDEBUG_
#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

static float _version       = 2.10F;
static char _version_date[] = { __DATE__ };

SlibTime_t slibGetSystemTime()
{
  SlibTime_t mstime;
#ifdef WIN32
  struct _timeb t ;
  _ftime(&t);
  mstime = (SlibTime_t)(t.time * 1000 + t.millitm);
#else
  struct timeval t;
  struct timezone tz;

  gettimeofday(&t, &tz);
  mstime = (SlibTime_t)(t.tv_sec * 1000 + t.tv_usec / 1000);
#endif
  return(mstime);
}

qword SlibGetFrameNumber(SlibHandle_t handle, SlibStream_t stream)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info && Info->FramesPerSec>0.0F)
    return(slibTimeToFrame(Info, Info->VideoTimeStamp
                                 +(Info->VideoFrameDuration/200)));
  else
    return((qword)-1);
}

SlibTime_t SlibGetVideoTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->VideoTimeStamp);
}

SlibTime_t SlibGetAudioTime(SlibHandle_t handle, SlibStream_t stream)
{
  if (!handle)
    return(0);
  return((long)((SlibInfo_t *)handle)->AudioTimeStamp);
}

SlibBoolean_t SlibCanSetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibBoolean_t SlibCanGetParam(SlibHandle_t handle, SlibStream_t stream,
                              SlibParameter_t param)
{
  return(TRUE);
}

SlibStatus_t SlibSetParamInt(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, long value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  long actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_, printf("SlibSetParamInt(SLIB_PARAM_FPS)\n") );
          status=SlibSetParamFloat(handle, stream, param, (float)value);
          break;
    case SLIB_PARAM_BITRATE:
          _SlibDebug(_DEBUG_,
              printf("SlibSetParamInt(SLIB_PARAM_BITRATE, %d)\n", value) );
          if (stream==SLIB_STREAM_MAINAUDIO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                   value);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                   value);
          else /* setting overall bitrate: try to calc best audio+video rates */
          {
            long vbitrate=value;
            /* spread total bitrate across all streams */
            if (Info->AudioStreams)
            {
              long abitrate=Info->VideoStreams ? (value*Info->Channels)/10 
                                            : value;
              /* don't set bitrates higher than necessary */
              if (Info->Channels==1 && abitrate>112*1000)
                abitrate=112*1000;
              else if (abitrate>192*1000)
                abitrate=192*1000;
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE,
                                abitrate);
              abitrate=SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE);
              vbitrate=value-abitrate; /* subtract bitrate allocated to audio */
            }
            if (Info->VideoStreams)
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                  vbitrate);
            slibValidateBitrates(Info);  /* check the bitrate setting */
            if (Info->VideoStreams && Info->TotalBitRate>value)
            {
              /*
               * Since the total bitrate is over the desired bitrate
               * subtract the difference from the video bitrate
               */
              vbitrate=Info->VideoBitRate-(Info->TotalBitRate-value);
              status=SlibSetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE,
                                     vbitrate);
            }
          }
          slibValidateBitrates(Info);
          actvalue=Info->TotalBitRate;
          _SlibDebug(_DEBUG_,
            printf("MuxBitRate=%d TotalBitRate=%d abitrate=%d vbitrate=%d\n",
               Info->MuxBitRate, Info->TotalBitRate, 
                SlibGetParamInt(handle, stream, SLIB_PARAM_AUDIOBITRATE),
                SlibGetParamInt(handle, stream, SLIB_PARAM_VIDEOBITRATE) ) );
          break;
    case SLIB_PARAM_VIDEOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITRATE, %d)\n", value) );
          if (Info->Svh)
          {
            SvSetParamInt(Info->Svh, SV_PARAM_BITRATE, value);
            actvalue=(long)SvGetParamInt(Info->Svh, SV_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->VideoBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_VIDEOSTREAMS:
          if (Info->VideoStreams!=(int)value)
          {
            Info->VideoStreams=(int)value;
            if (Info->VideoStreams)
              slibAddPin(Info, SLIB_DATA_VIDEO, "Video");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_VIDEO);
              slibRemovePin(Info, SLIB_DATA_VIDEO);
            }
          }
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONALG, value);
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_ALGFLAGS, value);
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH, value);
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH, value);
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTI, value);
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTP, value);
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUANTB, value);
          break;
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_KEYSPACING, value);
          break;
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING, value);
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FRAMETYPE, value);
          break;
    case SLIB_PARAM_VIDEOPROGRAM:
          Info->VideoPID=(int)value;
          break;
    case SLIB_PARAM_AUDIOPROGRAM:
          Info->AudioPID=(int)value;
          break;
    case SLIB_PARAM_VIDEOMAINSTREAM:
          Info->VideoMainStream=(int)value;
          break;
    case SLIB_PARAM_AUDIOMAINSTREAM:
          Info->AudioMainStream=(int)value;
          break;
    case SLIB_PARAM_WIDTH:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_WIDTH)\n") );
          Info->Width=(short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biWidth=Info->Width;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biWidth=Info->Width;
          if (Info->VideoFormat)
            Info->VideoFormat->biWidth=Info->Width;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_STRIDE)\n") );
          Info->Stride=(long)value;
          if (Info->Sch && Info->Mode==SLIB_MODE_DECOMPRESS)
            SconSetParamInt(Info->Sch, SCON_OUTPUT, SCON_PARAM_STRIDE, Info->Stride);
          break;
    case SLIB_PARAM_HEIGHT:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_HEIGHT)\n") );
          Info->Height=(short)value<0 ? (short)-value : (short)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CompVideoFormat)
            Info->CompVideoFormat->biHeight=Info->Height;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biHeight=Info->Height;
          if (Info->VideoFormat)
            Info->VideoFormat->biHeight=(short)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOFORMAT:
          _SlibDebug(_DEBUG_,
             printf("SlibSetParamInt(SLIB_PARAM_VIDEOFORMAT, '%c%c%c%c')\n",
              value&0xFF, (value>>8)&0xFF, (value>>16)&0xFF,(value>>24)&0xFF) );
          if (Info->VideoFormat)
            Info->VideoFormat->biCompression=(dword)value;
#if 0
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biCompression=(dword)value;
#endif
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_VIDEOBITS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamInt(SLIB_PARAM_VIDEOBITS, %d)\n", value) );
          if (Info->VideoFormat)
            Info->VideoFormat->biBitCount=(word)value;
          if (Info->Mode==SLIB_MODE_COMPRESS && Info->CodecVideoFormat)
            Info->CodecVideoFormat->biBitCount=(dword)value;
          return(slibValidateVideoParams(Info));
    case SLIB_PARAM_AUDIOSTREAMS:
          if (Info->AudioStreams!=(int)value)
          {
            Info->AudioStreams=(int)value;
            if (Info->AudioStreams)
              slibAddPin(Info, SLIB_DATA_AUDIO, "Audio");
            else
            {
              slibPinPrepareReposition(Info, SLIB_DATA_AUDIO);
              slibRemovePin(Info, SLIB_DATA_AUDIO);
            }
          }
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          _SlibDebug(_DEBUG_,
            printf("SlibSetParamInt(SLIB_PARAM_AUDIOBITRATE, %d)\n", value) );
          if (Info->Sah)
          {
            SaSetParamInt(Info->Sah, SA_PARAM_BITRATE, value);
            actvalue=(long)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          }
          if (actvalue>0)
            Info->AudioBitRate=actvalue;
          slibValidateBitrates(Info);
          break;
    case SLIB_PARAM_AUDIOCHANNELS:
          if (Info->Mode==SLIB_MODE_COMPRESS ||
              Info->AudioType==SLIB_TYPE_AC3_AUDIO)
          {
            Info->Channels=value;
            if (Info->AudioFormat)
              Info->AudioFormat->nChannels=(word)value;
            SaSetParamInt(Info->Sah, SA_PARAM_CHANNELS, value);
          }
          actvalue=Info->Channels;
          break;
    case SLIB_PARAM_SAMPLESPERSEC:
          {
            unsigned dword nativesps;
            Info->SamplesPerSec=value;
            nativesps=value;
#ifdef MPEG_SUPPORT
            if (SlibTypeIsMPEG(Info->Type))
            {
              /* choose a MPEG supported native sample rate */
              if (value%11025 == 0) /* multiples of 11025 can be converted */
                nativesps=44100;
              else if (value==48000)
                nativesps=48000;
              else if (value%8000 == 0) /* multiples of 8000 can be converted */
                nativesps=32000;
            }
#endif /* MPEG_SUPPORT */
            if (Info->AudioFormat)
              Info->AudioFormat->nSamplesPerSec=nativesps;
          }
          break;
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            Info->AudioFormat->nSamplesPerSec=(dword)value;
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          Info->BitsPerSample=value;
          if (Info->AudioFormat && value==16)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            Info->AudioFormat->wBitsPerSample=(word)value;
          break;
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_QUALITY, (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FILESIZE:
          Info->FileSize=(unsigned long)value;
          break;
    case SLIB_PARAM_FILEBUFSIZE:
          Info->FileBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_COMPBUFSIZE:
          if (value<=0)
            Info->CompBufSize=(unsigned dword)2*1024; /* default */
          else
            Info->CompBufSize=(unsigned dword)value;
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_PACKETSIZE, value);
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_FORMATEXT, value);
          break;
    case SLIB_PARAM_OVERFLOWSIZE:
          Info->OverflowSize=(unsigned long)value;
          break;
    case SLIB_PARAM_DEBUG:
          Info->dbg=(void *)value;
          if (Info->Svh)
            SvSetParamInt(Info->Svh, SV_PARAM_DEBUG, value);
          if (Info->Sah)
            SaSetParamInt(Info->Sah, SA_PARAM_DEBUG, value);
          break;
    default:
          return(SlibErrorUnsupportedParam);
  }
  if (actvalue!=value)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
         printf("SlibSetParamFloat() SettingNotEqual: %ld(req) != %ld(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamLong(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param, qword value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  qword actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamLong(stream=%d, param=%d, %ld)\n",
                   stream, param, value) );
  /* this needs to be implemented */
  return(SlibSetParamInt(handle, stream, param, (long)value));
}

SlibStatus_t SlibSetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                               SlibParameter_t param, float value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  float actvalue=value;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_FPS:
          _SlibDebug(_DEBUG_,
                printf("SlibSetParamFloat(SLIB_PARAM_FPS)\n") );
          if (Info->Svh)
          {
            SvSetParamFloat(Info->Svh, SV_PARAM_FPS, value);
            actvalue=SvGetParamFloat(Info->Svh, SV_PARAM_FPS);
          }
          if (actvalue>0.0F)
            Info->FramesPerSec=actvalue;
          break;
    default:
          return(SlibSetParamInt(handle, stream, param, (long)value));
  }
  if (actvalue>value+(float)0.0000001 ||
      actvalue<value-(float)0.0000001)
  {
    _SlibDebug(_DEBUG_ || _WARN_, 
        printf("SlibSetParamFloat() SettingNotEqual: %.3f(req) != %.3f(act)\n",
                     value, actvalue) );
    return(SlibErrorSettingNotEqual);
  }
  return(status);
}

SlibStatus_t SlibSetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                 SlibParameter_t param, SlibBoolean_t value)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SlibSetParamFloat()\n") );
  switch (param)
  {
    case SLIB_PARAM_STATS:
          if (value)
          {
            if (Info->stats==NULL)
            {
              Info->stats = (SlibStats_t *)ScAlloc(sizeof(SlibStats_t));
              if (Info->stats==NULL)
                return(SlibErrorMemory);
              SlibSetParamBoolean(handle, stream, SLIB_PARAM_STATS_RESET, TRUE);
            }
            else
              Info->stats->StartTime=slibGetSystemTime();
            Info->stats->Record=TRUE;
          }
          else if (Info->stats)
          {
            Info->stats->Record=FALSE;
            Info->stats->StopTime=slibGetSystemTime();
          }
          break;
    case SLIB_PARAM_STATS_RESET:
          if (Info->stats)
          {
            Info->stats->StartTime=Info->stats->StopTime=
                slibGetSystemTime();
            Info->stats->FramesProcessed=0;
            Info->stats->FramesSkipped=0;
          }
          break;
    case SLIB_PARAM_NEEDACCURACY:
          Info->NeedAccuracy = value ? TRUE : FALSE;
          if (Info->NeedAccuracy && slibHasTimeCode(Info))
          {
            /*
             * We'll seek toward the end of the file so the frame count
             * can be more accurately measured
             */
            if (!Info->VideoLengthKnown && Info->FileSize>0)
            {
              int minpercent=0, maxpercent=9900, lastpercent=0, trypercent=9900;
              int tries=0;
              unsigned qword newfilesize=Info->FileSize;
              qword stime = Info->VideoTimeStamp;
              SlibStatus_t status;
              if (SlibTimeIsInValid(stime)) stime=0;
              while (!Info->VideoLengthKnown && maxpercent-minpercent>200 && tries<5)
              {
                status=SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, 
                                  trypercent, SLIB_UNIT_PERCENT100, NULL);
                if (status==SlibErrorEndOfStream)
                  break;
                else if (status==SlibErrorNoBeginning)
                {
                  /* adjust the file size, data at end must be invalid */
                  newfilesize=(Info->FileSize*(trypercent/100))/100;
                  lastpercent=trypercent;
                  maxpercent=trypercent;
                  trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                }
                else if (status==SlibErrorNone)
                {
                  if (maxpercent-trypercent<=300)
                    break;
                  else
                  {
                    lastpercent=trypercent;
                    minpercent=trypercent;
                    trypercent=(minpercent+maxpercent)/2; /* try half way between min and max */
                  }
                }
                else
                {
                  lastpercent=trypercent;
                  trypercent=((trypercent-minpercent)*3)/4;
                }
                tries++;
              }
              Info->FileSize=newfilesize;
              while (status==SlibErrorNone && !Info->VideoLengthKnown)
                status=SlibSeek(handle, SLIB_STREAM_ALL, SLIB_SEEK_NEXT_KEY, 0);
              SlibSeekEx(handle, SLIB_STREAM_ALL, SLIB_SEEK_KEY, stime,
                                                  SLIB_UNIT_MS, NULL);
            }
          }
          break;
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTENCODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            SvSetParamBoolean(Info->Svh, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          if (Info->Sah)
            SvSetParamBoolean(Info->Sah, SV_PARAM_FASTDECODE, 
                                         (ScBoolean_t)value);
          break;
    case SLIB_PARAM_MOTIONALG:
          SlibSetParamInt(handle, stream, param, value?1:0);
          break;
    default:
         return(SlibErrorUnsupportedParam);
  }
  return(SlibErrorNone);
}

SlibStatus_t SlibSetParamStruct(SlibHandle_t handle, SlibStream_t stream,
                             SlibParameter_t param,
                             void *data, unsigned dword datasize)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  SlibStatus_t status=SlibErrorNone;
  if (!handle)
    return(SlibErrorBadHandle);
  if (data==NULL || datasize==0)
    return(SlibErrorBadArgument);
  _SlibDebug(_DEBUG_, printf("SlibSetParamStruct(stream=%d, param=%d, data=%p datasize=%ld)\n",
                   stream, param, data, datasize) );
  switch (param)
  {
    case SLIB_PARAM_VIDEOFORMAT:
         {
           BITMAPINFOHEADER *bmh=(BITMAPINFOHEADER *)data;
           _SlibDebug(_DEBUG_,
             printf("SlibSetParamStruct(SLIB_PARAM_VIDEOFORMAT)\n") );
           if (Info->VideoFormat==NULL || Info->VideoFormat->biSize<datasize)
           {
             ScFree(Info->VideoFormat);
             Info->VideoFormat=NULL;
           }
           if (Info->VideoFormat==NULL)
             Info->VideoFormat=(BITMAPINFOHEADER *)ScAlloc(datasize);
           Info->Width=(word)bmh->biWidth;
           Info->Height=abs(bmh->biHeight);
           if (Info->VideoFormat)
           {
             memcpy(Info->VideoFormat, bmh, datasize);
             return(slibValidateVideoParams(Info));
           }
           else
             return(SlibErrorMemory);
         }
    default:
         return(SlibErrorUnsupportedParam);
  }
  /* this needs to be implemented */
  return(SlibErrorNone);
}

long SlibGetParamInt(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(0);
  switch (param)
  {
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return((long)Info->AudioType);
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return((long)Info->VideoType);
          else
            return((long)Info->Type);
          break;
    case SLIB_PARAM_FPS:
          return((long)Info->FramesPerSec);
          break;
    case SLIB_PARAM_BITRATE:
          return((long)Info->TotalBitRate);
    case SLIB_PARAM_VIDEOBITRATE:
          return((long)Info->VideoBitRate);
    case SLIB_PARAM_WIDTH:
          return((long)Info->Width);
    case SLIB_PARAM_HEIGHT:
          return((long)Info->Height);
    case SLIB_PARAM_STRIDE:
          return((long)Info->Stride);
    case SLIB_PARAM_NATIVEWIDTH:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biWidth);
          else
            return((long)Info->Width);
    case SLIB_PARAM_NATIVEHEIGHT:
          if (Info->CompVideoFormat)
            return((long)Info->CompVideoFormat->biHeight);
          else
            return((long)Info->Height);
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          {
            long format=(long)SvGetParamInt(Info->Svh, SV_PARAM_NATIVEFORMAT);
            if (format==0)
              format=Info->CodecVideoFormat
                             ? Info->CodecVideoFormat->biCompression
                             : Info->VideoFormat->biCompression;
            return(format);
          }
    case SLIB_PARAM_IMAGESIZE:
          return((long)Info->ImageSize);
    case SLIB_PARAM_MININPUTSIZE:
          {
            long size=0;
            if (Info->Mode==SLIB_MODE_COMPRESS)
            {
              if (slibHasVideo(Info))
                size+=Info->ImageSize;
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=480;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            else if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_H263:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                       break;
                  default:
                       size+=Info->VideoBitRate>0?(Info->VideoBitRate/8):(64*1024);
                }
              if (slibHasAudio(Info))
                switch (Info->AudioType)
                {
                  case SLIB_TYPE_G723:
                       size+=(Info->AudioBitRate>=6000)?24:20;
                       break;
                  default:
                       if (Info->AudioFormat)
                         size+=Info->AudioFormat->nBlockAlign;
                }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_INPUTSIZE:
          {
            long size=0;
            size+=SlibGetParamInt(handle, stream, SLIB_PARAM_MININPUTSIZE);
            if (size<=8) size=8*1024;
            if (Info->Mode==SLIB_MODE_DECOMPRESS)
            {
              if (slibHasVideo(Info))
                switch (Info->Type) /* add in bytes for header */
                {
                  case SLIB_TYPE_AVI:      size+=64; break;
                }
              if (slibHasAudio(Info))
              {
                if (!Info->HeaderProcessed) /* add in header */
                  switch (Info->Type)
                  {
                    case SLIB_TYPE_PCM_WAVE: size+=40; break;
                  }
              }
            }
            return(size);
          }
          break;
    case SLIB_PARAM_VIDEOFRAME:
          if (Info->FramesPerSec)
            return((long)slibTimeToFrame(Info, Info->VideoTimeStamp
                                               +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_FRAMEDURATION:
          if (Info->FramesPerSec)
            return((long)(10000000L/Info->FramesPerSec));
          else
            return((long)0);
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biCompression);
          else
            return(0L);
          break;
    case SLIB_PARAM_VIDEOBITS:
          if (Info->VideoFormat)
            return((long)Info->VideoFormat->biBitCount);
          else
            return(0L);
    case SLIB_PARAM_VIDEOPROGRAM:
          return((long)Info->VideoPID);
    case SLIB_PARAM_AUDIOPROGRAM:
          return((long)Info->AudioPID);
    case SLIB_PARAM_VIDEOMAINSTREAM:
          return((long)Info->VideoMainStream);
    case SLIB_PARAM_AUDIOMAINSTREAM:
          return((long)Info->AudioMainStream);
    case SLIB_PARAM_KEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_KEYSPACING));
          else
            return((long)Info->KeySpacing);
    case SLIB_PARAM_SUBKEYSPACING:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_SUBKEYSPACING));
          else
            return((long)Info->SubKeySpacing);
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wFormatTag);
          else
            return(0);
          break;
    case SLIB_PARAM_AUDIOBITRATE:
          if (Info->AudioBitRate==0 && Info->Sah)
            Info->AudioBitRate=(dword)SaGetParamInt(Info->Sah, SA_PARAM_BITRATE);
          return((long)Info->AudioBitRate);
    case SLIB_PARAM_VIDEOSTREAMS:
          return((long)Info->VideoStreams);
    case SLIB_PARAM_AUDIOSTREAMS:
          return((long)Info->AudioStreams);
    case SLIB_PARAM_AUDIOCHANNELS:
          return((long)Info->Channels);
    case SLIB_PARAM_SAMPLESPERSEC:
          return((long)Info->SamplesPerSec);
    case SLIB_PARAM_NATIVESAMPLESPERSEC:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->nSamplesPerSec);
          break;
    case SLIB_PARAM_BITSPERSAMPLE:
          return((long)Info->BitsPerSample);
    case SLIB_PARAM_NATIVEBITSPERSAMPLE:
          if (Info->AudioFormat)
            return((long)Info->AudioFormat->wBitsPerSample);
          break;
    case SLIB_PARAM_FILESIZE:
          return((long)Info->FileSize);
    case SLIB_PARAM_FILEBUFSIZE:
          return((long)Info->FileBufSize);
    case SLIB_PARAM_COMPBUFSIZE:
          return((long)Info->CompBufSize);
    case SLIB_PARAM_OVERFLOWSIZE:
          return((long)Info->OverflowSize);
    case SLIB_PARAM_VIDEOQUALITY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUALITY));
          break;
    case SLIB_PARAM_AUDIOQUALITY:
          if (Info->Sah)
            return((long)SaGetParamInt(Info->Sah, SA_PARAM_QUALITY));
          break;
    case SLIB_PARAM_VBVBUFFERSIZE:
          {
            dword vbv;
            if (Info->Svh)
              vbv=(dword)SvGetParamInt(Info->Svh, SV_PARAM_VBVBUFFERSIZE);
            if (vbv<=0)
              vbv=Info->VBVbufSize;
            return(vbv);
          }
    case SLIB_PARAM_VBVDELAY:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_VBVDELAY));
          break;
    case SLIB_PARAM_MOTIONALG:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONALG));
          break;
    case SLIB_PARAM_ALGFLAGS:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_ALGFLAGS));
          break;
    case SLIB_PARAM_MOTIONSEARCH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONSEARCH));
          break;
    case SLIB_PARAM_MOTIONTHRESH:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_MOTIONTHRESH));
          break;
    case SLIB_PARAM_PACKETSIZE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_PACKETSIZE));
          break;
    case SLIB_PARAM_FORMATEXT:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FORMATEXT));
          break;
    case SLIB_PARAM_QUANTI:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTI));
          break;
    case SLIB_PARAM_QUANTP:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTP));
          break;
    case SLIB_PARAM_QUANTB:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_QUANTB));
          break;
    case SLIB_PARAM_FRAMETYPE:
          if (Info->Svh)
            return((long)SvGetParamInt(Info->Svh, SV_PARAM_FRAMETYPE));
          break;
    case SLIB_PARAM_STATS_FPS:
          return((long)SlibGetParamFloat(handle, stream, SLIB_PARAM_STATS_FPS));
    default:
          return((long)SlibGetParamLong(handle, stream, param));
  }
  return(0);
}

qword SlibGetParamLong(SlibHandle_t handle, SlibStream_t stream,
                                          SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return((qword)0);
  switch (param)
  {
    case SLIB_PARAM_VIDEOFRAMES:
          if (Info->FramesPerSec)
            return(slibTimeToFrame(Info, Info->VideoLength
                                         +(Info->VideoFrameDuration/200)));
          break;
    case SLIB_PARAM_VIDEOLENGTH:
          return(Info->VideoLength);
    case SLIB_PARAM_AUDIOLENGTH:
          return((long)Info->AudioLength);
    case SLIB_PARAM_STATS_TIME:
          if (Info->stats)
          {
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            return((long)(Info->stats->StopTime-Info->stats->StartTime));
          }
          break;
    case SLIB_PARAM_STATS_FRAMESPROCESSED:
          if (Info->stats)
            return(Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_STATS_FRAMESSKIPPED:
          if (Info->stats)
            return(Info->stats->FramesSkipped);
          break;
    case SLIB_PARAM_STATS_FRAMES:
          if (Info->stats)
            return(Info->stats->FramesSkipped+
                   Info->stats->FramesProcessed);
          break;
    case SLIB_PARAM_TIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          break;
    case SLIB_PARAM_CALCTIMECODE:
          if (Info->Svh)
            return(SvGetParamInt(Info->Svh, SV_PARAM_CALCTIMECODE));
          break;
    case SLIB_PARAM_PTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioPTimeCode);
          else if (Info->VideoPTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoPTimeCode);
    case SLIB_PARAM_DTIMECODE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(Info->AudioDTimeCode);
          else if (Info->VideoDTimeCode==SLIB_TIME_NONE && Info->Svh &&
                   SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE)>0)
            return(SvGetParamInt(Info->Svh, SV_PARAM_TIMECODE));
          else
            return(Info->VideoDTimeCode);
    case SLIB_PARAM_PERCENT100:
          if (Info->FileSize>0)
          {
            ScBitstream_t *bs;
            SlibPosition_t pos=slibGetPinPosition(Info, SLIB_DATA_COMPRESSED);
            /* subtract all the unused data from the input position */
            pos-=slibDataOnPin(Info, SLIB_DATA_VIDEO);
            pos-=slibDataOnPin(Info, SLIB_DATA_AUDIO);
            if ((bs=SvGetDataSource(Info->Svh))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Video Codec unused bytes */
            if ((bs=SaGetDataSource(Info->Sah))!=NULL)
              pos-=ScBSBufferedBytesUnused(bs); /* Audio Codec unused bytes */
            if (pos>=(SlibPosition_t)Info->FileSize)
              return(10000);
            else if (pos>=0)
              return((pos*10000)/Info->FileSize);
            else
              return(0);
          }
          else
          {
            if (stream==SLIB_STREAM_MAINAUDIO &&
                   SlibTimeIsValid(Info->AudioTimeStamp) &&
                   Info->AudioLength>0)
              return((Info->AudioTimeStamp*10000)/Info->AudioLength);
            else if (SlibTimeIsValid(Info->VideoTimeStamp)
                      && Info->VideoLength>0)
              return((Info->VideoTimeStamp*10000)/Info->VideoLength);
          }
          return((qword)-1);
  }
  return((qword)0);
}

float SlibGetParamFloat(SlibHandle_t handle, SlibStream_t stream,
                        SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  switch (param)
  {
    case SLIB_PARAM_VERSION:
          return(_version);
  }
  if (!handle)
    return((float)0.0);
  switch (param)
  {
    case SLIB_PARAM_FPS:
          return((float)Info->FramesPerSec);
    case SLIB_PARAM_VIDEOASPECTRATIO:
          if (Info->Svh)
            return(SvGetParamFloat(Info->Svh, SV_PARAM_ASPECTRATIO));
          break;
    case SLIB_PARAM_STATS_FPS:
          if (Info->stats)
          {
            float fps=0.0F;
            if (Info->stats->Record) /* still recording */
              Info->stats->StopTime=slibGetSystemTime();
            if (Info->stats->StartTime<Info->stats->StopTime)
            {
              qword ellapsedtime=Info->stats->StopTime-Info->stats->StartTime;
              fps=(float)(Info->stats->FramesProcessed*1000)/ellapsedtime;
            }
            return(fps);
          }
          else
            return(0.0F);
  }
  return((float)SlibGetParamInt(handle, stream, param));
}

SlibBoolean_t SlibGetParamBoolean(SlibHandle_t handle, SlibStream_t stream,
                                  SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (!handle)
    return(SlibErrorBadHandle);
  switch (param)
  {
    case SLIB_PARAM_STATS:
          return(Info->stats ? Info->stats->Record : FALSE);
    case SLIB_PARAM_NEEDACCURACY:
          return((SlibBoolean_t)Info->NeedAccuracy);
    case SLIB_PARAM_FASTENCODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTENCODE));
          break;
    case SLIB_PARAM_FASTDECODE:
          if (Info->Svh)
            return((SlibBoolean_t)SvGetParamBoolean(Info->Svh, 
                                     SV_PARAM_FASTDECODE));
          break;
  }
  return(FALSE);
}

char *SlibGetParamString(SlibHandle_t handle, SlibStream_t stream,
                                              SlibParameter_t param)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  static char result[100];
  strcpy(result, "Unknown");
  switch (param)
  {
    case SLIB_PARAM_VERSION_DATE:
          return(_version_date);
          break;
  }
  if (!handle)
    return(result);
  switch (param)
  {
    case SLIB_PARAM_NATIVEVIDEOFORMAT:
          if (Info->CodecVideoFormat)
            switch(Info->CodecVideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_VIDEOFORMAT:
          if (Info->VideoFormat)
            switch(Info->VideoFormat->biCompression)
            {
              case BI_YUY2:
              case BI_DECYUVDIB:        strcpy(result, "YUV 4:2:2 Interleaved");
                                        break;
              case BI_BITFIELDS:        strcpy(result, "BITFIELDS");
                                        break;
              case BI_DECXIMAGEDIB:     sprintf(result, "XIMAGE %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
              case BI_YU12SEP:          strcpy(result, "YUV 4:1:1 Separated");
                                        break;
              case BI_YU16SEP:          strcpy(result, "YUV 4:2:2 Separated");
                                        break;
              case BI_RGB:              sprintf(result, "RGB %d",
                                           Info->VideoFormat->biBitCount);
                                        break;
            }
          break;
    case SLIB_PARAM_AUDIOFORMAT:
          if (Info->AudioFormat)
            switch (Info->AudioFormat->wFormatTag)
            {
              case WAVE_FORMAT_PCM:    strcpy(result, "PCM");
                                       break;
            }
          break;
    case SLIB_PARAM_TYPE:
          if (stream==SLIB_STREAM_MAINAUDIO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->AudioType));
          else if (stream==SLIB_STREAM_MAINVIDEO)
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->VideoType));
          else
            return(SlibQueryForDesc(SLIB_QUERY_TYPES, Info->Type));
          break;
  }
  return(result);
}

/*
** Name:    SlibValidateParams
** Purpose: Ensure that the the Video and Audio parameter settings are
**          valid and supported.
*/
SlibStatus_t SlibValidateParams(SlibHandle_t handle)
{
  SlibInfo_t *Info=(SlibInfo_t *)handle;
  if (Info->VideoStreams>0 && slibValidateVideoParams(Info)!=SlibErrorNone)
    return(slibValidateVideoParams(Info));
  if (Info->AudioStreams>0 && slibValidateAudioParams(Info)!=SlibErrorNone)
    return(slibValidateAudioParams(Info));
  if (Info->Svh)
  {
    SvStatus_t status;
    _SlibDebug(_DEBUG_, printf("SvQuery(%c%c%c%c,%d bits,%dx%d,%c%c%c%c,%d bits,%dx%d)\n",
                     (Info->CodecVideoFormat->biCompression)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>8)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>16)&0xFF,
                     (Info->CodecVideoFormat->biCompression>>24)&0xFF,
                      Info->CodecVideoFormat->biBitCount,
                      Info->CodecVideoFormat->biWidth,
                      Info->CodecVideoFormat->biHeight,
                     (Info->CompVideoFormat->biCompression)&0xFF,
                     (Info->CompVideoFormat->biCompression>>8)&0xFF,
                     (Info->CompVideoFormat->biCompression>>16)&0xFF,
                     (Info->CompVideoFormat->biCompression>>24)&0xFF,
                      Info->CompVideoFormat->biBitCount,
                      Info->CompVideoFormat->biWidth,
                      Info->CompVideoFormat->biHeight) );
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SvCompressQuery(Info->Svh, Info->CodecVideoFormat,
                                        Info->CompVideoFormat);
    else
      status=SvDecompressQuery(Info->Svh, Info->CompVideoFormat,
                                          Info->CodecVideoFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SvQuery failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  if (Info->Sah)
  {
    SaStatus_t status;
    if (Info->Mode==SLIB_MODE_COMPRESS)
      status=SaCompressQuery(Info->Sah, Info->AudioFormat,
                                        Info->CompAudioFormat);
    else
      status=SaDecompressQuery(Info->Sah, Info->CompAudioFormat,
                                          Info->AudioFormat);
    if (status!=NoErrors)
    {
      _SlibDebug(_WARN_, printf("SlibValidateParams() SaBegin failed\n");
                       ScGetErrorText(status,0,0) );
      return(SlibErrorUnsupportedFormat);
    }
  }
  return(SlibErrorNone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\pred.c ===
/* File: sv_h263_pred.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"
#ifndef USE_C
#include "perr.h"
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

static int roundtab[] = {0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2};


static void FindForwLumPredPB(SvH263CompressInfo_t *H263Info,
                              unsigned char *prev_ipol, int x_curr, int y_curr,
                              H263_MotionVector *fr, short *pred, int TRD, int TRB,
                              int bdx, int bdy, int bs, int comp);
void FindBiDirLumPredPB(short *recon_P, H263_MotionVector *fr, short *pred, int TRD,
			   int TRB, int bdx, int bdy, int nh, int nv);

void BiDirLumPredPB(H263_MB_Structure *recon_P, H263_MotionVector *fr,
					H263_MB_Structure *pred, int TRD, int TRB, int bdx, int bdy);

void FindBiDirChrPredPB(H263_MB_Structure *recon_P, int dx, int dy,
			   H263_MB_Structure *pred);
void FindBiDirLimits(int vec, int *start, int *stop, int nhv);
void FindBiDirChromaLimits(int vec, int *start, int *stop);
void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		       int xvec, int yvec, short *recon, short *pred, int bl);
static void DoPredChrom_P(SvH263CompressInfo_t *H263Info,
                          int x_curr, int y_curr, int dx, int dy,
                          H263_PictImage *curr, H263_PictImage *prev,
                          H263_MB_Structure *pred_error);
static void FindPred(SvH263CompressInfo_t *H263Info,
                     int x, int y, H263_MotionVector *fr, unsigned char *prev,
                     short *pred, int bs, int comp);
static void FindPredOBMC(SvH263CompressInfo_t *H263Info,
                  int x, int y, H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                  unsigned char *prev, short *pred, int comp, int PB);
static void ReconLumBlock_P(SvH263CompressInfo_t *H263Info,
                            int x, int y, H263_MotionVector *fr,
                            unsigned char *prev, short *data, int bs, int comp);
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data);
static void FindChromBlock_P(SvH263CompressInfo_t *H263Info,
                             int x_curr, int y_curr, int dx, int dy,
                             H263_PictImage *prev, H263_MB_Structure *data);

/**********************************************************************
 *
 *	Name:		Predict_P
 *	Description:    Predicts P macroblock in advanced or normal
 *                      mode
 *	
 *	Input:		pointers to current and previous frames
 *			and previous interpolated image,
 *                      position and motion vector array
 *	Returns:	pointer to MB_Structure of data to be coded
 *	Side effects:	allocates memory to MB_Structure
 *
 ***********************************************************************/
void sv_H263PredictP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *curr_image, H263_PictImage *prev_image,
                     unsigned char *prev_ipol, int x, int y,
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *pred_error)
{
  short curr[16][16];
  short pred[16][16];
  H263_MotionVector *fr0,*fr1,*fr2,*fr3,*fr4;
  int sum, dx, dy;
  int xmb, ymb;
#ifdef USE_C
  int m,n;
#endif

  xmb = x/H263_MB_SIZE+1;
  ymb = y/H263_MB_SIZE+1;

  fr0 = MV[0][ymb][xmb];
  fr1 = MV[1][ymb][xmb];
  fr2 = MV[2][ymb][xmb];
  fr3 = MV[3][ymb][xmb];
  fr4 = MV[4][ymb][xmb];

  /* Find MB in current image */
  sv_H263FindMB(H263Info, x, y, curr_image->lum, curr);


  /* Find prediction based on half pel MV */
  if (H263Info->advanced) {
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[0][0], 0, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[0][8], 1, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[8][0], 2, PB);
    FindPredOBMC(H263Info, x, y, MV, prev_ipol, &pred[8][8], 3, PB);
  }
  else
    FindPred(H263Info, x, y, fr0, prev_ipol, &pred[0][0], 16, 0);

  /* Do the actual prediction */
  if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
#ifndef USE_C
    sv_H263Sub256_S(&(curr[0][0]), &(pred[0][0]), &(pred_error->lum[0][0]), 16);
#else
    for (n = 0; n < H263_MB_SIZE; n++)
      for (m = 0; m < H263_MB_SIZE; m++)
	    pred_error->lum[n][m] = curr[n][m] - pred[n][m];
#endif
    dx = 2*fr0->x + fr0->x_half;
    dy = 2*fr0->y + fr0->y_half;
    dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
    dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );

    DoPredChrom_P(H263Info, x, y, dx, dy, curr_image, prev_image, pred_error);
  }
  else if (fr0->Mode == H263_MODE_INTER4V) {

#ifndef USE_C
  	  sv_H263Sub256_S(&(curr[0][0]), &(pred[0][0]), &(pred_error->lum[0][0]), 16);
#else
    for (n = 0; n < H263_MB_SIZE; n++)
      for (m = 0; m < H263_MB_SIZE; m++)
	    pred_error->lum[n][m] = curr[n][m] - pred[n][m];
#endif

    sum = 2*fr1->x + fr1->x_half + 2*fr2->x + fr2->x_half +
          2*fr3->x + fr3->x_half + 2*fr4->x + fr4->x_half ;
    dx = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

    sum = 2*fr1->y + fr1->y_half + 2*fr2->y + fr2->y_half +
          2*fr3->y + fr3->y_half + 2*fr4->y + fr4->y_half;
    dy = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

    DoPredChrom_P(H263Info, x, y, dx, dy, curr_image, prev_image, pred_error);
  }

  else
  {
    _SlibDebug(_WARN_, printf("Illegal Mode in Predict_P (pred.c)\n") );
  }
  return;
}


#ifdef USE_C /* replaced by svH263Ierr16 */
int sv_H263SADMBinteger(short *ii, short *act_block, int h_length, int min_sofar, int max_rtn)
{
  int i, sad = 0;
  short *kk;

  kk = act_block;
  i = 16;
  while (i--) {
    sad += (abs(*ii      - *kk     ) +
		    abs(*(ii+1 ) - *(kk+1) ) +
	        abs(*(ii+2)  - *(kk+2) ) +
			abs(*(ii+3 ) - *(kk+3) ) +
	        abs(*(ii+4)  - *(kk+4) ) +
			abs(*(ii+5 ) - *(kk+5) ) +
	        abs(*(ii+6)  - *(kk+6) ) +
			abs(*(ii+7 ) - *(kk+7) ) +
	        abs(*(ii+8)  - *(kk+8) ) +
			abs(*(ii+9 ) - *(kk+9) ) +
	        abs(*(ii+10) - *(kk+10)) +
		    abs(*(ii+11) - *(kk+11)) +
	        abs(*(ii+12) - *(kk+12)) +
			abs(*(ii+13) - *(kk+13)) +
	        abs(*(ii+14) - *(kk+14)) +
			abs(*(ii+15) - *(kk+15)) );

	/*  min_sofar = INT_MAX always */
    if (sad > min_sofar) return INT_MAX;

    ii += h_length;
    kk += 16;
  }
  return sad;
}
#endif

/***********************************************************************
 *
 *	Name:		Predict_B
 *	Description:    Predicts the B macroblock in PB-frame prediction
 *	
 *	Input:	        pointers to current frame, previous recon. frame,
 *                      pos. in image, MV-data, reconstructed macroblock
 *                      from image ahead
 *	Returns:        pointer to differential MB data after prediction
 *	Side effects:   allocates memory to MB_structure
 *
 ***********************************************************************/
void sv_H263PredictB(SvH263CompressInfo_t *H263Info,
            H263_PictImage *curr_image, H263_PictImage *prev_image,
			unsigned char *prev_ipol,int x, int y,
			H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
			H263_MB_Structure *recon_P, int TRD,int TRB,
			H263_MB_Structure *p_err, H263_MB_Structure *pred)
{
  int i,j,k;
  int sad, sad_min=INT_MAX, bdx=0, bdy=0;
  int start_x, start_y, end_x, end_y ;
  short curr[16][16];
  H263_MotionVector *f[5];
  int xvec, yvec, mvx, mvy;
#ifndef USE_C
  unsigned char *curCr, *curCb ;
#endif
  for(k=0; k<=4; k++) f[k]=MV[k][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1];

  /* Find MB in current image */
  sv_H263FindMB(H263Info, x, y, curr_image->lum, curr);

  if(f[0]->Mode == H263_MODE_INTER4V) {  /* Mode INTER4V */

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,0,0,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,0,0,8,1);
	FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,0,0,8,2);
	FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,0,0,8,3);
#ifndef USE_C
    sad_min = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#else
    sad_min = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#endif
	sad_min -= H263_PREF_PBDELTA_NULL_VEC;
    bdx = bdy = 0;

    /* Find forward prediction */
    /* Luma */
    for (j = -H263_DEF_PBDELTA_WIN; j <= H263_DEF_PBDELTA_WIN; j++) {
      for (i = -H263_DEF_PBDELTA_WIN; i <= H263_DEF_PBDELTA_WIN; i++) {

	    if(i != 0 || j != 0) {
   	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,i,j,8,0);
          FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,i,j,8,1);
	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,i,j,8,2);
	      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,i,j,8,3);
#ifndef USE_C
          sad = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#else
          sad = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#endif
	      if (sad < sad_min) { sad_min = sad; bdx = i; bdy = j; }
		}
      }
    }

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,8,1);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,8,2);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,8,3);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      xvec += TRB*(2*f[k]->x + f[k]->x_half)/TRD + bdx;
      yvec += TRB*(2*f[k]->y + f[k]->y_half)/TRD + bdy;
    }

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, i, j, prev_image, pred);

    /* Find bidirectional prediction */
    FindBiDirLumPredPB(&recon_P->lum[0][0],f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,0,0);
    FindBiDirLumPredPB(&recon_P->lum[0][8],f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,1,0);
    FindBiDirLumPredPB(&recon_P->lum[8][0],f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,0,1);
    FindBiDirLumPredPB(&recon_P->lum[8][8],f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,1,1);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      mvx = 2*f[k]->x + f[k]->x_half;
      mvy = 2*f[k]->y + f[k]->y_half;
      xvec += bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx;
      yvec += bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    }

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, i, j, pred);
  }
  else {  /* Mode INTER or INTER_Q */

    if( f[0]->Mode==H263_MODE_INTRA || f[0]->Mode==H263_MODE_INTRA_Q ||
       (f[0]->x==0 && f[0]->y==0 && f[0]->x_half==0 && f[0]->y_half==0))
	          bdx = bdy = 0;
    else{
      /* Find forward prediction */
      FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB,0,0,16,0);
#ifndef USE_C
      sad_min = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#else
      sad_min = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, INT_MAX, INT_MAX);
#endif
      sad_min -= H263_PREF_PBDELTA_NULL_VEC;
      bdx = bdy = 0;

	  start_x = start_y = -H263_DEF_PBDELTA_WIN;
	  end_x   = end_y   =  H263_DEF_PBDELTA_WIN;

      /* To keep things simple I turn off PB delta vectors at the edges */
      if(!H263Info->mv_outside_frame) {
         if (x == 0 || x == H263Info->pels - H263_MB_SIZE) start_x = end_x = 0;
         if (y == 0 || y == H263Info->lines - H263_MB_SIZE) start_y = end_y = 0;
      }

      for (j = start_y; j <= end_y; j++) {
        for (i = start_x; i <= end_x; i++) {
		  if(i || j) {
            FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],
				                                          TRD,TRB,i,j,16,0);
#ifndef USE_C				
            sad = sv_H263Ierr16_S(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#else
            sad = sv_H263SADMBinteger(&curr[0][0],&pred->lum[0][0], 16, sad_min, INT_MAX);
#endif
	        if (sad < sad_min) { sad_min = sad; bdx = i; bdy = j; }
	      }
        }
      }
    }

    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB, bdx,bdy,16,0);

    xvec = 4 * (TRB*(2*f[0]->x + f[0]->x_half) / TRD + bdx);
    yvec = 4 * (TRB*(2*f[0]->y + f[0]->y_half) / TRD + bdy);
    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, i, j, prev_image, pred);

    /* Find bidirectional prediction */
    BiDirLumPredPB(recon_P, f[0], pred, TRD, TRB, bdx, bdy);

    /* chroma vectors */
    mvx = 2*f[0]->x + f[0]->x_half;
    xvec = bdx == 0 ? (TRB-TRD) * mvx / TRD : TRB * mvx / TRD + bdx - mvx;
    xvec *= 4;

    mvy = 2*f[0]->y + f[0]->y_half;
    yvec = bdy == 0 ? (TRB-TRD) * mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    yvec *= 4;

    /* round values according to TABLE 16/H.263 */
    i = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    j = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, i, j, pred);
  }

  /* store PB-deltas */
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x = (short)bdx; /* is in half pel format */
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y = (short)bdy;
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x_half = 0;
  MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y_half = 0;

#ifndef USE_C
  /* Do the actual prediction */
  curCr  = curr_image->lum + x + y*H263Info->pels ;
  sv_H263Sub16_S(curCr, &(pred->lum[0][0]), &(p_err->lum[0][0]), H263Info->pels) ;

  y >>= 1;  x >>= 1;
  curCr  = curr_image->Cr + x + y*H263Info->cpels ;
  curCb  = curr_image->Cb + x + y*H263Info->cpels ;

  sv_H263Sub8_S(curCr, &(pred->Cr[0][0]), &(p_err->Cr[0][0]), H263Info->cpels);
  sv_H263Sub8_S(curCb, &(pred->Cb[0][0]), &(p_err->Cb[0][0]), H263Info->cpels);

#else
 /* Do the actual prediction */
  for (j = 0; j < H263_MB_SIZE; j++)
    for (i = 0; i < H263_MB_SIZE; i++)
      p_err->lum[j][i] =
	   *(curr_image->lum+x+i + (y+j)*H263Info->pels) - pred->lum[j][i];

  y >>= 1;
  x >>= 1;
  for (j = 0; j < H263_MB_SIZE>>1; j++)
    for (i = 0; i < H263_MB_SIZE>>1; i++) {
      p_err->Cr[j][i] = *(curr_image->Cr+x+i + (y+j)*H263Info->cpels) - pred->Cr[j][i];
      p_err->Cb[j][i] = *(curr_image->Cb+x+i + (y+j)*H263Info->cpels) - pred->Cb[j][i];
    }
#endif

  return ;
}

/***********************************************************************
 *
 *	Name:		MB_Recon_B
 *	Description:    Reconstructs the B macroblock in PB-frame
 *                      prediction
 *	
 *	Input:	        pointers previous recon. frame, pred. diff.,
 *                      pos. in image, MV-data, reconstructed macroblock
 *                      from image ahead
 *	Returns:        pointer to reconstructed MB data
 *	Side effects:   allocates memory to MB_structure
 *
 ***********************************************************************/

void sv_H263MBReconB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, H263_MB_Structure *diff,
                     unsigned char *prev_ipol,int x, int y,
                     H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                     H263_MB_Structure *recon_P,int TRD, int TRB,
                     H263_MB_Structure *recon_B,H263_MB_Structure *pred)
{
#if 1
  int j;
  unsigned qword *dpc ;
  unsigned UNALIGNED qword *dpa, *dpb;

  dpc = (unsigned qword *) &(recon_B->lum[0][0]);
  dpb = (unsigned qword *) &(pred->lum[0][0]);
  dpa = (unsigned qword *) &(diff->lum[0][0]);

  for (j = 0; j < 12; j++) {
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;

 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
 	*dpc++ = *dpb++ + *dpa++ ;
  }
#else
  int j,k;
  int dx, dy, bdx, bdy, mvx, mvy, xvec, yvec;
  H263_MotionVector *f[5];

  for (k = 0; k <= 4; k++)
    f[k] = MV[k][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1];

  bdx = MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->x;
  bdy = MV[5][y/H263_MB_SIZE+1][x/H263_MB_SIZE+1]->y;

  if (f[0]->Mode == H263_MODE_INTER4V) {  /* Mode INTER4V */
    /* Find forward prediction */

    /* Luma */
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[1],&pred->lum[0][0],TRD,TRB,bdx,bdy,8,0);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[2],&pred->lum[0][8],TRD,TRB,bdx,bdy,8,1);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[3],&pred->lum[8][0],TRD,TRB,bdx,bdy,8,2);
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[4],&pred->lum[8][8],TRD,TRB,bdx,bdy,8,3);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      xvec += TRB*(2*f[k]->x + f[k]->x_half)/TRD + bdx;
      yvec += TRB*(2*f[k]->y + f[k]->y_half)/TRD + bdy;
    }

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, dx, dy, prev_image, pred);

    /* Find bidirectional prediction */
    FindBiDirLumPredPB(&recon_P->lum[0][0], f[1], &pred->lum[0][0],
		       TRD, TRB, bdx, bdy, 0, 0);
    FindBiDirLumPredPB(&recon_P->lum[0][8], f[2], &pred->lum[0][8],
		       TRD, TRB, bdx, bdy, 1, 0);
    FindBiDirLumPredPB(&recon_P->lum[8][0], f[3], &pred->lum[8][0],
		       TRD, TRB, bdx, bdy, 0, 1);
    FindBiDirLumPredPB(&recon_P->lum[8][8], f[4], &pred->lum[8][8],
		       TRD, TRB, bdx, bdy, 1, 1);

    /* chroma vectors are sum of B luma vectors divided and rounded */
    xvec = yvec = 0;
    for (k = 1; k <= 4; k++) {
      mvx = 2*f[k]->x + f[k]->x_half;
      mvy = 2*f[k]->y + f[k]->y_half;
      xvec += bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx;
      yvec += bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    }

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, dx, dy, pred);
  }
  else {  /* Mode INTER or INTER_Q */
    /* Find forward prediction */
    FindForwLumPredPB(H263Info, prev_ipol,x,y,f[0],&pred->lum[0][0],TRD,TRB,
		      bdx,bdy,16,0);

    xvec = 4 * (TRB*(2*f[0]->x + f[0]->x_half) / TRD + bdx);
    yvec = 4 * (TRB*(2*f[0]->y + f[0]->y_half) / TRD + bdy);
    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindChromBlock_P(H263Info, x, y, dx, dy, prev_image, pred);

    /* Find bidirectional prediction */
    BiDirLumPredPB(recon_P, f[0], pred, TRD, TRB, bdx, bdy);

    /* chroma vectors */
    mvx = 2*f[0]->x + f[0]->x_half;
    xvec = bdx == 0 ? (TRB-TRD) * mvx / TRD : TRB * mvx / TRD + bdx - mvx;
    xvec *= 4;

    mvy = 2*f[0]->y + f[0]->y_half;
    yvec = bdy == 0 ? (TRB-TRD) * mvy / TRD : TRB * mvy / TRD + bdy - mvy;
    yvec *= 4;

    /* round values according to TABLE 16/H.263 */
    dx = sign(xvec)*(roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
    dy = sign(yvec)*(roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

    FindBiDirChrPredPB(recon_P, dx, dy, pred);
  }

  /* Reconstruction */
  for (j = 0; j < H263_MB_SIZE; j++)
    for (k = 0; k < H263_MB_SIZE; k++)
      recon_B->lum[j][k] = pred->lum[j][k] + diff->lum[j][k];

  for (j = 0; j < H263_MB_SIZE>>1; j++)
    for (k = 0; k < H263_MB_SIZE>>1; k++) {
      recon_B->Cr[j][k] = pred->Cr[j][k] + diff->Cr[j][k];
      recon_B->Cb[j][k] = pred->Cb[j][k] + diff->Cb[j][k];
    }
#endif

  return ;
}

/**********************************************************************
 *
 *	Name:	       FindForwLumPredPB
 *	Description:   Finds the forward luma  prediction in PB-frame
 *                     pred.
 *	
 *	Input:	       pointer to prev. recon. frame, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/

static void FindForwLumPredPB(SvH263CompressInfo_t *H263Info,
                       unsigned char *prev_ipol, int x_curr, int y_curr,
		               H263_MotionVector *fr, short *pred, int TRD, int TRB,
		               int bdx, int bdy, int bs, int comp)
{
  int i,j,i2,j2;
  int xvec,yvec,lx2;
  unsigned char *ptn ;

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) * 2;

  /* Luma */
  xvec = (TRB)*(2*fr->x + fr->x_half)/TRD + bdx;
  yvec = (TRB)*(2*fr->y + fr->y_half)/TRD + bdy;

  x_curr = (x_curr + ((comp&1)<<3)) * 2 + xvec;
  y_curr = (y_curr + ((comp&2)<<2)) * 2 + yvec;
  x_curr += (y_curr * lx2) ;

  ptn = prev_ipol + x_curr ;
  lx2 = (lx2 << 1) ;

#ifdef USE_C
  for (j = j2 = 0; j < bs; j++, j2 += lx2)
    for (i = i2 = 0; i < bs; i++, i2 += 2)
      *(pred+i+j*16) = *(ptn + i2 + j2);
#else
  if(bs == 16) {
     sv_H263Intpix16_S(ptn, pred, lx2, 16) ;
  }
  else {
    for (j = j2 = 0; j < bs; j++, j2 += lx2)
      for (i = i2 = 0; i < bs; i++, i2 += 2)
        *(pred+i+j*16) = *(ptn + i2 + j2);
  }
#endif

  return;
}

/**********************************************************************
 *
 *	Name:	       FindBiDirLumPredPB
 *	Description:   Finds the bi-dir. luma prediction in PB-frame
 *                     prediction
 *	
 *	Input:	       pointer to future recon. data, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/
void FindBiDirLumPredPB(short *recon_P, H263_MotionVector *fr, short *pred, int TRD,
			int TRB, int bdx, int bdy, int nh, int nv)
{
  int xstart,xstop,ystart,ystop;
  int xvec,yvec, mvx, mvy;

  mvx = 2*fr->x + fr->x_half;
  mvy = 2*fr->y + fr->y_half;

  xvec = (bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx);
  yvec = (bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy);

  /* Luma */

  FindBiDirLimits(xvec,&xstart,&xstop,nh);
  FindBiDirLimits(yvec,&ystart,&ystop,nv);

  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, recon_P,pred,16);

  return;
}

void BiDirLumPredPB(H263_MB_Structure *recon_P, H263_MotionVector *fr,
					H263_MB_Structure *pred,int TRD,int TRB,int bdx,int bdy)
{
  int xstart,xstop,ystart,ystop;
  int xvec,yvec, mvx, mvy;

  mvx = 2*fr->x + fr->x_half;
  mvy = 2*fr->y + fr->y_half;

  xvec = (bdx == 0 ? (TRB-TRD) *  mvx / TRD : TRB * mvx / TRD + bdx - mvx);
  yvec = (bdy == 0 ? (TRB-TRD) *  mvy / TRD : TRB * mvy / TRD + bdy - mvy);

  /* Luma */
  FindBiDirLimits(xvec,&xstart,&xstop,0);
  FindBiDirLimits(yvec,&ystart,&ystop,0);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[0][0],
	             &pred->lum[0][0],16);

  FindBiDirLimits(xvec,&xstart,&xstop,1);
  FindBiDirLimits(yvec,&ystart,&ystop,0);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[0][8],
	             &pred->lum[0][8],16);

  FindBiDirLimits(xvec,&xstart,&xstop,0);
  FindBiDirLimits(yvec,&ystart,&ystop,1);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[8][0],
	             &pred->lum[8][0],16);

  FindBiDirLimits(xvec,&xstart,&xstop,1);
  FindBiDirLimits(yvec,&ystart,&ystop,1);
  BiDirPredBlock(xstart,xstop,ystart,ystop,xvec,yvec, &recon_P->lum[8][8],
	             &pred->lum[8][8],16);
  return;
}

/**********************************************************************
 *
 *	Name:	       FindBiDirChrPredPB
 *	Description:   Finds the bi-dir. chroma prediction in PB-frame
 *                     prediction
 *	
 *	Input:	       pointer to future recon. data, current positon,
 *                     MV structure and pred. structure to fill
 *
 ***********************************************************************/

void FindBiDirChrPredPB(H263_MB_Structure *recon_P, int dx, int dy,
			H263_MB_Structure *pred)
{
  int xstart,xstop,ystart,ystop;

  FindBiDirChromaLimits(dx,&xstart,&xstop);
  FindBiDirChromaLimits(dy,&ystart,&ystop);

  BiDirPredBlock(xstart,xstop,ystart,ystop,dx,dy,
		 &recon_P->Cb[0][0], &pred->Cb[0][0],8);
  BiDirPredBlock(xstart,xstop,ystart,ystop,dx,dy,
		 &recon_P->Cr[0][0], &pred->Cr[0][0],8);

  return;
}

void FindBiDirLimits(int vec, int *start, int *stop, int nhv)
{
  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2 - nhv*8);
  *stop = mmin(7,15-(vec+1)/2 - nhv*8);

  return;
}

void FindBiDirChromaLimits(int vec, int *start, int *stop)
{
  /* limits taken from C loop in section G5 in H.263 */
  *start = mmax(0,(-vec+1)/2);
  *stop = mmin(7,7-(vec+1)/2);

  return;
}


#if 1
void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		    int xvec, int yvec, short *recon, short *pred, int bl)
{
  int i,j,pel;
  int xint, yint;
  int xh, yh;
  register short *ptn, *ptnd;

  xint = xvec>>1;
  xh = xvec - (xint << 1);
  yint = yvec>>1;
  yh = yvec - (yint << 1);

  ptn  =  recon + ystart*bl + xint + yint * bl;
  ptnd  = pred  + ystart*bl ;

  if (!xh && !yh) {
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
/*   *(ptnd + i) = (sv_H263lim255r_S(pel) + *(ptnd + i))>>1; */
	    *(ptnd + i) = ( *(ptn + i) + *(ptnd + i) )>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else if (!xh && yh) {
    yh *= bl ;
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	    pel = (*(ptn + i) + *(ptn + i + yh) + 1)>>1;
	    *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else if (xh && !yh) {
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	     pel = (*(ptn + i) + *(ptn + i + xh) + 1)>>1;
		 *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  else { /* xh && yh */
    yh *= bl ;
    for (j=ystart; j <= ystop; j++) {
      for (i=xstart; i <= xstop; i++) {
	     pel = (*(ptn + i) + *(ptn + i + yh) +
	            *(ptn + i + xh) + *(ptn + i + yh + xh)+2)>>2;
	     *(ptnd + i) = (pel + *(ptnd + i))>>1;
      }
      ptn  += bl;  ptnd += bl;
    }
  }
  return;
}

#else

void BiDirPredBlock(int xstart, int xstop, int ystart, int ystop,
		    int xvec, int yvec, int *recon, int *pred, int bl)
{
  int i,j,pel;
  int xint, yint;
  int xh, yh;

  xint = xvec>>1;
  xh = xvec - 2*xint;
  yint = yvec>>1;
  yh = yvec - 2*yint;

  if (!xh && !yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = *(recon +(j+yint)*bl + i+xint);
#ifndef USE_C
	*(pred + j*bl + i) = (sv_H263lim255r_S(pel)) + *(pred + j*bl + i))>>1;
#else
	*(pred + j*bl + i) = (mmin(255,mmax(0,pel)) + *(pred + j*bl + i))>>1;
#endif
      }
    }
  }
  else if (!xh && yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint+yh)*bl + i+xint) + 1)>>1;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  else if (xh && !yh) {
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint)*bl + i+xint+xh) + 1)>>1;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  else { /* xh && yh */
    for (j = ystart; j <= ystop; j++) {
      for (i = xstart; i <= xstop; i++) {
	pel = (*(recon +(j+yint)*bl + i+xint)       +
	       *(recon +(j+yint+yh)*bl + i+xint) +
	       *(recon +(j+yint)*bl + i+xint+xh) +
	       *(recon +(j+yint+yh)*bl + i+xint+xh)+2)>>2;
	*(pred + j*bl + i) = (pel + *(pred + j*bl + i))>>1;
      }
    }
  }
  return;
}

#endif
/**********************************************************************
 *
 *	Name:		DoPredChrom_P
 *	Description:	Does the chrominance prediction for P-frames
 *	
 *	Input:		motionvectors for each field,
 *			current position in image,
 *			pointers to current and previos image,
 *			pointer to pred_error array,
 *			(int) field: 1 if field coding
 *			
 *	Side effects:	fills chrom-array in pred_error structure
 *
 ***********************************************************************/
static void DoPredChrom_P(SvH263CompressInfo_t *H263Info,
                          int x_curr, int y_curr, int dx, int dy,
                          H263_PictImage *curr, H263_PictImage *prev,
                          H263_MB_Structure *pred_error)
{
  int ofy, lx;
  int xh, yh, ofyy;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb, *curCr, *curCb;
  int x, y, ofx;
#ifdef USE_C
  int ydiff,pel,m,n;
#endif

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  x  = x_curr>>1;
  y = y_curr>>1;
  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(pred_error->Cr[0][0]) ;
  ptnb = &(pred_error->Cb[0][0]) ;

  ofy   = (y + (dy >> 1))*lx + x + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  ofx   = x + y * H263Info->cpels ;
  curCr = curr->Cr + ofx ;
  curCb = curr->Cb + ofx ;

  if (!xh && !yh) {
#ifndef USE_C
    sv_H263SubCpy_S(curCr, preCr, ptnr, H263Info->cpels, lx) ;
    sv_H263SubCpy_S(curCb, preCb, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	     *(ptnr++) = (short)(*(curCr++) - *(preCr++));
	     *(ptnb++) = (short)(*(curCb++) - *(preCb++));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
#ifndef USE_C
    sv_H263Sub2Cpy_S(curCr, preCr, preCr + ofyy, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub2Cpy_S(curCb, preCb, preCb + ofyy, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
   *(ptnr++) = (short)(*(curCr++) - ((*(preCr + ofyy) + *(preCr++) + 1)>>1));
   *(ptnb++) = (short)(*(curCb++) - ((*(preCb + ofyy) + *(preCb++) + 1)>>1));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
   }
  else if (xh && !yh) {
#ifndef USE_C
    sv_H263Sub2Cpy_S(curCr, preCr, preCr + xh, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub2Cpy_S(curCb, preCb, preCb + xh, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	 *(ptnr++) = (short)(*(curCr++) - ((*(preCr + xh) + *(preCr++) + 1)>>1));

	 *(ptnb++) = (short)(*(curCb++) - ((*(preCb + xh) + *(preCb++) + 1)>>1));
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
#ifndef USE_C
    sv_H263Sub4Cpy_S(curCr, preCr, preCr + xh, preCr + ofyy,
		           preCr + xh + ofyy, ptnr, H263Info->cpels, lx) ;
    sv_H263Sub4Cpy_S(curCb, preCb, preCb + xh, preCb + ofyy,
		           preCb + xh + ofyy, ptnb, H263Info->cpels, lx) ;
#else
	ofx = H263Info->cpels - 8;
	ydiff = lx - 8;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
        pel = (short)(*(preCr + xh) + *(preCr + ofyy) +
 	                *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnr++) = (short)(*(curCr++) - pel);

        pel = (short)(*(preCb + xh) + *(preCb + ofyy)+
	                *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
	    *(ptnb++) = (short)(*(curCb++) - pel);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
	  curCr += ofx ;
	  curCb += ofx ;
    };
#endif
  }
  return;
}

/**********************************************************************
 *
 *	Name:		FindHalfPel
 *	Description:	Find the optimal half pel prediction
 *	
 *	Input:		position, vector, array with current data
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *
 ***********************************************************************/

void sv_H263FindHalfPel(SvH263CompressInfo_t *H263Info,
                        int x, int y, H263_MotionVector *fr, unsigned char *prev,
                        unsigned char *curr, int bs, int comp)
{
  int m, n;
  int start_x, start_y, stop_x, stop_y, new_x, new_y, lx;
  int AE, AE_min;
  int m2, n2, lx2, lx4, n16;
  unsigned char *ptn, *ptnn, *cur ;
  int curX,curY,minX,minY;

  cur = curr + x + y * H263Info->pels;

  start_x = -1;  stop_x = 1;
  start_y = -1;  stop_y = 1;

  new_x = x + fr->x;
  new_y = y + fr->y;

  new_x += ((comp&1)<<3);
  new_y += ((comp&2)<<2);

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= 0) start_x = 0;
    if ((new_y) <= 0) start_y = 0;
    if ((new_x) >= (H263Info->pels-bs))  stop_x = 0;
    if ((new_y) >= (H263Info->lines-bs)) stop_y = 0;
  }

  lx2 = (lx << 1);
  lx4 = (lx2 << 1);
  ptn = prev + (new_x<<1) + ((new_y<<1) * lx2);

  minX = minY =0;

#ifdef USE_C

  AE_min = 0;
  for (n = n2 = 0; n < bs; n++, n2 += lx4) {
    n16 = n<<4;
     /* Find absolute error */
    for (m = m2 = 0; m < bs; m++, m2 += 2)
       AE_min += abs(*(ptn + m2 + n2) - *(cur + m + n * H263Info->pels));
  }
  for(curY=start_y;curY<=stop_y;curY++){
    for(curX=start_x; curX<=stop_x;curX++) {

      if(curX || curY) {	
         ptnn = ptn + curY*lx2 + curX ;
         AE = 0;
         for (n = n2 = 0; n < bs; n++, n2 += lx4) {
           n16 = n<<4;
           /* Find absolute error */
           for (m = m2 = 0; m < bs; m++, m2 += 2)
  	         AE += abs(*(ptnn + m2 + n2) - *(cur + m + n * H263Info->pels));

           if(AE > AE_min) { AE = INT_MAX; break;}
         }
         /*
          * if (i == 0 && fr->x == 0 && fr->y == 0 && bs == 16)
          * AE -= PREF_NULL_VEC;
          */
         if (AE < AE_min) {
           AE_min = AE;
           minX = curX;
           minY = curY;
		 }
	  }
	}
  }

#else

  if(bs == 16){

    AE_min = sv_H263HalfPerr16_S(cur, ptn, H263Info->pels, lx4, INT_MAX);

    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {
	    if(curX || curY) {	
	      ptnn = ptn + curY*lx2 + curX ;
          if((AE = sv_H263HalfPerr16_S(cur, ptnn, H263Info->pels,
		                               lx4, AE_min)) < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
  } } } } }
  else if(bs == 8) {

    AE_min = sv_H263HalfPerr8_S(cur, ptn, H263Info->pels, lx4, INT_MAX);

    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {
	    if(curX || curY) {	
	      ptnn = ptn + curY*lx2 + curX ;
          if((AE = sv_H263HalfPerr8_S(cur, ptnn, H263Info->pels,
		                               lx4, AE_min)) < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
  } } } } }
  else{

    AE_min = 0;
    for (n = n2 = 0; n < bs; n++, n2 += lx4) {
      n16 = n<<4;
       /* Find absolute error */
      for (m = m2 = 0; m < bs; m++, m2 += 2)
         AE_min += abs(*(ptn + m2 + n2) - *(cur + m + n * H263Info->pels));
    }
    for(curY=start_y;curY<=stop_y;curY++){
	  for(curX=start_x; curX<=stop_x;curX++) {

	    if(curX || curY) {	
           ptnn = ptn + curY*lx2 + curX ;
           AE = 0;
           for (n = n2 = 0; n < bs; n++, n2 += lx4) {
             n16 = n<<4;
             /* Find absolute error */
             for (m = m2 = 0; m < bs; m++, m2 += 2)
    	         AE += abs(*(ptnn + m2 + n2) - *(cur + m + n * H263Info->pels));

	         if(AE > AE_min) { AE = INT_MAX; break;}
           }
          /*
           * if (i == 0 && fr->x == 0 && fr->y == 0 && bs == 16)
           * AE -= PREF_NULL_VEC;
           */
          if (AE < AE_min) {
            AE_min = AE;
            minX = curX;
            minY = curY;
  } } } } }

#endif

   /* Store optimal values */
  fr->min_error = (short)AE_min;
  fr->x_half = (short)minX;
  fr->y_half = (short)minY;

  return;

}

/**********************************************************************
 *
 *	Name:		AdvHalfPel
 *	Description:	Find the optimal half pel prediction for Advanced mode
 *	
 *	Input:		position, vector, array with current data
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *
 ***********************************************************************/

#ifndef USE_C
void sv_H263AdvHalfPel(SvH263CompressInfo_t *H263Info, int x, int y,
                             H263_MotionVector *fr0, H263_MotionVector *fr1,
                             H263_MotionVector *fr2, H263_MotionVector *fr3,
                             H263_MotionVector *fr4,
                             unsigned char *prev, unsigned char *curr,
                             int bs, int comp)
{
  int start_x, start_y, stop_x, stop_y, new_x, new_y, lx;
  unsigned int AE, AE_min, minER1, minER2, minER3, minER4;
  int lx2, lx4;
  unsigned char *ptn, *ptnn, *cur ;
  int curX,curY,minX,minY,minX1,minY1,minX2,minY2,minX3,minY3,minX4,minY4;
  unsigned int error[4];

  cur = curr + x + y * H263Info->pels;

  start_x = -1;  stop_x = 1;
  start_y = -1;  stop_y = 1;

  new_x = x + fr0->x;
  new_y = y + fr0->y;

  new_x += ((comp&1)<<3);
  new_y += ((comp&2)<<2);

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  /* Make sure that no addressing is outside the frame */
  if (!H263Info->mv_outside_frame) {
    if ((new_x) <= 0) start_x = 0;
    if ((new_y) <= 0) start_y = 0;
    if ((new_x) >= (H263Info->pels-bs))  stop_x = 0;
    if ((new_y) >= (H263Info->lines-bs)) stop_y = 0;
  }

  lx2 = (lx << 1);
  lx4 = (lx2 << 1);
  ptn = prev + (new_x<<1) + ((new_y<<1) * lx2);

  minX=minY=minX1=minY1=minX2=minY2=minX3=minY3=minX4=minY4=0;

  sv_H263HalfPerr4_S(cur, ptn, H263Info->pels, lx4, error);
  AE_min = error[0] + error[1] + error[2] + error[3] ;
  minER1 = error[0];
  minER2 = error[1];
  minER3 = error[2];
  minER4 = error[3];

  for(curY=start_y;curY<=stop_y;curY++){
    for(curX=start_x; curX<=stop_x;curX++) {
      if(curX || curY) {	
        ptnn = ptn + curY*lx2 + curX ;
        sv_H263HalfPerr4_S(cur,ptnn,H263Info->pels,lx4,error);
		AE = error[0] + error[1] + error[2] + error[3] ;
		if(AE < AE_min) {
             AE_min = AE;
             minX = curX;
             minY = curY;
		}
		if(error[0] < minER1) {
             minER1 = error[0];
             minX1  = curX;
             minY1  = curY;
		}
		if(error[1] < minER2) {
             minER2 = error[1];
             minX2  = curX;
             minY2  = curY;
		}
		if(error[2] < minER3) {
             minER3 = error[2];
             minX3  = curX;
             minY3  = curY;
		}
		if(error[3] < minER4) {
             minER4 = error[3];
             minX4  = curX;
             minY4  = curY;
		}
	  }
	}
  }

   /* Store optimal values */
  fr0->min_error = (short)AE_min;
  fr0->x_half = (short)minX;
  fr0->y_half = (short)minY;

  fr1->min_error = (short)minER1;
  fr1->x_half = (short)minX1;
  fr1->y_half = (short)minY1;

  fr2->min_error = (short)minER2;
  fr2->x_half = (short)minX2;
  fr2->y_half = (short)minY2;

  fr3->min_error = (short)minER3;
  fr3->x_half = (short)minX3;
  fr3->y_half = (short)minY3;

  fr4->min_error = (short)minER4;
  fr4->x_half = (short)minX4;
  fr4->y_half = (short)minY4;

  return;
}
#endif

/**********************************************************************
 *
 *	Name:		FindPred
 *	Description:	Find the prediction block
 *	
 *	Input:		position, vector, array for prediction
 *			pointer to previous interpolated luminance,
 *
 *	Side effects:	fills array with prediction
 *
 ***********************************************************************/

static void FindPred(SvH263CompressInfo_t *H263Info,
                     int x, int y, H263_MotionVector *fr, unsigned char *prev,
                     short *pred, int bs, int comp)
{
  register int m, n, m2, n2;
  int new_x, new_y, lx2;
  unsigned char *ptn;

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) << 1;

  new_x = ((x + fr->x + ((comp&1)<<3))<<1) + fr->x_half;
  new_y = ((y + fr->y + ((comp&2)<<2))<<1) + fr->y_half;
  new_x += (new_y * lx2) ;

  lx2 = (lx2 << 1) ;
  ptn = prev + new_x ;
  /* Fill pred. data */
#ifndef USE_C
  if(bs == 16) {
     sv_H263Intpix16_S(ptn, pred, lx2, 16) ;
  }
  else {
    for (n = n2 = 0; n < bs; n++, n2 += lx2)
      for (m = m2 = 0; m < bs; m++, m2 += 2)
        /* Find interpolated pixel-value */
        *(pred+m+n*16) = (int) *(ptn + m2 + n2);
  }
#else
  for (n = n2 = 0; n < bs; n++, n2 += lx2)
    for (m = m2 = 0; m < bs; m++, m2 += 2)
      /* Find interpolated pixel-value */
      *(pred+m+n*16) = (int) *(ptn + m2 + n2);
#endif
  return ;
}

/**********************************************************************
 *
 *	Name:		FindPredOBMC
 *	Description:	Find the OBMC prediction block
 *	
 *	Input:		position, vector, array for prediction
 *			pointer to previous interpolated luminance,
 *
 *	Returns:
 *	Side effects:	fills array with prediction
 *
 ***********************************************************************/


static void FindPredOBMC(SvH263CompressInfo_t *H263Info, int x, int y,
                  H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2],
                  unsigned char *prev, short *pred, int comp, int PB)
{
  register int m, n;
  int pc,pt,pb,pr,pl;
  int nxc,nxt,nxb,nxr,nxl;
  int nyc,nyt,nyb,nyr,nyl;
  int xit,xib,xir,xil;
  int yit,yib,yir,yil;
  int vect,vecb,vecr,vecl;
  int c8,t8,l8,r8;
  int ti8,li8,ri8;
  int xmb, ymb, lx;
  int m2, n2, lx2;
  register int *omc, *omt, *omb, *omr, *oml ;

  unsigned char *prevc, *prevt, *prevb, *prevr, *prevl;

  H263_MotionVector *fc,*ft,*fb,*fr,*fl;

  int Mc[8][8] = {
    {4,5,5,5,5,5,5,4},
    {5,5,5,5,5,5,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,6,6,6,6,5,5},
    {5,5,5,5,5,5,5,5},
    {4,5,5,5,5,5,5,4},
  };
  int Mt[8][8] = {
    {1,1,1,1,1,1,1,1},
    {0,0,1,1,1,1,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
  };
  int Mb[8][8] = {
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,1,1,1,1,0,0},
    {1,1,1,1,1,1,1,1},
  };
  int Mr[8][8] = {
    {0,0,0,0,0,0,0,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,1,1},
    {0,0,0,0,0,0,0,1},
  };
  int Ml[8][8] = {
    {1,0,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,1,0,0,0,0,0,0},
    {1,0,0,0,0,0,0,0},
  };
/*
  int Mt[8][8] = {
    {2,2,2,2,2,2,2,2},
    {1,1,2,2,2,2,1,1},
    {1,1,1,1,1,1,1,1},
    {1,1,1,1,1,1,1,1},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
  };
  int Mb[8][8] = {
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0},
    {1,1,1,1,1,1,1,1},
    {1,1,1,1,1,1,1,1},
    {1,1,2,2,2,2,1,1},
    {2,2,2,2,2,2,2,2},
  };
  int Mr[8][8] = {
    {0,0,0,0,1,1,1,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,2,2},
    {0,0,0,0,1,1,1,2},
  };
  int Ml[8][8] = {
    {2,1,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,2,1,1,0,0,0,0},
    {2,1,1,1,0,0,0,0},
  };
*/

  xmb = x/H263_MB_SIZE+1;
  ymb = y/H263_MB_SIZE+1;

  lx = (H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels);

  c8  = (MV[0][ymb][xmb]->Mode == H263_MODE_INTER4V ? 1 : 0);

  t8  = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTER4V ? 1 : 0);
  ti8 = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTRA ? 1 : 0);
  ti8 = (MV[0][ymb-1][xmb]->Mode == H263_MODE_INTRA_Q ? 1 : ti8);

  l8  = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTER4V ? 1 : 0);
  li8 = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTRA ? 1 : 0);
  li8 = (MV[0][ymb][xmb-1]->Mode == H263_MODE_INTRA_Q ? 1 : li8);

  r8  = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTER4V ? 1 : 0);
  ri8 = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTRA ? 1 : 0);
  ri8 = (MV[0][ymb][xmb+1]->Mode == H263_MODE_INTRA_Q ? 1 : ri8);

  if (PB) ti8 = li8 = ri8 = 0;

  switch (comp+1) {

  case 1:
    vect = (ti8 ? (c8 ? 1 : 0) : (t8 ? 3 : 0));
    yit  = (ti8 ? ymb : ymb - 1);
    xit = xmb;

    vecb = (c8 ? 3 : 0) ; yib = ymb; xib = xmb;

    vecl = (li8 ? (c8 ? 1 : 0) : (l8 ? 2 : 0));
    yil = ymb;
    xil = (li8 ? xmb : xmb-1);

    vecr = (c8 ? 2 : 0) ; yir = ymb; xir = xmb;

    /* edge handling */
    if (ymb == 1) {
      yit = ymb;
      vect = (c8 ? 1 : 0);
    }
    if (xmb == 1) {
      xil = xmb;
      vecl = (c8 ? 1 : 0);
    }
    break;

  case 2:
    vect = (ti8 ? (c8 ? 2 : 0) : (t8 ? 4 : 0));
    yit = (ti8 ? ymb : ymb-1);
    xit = xmb;

    vecb = (c8 ? 4 : 0) ; yib = ymb; xib = xmb;
    vecl = (c8 ? 1 : 0) ; yil = ymb; xil = xmb;

    vecr = (ri8 ? (c8 ? 2 : 0) : (r8 ? 1 : 0));
    yir = ymb;
    xir = (ri8 ? xmb : xmb+1);

    /* edge handling */
    if (ymb == 1) {
      yit = ymb;
      vect = (c8 ? 2 : 0);
    }
    if (xmb == H263Info->pels/16) {
      xir = xmb;
      vecr = (c8 ? 2 : 0);
    }
    break;

  case 3:
    vect = (c8 ? 1 : 0) ; yit = ymb  ; xit = xmb;
    vecb = (c8 ? 3 : 0) ; yib = ymb  ; xib = xmb;

    vecl = (li8 ? (c8 ? 3 : 0) : (l8 ? 4 : 0));
    yil = ymb;
    xil = (li8 ? xmb : xmb-1);

    vecr = (c8 ? 4 : 0) ; yir = ymb  ; xir = xmb;

    /* edge handling */
    if (xmb == 1) {
      xil = xmb;
      vecl = (c8 ? 3 : 0);
    }
    break;

  case 4:
    vect = (c8 ? 2 : 0) ; yit = ymb  ; xit = xmb;
    vecb = (c8 ? 4 : 0) ; yib = ymb  ; xib = xmb;
    vecl = (c8 ? 3 : 0) ; yil = ymb  ; xil = xmb;

    vecr = (ri8 ? (c8 ? 4 : 0) : (r8 ? 3 : 0));
    yir = ymb;
    xir = (ri8 ? xmb : xmb+1);

    /* edge handling */
    if (xmb == H263Info->pels/16) {
      xir = xmb;
      vecr = (c8 ? 4 : 0);
    }
    break;

  default:
    _SlibDebug(_WARN_, printf("Illegal block number in FindPredOBMC (pred.c)\n") );
    return;
    break;
  }

  fc = MV[c8 ? comp + 1: 0][ymb][xmb];

  ft = MV[vect][yit][xit];
  fb = MV[vecb][yib][xib];
  fr = MV[vecr][yir][xir];
  fl = MV[vecl][yil][xil];

  nxc = 2*x + ((comp&1)<<4); nyc = 2*y + ((comp&2)<<3);
  nxt = nxb = nxr = nxl = nxc;
  nyt = nyb = nyr = nyl = nyc;

  nxc += 2*fc->x + fc->x_half; nyc += 2*fc->y + fc->y_half;
  nxt += 2*ft->x + ft->x_half; nyt += 2*ft->y + ft->y_half;
  nxb += 2*fb->x + fb->x_half; nyb += 2*fb->y + fb->y_half;
  nxr += 2*fr->x + fr->x_half; nyr += 2*fr->y + fr->y_half;
  nxl += 2*fl->x + fl->x_half; nyl += 2*fl->y + fl->y_half;

#if 1
  /* Fill pred. data */
  lx2 = lx << 1 ;
  omc = &Mc[0][0] ; omt = &Mt[0][0] ; omb = &Mb[0][0] ;
  omr = &Mr[0][0] ; oml = &Ml[0][0] ;

  prevc = prev + nxc + nyc*lx2;
  prevt = prev + nxt + nyt*lx2;
  prevb = prev + nxb + nyb*lx2;
  prevr = prev + nxr + nyr*lx2;
  prevl = prev + nxl + nyl*lx2;

  lx2 <<= 1;
  for (n = n2 = 0; n < 4; n++, n2+=lx2) {

    /* Find interpolated pixel-value */
    for (m = 0, m2=n2; m < 4; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
      pt = *(prevt + m2) << (*omt++);
	  pl = *(prevl + m2) << (*oml++);

      *(pred + m + (n<<4)) = (pc+pt+pl+4)>>3;
    }	
	omr += 4;
	for (m = 4; m < 8; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
      pt = *(prevt + m2) << (*omt++);
	  pr = *(prevr + m2) << (*omr++);

      *(pred + m + (n<<4)) = (pc+pt+pr+4)>>3;
    }	
	oml += 4;
  }
  omb += 32;

  for (n = 4; n < 8; n++, n2+=lx2) {

    /* Find interpolated pixel-value */
    for (m = 0, m2=n2; m < 4; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
	  pb = *(prevb + m2) << (*omb++);
	  pl = *(prevl + m2) << (*oml++);

      *(pred + m + (n<<4)) = (pc+pb+pl+4)>>3;
    }	
	omr += 4;
	for (m = 4; m < 8; m++, m2+=2) {
      pc = *(prevc + m2) * (*omc++);
	  pb = *(prevb + m2) << (*omb++);
	  pr = *(prevr + m2) << (*omr++);

      *(pred + m + (n<<4)) = (pc+pb+pr+4)>>3;
    }	
	oml += 4;
  }
#else /* original */
  /* Fill pred. data */
  lx2 = lx << 1 ;
  omc = &Mc[0][0] ; omt = &Mt[0][0] ; omb = &Mb[0][0] ;
  omr = &Mr[0][0] ; oml = &Ml[0][0] ;

  for (n = n2 = 0; n < 8; n++,n2+=(lx2<<1)) {
    for (m = 0, m2=n2; m < 8; m++, m2 += 2) {
      /* Find interpolated pixel-value */
      pc = *(prev + nxc + m2 + nyc*lx2) * (*omc++);
      pt = *(prev + nxt + m2 + nyt*lx2) * (*omt++);
	  pb = *(prev + nxb + m2 + nyb*lx2) * (*omb++);
	  pr = *(prev + nxr + m2 + nyr*lx2) * (*omr++);
	  pl = *(prev + nxl + m2 + nyl*lx2) * (*oml++);

      *(pred + m + n*16) = (pc+pt+pb+pr+pl+4)>>3;
    }	
  }
#endif
  return;
}


/**********************************************************************
 *
 *	Name:		ReconMacroblock_P
 *	Description:	Reconstructs MB after quantization for P_images
 *	
 *	Input:		pointers to current and previous image,
 *			current slice and mb, and which mode
 *			of prediction has been used
 *	Returns:
 *	Side effects:
 *
 ***********************************************************************/
void sv_H263MBReconP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, unsigned char *prev_ipol,
                     H263_MB_Structure *diff, int x_curr, int y_curr,
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *recon_data)
{
  H263_MotionVector *fr0,*fr1,*fr2,*fr3,*fr4;
  short pred[16][16];
  int dx, dy, sum;
#ifdef USE_C
  int i,j;
#endif

  fr0 = MV[0][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];

  if (H263Info->advanced) {
    if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][0], 0, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][8], 1, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][0], 2, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][8], 3, PB);

#ifndef USE_C
      sv_H263Add256_S(&(diff->lum[0][0]),&(pred[0][0]));
#else
      for (j = 0; j < H263_MB_SIZE; j++)
  	    for (i = 0; i < H263_MB_SIZE; i++)
	       diff->lum[j][i] += pred[j][i];
#endif

      dx = 2*fr0->x + fr0->x_half;
      dy = 2*fr0->y + fr0->y_half;
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
    else if (fr0->Mode == H263_MODE_INTER4V) { /* Inter 8x8 */

      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][0], 0, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[0][8], 1, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][0], 2, PB);
      FindPredOBMC(H263Info, x_curr, y_curr, MV, prev_ipol, &pred[8][8], 3, PB);

#ifndef USE_C
      sv_H263Add256_S(&(diff->lum[0][0]),&(pred[0][0]));
#else
      for (j = 0; j < H263_MB_SIZE; j++)
	     for (i = 0; i < H263_MB_SIZE; i++)
	        diff->lum[j][i] += pred[j][i];
#endif

      fr1 = MV[1][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr2 = MV[2][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr3 = MV[3][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];
      fr4 = MV[4][y_curr/H263_MB_SIZE+1][x_curr/H263_MB_SIZE+1];

      sum = 2*fr1->x + fr1->x_half + 2*fr2->x + fr2->x_half +
	2*fr3->x + fr3->x_half + 2*fr4->x + fr4->x_half ;
      dx = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      sum = 2*fr1->y + fr1->y_half + 2*fr2->y + fr2->y_half +
	2*fr3->y + fr3->y_half + 2*fr4->y + fr4->y_half;
      dy = sign(sum)*(roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
  }
  else {
    if (fr0->Mode == H263_MODE_INTER || fr0->Mode == H263_MODE_INTER_Q) {
      /* Inter 16x16 */
      ReconLumBlock_P(H263Info, x_curr,y_curr,fr0,prev_ipol,&diff->lum[0][0],16,0);

      dx = 2*fr0->x + fr0->x_half;
      dy = 2*fr0->y + fr0->y_half;
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      ReconChromBlock_P(H263Info, x_curr, y_curr, dx, dy, prev_image, diff);
    }
  }

  memcpy(recon_data, diff, sizeof(H263_MB_Structure));
  return ;
}

/**********************************************************************
 *
 *	Name:		ReconLumBlock_P
 *	Description:	Reconstructs one block of luminance data
 *	
 *	Input:		position, vector-data, previous image, data-block
 *	Returns:
 *	Side effects:	reconstructs data-block
 *
 ***********************************************************************/
static void ReconLumBlock_P(SvH263CompressInfo_t *H263Info,
                            int x, int y, H263_MotionVector *fr,
                            unsigned char *prev, short *data, int bs, int comp)
{
  int x1, y1, lx2;
  unsigned char *ptn ;
#ifdef USE_C
  int m,n;
#endif

  lx2 = ((H263Info->mv_outside_frame ? H263Info->pels + (H263Info->long_vectors?64:32) : H263Info->pels)) << 1;

  x1 = ((x + fr->x) << 1) + fr->x_half + ((comp&1)<<4) ;
  y1 = ((y + fr->y) << 1) + fr->y_half + ((comp&2)<<3);
  x1 += (y1 * lx2) ;

  ptn = prev + x1 ;

#ifndef USE_C
  sv_H263Add16Skp_S(ptn, data, (2 * lx2)) ;
#else
/* int m, n; */
  lx2 = (lx2 <<1) - (bs << 1) ;	
  for (n = 0; n < bs; n++, ptn += lx2)
    for (m = 0; m < bs; m++, ptn += 2)
       *(data++) += (short)(*ptn);
#endif
  return;
}

/**********************************************************************
 *
 *	Name:		ReconChromBlock_P
 *	Description:   	Reconstructs chrominance of one block in P frame
 *	
 *	Input:	      	position, vector-data, previous image, data-block
 *	Returns:       	
 *	Side effects:	reconstructs data-block
 *
 ***********************************************************************/

#ifndef USE_C
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data)
{
  int ofy, lx;
  int xh, yh, ofyy, ydiff;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ((y_curr>>1) + (dy >> 1))*lx + (x_curr>>1) + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    sv_H263Add_S(preCr, ptnr, preCb, ptnb, lx);
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    sv_H263Avg2Add_S(preCr + ofyy, preCr, ptnr, preCb + ofyy, preCb, ptnb, lx);
  }
  else if (xh && !yh) {
    sv_H263Avg2Add_S(preCr + xh, preCr, ptnr, preCb + xh, preCb, ptnb, lx);
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
    sv_H263Avg4Add_S(preCr,preCr+xh,preCr+ofyy,preCr+xh+ofyy,ptnr,lx);
    sv_H263Avg4Add_S(preCb,preCb+xh,preCb+ofyy,preCb+xh+ofyy,ptnb,lx);
  }
  return;
}
#else
static void ReconChromBlock_P(SvH263CompressInfo_t *H263Info,
                              int x_curr, int y_curr, int dx, int dy,
                              H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;
  register short *ptnr, *ptnb;
  unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ((y_curr>>1) + (dy >> 1))*lx + (x_curr>>1) + (dx >> 1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	     *(ptnr++) += (short) *(preCr++);
		 *(ptnb++) += (short) *(preCb++);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
	    *(ptnb++) += (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) += (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
	n = 8 ;
    while(n--){
	  m = 8 ;
      while(m--) {
	    *(ptnr++) += (short)(*(preCr + xh) + *(preCr + ofyy) +
 	                       *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnb++) += (short)(*(preCb + xh) + *(preCb + ofyy)+
	                       *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  return;
}
#endif

/**********************************************************************
 *
 *	Name:		FindChromBlock_P
 *	Description:   	Finds chrominance of one block in P frame
 *	
 *	Input:	      	position, vector-data, previous image, data-block
 *
 ***********************************************************************/

#ifndef USE_C
static void FindChromBlock_P(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, int dx, int dy,
                             H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;

  register short *ptnr, *ptnb;
  register unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ( (y_curr>>1) + (dy>>1)) * lx + (x_curr>>1) + (dx>>1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh)     sv_H263Cpy_S(preCr, ptnr, preCb, ptnb, lx);
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
		*(ptnb++) = (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };

  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
    sv_H263Avg4Cpy_S(preCr,preCr+xh,preCr+ofyy,preCr+xh+ofyy,ptnr,lx);
    sv_H263Avg4Cpy_S(preCb,preCb+xh,preCb+ofyy,preCb+xh+ofyy,ptnb,lx);
  }
  return;
}

#else
void FindChromBlock_P(SvH263CompressInfo_t *H263Info, int x_curr, int y_curr, int dx, int dy,
		      H263_PictImage *prev, H263_MB_Structure *data)
{
  register int m,n;
  int ofy, lx;
  int xh, yh, ofyy, ydiff;

  register short *ptnr, *ptnb;
  register unsigned char *preCr, *preCb;

  lx = (H263Info->mv_outside_frame ? H263Info->pels/2 + (H263Info->long_vectors?32:16) : H263Info->pels/2);

  xh = dx & 1;
  yh = dy & 1;

  ptnr = &(data->Cr[0][0]) ;
  ptnb = &(data->Cb[0][0]) ;

  ydiff = lx - 8 ;

  ofy = ( (y_curr>>1) + (dy>>1)) * lx + (x_curr>>1) + (dx>>1) ;
  preCr = prev->Cr + ofy;
  preCb = prev->Cb + ofy ;

  if (!xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8;
      while(m--) {
	     *(ptnr++) = (short) *(preCr++);
		 *(ptnb++) = (short) *(preCb++);
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else if (!xh && yh) {
    ofyy = yh * lx ;
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + ofyy) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + ofyy) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };

  }
  else if (xh && !yh) {
    n = 8 ;
    while(n--) {
      m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr++) + 1)>>1;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb++) + 1)>>1;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  else { /* xh && yh */
    ofyy = yh * lx ;
	n = 8 ;
    while(n--){
	  m = 8 ;
      while(m--) {
	    *(ptnr++) = (short)(*(preCr + xh) + *(preCr + ofyy) +
	                      *(preCr + xh + ofyy) + *(preCr++) + 2)>>2;
	    *(ptnb++) = (short)(*(preCb + xh) + *(preCb + ofyy)+
	                      *(preCb + xh + ofyy) + *(preCb++) + 2)>>2;
      };
	  preCr += ydiff ;
	  preCb += ydiff ;
    };
  }
  return;
}
#endif
/**********************************************************************
 *
 *	Name:		ChooseMode
 *	Description:    chooses coding mode
 *	
 *	Input:	        pointer to original fram, min_error from
 *                      integer pel search, DQUANT
 *	Returns:        1 for Inter, 0 for Intra
 *
 ***********************************************************************/

#ifndef USE_C
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr,
					  int x_pos, int y_pos, int min_SAD, int *VARmb)
{
  x_pos += (y_pos*H263Info->pels) ;

  min_SAD -= 500;
  if((*VARmb=sv_H263VAR_S((curr+x_pos), H263Info->pels, min_SAD)) < min_SAD)
	  return H263_MODE_INTRA;
  else  return H263_MODE_INTER;
}
#else
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info,
                      unsigned char *curr, int x_pos, int y_pos, int min_SAD)
{
  register int m, n;
  int xdiff = H263Info->pels - H263_MB_SIZE;
  unsigned char *in;
  int MB_mean = 0, A = 0;

  x_pos = y_pos*H263Info->pels + x_pos ;
  in = curr + x_pos;

  m = H263_MB_SIZE;
  while (m--) {
    n = H263_MB_SIZE;
    while (n--) MB_mean += *in++;
    in += xdiff ;
  };
  MB_mean /= (H263_MB_SIZE*H263_MB_SIZE);

  in = curr + x_pos;
  m = H263_MB_SIZE;
  while (m--) {

    n = H263_MB_SIZE;
    while (n--) A += abs( *(in++) - MB_mean );
    in += xdiff ;
  };

  if (A < (min_SAD - 500))
    return H263_MODE_INTRA;
  else
    return H263_MODE_INTER;
}
#endif

int sv_H263ModifyMode(int Mode, int dquant)
{

  if (Mode == H263_MODE_INTRA) {
    if(dquant!=0)
      return H263_MODE_INTRA_Q;
    else
      return H263_MODE_INTRA;
  }
  else{
    if(dquant!=0)
      return H263_MODE_INTER_Q;
    else
      return Mode;
  }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1994                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SV_H263_PROTO_H_
#define _SV_H263_PROTO_H_

#include "sv_intrn.h"

#define svH263mputv(n, b)  ScBSPutBits(BSOut,b,n)
#define svH263mputb(b)     ScBSPutBit(BSOut,b?1:0)

void svH263Error(char *text);
/*
** sv_h263_getpic.c
*/
extern SvStatus_t sv_H263GetPicture(SvCodecInfo_t *Info);
/*
** sv_h263_gethdr.c
*/
extern SvStatus_t sv_H263GetHeader(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int *pgob);
extern SvStatus_t sv_H263StartCode(ScBitstream_t *BSIn);
/*
** sv_h263_recon.c
*/
extern void sv_H263Reconstruct(SvH263DecompressInfo_t *H263Info, int bx, int by, int P, int bdx, int bdy);
/*
** sv_h263_getvlc.c
*/
extern int sv_H263GetTMNMV(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMCBPC(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMODB(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetMCBPCintra(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
extern int sv_H263GetCBPY(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn);
/*
** sv_h263_getblk.c
*/
extern void sv_H263GetBlock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int mode);
extern void sv_H263GetSACblock(SvH263DecompressInfo_t *H263Info, ScBitstream_t *BSIn, int comp, int ptype);
/*
** sv_h263_sac.c
*/
extern void sv_H263SACDecoderReset(ScBitstream_t *BSIn);
extern int sv_H263SACDecode_a_symbol(ScBitstream_t *BSIn, int cumul_freq[ ]);
extern int sv_H263AREncode(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                    int index, int cumul_freq[ ]);
extern int sv_H263AREncoderFlush(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut);
int sv_H263IndexFN(int value, int table[], int max);

/* sc_h263_idct3.s */
void sv_H263IDCTAddToFrameP_S(dword *inbuf,unsigned char *rfp,int incr);
void sv_H263IDCTToFrameP_S(dword *inbuf,unsigned char *rfp, int incr) ;
/*
int sv_H263lim_S(int input);
*/
int sv_H263lim_S( int input, int low, int upp) ; 


/* sv_h263_recon2.s */
void svH263Load16_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16A_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8A_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16H_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8H_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16HA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8HA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16V_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8V_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16VA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8VA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16B_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8B_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec16BA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
void svH263Rec8BA_S(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
/*
** sv_h263_encode.c
*/
void sv_H263UpdateQuality(SvCodecInfo_t *Info);
H263_PictImage *sv_H263InitImage(int size);
void sv_H263FreeImage(H263_PictImage *image);
H263_PictImage *sv_H263CodeOneIntra(SvCodecInfo_t *Info, H263_PictImage *curr,
                          H263_PictImage *recon, int QP, H263_Bits *bits, H263_Pict *pic);
void sv_H263Clip(H263_MB_Structure *data);
SvStatus_t sv_H263RefreshCompressor(SvCodecInfo_t *Info);

/*
** sv_h263_edge.c
*/
unsigned char *sv_H263EdgeGrow(unsigned char *Edge, int rows, int cols, int sr, int sc);
void sv_H263EdgeMap(unsigned char *image, unsigned char *EdgeMag, unsigned char *EdgeOrient,
                    int rows, int cols);
/*
** sv_h263_quant.c
*/
int sv_H263Quant(short *coeff, int QP, int Mode);
void sv_H263Dequant(short *qcoeff, short *rcoeff, int QP, int Mode);
/*
** sv_h263_pred.c
*/
void sv_H263PredictB(SvH263CompressInfo_t *H263Info,
            H263_PictImage *curr_image, H263_PictImage *prev_image,
			unsigned char *prev_ipol,int x, int y,
			H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
			H263_MB_Structure *recon_P, int TRD,int TRB,
			H263_MB_Structure *p_err, H263_MB_Structure *pred);
void sv_H263PredictP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *curr_image, H263_PictImage *prev_image,
                     unsigned char *prev_ipol, int x, int y, 
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *pred_error);
void sv_H263MBReconP(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, unsigned char *prev_ipol,
                     H263_MB_Structure *diff, int x_curr, int y_curr, 
                     H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int PB,
                     H263_MB_Structure *recon_data);
void sv_H263MBReconB(SvH263CompressInfo_t *H263Info,
                     H263_PictImage *prev_image, H263_MB_Structure *diff,
                     unsigned char *prev_ipol,int x, int y,
                     H263_MotionVector *MV[5][H263_MBR+1][H263_MBC+2],
                     H263_MB_Structure *recon_P,int TRD, int TRB,
                     H263_MB_Structure *recon_B,H263_MB_Structure *pred);
void sv_H263FindHalfPel(SvH263CompressInfo_t *H263Info, 
                        int x, int y, H263_MotionVector *fr, unsigned char *prev, 
                        unsigned char *curr, int bs, int comp);
void sv_H263AdvHalfPel(SvH263CompressInfo_t *H263Info, int x, int y, 
                             H263_MotionVector *fr0, H263_MotionVector *fr1,
                             H263_MotionVector *fr2, H263_MotionVector *fr3,
                             H263_MotionVector *fr4,
                             unsigned char *prev, unsigned char *curr, 
                             int bs, int comp);

int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr, 
					  int x_pos, int y_pos, int min_SAD, int *VARmb);
/*
int sv_H263ChooseMode(SvH263CompressInfo_t *H263Info, unsigned char *curr, 
					  int x_pos, int y_pos, int min_SAD);
*/
int sv_H263ModifyMode(int Mode, int dquant);
/*
** sv_h263_putbits.c
*/
int sv_H263EqualVec(H263_MotionVector *MV2, H263_MotionVector *MV1);
void sv_H263AddBitsPicture(H263_Bits *bits);
void sv_H263AddBits(H263_Bits *total, H263_Bits *bits);
void sv_H263ZeroBits(H263_Bits *bits);
void sv_H263ZeroRes(H263_Results *res);
int sv_H263CountBitsPicture(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, H263_Pict *pic);
int sv_H263CountBitsSlice(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                          int slice, int quant);
void sv_H263CountBitsMB(ScBitstream_t *BSOut, int Mode, int COD, int CBP,
                        int CBPB, H263_Pict *pic, H263_Bits *bits);
void sv_H263CountSACBitsMB(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            int Mode,int COD,int CBP,int CBPB,H263_Pict *pic,H263_Bits *bits);
void sv_H263CountBitsCoeff(ScBitstream_t *BSOut, short *qcoeff, int Mode,
                           int CBP, H263_Bits *bits, int ncoeffs);
void sv_H263CountSACBitsCoeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                              short *qcoeff,int Mode,
                              int CBP, H263_Bits *bits, int ncoeffs);
void sv_H263CountBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits, 
                            int x, int y, int Mode, int newgob, H263_Pict *pic);
void sv_H263CountSACBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits,
                                int x, int y, int Mode, int newgob, H263_Pict *pic);
void sv_H263InitHuff(SvH263CompressInfo_t *H263Info);
void sv_H263FreeHuff(SvH263CompressInfo_t *H263Info);
void sv_H263FindPMV(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int x, int y, 
                    int *pmv0, int *pmv1, int block, int newgob, int half_pel);
void sv_H263ZeroVec(H263_MotionVector *MV);
void sv_H263MarkVec(H263_MotionVector *MV);

/*
** sv_h263_morph.c
*/
H263_PictImage *sv_H263AdaptClean(SvH263CompressInfo_t *H263Info, 
                                  H263_PictImage *curr_image, int rows, int cols, int sr, int sc);
H263_PictImage **sv_H263MorphLayers(H263_PictImage *img, int depth, int rows, int cols, int sz);
/*
** sv_h263_ratectrl.c
*/
int sv_H263FrameUpdateQP(int buf, int bits, int frames_left, int QP, int B, 
                         float seconds);
/*
** sv_h263_dct.c
*/
void sv_H263init_idctref();
void sv_H263idctref(short *coeff, short *block);
int sv_H263IDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size);
int sv_H263DCT( short *block, short *coeff, int QP, int Mode);

int sv_H263ZoneDCT( short *block, short *coeff, int QP, int Mode);
int sv_H263ZoneIDCT(short *inbuf, short *outbuf, int QP, int Mode, int outbuf_size);

/*
** sv_h263_motion.c
*/
void sv_H263FastME(SvH263CompressInfo_t *H263Info,
                   unsigned char *curr, unsigned char *prev, int x_curr,
		           int y_curr, int xoff, int yoff, int seek_dist, 
		           short *MVx, short *MVy, short *MVer, int *SAD_0);
void sv_H263MotionEstimation(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
                             int y_curr, int xoff, int yoff, int seek_dist, 
                             H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
void sv_H263FindMB(SvH263CompressInfo_t *H263Info, int x, int y, unsigned char *image, short MB[16][16]);
int sv_H263BError16x16_C(unsigned char *ii, unsigned char *aa, unsigned char *bb, 
                         int width, int min_sofar);
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
                      int h_length, int lx2, int min_sofar);
void sv_H263LdSubs2Area(unsigned char *im, int x, int y, 
  	                    int x_size, int y_size, int lx, 
						unsigned char *srch_area, int area_length);
#ifdef USE_C
int sv_H263SADMacroblock(unsigned char *ii, unsigned char *act_block,
                               int h_length, int lx2, int Min_FRAME);
#endif
/*
** sv_h263_me1.c
*/
void sv_H263ME_2levels_7_1(SvH263CompressInfo_t *H263Info,
                          unsigned char *curr, unsigned char *prev, int x_curr,
                          int y_curr, int xoff, int yoff, int seek_dist, 
                          H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
unsigned char *sv_H263LoadSubs2Area(unsigned char *im, int x, int y, 
                                    int x_size, int y_size, int lx);
int sv_H263MySADSubBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int min_sofar);
#ifdef USE_C
int sv_H263MySADBlock(unsigned char *ii, unsigned char *act_block,
	      int h_length, int lx2, int min_sofar);
#endif
/*
** sv_h263_me2.c
*/
void sv_H263ME_2levels_421_1(SvH263CompressInfo_t *H263Info,
                             unsigned char *curr, unsigned char *prev, int x_curr,
                             int y_curr, int xoff, int yoff, int seek_dist, 
                             H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
/*
** sv_h263_me3.c
*/
void sv_H263ME_2levels_7_polint(SvH263CompressInfo_t *H263Info,
                                unsigned char *curr, unsigned char *prev, int x_curr,
                                int y_curr, int xoff, int yoff, int seek_dist, 
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
/*
** sv_h263_me4.c
*/
void sv_H263ME_2levels_7_pihp(SvH263CompressInfo_t *H263Info,
                              unsigned char *curr, unsigned char *prev, int x_curr,
                              int y_curr, int xoff, int yoff, int seek_dist, 
                              H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int *SAD_0);
#endif /* _SV_H263_PROTO_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sa.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SA.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:22  Hans_Graves
 * 	Added SaDecompressEx() for AC3 multichannels.
 * 	[1996/11/14  21:46:20  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:34  Hans_Graves
 * 	Added AC3 enum types.
 * 	[1996/11/08  21:16:32  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/07/19  02:11:00  Hans_Graves
 * 	Added SA_PARAM_DEBUG.
 * 	[1996/07/19  01:22:50  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/23  21:01:39  Hans_Graves
 * 	Added protos for SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:15  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/15  14:18:34  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:30  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/10  21:47:05  Hans_Graves
 * 	Added PARAMs. Replaced externs with EXTERN.
 * 	[1996/04/10  21:22:49  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:20:59  Hans_Graves
 * 	Changed include <mme/mmsystem.h> to <mmsystem.h>
 * 	[1996/03/29  22:16:43  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/02/06  22:53:52  Hans_Graves
 * 	Added PARAM enums
 * 	[1996/02/06  22:18:04  Hans_Graves]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:21  Hans_Graves
 * 	Added prototypes for SaSetDataDestination() and SaSetBitrate()
 * 	[1996/01/15  15:42:41  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/09/14  17:28:10  Bjorn_Engberg
 * 	Ported to NT
 * 	[1995/09/14  17:17:18  Bjorn_Engberg]
 * 
 * Revision 1.1.2.7  1995/07/21  17:41:00  Hans_Graves
 * 	Moved Callback related stuff to SC.h
 * 	[1995/07/21  17:27:29  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/07/17  22:01:30  Hans_Graves
 * 	Defined SaBufferInfo_t as ScBufferInfo_t.
 * 	[1995/07/17  21:41:54  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  17:40:59  Hans_Graves
 * 	Added include <mme/mmsystem.h>.
 * 	[1995/06/27  17:39:26  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/27  13:54:20  Hans_Graves
 * 	Added SA_GSM_DECODE and SA_GSM_ENCODE
 * 	[1995/06/26  21:01:12  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/09  18:33:29  Hans_Graves
 * 	Added SaGetInputBitstream() prototype.
 * 	[1995/06/09  17:41:59  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:19:33  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:26:57  Hans_Graves
 * 	Added ENCODE Codec defs
 * 	[1995/04/17  18:26:33  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:35:31  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:22:48  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SA_H_
#define _SA_H_

#ifdef WIN32
#include <windows.h>  /* Windows NT        */
#endif
#include <mmsystem.h> /* needed for WAVEFORMATEX structure def */

#include "SC.h"

typedef enum {
   SA_MPEG_DECODE = 102,
   SA_MPEG_ENCODE = 103,
   SA_PCM_DECODE =  104,
   SA_PCM_ENCODE =  105,
   SA_GSM_DECODE =  106,
   SA_GSM_ENCODE =  107,
   SA_AC3_DECODE =  108,
   SA_AC3_ENCODE =  109,
   SA_G723_DECODE = 110,
   SA_G723_ENCODE = 111,
   SA_TMP_DECODE =  200,  /* temp - used for testing */
   SA_TMP_ENCODE =  201,
} SaCodecType_e;

#define SA_USE_SAME           STREAM_USE_SAME
#define SA_USE_FILE           STREAM_USE_FILE
#define SA_USE_BUFFER_QUEUE   STREAM_USE_QUEUE
#define SA_USE_BUFFER         STREAM_USE_BUFFER

/*
** Parameters
*/
typedef enum {
  SA_PARAM_NATIVEFORMAT,  /* native/preferred decompressed format (FOURCC) */
  SA_PARAM_BITRATE,       /* bitrate - bits per second */
  SA_PARAM_CHANNELS,      /* channels - 1=mono, 2=stereo, 4/5=surround */
  SA_PARAM_AUDIOLENGTH,   /* milliseconds of audio */
  SA_PARAM_SAMPLESPERSEC, /* samples per second (8000, 11025, 22050, etc.)
  SA_PARAM_BITSPERSAMPLE, /* bits per sample (8 or 16) */
  SA_PARAM_TIMECODE,      /* audio time code */
  SA_PARAM_MPEG_LAYER,    /* MPEG Layer: I, II, or III */
  SA_PARAM_PSY_MODEL,     /* Psy Acoustic Model */
  SA_PARAM_ALGFLAGS,      /* Algorithm flags */
  SA_PARAM_QUALITY,       /* Quality: 0=worst 99>=best */
  SA_PARAM_FASTDECODE,    /* Fast decode desired */
  SA_PARAM_FASTENCODE,    /* Fast encode desired */
  SA_PARAM_DEBUG,         /* Setup debug */
} SaParameter_t;

/*
** Type definitions
*/
typedef int SaStatus_t;
typedef void *SaHandle_t;
typedef ScCallbackInfo_t SaCallbackInfo_t;

/*
** Store basic info for user about the codec
*/
typedef struct SaInfo_s {
  SaCodecType_e Type;     /* Codec Type */
  char          Name[20];         /* Codec name (i.e. "MPEG-Decode") */
  char          Description[128]; /* Codec description */
  unsigned int  Version;          /* Codec version number */
  int           CodecStarted;     /* SaDecompressBegin/End */
  unsigned int  MS;               /* Number of milliseconds processed */
  unsigned int  NumBytesIn;       /* Number of bytes input */
  unsigned int  NumBytesOut;      /* Number of bytes output */
  unsigned int  NumFrames;        /* Number of ellapsed frames */
  unsigned long TotalFrames;      /* Total number of frames */
  unsigned long TotalMS;          /* Total number of milliseconds */
} SaInfo_t;

/***************************** Prototypes ********************************/
EXTERN SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah);
EXTERN SaStatus_t SaCloseCodec (SaHandle_t Sah);
EXTERN SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData);
EXTERN ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah);
EXTERN SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen);
PRIVATE_EXTERN SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, 
                                       unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen);
EXTERN SaStatus_t SaDecompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut);
EXTERN SaStatus_t SaCompress (SaHandle_t Sah,
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen);
EXTERN SaStatus_t SaCompressEnd (SaHandle_t Sah);
EXTERN SaStatus_t SaSetDataSource(SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN SaStatus_t SaSetDataDestination(SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize);
EXTERN ScBitstream_t *SaGetDataSource (SaHandle_t Sah);
EXTERN ScBitstream_t *SaGetDataDestination(SaHandle_t Sah);
EXTERN SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo);
#ifdef MPEG_SUPPORT
EXTERN SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, 
                                      SaInfo_t *info);
#endif /* MPEG_SUPPORT */
EXTERN SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                             ScBoolean_t value);
EXTERN SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                             qword value);
EXTERN ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param);
EXTERN qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param);

#endif _SA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\quant.c ===
/* File: sv_h263_quant.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#include "sv_h263.h"
#include "proto.h"


/**********************************************************************
 *
 *	Name:		Quant
 *	Description:	quantizer for SIM3
 *	
 *	Input:		pointers to coeff and qcoeff
 *			
 *	Returns:	
 *	Side effects:	
 *
 ***********************************************************************/

int sv_H263Quant(short *coeff, int QP, int Mode)
{
  register int i;
  register int Q2, hfQ;
  register short *ptn, tmp;

  unsigned __int64 *dp ;

  if (QP) {
    Q2 = QP << 1 ;
    if(Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */

	  coeff[0] = mmax(1,mmin(254,coeff[0]/8));

	  ptn = coeff + 1;
	  if (Q2 > 10)
		  for (i=1; i < 64; i++, ptn++) *ptn /= (short)Q2;
      else
        for (i=1; i < 64; i++, ptn++) {
          if(tmp = *ptn)
	        *ptn = (tmp > 0) ? mmin(127,tmp/Q2) : mmax(-127,-(-tmp/Q2));
        }

	  /* check CBP */
      ptn = coeff + 1;
      for (i=1; i < 64; i++) if(*ptn++) return 1;

      return 0;
    }
    else { /* non Intra */
      hfQ = QP >> 1;
	  ptn = coeff;
	  if( Q2 > 10)
        for (i = 0; i < 64; i++, ptn++) {
          if(tmp = *ptn)
            *ptn = (tmp>0) ? (tmp-hfQ)/Q2 : (tmp+hfQ)/Q2 ;
        }
	  else
        for (i = 0; i < 64; i++, ptn++) {
          if(tmp = *ptn)
            *ptn = (tmp>0) ? mmin(127,(tmp-hfQ)/Q2) : mmax(-127,-((-tmp-hfQ)/Q2));
	  }
    }
  }
  /* IF(QP == 0). No quantizing.
     Used only for testing. Bitstream will not be decodable
     whether clipping is performed or not */

  /* check CBP */
  dp = (unsigned __int64 *) coeff ;
  for (i = 0; i < 16; i++) 	if(*dp++) return 1;

  return 0;
}

/**********************************************************************
 *
 *	Name:		Dequant
 *	Description:	dequantizer for SIM3
 *	
 *	Input:		pointers to coeff and qcoeff
 *			
 *	Returns:	
 *	Side effects:	
 *
 ***********************************************************************/
void sv_H263Dequant(short *qcoeff, short *rcoeff, int QP, int Mode)
{
  int i;
  register int Q2;
  register short *inptr, *outptr, tmp;
	
  inptr  = qcoeff;
  outptr = rcoeff;

  Q2 = QP << 1;
  if (QP) {
    if((QP%2) == 1){
      for (i = 0; i < 64; i++) {
        if (!(tmp = *inptr++)) *outptr++ = 0;
	    else        *outptr++ = (tmp > 0) ? Q2*tmp+QP : Q2*tmp-QP ;
	  }
    }
	else {
      for (i = 0; i < 64; i++) {
        if (!(tmp = *inptr++)) *outptr++ = 0;
	    else        *outptr++ = (tmp > 0) ? Q2*tmp+QP-1 : Q2*tmp-QP+1 ;
	  }
	}

	/* Intra */
    if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)
       rcoeff[0] = qcoeff[0] << 3;
  }
  else {
    /* No quantizing at all */
    for (i = 0; i < 64; i++) *outptr++ = *inptr++;
  }

  return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_intrn.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_internals.h,v $
 * Revision 1.1.6.2  1996/11/08  21:50:56  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:56  Hans_Graves]
 *
 * Revision 1.1.4.2  1996/03/29  22:21:09  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  21:47:46  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/07/21  17:41:04  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:28:24  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:25  Hans_Graves
 * 	Added SaGSMInfo_t structure.
 * 	[1995/06/27  13:17:39  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:41  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:30:39  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:25:06  Hans_Graves
 * 	Added BSOut to CodecInfo struct for streaming
 * 	[1995/04/17  18:24:31  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:05  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:25:01  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SA_INTERNALS_H_
#define _SA_INTERNALS_H_

#include "SC.h"
#include "SA.h"

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
#include "sa_g723.h"
#endif /* G723_SUPPORT */

typedef struct SaCodecInfo_s {
  SaCodecType_e           Type;
  ScBoolean_t             started;           /* begin was called? */
  SaInfo_t                Info;

  union {
    void *info;
#ifdef MPEG_SUPPORT
    SaMpegDecompressInfo_t *MDInfo;
    SaMpegCompressInfo_t   *MCInfo;
#endif /* !MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    SaGSMInfo_t            *GSMInfo;
#endif /* !GSM_SUPPORT */
#ifdef AC3_SUPPORT
    SaAC3DecompressInfo_t  *AC3Info;
#endif /* !AC3_SUPPORT */
#ifdef G723_SUPPORT
    SaG723Info_t  *pSaG723Info;
#endif /* !G723_SUPPORT */
  }; /* union */

  ScQueue_t              *Q;
  ScBitstream_t          *BSIn;
  ScBitstream_t          *BSOut;
  WAVEFORMATEX           *wfIn;
  WAVEFORMATEX           *wfOut;
  /*
   ** Callback function to control processing
   */
  int (* CallbackFunction)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *);
} SaCodecInfo_t; 

#endif _SA_INTERNALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\recon.c ===
/* File: sv_h263_recon.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#include "sv_h263.h"
#include "proto.h"

/* private prototypes */
static void sv_recon_comp(unsigned char *src, unsigned char *dst,
  int lx, int lx2, int w, int h, int x, int y, int dx, int dy, int flag);
static void sv_recon_comp_obmc(SvH263DecompressInfo_t *H263Info, unsigned char *src, unsigned char *dst,
                            int lx, int lx2, int comp, int w, int h, int x, int y);
static void sv_rec(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_reco(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_rech(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rechc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recho(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_recv(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recvc(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_recvo(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);
static void sv_rec4(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rec4c(unsigned char *s, unsigned char *d, int lx, int lx2, int h);
static void sv_rec4o(unsigned char *s, int *d, int lx2, int c, int xa, int xb, int ya, int yb);

static int H263_roundtab[16]= {0,0,0,1,1,1,1,1,1,1,1,1,1,1,2,2};

void sv_H263Reconstruct(SvH263DecompressInfo_t *H263Info, int bx, int by, int P, int bdx, int bdy)
{
  int w,h,lx,lx2,dx,dy,xp,yp,comp,sum;
  int x,y,mode,xvec,yvec;
  unsigned char *src[3];

  x = bx/16+1; y = by/16+1;
  lx = H263Info->coded_picture_width;

  if (H263Info->mv_outside_frame) {
    lx2 = H263Info->coded_picture_width + 64;
    src[0] = H263Info->edgeframe[0];
    src[1] = H263Info->edgeframe[1];
    src[2] = H263Info->edgeframe[2];
  }
  else {
    lx2 = H263Info->coded_picture_width;
    src[0] = H263Info->oldrefframe[0];
    src[1] = H263Info->oldrefframe[1];
    src[2] = H263Info->oldrefframe[2];
  }

  mode = H263Info->modemap[y][x];

  if (P) {
    /* P prediction */
    if (H263Info->adv_pred_mode) {
      w = 8; h = 8;
      /* Y*/
      for (comp = 0; comp < 4; comp++) {
        xp = bx + ((comp&1)<<3);
        yp = by + ((comp&2)<<2);
        sv_recon_comp_obmc(H263Info, src[0],H263Info->newframe[0], lx,lx2,comp,w,h,xp,yp);
      }
      if (mode == H263_MODE_INTER4V) {

        sum = H263Info->MV[0][1][y][x]+H263Info->MV[0][2][y][x]+ H263Info->MV[0][3][y][x]+H263Info->MV[0][4][y][x];
        dx = sign(sum)*(H263_roundtab[abs(sum)%16] + (abs(sum)/16)*2);

        sum = H263Info->MV[1][1][y][x]+H263Info->MV[1][2][y][x]+ H263Info->MV[1][3][y][x]+H263Info->MV[1][4][y][x];
        dy = sign(sum)*(H263_roundtab[abs(sum)%16] + (abs(sum)/16)*2);

      }
      else {
        dx = H263Info->MV[0][0][y][x];
        dy = H263Info->MV[1][0][y][x];
        /* chroma rounding */
        dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
        dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );
      }
      lx>>=1;bx>>=1; lx2>>=1; 
      by>>=1;
      /* Chroma */
      sv_recon_comp(src[1],H263Info->newframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->newframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
    else { /* normal prediction mode */
      /* P prediction */
      w = 16; h = 16;
      dx = H263Info->MV[0][0][y][x];
      dy = H263Info->MV[1][0][y][x];
      
      /* Y */
      sv_recon_comp(src[0],H263Info->newframe[0], lx,lx2,w,h,bx,by,dx,dy,0);
      
      lx>>=1; w>>=1; bx>>=1; lx2>>=1; 
      h>>=1; by>>=1;  
      /* chroma rounding */
      dx = ( dx % 4 == 0 ? dx >> 1 : (dx>>1)|1 );
      dy = ( dy % 4 == 0 ? dy >> 1 : (dy>>1)|1 );

      /* Chroma */
      sv_recon_comp(src[1],H263Info->newframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->newframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
  }
  else {
    /* B forward prediction */
    if (H263Info->adv_pred_mode) {
      if (mode == H263_MODE_INTER4V) {
        w = 8; h = 8;
        /* Y*/
        xvec = yvec = 0;
        for (comp = 0; comp < 4; comp++) {
          xvec += (dx = (H263Info->trb)*H263Info->MV[0][comp+1][y][x]/H263Info->trd + bdx);
          yvec += (dy = (H263Info->trb)*H263Info->MV[1][comp+1][y][x]/H263Info->trd + bdy);
          xp = bx + ((comp&1)<<3);
          yp = by + ((comp&2)<<2);
          sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,xp,yp,dx,dy,0);
        }

        /* chroma rounding (table 16/H.263) */
        dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
        dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

        lx>>=1;bx>>=1; lx2>>=1;
        by>>=1;
        /* Chroma */
        sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
        sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
      }
      else {  /* H263Info->adv_pred_mode but 16x16 vector */
        w = 16; h = 16;

        dx = (H263Info->trb)*H263Info->MV[0][0][y][x]/H263Info->trd + bdx;
        dy = (H263Info->trb)*H263Info->MV[1][0][y][x]/H263Info->trd + bdy;
        /* Y */
        sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,bx,by,dx,dy,0);
        
        lx>>=1; w>>=1; bx>>=1; lx2>>=1;
        h>>=1; by>>=1;  

        xvec = 4*dx;
        yvec = 4*dy;

        /* chroma rounding (table 16/H.263) */
        dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
        dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

        /* Chroma */
        sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
        sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
      }
    }
    else { /* normal B forward prediction */

      w = 16; h = 16;
      dx = (H263Info->trb)*H263Info->MV[0][0][y][x]/H263Info->trd + bdx;
      dy = (H263Info->trb)*H263Info->MV[1][0][y][x]/H263Info->trd + bdy;
      /* Y */
      sv_recon_comp(src[0],H263Info->bframe[0], lx,lx2,w,h,bx,by,dx,dy,0);

      lx>>=1; w>>=1; bx>>=1; lx2>>=1;
      h>>=1; by>>=1;  

      xvec = 4*dx;
      yvec = 4*dy;

      /* chroma rounding (table 16/H.263) */ 
      dx = sign(xvec)*(H263_roundtab[abs(xvec)%16] + (abs(xvec)/16)*2);
      dy = sign(yvec)*(H263_roundtab[abs(yvec)%16] + (abs(yvec)/16)*2);

      /* Chroma */
      sv_recon_comp(src[1],H263Info->bframe[1], lx,lx2,w,h,bx,by,dx,dy,1);
      sv_recon_comp(src[2],H263Info->bframe[2], lx,lx2,w,h,bx,by,dx,dy,2);
    }
  }
}


static void sv_recon_comp(src,dst,lx,lx2,w,h,x,y,dx,dy,chroma)
unsigned char *src;
unsigned char *dst;
int lx,lx2;
int w,h;
int x,y;
int dx,dy;
int chroma;
{
  register int xint, xh, yint, yh;
  register unsigned char *s, *d;

  xint = dx>>1;
  xh = dx & 1;
  yint = dy>>1;
  yh = dy & 1;

  /* origins */
  s = src + lx2*(y+yint) + x + xint;
  d = dst + lx*y + x;

#if 0 /* fast but less accurate */

  if (w!=8) {
    if      (!xh && !yh) svH263Rec16_S(s,d,lx,lx2,h);
    else if (!xh &&  yh) svH263Rec16V_S(s,d,lx,lx2,h);
    else if ( xh && !yh) svH263Rec16H_S(s,d,lx,lx2,h);
    else                 svH263Rec16B_S(s,d,lx,lx2,h);
  }
  else {
    if      (!xh && !yh) svH263Rec8_S(s,d,lx,lx2,h);
    else if (!xh &&  yh) svH263Rec8V_S(s,d,lx,lx2,h);
    else if ( xh && !yh) svH263Rec8H_S(s,d,lx,lx2,h);
    else                 svH263Rec8B_S(s,d,lx,lx2,h);
  }

#else

  if(w != 8) {
    if      (!xh && !yh) sv_rec(s,d,lx,lx2,h);
    else if (!xh &&  yh) sv_recv(s,d,lx,lx2,h);
    else if ( xh && !yh) sv_rech(s,d,lx,lx2,h);
    else                 sv_rec4(s,d,lx,lx2,h);
  }
  else {
    if      (!xh && !yh) sv_recc(s,d,lx,lx2,h);
    else if (!xh &&  yh) sv_recvc(s,d,lx,lx2,h);
    else if ( xh && !yh) sv_rechc(s,d,lx,lx2,h);
    else                 sv_rec4c(s,d,lx,lx2,h);
  }

#endif

}

static void sv_rec(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register int j;
  register unsigned qword *p1;
  unsigned UNALIGNED qword *p2;

  for (j=0; j<h; j++)
  {
    p1 = (unsigned qword *) d;
    p2 = (unsigned qword *) s;
    p1[0] = p2[0];
    p1[1] = p2[1];
    s+= lx2;
    d+= lx;
  }

/*
  for (j=0; j<h; j++)
  {
    d[0] = s[0];
    d[1] = s[1];
    d[2] = s[2];
    d[3] = s[3];
    d[4] = s[4];
    d[5] = s[5];
    d[6] = s[6];
    d[7] = s[7];
    d[8] = s[8];
    d[9] = s[9];
    d[10] = s[10];
    d[11] = s[11];
    d[12] = s[12];
    d[13] = s[13];
    d[14] = s[14];
    d[15] = s[15];
    s+= lx2;
    d+= lx;
  }
*/
}

static void sv_recc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  int j;

  for (j=0; j<h; j++)
  {
    unsigned qword *p1;
    unsigned UNALIGNED qword *p2;
 
    p1 = (unsigned qword *) d;
    p2 = (unsigned qword *) s;
    p1[0] = p2[0];
    s+= lx2;
    d+= lx;
  }
/*
  for (j=0; j<h; j++)
  {
    d[0] = s[0];
    d[1] = s[1];
    d[2] = s[2];
    d[3] = s[3];
    d[4] = s[4];
    d[5] = s[5];
    d[6] = s[6];
    d[7] = s[7];
    s+= lx2;
    d+= lx;
  }
*/
}

static void sv_rech(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/* unsigned int s1,s2; */
  register unsigned char *dp,*sp;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) (sp+1);
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= 0x00ff00ff00ff00ff;
    acc2 &= 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
    acc1 = p1[1];
    acc2 = p2[1];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (acc3 << 8) | acc1;
   /*
    s1=sp[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+1)>>1;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+1)>>1;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+1)>>1;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+1)>>1;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+1)>>1;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+1)>>1;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+1)>>1;
    dp[7] = (unsigned int)(s2+(s1=sp[8])+1)>>1;
    dp[8] = (unsigned int)(s1+(s2=sp[9])+1)>>1;
    dp[9] = (unsigned int)(s2+(s1=sp[10])+1)>>1;
    dp[10] = (unsigned int)(s1+(s2=sp[11])+1)>>1;
    dp[11] = (unsigned int)(s2+(s1=sp[12])+1)>>1;
    dp[12] = (unsigned int)(s1+(s2=sp[13])+1)>>1;
    dp[13] = (unsigned int)(s2+(s1=sp[14])+1)>>1;
    dp[14] = (unsigned int)(s1+(s2=sp[15])+1)>>1;
    dp[15] = (unsigned int)(s2+sp[16]+1)>>1;
*/
    sp+= lx2;
    dp+= lx;
  }
}

static void sv_rechc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2; */
  register unsigned char *dp,*sp;
  int j;
  unsigned qword *dpl;
  unsigned UNALIGNED qword *p1;
  unsigned UNALIGNED qword *p2;
  unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) (sp+1);
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
/*
    s1=sp[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+1)>>1;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+1)>>1;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+1)>>1;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+1)>>1;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+1)>>1;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+1)>>1;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+1)>>1;
    dp[7] = (unsigned int)(s2+sp[8]+1)>>1;
*/
    sp+= lx2;
    dp+= lx;
  }
}


static void sv_recv(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) sp2;
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;
    acc1 = p1[1];
    acc2 = p2[1];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (acc3 << 8) | acc1;
/*
    dp[0] = (unsigned int)(sp[0]+sp2[0]+1)>>1;
    dp[1] = (unsigned int)(sp[1]+sp2[1]+1)>>1;
    dp[2] = (unsigned int)(sp[2]+sp2[2]+1)>>1;
    dp[3] = (unsigned int)(sp[3]+sp2[3]+1)>>1;
    dp[4] = (unsigned int)(sp[4]+sp2[4]+1)>>1;
    dp[5] = (unsigned int)(sp[5]+sp2[5]+1)>>1;
    dp[6] = (unsigned int)(sp[6]+sp2[6]+1)>>1;
    dp[7] = (unsigned int)(sp[7]+sp2[7]+1)>>1;
    dp[8] = (unsigned int)(sp[8]+sp2[8]+1)>>1;
    dp[9] = (unsigned int)(sp[9]+sp2[9]+1)>>1;
    dp[10] = (unsigned int)(sp[10]+sp2[10]+1)>>1;
    dp[11] = (unsigned int)(sp[11]+sp2[11]+1)>>1;
    dp[12] = (unsigned int)(sp[12]+sp2[12]+1)>>1;
    dp[13] = (unsigned int)(sp[13]+sp2[13]+1)>>1;
    dp[14] = (unsigned int)(sp[14]+sp2[14]+1)>>1;
    dp[15] = (unsigned int)(sp[15]+sp2[15]+1)>>1;
*/
    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static void sv_recvc(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *p1;
  register unsigned UNALIGNED qword *p2;
  register unsigned qword acc1,acc2,acc3,acc4;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  for (j=0; j<h; j++)
  {
/*
    dp[0] = (unsigned int)(sp[0]+sp2[0]+1)>>1;
    dp[1] = (unsigned int)(sp[1]+sp2[1]+1)>>1;
    dp[2] = (unsigned int)(sp[2]+sp2[2]+1)>>1;
    dp[3] = (unsigned int)(sp[3]+sp2[3]+1)>>1;
    dp[4] = (unsigned int)(sp[4]+sp2[4]+1)>>1;
    dp[5] = (unsigned int)(sp[5]+sp2[5]+1)>>1;
    dp[6] = (unsigned int)(sp[6]+sp2[6]+1)>>1;
    dp[7] = (unsigned int)(sp[7]+sp2[7]+1)>>1;
*/
    dpl = (unsigned qword *) dp;
    p1 = (unsigned qword *) sp;
    p2 = (unsigned qword *) sp2;
    acc1 = p1[0];
    acc2 = p2[0];
    acc3 = (acc1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc4 = (acc2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    acc1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    acc3 += acc4 + (unsigned qword) 0x0001000100010001;
    acc1 += acc2 + (unsigned qword) 0x0001000100010001;
    acc3 = (acc3 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    acc1 = (acc1 >> 1) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (acc3 << 8) | acc1;

    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}


static void sv_rec4(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2,s3,s4; */
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *u1;
  register unsigned UNALIGNED qword *u2;
  register unsigned UNALIGNED qword *l1;
  register unsigned UNALIGNED qword *l2;
  unsigned qword odd1,odd2,even1,even2,oddacc,evenacc;


  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
/*
    s1=sp[0]; s3=sp2[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+s3+(s4=sp2[1])+2)>>2;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+s4+(s3=sp2[2])+2)>>2;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+s3+(s4=sp2[3])+2)>>2;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+s4+(s3=sp2[4])+2)>>2;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+s3+(s4=sp2[5])+2)>>2;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+s4+(s3=sp2[6])+2)>>2;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+s3+(s4=sp2[7])+2)>>2;
    dp[7] = (unsigned int)(s2+(s1=sp[8])+s4+(s3=sp2[8])+2)>>2;
    dp[8] = (unsigned int)(s1+(s2=sp[9])+s3+(s4=sp2[9])+2)>>2;
    dp[9] = (unsigned int)(s2+(s1=sp[10])+s4+(s3=sp2[10])+2)>>2;
    dp[10] = (unsigned int)(s1+(s2=sp[11])+s3+(s4=sp2[11])+2)>>2;
    dp[11] = (unsigned int)(s2+(s1=sp[12])+s4+(s3=sp2[12])+2)>>2;
    dp[12] = (unsigned int)(s1+(s2=sp[13])+s3+(s4=sp2[13])+2)>>2;
    dp[13] = (unsigned int)(s2+(s1=sp[14])+s4+(s3=sp2[14])+2)>>2;
    dp[14] = (unsigned int)(s1+(s2=sp[15])+s3+(s4=sp2[15])+2)>>2;
    dp[15] = (unsigned int)(s2+sp[16]+s4+sp2[16]+2)>>2;
*/
    dpl = (unsigned qword *) dp;
    u1 = (unsigned qword *) sp;
    u2 = (unsigned qword *) (sp+1);
    l1 = (unsigned qword *) sp2;
    l2 = (unsigned qword *) (sp2+1);
    odd1 = u1[0];
    odd2 = u2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[0];
    odd2 = l2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (evenacc << 8) | oddacc;

    odd1 = u1[1];
    odd2 = u2[1];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword)0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword)0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[1];
    odd2 = l2[1];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[1] = (evenacc << 8) | oddacc;

    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static void sv_rec4c(s,d,lx,lx2,h)
unsigned char *s, *d;
int lx,lx2,h;
{
/*  unsigned int s1,s2,s3,s4; */
  register unsigned char *dp,*sp,*sp2;
  int j;
  register unsigned qword *dpl;
  register unsigned UNALIGNED qword *u1;
  register unsigned UNALIGNED qword *u2;
  register unsigned UNALIGNED qword *l1;
  register unsigned UNALIGNED qword *l2;
  unsigned qword odd1,odd2,even1,even2,oddacc,evenacc;

  sp = s;
  sp2 = s+lx2;
  dp = d;
  for (j=0; j<h; j++)
  {
 /*

    s1=sp[0]; s3=sp2[0];
    dp[0] = (unsigned int)(s1+(s2=sp[1])+s3+(s4=sp2[1])+2)>>2;
    dp[1] = (unsigned int)(s2+(s1=sp[2])+s4+(s3=sp2[2])+2)>>2;
    dp[2] = (unsigned int)(s1+(s2=sp[3])+s3+(s4=sp2[3])+2)>>2;
    dp[3] = (unsigned int)(s2+(s1=sp[4])+s4+(s3=sp2[4])+2)>>2;
    dp[4] = (unsigned int)(s1+(s2=sp[5])+s3+(s4=sp2[5])+2)>>2;
    dp[5] = (unsigned int)(s2+(s1=sp[6])+s4+(s3=sp2[6])+2)>>2;
    dp[6] = (unsigned int)(s1+(s2=sp[7])+s3+(s4=sp2[7])+2)>>2;
    dp[7] = (unsigned int)(s2+sp[8]+s4+sp2[8]+2)>>2;
*/

    dpl = (unsigned qword *) dp;
    u1 = (unsigned qword *) sp;
    u2 = (unsigned qword *) (sp+1);
    l1 = (unsigned qword *) sp2;
    l2 = (unsigned qword *) (sp2+1);
    odd1 = u1[0];
    odd2 = u2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = odd1 + odd2;
    evenacc = even1 + even2;
    odd1 = l1[0];
    odd2 = l2[0];
    even1 = (odd1 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    even2 = (odd2 & (unsigned qword) 0xff00ff00ff00ff00) >> 8;
    odd1 &= (unsigned qword) 0x00ff00ff00ff00ff;
    odd2 &= (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc += odd1 + odd2 + (unsigned qword) 0x0002000200020002;
    evenacc += even1 + even2 + (unsigned qword) 0x0002000200020002;
    evenacc = (evenacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    oddacc = (oddacc >> 2) & (unsigned qword) 0x00ff00ff00ff00ff;
    dpl[0] = (evenacc << 8) | oddacc;
    sp+= lx2;
    sp2+= lx2;
    dp+= lx;
  }
}

static int DEC_OM[4][8][8] =
{{
  {1,1,1,1,1,1,1,1},
  {0,0,1,1,1,1,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
},{
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,0,0,0,0,0,0},
  {0,0,1,1,1,1,0,0},
  {1,1,1,1,1,1,1,1},
},{
  {0,0,0,0,0,0,0,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,1,1},
  {0,0,0,0,0,0,0,1},
},{
  {1,0,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,1,0,0,0,0,0,0},
  {1,0,0,0,0,0,0,0},
} };

static void sv_reco(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  int i,j;

  switch(c) {

  case 0:
    *d++ = (unsigned int)s[0] << 2;
    for (i = 1; i < 7; i++) *d++ = (unsigned int)s[i] * 5 ;
    *d++ = (unsigned int)s[7] << 2;
    s+= lx2; 
	
    for (i = 0; i < 8; i++) *d++ = (unsigned int)s[i] * 5 ;
    s+= lx2; 

    for (j = 2; j < 6; j++) {
      *d++ = (unsigned int)s[0] * 5;
      *d++ = (unsigned int)s[1] * 5;
      for (i = 2; i < 6; i++) *d++ = (unsigned int)s[i] * 6 ;
      *d++ = (unsigned int)s[6] * 5;
      *d++ = (unsigned int)s[7] * 5;
      s+= lx2; 
    }

    for (i = 0; i < 8; i++) *d++ = (unsigned int)s[i] * 5 ;
    s+= lx2; 

    *d++ = (unsigned int)s[0] << 2;
    for (i = 1; i < 7; i++) *d++ = (unsigned int)s[i] * 5 ;
    *d++ = (unsigned int)s[7] << 2;
  	break;

  case 1:
    *d++ += ((unsigned int)s[0] << 1);
    *d++ += ((unsigned int)s[1] << 1);
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += ((unsigned int)s[6] << 1);
    *d++ += ((unsigned int)s[7] << 1);
    s += lx2;

    *d++ += s[0];
    *d++ += s[1];
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += s[6];
    *d++ += s[7];
	s += lx2; 

    for (j=2; j<4; j++) {
      *d++ += s[0];
      *d++ += s[1];
      *d++ += s[2];
      *d++ += s[3];
      *d++ += s[4];
      *d++ += s[5];
      *d++ += s[6];
      *d++ += s[7];
	  s += lx2; 
    }
  	break;

  case 2:
   for (j=0; j<2; j++) {
      *d++ += s[0];
      *d++ += s[1];
      *d++ += s[2];
      *d++ += s[3];
      *d++ += s[4];
      *d++ += s[5];
      *d++ += s[6];
      *d++ += s[7];
	  s += lx2;  
    }
    *d++ += s[0];
    *d++ += s[1];
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += s[6];
    *d++ += s[7];
	s += lx2; 

    *d++ += ((unsigned int)s[0] << 1);
    *d++ += ((unsigned int)s[1] << 1);
    *d++ += ((unsigned int)s[2] << 1);
    *d++ += ((unsigned int)s[3] << 1);
    *d++ += ((unsigned int)s[4] << 1);
    *d++ += ((unsigned int)s[5] << 1);
    *d++ += ((unsigned int)s[6] << 1);
    *d++ += ((unsigned int)s[7] << 1);
    s += lx2; 
    break;

  case 3:
    d[4] += s[4];
    d[5] += s[5];
    d[6] += s[6];
    d[7] += ((unsigned int)s[7] << 1) ;
	s += lx2; d += 8;

    for (j=0; j<6; j++) {
      d[4] += s[4];
	  d[5] += s[5];
      d[6] += ((unsigned int)s[6] << 1) ;
      d[7] += ((unsigned int)s[7] << 1) ;
	  s += lx2; d += 8;
    }

    d[4] += s[4];
    d[5] += s[5];
    d[6] += s[6];
    d[7] += ((unsigned int)s[7] << 1) ;
	break;

  case 4:
    d[0] += ((unsigned int)s[0] << 1) ;
    d[1] += s[1];
    d[2] += s[2];
    d[3] += s[3];
    s += lx2; d += 8;

    for (j=0; j<6; j++) {
      d[0] += ((unsigned int)s[0] << 1) ;
      d[1] += ((unsigned int)s[1] << 1) ;
      d[2] += s[2];
	  d[3] += s[3];
	  s += lx2; d += 8;
    }

    d[0] += ((unsigned int)s[0] << 1) ;
    d[1] += s[1];
    d[2] += s[2];
    d[3] += s[3];

  default:
  break;
  }
}

static void sv_recvo(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,*om;
  register unsigned char *sp,*sp2;
  int i,j;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  if(!c) {
      
    *dp++ = (unsigned int)((sp[0] + sp2[0] + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    *dp++ = (unsigned int)((sp[7] + sp2[7] + 1) >> 1) << 2;
    sp  += lx2; sp2 += lx2; 
	
    for (i = 0; i < 8; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    sp  += lx2; sp2 += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0] + sp2[0] + 1)>>1) * 5;
      *dp++ = ((unsigned int)(sp[1] + sp2[1] + 1)>>1) * 5;
      for (i = 2; i < 6; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 6 ;
      *dp++ = ((unsigned int)(sp[6] + sp2[6] + 1)>>1) * 5;
      *dp++ = ((unsigned int)(sp[7] + sp2[7] + 1)>>1) * 5;
      sp+= lx2; sp2+=lx2;  
    }

    for (i = 0; i < 8; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    sp+= lx2; sp2+=lx2; 

    *dp++ = (unsigned int)((sp[0] + sp2[0] + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) *dp++ = ((unsigned int)(sp[i] + sp2[i] + 1)>>1) * 5 ;
    *dp++ =  (unsigned int)((sp[7] + sp2[7] + 1) >> 1) << 2;
  }
  else {
	om = &DEC_OM[c-1][ya][0];
    for (j = ya; j < yb; j++) {
      for (i = xa; i < xb; i++) 
        dp[i] += (((unsigned int)(sp[i] + sp2[i] + 1)>>1) << om[i]) ;
        
      sp  += lx2; sp2 += lx2; dp  += 8; om  += 8;
    }
  }
}

static void sv_recho(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,*om;
  register unsigned char *sp,tmp;
  int i,j;

  sp = s;
  dp = d;

  if(!c) {

    *dp++ = (unsigned int)((sp[0] + (tmp=sp[1]) + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    *dp++ = (unsigned int)((tmp + sp[8]+1) >> 1) << 2;
    sp  += lx2; 
	
	tmp = sp[0] ;
    for (i = 0; i < 8; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    sp  += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0] + (tmp=sp[1]) + 1)>>1) * 5;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[2]) + 1)>>1) * 5;
      for (i = 2; i < 6; i++) 
		  *dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 6 ;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[7]) + 1)>>1) * 5;
      *dp++ = ((unsigned int)(tmp + (tmp=sp[8]) + 1)>>1) * 5;
      sp+= lx2;  
    }

	tmp = sp[0];
    for (i = 0; i < 8; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    sp+= lx2; 

    *dp++ = (unsigned int)((sp[0] + (tmp=sp[1]) + 1) >> 1) << 2;
    for (i = 1; i < 7; i++) 
		*dp++ = ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) * 5 ;
    *dp++ =  (unsigned int)((tmp + sp[8]+1) >> 1) << 2;
  }
  else {
    om = &DEC_OM[c-1][ya][0];
    for (j = ya; j < yb; j++) {
      tmp = sp[xa];
      for (i = xa; i < xb; i++) 
    	dp[i] += ( ((unsigned int)(tmp + (tmp=sp[i+1]) + 1)>>1) << om[i]) ;
        
      sp+= lx2; dp+= 8; om+= 8;
    }
  }
}

static void sv_rec4o(s,d,lx2,c,xa,xb,ya,yb)
unsigned char *s;
int *d;
int lx2,c,xa,xb,ya,yb;
{
  register int *dp,tmp;
  register unsigned char *sp,*sp2;
  int i,j;

  sp = s;
  sp2 = s+lx2;
  dp = d;

  switch(c) {

  case 0:
    *dp++ = (unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2);
    for (i = 1; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ = (unsigned int)(tmp+sp[8]+sp2[8]+2);
    sp  += lx2; sp2 += lx2; 
	
	tmp = sp[0]+sp2[0];
    for (i = 0; i < 8; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    sp  += lx2; sp2 += lx2; 

    for (j = 2; j < 6; j++) {
      *dp++ = ((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2)*5;
      *dp++ = ((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2)*5;
      for (i = 2; i < 6; i++) 
		*dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*6 ;
      *dp++ = ((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2)*5;
      *dp++ = ((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2)*5;
      sp+= lx2; sp2+=lx2; 
    }

	tmp = sp[0]+sp2[0];
    for (i = 0; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ =  (unsigned int)((tmp+sp[8]+sp2[8]+2)>>2)*5 ;
    sp+= lx2; sp2+=lx2; 

    *dp++ = (unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2);
    for (i = 1; i < 7; i++) 
	  *dp++ = ((unsigned int)(tmp+(tmp=(sp[i+1]+sp2[i+1]))+2)>>2)*5 ;
    *dp++ =  (unsigned int)(tmp+sp[8]+sp2[8]+2);
    break;

  case 1:
    *dp++ += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[8]+sp2[8]))+2)>>2) << 1);
    sp+= lx2; sp2+= lx2; 

    *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[8]+sp2[8]))+2)>>2);
    sp+= lx2; sp2+= lx2; 
    
    for (j=2; j<4; j++) {
      *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[4]+sp2[4]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[5]+sp2[5]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
      *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
      sp+= lx2; sp2+= lx2;  
    }
  	break;

  case 2:
    for (j=0; j<2; j++) {
      *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[4]+sp2[4]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[5]+sp2[5]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
      *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
      sp+= lx2; sp2+= lx2;  
    }

    *dp++ += ((sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2);
    *dp++ += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    *dp++ += ((tmp+sp[8]+sp2[8]+2)>>2);
    sp+= lx2; sp2+= lx2; 

    *dp++ += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[3]+sp2[3]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[4]+sp2[4]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[5]+sp2[5]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[6]+sp2[6]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1);
    *dp++ += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1);
    break;

  case 3:
    dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
    dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
    dp[6] += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;
    sp  += lx2; sp2 += lx2; dp  += 8; 

    for (j=0; j<6; j++) {
      dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
	  dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
      dp[6] += (((unsigned int)(tmp+(tmp=(sp[7]+sp2[7]))+2)>>2) << 1) ;
      dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;
      sp  += lx2; sp2 += lx2; dp  += 8; ;
    }

    dp[4] += ((sp[4]+sp2[4]+(tmp=(sp[5]+sp2[5]))+2)>>2);
    dp[5] += ((tmp+(tmp=(sp[6]+sp2[6]))+2)>>2);
    dp[6] += ((tmp+(tmp=(sp[7]+sp2[7]))+2)>>2);
    dp[7] += (((unsigned int)(tmp+sp[8]+sp2[8]+2)>>2) << 1) ;

	break;

  case 4:
    dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
    dp[1] += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
    dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);
    sp  += lx2; sp2 += lx2; dp  += 8; 
   
    for (j=0; j<6; j++) {
      dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
      dp[1] += (((unsigned int)(tmp+(tmp=(sp[2]+sp2[2]))+2)>>2) << 1) ;
      dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
	  dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);
      sp  += lx2; sp2 += lx2; dp  += 8; 
    }

    dp[0] += (((unsigned int)(sp[0]+sp2[0]+(tmp=(sp[1]+sp2[1]))+2)>>2) << 1) ;
    dp[1] += ((tmp+(tmp=(sp[2]+sp2[2]))+2)>>2);
    dp[2] += ((tmp+(tmp=(sp[3]+sp2[3]))+2)>>2);
    dp[3] += ((tmp+sp[4]+sp2[4]+2)>>2);

  default:
  break;
  }
}

static void sv_recon_comp_obmc(SvH263DecompressInfo_t *H263Info, unsigned char *src, unsigned char *dst,
                            int lx, int lx2, int comp, int w, int h, int x, int y)
{
  int j,k;
  int xmb,ymb;
  int c8,t8,l8,r8;
  int ti8,li8,ri8;
  int xit,xib,xir,xil;
  int yit,yib,yir,yil;
  int vect,vecb,vecr,vecl;
  int nx[5],ny[5],xint,yint,xh[5],yh[5];
  int p[64],*pd;
  unsigned char *d,*s[5];

  xmb = (x>>4)+1;
  ymb = (y>>4)+1;

  c8  = (H263Info->modemap[ymb][xmb] == H263_MODE_INTER4V ? 1 : 0);

  t8  = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTER4V ? 1 : 0);
  ti8 = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTRA ? 1 : 0);
  ti8 = (H263Info->modemap[ymb-1][xmb] == H263_MODE_INTRA_Q ? 1 : ti8);

  l8  = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTER4V ? 1 : 0);
  li8 = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTRA ? 1 : 0);
  li8 = (H263Info->modemap[ymb][xmb-1] == H263_MODE_INTRA_Q ? 1 : li8);
  
  r8  = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTER4V ? 1 : 0);
  ri8 = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTRA ? 1 : 0);
  ri8 = (H263Info->modemap[ymb][xmb+1] == H263_MODE_INTRA_Q ? 1 : ri8);

  if (H263Info->pb_frame) ti8 = li8 = ri8 = 0;

  switch (comp+1) {

    case 1:
      vect = (ti8 ? (c8 ? 1 : 0) : (t8 ? 3 : 0)); 
      yit  = (ti8 ? ymb : ymb - 1); 
      xit = xmb;
      vecb = (c8 ? 3 : 0) ; yib = ymb; xib = xmb;
      vecl = (li8 ? (c8 ? 1 : 0) : (l8 ? 2 : 0)); 
      yil = ymb; 
      xil = (li8 ? xmb : xmb-1);
      vecr = (c8 ? 2 : 0) ; yir = ymb; xir = xmb;

      /* edge handling */
      if (ymb == 1) {
        yit = ymb;
        vect = (c8 ? 1 : 0);
      }
      if (xmb == 1) {
        xil = xmb;
        vecl = (c8 ? 1 : 0);
      }
      break;
  
    case 2:
      vect = (ti8 ? (c8 ? 2 : 0) : (t8 ? 4 : 0)); 
      yit = (ti8 ? ymb : ymb-1); 
      xit = xmb;
      vecb = (c8 ? 4 : 0) ; yib = ymb; xib = xmb;
      vecl = (c8 ? 1 : 0) ; yil = ymb; xil = xmb;
      vecr = (ri8 ? (c8 ? 2 : 0) : (r8 ? 1 : 0)); 
      yir = ymb; 
      xir = (ri8 ? xmb : xmb+1);

      /* edge handling */
      if (ymb == 1) {
        yit = ymb;
        vect = (c8 ? 2 : 0);
      }
      if (xmb == H263Info->mb_width) {
        xir = xmb;
        vecr = (c8 ? 2 : 0);
      }
      break;

    case 3:
      vect = (c8 ? 1 : 0) ; yit = ymb  ; xit = xmb;
      vecb = (c8 ? 3 : 0) ; yib = ymb  ; xib = xmb;
      vecl = (li8 ? (c8 ? 3 : 0) : (l8 ? 4 : 0)); 
      yil = ymb;  
      xil = (li8 ? xmb : xmb-1);
      vecr = (c8 ? 4 : 0) ; yir = ymb  ; xir = xmb;

      /* edge handling */
      if (xmb == 1) {
        xil = xmb;
        vecl = (c8 ? 3 : 0);
      }
      break;

    case 4:
      vect = (c8 ? 2 : 0) ; yit = ymb  ; xit = xmb;
      vecb = (c8 ? 4 : 0) ; yib = ymb  ; xib = xmb;
      vecl = (c8 ? 3 : 0) ; yil = ymb  ; xil = xmb;
      vecr = (ri8 ? (c8 ? 4 : 0) : (r8 ? 3 : 0)); 
      yir = ymb; 
      xir = (ri8 ? xmb : xmb+1);

      /* edge handling */
      if (xmb == H263Info->mb_width) {
        xir = xmb;
        vecr = (c8 ? 4 : 0);
      }
      break;

    default:
      svH263Error("Illegal block number in sv_recon_comp_obmc (sv_recon.c)\n");
      break;
  }

  nx[0] = H263Info->MV[0][c8 ? comp + 1 : 0][ymb][xmb];
  ny[0] = H263Info->MV[1][c8 ? comp + 1 : 0][ymb][xmb];
  
  nx[1] = H263Info->MV[0][vect][yit][xit]; ny[1] = H263Info->MV[1][vect][yit][xit];
  nx[2] = H263Info->MV[0][vecb][yib][xib]; ny[2] = H263Info->MV[1][vecb][yib][xib];
  nx[3] = H263Info->MV[0][vecr][yir][xir]; ny[3] = H263Info->MV[1][vecr][yir][xir];
  nx[4] = H263Info->MV[0][vecl][yil][xil]; ny[4] = H263Info->MV[1][vecl][yil][xil];

  for (k=0; k<5; k++) {
    xint  = nx[k]>>1;
    xh[k] = nx[k] & 1;
    yint  = ny[k]>>1;
    yh[k] = ny[k] & 1;
    s[k]  = src + lx2 * (y + yint) + x + xint;
  }
  
  d = dst + lx*y + x;
  pd = &p[0];

  if      (!xh[0] && !yh[0]) sv_reco(s[0],pd,lx2,0,0,8,0,8);
  else if (!xh[0] &&  yh[0]) sv_recvo(s[0],pd,lx2,0,0,8,0,8);
  else if ( xh[0] && !yh[0]) sv_recho(s[0],pd,lx2,0,0,8,0,8);
  else                       sv_rec4o(s[0],pd,lx2,0,0,8,0,8);

  if      (!xh[1] && !yh[1]) sv_reco(s[1],pd,lx2,1,0,8,0,4);
  else if (!xh[1] &&  yh[1]) sv_recvo(s[1],pd,lx2,1,0,8,0,4);
  else if ( xh[1] && !yh[1]) sv_recho(s[1],pd,lx2,1,0,8,0,4);
  else                       sv_rec4o(s[1],pd,lx2,1,0,8,0,4);

  if      (!xh[2] && !yh[2]) sv_reco(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else if (!xh[2] &&  yh[2]) sv_recvo(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else if ( xh[2] && !yh[2]) sv_recho(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);
  else                       sv_rec4o(s[2]+(lx2<<2),pd+32,lx2,2,0,8,4,8);

  if      (!xh[3] && !yh[3]) sv_reco(s[3],pd,lx2,3,4,8,0,8);
  else if (!xh[3] &&  yh[3]) sv_recvo(s[3],pd,lx2,3,4,8,0,8);
  else if ( xh[3] && !yh[3]) sv_recho(s[3],pd,lx2,3,4,8,0,8);
  else                       sv_rec4o(s[3],pd,lx2,3,4,8,0,8);

  if      (!xh[4] && !yh[4]) sv_reco(s[4],pd,lx2,4,0,4,0,8);
  else if (!xh[4] &&  yh[4]) sv_recvo(s[4],pd,lx2,4,0,4,0,8);
  else if ( xh[4] && !yh[4]) sv_recho(s[4],pd,lx2,4,0,4,0,8);
  else                       sv_rec4o(s[4],pd,lx2,4,0,4,0,8);

  for (j = 0; j < 8; j++) {
    d[0] = (pd[0] + 4 )>>3;	
    d[1] = (pd[1] + 4 )>>3;	
    d[2] = (pd[2] + 4 )>>3;	
    d[3] = (pd[3] + 4 )>>3;	
    d[4] = (pd[4] + 4 )>>3;	
    d[5] = (pd[5] + 4 )>>3;	
    d[6] = (pd[6] + 4 )>>3;	
    d[7] = (pd[7] + 4 )>>3;	
    d += lx;
    pd += 8;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\ratectrl.c ===
/* File: sv_h263_ratectl.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/* ABOUT THE NEW RATE CONTROL:

   ratectrl.c now contains the new simplified rate control we used to
   generate the MPEG-4 anchors, instead of the TMN5 rate control. This
   simplified scheme works fine to get a specified mean bitrate for
   the whole sequence for easy comparison with other coding schemes,
   but it is too simple to guarantee a minimum delay in real
   videophone applications. It does not skip any extra pictures after
   the first frame, and it uses a fixed frame rate. Its purpose is to
   achieve the target bitrate as a mean bitrate for the whole
   sequence. If the number of pictures encoded is very small, this
   will not always be possible because of the high number of bits
   spent on the first frame.

   The reason we have removed the TMN5 rate control is that we did not
   think it worked as well as it should, especially when PB-frames
   were used. Any real H.263 product would have had to improve it
   anyway. 

   When grabbing sequences from a framegrabber card, you will not
   always get the full reference frame rate, and the original sequence
   will have skipped frames. This was much easier to support with a
   fixed frame rate scheme.

   If you would like to include code for a rate control scheme which
   satisfies the HRD requirements in the H.263 standard as well as
   works for all types of sequences with and without PB-frames (for
   instance with the adaptive PB-frames as included in this version),
   please feel free to do so.

   If you think the TMN5 scheme worked well enough for you, and the
   simplified scheme is too simple, you can add the TMN5 code
   without too much work. However, this will not work with the
   adaptive PB-frames without a lot of changes, and also coding
   sequences which has a lower frame rate than the reference frame
   rate will not be possible without additional changes. */

/*
#define _SLIBDEBUG_
*/

#include <math.h>

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif


/**********************************************************************
 *
 *	Name:	        FrameUpdateQP
 *	Description:    updates quantizer once per frame for 
 *                      simplified rate control
 *	
 *      Returns:        new quantizer
 *	Side effects:
 *
 ***********************************************************************/

int sv_H263FrameUpdateQP(int buf, int bits, int frames_left, int QP, int B, 
                         float seconds) 
{
  int newQP, dQP;
  float buf_rest, buf_rest_pic;

  buf_rest = seconds * B - (float)buf;

  newQP = QP;

  if (frames_left > 0) {
    buf_rest_pic = buf_rest / (float)frames_left;
    _SlibDebug(_VERBOSE_,
        ScDebugPrintf(NULL, "  Simplified rate control for %d remaining pictures:\n", frames_left);
        ScDebugPrintf(NULL, "  Bits spent / left       : %8d / %d (%d per picture)\n", 
                                       buf, mnint(buf_rest), mnint(buf_rest_pic));
        ScDebugPrintf(NULL, "  Limits                  : %8.0f / %.0f\n", 
                                       buf_rest_pic / 1.15, buf_rest_pic * 1.15);
        ScDebugPrintf(NULL, "  Bits spent on last frame: %8d\n", bits)
        );
    dQP = (int) mmax(1,QP*0.1);


    if (bits > buf_rest_pic * 1.15) {
      newQP = mmin(31,QP+dQP);
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP -> new QP            : %2d -> %2d\n", QP, newQP) );
    }
    else if (bits < buf_rest_pic / 1.15) {
      newQP = mmax(1,QP-dQP);
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP -> new QP            : %2d -> %2d\n", QP, newQP) );
    }
    else {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "  QP not changed\n", QP, newQP) );
    }
  }
  return newQP;
}



/* rate control static variables */

static float B_prev;     /* number of bits spent for the previous frame */
static float B_target;   /* target number of bits/picture               */
static float global_adj; /* due to bits spent for the previous frame    */

void sv_H263GOBInitRateCntrl()
{
  B_prev = (float)0.0;
}

void sv_H263GOBUpdateRateCntrl(int bits)
{
  B_prev = (float)bits;
}

int sv_H263GOBInitQP(float bit_rate, float target_frame_rate, float QP_mean) 

/* QP_mean = mean quantizer parameter for the previous picture */
/* bitcount = current total bit count                          */
/* To calculate bitcount in coder.c, do something like this :  */
/* int bitcount;                                               */
/* AddBitsPicture(bits);                                       */
/* bitcount = bits->total;                                     */
{
  int newQP;

  B_target = bit_rate / target_frame_rate;

  /* compute picture buffer descrepency as of the previous picture */

  if (B_prev != 0.0) {
    global_adj = (B_prev - B_target) / (2*B_target);
  }
  else {
    global_adj = (float)0.0;
  }
  newQP = (int)(QP_mean + QP_mean * global_adj + (float)0.5);
  newQP = mmax(1,mmin(31,newQP));  

  return newQP;
}


/*********************************************************************
*   Name:          UpdateQuantizer
*
*
* Description: This function generates a new quantizer step size based
*                  on bits spent up until current macroblock and bits
*                  spent from the previous picture.  Note: this
*                  routine should be called at the beginning of each
*                  macroblock line as specified by TMN4. However, this
*                  can be done at any macroblock if so desired.
*
*  Input: current macroblock number (raster scan), mean quantizer
*  paramter for previous picture, bit rate, source frame rate,
*  hor. number of macroblocks, vertical number of macroblocks, total #
*  of bits used until now in the current picture.
*
*  Returns: Returns a new quantizer step size for the use of current
*  macroblock Note: adjustment to fit with 2-bit DQUANT should be done
*  in the calling program.
*
*  Side Effects:  
*
*  Date: 1/5/95    Author: Anurag Bist
*
**********************************************************************/


int sv_H263GOBUpdateQP(int mb, float QP_mean, float bit_rate, 
                       int mb_width, int mb_height, int bitcount,
					   int NOgob, int *VARgob, int pb_frame) 

/* mb = macroblock index number */
/* QP_mean = mean quantizer parameter for the previous picture */
/* bitcount = total # of bits used until now in the current picture */
{
  int newQP=16, i, VARavg=0;
  float local_adj, descrepency, projection;
  double VARratio=0.0;

 if(NOgob) {
	 for(i=0;i<NOgob;i++) VARavg += VARgob[i];  
	 VARavg /= NOgob;
 }
  /* compute expected buffer fullness */
  projection = mb * (B_target / (mb_width*mb_height));
    
  /* measure descrepency between current fullness and projection */
  descrepency= ((float)bitcount - projection);

  /* scale */
  local_adj = 12 * descrepency / bit_rate;  

  if(NOgob) {
    VARratio = (double)VARgob[NOgob] / (double)VARavg ; 
    VARratio = log(VARratio) / 0.693147 ;
	if(pb_frame) local_adj += (float) (VARratio / 4.0);
	else         local_adj += (float) (VARratio / 2.0);
  }

  newQP = (int)(QP_mean + QP_mean * (global_adj + local_adj) + (float)0.5);

  newQP = mmax(1,mmin(31,newQP));  

  return newQP;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\render.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: slib_render.c,v $
 * Revision 1.1.2.3  1996/10/28  17:32:35  Hans_Graves
 * 	MME-1402, 1431, 1435: Timestamp related changes.
 * 	[1996/10/28  17:23:09  Hans_Graves]
 *
 * Revision 1.1.2.2  1996/10/12  17:18:58  Hans_Graves
 * 	Move render related code out of slib_api.c
 * 	[1996/10/11  21:19:37  Hans_Graves]
 * 
 * $EndLog$
 */

/*
#define _SLIBDEBUG_
*/

#define SLIB_INTERNAL
#include "slib.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"
#define _DEBUG_     0  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

SlibStatus_t slibConvertAudio(SlibInfo_t *Info,
                              void *inbuf, unsigned dword inbufsize,
                              unsigned int insps, unsigned int inbps,
                              void **poutbuf, unsigned dword *poutbufsize,
                              unsigned int outsps, unsigned int outbps,
                              unsigned int channels)
{
  char *fromptr, *toptr;
  unsigned dword outbufsize, samples, count;
  unsigned dword ratio, spsratio;
  char *outbuf;
  if (inbps==outbps && insps==outsps)/* input and output formats are the same */
  {
    if (*poutbuf==NULL)
    {
      SlibAllocSubBuffer(inbuf, inbufsize);
      *poutbuf=inbuf;
    }
    else
      memcpy(*poutbuf, inbuf, inbufsize);
    *poutbufsize=inbufsize;
    return(SlibErrorNone);
  }
  samples = inbufsize/(inbps/2);
  ratio=(insps*inbps*256)/(outsps*outbps);
  outbufsize = (inbufsize*256)/ratio;
  spsratio=(insps*256)/outsps;
  if (spsratio!=64 && spsratio!=128 && spsratio!=256 && spsratio!=512)
    return(SlibErrorUnsupportedFormat);
  if (*poutbuf==NULL)
  {
    outbuf=SlibAllocBuffer(outbufsize);
    *poutbuf=outbuf;
    if (outbuf==NULL)
      return(SlibErrorMemory);
  }
  else
    outbuf=*poutbuf;
  *poutbufsize=outbufsize;
  fromptr = (char *)inbuf;
  toptr = (char *)outbuf;
  if (inbps==16 && outbps==8) /* 16 bit -> 8 bit */
  {
    fromptr++;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = *fromptr+128;
          *toptr++ = *fromptr+128;
        }
      else
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      for (count=inbufsize/2; count; count--, fromptr+=2)
        *toptr++ = *fromptr+128;
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
          *toptr++ = *fromptr+128;
      else
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0]+128;
          *toptr++ = fromptr[2]+128;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==16) /* 8 bit -> 16 bit */
  {
    unsigned word left, right;
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==256) /* insps==outsps */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          left=(*fromptr-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          left=(fromptr[0]-128)<<8;
          right=(fromptr[1]-128)<<8;
          *toptr++ = left&0xFF;
          *toptr++ = left>>8;
          *toptr++ = right&0xFF;
          *toptr++ = right>>8;
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==16 && outbps==16) /* 16 bit -> 16 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      else /* stereo */
        for (count=inbufsize/8; count; count--, fromptr+=8)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[2];
          *toptr++ = fromptr[3];
        }
      return(SlibErrorNone);
    }
  }
  else if (inbps==8 && outbps==8) /* 8 bit -> 8 bit */
  {
    if (spsratio==64) /* insps==outsps/4 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==128) /* insps==outsps/2 */
    {
      if (channels==1)
        for (count=inbufsize; count; count--, fromptr++)
        {
          *toptr++ = *fromptr;
          *toptr++ = *fromptr;
        }
      else /* stereo */
        for (count=inbufsize/2; count; count--, fromptr+=2)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
    else if (spsratio==512) /* insps==outsps*2 */
    {
      if (channels==1)
        for (count=inbufsize/2; count; count--, fromptr+=2)
          *toptr++ = *fromptr;
      else /* stereo */
        for (count=inbufsize/4; count; count--, fromptr+=4)
        {
          *toptr++ = fromptr[0];
          *toptr++ = fromptr[1];
        }
      return(SlibErrorNone);
    }
  }
  *poutbufsize=0;
  return(SlibErrorUnsupportedFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\putbits.c ===
/* File: sv_h263_putbits.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#endif

#define H263_EHUFF struct Modified_Encoder_Huffman

H263_EHUFF
{
  int n;
  int *Hlen;
  int *Hcode;
};

/* from sactbls.h */

int cumf_COD[3]={16383, 6849, 0};

int cumf_MCBPC[22]={16383, 4105, 3088, 2367, 1988, 1621, 1612, 1609, 1608, 496, 353, 195, 77, 22, 17, 12, 5, 4, 3, 2, 1, 0};

int cumf_MCBPC_intra[10]={16383, 7410, 6549, 5188, 442, 182, 181, 141, 1, 0};

int cumf_MODB[4]={16383, 6062, 2130, 0};

int cumf_YCBPB[3]={16383,6062,0};

int cumf_UVCBPB[3]={16383,491,0};

int cumf_CBPY[17]={16383, 14481, 13869, 13196, 12568, 11931, 11185, 10814, 9796, 9150, 8781, 7933, 6860, 6116, 4873, 3538, 0};

int cumf_CBPY_intra[17]={16383, 13619, 13211, 12933, 12562, 12395, 11913, 11783, 11004, 10782, 10689, 9928, 9353, 8945, 8407, 7795, 0};

int cumf_DQUANT[5]={16383, 12287, 8192, 4095, 0};

int cumf_MVD[65]={16383, 16380, 16369, 16365, 16361, 16357, 16350, 16343, 16339, 16333, 16326, 16318, 16311, 16306, 16298, 16291, 16283, 16272, 16261, 16249, 16235, 16222, 16207, 16175, 16141, 16094, 16044, 15936, 15764, 15463, 14956, 13924, 11491, 4621, 2264, 1315, 854, 583, 420, 326, 273, 229, 196, 166, 148, 137, 123, 114, 101, 91, 82, 76, 66, 59, 53, 46, 36, 30, 26, 24, 18, 14, 10, 5, 0};

int cumf_INTRADC[255]={16383, 16380, 16379, 16378, 16377, 16376, 16370, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16343, 16238, 16237, 16236, 16230, 16221, 16220, 16205, 16190, 16169, 16151, 16130, 16109, 16094, 16070, 16037, 16007, 15962, 15938, 15899, 15854, 15815, 15788, 15743, 15689, 15656, 15617, 15560, 15473, 15404, 15296, 15178, 15106, 14992, 14868, 14738, 14593, 14438, 14283, 14169, 14064, 14004, 13914, 13824, 13752, 13671, 13590, 13515, 13458, 13380, 13305, 13230, 13143, 13025, 12935, 12878, 12794, 12743, 12656, 12596, 12521, 12443, 12359, 12278, 12200, 12131, 12047, 12002, 11948, 11891, 11828, 11744, 11663, 11588, 11495, 11402, 11288, 11204, 11126, 11039, 10961, 10883, 10787, 10679, 10583, 10481, 10360, 10227, 10113, 9961, 9828, 9717, 9584, 9485, 9324, 9112, 9019, 8908, 8766, 8584, 8426, 8211, 7920, 7663, 7406, 7152, 6904, 6677, 6453, 6265, 6101, 5904, 5716, 5489, 5307, 5056, 4850, 4569, 4284, 3966, 3712, 3518, 3342, 3206, 3048, 2909, 2773, 2668, 2596, 2512, 2370, 2295, 2232, 2166, 2103, 2022, 1956, 1887, 1830, 1803, 1770, 1728, 1674, 1635, 1599, 1557, 1500, 1482, 1434, 1389, 1356, 1317, 1284, 1245, 1200, 1179, 1140, 1110, 1092, 1062, 1044, 1035, 1014, 1008, 993, 981, 954, 936, 912, 894, 876, 864, 849, 828, 816, 801, 792, 777, 756, 732, 690, 660, 642, 615, 597, 576, 555, 522, 489, 459, 435, 411, 405, 396, 387, 375, 360, 354, 345, 344, 329, 314, 293, 278, 251, 236, 230, 224, 215, 214, 208, 199, 193, 184, 178, 169, 154, 127, 100, 94, 73, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 20, 19, 18, 17, 16, 15, 9, 0};

int cumf_TCOEF1[104]={16383, 13455, 12458, 12079, 11885, 11800, 11738, 11700, 11681, 11661, 11651, 11645, 11641, 10572, 10403, 10361, 10346, 10339, 10335, 9554, 9445, 9427, 9419, 9006, 8968, 8964, 8643, 8627, 8624, 8369, 8354, 8352, 8200, 8192, 8191, 8039, 8036, 7920, 7917, 7800, 7793, 7730, 7727, 7674, 7613, 7564, 7513, 7484, 7466, 7439, 7411, 7389, 7373, 7369, 7359, 7348, 7321, 7302, 7294, 5013, 4819, 4789, 4096, 4073, 3373, 3064, 2674, 2357, 2177, 1975, 1798, 1618, 1517, 1421, 1303, 1194, 1087, 1027, 960, 890, 819, 758, 707, 680, 656, 613, 566, 534, 505, 475, 465, 449, 430, 395, 358, 335, 324, 303, 295, 286, 272, 233, 215, 0};

int cumf_TCOEF2[104]={16383, 13582, 12709, 12402, 12262, 12188, 12150, 12131, 12125, 12117, 12113, 12108, 12104, 10567, 10180, 10070, 10019, 9998, 9987, 9158, 9037, 9010, 9005, 8404, 8323, 8312, 7813, 7743, 7726, 7394, 7366, 7364, 7076, 7062, 7060, 6810, 6797, 6614, 6602, 6459, 6454, 6304, 6303, 6200, 6121, 6059, 6012, 5973, 5928, 5893, 5871, 5847, 5823, 5809, 5796, 5781, 5771, 5763, 5752, 4754, 4654, 4631, 3934, 3873, 3477, 3095, 2758, 2502, 2257, 2054, 1869, 1715, 1599, 1431, 1305, 1174, 1059, 983, 901, 839, 777, 733, 683, 658, 606, 565, 526, 488, 456, 434, 408, 380, 361, 327, 310, 296, 267, 259, 249, 239, 230, 221, 214, 0};

int cumf_TCOEF3[104]={16383, 13532, 12677, 12342, 12195, 12112, 12059, 12034, 12020, 12008, 12003, 12002, 12001, 10586, 10297, 10224, 10202, 10195, 10191, 9223, 9046, 8999, 8987, 8275, 8148, 8113, 7552, 7483, 7468, 7066, 7003, 6989, 6671, 6642, 6631, 6359, 6327, 6114, 6103, 5929, 5918, 5792, 5785, 5672, 5580, 5507, 5461, 5414, 5382, 5354, 5330, 5312, 5288, 5273, 5261, 5247, 5235, 5227, 5219, 4357, 4277, 4272, 3847, 3819, 3455, 3119, 2829, 2550, 2313, 2104, 1881, 1711, 1565, 1366, 1219, 1068, 932, 866, 799, 750, 701, 662, 605, 559, 513, 471, 432, 403, 365, 336, 312, 290, 276, 266, 254, 240, 228, 223, 216, 206, 199, 192, 189, 0};

int cumf_TCOEFr[104]={16383, 13216, 12233, 11931, 11822, 11776, 11758, 11748, 11743, 11742, 11741, 11740, 11739, 10203, 9822, 9725, 9691, 9677, 9674, 8759, 8609, 8576, 8566, 7901, 7787, 7770, 7257, 7185, 7168, 6716, 6653, 6639, 6276, 6229, 6220, 5888, 5845, 5600, 5567, 5348, 5327, 5160, 5142, 5004, 4900, 4798, 4743, 4708, 4685, 4658, 4641, 4622, 4610, 4598, 4589, 4582, 4578, 4570, 4566, 3824, 3757, 3748, 3360, 3338, 3068, 2835, 2592, 2359, 2179, 1984, 1804, 1614, 1445, 1234, 1068, 870, 739, 668, 616, 566, 532, 489, 453, 426, 385, 357, 335, 316, 297, 283, 274, 266, 259, 251, 241, 233, 226, 222, 217, 214, 211, 209, 208, 0};

int cumf_TCOEF1_intra[104]={16383, 13383, 11498, 10201, 9207, 8528, 8099, 7768, 7546, 7368, 7167, 6994, 6869, 6005, 5474, 5220, 5084, 4964, 4862, 4672, 4591, 4570, 4543, 4397, 4337, 4326, 4272, 4240, 4239, 4212, 4196, 4185, 4158, 4157, 4156, 4140, 4139, 4138, 4137, 4136, 4125, 4124, 4123, 4112, 4111, 4110, 4109, 4108, 4107, 4106, 4105, 4104, 4103, 4102, 4101, 4100, 4099, 4098, 4097, 3043, 2897, 2843, 1974, 1790, 1677, 1552, 1416, 1379, 1331, 1288, 1251, 1250, 1249, 1248, 1247, 1236, 1225, 1224, 1223, 1212, 1201, 1200, 1199, 1198, 1197, 1196, 1195, 1194, 1193, 1192, 1191, 1190, 1189, 1188, 1187, 1186, 1185, 1184, 1183, 1182, 1181, 1180, 1179, 0};

int cumf_TCOEF2_intra[104]={16383, 13242, 11417, 10134, 9254, 8507, 8012, 7556, 7273, 7062, 6924, 6839, 6741, 6108, 5851, 5785, 5719, 5687, 5655, 5028, 4917, 4864, 4845, 4416, 4159, 4074, 3903, 3871, 3870, 3765, 3752, 3751, 3659, 3606, 3580, 3541, 3540, 3514, 3495, 3494, 3493, 3474, 3473, 3441, 3440, 3439, 3438, 3425, 3424, 3423, 3422, 3421, 3420, 3401, 3400, 3399, 3398, 3397, 3396, 2530, 2419, 2360, 2241, 2228, 2017, 1687, 1576, 1478, 1320, 1281, 1242, 1229, 1197, 1178, 1152, 1133, 1114, 1101, 1088, 1087, 1086, 1085, 1072, 1071, 1070, 1069, 1068, 1067, 1066, 1065, 1064, 1063, 1062, 1061, 1060, 1059, 1058, 1057, 1056, 1055, 1054, 1053, 1052, 0};

int cumf_TCOEF3_intra[104]={16383, 12741, 10950, 10071, 9493, 9008, 8685, 8516, 8385, 8239, 8209, 8179, 8141, 6628, 5980, 5634, 5503, 5396, 5327, 4857, 4642, 4550, 4481, 4235, 4166, 4151, 3967, 3922, 3907, 3676, 3500, 3324, 3247, 3246, 3245, 3183, 3168, 3084, 3069, 3031, 3030, 3029, 3014, 3013, 2990, 2975, 2974, 2973, 2958, 2943, 2928, 2927, 2926, 2925, 2924, 2923, 2922, 2921, 2920, 2397, 2298, 2283, 1891, 1799, 1591, 1445, 1338, 1145, 1068, 1006, 791, 768, 661, 631, 630, 615, 592, 577, 576, 561, 546, 523, 508, 493, 492, 491, 476, 475, 474, 473, 472, 471, 470, 469, 468, 453, 452, 451, 450, 449, 448, 447, 446, 0};

int cumf_TCOEFr_intra[104]={16383, 12514, 10776, 9969, 9579, 9306, 9168, 9082, 9032, 9000, 8981, 8962, 8952, 7630, 7212, 7053, 6992, 6961, 6940, 6195, 5988, 5948, 5923, 5370, 5244, 5210, 4854, 4762, 4740, 4384, 4300, 4288, 4020, 3968, 3964, 3752, 3668, 3511, 3483, 3354, 3322, 3205, 3183, 3108, 3046, 2999, 2981, 2974, 2968, 2961, 2955, 2949, 2943, 2942, 2939, 2935, 2934, 2933, 2929, 2270, 2178, 2162, 1959, 1946, 1780, 1651, 1524, 1400, 1289, 1133, 1037, 942, 849, 763, 711, 591, 521, 503, 496, 474, 461, 449, 442, 436, 426, 417, 407, 394, 387, 377, 373, 370, 367, 366, 365, 364, 363, 362, 358, 355, 352, 351, 350, 0};

int cumf_SIGN[3]={16383, 8416, 0};

int cumf_LAST[3]={16383, 9469, 0};

int cumf_LAST_intra[3]={16383, 2820, 0};

int cumf_RUN[65]={16383, 15310, 14702, 13022, 11883, 11234, 10612, 10192, 9516, 9016, 8623, 8366, 7595, 7068, 6730, 6487, 6379, 6285, 6177, 6150, 6083, 5989, 5949, 5922, 5895, 5828, 5774, 5773, 5394, 5164, 5016, 4569, 4366, 4136, 4015, 3867, 3773, 3692, 3611, 3476, 3341, 3301, 2787, 2503, 2219, 1989, 1515, 1095, 934, 799, 691, 583, 435, 300, 246, 206, 125, 124, 97, 57, 30, 3, 2, 1, 0};

int cumf_RUN_intra[65]={16383, 10884, 8242, 7124, 5173, 4745, 4246, 3984, 3034, 2749, 2607, 2298, 966, 681, 396, 349, 302, 255, 254, 253, 206, 159, 158, 157, 156, 155, 154, 153, 106, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

int cumf_LEVEL[255]={16383, 16382, 16381, 16380, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16310, 16309, 16308, 16307, 16306, 16305, 16304, 16303, 16302, 16301, 16300, 16299, 16298, 16297, 16296, 16295, 16294, 16293, 16292, 16291, 16290, 16289, 16288, 16287, 16286, 16285, 16284, 16283, 16282, 16281, 16280, 16279, 16278, 16277, 16250, 16223, 16222, 16195, 16154, 16153, 16071, 15989, 15880, 15879, 15878, 15824, 15756, 15674, 15606, 15538, 15184, 14572, 13960, 10718, 7994, 5379, 2123, 1537, 992, 693, 611, 516, 448, 421, 380, 353, 352, 284, 257, 230, 203, 162, 161, 160, 133, 132, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

int cumf_LEVEL_intra[255]={16383, 16379, 16378, 16377, 16376, 16375, 16374, 16373, 16372, 16371, 16370, 16369, 16368, 16367, 16366, 16365, 16364, 16363, 16362, 16361, 16360, 16359, 16358, 16357, 16356, 16355, 16354, 16353, 16352, 16351, 16350, 16349, 16348, 16347, 16346, 16345, 16344, 16343, 16342, 16341, 16340, 16339, 16338, 16337, 16336, 16335, 16334, 16333, 16332, 16331, 16330, 16329, 16328, 16327, 16326, 16325, 16324, 16323, 16322, 16321, 16320, 16319, 16318, 16317, 16316, 16315, 16314, 16313, 16312, 16311, 16268, 16267, 16224, 16223, 16180, 16179, 16136, 16135, 16134, 16133, 16132, 16131, 16130, 16129, 16128, 16127, 16126, 16061, 16018, 16017, 16016, 16015, 16014, 15971, 15970, 15969, 15968, 15925, 15837, 15794, 15751, 15750, 15749, 15661, 15618, 15508, 15376, 15288, 15045, 14913, 14781, 14384, 13965, 13502, 13083, 12509, 12289, 12135, 11892, 11738, 11429, 11010, 10812, 10371, 9664, 9113, 8117, 8116, 8028, 6855, 5883, 4710, 4401, 4203, 3740, 3453, 3343, 3189, 2946, 2881, 2661, 2352, 2132, 1867, 1558, 1382, 1250, 1162, 1097, 1032, 967, 835, 681, 549, 439, 351, 350, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 255, 212, 211, 210, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 115, 114, 113, 112, 111, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};

/* from indices.h */

int codtab[2] = {0,1};

int mcbpctab[21] = {0,16,32,48,1,17,33,49,2,18,34,50,3,19,35,51,4,20,36,52,255};

int mcbpc_intratab[9] = {3,19,35,51,4,20,36,52,255};

int cbpytab[16] = {15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0};

int cbpy_intratab[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};

int dquanttab[4] = {1,0,3,4};

int mvdtab[64] = {32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};

int intradctab[254] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,255,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254};

int tcoeftab[103] = {1,2,3,4,5,6,7,8,9,10,11,12,17,18,19,20,21,22,33,34,35,36,49,50,51,65,66,67,81,82,83,97,98,99,113,114,129,130,145,146,161,162,177,193,209,225,241,257,273,289,305,321,337,353,369,385,401,417,4097,4098,4099,4113,4114,4129,4145,4161,4177,4193,4209,4225,4241,4257,4273,4289,4305,4321,4337,4353,4369,4385,4401,4417,4433,4449,4465,4481,4497,4513,4529,4545,4561,4577,4593,4609,4625,4641,4657,4673,4689,4705,4721,4737,7167};

int signtab[2] = {0,1};

int lasttab[2] = {0,1};

int last_intratab[2] = {0,1};

int runtab[64] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63};

int leveltab[254] = {129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127};


int arith_used = 0;

int CodeCoeff(ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs);
int Code_sac_Coeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs);
int CodeTCoef(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int mod_index, int position, int intra);

static int sv_H263HuffEncode(ScBitstream_t *BSOut, int val,H263_EHUFF *huff);

/**********************************************************************
 *
 *	Name:		CountBitsMB
 *	Description:    counts bits used for MB info
 *	
 *	Input:	        Mode, COD, CBP, Picture and Bits structures
 *	Returns:       
 *	Side effects:
 *
 ***********************************************************************/

void sv_H263CountBitsMB(ScBitstream_t *BSOut, int Mode, int COD, int CBP,
                        int CBPB, H263_Pict *pic, H263_Bits *bits)
{
  extern H263_EHUFF *vlc_cbpy, *vlc_cbpcm, *vlc_cbpcm_intra;
  int cbpy, cbpcm, length;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsMB(CBP=0x%X) MB=%d COD=%d\n",
                                                            CBP, pic->MB, COD) );
  if (pic->picture_coding_type == H263_PCT_INTER) {
    svH263mputv(1,COD);
    bits->COD++;
  }

  if (COD)  return;    /* not coded */

  /* CBPCM */
  cbpcm = Mode | ((CBP&3)<<4);
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "CBPCM (CBP=%d) (cbpcm=%d): \n", CBP, cbpcm) );
  if (pic->picture_coding_type == H263_PCT_INTRA)
    length = sv_H263HuffEncode(BSOut, cbpcm,vlc_cbpcm_intra);
  else
    length = sv_H263HuffEncode(BSOut, cbpcm,vlc_cbpcm);
  bits->CBPCM += length;

    /* MODB & CBPB */
  if (pic->PB) {
    switch (pic->MODB) {
    case H263_PBMODE_NORMAL:
      svH263mputv(1,0);
      bits->MODB += 1;
      break;
    case H263_PBMODE_MVDB:
      svH263mputv(2,2);
      bits->MODB += 2;
      break;
    case H263_PBMODE_CBPB_MVDB:
      svH263mputv(2,3);
      bits->MODB += 2;
      /* CBPB */
      svH263mputv(6,CBPB);
      bits->CBPB += 6;
      break;
    }
    _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "MODB: %d, CBPB: %d\n", pic->MODB, CBPB) );
  }
    
  /* CBPY */
  cbpy = CBP>>2;
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) /* Intra */
    cbpy = cbpy^15;
    _SlibDebug(_DEBUG_,
      ScDebugPrintf(NULL, "CBPY (CBP=%d) (cbpy=%d): \n",CBP,cbpy) );
  length = sv_H263HuffEncode(BSOut, cbpy, vlc_cbpy);
  bits->CBPY += length;
  
  /* DQUANT */
  if ((Mode == H263_MODE_INTER_Q) || (Mode == H263_MODE_INTRA_Q)) {
    switch (pic->DQUANT) {
    case -1:
      svH263mputv(2,0);
      break;
    case -2:
      svH263mputv(2,1);
      break;
    case 1:
      svH263mputv(2,2);
      break;
    case 2:
      svH263mputv(2,3);
      break;
    default:
      _SlibDebug(_WARN_,
        ScDebugPrintf(NULL, "sv_H263CountBitsMB() Invalid DQUANT: %d\n", pic->DQUANT) );
      return;
    }
    bits->DQUANT += 2;
  }
  return;
}

/**********************************************************************
 *
 *      Name:           Count_sac_BitsMB
 *      Description:    counts bits used for MB info using SAC models
 *                      modified from CountBitsMB
 *
 *      Input:          Mode, COD, CBP, Picture and Bits structures
 *      Returns:	none
 *      Side effects:	Updates Bits structure.
 *
 ***********************************************************************/
 
void sv_H263CountSACBitsMB(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            int Mode,int COD,int CBP,int CBPB,H263_Pict *pic,H263_Bits *bits)
{
  int cbpy, cbpcm, length, i;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountSACBitsMB(CBP=0x%X) MB=%d COD=%d\n",
                                                            CBP, pic->MB, COD) );
 
  arith_used = 1;
 
  /* COD */
  if (pic->picture_coding_type == H263_PCT_INTER)
    bits->COD+=sv_H263AREncode(H263Info, BSOut, COD, cumf_COD);
 
  if (COD)  return;    /* not coded */
 
  /* CBPCM */
   cbpcm = Mode | ((CBP&3)<<4);
  _SlibDebug(_DEBUG_,
      ScDebugPrintf(H263Info->dbg, "CBPCM (CBP=%d) (cbpcm=%d): \n",CBP,cbpcm) );
  if (pic->picture_coding_type == H263_PCT_INTRA)
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpcm,mcbpc_intratab,9),cumf_MCBPC_intra);
  else
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpcm,mcbpctab,21),cumf_MCBPC);
 
  bits->CBPCM += length;
 
  /* MODB & CBPB */
   if (pic->PB) {
     switch (pic->MODB) {
     case H263_PBMODE_NORMAL:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 0, cumf_MODB);
       break;
     case H263_PBMODE_MVDB:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 1, cumf_MODB);
       break;
     case H263_PBMODE_CBPB_MVDB:
       bits->MODB += sv_H263AREncode(H263Info, BSOut, 2, cumf_MODB);
       /* CBPB */
       for(i=5; i>1; i--)
	 bits->CBPB += sv_H263AREncode(H263Info, BSOut, ((CBPB & 1<<i)>>i), cumf_YCBPB);
       for(i=1; i>-1; i--)
	 bits->CBPB += sv_H263AREncode(H263Info, BSOut, ((CBPB & 1<<i)>>i), cumf_UVCBPB);
       break;
     }
     _SlibDebug(_VERBOSE_,
       ScDebugPrintf(H263Info->dbg, "MODB: %d, CBPB: %d\n", pic->MODB, CBPB) );
   }

  /* CBPY */
  cbpy = CBP>>2;
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) { /* Intra */
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpy,cbpy_intratab,16),cumf_CBPY_intra);
  } else {
    length = sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(cbpy,cbpytab,16),cumf_CBPY);
  }
  _SlibDebug(_VERBOSE_,
      ScDebugPrintf(H263Info->dbg, "CBPY (CBP=%d) (cbpy=%d):\n",CBP,cbpy) );
  bits->CBPY += length;
 
  /* DQUANT */
  if ((Mode == H263_MODE_INTER_Q) || (Mode == H263_MODE_INTRA_Q)) {
    bits->DQUANT += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(pic->DQUANT+2,dquanttab,4), cumf_DQUANT);
  }
  return;
}


/**********************************************************************
 *
 *	Name:		CountBitsSlice
 *	Description:    couonts bits used for slice (GOB) info
 *	
 *	Input:	        slice no., quantizer
 *
 ***********************************************************************/

int sv_H263CountBitsSlice(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                          int slice, int quant)
{
  int bits = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsSlice(slice=%d, quant=%d)\n",
                                     slice, quant) );

  if (arith_used) {
    bits+=sv_H263AREncoderFlush(H263Info, BSOut); /* Need to call before fixed length string output */
    arith_used = 0;
  }

  /* Picture Start Code */
  svH263mputv(H263_PSC_LENGTH,H263_PSC); /* PSC */
  bits += H263_PSC_LENGTH;

  /* Group Number */
  svH263mputv(5,slice);
  bits += 5;

  /* GOB Sub Bitstream Indicator */
  /* if CPM == 1: read 2 bits GSBI */
  /* not supported in this version */

  /* GOB Frame ID */

  svH263mputv(2, 0); 
  
  /* NB: in error-prone environments this value should change if 
     PTYPE in picture header changes. In this version of the encoder
     PTYPE only changes when PB-frames are used in the following cases:
     (i) after the first intra frame
     (ii) if the distance between two P-frames is very large 
     Therefore I haven't implemented this GFID change */
  /* GFID is not allowed to change unless PTYPE changes */
  bits += 2;

  /* Gquant */

  svH263mputv(5,quant);
  bits += 5;

  return bits;
}


/**********************************************************************
 *
 *	Name:		CountBitsCoeff
 *	Description:	counts bits used for coeffs
 *	
 *	Input:		qcoeff, coding mode CBP, bits structure, no. of 
 *                      coeffs
 *			
 *	Returns:	struct with no. of bits used
 *	Side effects:	
 *
 ***********************************************************************/

void sv_H263CountBitsCoeff(ScBitstream_t *BSOut, short *qcoeff, int Mode,
                           int CBP, H263_Bits *bits, int ncoeffs)
{
  int i;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountBitsCoeff(CBP=%d, ncoeffs=%d)\n",
                                       CBP, ncoeffs) );

  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) {
    for (i = 0; i < 4; i++) 
      bits->Y += CodeCoeff(BSOut, Mode, qcoeff,i,ncoeffs);
    
    for (i = 4; i < 6; i++) 
      bits->C += CodeCoeff(BSOut, Mode, qcoeff,i,ncoeffs);
  }
  else {
    for (i = 0; i < 4; i++) 
      if ((i==0 && CBP&32) || (i==1 && CBP&16) || (i==2 && CBP&8) || 
	      (i==3 && CBP&4)) 
	       bits->Y += CodeCoeff(BSOut, Mode, qcoeff, i, ncoeffs);      
    
    for (i = 4; i < 6; i++) 
      if ((i==4 && CBP&2) || (i==5 && CBP&1)) 
   	    bits->C += CodeCoeff(BSOut, Mode, qcoeff, i, ncoeffs);
  }
  return;
}
  
int CodeCoeff(ScBitstream_t *BSOut, int Mode, short *qcoeff, int block, int ncoeffs)
{
  int j, jj, bits;
  int prev_run, run, prev_level, level, first;
  int prev_ind, ind, prev_s, s, length;

  extern H263_EHUFF *vlc_3d;

  run = bits = 0;
  first = 1;
  prev_run = prev_level = prev_ind = level = s = prev_s = ind = 0;
  
  jj = (block + 1)*ncoeffs;
  for (j = block*ncoeffs; j< jj; j++) {
    /* Do this block's DC-coefficient first */
    if (!(j%ncoeffs) && (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q)) {
      /* DC coeff */
      if (qcoeff[block*ncoeffs] != 128)
	     svH263mputv(8,qcoeff[block*ncoeffs]);
      else
	     svH263mputv(8,255);
      bits += 8;
    }
    else {
      /* AC coeff */
      s = 0;
      /* Increment run if coeff is zero */
      if ((level = qcoeff[j]) == 0)  run++;
      else {
	    /* code run & level and count bits */
	    if (level < 0) {
	      s = 1;
	      level = -level;
	    }
	    ind = level | run<<4;
  	    ind = ind | 0<<12; /* Not last coeff */

	    if (!first) {
	      /* Encode the previous ind */
	      if (prev_level  < 13 && prev_run < 64) 
	        length = sv_H263HuffEncode(BSOut, prev_ind,vlc_3d);
	      else length = 0;
	      if (length == 0) {  /* Escape coding */
	 	    if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
	          sv_H263HuffEncode(BSOut, H263_ESCAPE,vlc_3d);
	        svH263mputv(1,0);
	        svH263mputv(6,prev_run);
	        svH263mputv(8,prev_level);
	        bits += 22;
	      }
	      else {
	        svH263mputv(1,prev_s);
	        bits += length + 1;
	      }
	    }
	    prev_run = run; prev_s = s;
	    prev_level = level; prev_ind = ind;

	    run = first = 0;
      }
    }
  }
  /* Encode the last coeff */
  if (!first) {

    /* if (H263_trace) fprintf(H263_trace_file,"Last coeff: "); */

    prev_ind = prev_ind | 1<<12;   /* last coeff */
    if (prev_level  < 13 && prev_run < 64) 
      length = sv_H263HuffEncode(BSOut, prev_ind,vlc_3d);
    else length = 0;
    if (length == 0) {  /* Escape coding */
      if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
	  sv_H263HuffEncode(BSOut, H263_ESCAPE,vlc_3d);
      svH263mputv(1,1);
      svH263mputv(6,prev_run);
      svH263mputv(8,prev_level);
      bits += 22;
    }
	else {
      svH263mputv(1,prev_s);
      bits += length + 1;
    }
  }
  return bits;
}

/**********************************************************************
 *
 *      Name:           Count_sac_BitsCoeff
 *                      counts bits using SAC models
 *
 *      Input:          qcoeff, coding mode CBP, bits structure, no. of
 *                      coeffs
 *
 *      Returns:        struct with no. of bits used
 *      Side effects:
 *
 ***********************************************************************/
 
void sv_H263CountSACBitsCoeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                              short *qcoeff,int Mode,
                              int CBP, H263_Bits *bits, int ncoeffs)
{
 
  int i;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountSACBitsCoeff(CBP=%d, ncoeffs=%d)\n",
                                           CBP, ncoeffs) );

  arith_used = 1;
 
  if (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q) {
    for (i = 0; i < 4; i++) {
      bits->Y += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff,i,ncoeffs);
    }
    for (i = 4; i < 6; i++) {
      bits->C += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff,i,ncoeffs);
    }
  }
  else {
    for (i = 0; i < 4; i++) {
      if ((i==0 && CBP&32) ||
          (i==1 && CBP&16) ||
          (i==2 && CBP&8)  ||
          (i==3 && CBP&4)) { 
        bits->Y += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff, i, ncoeffs);
      }
    }
    for (i = 4; i < 6; i++) {
      if ((i==4 && CBP&2) || (i==5 && CBP&1)) 
        bits->C += Code_sac_Coeff(H263Info, BSOut, Mode, qcoeff, i, ncoeffs);
    }
  }
  return;
}
 
int Code_sac_Coeff(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                   int Mode, short *qcoeff, int block, int ncoeffs)
{
  int j, jj, bits, mod_index, intra;
  int prev_run, run, prev_level, level, first, prev_position, position;
  int prev_ind, ind, prev_s, s, length;
 
  run = bits = 0;
  first = 1; position = 0; intra = 0;
 
  level = s = ind = 0;
  prev_run = prev_level = prev_ind = prev_s = prev_position = 0;
 
  intra = (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q);
 
  jj = (block + 1)*ncoeffs;
  for (j = block*ncoeffs; j< jj; j++) {
 
    if (!(j%ncoeffs) && intra) {
      if (qcoeff[block*ncoeffs]!=128)
        mod_index = sv_H263IndexFN(qcoeff[block*ncoeffs],intradctab,254);
      else
        mod_index = sv_H263IndexFN(255,intradctab,254);
      bits += sv_H263AREncode(H263Info, BSOut, mod_index, cumf_INTRADC);
    }
    else {
 
      s = 0;
      /* Increment run if coeff is zero */
      if ((level = qcoeff[j]) == 0) {
        run++;
      }
      else {
	/* code run & level and count bits */
	if (level < 0) {
	  s = 1;
	  level = -level;
	}
	ind = level | run<<4;
	ind = ind | 0<<12; /* Not last coeff */
	position++;
 
	if (!first) {
	  mod_index = sv_H263IndexFN(prev_ind, tcoeftab, 103);
	  if (prev_level < 13 && prev_run < 64)
	    length = CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
	  else
	    length = -1;
 
	  if (length == -1) {  /* Escape coding */
 
	    if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
 
	    mod_index = sv_H263IndexFN(H263_ESCAPE, tcoeftab, 103);
	    bits += CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(0, lasttab, 2), cumf_LAST_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(0, lasttab, 2), cumf_LAST);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN);
 
	    if (intra)
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), 
				cumf_LEVEL_intra);
	    else
	      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), 
				cumf_LEVEL);
 
	  }
	  else {
	    bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_s, signtab, 2), cumf_SIGN);
	    bits += length;
	  }
	}
 
	prev_run = run; prev_s = s;
	prev_level = level; prev_ind = ind;
	prev_position = position;
 
	run = first = 0;
 
      }
    }
  }
 
  /* Encode Last Coefficient */
 
  if (!first) {
    prev_ind = prev_ind | 1<<12;   /* last coeff */
    mod_index = sv_H263IndexFN(prev_ind, tcoeftab, 103);
 
    if (prev_level  < 13 && prev_run < 64)
      length = CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
    else
      length = -1;
 
    if (length == -1) {  /* Escape coding */

      if (prev_s == 1) {prev_level = (prev_level^0xff)+1;}
 
      mod_index = sv_H263IndexFN(H263_ESCAPE, tcoeftab, 103);
      bits += CodeTCoef(H263Info, BSOut, mod_index, prev_position, intra);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(1, lasttab, 2), cumf_LAST_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(1, lasttab, 2), cumf_LAST);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_run, runtab, 64), cumf_RUN);
 
      if (intra)
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), cumf_LEVEL_intra);
      else
        bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_level, leveltab, 254), cumf_LEVEL);
    }
    else {
      bits += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(prev_s, signtab, 2), cumf_SIGN);
      bits += length;
    }
  } /* last coeff */
 
  return bits;
}
 
/*********************************************************************
 *
 *      Name:           CodeTCoef
 *
 *      Description:    Encodes an AC Coefficient using the
 *                      relevant SAC model.
 *
 *      Input:          Model index, position in DCT block and intra/
 *			inter flag.
 *
 *      Returns:        Number of bits used.
 *
 *      Side Effects:   None
 *
 *********************************************************************/

int CodeTCoef(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, int mod_index, int position, int intra)
{
  int length;
 
  switch (position) {
    case 1:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF1_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF1);
        break;
    }
    case 2:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF2_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF2);
        break;
    }
    case 3:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF3_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEF3);
        break;
    }
    default:
    {
        if (intra)
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEFr_intra);
        else
          length = sv_H263AREncode(H263Info, BSOut, mod_index, cumf_TCOEFr);
        break;
    }
  }
 
  return length;
}

/**********************************************************************
 *
 *	Name:		FindCBP
 *	Description:	Finds the CBP for a macroblock
 *	
 *	Input:		qcoeff and mode
 *			
 *	Returns:	CBP
 *	Side effects:	
 *
 ***********************************************************************/

#if 0 /* merged into Quantizer */
int svH263FindCBP(short *qcoeff, int Mode, int ncoeffs)
{
  int i,j,jj;
  int CBP = 0;
  int intra = (Mode == H263_MODE_INTRA || Mode == H263_MODE_INTRA_Q);
  register short *ptr;

  /* Set CBP for this Macroblock */
  jj = ncoeffs - intra;
  qcoeff += intra;
  
  for (i=0; i < 6; i++, qcoeff += ncoeffs) {
	ptr = qcoeff; 
    for (j=0; j < jj; j++) if (*ptr++) {     
         CBP |= (32 >> i); 
		 break; 
	}
  }

  return CBP;
}
#endif

void sv_H263CountBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                            H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits, 
                            int x, int y, int Mode, int newgob, H263_Pict *pic)
{
  int y_vec, x_vec;
  extern H263_EHUFF *vlc_mv;
  int pmv0, pmv1;
  int start,stop,block;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountBitsVectors(x=%d, y=%d)\n", x, y) );

  x++;y++;

  if (Mode == H263_MODE_INTER4V) {
    start = 1; stop = 4;
  }
  else {
    start = 0; stop = 0;
  }

  for (block = start; block <= stop;  block++) {

    sv_H263FindPMV(MV,x,y,&pmv0,&pmv1, block, newgob, 1);

    x_vec = (2*MV[block][y][x]->x + MV[block][y][x]->x_half) - pmv0;
    y_vec = (2*MV[block][y][x]->y + MV[block][y][x]->y_half) - pmv1;

    if (!H263Info->long_vectors) {
      if (x_vec < -32) x_vec += 64;
      else if (x_vec > 31) x_vec -= 64;

      if (y_vec < -32) y_vec += 64;
      else if (y_vec > 31) y_vec -= 64;
    }
    else {
      if (pmv0 < -31 && x_vec < -63) x_vec += 64;
      else if (pmv0 > 32 && x_vec > 63) x_vec -= 64;

      if (pmv1 < -31 && y_vec < -63) y_vec += 64;
      else if (pmv1 > 32 && y_vec > 63) y_vec -= 64;
    }
    
    if (x_vec < 0) x_vec += 64;
    if (y_vec < 0) y_vec += 64;

    bits->vec += sv_H263HuffEncode(BSOut, x_vec,vlc_mv);
    bits->vec += sv_H263HuffEncode(BSOut, y_vec,vlc_mv);

  _SlibDebug(_DEBUG_,
      if (x_vec > 31) x_vec -= 64;
      if (y_vec > 31) y_vec -= 64;
      ScDebugPrintf(H263Info->dbg, "(x,y) = (%d,%d) - ",
	      (2*MV[block][y][x]->x + MV[block][y][x]->x_half),
	      (2*MV[block][y][x]->y + MV[block][y][x]->y_half));
      ScDebugPrintf(H263Info->dbg, "(Px,Py) = (%d,%d)\n", pmv0,pmv1);
      ScDebugPrintf(H263Info->dbg, "(x_diff,y_diff) = (%d,%d)\n",x_vec,y_vec)
          );
  }

  /* PB-frames delta vectors */
  if (pic->PB)
    if (pic->MODB == H263_PBMODE_MVDB || pic->MODB == H263_PBMODE_CBPB_MVDB) {

      x_vec = MV[5][y][x]->x;
      y_vec = MV[5][y][x]->y;

      /* x_vec and y_vec are the PB-delta vectors */
    
      if (x_vec < 0) x_vec += 64;
      if (y_vec < 0) y_vec += 64;

      bits->vec += sv_H263HuffEncode(BSOut, x_vec,vlc_mv);
      bits->vec += sv_H263HuffEncode(BSOut, y_vec,vlc_mv);

      _SlibDebug(_DEBUG_, 
         if (x_vec > 31) x_vec -= 64;
         if (y_vec > 31) y_vec -= 64;
         ScDebugPrintf(H263Info->dbg, "MVDB (x,y) = (%d,%d)\n",x_vec,y_vec) );
    }

  return;
}

void sv_H263CountSACBitsVectors(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                                H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], H263_Bits *bits,
                                int x, int y, int Mode, int newgob, H263_Pict *pic)
{
  int y_vec, x_vec;
  int pmv0, pmv1;
  int start,stop,block;
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "sv_H263CountSACBitsVectors(x=%d, y=%d)", x, y) );
 
  arith_used = 1;
  x++;y++;
 
  if (Mode == H263_MODE_INTER4V) {
    start = 1; stop = 4;
  }
  else {
    start = 0; stop = 0;
  }
 
  for (block = start; block <= stop;  block++) {
 
    sv_H263FindPMV(MV,x,y,&pmv0,&pmv1, block, newgob, 1);
 
    x_vec = (2*MV[block][y][x]->x + MV[block][y][x]->x_half) - pmv0;
    y_vec = (2*MV[block][y][x]->y + MV[block][y][x]->y_half) - pmv1;
 
    if (!H263Info->long_vectors) {
      if (x_vec < -32) x_vec += 64;
      else if (x_vec > 31) x_vec -= 64;

      if (y_vec < -32) y_vec += 64;
      else if (y_vec > 31) y_vec -= 64;
    }
    else {
      if (pmv0 < -31 && x_vec < -63) x_vec += 64;
      else if (pmv0 > 32 && x_vec > 63) x_vec -= 64;

      if (pmv1 < -31 && y_vec < -63) y_vec += 64;
      else if (pmv1 > 32 && y_vec > 63) y_vec -= 64;
    }

    if (x_vec < 0) x_vec += 64;
    if (y_vec < 0) y_vec += 64;
 
    bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(x_vec,mvdtab,64),cumf_MVD);
    bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(y_vec,mvdtab,64),cumf_MVD);
 
    _SlibDebug(_DEBUG_,
      if (x_vec > 31) x_vec -= 64;
      if (y_vec > 31) y_vec -= 64;
      ScDebugPrintf(H263Info->dbg, "(x,y) = (%d,%d) - ",
              (2*MV[block][y][x]->x + MV[block][y][x]->x_half),
              (2*MV[block][y][x]->y + MV[block][y][x]->y_half));
      ScDebugPrintf(H263Info->dbg, "(Px,Py) = (%d,%d)\n", pmv0,pmv1);
      ScDebugPrintf(H263Info->dbg, "(x_diff,y_diff) = (%d,%d)\n",x_vec,y_vec) );
  }

   /* PB-frames delta vectors */
  if (pic->PB)
    if (pic->MODB == H263_PBMODE_MVDB || pic->MODB == H263_PBMODE_CBPB_MVDB) {
 
      x_vec = MV[5][y][x]->x;
      y_vec = MV[5][y][x]->y;
 
      if (x_vec < -32)
 	x_vec += 64;
      else if (x_vec > 31)
 	x_vec -= 64;
      if (y_vec < -32)
 	y_vec += 64;
      else if (y_vec > 31)
 	y_vec -= 64;
      
      if (x_vec < 0) x_vec += 64;
      if (y_vec < 0) y_vec += 64;
      
      bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(x_vec,mvdtab,64),cumf_MVD);
      bits->vec += sv_H263AREncode(H263Info, BSOut, sv_H263IndexFN(y_vec,mvdtab,64),cumf_MVD);
      
      _SlibDebug(_DEBUG_, 
        if (x_vec > 31) x_vec -= 64;
        if (y_vec > 31) y_vec -= 64;
        ScDebugPrintf(H263Info->dbg, "PB delta vectors: MVDB (x,y) = (%d,%d)\n",x_vec,y_vec)
        );
    }
  
  return;
}

void sv_H263FindPMV(H263_MotionVector *MV[6][H263_MBR+1][H263_MBC+2], int x, int y, 
                    int *pmv0, int *pmv1, int block, int newgob, int half_pel)
{
  int p1,p2,p3;
  int xin1,xin2,xin3;
  int yin1,yin2,yin3;
  int vec1,vec2,vec3;
  int l8,o8,or8;


  l8 = o8 = or8 = 0;
  if (MV[0][y][x-1]->Mode == H263_MODE_INTER4V)
    l8 = 1;
  if (MV[0][y-1][x]->Mode == H263_MODE_INTER4V)
    o8 = 1;
  if (MV[0][y-1][x+1]->Mode == H263_MODE_INTER4V)
    or8 = 1;

  switch (block) {
  case 0: 
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 1:
    vec1 = (l8 ? 2 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = (o8 ? 3 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 2:
    vec1 = 1            ; yin1 = y  ; xin1 = x;
    vec2 = (o8 ? 4 : 0) ; yin2 = y-1; xin2 = x;
    vec3 = (or8? 3 : 0) ; yin3 = y-1; xin3 = x+1;
    break;
  case 3:
    vec1 = (l8 ? 4 : 0) ; yin1 = y  ; xin1 = x-1;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  case 4:
    vec1 = 3            ; yin1 = y  ; xin1 = x;
    vec2 = 1            ; yin2 = y  ; xin2 = x;
    vec3 = 2            ; yin3 = y  ; xin3 = x;
    break;
  default:
    _SlibDebug(_WARN_, ScDebugPrintf(NULL, "Illegal block number in FindPMV (countbit.c)\n") );
    return;
  }
  if (half_pel) {
    p1 = 2*MV[vec1][yin1][xin1]->x + MV[vec1][yin1][xin1]->x_half;
    p2 = 2*MV[vec2][yin2][xin2]->x + MV[vec2][yin2][xin2]->x_half;
    p3 = 2*MV[vec3][yin3][xin3]->x + MV[vec3][yin3][xin3]->x_half;
  }
  else {
    p1 = 2*MV[vec1][yin1][xin1]->x;
    p2 = 2*MV[vec2][yin2][xin2]->x;
    p3 = 2*MV[vec3][yin3][xin3]->x;
  }
  if (newgob && (block == 0 || block == 1 || block == 2))
    p2 = 2*H263_NO_VEC;

  if (p2 == 2*H263_NO_VEC) { p2 = p3 = p1; }

  *pmv0 = p1+p2+p3 - mmax(p1,mmax(p2,p3)) - mmin(p1,mmin(p2,p3));
    
  if (half_pel) {
    p1 = 2*MV[vec1][yin1][xin1]->y + MV[vec1][yin1][xin1]->y_half;
    p2 = 2*MV[vec2][yin2][xin2]->y + MV[vec2][yin2][xin2]->y_half;
    p3 = 2*MV[vec3][yin3][xin3]->y + MV[vec3][yin3][xin3]->y_half;
  }
  else {
    p1 = 2*MV[vec1][yin1][xin1]->y;
    p2 = 2*MV[vec2][yin2][xin2]->y;
    p3 = 2*MV[vec3][yin3][xin3]->y;
  }    
  if (newgob && (block == 0 || block == 1 || block == 2))
    p2 = 2*H263_NO_VEC;

  if (p2 == 2*H263_NO_VEC) { p2 = p3 = p1; }

  *pmv1 = p1+p2+p3 - mmax(p1,mmax(p2,p3)) - mmin(p1,mmin(p2,p3));
  
  return;
}

void sv_H263ZeroBits(H263_Bits *bits)
{
  bits->Y = 0;
  bits->C = 0;
  bits->vec = 0;
  bits->CBPY = 0;
  bits->CBPCM = 0;
  bits->MODB = 0;
  bits->CBPB = 0;
  bits->COD = 0;
  bits->DQUANT = 0;
  bits->header = 0;
  bits->total = 0;
  bits->no_inter = 0;
  bits->no_inter4v = 0;
  bits->no_intra = 0;
  return;
}
void sv_H263ZeroRes(H263_Results *res)
{
  res->SNR_l = (float)0;
  res->SNR_Cr = (float)0;
  res->SNR_Cb = (float)0;
  res->QP_mean = (float)0;
}
void sv_H263AddBits(H263_Bits *total, H263_Bits *bits)
{
  total->Y += bits->Y;
  total->C += bits->C;
  total->vec += bits->vec;
  total->CBPY += bits->CBPY;
  total->CBPCM += bits->CBPCM;
  total->MODB += bits->MODB;
  total->CBPB += bits->CBPB;
  total->COD += bits->COD;
  total->DQUANT += bits->DQUANT;
  total->header += bits->header;
  total->total += bits->total;
  total->no_inter += bits->no_inter;
  total->no_inter4v += bits->no_inter4v;
  total->no_intra += bits->no_intra;
  return;
}
void sv_H263AddRes(H263_Results *total, H263_Results *res, H263_Pict *pic)
{
  total->SNR_l += res->SNR_l;
  total->SNR_Cr += res->SNR_Cr;
  total->SNR_Cb += res->SNR_Cb;
  total->QP_mean += pic->QP_mean;

  return;
}

void sv_H263AddBitsPicture(H263_Bits *bits)
{
  bits->total = 
    bits->Y + 
    bits->C + 
    bits->vec +  
    bits->CBPY + 
    bits->CBPCM + 
    bits->MODB +
    bits->CBPB +
    bits->COD + 
    bits->DQUANT +
    bits->header ;
}

void sv_H263ZeroVec(H263_MotionVector *MV)
{
  MV->x = 0;
  MV->y = 0;
  MV->x_half = 0;
  MV->y_half = 0;
  return;
}

void sv_H263MarkVec(H263_MotionVector *MV)
{
  MV->x = H263_NO_VEC;
  MV->y = H263_NO_VEC;
  MV->x_half = 0;
  MV->y_half = 0;
  return;
}

void svH263CopyVec(H263_MotionVector *MV2, H263_MotionVector *MV1)
{
  MV2->x = MV1->x;
  MV2->x_half = MV1->x_half;
  MV2->y = MV1->y;
  MV2->y_half = MV1->y_half;
  return;
}

int sv_H263EqualVec(H263_MotionVector *MV2, H263_MotionVector *MV1)
{
  if (MV1->x != MV2->x)
    return 0;
  if (MV1->y != MV2->y)
    return 0;
  if (MV1->x_half != MV2->x_half)
    return 0;
  if (MV1->y_half != MV2->y_half)
    return 0;
  return 1;
}

/**********************************************************************
 *
 *	Name:		CountBitsPicture(Pict *pic)
 *	Description:    counts the number of bits needed for picture
 *                      header
 *	
 *	Input:	        pointer to picture structure
 *	Returns:        number of bits
 *	Side effects:
 *
 ***********************************************************************/

int sv_H263CountBitsPicture(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut, H263_Pict *pic)
{
  int bits = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263CountBitsPicture(frames=%d)\n",
                                           H263Info->frames) );

  /* in case of arithmetic coding, encoder_flush() has been called before
     zeroflush() in main.c */

  /* Picture start code */
#if 0
  if (H263_trace) {    fprintf(tf,"picture_start_code: "); }
#endif
  svH263mputv(H263_PSC_LENGTH,H263_PSC);
  bits += H263_PSC_LENGTH;

  /* Group number */
#if 0
  if (H263_trace) {   fprintf(tf,"Group number in picture header: ");}
#endif
  svH263mputv(5,0); 
  bits += 5;
  
  /* Time reference */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "Time reference: %d\n", pic->TR) );
  svH263mputv(8,pic->TR);
  bits += 8;

 /* bit 1 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "Spare: %d\n", pic->spare) );
  pic->spare = 1; /* always 1 to avoid start code emulation */
  svH263mputv(1,pic->spare);
  bits += 1;

  /* bit 2 */
#if 0
  if (H263_trace) {    fprintf(tf,"always zero for distinction with H.261\n"); }
#endif
  svH263mputv(1,0);
  bits += 1;
  
  /* bit 3 */
#if 0
  if (H263_trace) {   fprintf(tf,"split_screen_indicator: ");  }
#endif
  svH263mputv(1,0);     /* no support for split-screen in this software */
  bits += 1;

  /* bit 4 */
#if 0
  if (H263_trace) {   fprintf(tf,"document_camera_indicator: ");  }
#endif
  svH263mputv(1,0);
  bits += 1;

  /* bit 5 */
#if 0
  if (H263_trace) {   fprintf(tf,"freeze_picture_release: "); }
#endif
  svH263mputv(1,0);
  bits += 1;

  /* bit 6-8 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "source_format: %d\n", pic->source_format) );
  svH263mputv(3,pic->source_format);
  bits += 3;

  /* bit 9 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "picture_coding_type: %d\n",
                                                pic->picture_coding_type) );
  svH263mputv(1,pic->picture_coding_type);
  bits += 1;

  /* bit 10 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "mv_outside_frame: %d\n",
                                                pic->unrestricted_mv_mode) );
  svH263mputv(1,pic->unrestricted_mv_mode);  /* Unrestricted Motion Vector mode */
  bits += 1;

  /* bit 11 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sac_coding: %d\n",
                                                H263Info->syntax_arith_coding) );
  svH263mputv(1,H263Info->syntax_arith_coding); /* Syntax-based Arithmetic Coding mode */
  bits += 1;

  /* bit 12 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "adv_pred_mode: %d\n", H263Info->advanced) );
  svH263mputv(1,H263Info->advanced); /* Advanced Prediction mode */
  bits += 1;

  /* bit 13 */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "PB-coded: %d\n", pic->PB) );
  svH263mputv(1,pic->PB);
  bits += 1;


  /* QUANT */
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "QUANT: %d\n", pic->QUANT) );
  svH263mputv(5,pic->QUANT);
  bits += 5;

  /* Continuous Presence Multipoint (CPM) */
  svH263mputv(1,0); /* CPM is not supported in this software */
  bits += 1;

  /* Picture Sub Bitstream Indicator (PSBI) */
  /* if CPM == 1: 2 bits PSBI */
  /* not supported */

  /* extra information for PB-frames */
  if (pic->PB) {
#if 0
    if (H263_trace) {      fprintf(tf,"TRB: "); }
#endif
    svH263mputv(3,pic->TRB);
    bits += 3;

#if 0
    if (H263_trace) {      fprintf(tf,"BQUANT: ");}
#endif
    svH263mputv(2,pic->BQUANT);
    bits += 2;
    
  }

  /* PEI (extra information) */
#if 0
  if (H263_trace) { fprintf(tf,"PEI: "); }
#endif
  /* "Encoders shall not insert PSPARE until specified by the ITU" */
  svH263mputv(1,0); 
  bits += 1;

  /* PSPARE */
  /* if PEI == 1: 8 bits PSPARE + another PEI bit */
  /* not supported */

  return bits;
}

/*****************************************************************
 *
 *  huffman.c, Huffman coder for H.263 encoder 
 *  Wei-Lien Hsu
 *  Date: December 11, 1996
 *
 *****************************************************************/

/*
************************************************************
huffman.c

This file contains the Huffman routines.  They are constructed to use
no look-ahead in the stream.

************************************************************
*/


/* tables.h */
/* TMN Huffman tables */

/* Motion vectors */
int vlc_mv_coeff[] = {
32,13,5,
33,13,7,
34,12,5,
35,12,7,
36,12,9,
37,12,11,
38,12,13,
39,12,15,
40,11,9,
41,11,11,
42,11,13,
43,11,15,
44,11,17,
45,11,19,
46,11,21,
47,11,23,
48,11,25,
49,11,27,
50,11,29,
51,11,31,
52,11,33,
53,11,35,
54,10,19,
55,10,21,
56,10,23,
57,8,7,
58,8,9,
59,8,11,
60,7,7,
61,5,3,
62,4,3,
63,3,3,
 0,1,1,
 1,3,2,
 2,4,2,
 3,5,2,
 4,7,6,
 5,8,10,
 6,8,8,
 7,8,6,
 8,10,22,
 9,10,20,
10,10,18,
11,11,34,
12,11,32,
13,11,30,
14,11,28,
15,11,26,
16,11,24,
17,11,22,
18,11,20,
19,11,18,
20,11,16,
21,11,14,
22,11,12,
23,11,10,
24,11,8,
25,12,14,
26,12,12,
27,12,10,
28,12,8,
29,12,6,
30,12,4,
31,13,6,
-1,-1
};

/* CBPCM (MCBPC) */
int vlc_cbpcm_intra_coeff[] = {
3,1,1,
19,3,1,
35,3,2,
51,3,3,
4,4,1,
20,6,1,
36,6,2,
52,6,3,
255,9,1,
-1,-1
};

int vlc_cbpcm_coeff[] = {
0,1,1,
16,4,3,
32,4,2,
48,6,5,
1,3,3,
17,7,7,
33,7,6,
49,9,5,
2,3,2,
18,7,5,
34,7,4,
50,8,5,
3,5,3,
19,8,4,
35,8,3,
51,7,3,
4,6,4,
20,9,4,
36,9,3,
52,9,2,
255,9,1,
-1,-1
};


/* CBPY */
int vlc_cbpy_coeff[] = {
0,  2,3,
8,  4,11,
4,  4,10,
12, 4,9,
2,  4,8,
10, 4,7,
6,  6,3,
14, 5,5,
1,  4,6,
9,  6,2,
5,  4,5,
13, 5,4,
3,  4,4,
11, 5,3,
7,  5,2,
15, 4,3,
-1,-1
};

/* 3D VLC */
int vlc_3d_coeff[] = {
1,2,2,
2,4,15,
3,6,21,
4,7,23,
5,8,31,
6,9,37,
7,9,36,
8,10,33,
9,10,32,
10,11,7,
11,11,6,
12,11,32,
17,3,6,
18,6,20,
19,8,30,
20,10,15,
21,11,33,
22,12,80,
33,4,14,
34,8,29,
35,10,14,
36,12,81,
49,5,13,
50,9,35,
51,10,13,
65,5,12,
66,9,34,
67,12,82,
81,5,11,
82,10,12,
83,12,83,
97,6,19,
98,10,11,
99,12,84,
113,6,18,
114,10,10,
129,6,17,
130,10,9,
145,6,16,
146,10,8,
161,7,22,
162,12,85,
177,7,21,
193,7,20,
209,8,28,
225,8,27,
241,9,33,
257,9,32,
273,9,31,
289,9,30,
305,9,29,
321,9,28,
337,9,27,
353,9,26,
369,11,34,
385,11,35,
401,12,86,
417,12,87,

4097,4,7,                          /* Table for last coeff */
4098,9,25,
4099,11,5,
4113,6,15,
4114,11,4,
4129,6,14,
4145,6,13,
4161,6,12,
4177,7,19,
4193,7,18,
4209,7,17,
4225,7,16,
4241,8,26,
4257,8,25,
4273,8,24,
4289,8,23,
4305,8,22,
4321,8,21,
4337,8,20,
4353,8,19,
4369,9,24,
4385,9,23,
4401,9,22,
4417,9,21,
4433,9,20,
4449,9,19,
4465,9,18,
4481,9,17,
4497,10,7,
4513,10,6,
4529,10,5,
4545,10,4,
4561,11,36,
4577,11,37,
4593,11,38,
4609,11,39,
4625,12,88,
4641,12,89,
4657,12,90,
4673,12,91,
4689,12,92,
4705,12,93,
4721,12,94,
4737,12,95,
7167,7,3,               /* escape */
-1,-1
};


#define MakeStructure(S) (S *) ScAlloc(sizeof(S))

H263_EHUFF *vlc_3d;
H263_EHUFF *vlc_cbpcm;
H263_EHUFF *vlc_cbpcm_intra;
H263_EHUFF *vlc_cbpy;
H263_EHUFF *vlc_mv;

H263_EHUFF *MakeEhuff();
void  FreeEhuff(H263_EHUFF *eh);
void  LoadETable();


/**********************************************************************
 *
 *	Name:		InitHuff
 *	Description:   	Initializes vlc-tables
 *	
 *	Input:	      
 *	Returns:       
 *	Side effects:
 *
 ***********************************************************************/

void sv_H263InitHuff(SvH263CompressInfo_t *H263Info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263InitHuff()\n") );
  vlc_3d = MakeEhuff(8192);
  vlc_cbpcm = MakeEhuff(256);
  vlc_cbpcm_intra = MakeEhuff(256);
  vlc_cbpy = MakeEhuff(16);
  vlc_mv = MakeEhuff(65);
  LoadETable(vlc_3d_coeff,vlc_3d);
  LoadETable(vlc_cbpcm_coeff,vlc_cbpcm);
  LoadETable(vlc_cbpcm_intra_coeff,vlc_cbpcm_intra);
  LoadETable(vlc_cbpy_coeff,vlc_cbpy);
  LoadETable(vlc_mv_coeff,vlc_mv);
  return;
}

/* FreeHuff(): Frees the VLC-tables */
void sv_H263FreeHuff(SvH263CompressInfo_t *H263Info)
{
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "sv_H263FreeHuff()\n") );
  FreeEhuff(vlc_3d);
  FreeEhuff(vlc_cbpcm);
  FreeEhuff(vlc_cbpcm_intra);
  FreeEhuff(vlc_cbpy);
  FreeEhuff(vlc_mv);
}
    
/*
MakeEhuff() constructs an encoder huff with a designated table-size.
This table-size, n, is used for the lookup of Huffman values, and must
represent the largest positive Huffman value.

*/

H263_EHUFF *MakeEhuff(int n)
{
    int i;
    H263_EHUFF *temp;

    temp = MakeStructure(H263_EHUFF);
    temp->n = n;
    temp->Hlen = (int *) ScCalloc(n*sizeof(int));
    temp->Hcode = (int *) ScCalloc(n*sizeof(int));
    for(i=0;i<n;i++)
	{
	    temp->Hlen[i] = -1;
	    temp->Hcode[i] = -1;
	}
    return(temp);
}

void FreeEhuff(H263_EHUFF *eh)
{
    ScFree(eh->Hlen);
    ScFree(eh->Hcode);
    ScFree(eh);
}

/*

LoadETable() is used to load an array into an encoder table.  The
array is grouped in triplets and the first negative value signals the
end of the table.

*/

void LoadETable(int *array,H263_EHUFF *table)
{
    while(*array>=0)
	{
	    _SlibDebug(_WARN_ && *array>table->n,
		    ScDebugPrintf(NULL, "Table overflow.\n");
            return );
	    table->Hlen[*array] = array[1];
	    table->Hcode[*array] = array[2];
	    array+=3;
	}
}

/*

PrintEhuff() prints the encoder Huffman structure passed into it.

*/

/*$void PrintEhuff(H263_EHUFF *huff)
{
    int i;

    printf("Modified Huffman Encoding Structure: %x\n",&huff);
    printf("Number of values %d\n",huff->n);
    for(i=0;i<huff->n;i++)
	{
	    if (huff->Hlen[i]>=0)
		{
		    printf("Value: %x  Length: %d  Code: %x\n",
			   i,huff->Hlen[i],huff->Hcode[i]);
		}
	}
}$*/

/*

PrintTable() prints out 256 elements in a nice byte ordered fashion.

*/
#if 0
void PrintTable(int *table)
{
    int i,j;

    for(i=0;i<16;i++)
	{
	    for(j=0;j<16;j++)
		printf("%2x ",*(table++));
	    printf("\n");
	}
}
#endif
/*
Encode() encodes a symbol according to a designated encoder Huffman
table out to the stream. It returns the number of bits written to the
stream and a zero on error.
*/

static int sv_H263HuffEncode(ScBitstream_t *BSOut, int val,H263_EHUFF *huff)
{

    if (val < 0)
    {
	    _SlibDebug(_WARN_, ScDebugPrintf(NULL, "Out of bounds val:%d.\n",val) );
	    return(-1);
    }
    else if (val >= huff->n) {
	return 0; /* No serious error, can occur with some values */
    }
    else if (huff->Hlen[val] < 0) {
	return 0;
    }
    else {
	svH263mputv(huff->Hlen[val],huff->Hcode[val]); 
	return(huff->Hlen[val]);
    }
}

/*
char *BitPrint(int length, int val)
{
    int m;
    char *bit = (char *)ScAlloc(sizeof(char)*(length+3));

    m = length;
    bit[0] = '"';
    while (m--) 
	bit[length-m] = (val & (1<<m)) ? '1' : '0';
    bit[length+1] = '"';
    bit[length+2] = '\0';
    return bit;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\scon.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_H_
#define _SCON_H_

#ifdef WIN32
#include <windows.h>
#endif
#include "SC.h"

typedef void       *SconHandle_t;
typedef ScBoolean_t SconBoolean_t;

typedef enum {
  SCON_MODE_NONE,
  SCON_MODE_VIDEO,  /* Video conversions */
  SCON_MODE_AUDIO   /* Audio conversions */
} SconMode_t;

typedef enum {
  SconErrorNone = 0,
  SconErrorInternal,
  SconErrorMemory,
  SconErrorBadArgument,
  SconErrorBadHandle,
  SconErrorBadMode,
  SconErrorUnsupportedFormat,
  SconErrorBufSize,
  SconErrorUnsupportedParam,
  SconErrorImageSize,        /* Invalid image height and/or width */
  SconErrorSettingNotEqual,  /* The exact Parameter setting was not accepted */
  SconErrorInit,             /* initialization error */
} SconStatus_t;

typedef enum {
  SCON_INPUT = 1,
  SCON_OUTPUT = 2,
  SCON_INPUT_AND_OUTPUT = 3,
} SconParamType_t;

typedef enum {
  /* SCON Parameters */
  SCON_PARAM_VERSION=0x00,  /* SCON version number */
  SCON_PARAM_VERSION_DATE,  /* SCON build date */
  SCON_PARAM_DEBUG,         /* debug handle */
  SCON_PARAM_KEY,           /* SCON security key */
  /* Video Parameters */
  SCON_PARAM_WIDTH=0x100,
  SCON_PARAM_HEIGHT,
  SCON_PARAM_STRIDE,            /* bytes between scan lines */
  SCON_PARAM_IMAGESIZE,
  SCON_PARAM_VIDEOFORMAT,
  SCON_PARAM_VIDEOBITS,
  SCON_PARAM_VIDEOQUALITY,      /* video quality */
} SconParameter_t;

typedef qword SconListParam1_t;
typedef qword SconListParam2_t;

typedef struct SconList_s {
  int   Enum;   /* an enumerated value associated with the entry */
  char *Name;   /* the name of an entry in the list. NULL = last entry */
  char *Desc;   /* a lengthy description of the entry */
  SconListParam1_t param1;
  SconListParam2_t param2;
} SconList_t;

/********************** Public Prototypes ***********************/
/*
 * scon_api.c
 */
EXTERN SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                             void *informat, void *outformat);
EXTERN SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                void *outbuf, dword outbufsize);
EXTERN SconBoolean_t SconIsSame(SconHandle_t handle);
EXTERN SconStatus_t SconClose(SconHandle_t handle);
EXTERN SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value);

#endif /* _SCON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_int.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_internals.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

#ifndef _SCON_INTERNALS_H_
#define _SCON_INTERNALS_H_

#include "scon.h"

typedef struct SconVideoInfo_s {
  dword         Width;
  dword         Height;
  SconBoolean_t NegHeight; /* height is negative */
  dword         Stride;
  dword         FourCC;
  dword         BPP;       /* bits per pixel */
  dword         Pixels;    /* total pixels in a frame */
  dword         ImageSize; /* image size in bytes */
  dword         RGBmasks;  /* 565, 555, 888 */
  dword         Rmask;     /* Red mask */
  dword         Gmask;     /* Green mask */
  dword         Bmask;     /* Blue mask */
} SconVideoInfo_t;

typedef struct SconAudioInfo_s {
  dword SPS;      /* samples per second: 8000, 11025, 22050, etc */
  dword BPS;      /* bits per sample: 8 or 16 */
  dword Channels; /* channels: 1=mono, 2=stereo */
} SconAudioInfo_t;

typedef struct SconInfo_s {
  SconMode_t        Mode;
  SconBoolean_t     InputInited;  /* input format has been setup */
  SconBoolean_t     OutputInited; /* output format has been setup */
  SconBoolean_t     SameFormat;   /* input and output are the same format */
  SconBoolean_t     Flip;         /* image must be flipped when converted */
  SconBoolean_t     ScaleDown;    /* input image is being scaled down */
  SconBoolean_t     ScaleUp;      /* input image is being scaled up */
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Input;
  union {
    SconVideoInfo_t vinfo;
    SconAudioInfo_t ainfo;
  } Output;
  unsigned char    *FImage;        /* format conversion image buffer */
  dword             FImageSize;
  unsigned char    *SImage;        /* scaling image buffer */
  dword             SImageSize;
  void             *Table;         /* conversion lookup table */
  dword             TableSize;
  void             *dbg;           /* debug handle */
} SconInfo_t;

/********************** Private Prototypes ***********************/
/*
 * scon_video.c
 */
unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo);
SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize);

/*
 * scon_yuv_to_rgb.c
 */
SconStatus_t sconInitYUVtoRGB(SconInfo_t *Info);
SconStatus_t scon422ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB565(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon422ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t scon420ToRGB888(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);
SconStatus_t sconInitRGBtoYUV(SconInfo_t *Info);
SconStatus_t sconRGB888To420(unsigned char *inimage, unsigned char *outimage,
                     unsigned dword width,  unsigned dword height,
                     dword stride, unsigned qword *pTable);

#endif /* _SCON_INTERNALS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sac.c ===
/* File: sv_h263_sac.c */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995, 1997                 **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _SLIBDEBUG_
*/

#include "sv_h263.h"
#include "sv_intrn.h"
#include "SC_err.h"
#include "proto.h"

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 1  /* show progress */
#define _VERIFY_  0  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
extern void *dbg;
#endif

#define   q1    16384
#define   q2    32768
#define   q3    49152
#define   top   65535

/* local prototypes */
static void bit_out_psc_layer(ScBitstream_t *BSIn);
static int sv_H263bit_opp_bits(ScBitstream_t *BSOut, int bit);              
static int sv_H263bit_in_psc_layer(ScBitstream_t *BSOut, int bit);

/*********************************************************************
 *        SAC Decoder Algorithm as Specified in H26P Annex -E
 *
 *        Name:        decode_a_symbol
 *
 *	Description:	Decodes an Aritmetically Encoded Symbol
 *
 *	Input:        array holding cumulative freq. data
 *        also uses static data for decoding endpoints
 *        and code_value variable
 *
 *	Returns:	Index to relevant symbol model
 *
 *	Side Effects:	Modifies low, high, length, cum and code_value
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/
 
static qword low=0, high=top, zerorun=0; /* decoder and encoder */
static qword code_value, bit; /* decoder */
static qword opposite_bits=0; /* encoder */

int sv_H263SACDecode_a_symbol(ScBitstream_t *BSIn, int cumul_freq[ ])
{
  qword length, cum, sacindex;
  length = high - low + 1;
  cum = (-1 + (code_value - low + 1) * cumul_freq[0]) / length;
  for (sacindex = 1; cumul_freq[sacindex] > cum; sacindex++);
  high = low - 1 + (length * cumul_freq[sacindex-1]) / cumul_freq[0];
  low += (length * cumul_freq[sacindex]) / cumul_freq[0];

  for ( ; ; ) {  
    if (high < q2) ;
    else if (low >= q2) {
      code_value -= q2; 
      low -= q2; 
      high -= q2;
    }
    else if (low >= q1 && high < q3) {
      code_value -= q1; 
      low -= q1; 
      high -= q1;
    }
    else
	{
      _SlibDebug(_VERBOSE_,
          ScDebugPrintf(dbg, "sv_H263SACDecode_a_symbol() code_value=%ld sacindex=%ld\n",
                                code_value, sacindex) );
      break;
    }
    low = low << 1; 
    high = (high << 1) + 1;
    bit_out_psc_layer(BSIn); 
    code_value = (code_value << 1) + bit;
  }

  return ((int)sacindex-1);
}
 
/*********************************************************************
 *
 *        Name:        decoder_reset
 *
 *	Description:	Fills Decoder FIFO after a fixed word length
 *        string has been detected.
 *
 *	Input:        None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Fills Arithmetic Decoder FIFO
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

void sv_H263SACDecoderReset(ScBitstream_t *BSIn)
{
  int i;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263SACDecoderReset() bytepos=%d\n",
                                              (int)ScBSBytePosition(BSIn)) );
  zerorun = 0;        /* clear consecutive zero's counter */
  code_value = 0;
  low = 0;
  high = top;
  for (i = 1;   i <= 16;   i++) {
    bit_out_psc_layer(BSIn); 
    code_value = (code_value << 1) + bit;
  }
}

/*********************************************************************
 *
 *        Name:        bit_out_psc_layer
 *
 *	Description:	Gets a bit from the Encoded Stream, Checks for
 *        and removes any PSC emulation prevention bits
 *        inserted at the decoder, provides 'zeros' to the
 *        Arithmetic Decoder FIFO to allow it to finish 
 *        data prior to the next PSC. (Garbage bits)
 *
 *	Input:        None
 *
 *	Returns:	Nothing
 *
 *	Side Effects:	Gets a bit from the Input Data Stream
 *
 *	Author:        Wayne Ellis <ellis_w_wayne@bt-web.bt.co.uk>
 *
 *********************************************************************/

static void bit_out_psc_layer(ScBitstream_t *BSIn)
{
  if (ScBSPeekBits(BSIn, 17)!=1)  /* check for startcode in Arithmetic Decoder FIFO */
  {
    _SlibDebug(_DEBUG_, ScDebugPrintf(dbg, "bit_out_psc_layer()\n") );

    bit = ScBSGetBit(BSIn);

    if (zerorun > 13) {	/* if number of consecutive zeros = 14 */	 
      if (!bit) {
        _SlibDebug(_WARN_,
            ScDebugPrintf(dbg, "bit_out_psc_layer() PSC/GBSC, Header Data, or Encoded Stream Error\n") );
        zerorun = 1;        
      }
      else { /* if there is a 'stuffing bit present */
/*
        if (H263_DEC_trace)
          printf("Removing Startcode Emulation Prevention bit \n");
*/
        bit = ScBSGetBit(BSIn);        /* overwrite the last bit */	
        zerorun = !bit;        /* zerorun=1 if bit is a '0' */
      }
    }

    else { /* if consecutive zero's not exceeded 14 */
      if (!bit) zerorun++;
      else      zerorun = 0;
    }

  } /* end of if !(showbits(17)) */
  else {
    _SlibDebug(_WARN_, ScDebugPrintf(dbg, "bit_out_psc_layer() startcode found, using 'Garbage bits'\n") );
    bit = 0;
  }

   /*	
   printf("lastbit = %ld bit = %ld zerorun = %ld \n", lastbit, bit, zerorun); 
   lastbit = bit;
   */
  /* latent diagnostics */
}

/*********************************************************************
 *
 * SAC Encoder Module
 * Algorithm as specified in H263 (Annex E)
 *
 *********************************************************************/

/*********************************************************************
 *
 *      Name:           AR_Encode
 *
 *      Description:    Encodes a symbol using syntax based arithmetic
 *			coding. Algorithm specified in H.263 (Annex E).
 *
 *      Input:          Array holding cumulative frequency data.
 *			Index into specific cumulative frequency array.
 *                      Static data for encoding endpoints.
 *
 *      Returns:        Number of bits used while encoding symbol.
 *
 *      Side Effects:   Modifies low, high, length and opposite_bits
 *			variables.
 *
 *********************************************************************/

int sv_H263AREncode(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut,
                    int index, int cumul_freq[ ])
{
  qword length;
  int bitcount=0;

  if (index<0) 
    return -1; /* Escape Code */

  length = high - low + 1;
  high = low - 1 + (length * cumul_freq[index]) / cumul_freq[0];
  low += (length * cumul_freq[index+1]) / cumul_freq[0];

  for ( ; ; ) {
    if (high < q2) {
      bitcount+=sv_H263bit_opp_bits(BSOut, 0);
    }
    else if (low >= q2) {
      bitcount+=sv_H263bit_opp_bits(BSOut, 1);	
      low -= q2; 
      high -= q2;
    }
    else if (low >= q1 && high < q3) {
      opposite_bits += 1; 
      low -= q1; 
      high -= q1;
    }
    else break;
 
    low *= 2; 
    high = 2*high+1;
  }
  return bitcount;
}

static int sv_H263bit_opp_bits(ScBitstream_t *BSOut, int bit) /* Output a bit and the following opposite bits */              
{                                   
  int bitcount=0;

  bitcount = sv_H263bit_in_psc_layer(BSOut, bit);

  while(opposite_bits > 0){
    bitcount += sv_H263bit_in_psc_layer(BSOut, !bit);
    opposite_bits--;
  }
  return bitcount;
}

/*********************************************************************
 *
 *      Name:           encoder_flush
 *
 *      Description:    Completes arithmetic coding stream before any
 *			fixed length codes are transmitted.
 *
 *      Input:          None
 *
 *      Returns:        Number of bits used.
 *
 *      Side Effects:   Resets low, high, zerorun and opposite_bits 
 *			variables.
 *
 *********************************************************************/

int sv_H263AREncoderFlush(SvH263CompressInfo_t *H263Info, ScBitstream_t *BSOut)
{
  int bitcount = 0;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(dbg, "sv_H263AREncoderFlush() bytepos=%d\n",
                                              (int)ScBSBytePosition(BSOut)) );

  opposite_bits++;
  if (low < q1) {
    bitcount+=sv_H263bit_opp_bits(BSOut, 0);
  }
  else {
    bitcount+=sv_H263bit_opp_bits(BSOut, 1);
  }
  low = 0; 
  high = top;

  zerorun=0;

  return bitcount;
}

/*********************************************************************
 *
 *      Name:           bit_in_psc_layer
 *
 *      Description:    Inserts a bit into output bitstream and avoids
 *			picture start code emulation by stuffing a one
 *			bit.
 *
 *      Input:          Bit to be output.
 *
 *      Returns:        Nothing
 *
 *      Side Effects:   Updates zerorun variable.
 *
 *********************************************************************/

static int sv_H263bit_in_psc_layer(ScBitstream_t *BSOut, int bit)
{
  int bitcount = 0;

  if (zerorun > 13) {
    _SlibDebug(_DEBUG_, ScDebugPrintf(dbg,
               "sv_H263bit_in_psc_layer() bytepos=%d, PSC emulation...Bit stuffed\n",
                                              (int)ScBSBytePosition(BSOut)) );
    svH263mputb(1);
    bitcount++;
    zerorun = 0;
  }

  svH263mputb(bit);
  bitcount++;

  if (bit)
    zerorun = 0;
  else
    zerorun++;

  return bitcount;
}

/*********************************************************************
 *
 *      Name:           indexfn
 *
 *      Description:    Translates between symbol value and symbol
 *			index.
 *
 *      Input:          Symbol value, index table, max number of
 *			values.
 *
 *      Returns:        Index into cumulative frequency tables or
 *			escape code.
 *
 *      Side Effects:   none
 *
 *********************************************************************/

int sv_H263IndexFN(int value, int table[], int max)
{
  int n=0;

  while(1) {
    if (table[n++]==value) return n-1;
    if (n>max) return -1;
  }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_api.c,v $
 * Revision 1.1.8.6  1996/11/25  18:21:14  Hans_Graves
 * 	Fix compile warnings under unix.
 * 	[1996/11/25  18:21:00  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/11/14  21:49:21  Hans_Graves
 * 	AC3 buffering fixes.
 * 	[1996/11/14  21:45:14  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/11/13  16:10:44  Hans_Graves
 * 	AC3 frame size calculation change.
 * 	[1996/11/13  15:53:44  Hans_Graves]
 * 
 * Revision 1.1.8.3  1996/11/08  21:50:27  Hans_Graves
 * 	Added AC3 support.
 * 	[1996/11/08  21:08:35  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:45:23  Hans_Graves
 * 	Add some some MPEG memory freeing
 * 	[1996/09/18  21:42:12  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/23  21:01:38  Hans_Graves
 * 	Added SaDecompressQuery() and SaCompressQuery()
 * 	[1996/04/23  20:57:47  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/17  16:38:31  Hans_Graves
 * 	Add casts where ScBitBuf_t and ScBitString_t types are used
 * 	[1996/04/17  16:34:14  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/15  14:18:32  Hans_Graves
 * 	Change proto for SaCompress() - returns bytes processed
 * 	[1996/04/15  14:10:27  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/10  21:46:51  Hans_Graves
 * 	Added SaGet/SetParam functions
 * 	[1996/04/10  21:25:16  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/09  16:04:23  Hans_Graves
 * 	Remove warnings under NT
 * 	[1996/04/09  15:55:26  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/29  22:20:48  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT
 * 	[1996/03/29  21:51:24  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:05  Hans_Graves
 * 	Removed debugging printf
 * 	[1996/03/08  18:42:52  Hans_Graves]
 * 
 * Revision 1.1.4.5  1996/02/22  21:55:04  Bjorn_Engberg
 * 	Removed a compiler warning on NT.
 * 	[1996/02/22  21:54:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1996/02/06  22:53:51  Hans_Graves
 * 	Moved ScBSReset() from DecompressBegin() to DecompressEnd(). Disabled FRAME callbacks.
 * 	[1996/02/06  22:19:16  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:27  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  15:03:46  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:18  Hans_Graves
 * 	Added SaSetBitrate(). SOme MPEG Audio encoding fix-ups
 * 	[1996/01/15  16:07:48  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/07/21  17:40:57  Hans_Graves
 * 	Renamed Callback related stuff.
 * 	[1995/07/21  17:25:44  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/27  17:40:57  Hans_Graves
 * 	Removed include <mmsystem.h>.
 * 	[1995/06/27  17:32:20  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/27  13:54:14  Hans_Graves
 * 	Added GSM Encoding and Decoding
 * 	[1995/06/26  21:04:12  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/09  18:33:27  Hans_Graves
 * 	Added SaGetInputBitstream().
 * 	[1995/06/09  18:32:35  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/07  19:34:39  Hans_Graves
 * 	Enhanced sa_GetMpegAudioInfo().
 * 	[1995/06/07  19:33:25  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:17  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  17:28:50  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:47:31  Hans_Graves
 * 	Added MPEG Compression functionality
 * 	[1995/04/17  18:47:00  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:55:45  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:55:15  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
#define _DEBUG_
#define _VERBOSE_
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "SC.h"
#include "SC_err.h"
#include "SA.h"
#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* AC3_SUPPORT */
#include "sa_intrn.h"
#include "sa_proto.h"

#ifdef MPEG_SUPPORT
static int MPEGAudioFilter(ScBitstream_t *bs)
{
  int type, stat=NoErrors;
  unsigned dword PacketStartCode;
  ScBSPosition_t PacketStart, PacketLength=0;

  while (!bs->EOI)
  {
    if ((int)ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
    {
      ScBSSetFilter(bs, NULL);
      return(0);
    }
    PacketStartCode=(unsigned int)ScBSGetBits(bs, PACKET_START_CODE_PREFIX_LEN);
    if (PacketStartCode!=PACKET_START_CODE_PREFIX) {
      fprintf(stderr,"Packet cannot be located at Byte pos 0x%X; got 0x%X\n",
                      ScBSBytePosition(bs),PacketStartCode);
      bs->EOI=TRUE;
      return(-1);
    }
    type=(int)ScBSGetBits(bs, 8);
    switch (type)
    {
      case AUDIO_STREAM_BASE:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             PacketStart=ScBSBitPosition(bs);
             sc_dprintf("Audio Packet Start=0x%X Length=0x%X (0x%X)\n",
                          PacketStart/8, PacketLength/8, PacketLength/8);
             while (ScBSPeekBits(bs, 8)==0xFF) /* Stuffing bytes */
               ScBSSkipBits(bs, 8);
             if (ScBSPeekBits(bs, 2)==1)       /* STD_buffer stuff */
               ScBSSkipBits(bs, 2*8);
             if (ScBSPeekBits(bs, 4)==2)       /* Time Stamps */
               ScBSSkipBits(bs, 5*8);
             else if (ScBSPeekBits(bs, 4)==3)  /* Time Stamps */
               ScBSSkipBits(bs, 10*8);
             else if (ScBSGetBits(bs, 8)!=0x0F)
               fprintf(stderr, "Last byte before data not 0x0F at pos 0x%X\n",
                                             ScBSBytePosition(bs));
             return((int)(PacketStart+PacketLength));
             break;
      case PACK_START_BASE:
             sc_dprintf("Pack Start=0x%X Length=0x%X\n",
                          ScBSBytePosition(bs), 8);
             ScBSSkipBits(bs, 8*8);
             break;
      default:
             PacketLength=(unsigned int)ScBSGetBits(bs, 16)*8;
             ScBSSkipBits(bs, (unsigned int)PacketLength);
             break;
    }
  }
  return(0);
}
#endif /* MPEG_SUPPORT */

/*
** Name:     SaOpenCodec
** Purpose:  Open the specified codec. Return stat code.
**
** Args:     CodecType = SA_MPEG_ENCODE & SA_MPEG_DECODE are the only
**           recognized codec for now.
**           Sah = handle to software codec's Info structure.
*/
SaStatus_t SaOpenCodec (SaCodecType_e CodecType, SaHandle_t *Sah)
{
   int stat;
   SaCodecInfo_t          *Info = NULL;

   if ((CodecType != SA_PCM_DECODE)
       && (CodecType != SA_PCM_ENCODE)
#ifdef MPEG_SUPPORT
       && (CodecType != SA_MPEG_DECODE)
       && (CodecType != SA_MPEG_ENCODE)
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
       && (CodecType != SA_GSM_DECODE)
       && (CodecType != SA_GSM_ENCODE)
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
       && (CodecType != SA_AC3_DECODE)
       /* && (CodecType != SA_AC3_ENCODE) */
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
       && (CodecType != SA_G723_DECODE)
       && (CodecType != SA_G723_ENCODE)
#endif /* G723_SUPPORT */
     )
     return(SaErrorCodecType);

   if (!Sah)
     return (SaErrorBadPointer);

   /*
   ** Allocate memory for the Codec Info structure:
   */
   if ((Info = (SaCodecInfo_t *)ScAlloc(sizeof(SaCodecInfo_t))) == NULL)
       return (SaErrorMemory);

   Info->Type = CodecType;
   Info->CallbackFunction=NULL;
   Info->BSIn = NULL;
   Info->BSOut = NULL;
   stat = ScBufQueueCreate(&Info->Q);
   if (stat != NoErrors)
     return(stat);

   /*
   ** Allocate memory for Info structure and clear it
   */
   switch(CodecType)
   {
     case SA_PCM_DECODE:
     case SA_PCM_ENCODE:
          break;

#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
          {
            SaMpegDecompressInfo_t *MDInfo;
            if ((MDInfo = (SaMpegDecompressInfo_t *)
                  ScAlloc (sizeof(SaMpegDecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MDInfo = MDInfo;
            stat = sa_InitMpegDecoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;

     case SA_MPEG_ENCODE:
          {
            SaMpegCompressInfo_t *MCInfo;
            if ((MCInfo = (SaMpegCompressInfo_t *)
                  ScAlloc (sizeof(SaMpegCompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->MCInfo = MCInfo;
            stat = sa_InitMpegEncoder (Info);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
          {
            SaAC3DecompressInfo_t *AC3Info;
            if ((AC3Info = (SaAC3DecompressInfo_t *)
                       ScAlloc (sizeof(SaAC3DecompressInfo_t))) == NULL)
              return(SaErrorMemory);
            Info->AC3Info = AC3Info;

            /* Initialize Dolby subroutine */
            stat = sa_InitAC3Decoder(Info);
          }
          break;
#endif /* AC3_SUPPORT */


#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
          {
            SaGSMInfo_t *GSMInfo;
            if ((GSMInfo = (SaGSMInfo_t *)ScAlloc (sizeof(SaGSMInfo_t)))==NULL)
              return(SaErrorMemory);
            Info->GSMInfo = GSMInfo;
            stat = sa_InitGSM(GSMInfo);
            RETURN_ON_ERROR(stat);
          }
          break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
     case SA_G723_DECODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723DecompressInit(pSaG723Info);
          }
          break;

     case SA_G723_ENCODE:
          {
            SaG723Info_t *pSaG723Info;
            if ((pSaG723Info = (SaG723Info_t *)
                  ScAlloc (sizeof(SaG723Info_t))) == NULL)
              return(SaErrorMemory);

            Info->pSaG723Info = pSaG723Info;
            saG723CompressInit(pSaG723Info);
            SaSetParamInt((SaHandle_t)Info, SA_PARAM_BITRATE, 6400);
          }
          break;
#endif /* G723_SUPPORT */

    default:
          return(SaErrorCodecType);
   }
   *Sah = (SaHandle_t) Info;        /* Return handle */
   Info->wfIn=NULL;
   Info->wfOut=NULL;

   return(NoErrors);
}

/*
** Name:     SaCloseCodec
** Purpose:  Closes the specified codec. Free the Info structure
**
** Args:     Sah = handle to software codec's Info structure.
**
*/
SaStatus_t SaCloseCodec (SaHandle_t Sah)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   ScBufQueueDestroy(Info->Q);

   switch (Info->Type)
   {
#ifdef MPEG_SUPPORT
       case SA_MPEG_DECODE:
            if (Info->MDInfo) 
            {
              sa_EndMpegDecoder(Info);
              ScFree(Info->MDInfo);
            }
            break;
       case SA_MPEG_ENCODE:
            if (Info->MCInfo)
            {
              sa_EndMpegEncoder(Info);
              ScFree(Info->MCInfo);
            }
            break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
     /* case SA_AC3_ENCODE: */
            sa_EndAC3Decoder(Info);
            if (Info->AC3Info)
              ScFree(Info->AC3Info);
            break;
#endif /* AC3_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_DECODE:
     case SA_GSM_ENCODE:
            if (Info->GSMInfo)
              ScFree(Info->GSMInfo);
            break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
       case SA_G723_DECODE:
            if (Info->pSaG723Info) 
            {
              saG723DecompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
       case SA_G723_ENCODE:
            if (Info->pSaG723Info)
            {
              saG723CompressFree(Info->pSaG723Info);
              ScFree(Info->pSaG723Info);
            }
            break;
#endif /* G723_SUPPORT */
   }

   if (Info->wfIn)
     ScFree(Info->wfIn);
   if (Info->wfOut)
     ScFree(Info->wfOut);

   /*
   ** Free Info structure
   */
   if (Info->BSIn)
     ScBSDestroy(Info->BSIn);
   if (Info->BSOut)
     ScBSDestroy(Info->BSOut);

   ScFree(Info);

   return(NoErrors);
}

/*
** Name:     SaRegisterCallback
** Purpose:  Specify the user-function that will be called during processing
**           to determine if the codec should abort the frame.
** Args:     Sah          = handle to software codec's Info structure.
**           Callback     = callback function to register
**
*/
SaStatus_t SaRegisterCallback (SaHandle_t Sah,
           int (*Callback)(SaHandle_t, SaCallbackInfo_t *, SaInfo_t *),
           void *UserData)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!Callback)
     return(SaErrorBadPointer);

  Info->CallbackFunction = Callback;
  if (Info->BSIn)
  {
    Info->BSIn->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSIn->UserData=UserData;
  }
  if (Info->BSOut)
  {
    Info->BSOut->Callback=(int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Callback;
    Info->BSOut->UserData=UserData;
  }
  return(NoErrors);
}

/*
** Name: SaGetInputBitstream
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetInputBitstream (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (Info)
    return(Info->BSIn);
  return(NULL);
}

/***************************** Decompression *******************************/
/*
** Name:     SaDecompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaDecompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                             WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  /*
   * This stuff should really be pushed down to the individual codecs
   * unless it has to be here - tfm 
   */
  if (!Info)
    return(SaErrorCodecHandle);

  if (wfIn)
  {
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2 && wfOut->nChannels!=4)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample !=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaDecompressBegin
** Purpose:  Initialize the Decompression Codec. Call after SaOpenCodec &
**           before SaDecompress (SaDecompress will call SaDecompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (compressed) audio
**           wfOut = format of output (uncompressed) audio
*/
SaStatus_t SaDecompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                              WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaDecompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
     case SA_PCM_DECODE:
        break;
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        if (Info->MDInfo->DecompressStarted = FALSE)
           Info->MDInfo->DecompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        if (Info->AC3Info->DecompressStarted = FALSE)
           Info->AC3Info->DecompressStarted = TRUE;
        break;
#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
     /*
     case SA_G723_DECODE:
        if (Info->pSaG723Info->DecompressStarted = FALSE)
           Info->pSaG723Info->DecompressStarted = TRUE;
        break;
      */
#endif /* G723_SUPPORT */
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaDecompress
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of output buffer
**
*/
SaStatus_t SaDecompress (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char *DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
       stat=sa_DecompressMPEG(Info, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesOut += *DcmpLen;
       break; 
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* MPEG_SUPPORT */

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
       stat=sa_DecompressAC3(Info, &DcmpData, MaxDcmpLen, DcmpLen);
	    Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */

#ifdef GSM_SUPPORT
    case SA_GSM_DECODE:
       stat=sa_GSMDecode(Info->GSMInfo, CompData, (word *)DcmpData);
       if (stat==NoErrors)
       {
         *DcmpLen = 160 * 2;
         Info->Info.NumBytesIn += 33;
         Info->Info.NumBytesOut += 160 * 2;
       }
       else
         *DcmpLen = 0;
       break;
#endif /* GSM_SUPPORT */

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
       //Can add a Param for to have CRC or not
       {
         word Crc = 0;

         stat = saG723Decompress( Info,(word *)DcmpData,
                                       (char *)CompData, Crc ) ;
         if(stat == SaErrorNone)
         {
            *DcmpLen = 480; //G723 240 samples(16-bit)= 240*2 = 480 bytes
            Info->Info.NumBytesOut += *DcmpLen;
         }
         else
            *DcmpLen = 0;
       }  
       break; 
    /*
    case SA_PCM_DECODE:
       stat=ScBSGetBytes(Info->BSIn, DcmpData, MaxDcmpLen, DcmpLen);
       Info->Info.NumBytesIn += *DcmpLen;
       Info->Info.NumBytesOut += *DcmpLen;
       break;
    */
#endif /* G723_SUPPORT */
    default:
       *DcmpLen=0;
       return(SaErrorUnrecognizedFormat);
  }
#if 0
  if (*DcmpLen && Info->CallbackFunction)
  {
    SaCallbackInfo_t CB;
    CB.Message       = CB_FRAME_READY;
    CB.Data          = DcmpData;
    CB.DataSize      = CB_DATA_AUDIO;
    CB.DataSize      = MaxDcmpLen;
    CB.DataUsed      = *DcmpLen;
    CB.Action        = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
  }
#endif

  return(stat);
}

/*
** Name:     SaDecompressEx
** Purpose:  Decompress a frame CompData -> PCM
**
** Args:     Sah        = handle to software codec's Info structure.
**           CompData   = Pointer to compressed data (INPUT)
**           CompLen    = Length of CompData buffer
**           DcmpData   = Array of pointers to buffer for decompressed data (OUTPUT)
**           DcmpLen    = Size of decompressed buffers (all must be the same size)
**
*/
SaStatus_t SaDecompressEx (SaHandle_t Sah, u_char *CompData, unsigned int CompLen,
                           u_char **DcmpData, unsigned int *DcmpLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxDcmpLen = *DcmpLen;
  int stat=NoErrors;


  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen)
    return(SaErrorBadPointer);

  switch (Info->Type)
  {
#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:

       stat=sa_DecompressAC3(Info, DcmpData, MaxDcmpLen, DcmpLen);
	   Info->Info.NumBytesOut += *DcmpLen;
       break;
#endif /* AC3_SUPPORT */
  }

  return(stat);
}


/*
** Name:     SaDecompressEnd
** Purpose:  Terminate the Decompression Codec. Call after all calls to
**           SaDecompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaDecompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_DECODE:
        Info->MDInfo->DecompressStarted = FALSE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef AC3_SUPPORT
     case SA_AC3_DECODE:
        Info->AC3Info->DecompressStarted = FALSE;
        break;
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_DECODE:
        //Info->pSaG723Info->DecompressStarted = FALSE;
        break;
#endif /* G723_SUPPORT */
     default:
        break;
  }
  if (Info->BSIn)
    ScBSReset(Info->BSIn); /* frees up any remaining compressed buffers */
  return(NoErrors);
}

/****************************** Compression ********************************/
/*
** Name:     SaCompressQuery
** Purpose:  Check if input and output formats are supported.
*/
SaStatus_t SaCompressQuery(SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                           WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  if (wfIn)
  {
    if (wfIn->wFormatTag != WAVE_FORMAT_PCM)
      return(SaErrorUnrecognizedFormat);
    if (wfIn->nChannels!=1 && wfIn->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }
  if (wfOut)
  {
    if (wfOut->nChannels!=1 && wfOut->nChannels!=2)
      return(SaErrorUnrecognizedFormat);
  }

  if (wfIn && wfOut)
  {
    if (wfIn->nSamplesPerSec != wfOut->nSamplesPerSec)
      return(SaErrorUnrecognizedFormat);

    if (wfIn->wBitsPerSample!=16 && 
        (wfOut->wBitsPerSample !=16 || wfOut->wBitsPerSample !=8))
      return(SaErrorUnrecognizedFormat);
  }
  return(SaErrorNone);
}

/*
** Name:     SaCompressBegin
** Purpose:  Initialize the Compression Codec. Call after SaOpenCodec &
**           before SaCompress (SaCompress will call SaCompressBegin
**           on first call to codec after open if user doesn't call it)
**
** Args:     Sah = handle to software codec's Info structure.
**           wfIn  = format of input (uncompressed) audio
**           wfOut = format of output (compressed) audio
*/
SaStatus_t SaCompressBegin (SaHandle_t Sah, WAVEFORMATEX *wfIn,
                                            WAVEFORMATEX *wfOut)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  SaStatus_t status;

  if (!Info)
    return(SaErrorCodecHandle);

  if (!wfIn || !wfOut)
    return(SaErrorBadPointer);

  status=SaCompressQuery(Sah, wfIn, wfOut);
  if (status!=SaErrorNone)
    return(status);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
     case SA_MPEG_ENCODE:
        SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        sa_MpegVerifyEncoderSettings(Sah);
        if (Info->MCInfo->CompressStarted = FALSE)
           Info->MCInfo->CompressStarted = TRUE;
        break;
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
     case SA_GSM_ENCODE:
        break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0
     case SA_AC3_ENCODE:
        break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
     case SA_G723_ENCODE:
        //SaSetParamInt(Sah, SA_PARAM_SAMPLESPERSEC, wfIn->nSamplesPerSec);
        //SaSetParamInt(Sah, SA_PARAM_CHANNELS, wfIn->nChannels);
        //sa_MpegVerifyEncoderSettings(Sah);
        /*
        if (Info->pSaG723Info->CompressStarted = FALSE)
           Info->pSaG723Info->CompressStarted = TRUE;
        */
        break;
#endif /* G723_SUPPORT */
     case SA_PCM_ENCODE:
        break;
     default:
        return(SaErrorUnrecognizedFormat);
  }
  if ((Info->wfIn = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
            wfIn->cbSize)) == NULL)
       return (SaErrorMemory);
  if ((Info->wfOut = (WAVEFORMATEX *)ScAlloc(sizeof(WAVEFORMATEX)+
           wfOut->cbSize)) == NULL)
       return (SaErrorMemory);
  memcpy(Info->wfOut, wfOut, sizeof(WAVEFORMATEX)+wfOut->cbSize);
  memcpy(Info->wfIn, wfIn, sizeof(WAVEFORMATEX)+wfIn->cbSize);
  return(NoErrors);
}

/*
** Name:     SaCompress
** Purpose:  Compress PCM audio  ->CompData 
**
** Args:     Sah        = handle to software codec's Info structure.
**           DcmpData   = buffer for decompressed data (INPUT)
**           DcmpLen    = Number of Bytes Compressed (return bytes processed)
**           CompData   = Pointer to compressed data (OUTPUT)
**           CompLen    = Length of CompData buffer
**
*/
SaStatus_t SaCompress(SaHandle_t Sah, 
                           u_char *DcmpData, unsigned int *DcmpLen,
                           u_char *CompData, unsigned int *CompLen)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  unsigned int MaxCompLen = *CompLen, NumBytesIn=0;
  int stat=NoErrors;

  if (Sah==NULL)
    return(SaErrorCodecHandle);

  if (!DcmpData || !DcmpLen || !CompLen)
    return(SaErrorBadPointer);

  *CompLen = 0;
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         do  {
           DcmpBytes=*DcmpLen-Offset;
           if (DcmpBytes<sa_GetMPEGSampleSize(Info)*2)
             break;
           _SlibDebug(_DEBUG_,
               printf("sa_CompressMPEG(Offset=%d) Address=%p Len=%d\n", Offset,
                          DcmpData, DcmpBytes) );
           stat=sa_CompressMPEG(Info, DcmpData+Offset, &DcmpBytes, 
                                                       &CompBytes);
           if (stat==NoErrors)
           {
             if (CompBytes && Info->CallbackFunction)
             {
               SaCallbackInfo_t CB;
               CB.Message       = CB_FRAME_READY;
               CB.Data          = DcmpData+Offset;
               CB.DataType      = CB_DATA_COMPRESSED;
               CB.DataSize      = *DcmpLen-Offset;
               CB.DataUsed      = CompBytes;
               CB.Action        = CB_ACTION_CONTINUE;
               (*Info->CallbackFunction)(Sah, &CB, &Info->Info);
             }
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen+=CompBytes;
           }
         } while (stat==NoErrors && DcmpBytes>0 && Offset<*DcmpLen);
       }
       break; 
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
    case SA_GSM_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_GSMEncode(Info->GSMInfo, (word *)(DcmpData+Offset),
                                          &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#if 0 /* no AC-3 Encode yet */
    case SA_AC3_ENCODE:
       {
         unsigned int DcmpBytes, CompBytes, Offset;
         Offset=0;
         *CompLen=0;
         if (!Info->BSOut && !CompData)
           return(SaErrorBadPointer);
         do  {
           DcmpBytes=*DcmpLen-Offset;
           stat=sa_AC3Encode(Info->AC3Info, (word *)(DcmpData+Offset),
                                      &DcmpBytes, CompData, Info->BSOut);
           if (stat==NoErrors)
           {
             Offset+=DcmpBytes;
             NumBytesIn += DcmpBytes;
             *CompLen += 33;
             if (CompData)
               CompData += 33;
           }
         } while (stat==NoErrors && Offset<*DcmpLen);
       }
       break;
#endif
#endif /* AC3_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       {
         /* Call SaG723Compress (audiobufsize/480) times
          * Need to store unprocessed stuff in Info->AudiobufUsed.
          * (This is done in SlibWriteAudio)
          * G723 encodes 240 samples at a time.=240*2 =480
          */
         unsigned int Offset;
         int iTimes = (int)(*DcmpLen / 480);
         int iLoop =0;
         Offset=0;
         *CompLen=0;
         while (stat==SaErrorNone && iLoop<iTimes)
         {
           stat = saG723Compress(Info,(word *)(DcmpData+Offset),
                                            (char *)CompData);
           Offset+=480; /* Input :240 samples (240*2 = 480 bytes) */
           NumBytesIn += 480;
           *CompLen+=24;/* 24 for 6.3 ;20 for 5.3 rate */
           iLoop++;
         }
       }
       break; 
#endif /* G723_SUPPORT */
    case SA_PCM_ENCODE:
       ScBSPutBytes(Info->BSOut, DcmpData, *DcmpLen);
       *CompLen = *DcmpLen;
       NumBytesIn = *DcmpLen;
       break;
    default:
       *CompLen=0;
       return(SaErrorUnrecognizedFormat);
  }
  *DcmpLen = NumBytesIn;
  Info->Info.NumBytesIn += NumBytesIn;
  Info->Info.NumBytesOut += *CompLen;

  return(stat);
}

/*
** Name:     SaCompressEnd
** Purpose:  Terminate the Compression Codec. Call after all calls to
**           SaCompress are done.
**
** Args:     Sah = handle to software codec's Info structure.
*/
SaStatus_t SaCompressEnd (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(SaErrorCodecHandle);

  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
       Info->MCInfo->CompressStarted = FALSE;
       break;
#endif /* MPEG_SUPPORT */
#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
       //Info->pSaG723Info->CompressStarted = FALSE;
       break;
#endif /* G723_SUPPORT */
    default:
       break;
  }
  if (Info->BSOut)
    ScBSFlush(Info->BSOut);  /* flush out any remaining compressed buffers */

/*
  if (Info->CallbackFunction)
  {
    CB.Message = CB_CODEC_DONE;
    CB.Data = NULL;
    CB.DataSize = 0;
    CB.DataUsed = 0;
    CB.DataType = CB_DATA_NONE;
    CB.TimeStamp = 0;
    CB.Flags = 0;
    CB.Value = 0;
    CB.Format = NULL;
    CB.Action  = CB_ACTION_CONTINUE;
    (*Info->CallbackFunction)(Sah, &CB, NULL);
    _SlibDebug(_DEBUG_,
            printf("SaDecompressEnd Callback: CB_CODEC_DONE Action = %d\n",
                    CB.Action) );
    if (CB.Action == CB_ACTION_END)
      return (ScErrorClientEnd);
  }
*/
  return(NoErrors);
}


/***************************** Miscellaneous *******************************/
/*
** Name:     SaSetDataSource
** Purpose:  Set the data source used by the MPEG bitstream parsing code
**           to either the Buffer Queue or File input. The default is
**           to use the Buffer Queue where data buffers are added by calling
**           SaAddBuffer. When using file IO, the data is read from a file
**           descriptor into a buffer supplied by the user.
**
** Args:     Sah    = handle to software codec's Info structure.
**           Source = SU_USE_QUEUE or SU_USE_FILE
**           Fd     = File descriptor to use if Source = SV_USE_FILE
**           Buf    = Pointer to buffer to use if Source = SV_USE_FILE
**           BufSize= Size of buffer when Source = SV_USE_FILE
*/
SaStatus_t SaSetDataSource (SaHandle_t Sah, int Source, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_DECODE || Info->Type==SA_GSM_DECODE ||
	  Info->Type==SA_AC3_DECODE || Info->Type == SA_G723_DECODE )
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSIn)
  {
    ScBSDestroy(Info->BSIn);
    Info->BSIn=NULL;
  }

  switch (Source)
  {
#ifdef MPEG_SUPPORT
     case SA_USE_SAME:
       if (Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
       break;
#endif /* MPEG_SUPPORT */
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSIn, Buffer_UserData, BufSize); 
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSIn, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSIn, Fd, Buffer_UserData, BufSize);
#ifdef MPEG_SUPPORT
       if (stat==NoErrors && Info->Type==SA_MPEG_DECODE)
         ScBSSetFilter(Info->BSIn, MPEGAudioFilter);
#endif /* MPEG_SUPPORT */
       break;

     default:
       stat=SaErrorBadArgument;
  }
  if (stat==NoErrors && Info->BSIn)
    ScBSReset(Info->BSIn);
  return(stat);
}

SaStatus_t SaSetDataDestination (SaHandle_t Sah, int Dest, int Fd,
                            void *Buffer_UserData, int BufSize)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  int stat=NoErrors;
  int DataType;

  if (!Info)
    return(SaErrorCodecHandle);

  if (Info->Type==SA_MPEG_ENCODE || Info->Type==SA_GSM_ENCODE 
	  /* || Info->Type==SA_AC3_ENCODE */ ||Info->Type==SA_G723_ENCODE)
    DataType=CB_DATA_COMPRESSED;
  else
    DataType=CB_DATA_AUDIO;

  if (Info->BSOut)
  {
    ScBSDestroy(Info->BSOut);
    Info->BSOut=NULL;
  }

  switch (Dest)
  {
     case SA_USE_SAME:
       break;
     case SA_USE_BUFFER:
       stat=ScBSCreateFromBuffer(&Info->BSOut, Buffer_UserData, BufSize); 
       break;

     case SA_USE_BUFFER_QUEUE:
       stat=ScBSCreateFromBufferQueue(&Info->BSOut, Sah, DataType, Info->Q, 
         (int (*)(ScHandle_t, ScCallbackInfo_t *, void *))Info->CallbackFunction,
         (void *)Buffer_UserData);
       break;

     case SA_USE_FILE:
       stat=ScBSCreateFromFile(&Info->BSOut, Fd, Buffer_UserData, BufSize);
       break;

     default:
       stat=SaErrorBadArgument;
  }
/*
  if (stat==NoErrors && Info->BSOut)
    ScBSReset(Info->BSOut);
*/
  return(stat);
}


/*
** Name: SaGetDataSource
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataSource (SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSIn);
}

/*
** Name: SaGetDataDestination
** Purpose: Returns the current input bitstream being used by
**          the Codec.
** Return:  NULL if there no associated bitstream
*/
ScBitstream_t *SaGetDataDestination(SaHandle_t Sah)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

  if (!Info)
    return(NULL);

  return(Info->BSOut);
}

/*
** Name:     SaAddBuffer
** Purpose:  Add a buffer of MPEG bitstream data to the CODEC or add an image
**           buffer to be filled by the CODEC (in streaming mode)
**
** Args:     Sah = handle to software codec's Info structure.
**           BufferInfo = structure describing buffer's address, type & size
*/
SaStatus_t SaAddBuffer (SaHandle_t Sah, SaCallbackInfo_t *BufferInfo)
{
   SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;

   if (!Info)
     return(SaErrorCodecHandle);

   if (BufferInfo->DataType != CB_DATA_COMPRESSED)
     return(SaErrorBadArgument);

   if (!BufferInfo->Data || (BufferInfo->DataSize <= 0))
     return(SaErrorBadArgument);

   ScBufQueueAdd(Info->Q, BufferInfo->Data, BufferInfo->DataSize);

   return(NoErrors);
}

#ifdef MPEG_SUPPORT
/*
** Name:  sa_GetMpegAudioInfo()
** Purpose: Extract info about audio packets in an MPEG file.
** Notes:   If an "info" structure is passed to this function,
**          the entire file will be read for extended info.
** Return:  Not 0 = error
*/
SaStatus_t sa_GetMpegAudioInfo(int fd, WAVEFORMATEX *wf, SaInfo_t *info)
{
  int stat, sync;
  ScBitstream_t *bs;
  SaFrameParams_t fr_ps;
  SaLayer_t layer;
  unsigned long aframes=0, samples=0;
  /* Default info parameters */
  if (info)
  {
    info->Name[0]=0;
    info->Description[0]=0;
    info->Version=0;
    info->CodecStarted=FALSE;
    info->MS=0;
    info->NumBytesIn=0;
    info->NumBytesOut=0;
    info->NumFrames=0;
    info->TotalFrames=0;
    info->TotalMS=0;
  }

  /* Default wave parameters */
  wf->wFormatTag = WAVE_FORMAT_PCM;
  wf->nChannels = 2;
  wf->nSamplesPerSec = 44100;
  wf->wBitsPerSample = 16; 
  wf->cbSize = 0; 

  stat=ScBSCreateFromFile(&bs, fd, NULL, 1024);
  if (stat!=NoErrors)
  {
    fprintf(stderr, "Error creating bitstream.\n");
    return(-1);
  }
  if (ScBSPeekBits(bs, PACK_START_CODE_LEN)!=PACK_START_CODE_BIN
      && ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)!=MPEG_SYNC_WORD)
    stat=SaErrorUnrecognizedFormat;
  else
  {
    if (ScBSPeekBits(bs, MPEG_SYNC_WORD_LEN)==MPEG_SYNC_WORD)
      printf("No MPEG packs found in file; assuming Audio stream only.\n");
    else
      ScBSSetFilter(bs, MPEGAudioFilter); /* Use the MPEG audio filter */

    fr_ps.header = &layer;
    fr_ps.tab_num = -1;   /* no table loaded */
    fr_ps.alloc = NULL;

    sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
    if (!sync) {
      sc_vprintf(stderr,"sa_GetMpegAudioInfo: Frame cannot be located\n");
      return(SaErrorSyncLost);
    }
    /* Decode the first header to see what kind of audio we have */
    sa_DecodeInfo(bs, &fr_ps);
    sa_hdr_to_frps(&fr_ps);
#ifdef _VERBOSE_
    sa_ShowHeader(&fr_ps);
#endif

    /* Save no. of channels & sample rate return parameters for caller */
    wf->nChannels = fr_ps.stereo;
    wf->nSamplesPerSec = s_freq_int[fr_ps.header->sampling_frequency];
    wf->wBitsPerSample = 16; 
    stat=SaErrorNone;
    if (info) /* Read through all frames if there's a info structure */
    {
      sc_vprintf("Counting frames...\n");
      aframes=0;
      while (!bs->EOI && sync)
      {
        sync = ScBSSeekAlign(bs, MPEG_SYNC_WORD, MPEG_SYNC_WORD_LEN);
        if (sync)
        {
          sc_dprintf("0x%X: Frame found\n", 
                      ScBSBytePosition(bs)-4);
          aframes++;
        }
        sa_DecodeInfo(bs, &fr_ps);
        if (wf->nChannels<2)  /* take the maximum number of channels */
        {
          sa_hdr_to_frps(&fr_ps);
          wf->nChannels = fr_ps.stereo;
        }
        if (layer.lay==1)
          samples+=384;
        else
          samples+=1152;

      }
      info->TotalFrames=aframes;
      info->TotalMS=(samples*1000)/wf->nSamplesPerSec;
      info->NumBytesOut=samples * wf->nChannels * 2;
      sc_vprintf("Total Audio Frames = %u Bytes = %d MS = %d\n", 
                       info->TotalFrames, info->NumBytesOut, info->TotalMS);
    }
  }
  /* Reset the bitstream back to the beginning */
  ScBSReset(bs);
  /* Close the bit stream */
  ScBSDestroy(bs);
  /* Calculate additional parameters */
  wf->nBlockAlign = (wf->wBitsPerSample>>3) * wf->nChannels; 
  wf->nAvgBytesPerSec = wf->nBlockAlign*wf->nSamplesPerSec;
  return(stat);
}
#endif /* MPEG_SUPPORT */

/*
** Name:  sa_ConvertFormat()
** Purpose: Do simple PCM data conversion (i.e. 16 to 8 bit,
**          Stereo to Mono, etc.)
*/
static int sa_ConvertPCMFormat(SaCodecInfo_t *Info, u_char *data, int length)
{
  int skip, rbytes;
  u_char *fromptr, *toptr;
  /* convert 16 bit to 8 bit if necessary */
  if (Info->wfOut->wBitsPerSample == 8)
  {
    if (Info->wfOut->nChannels==1 && Info->wfOut->nChannels==2)
      skip=4;
    else
      skip=2;
    length/=skip;
    toptr = data;
    fromptr = data+1;
    for (rbytes=length; rbytes; rbytes--, toptr++, fromptr+=skip)
      *toptr = *fromptr;
  }
  return(length);
}

SaStatus_t SaSetParamBoolean(SaHandle_t Sah, SaParameter_t param, 
                                             ScBoolean_t value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamBoolean()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_ENCODE:
           saMpegSetParamBoolean(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_ENCODE:
           saG723SetParamBoolean(Sah, param, value);
           break;
#endif
    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

SaStatus_t SaSetParamInt(SaHandle_t Sah, SaParameter_t param, qword value)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(SaErrorCodecHandle);
  _SlibDebug(_VERBOSE_, printf("SaSetParamInt()\n") );
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           saMpegSetParamInt(Sah, param, value);
           break;
#endif

#ifdef AC3_SUPPORT
    case SA_AC3_DECODE:
    /* case SA_AC3_ENCODE: */
           saAC3SetParamInt(Sah, param, value);
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           saG723SetParamInt(Sah, param, value);
           break;
#endif

    default:
           return(SaErrorCodecType);
  }
  return(NoErrors);
}

ScBoolean_t SaGetParamBoolean(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(FALSE);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamBoolean(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamBoolean(Sah, param));
           break;
#endif
  }
  return(FALSE);
}

qword SaGetParamInt(SaHandle_t Sah, SaParameter_t param)
{
  SaCodecInfo_t *Info = (SaCodecInfo_t *)Sah;
  if (!Info)
    return(0);
  switch (Info->Type)
  {
#ifdef MPEG_SUPPORT
    case SA_MPEG_DECODE:
    case SA_MPEG_ENCODE:
           return(saMpegGetParamInt(Sah, param));
           break;
#endif

#ifdef G723_SUPPORT
    case SA_G723_DECODE:
    case SA_G723_ENCODE:
           return(saG723GetParamInt(Sah, param));
           break;
#endif
  }
  return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sa_proto.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sa_prototypes.h,v $
 * Revision 1.1.8.4  1996/11/14  21:49:25  Hans_Graves
 * 	Added sa_AC3SetParamInt() proto.
 * 	[1996/11/14  21:48:29  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/08  21:50:58  Hans_Graves
 * 	Added AC3 stuff.
 * 	[1996/11/08  21:18:58  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/09/18  23:46:14  Hans_Graves
 * 	Changed proto for sa_PsychoAnal()
 * 	[1996/09/18  21:58:47  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:34  Hans_Graves
 * 	Added sa_MpegGet/SetParam functions
 * 	[1996/04/10  21:38:49  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:38  Hans_Graves
 * 	Fix protos for sa_SetMPEGBitrate and sa_SetMPEGParams)
 * 	[1996/04/09  16:02:14  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:11  Hans_Graves
 * 	Added MPEG_SUPPORT and GSM_SUPPORT ifdefs
 * 	[1996/03/29  22:13:39  Hans_Graves]
 * 
 * Revision 1.1.4.3  1996/01/19  15:29:34  Bjorn_Engberg
 * 	Removed compiler wanrnings for NT.
 * 	[1996/01/19  14:57:39  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1996/01/15  16:26:24  Hans_Graves
 * 	Added prototype for sa_SetMPEGBitrate()
 * 	[1996/01/15  15:43:13  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/27  13:54:26  Hans_Graves
 * 	Added prototypes for GSM.
 * 	[1995/06/27  13:24:34  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:45  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:34:15  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:38:58  Hans_Graves
 * 	Added MPEG Encoding prototypes
 * 	[1995/04/17  18:32:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:36:59  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:31:43  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*--------------------------------------------------------------------------
 * SLIB Internals Prototype file (externals are in SA.h)
 *
 * Modification History: sa_prototypes.h
 *
 *      29-Jul-94  PSG  Created
 *---------------------------------------------------------------------------*/

#ifndef _SA_PROTOTYPES_H
#define _SA_PROTOTYPES_H

#ifdef MPEG_SUPPORT
#include "sa_mpeg.h"
#endif /* MPEG_SUPPORT */
#ifdef GSM_SUPPORT
#include "sa_gsm.h"
#endif /* GSM_SUPPORT */
#ifdef AC3_SUPPORT
#include "sa_ac3.h"
#endif /* GSM_SUPPORT */
#include "sa_intrn.h"

/*---------------------------------------------------------------------------*/
/*                     Compress/Decompress Codec Prototypes                  */
/*---------------------------------------------------------------------------*/

#ifdef MPEG_SUPPORT
/*
 *  sa_mpeg_common.c
 */
extern SaStatus_t saMpegSetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);
extern SaStatus_t saMpegSetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);
extern qword saMpegGetParamInt(SaHandle_t Sah, SaParameter_t param);
extern ScBoolean_t saMpegGetParamBoolean(SaHandle_t Svh, SaParameter_t param);

extern int sa_PickTable(SaFrameParams_t *fr_ps);
extern void sa_ShowHeader(SaFrameParams_t *fr_ps);
extern void sa_ShowBitAlloc(unsigned int bit_alloc[2][SBLIMIT],
                            SaFrameParams_t *f_p);
extern void sa_ShowScale(unsigned int bit_alloc[2][SBLIMIT],
                  unsigned int scfsi[2][SBLIMIT],
                  unsigned int scalar[2][3][SBLIMIT],
                  SaFrameParams_t *fr_ps);
extern void sa_ShowSamples(int ch, unsigned int FAR sample[SBLIMIT],
                    unsigned int bit_alloc[SBLIMIT], SaFrameParams_t *fr_ps);
extern int sa_BitrateIndex(int layr, int bRate);
extern int sa_SmpFrqIndex(long sRate);
extern void sa_CRCupdate(unsigned int data, unsigned int length, unsigned int *crc);
extern void sa_CRCcalcI(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                                        unsigned int *crc);
extern void sa_CRCcalcII(SaFrameParams_t *fr_ps, unsigned int bit_alloc[2][SBLIMIT],
                             unsigned int scfsi[2][SBLIMIT], unsigned int *crc);
extern SaStatus_t sa_hdr_to_frps(SaFrameParams_t *fr_ps);


/*
 *   sa_mpeg_decode.c
 */
extern SaStatus_t sa_DecompressMPEG(SaCodecInfo_t *Info,
                              unsigned char *buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_DecodeInfo(ScBitstream_t *bs, SaFrameParams_t *fr_ps);
extern SaStatus_t sa_InitMpegDecoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegDecoder(SaCodecInfo_t *Info);

/*
 *   sa_mpeg_encode.c
 */
extern SaStatus_t sa_MpegVerifyEncoderSettings(SaHandle_t Sah);
extern SaStatus_t sa_CompressMPEG(SaCodecInfo_t *Info,
                           unsigned char *dcmp_buf, unsigned int *dcmp_len,
                           unsigned int *comp_len);
extern SaStatus_t sa_InitMpegEncoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndMpegEncoder(SaCodecInfo_t *Info);
extern unsigned int sa_GetMPEGSampleSize(SaCodecInfo_t *Info);

/*
** sa_mpeg_tonal.c
*/
extern void sa_II_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
extern void sa_I_Psycho_One(float buffer[2][1152], float scale[2][SBLIMIT],
                      float ltmin[2][SBLIMIT], SaFrameParams_t *fr_ps);
/*
** sa_mpeg_psy.c
*/
extern void sa_PsychoAnal(SaMpegCompressInfo_t *MCInfo, float *buffer,
                          float savebuf[1056],int chn,int lay,
                          float snr32[32],float sfreq,int num_pass);
#endif /* MPEG_SUPPORT */

#ifdef GSM_SUPPORT
/*
** sa_gsm_common.c
*/
SaStatus_t sa_InitGSM(SaGSMInfo_t *info);

extern word  gsm_mult(word a, word b);
extern dword gsm_L_mult(word a, word b);
extern word  gsm_mult_r(word a, word b);
extern word  gsm_div(word num, word denum);
extern word  gsm_add( word a, word b );
extern dword gsm_L_add(dword a, dword b );
extern word  gsm_sub(word a, word b);
extern dword gsm_L_sub(dword a, dword b);
extern word  gsm_abs(word a);
extern word  gsm_norm(dword a);
extern dword gsm_L_asl(dword a, int n);
extern word  gsm_asl(word a, int n);
extern dword gsm_L_asr(dword a, int n);
extern word  gsm_asr(word a, int n);

/*
** sa_gsm_encode.c
*/
extern SaStatus_t sa_GSMEncode(SaGSMInfo_t *s, word *dcmp_buf, 
                               unsigned int *dcmp_len,
                               unsigned char *comp_buf,
                               ScBitstream_t *bsout);
extern void Gsm_Long_Term_Predictor(SaGSMInfo_t *S, word *d, word *dp, word *e, word *dpp,
                                    word *Nc, word *bc);
extern void Gsm_Encoding(SaGSMInfo_t *S, word *e, word *ep, word *xmaxc, 
                          word *Mc, word *xMc);
extern void Gsm_Short_Term_Analysis_Filter(SaGSMInfo_t *S,word *LARc,word *d);
/*
** sa_gsm_decode.c
*/
extern int sa_GSMDecode(SaGSMInfo_t *s, unsigned char *comp_buf, word *dcmp_buf);
extern void Gsm_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word *xMcr, word *erp);
extern void Gsm_Long_Term_Synthesis_Filtering(SaGSMInfo_t *S, word Ncr, word bcr,
                                               word *erp, word *drp);
void Gsm_RPE_Decoding(SaGSMInfo_t *S, word xmaxcr, word Mcr, word * xMcr, word * erp);
void Gsm_RPE_Encoding(SaGSMInfo_t *S, word *e, word *xmaxc, word *Mc, word *xMc);
/*
** sa_gsm_filter.c
*/
extern void Gsm_Short_Term_Synthesis_Filter(SaGSMInfo_t *S, word *LARcr, 
                                            word *drp, word *s);
extern void Gsm_Update_of_reconstructed_short_time_residual_signal(word *dpp,
                                                              word *ep, word *dp);
/*
** sa_gsm_table.c
*/
extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
extern word gsm_INVA[8];
extern word gsm_DLB[4], gsm_QLB[4];
extern word gsm_H[11];
extern word gsm_NRFAC[8];
extern word gsm_FAC[8];
#endif /* GSM_SUPPORT */

#ifdef AC3_SUPPORT

/* AC-3 specific stuff goes here */
/*
 *   sa_ac3_decode.c
 */
extern SaStatus_t sa_DecompressAC3(SaCodecInfo_t *Info,
                              unsigned char **buffer, unsigned int size,
                              unsigned int *ret_length);
extern SaStatus_t sa_InitAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t sa_EndAC3Decoder(SaCodecInfo_t *Info);
extern SaStatus_t saAC3SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);


#endif /* AC3_SUPPORT */

#ifdef G723_SUPPORT
/* G723 encoder functions. 
   sa_g723_coder.c
*/
typedef  short int   Flag  ;
extern void saG723CompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Input frame (480 bytes)
//Vout     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
extern SaStatus_t  saG723Compress( SaCodecInfo_t *Info,word *DataBuff, char *Vout );

extern void saG723CompressFree(SaG723Info_t *psaG723Info);

/* G723 decoder functions. 
   sa_g723_decod.c
*/
extern void saG723DecompressInit(SaG723Info_t *psaG723Info);

//DataBuff :Empty Buffer to hold decoded frame(480 bytes)
//Vinp     :Encoded frame (20 bytes :5.3K bits/s
//                        (24 bytes :6.3K bits/s)
//Crc      : Transmission Error code (Cyclic Redundant code)
extern SaStatus_t  saG723Decompress( SaCodecInfo_t *Info,word *DataBuff, 
               char *Vinp, word Crc );

extern void saG723DecompressFree(SaG723Info_t *psaG723Info);

extern SaStatus_t saG723SetParamInt(SaHandle_t Sah, SaParameter_t param,
                                qword value);

extern SaStatus_t saG723SetParamBoolean(SaHandle_t Sah, SaParameter_t param,
                                  ScBoolean_t value);

extern qword saG723GetParamInt(SaHandle_t Sah, SaParameter_t param);

extern ScBoolean_t saG723GetParamBoolean(SaHandle_t Svh, SaParameter_t param);

#endif /* G723_SUPPORT */

#endif _SA_PROTOTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_vid.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_video.h,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API - Video
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif

unsigned dword sconCalcImageSize(SconVideoInfo_t *vinfo)
{
  vinfo->Pixels=vinfo->Width*vinfo->Height;
  switch (vinfo->FourCC)
  {
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*5)/4;
          break;
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
          vinfo->ImageSize = (vinfo->Pixels*3)/2;
          break;
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
          vinfo->ImageSize = vinfo->Pixels*2;
          break;
#ifndef WIN32
      case BI_DECXIMAGEDIB:
          vinfo->ImageSize = vinfo->Pixels*(vinfo->BPP==24 ? 4 : 1);
          break;
#endif /* !WIN32 */
      case BI_RGB:
      case BI_BITFIELDS:
          vinfo->ImageSize = vinfo->Pixels*((vinfo->BPP+7)/8);
          break;
      default:
          vinfo->ImageSize = vinfo->Pixels;
  }
  return(vinfo->ImageSize);
}

static void sconScaleFrame(unsigned word bytesperpixel,
                           void *inbuf, int inw, int inh,
                           void *outbuf, int outw, int outh, int stride)
{
  int inx, outx, iny=0, outy=0;
  int deltax, deltay;
  _SlibDebug(_VERBOSE_,
         ScDebugPrintf(NULL, "sconScaleFrame(byteperpixel=%d) %dx%d -> %dx%d\n",
                      bytesperpixel, inw, inh, outw, outh) );
  if (inh<0)  inh=-inh;   /* no flipping supported */
  if (outh<0) outh=-outh; /* no flipping supported */
  if (bytesperpixel==4)
  {
    unsigned dword *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned dword *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned dword *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned dword *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==3)
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    inw*=3;
    outw*=3;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            outscan[outx+1]=inscan[inx+1];
            outscan[outx+2]=inscan[inx+2];
            deltax+=inw;
            outx+=3;
          }
          inx+=3;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
  else if (bytesperpixel==2)
  {
    unsigned word *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned word *)inbuf;
      while (deltay<outh)
      {
        outscan=(unsigned word *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned word *)inbuf)+=inw;
    }
  }
  else /* bytesperpixel==1 */
  {
    unsigned char *inscan, *outscan;
    deltay=0;
    while (iny<inh)
    {
      inscan=(unsigned char *)inbuf;
      _SlibDebug(_DEBUG_>1,
          ScDebugPrintf(NULL, "deltay=%d iny=%d outy=%d inh=%d outh=%d\n",
                 deltay, iny, outy, inh, outh) );
      while (deltay<outh)
      {
        outscan=(unsigned char *)outbuf;
        inx=0; outx=0;
        deltax=0;
        while (inx<inw)
        {
          while (deltax<outw)
          {
            outscan[outx]=inscan[inx];
            deltax+=inw;
            outx++;
          }
          inx++;
          deltax-=outw;
        }
        outy++;
        deltay+=inh;
        (unsigned char *)outbuf+=stride;
      }
      iny++;
      deltay-=outh;
      ((unsigned char *)inbuf)+=inw;
    }
  }
}


SconStatus_t sconConvertVideo(SconInfo_t *Info, void *inbuf, dword inbufsize,
                                                void *outbuf, dword outbufsize)
{
  unsigned dword informat, outformat;
  unsigned char *prescalebuf=inbuf;
  dword inwidth, inheight, outwidth, outheight, inbpp, outbpp, stride;
  SconStatus_t retval=SconErrorNone;
  SconBoolean_t scale, flip, sameformat;
  _SlibDebug(_VERBOSE_, printf("sconConvertVideo()\n") );
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  inwidth=Info->Input.vinfo.Width;
  inheight=Info->Input.vinfo.Height;
  informat=Info->Input.vinfo.FourCC;
  inbpp=Info->Input.vinfo.BPP;
  outwidth=Info->Output.vinfo.Width,
  outheight=Info->Output.vinfo.Height;
  outformat=Info->Output.vinfo.FourCC;
  outbpp=Info->Output.vinfo.BPP;
  scale=(Info->ScaleUp || Info->ScaleDown)?TRUE:FALSE;
  flip=Info->Flip;
  sameformat=Info->SameFormat;
  _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() %dx%d(%c%c%c%c)->%dx%d(%c%c%c%c)\n",
            inwidth, inheight, informat&0xFF, (informat>>8)&0xFF, (informat>>16)&0xFF, (informat>>24)&0xFF,
            outwidth, outheight, outformat&0xFF, (outformat>>8)&0xFF, (outformat>>16)&0xFF, (outformat>>24)&0xFF) );
  _SlibDebug(_DEBUG_, ScDebugPrintf(NULL, "SconConvert() scale=%d flip=%d sameformat=%d\n",
                            scale, flip, sameformat) );
  if (scale || flip)
  {
    if (Info->SImage==NULL && !sameformat)
    {
      SconVideoInfo_t int_vinfo;
      memcpy(&int_vinfo, &Info->Output.vinfo, sizeof(SconVideoInfo_t));
      int_vinfo.Width=inwidth;
      int_vinfo.Height=inheight;
      Info->SImageSize=sconCalcImageSize(&int_vinfo);
      if ((Info->SImage=ScPaMalloc(Info->SImageSize))==NULL)
        return(SconErrorMemory);
    }
  }
  else if (sameformat)
  {
    memcpy(outbuf, inbuf, Info->Input.vinfo.ImageSize);
    return(SconErrorNone);
  }
  if (sameformat)
    prescalebuf=(unsigned char *)inbuf;
  else
  {
    prescalebuf=(unsigned char *)(scale?Info->SImage:outbuf);
    stride=scale?(inwidth*((outbpp+7)>>3)):Info->Output.vinfo.Stride;
    if (flip) stride=-stride;
    if (IsYUV411Sep(informat)) /* YUV 4:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:      /* YUV 4:2:2 Packed */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YUY2\n") );
          ScSepYUVto422i((unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf, inwidth, inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Ue=(unsigned char *)prescalebuf+inwidth*inheight,
                          *Uo=Ue+inwidth/2;
            memcpy(prescalebuf, inbuf, inwidth*inheight);
            ((unsigned char *)inbuf)+=inwidth*inheight;
            for (i=inheight; i; i--)
            {
              memcpy(Ue, inbuf, inwidth/2);
              memcpy(Uo, inbuf, inwidth/2);
              ((unsigned char *)inbuf)+=inwidth/2;
              Ue+=inwidth;
              Uo+=inwidth;
            }
          }
          break;
        case BI_YVU9SEP: /* YUV 16:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->BI_YVU9\n") );
          ScConvert411sTo1611s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*9)/8,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon420ToRGB565((unsigned char *)inbuf,
                              (unsigned char *)prescalebuf,
                              inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp=24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon420ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
          {
            BITMAPINFOHEADER outbmh;
            outbmh.biWidth=inwidth;
            outbmh.biHeight=inheight;
            outbmh.biCompression=outformat;
            outbmh.biBitCount=(WORD)outbpp;
            stride=scale?inwidth:outwidth;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->RGB\n") );
            ScYuv411ToRgb(&outbmh, (unsigned char *)inbuf,
                     (unsigned char *)inbuf+(inwidth*inheight),
                     (unsigned char *)inbuf+(inwidth*inheight*5)/4,
                     (unsigned char *)prescalebuf,
                     inwidth, inheight, stride);
          }
          break;
        default:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU12SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Sep(informat)) /* YUV 4:2:2 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Planar->BI_YU12SEP\n") );
          ScConvert422PlanarTo411_C((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          ScConvert422PlanarTo422i_C((unsigned char *)inbuf,
                           ((unsigned char *)inbuf)+(inwidth*inheight),
                           ((unsigned char *)inbuf)+(inwidth*inheight*3)/2,
                           (unsigned char *)prescalebuf,
                           inwidth, inheight);
          break;
        case BI_RGB:
        case BI_BITFIELDS:
        case BI_DECXIMAGEDIB:
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->BI_RGB Unsupported\n") );
          if (outbpp==16)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            if (Info->Output.vinfo.RGBmasks==565)
              scon422ToRGB565((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else if (outbpp==24)
          {
            if (Info->Table==NULL)
              sconInitYUVtoRGB(Info);
            scon422ToRGB888((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, stride, Info->Table);
          }
          else
            retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YU16SEP->Unsupported\n") );
      }
    }
    else if (IsYUV422Packed(informat)) /* YUV 4:2:2 Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() 422 Packed->BI_YU12SEP\n") );
          ScConvert422ToYUV_char((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* 4:2:2 Packed -> 4:2:2 Planar */
        case BI_DECSEPYUVDIB:
          _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_YU16SEP\n") );
          {
            register int i;
            unsigned char *Y=prescalebuf,
                          *U=(unsigned char *)prescalebuf+(inwidth*inheight),
                          *V=U+(inwidth*inheight)/2;
            for (i=(inwidth*inheight)/2; i; i--)
            {
              *Y++ = *((unsigned char *)inbuf)++;
              *U++ = *((unsigned char *)inbuf)++;
              *Y++ = *((unsigned char *)inbuf)++;
              *V++ = *((unsigned char *)inbuf)++;
            }
          }
          break;
        case BI_RGB: /* 4:2:2 Packed -> RGB */
          if (outbpp!=16)
            return(SconErrorUnsupportedFormat);
          else
          {
            u_short *Sout;
            int i, Y1, Y2, U, V, Luma;
            int R1,R2, G1,G2, B1,B2;
            _SlibDebug(_VERBOSE_,
               ScDebugPrintf(NULL, "SconConvert() BI_YUY2->BI_RGB\n") );
            Sout = (u_short *)prescalebuf;
            for (i=(inwidth*inheight)/4; i; i--)
            {
              Y1=(int)*((unsigned char *)inbuf)++;
              U=(int)(*((unsigned char *)inbuf)++) - 128;
              Y2=(int)*((unsigned char *)inbuf)++;
              V=(int)(*((unsigned char *)inbuf)++) - 128;
               if (U || V) {
                 R1 = R2 = (int) (              + (1.596 * V));
                 G1 = G2 = (int) (- (0.391 * U) - (0.813 * V));
                 B1 = B2 = (int) (+ (2.018 * U)              );
               } else { R1=R2=G1=G2=B1=B2=0; }
                   Luma = (int) ((float)(Y1 - 16) * (float)1.164);
               R1 += Luma; G1 += Luma; B1 += Luma;
                   Luma = (int) ((float)(Y2 - 16) * (float)1.164);
               R2 += Luma; G2 += Luma; B2 += Luma;
               if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) {
                 if (R1<0) R1=0; else if (R1>255) R1=255;
                 if (G1<0) G1=0; else if (G1>255) G1=255;
                 if (B1<0) B1=0; else if (B1>255) B1=255;
                 if (R2<0) R2=0; else if (R2>255) R2=255;
                 if (G2<0) G2=0; else if (G2>255) G2=255;
                 if (B2<0) B2=0; else if (B2>255) B2=255;
               }
#if 1 /* RGB 565 - 16 bit */
               *(Sout++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
#else /* RGB 555 - 15 bit */
               *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
               *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
#endif
            }
          }
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YUY2->Unsupported\n") );
      }
    }
    else if (IsRGBPacked(informat)) /* RGB Packed */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          if (inbpp==16)
            ScConvertRGB555To411s((unsigned char *)inbuf,
                                (unsigned char *)prescalebuf,
                                inwidth, flip?-inheight:inheight);
          else
          {
            if (Info->Table==NULL)
              sconInitRGBtoYUV(Info);
            sconRGB888To420((unsigned char *)inbuf,
                            (unsigned char *)prescalebuf,
                            inwidth, inheight, (flip?-inwidth:inwidth)*3, Info->Table);
            // ScConvertRGB24To411s((unsigned char *)inbuf,
            //                    (unsigned char *)prescalebuf,
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight),
            //                    ((unsigned char *)prescalebuf)+(inwidth*inheight*5)/4,
            //                    inwidth, flip?-inheight:inheight);
          }
          break;
        case BI_RGB: /* RGB */
          retval=SconErrorUnsupportedFormat;
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_RGB->Unsupported\n") );
      }
    }
    else if (IsYUV1611Sep(informat)) /* YUV 16:1:1 Planar */
    {
      switch (outformat)
      {
        case BI_YU12SEP: /* YUV 4:1:1 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU12SEP\n") );
          ScConvert1611sTo411s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*5)/4,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_YU16SEP: /* YUV 4:2:2 Planar */
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YU16SEP\n") );
          ScConvert1611sTo422s((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf,
                           ((unsigned char *)prescalebuf)+(outwidth*outheight),
                           ((unsigned char *)prescalebuf)+(outwidth*outheight*3)/2,
                           inwidth, flip?-inheight:inheight);
          break;
        case BI_DECYUVDIB: /* YUV 4:2:2 Packed */
        case BI_YUY2:
          _SlibDebug(_VERBOSE_,
              ScDebugPrintf(NULL, "SconConvert() BI_YVU9->BI_YUY2\n") );
          ScConvert1611sTo422i((unsigned char *)inbuf,
                           (unsigned char *)prescalebuf, inwidth, flip?-inheight:inheight);
          break;
        default:
          retval=SconErrorUnsupportedFormat;
          _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() BI_YVU9->Unsupported\n") );
      }
    }
    _SlibDebug(_VERBOSE_ && retval==SconErrorUnsupportedFormat,
              ScDebugPrintf(NULL, "SconConvert() Unsupported->Unsupported\n"));
  }
  if (retval==SconErrorNone && scale)
  {
    if (IsRGBPacked(outformat))
    {
      /* Scaling RGB */
      _SlibDebug(_VERBOSE_,
           ScDebugPrintf(NULL, "SconConvert() Scaling BI_RGB\n") );
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame((unsigned word)((outbpp+7)>>3),
                   prescalebuf, inwidth, inheight,
                   outbuf, outwidth, outheight, stride);
    }
    else if (IsYUV411Sep(outformat)) /* YUV 4:1:1 Planar */
    {
      _SlibDebug(_VERBOSE_, ScDebugPrintf(NULL, "SconConvert() Scaling BI_YU12SEP\n") );
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/2, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/2, outheight, outwidth/2);
    }
    else if (IsYUV422Packed(outformat)) /* YUV 4:2:2 Packed */
    {
      stride=Info->Output.vinfo.Stride;
      sconScaleFrame(4,
                     prescalebuf, inwidth/2, inheight,
                     outbuf, outwidth/2, outheight, stride);
    }
    else if (IsYUV422Sep(outformat)) /* YUV 4:2:2 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth, outheight, outwidth);
    }
    else if (IsYUV1611Sep(outformat)) /* YUV 16:1:1 Planar */
    {
      sconScaleFrame(1,
                         prescalebuf, inwidth, inheight,
                         outbuf, outwidth, outheight, outwidth);
      sconScaleFrame(1,
                         ((unsigned char *)prescalebuf)+(inwidth*inheight),
                               inwidth/8, inheight,
                         ((unsigned char *)outbuf)+(outwidth*outheight),
                               outwidth/8, outheight, outwidth/8);
    }
    else
    {
      retval=SconErrorUnsupportedFormat;
      _SlibDebug(_VERBOSE_,
                ScDebugPrintf(NULL, "SconConvert() Scaling Unsupported\n") );
    }
  }
  return(retval);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_conv.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_convert.c,v $
 * Revision 1.1.8.6  1996/10/28  17:32:17  Hans_Graves
 * 	Add use IsYUV422Sep() macro in ScConvertSepYUVToOther().
 * 	[1996/10/28  16:51:30  Hans_Graves]
 *
 * Revision 1.1.8.5  1996/10/02  18:42:50  Hans_Graves
 * 	Fix RGB 24-bit conversion in ScYuv411ToRgb().
 * 	[1996/10/02  18:32:51  Hans_Graves]
 *
 * Revision 1.1.8.4  1996/09/29  22:19:32  Hans_Graves
 * 	Added stride support to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:17  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/09/18  23:45:34  Hans_Graves
 * 	Added ScConvert1611PlanarTo411_C, ScConvert411sTo422s_C, and ScRgbToYuv411
 * 	[1996/09/18  21:52:27  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/05/07  19:55:42  Hans_Graves
 * 	Added YUV 4:1:1 to RGB 32-bit conversion - C code
 * 	[1996/05/07  19:44:38  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/11  20:21:57  Hans_Graves
 * 	Moved ScIsUpsideDown() from sc_convert_yuv.c
 * 	[1996/04/11  20:03:44  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/09  16:04:24  Hans_Graves
 * 	Added ValidateBI_BITFIELDS(). Fixed BI_RGB 16 bit conversion in ScYuv411ToRgb()
 * 	[1996/04/09  14:46:27  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/03  21:41:07  Hans_Graves
 * 	Change include path for <mmsystems.h>
 * 	[1996/04/03  21:37:55  Hans_Graves]
 *
 * Revision 1.1.4.4  1996/02/22  17:35:17  Bjorn_Engberg
 * 	Added support for BI_BITFIELDS 16 and BI_RGB 32 rendering.
 * 	[1996/02/22  17:31:35  Bjorn_Engberg]
 *
 * Revision 1.1.4.3  1996/01/02  18:30:33  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts
 * 	[1996/01/02  15:21:27  Bjorn_Engberg]
 *
 * Revision 1.1.4.2  1995/12/07  19:31:15  Hans_Graves
 * 	Added ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:00  Hans_Graves]
 *
 * Revision 1.1.2.21  1995/11/30  20:17:02  Hans_Graves
 * 	Cleaned up ScYuv422toRgb() routine
 * 	[1995/11/30  20:13:26  Hans_Graves]
 *
 * Revision 1.1.2.20  1995/11/28  22:47:28  Hans_Graves
 * 	Make XIMAGE 24 identical to BI_BITFIELDS pBGR
 * 	[1995/11/28  22:26:11  Hans_Graves]
 *
 * 	Added ScYuv1611ToRgb() routine for use by Indeo
 * 	[1995/11/28  21:34:28  Hans_Graves]
 *
 * Revision 1.1.2.19  1995/11/17  21:31:21  Hans_Graves
 * 	Add ScYuv411ToRgb() conversion routine.
 * 	[1995/11/17  20:50:51  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/10/25  18:19:18  Bjorn_Engberg
 * 	Support Upside Down in ScRgbInterlToYuvInterl().
 * 	[1995/10/25  18:05:18  Bjorn_Engberg]
 *
 * Revision 1.1.2.17  1995/10/10  21:43:02  Bjorn_Engberg
 * 	Speeded up RgbToYuv code and made it table driven.
 * 	[1995/10/10  21:21:48  Bjorn_Engberg]
 *
 * Revision 1.1.2.16  1995/10/09  19:44:31  Bjorn_Engberg
 * 	Removed ValidateBI_BITFIELDS(), it's now in sc_convert_yuv.c
 * 	[1995/10/09  19:44:14  Bjorn_Engberg]
 *
 * Revision 1.1.2.15  1995/10/06  20:43:23  Farokh_Morshed
 * 	Enhance ScRgbInterlToYuvInterl to handle BI_BITFIELDS
 * 	[1995/10/06  20:42:43  Farokh_Morshed]
 *
 * Revision 1.1.2.14  1995/10/02  19:30:26  Bjorn_Engberg
 * 	Added support for Assebler YUV to RGB routines.
 * 	[1995/10/02  18:39:05  Bjorn_Engberg]
 *
 * Revision 1.1.2.13  1995/09/28  20:37:53  Farokh_Morshed
 * 	Handle negative Height
 * 	[1995/09/28  20:37:39  Farokh_Morshed]
 *
 * Revision 1.1.2.12  1995/09/26  15:58:47  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:09  Paul_Gauthier]
 *
 * Revision 1.1.2.11  1995/09/22  18:56:35  Paul_Gauthier
 * 	{** Merge Information **}
 * 	      {** Command used:       bsubmit **}
 * 	      {** Ancestor revision:  1.1.2.7 **}
 * 	      {** Merge revision:     1.1.2.10 **}
 * 	{** End **}
 * 	Use faster method for 16bit YUV output for TGA2
 * 	[1995/09/22  18:39:55  Paul_Gauthier]
 *
 * Revision 1.1.2.10  1995/09/21  18:26:45  Farokh_Morshed
 * 	When BI_RGB or BI_BITFIELDS, invert the image while translating from
 * 	YUV to RGB.  Also fix the coefficient for the YUV colors.
 * 	This work was actually done by Bjorn
 * 	[1995/09/21  18:26:19  Farokh_Morshed]
 *
 * Revision 1.1.2.9  1995/09/20  17:39:18  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:22  Karen_Dintino]
 *
 * Revision 1.1.2.8  1995/09/20  14:59:31  Bjorn_Engberg
 * 	Port to NT
 * 	[1995/09/20  14:41:10  Bjorn_Engberg]
 *
 * Revision 1.1.2.7  1995/09/18  19:47:47  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:13  Paul_Gauthier]
 *
 * Revision 1.1.2.6  1995/09/14  14:40:34  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:26:13  Karen_Dintino]
 *
 * Revision 1.1.2.5  1995/09/11  18:47:25  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.3 **}
 * 		{** Merge revision:	1.1.2.4 **}
 * 	{** End **}
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:43:39  Farokh_Morshed]
 *
 * Revision 1.1.2.4  1995/09/05  17:17:34  Paul_Gauthier
 * 	Fix for softjpeg decompression JPEG -> BICOMP_DECYUVDIB
 * 	[1995/09/05  17:17:09  Paul_Gauthier]
 *
 * Revision 1.1.2.3  1995/08/03  15:01:06  Hans_Graves
 * 	Moved ScConvert422ToYUV_char_C() from h261.
 * 	[1995/08/03  14:46:23  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:27  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:06:30  Hans_Graves]
 *
 * $EndLog$
 */

/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1993                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
**
**  Miscellaneous conversion utility subroutines
**
**  Author(s): Victor Bahl
**  Date:      May 27, 1993
**
*/

#include <stdio.h>  /* NULL */
#include <sys/types.h>
#ifdef WIN32
#include <windows.h>
#include <mmsystem.h>
#else /* !WIN32 */
#include <mmsystem.h>
#endif /* !WIN32 */

#include "SC_conv.h"
#include "SC_err.h"

#ifndef BI_DECSEPRGBDIB
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#endif

#define NEW_YCBCR		/* Use new YUV to RGB coefficients */

/*
** Name:     ScCreateBMHeader
** Purpose:  Allocate memory for a (Microsoft specified) bitmap header and
**           fill in the appropriate fields
**
*/
BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors)
{
    BITMAPINFOHEADER *pHead;
    int struct_size = sizeof(BITMAPINFOHEADER) + ncolors*sizeof(RGBQUAD);

    if ((pHead = (BITMAPINFOHEADER *)ScAlloc(struct_size)) == NULL) {
       puts("Can't Allocate memory for image headers");
       return NULL;
    }

    pHead->biSize          = sizeof(BITMAPINFOHEADER);
    pHead->biWidth         = width;
    pHead->biHeight        = height;
    pHead->biPlanes        = 1;
    pHead->biBitCount      = (WORD)bpp;
    pHead->biCompression   = format;
    pHead->biSizeImage     = 0;
    pHead->biXPelsPerMeter = 0;
    pHead->biYPelsPerMeter = 0;
    pHead->biClrUsed       = ncolors;
    pHead->biClrImportant  = 0;

    return pHead;
}

/*
** Function: ScIsUpsideDown
** Descript: Return TRUE if the current combination
** of input and output formats and image
** heights means that the image should be
** flipped during the render stage.
*/
int ScIsUpsideDown( BITMAPINFOHEADER *lpbiIn,
                    BITMAPINFOHEADER *lpbiOut )
{
    int ups = 0 ;
    if( lpbiIn )
      ups = (((lpbiIn->biCompression == BI_RGB) ||
              (lpbiIn->biCompression == BI_BITFIELDS)) ^
             ((int) lpbiIn->biHeight < 0)) ;
    if( lpbiOut )
      ups ^= (((lpbiOut->biCompression == BI_RGB) ||
               (lpbiOut->biCompression == BI_BITFIELDS)) ^
              ((int) lpbiOut->biHeight < 0)) ;
    return ups ;
}

/*
**++
**  FUNCTIONAL_DESCRIPTION:
**	Return an enum value that validates a BI_BITFIELDS bitmapinfoheader
**      with BI_BITFIELDS format.
**
**  FORMAL PARAMETERS:
**	Pointer to bitmapinfoheader
**  RETURN VALUE:
**	A value from enum type ValidBI_BITFIELDSKinds.
**/
enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(
    LPBITMAPINFOHEADER 	lpbi)
{
    DWORD *MaskPtr;

    if (lpbi == NULL || lpbi->biCompression != BI_BITFIELDS)
        return InvalidBI_BITFIELDS;

    MaskPtr = (DWORD *)&lpbi[1];

    /*
     * For 32-bit BI_BITFIELDS, we support
     * only the special cases 00RRGGBB and 00BBGGRR.
     */

    if( lpbi->biBitCount == 32 ) {
	if (MaskPtr[1] != 0x0000FF00U)
	    return InvalidBI_BITFIELDS;
	else if (MaskPtr[0] == 0x00FF0000U && MaskPtr[2] == 0x000000FFU)
	    return pRGB;
	else if (MaskPtr[0] == 0x000000FFU && MaskPtr[2] == 0x00FF0000U)
            return pBGR;
	else
	    return InvalidBI_BITFIELDS;
    }

#ifdef WIN32
    /*
     * For 16-bit BI_BITFIELDS, we support any legal
     * color arrangement, but RGB565 and RGB555 are
     * recognized as special since we have extra
     * fast assembler code for those cases.
     */

    else if( lpbi->biBitCount == 16 ) {
	int i ;
	if( MaskPtr[2] == 0x001f ) {
	    if( MaskPtr[0] == 0xf800 && MaskPtr[1] == 0x07e0 )
	    	return pRGB565 ;
	    else if( MaskPtr[0] == 0x7c00 && MaskPtr[1] == 0x03e00 )
	    	return pRGB555 ;
	}
	/*
	 * Generic case: First make sure that each mask is
	 * a 16-bit mask.
	 */

	if( (MaskPtr[0] | MaskPtr[1] | MaskPtr[2]) & ~0x0000ffff )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Masks must not overlap.
	 */

	if( (MaskPtr[0] & MaskPtr[1]) ||
	    (MaskPtr[0] & MaskPtr[2]) ||
	    (MaskPtr[1] & MaskPtr[2]) )
	    return InvalidBI_BITFIELDS ;

	/*
	 * Make sure each mask contains a contiguous
	 * sequence of 1's (or is 0).
	 */

	for( i=0 ; i<3 ; i++ ) {
	   DWORD v = MaskPtr[i] ;
	   if( (((v-1)|v)+1)&v )
	       return InvalidBI_BITFIELDS ;	
	}

	/*
	 * If we pass all these tests, we have
	 * a valid generic 16-bit BI_BITFIELDS case.
	 */

	return pRGBnnn ;
    }

#endif /* WIN32 */

    /*
     * No other biBitCounts are supported.
     */

    return InvalidBI_BITFIELDS ;
}

/*********************** Conversion Routines ***************************/

static void sc_ExtractBlockNonInt(u_char *InData, float **OutData,
	   		          int ByteWidth, int x, int y)
{
  register int i,j;
  u_char *Inp, *IStart = InData + 8*y*ByteWidth + 8*x;

  for (i = 0 , Inp = IStart ; i < 8 ; i++ , Inp += ByteWidth)
    for (j = 0 ; j < 8 ; j++)
      *((*OutData)++) = (float)((int)(*Inp++) - 128);
}


/*
** Name:     ScConvertSepYUVToOther
** Purpose:  Convert Seperated YUV 422 to another format
**
*/
ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				  BITMAPINFOHEADER *OutBmh,
				  u_char *OutImage,
				  u_char *YData, u_char *CbData, u_char *CrData)
{
    /*
    ** no need to do extensive checking, DecompressBegin and CompressBegin
    ** should take care of static checking (eg. valid output colorspace
    */


    /*
    ** Are we converting from SepYUV to RGB ?
    */
    if ((OutBmh->biCompression == BI_RGB)              ||
        (OutBmh->biCompression == BI_BITFIELDS)        ||
        (OutBmh->biCompression == BI_DECXIMAGEDIB) ||
	(OutBmh->biCompression == BI_DECSEPRGBDIB)) {
        /*
	** It is assumed that YUV is subsampled 4:2:2, we will need to
	** generalize the code below to handle other cases as well -- VB
	*/
        if (InBmh->biBitCount == 8)
	  ScYuv422ToRgb (OutBmh, YData, NULL, NULL, OutImage);
        else
	  ScYuv422ToRgb (OutBmh, YData, CbData, CrData, OutImage);
    }
    /*
    ** Are we converting from SepYUV to Interlaced YUV ?
    */
    else if (IsYUV422Sep(OutBmh->biCompression))
    {
       /*
       ** It is assumed that YUV is subsampled 4:2:2, we will need to
       ** generalize the code below to handle other cases as well
       **   XXX - Bad idea to do this here, should be done as part of
       **         decompression (VB)
       **   XXX - While we can move the Sep YUV to 422 interleaved
       **         to decompression, we also need a copy here so we
       **         can use this as a general purpose dither'ing
       **         device. (JPL)
       */
       int i, j;

       /*
       ** If the input format is Mono JPEG and the output format is
       ** packed YUV422, we must reset the U and V values to neutral (Gray).
       */
       if (InBmh->biBitCount == 8) {
#ifdef __alpha
         /*
	  * If we're an Alpha, and the buffer is quadword
	  * aligned, we can use 64-bit transfers.
	  */
         if( ((INT_PTR) OutImage & 0x7) == 0 )
	   {
	     _int64 val   = 0x7f007f007f007f00L ;
	     _int64 *iptr = (_int64 *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>2) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         else
#endif /* __alpha */
	   {
	     int val   = 0x7f007f00 ;
	     int *iptr = (int *) OutImage ;
	     for( i=(OutBmh->biWidth*abs(OutBmh->biHeight)>>1) ; i>0 ; i-- )
	       *iptr++ = val ;
	   }
         /*
	 ** Plug in the luminance samples
	 */
         for( i=(OutBmh->biWidth * abs(OutBmh->biHeight)) ; i>0 ; i-- ) {
           *OutImage = *YData++;
           OutImage +=2;
         }
       }
       /*
       ** Color input
       */
       else {
	 /* If this is quad padded in both X and Y and quad aligned,
	 ** we can call the assembly routine
	 */
	 if ( (abs(OutBmh->biHeight) & 0x7) == 0 &&
	     (OutBmh->biWidth & 0x7) == 0 &&
	     ((ULONG_PTR)OutImage & 0xf) == 0 )
	   {
	     ScConvert422PlanarTo422i(YData, CbData, CrData, OutImage,
				      OutBmh->biWidth, abs(OutBmh->biHeight));
	   }
	 else {
	   for (i=0; i<abs(OutBmh->biHeight); i++)
	     /* Remember, pixels are 16 bit in interleaved YUV. That
	     ** means the 4 bytes below represent two pixels so our
	     ** loop should be for half the width.
	     */
	     for (j=0; j<OutBmh->biWidth>>1; j++) {     /* Note: was j+=2 */
	       *OutImage++ = *YData++;
	       *OutImage++ = *CbData++;
	       *OutImage++ = *YData++;
	       *OutImage++ = *CrData++;
	     }
	 }
       }
    }
    else return(ScErrorUnrecognizedFormat);

    return(ScErrorNone);
}

/*
** Name:    ScYuv411ToRgb
** Purpose: convert 16-bit YCrCb 4:1:1 to an 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
*/
ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut, int Width, int Height, long stride)
{
   const int pixels = Width;
   int lines  = Height;
   register int row, col;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 2x2 matrix of pixels */
   int R1,R2,R3,R4;
   int G1,G2,G3,G4;
   int B1,B2,B3,B4;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y1=Y, *Y2=Y+pixels;
#define _LoadRGBfrom411() \
         R1 = R2 = R3 = R4 = (int) (              + (1.596 * V)); \
         G1 = G2 = G3 = G4 = (int) (- (0.391 * U) - (0.813 * V)); \
         B1 = B2 = B3 = B4 = (int) (+ (2.018 * U)              ); \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R1 += Luma; G1 +=Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y1++) - 16) * 1.164); \
         R2 += Luma; G2 +=Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         } \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R3 += Luma; G3 +=Luma; B3 += Luma; \
         Luma = (int) (((int) *(Y2++) - 16) * 1.164); \
         R4 += Luma; G4 +=Luma; B4 += Luma; \
         if ((R3 | G3 | B3 | R4 | G4 | B4) & 0xffffff00) { \
           if (R3<0) R3=0; else if (R3>255) R3=255; \
           if (G3<0) G3=0; else if (G3>255) G3=255; \
           if (B3<0) B3=0; else if (B3>255) B3=255; \
           if (R4<0) R4=0; else if (R4>255) R4=255; \
           if (G4<0) G4=0; else if (G4>255) G4=255; \
           if (B4<0) B4=0; else if (B4>255) B4=255; \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 16:
                {
                  u_short *Sout1 = (u_short *)ImageOut, *Sout2=Sout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Sout1 = (u_short *)ImageOut+tmp; /* For 16-bit */
                      Sout2=Sout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
#ifdef WIN95  /* RGB 565 - 16 bit */
		      *(Sout1++) = ((R1&0xf8)<<8)|((G1&0xfC)<<3)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<8)|((G2&0xfC)<<3)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<8)|((G3&0xfC)<<3)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<8)|((G4&0xfC)<<3)|((B4&0xf8)>>3);
#else /* RGB 555 - 15 bit */
		      *(Sout1++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout1++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
		      *(Sout2++) = ((R3&0xf8)<<7)|((G3&0xf8)<<2)|((B3&0xf8)>>3);
		      *(Sout2++) = ((R4&0xf8)<<7)|((G4&0xf8)<<2)|((B4&0xf8)>>3);
#endif
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout1, *Cout2;
                  stride*=3;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1) ;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Cout1 = (u_char *)(ImageOut + tmp); /* For 24-bit */
                      Cout2=Cout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
	              *(Cout1++) = (u_char)B1; *(Cout1++) = (u_char)G1; *(Cout1++) = (u_char)R1;
	              *(Cout1++) = (u_char)B2; *(Cout1++) = (u_char)G2; *(Cout1++) = (u_char)R2;
	              *(Cout2++) = (u_char)B3; *(Cout2++) = (u_char)G3; *(Cout2++) = (u_char)R3;
	              *(Cout2++) = (u_char)B4; *(Cout2++) = (u_char)G4; *(Cout2++) = (u_char)R4;
                    }
                    Y1=Y2;
                  }
                }
                break;
              case 32:
                {
                  unsigned dword *Wout1 = (unsigned dword *)ImageOut,
                                 *Wout2=Wout1+pixels;
                  for (row = 0; row < lines; row+=2)
                  {
                    if (Ups)
                    {
                      tmp = stride * (lines-row-1);
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1-stride;
                    }
                    else
                    {
                      tmp = stride * row;
                      Wout1 = (unsigned dword *)ImageOut + tmp;
                      Wout2=Wout1+stride;
                    }
                    Y2=Y1+pixels;
                    for (col = 0; col < pixels; col += 2)
                    {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                      _LoadRGBfrom411();
		      *(Wout1++) = (R1<<16) | (G1<<8) | B1;
		      *(Wout1++) = (R2<<16) | (G2<<8) | B2;
		      *(Wout2++) = (R3<<16) | (G3<<8) | B3;
		      *(Wout2++) = (R4<<16) | (G4<<8) | B4;
                    }
                    Y1=Y2;
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData1, *GData1, *BData1;
              u_char *RData2, *GData2, *BData2;
              RData1 = ImageOut;
              GData1 = RData1 + (pixels * lines);
              BData1 = GData1 + (pixels * lines);
              RData2 = RData1 + pixels;
              GData2 = GData1 + pixels;
              BData2 = BData1 + pixels;
              for (row = 0; row < lines; row+=2)
              {
                Y2=Y1+pixels;
                for (col = 0; col < pixels; col += 2)
                {
	          U = *Cb++ - 128;
	          V = *Cr++ - 128;
                  _LoadRGBfrom411();
		  *(RData1++) = (u_char)R1; *(RData1++) = (u_char)R2;
          *(RData2++) = (u_char)R3; *(RData2++) = (u_char)R4;
		  *(GData1++) = (u_char)G1; *(GData1++) = (u_char)G2;
		  *(GData2++) = (u_char)G3; *(GData2++) = (u_char)G4;
		  *(BData1++) = (u_char)B1; *(BData1++) = (u_char)B2;
		  *(BData2++) = (u_char)B3; *(BData2++) = (u_char)B4;
	        }
                RData1=RData2;
                RData2=RData1+pixels;
                Y1=Y2;
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout1 = (unsigned dword *)ImageOut,
                             *Iout2=Iout1+pixels;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (R1<<16) | (G1<<8) | B1;
                    *(Iout1++) = (R2<<16) | (G2<<8) | B2;
                    *(Iout2++) = (R3<<16) | (G3<<8) | B3;
                    *(Iout2++) = (R4<<16) | (G4<<8) | B4;
                  }
                  Y1=Y2;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=2)
                {
                  if (Ups)
                  {
                    tmp = stride * (lines-row-1);
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1-stride;
                  }
                  else
                  {
                    tmp = stride * row;
                    Iout1 = (unsigned dword *)ImageOut+tmp;  /* For 32-bit */
                    Iout2=Iout1+stride;
                  }
                  Y2=Y1+pixels;
                  for (col = 0; col < pixels; col += 2)
                  {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                    _LoadRGBfrom411();
                    *(Iout1++) = (B1<<16) | (G1<<8) | R1;
                    *(Iout1++) = (B2<<16) | (G2<<8) | R2;
                    *(Iout2++) = (B3<<16) | (G3<<8) | R3;
                    *(Iout2++) = (B4<<16) | (G4<<8) | R4;
                  }
                  Y1=Y2;
                }
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv1611ToRgb
** Purpose: convert 16-bit YCrCb 16:1:1 (YUV9/YVU9) to 16/24/32-bit RGB
**
** Note:    The code below is pixel based and is inefficient, we
**	    plan to replace faster assembly code
** This routine is used by Indeo, which actually only has 7-bits for
** Y, U and V components.  The 8th bits are ignored.
*/
ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   const int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
   register int row, col, i;
   register int Luma, U, V;
   /* Variables to hold R, G and B values for a 4x4 matrix of pixels */
   int R[16], G[16], B[16], tmpR, tmpG, tmpB, cR, cG, cB;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char  *Y0=Y, *Y1, *Y2, *Y3;
#define _LoadRGBfrom1611() \
         cR=(int) (             + (1.596 * V));\
	 cG=(int) (-(0.391 * U) - (0.813 * V));\
	 cB=(int) (+(2.018 * U)              );\
         for (i=0; i<4; i++) { \
	   Luma = (int) ((((int)(*Y0++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<8; i++) { \
	   Luma = (int) ((((int)(*Y1++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<12; i++) { \
	   Luma = (int) ((((int)(*Y2++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         } \
         for (; i<16; i++) { \
	   Luma = (int) ((((int)(*Y3++)<<1) - 16) * 1.164); \
           tmpR=cR + Luma; tmpG=cG + Luma; tmpB=cB + Luma; \
           if ((tmpR | tmpG | tmpB) & 0xffffff00) { \
             if (tmpR<0) R[i]=0; else if (tmpR>255) R[i]=255; else R[i]=tmpR; \
             if (tmpG<0) G[i]=0; else if (tmpG>255) G[i]=255; else G[i]=tmpG; \
             if (tmpB<0) B[i]=0; else if (tmpB>255) B[i]=255; else B[i]=tmpB; \
           } else { R[i]=tmpR; G[i]=tmpG; B[i]=tmpB; } \
         }

   /*
    * Normally, images are stored right side up, that is with the
    * first pixel in the buffer corresponding to the top left pixel
    * in the image.
    *
    * The Microsoft standard Device Independent bitmap formats BI_RGB and
    * BI_BITFIELD are stored with the lower left pixel first.  We view that
    * as upside down.
    *
    * Each format can also have a negative height, which also signifes
    * upside down.
    *
    * Since two negatives makes a positive, that means that BI_ formats with
    * negative height are right side up.
    */
   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS )
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** The assumption is that YCrCb are subsampled 4:1:1
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/4
   */
   switch (Bmh->biCompression)
   {
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 32-bit RGB */
            {
              unsigned dword *Iout0 = (unsigned dword *)ImageOut,
                             *Iout1, *Iout2, *Iout3;
              if (ValidateBI_BITFIELDS(Bmh) == pRGB)
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<8; i++)
                        *(Iout1++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<12; i++)
                        *(Iout2++) = (R[i]<<16) | (G[i]<<8) | B[i];
                      for (; i<16; i++)
                        *(Iout3++) = (R[i]<<16) | (G[i]<<8) | B[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
              else /* pBGR and XIMAGE 24-bit */
                for (row = 0; row < lines; row+=4)
                {
                  if (Ups) {
                    tmp = pixels * (lines-row-1) ;
                    Iout0 = (unsigned dword *)ImageOut+tmp;
                    Iout1=Iout0-pixels; Iout2=Iout1-pixels; Iout3=Iout2-pixels;
                  }
                  else {
                    Iout1=Iout0+pixels; Iout2=Iout1+pixels; Iout3=Iout2+pixels;
                  }
                  Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                  for (col = 0; col < pixels; col += 4)
                  {
                    if (*Cb & 0x80) /* if 8th bit is set, ignore */
                    {
                      for (i=0; i<4; i++) {
                        *(Iout0++) = 0;
                        *(Iout1++) = 0;
                        *(Iout2++) = 0;
                        *(Iout3++) = 0;
                      }
                      Cb++; Cr++;
                    }
                    else
                    {
	              U = ((*Cb++)<<1) - 128;
	              V = ((*Cr++)<<1) - 128;
                      _LoadRGBfrom1611();
                      for (i=0; i<4; i++)
                        *(Iout0++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<8; i++)
                        *(Iout1++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<12; i++)
                        *(Iout2++) = (B[i]<<16) | (G[i]<<8) | R[i];
                      for (; i<16; i++)
                        *(Iout3++) = (B[i]<<16) | (G[i]<<8) | R[i];
                    }
                  }
                  Iout0=Iout3;
                  Y0=Y3;
                }
            }
            break;
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout0 = (u_short *)ImageOut, *Sout1, *Sout2, *Sout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Sout0 = &((u_short *)ImageOut)[tmp];  /* For 32-bit */
                     Sout1=Sout0-pixels; Sout2=Sout1-pixels; Sout3=Sout2-pixels;
                    }
                    else {
                     Sout1=Sout0+pixels; Sout2=Sout1+pixels; Sout3=Sout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4; i++) {
                          *(Sout0++) = 0;
                          *(Sout1++) = 0;
                          *(Sout2++) = 0;
                          *(Sout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                          *(Sout0++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<8; i++)
                          *(Sout1++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<12; i++)
                          *(Sout2++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                        for (; i<16; i++)
                          *(Sout3++)=
                             ((R[i]&0xf8)<<7)|((G[i]&0xf8)<<2)|((B[i]&0xf8)>>3);
                      }
                    }
                    Sout0=Sout3;
                    Y0=Y3;
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout0 = (u_char *)ImageOut, *Cout1, *Cout2, *Cout3;
                  for (row = 0; row < lines; row+=4)
                  {
                    if (Ups) {
                     tmp = pixels * (lines-row-1) ;
                     Cout0 = &((u_char *)ImageOut)[tmp*3];  /* For 32-bit */
                     Cout1=Cout0-pixels; Cout2=Cout1-pixels; Cout3=Cout2-pixels;
                    }
                    else {
                     Cout1=Cout0+pixels; Cout2=Cout1+pixels; Cout3=Cout2+pixels;
                    }
                    Y1=Y0+pixels; Y2=Y1+pixels; Y3=Y2+pixels;
                    for (col = 0; col < pixels; col += 4)
                    {
                      if (*Cb & 0x80) /* if 8th bit is set, ignore */
                      {
                        for (i=0; i<4*3; i++) {
                          *(Cout0++) = 0;
                          *(Cout1++) = 0;
                          *(Cout2++) = 0;
                          *(Cout3++) = 0;
                        }
                        Cb++; Cr++;
                      }
                      else
                      {
	                U = ((*Cb++)<<1) - 128;
	                V = ((*Cr++)<<1) - 128;
                        _LoadRGBfrom1611();
                        for (i=0; i<4; i++)
                        { *(Cout0++)=(u_char)B[i]; *(Cout0++)=(u_char)G[i]; *(Cout0++)=(u_char)R[i]; }
                        for (; i<8; i++)
                        { *(Cout1++)=(u_char)B[i]; *(Cout1++)=(u_char)G[i]; *(Cout1++)=(u_char)R[i]; }
                        for (; i<12; i++)
                        { *(Cout2++)=(u_char)B[i]; *(Cout2++)=(u_char)G[i]; *(Cout2++)=(u_char)R[i]; }
                        for (; i<16; i++)
                        { *(Cout3++)=(u_char)B[i]; *(Cout3++)=(u_char)G[i]; *(Cout3++)=(u_char)R[i]; }
                      }
                    }
                    Cout0=Cout3;
                    Y0=Y3;
                  }
                }
                break;
            }
            break;
        default:
            return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}


/*
** Name:    ScYuv422ToRgb
** Purpose: convert 16-bit YCrCb 4:2:2 to an 24-bit/16-bit/32-bit RGB
**
** Note:    The code below is pixel based and is *extremely* inefficient, we
**	    plan to replace the dumb code below with some fast code
** If Cb==NULL and Cr==NULL then assume BI_DECGRAYDIB (use only Y component).
*/
ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
			u_char *Cr, u_char *ImageOut)
{
   register int row, col;
   register int Luma,U=0,V=0;
   int R1,R2, G1,G2, B1,B2;
   int Ups = 0, tmp;			/* Flip image upside down */
   u_char *RData, *GData, *BData;	/* pointers for non-interlaced mode */
   u_char  *Cout = (u_char *)ImageOut;
   u_short *Sout = (u_short *)ImageOut;
   u_int   *Iout = (u_int *)ImageOut;
   int pixels = Bmh->biWidth;
   int lines  = Bmh->biHeight;
#ifdef NEW_YCBCR
#define _LoadRGBfrom422() \
         if (U || V) { \
           R1 = R2 = (int) (              + (1.596 * V)); \
           G1 = G2 = (int) (- (0.391 * U) - (0.813 * V)); \
           B1 = B2 = (int) (+ (2.018 * U)              );  \
         } else { R1=R2=G1=G2=B1=B2=0; } \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R1 += Luma; G1 += Luma; B1 += Luma; \
	 Luma = (int) (((int) *(Y++) - 16) * 1.164); \
         R2 += Luma; G2 += Luma; B2 += Luma; \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#else
#define _LoadRGBfrom422() \
	 Luma = *(Y++); \
         R1 = Luma                + (1.4075 * V); \
         G1 = Luma - (0.3455 * U) - (0.7169 * V); \
         B1 = Luma + (1.7790 * U); \
	 Luma = *(Y++); \
         R2 = Luma                + (1.4075 * V); \
         G2 = Luma - (0.3455 * U) - (0.7169 * V); \
         B2 = Luma + (1.7790 * U); \
         if ((R1 | G1 | B1 | R2 | G2 | B2) & 0xffffff00) { \
           if (R1<0) R1=0; else if (R1>255) R1=255; \
           if (G1<0) G1=0; else if (G1>255) G1=255; \
           if (B1<0) B1=0; else if (B1>255) B1=255; \
           if (R2<0) R2=0; else if (R2>255) R2=255; \
           if (G2<0) G2=0; else if (G2>255) G2=255; \
           if (B2<0) B2=0; else if (B2>255) B2=255; \
         }
#endif /* NEW_YCBCR */

   /*
    * Normally, images are stored right side up,
    * that is with the first pixel in the buffer
    * corresponding to the top left pixel in the image.
    *
    * The Microsoft standard Device Independent bitmap
    * formats BI_RGB and BI_BITFIELD are stored with
    * the lower left pixel first.
    * We view that as upside down.
    *
    * Each format can also have a negative height,
    * which also signifes upside down.
    *
    * Since two negatives makes a positive, that means
    * that BI_ formats with a negative height are right side up.
    */

   if( Bmh->biCompression == BI_RGB ||
       Bmh->biCompression == BI_BITFIELDS)
       Ups = 1 ;

   if( lines < 0 ) {
      Ups = 1-Ups ;
      lines = -lines ;
   }

   /*
   ** needed if the three components are to be provided in a
   ** non-interlaced mode:
   */
   if (Bmh->biCompression == BI_DECSEPRGBDIB) {
      RData = ImageOut;
      GData = RData + (pixels * lines);
      BData = GData + (pixels * lines);
   }


   /*
   ** The assumption is that YCrCb are subsampled 4:2:2
   **	YSize           = lines * pixels
   **   CbSize = CrSize = (lines*pixels)/2
   */
   switch (Bmh->biCompression)
   {
      case BI_RGB:
            switch (Bmh->biBitCount)
            {
              case 15:
              case 16:
                {
                  u_short *Sout = (u_short *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Sout = &((u_short *)ImageOut)[tmp]; /* For 16-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Sout++) = ((R1&0xf8)<<7)|((G1&0xf8)<<2)|((B1&0xf8)>>3);
		      *(Sout++) = ((R2&0xf8)<<7)|((G2&0xf8)<<2)|((B2&0xf8)>>3);
                    }
                  }
                }
                break;
              case 24:
                {
                  u_char *Cout = (u_char *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Cout = &((u_char *)ImageOut)[3*tmp]; /* For 24-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
	              *(Cout++) = (u_char)B1; *(Cout++) = (u_char)G1; *(Cout++) = (u_char)R1;
	              *(Cout++) = (u_char)B2; *(Cout++) = (u_char)G2; *(Cout++) = (u_char)R2;
                    }
                  }
                }
                break;
              case 32:
                {
                  u_int *Iout = (u_int *)ImageOut;
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp]; /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
		      *(Iout++) = (R1<<16) | (G1<<8) | B1 ;
		      *(Iout++) = (R2<<16) | (G2<<8) | B2 ;
                    }
                  }
                }
                break;
            }
            break;
      case BI_DECSEPRGBDIB: /* 24-bit separate RGB */
            {
              u_char *RData, *GData, *BData;
              RData = ImageOut;
              GData = RData + (pixels * lines);
              BData = GData + (pixels * lines);
              for (row = 0; row < lines; row++)
              {
                for (col = 0; col < pixels; col += 2)
                {
                  if (Cb) {
	            U = *Cb++ - 128;
	            V = *Cr++ - 128;
                  }
                  _LoadRGBfrom422();
		  *(RData++) = (u_char)R1; *(RData++) = (u_char)R2;
		  *(GData++) = (u_char)G1; *(GData++) = (u_char)G2;
		  *(BData++) = (u_char)B1; *(BData++) = (u_char)B2;
	        }
              }
            }
            break;
      case BI_DECXIMAGEDIB:  /* XIMAGE 24 == pBGR */
      case BI_BITFIELDS: /* 16 or 32-bit RGB */
            switch (Bmh->biBitCount)
            {
	    case 16:
	      {	/* 16-bit BI_BITFIELDS, hardcoded to RGB565 */
		u_short *Sout = (u_short *)ImageOut;
                for (row = 0; row < lines; row++)
                {
                  if (Ups)
                  {
                    tmp = pixels * (lines-row-1) ;
                    Sout = &((u_short *)ImageOut)[tmp];  /* For 16-bit */
                  }
                  for (col = 0; col < pixels; col += 2)
                  {
                    if (Cb) {
	              U = *Cb++ - 128;
	              V = *Cr++ - 128;
                    }
                    _LoadRGBfrom422();
                    *(Sout++) = ((R1<<8) & 0xf800) | ((G1<<3) & 0x07e0) | ((B1>>3) & 0x01f);
                    *(Sout++) = ((R2<<8) & 0xf800) | ((G2<<3) & 0x07e0) | ((B2>>3) & 0x01f);
                  }
                }
	      }
	      break ;
	    case 24:
	    case 32:
	      { /* 32-bit RGB */
                u_int *Iout = (u_int *)ImageOut;
                if (ValidateBI_BITFIELDS(Bmh) == pRGB)
		{
                  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (R1<<16) | (G1<<8) | B1;
                      *(Iout++) = (R2<<16) | (G2<<8) | B2;
                    }
                  }
		}
                else /* pBGR and XIMAGE 24-bit */
                {
		  for (row = 0; row < lines; row++)
                  {
                    if (Ups)
                    {
                      tmp = pixels * (lines-row-1) ;
                      Iout = &((u_int *)ImageOut)[tmp];  /* For 32-bit */
                    }
                    for (col = 0; col < pixels; col += 2)
                    {
                      if (Cb) {
	                U = *Cb++ - 128;
	                V = *Cr++ - 128;
                      }
                      _LoadRGBfrom422();
                      *(Iout++) = (B1<<16) | (G1<<8) | R1;
                      *(Iout++) = (B2<<16) | (G2<<8) | R2;
                    }
                  }
		}	
	      }
	      break;
	    }
            break;
       default:
	    return(ScErrorUnrecognizedFormat);
   }
   return (NoErrors);
}

/*
** Name: ScInitRgbToYuv
** Purpose: Initializes tables for RGB to YUV conversion.
**
** Notes:
**
**	The tables are allocated and filled in once the first
**	time they are needed. They will remin for the lifetime
**	of the server.
**
**	The following formula is used:
**
**	y =  0.257 * r + 0.504 * g + 0.098 * b +  16 ; /+  16 - 235 +/
**	u = -0.148 * r - 0.291 * g + 0.439 * b + 128 ; /+  16 - 239 +/
**	v =  0.439 * r - 0.368 * g - 0.071 * b + 128 ; /+  16 - 239 +/
**
**	But we rewrite it thus:
**
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
**
**    ( By the way, the old constants are:				     )
**    ( y = r *  0.299 + g *  0.587 + b *  0.114        ;		     )
**    ( u = r * -0.169 + g * -0.332 + b *  0.500  + 128 ;		     )
**    ( v = r *  0.500 + g * -0.419 + b * -0.0813 + 128 ;		     )
**    ( or								     )
**    ( y =  0.0    + 0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
**
**	This particular arrangement of the formula allows Y, U and V values
**	to be calculated in paralell by simple table lookup.
**	The paralellism comes from the fact that Y,U and V values
**	are stored in the same word, but in different bytes.
**	The tables are such that the contribution from red, green
**	and blue can simply be added together, without any carry
**	between bytes. Since the YUV space is larger than the RGB
**	cube, and the RGB cube fits entirely within YUV space,
**	there is no overflow and no range checking is needed.
**
*/

#ifdef NEW_YCBCR
/*
**	y = 16.000 + 0.257 * r       + 0.504 * g       + 0.098 * b       ;
**	u = 16.055 + 0.148 * (255-r) + 0.291 * (255-g) + 0.439 * b       ;
**	v = 16.055 + 0.439 * r       + 0.368 * (255-g) + 0.071 * (255-b) ;
*/
#define YC 16.000
#define UC 16.055
#define VC 16.055
#define YR  0.257
#define UR  0.148
#define VR  0.439
#define YG  0.504
#define UG  0.291
#define VG  0.368
#define YB  0.098
#define UB  0.439
#define VB  0.071

#else /* !NEW_YCBCR */
/*
**    ( y =  0.0      0.299 * r       + 0.587 * g       + 0.1140 * b       ; )
**    ( u =  0.245  + 0.169 * (255-r) + 0.332 * (255-g) + 0.5000 * b       ; )
**    ( v =  0.4235 + 0.500 * r       + 0.419 * (255-g) + 0.0813 * (255-b) ; )
*/
#define YC 0.0
#define UC 0.245
#define VC 0.4235
#define YR 0.299
#define UR 0.169
#define VR 0.500
#define YG 0.587
#define UG 0.332
#define VG 0.419
#define YB 0.1140
#define UB 0.5000
#define VB 0.0813

#endif /* !NEW_YCBCR */

/*
 * We only need an int (32 bits) per table entry but
 * 64-bit aligned access is faster on alpha.
 */

#ifdef __alpha
_int64 *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#else /* !__alpha */
unsigned int *RedToYuyv, *GreenToYuyv, *BlueToYuyv ;
#endif /* !__alpha */

int ScInitRgbToYuv()
{
  int i, y, u, v ;

  if( RedToYuyv == NULL ) {
#ifdef __alpha
    RedToYuyv   = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    GreenToYuyv = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
    BlueToYuyv  = (_int64 *) ScAlloc( 256 * sizeof( _int64 ) ) ;
#else /* !__alpha */
    RedToYuyv   = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    GreenToYuyv = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
    BlueToYuyv  = (unsigned int *) ScAlloc( 256 * sizeof( unsigned int ) ) ;
#endif /* !__alpha */

    if( !RedToYuyv || !GreenToYuyv || !BlueToYuyv )
      return 0 ;

    for( i=0 ; i<256 ; i++ ) {

      /*
       * Calculate contribution from red.
       * We will also add in the constant here.
       * Pack it into the tables thus: lsb->YUYV<-msb
       */

      y = (int) (YC + YR * i) ;
      u = (int) (UC + UR * (255-i)) ;
      v = (int) (VC + VR * i) ;
      RedToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from green.
       */

      y = (int) (YG * i) ;
      u = (int) (UG * (255-i)) ;
      v = (int) (VG * (255-i)) ;
      GreenToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

      /*
       * Calculate contribution from blue.
       */

      y = (int) (YB * i) ;
      u = (int) (UB * i) ;
      v = (int) (VB * (255-i)) ;
      BlueToYuyv[i] = (y | (u<<8) | (y<<16) | (v<<24)) ;

    }
  }
  return 1 ;
}

/*
** Name:    ScConvertRGB24sTo422i_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh, u_char *R, u_char *G,
                                   u_char *B, u_short *ImageOut)
{
   register int row, col;
   int yuyv,r,g,b;
   int pixels = Bmh->biWidth;
   int lines  = abs(Bmh->biHeight);

   if( !RedToYuyv && !ScInitRgbToYuv() )
     return ScErrorMemory ;

   for (row = 0; row < lines; row++) {
      for (col = 0; col < pixels; col++) {
        r = *(R++); g = *(G++); b = *(B++);

	/*
	 * Quick convert to YUV.
	 */

	yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;

        /*
         * Pack 4:2:2 = YUYV YUYV ...
	 * We'll pack YU or YV depending on whether col is odd or not.
	 * Shift yuyv 0 for even, 16 for odd columns.
         */

	*(ImageOut++) = yuyv >> ((col & 1) << 4) ;

      }
    }
    return (NoErrors);
}

#define M_RND(f) ((int) ((f) + .5))

/*
** Name:    ScConvertRGB24To411s_C
** Purpose: convert 24-bit RGB (8:8:8 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                                  u_char *Y, u_char *U, u_char *V,
                                  int width, int height)
{
  register int row, col;
  int yuyv, r, g, b;
  u_char *tmp, *evl, *odl;

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    for (row = height-1; row; row--)
    {
      tmp = inimage+(width*row*3);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-(width*3);
      }
      else
      {
        evl = tmp;
        odl = tmp-(width*3);
      }
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    tmp = inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        r = *tmp++;
        g = *tmp++;
        b = *tmp++;
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          r = *evl++ + *odl++;
          g = *evl++ + *odl++;
          b = *evl++ + *odl++;
          r += (*evl++ + *odl++);
          g += (*evl++ + *odl++);
          b += (*evl++ + *odl++);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB555To411s_C
** Purpose: convert 16-bit RGB (5:5:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB555(in16, r, g, b) b = (inpixel>>7)&0xF8; \
                                 g = (inpixel>>2)&0xF8; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB555(in16, r, g, b) b += (inpixel>>7)&0xF8; \
                                 g += (inpixel>>2)&0xF8; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB555(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB555(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB555(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScConvertRGB565To411s_C
** Purpose: convert 16-bit RGB (5:6:5 format) to 16-bit YCrCb (4:1:1 format)
*/
ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                  int width, int height)
{
  u_char *Y=outimage, *U, *V;
  register int row, col, inpixel;
  int yuyv, r, g, b;
  unsigned word *tmp, *evl, *odl;

#define GetRGB565(in16, r, g, b) b = (inpixel>>8)&0xF8; \
                                 g = (inpixel>>3)&0xFC; \
                                 r = (inpixel<<3)&0xF8

#define AddRGB565(in16, r, g, b) b += (inpixel>>8)&0xF8; \
                                 g += (inpixel>>3)&0xFC; \
                                 r += (inpixel<<3)&0xF8

  if( !RedToYuyv && !ScInitRgbToYuv() )
    return(ScErrorMemory);
  if (height<0) /* flip image */
  {
    height = -height;
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    for (row = height-1; row; row--)
    {
      tmp = ((unsigned word *)inimage)+(width*row);
      if (row & 1)
      {
        odl = tmp;
        evl = tmp-width;
      }
      else
      {
        evl = tmp;
        odl = tmp-width;
      }
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  else
  {
    U=Y+(width*height);
    V=U+(width*height*1)/4;
    tmp = (unsigned word *)inimage;
    for (row = 0; row < height; row++)
    {
      if (row & 1)
        odl = tmp;
      else
        evl = tmp;
      for (col = 0; col < width; col++)
      {
        inpixel=*tmp++;
        GetRGB565(inpixel, r, g, b);
        yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
        *Y++ = (yuyv&0xff);

        /* We only store every fourth value of u and v components */
        if ((col & 1) && (row & 1))
        {
          /* Compute average r, g and b values */
          inpixel=*evl++;
          GetRGB565(inpixel, r, g, b);
          inpixel=*evl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          inpixel=*odl++;
          AddRGB565(inpixel, r, g, b);
          r = r >> 2;
          g = g >> 2;
          b = b >> 2;

          yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]);
          *U++ = ((yuyv&0xff000000) >> 24);       // V
          *V++ = ((yuyv&0xff00) >> 8);            // U
        }
      }
    }
  }
  return (NoErrors);
}

/*
** Name:    ScRgbInterlToYuvInterl
** Purpose: convert many RGB formats to 16-bit YCrCb (4:2:2 format)
*/
ScStatus_t ScRgbInterlToYuvInterl (
    LPBITMAPINFOHEADER Bmh,
    int Width,
    int Height,
    u_char *ImageIn,
    u_short *ImageOut)
{
    register int row, col;
    int yuyv,r,g,b,mask=0x00ff;
    int pixels = Width;
    int lines  = abs(Height);
    int IspBGR = (ValidateBI_BITFIELDS(Bmh) == pBGR) ||
         (Bmh->biCompression==BI_DECXIMAGEDIB && Bmh->biBitCount==24);
    int IspRGB_BI_RGB_24 = (Bmh->biCompression==BI_RGB && Bmh->biBitCount==24);
    int linestep = 0 ;

    if( !RedToYuyv && !ScInitRgbToYuv() )
      return ScErrorMemory ;

    /*
     * Check the input format and decide
     * whether the image is to be turned
     * upside down or not.
     */

    if( (Bmh->biCompression == BI_RGB ||
    	 Bmh->biCompression == BI_BITFIELDS) ^
	((int) Bmh->biHeight < 0) ) {
	ImageOut = &ImageOut[ pixels * (lines - 1) ] ;
	linestep = -(pixels << 1) ;
    }

    /*
     * To avoid if-then-else statements inside
     * the inner loop, we have 3 loops.
     */

    /*
     * 24 bits per pixel RGB.
     */

    if (IspRGB_BI_RGB_24) {

      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *(ImageIn++);
	  g = *(ImageIn++);
	  r = *(ImageIn++);

	  /*
	   * Quick convert from RGB to YUV. Just add together
	   * the contributions from each of Red, Green and Blue.
	   */

	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	
	  /*
	   * Pack 4:2:2 = YUYV YUYV ...
	   * We'll pack YU or YV depending on whether col is odd or not.
	   * Shift yuyv 0 for even, 16 for odd columns.
	   */
	
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;

	}
	/*
	 * In case we're turning the image upside down.
	 * This will do nothing if it's right side up.
	 */
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0BGR.
     */
    else if (IspBGR) {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  r = *((int *) ImageIn)++ ;
	  b = (r>>16) & mask ;
	  g = (r>> 8) & mask ;
	  r &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }
    /*
     * 32 bits per pixels 0RGB.
     */
    else {
      for (row = 0; row < lines; row++) {
	for (col = 0; col < pixels; col++) {
	  b = *((int *) ImageIn)++ ;
	  r = (b>>16) & mask ;
	  g = (b>> 8) & mask ;
	  b &= mask ;
	  yuyv = (int) (RedToYuyv[r] + GreenToYuyv[g] + BlueToYuyv[b]) ;
	  *(ImageOut++) = yuyv >> ((col & 1) << 4) ;
	}
	ImageOut = &ImageOut[linestep] ;
      }
    }

    return (NoErrors);
}


/*
** Function: ScConvert422ToYUV_char_C
** Purpose:  Extract the Y, U and V components into separate planes.
**           The interleaved format is YUYV, 4:2:2, we want 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;

  Width/=2;
  Height=abs(Height)/2;
  for (y = 0; y < Height; y++)
  {
    for (x = 0 ; x < Width; x++)
    {
      *Y++ = *RawImage++;
      *U++ = *RawImage++;
      *Y++ = *RawImage++;
      *V++ = *RawImage++;
    }
    for (x = 0; x < Width; x++)
    {
      *Y++ = *RawImage;
      RawImage+=2;
      *Y++ = *RawImage;
      RawImage+=2;
    }
 }
 return (NoErrors);
}

/*
** Function: ScConvert422PlanarTo411_C
** Purpose:  Extract the Y, U and V components from (4:2:2)
**           planes and convert to 4:1:1 so,
**           only copy every other line of the chrominance
*/
ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RY, *RU, *RV;
  RY=RawImage;
  RU=RY+(Width*Height);
  RV=RU+(Width*Height/2);

  Height=abs(Height);
  memcpy(Y, RawImage, Width*Height);
  for (y = Height/2; y > 0; y--)
  {
    memcpy(U, RU, HalfWidth);
    memcpy(V, RV, HalfWidth);
    U+=HalfWidth;
    V+=HalfWidth;
    RU+=Width; /* skip odd U and V lines */
    RV+=Width;
 }
 return (NoErrors);
}

/*
** C versions of block-extraction routines. To be replaced by ASM
*/
void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
			    float *Comp1, float *Comp2, float *Comp3,
			    int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int UBlocks    = Width/16;
  int VBlocks    = Width/16;
  int ByteWidth  = Width*2;
  u_char *I1 = RawImage;
  u_char *I2 = I1 + Width*abs(Height);
  u_char *I3 = I2 + Width*abs(Height)/2;
  float *C1 = Comp1, *C2 = Comp2, *C3 = Comp3;

  for (y = 0 ; y < VertBlocks ; y++) {
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
    for (x = 0 ; x < UBlocks ; x++)
      sc_ExtractBlockNonInt(I2, &C2, ByteWidth, x, y);
    for (x = 0 ; x < VBlocks ; x++)
      sc_ExtractBlockNonInt(I3, &C3, ByteWidth, x, y);
  }
}

void ScConvertGrayToBlock (u_char *RawImage, int bpp,
		       float *Comp1, int Width, int Height)
{
  int x,y;
  int VertBlocks = abs(Height)/8;
  int YBlocks    = Width/8;
  int ByteWidth  = Width;
  u_char *I1 = RawImage;
  float *C1 = Comp1;

  for (y = 0 ; y < VertBlocks ; y++)
    for (x = 0 ; x < YBlocks ; x++)
      sc_ExtractBlockNonInt(I1, &C1, ByteWidth, x, y);
}


/*
** Function: ScSepYUVto422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height)
{
  /* need C code for this */
  return(0);
}

/*
** Function: ScConvert422PlanarTo422i_C
** Purpose:  Convert a 4:2:2 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *OutImage,
				     long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *OutImage++ = *Y++;
       *OutImage++ = *Cb++;
       *OutImage++ = *Y++;
       *OutImage++ = *Cr++;
    }
  }
}

/*
** Function: ScConvert422iTo422s_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *U, u_char *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = *InImage++;
       *U++ = *InImage++;
       *Y++ = *InImage++;
       *V++ = *InImage++;
    }
  }
}

/*
** Function: ScConvert422iTo422sf_C
** Purpose:  Convert a 4:2:2 YUV interleaved to 4:2:2 planar.
*/
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V,
                                  long width, long height)
{
  int i, j;
  height=abs(height);
  width=width>>1;
  for (i=0; i<height; i++)
  {
    /* Remember, pixels are 16 bit in interleaved YUV. That
     ** means the 4 bytes below represent two pixels so our
     ** loop should be for half the width.
     */
    for (j=0; j<width; j++)
    {
       *Y++ = (float)*InImage++;
       *U++ = (float)*InImage++;
       *Y++ = (float)*InImage++;
       *V++ = (float)*InImage++;
    }
  }
}

/*
** Function: ScConvert411sTo422i_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p422e, *p422o, *Yo=Y+width;
  int i, j;
  height=abs(height)/2;
  p422e=OutImage;
  p422o=OutImage+width*2;

  for (i=0; i<height; i++)
  {
    for (j=0; j<width; j+=2)
    {
      *p422e++ = *Y++;
      *p422e++ = *Cb;
      *p422e++ = *Y++;
      *p422e++ = *Cr;
      *p422o++ = *Yo++;
      *p422o++ = *Cb++;
      *p422o++ = *Yo++;
      *p422o++ = *Cr++;
    }
    p422e=p422o;
    p422o=p422e+width*2;
    Y=Yo;
    Yo=Y+width;
  }
}

/*
** Function: ScConvert411sTo422s_C
** Purpose:  Convert a 4:1:1 YUV image in separate-component form to its
**           equivalent interleaved 4:2:2 form.
*/
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
                                  u_char *Cr, u_char *OutImage,
                                  long width, long height)
{
  u_char *p411, *p422e, *p422o;
  int i, j;
  height=abs(height);

  if (OutImage!=Y)
    memcpy(OutImage, Y, width*height); /* copy Y components */
  p411=Cb+((height/2)-1)*(width/2);
  p422e=OutImage+((height*width*3)/2)-width; /* U component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
  p411=Cr+((height/2)-1)*(width/2);
  p422e=OutImage+(height*width*2)-width; /* V component */
  p422o=p422e+(width/2);
  for (i=0; i<height; i+=2)
  {
    for (j=0; j<width; j+=2, p411++, p422e++, p422o++)
      *p422e=*p422o=*p411;
    p411-=width;
    p422o=p422e-width;
    p422e=p422o-(width/2);
  }
}

/*
** Name:    ScConvert1611sTo411s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:1:1
*/
ScStatus_t ScConvert1611sTo411s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y++)
  {
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU;
      *U++ = *RU++;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV;
      *V++ = *RV++;
 }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422s_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to YCrCb 4:2:2
*/
ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *RU, *RV;
  unsigned char *Uo, *Vo;
  int pixels = Width * abs(Height), tmp;

  tmp = pixels / 16;
  RU=inimage+pixels;
  RV=RU+tmp;

  memcpy(Y, inimage, pixels);
  for (y = Height/32; y>0; y--)
  {
    Vo=V+Width;
    Uo=U+Width;
    for (x = Width/4; x > 0; x--)
    {
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU;
      *U++ = *Uo++ = *RU++;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV;
      *V++ = *Vo++ = *RV++;
    }
    V=Vo; U=Uo;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert1611sTo422i_C
** Purpose: convert a YCrCb 16:1:1 (YUV9/YVU9) to 4:2:2 interleaved
*/
ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                  int Width, int Height)
{
  register int x, y;
  const int HalfWidth=Width/2;
  unsigned char *Ye, *Yo, *Ye2, *Yo2, *RU, *RV;
  unsigned char *o1, *e1, *o2, *e2;
  unsigned char U, V;

  RU=inimage+Width*abs(Height);
  RV=RU+(Width*abs(Height))/16;

  e1=outimage;
  Ye=inimage;
  for (y = abs(Height)/4; y>0; y--)
  {
    Yo=Ye+Width;
    Ye2=Yo+Width;
    Yo2=Ye2+Width;
    o1=e1+Width*2;
    e2=o1+Width*2;
    o2=e2+Width*2;
    for (x = Width/4; x > 0; x--)
    {
      U = *RU++;
      V = *RV++;
      /* even line */
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      *e1++ = *Ye++;
      *e1++ = U;
      *e1++ = *Ye++;
      *e1++ = V;
      /* odd line */
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      *o1++ = *Yo++;
      *o1++ = U;
      *o1++ = *Yo++;
      *o1++ = V;
      /* even line */
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      *e2++ = *Ye2++;
      *e2++ = U;
      *e2++ = *Ye2++;
      *e2++ = V;
      /* odd line */
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
      *o2++ = *Yo2++;
      *o2++ = U;
      *o2++ = *Yo2++;
      *o2++ = V;
    }
    e1=o2;
    Ye=Yo2;
  }
 return (NoErrors);
}

/*
** Name:    ScConvert411sTo1611s_C
** Purpose: convert a YCrCb 4:1:1 to YCrCb 16:1:1 (YUV9/YVU9)
*/
ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height)
{
  register int x, y, c0, c1, c2, c3;
  unsigned char *Ue, *Uo, *Ve, *Vo;
  int pixels = Width * abs(Height), tmp;
  Width/=2;
  tmp = pixels / 4;
  Ue=inimage+pixels;
  Uo=Ue+Width;
  Ve=Ue+tmp;
  Vo=Ve+Width;

  memcpy(Y, inimage, pixels);
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ue++;
      c1=*Ue++;
      c2=*Uo++;
      c3=*Uo++;
      *U++ = (c0+c1+c2+c3)/4;
    }
    Ue=Uo;
    Uo+=Width;
  }
  for (y = 0; y < tmp; y+=2)
  {
    for (x=0; x<Width; x+=2)
    {
      c0=*Ve++;
      c1=*Ve++;
      c2=*Vo++;
      c3=*Vo++;
      *V++ = (c0+c1+c2+c3)/4;
    }
    Ve=Vo;
    Vo+=Width;
  }
  return (NoErrors);
}

/*
** Function: ScConvertNTSCtoCIF422()
** Purpose:  Convert a Q/CIF frame from a 4:2:2 NTSC input.  We dup every 10th
**           pixel horizontally and every 4th line vertically.  We also
**           discard the chroma on every other line, since CIF wants 4:1:1.
*/
ScStatus_t ScConvertNTSC422toCIF411_C(u_char *framein,
                         u_char *yp, u_char *up, u_char *vp,
                         int stride)
{
  int h, w;

  int vdup = 5;
  for (h = 0; h < 240; ++h)
  {
    int hdup = 10/2;
    for (w = 320; w > 0; w -= 2)
    {
      yp[0] = framein[0];
      yp[1] = framein[2];
      yp += 2;
      if ((h & 1) == 0)
      {
        *up++ = framein[1];
        *vp++ = framein[3];
      }
      framein += 4;
      if (--hdup <= 0)
      {
        hdup = 10/2;
        yp[0] = yp[-1];
        yp += 1;
        if ((h & 1) == 0)
        {
          if ((w & 2) == 0)
          {
            up[0] = up[-1];
            ++up;
            vp[0] = vp[-1];
            ++vp;
          }
        }
      }
    }
    if (--vdup <= 0)
    {
      vdup = 5;
      /* copy previous line */
      memcpy((char*)yp, (char*)yp - stride, stride);
      yp += stride;
      if ((h & 1) == 0)
      {
        int s = stride >> 1;
        memcpy((char*)up, (char*)up - s, s);
        memcpy((char*)vp, (char*)vp - s, s);
        up += s;
        vp += s;
      }
    }
  }
  return (NoErrors);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC.h,v $
 * Revision 1.1.8.10  1996/12/03  23:15:11  Hans_Graves
 * 	Added ScBSBufferedBytes() macros.
 * 	[1996/12/03  23:11:06  Hans_Graves]
 *
 * Revision 1.1.8.9  1996/11/13  16:10:47  Hans_Graves
 * 	Addition of ScBitstreamSave_t.
 * 	[1996/11/13  15:58:26  Hans_Graves]
 * 
 * Revision 1.1.8.8  1996/11/08  21:50:36  Hans_Graves
 * 	Protos fixed for use with C++. Added bitstream protos for AC3.
 * 	[1996/11/08  21:17:23  Hans_Graves]
 * 
 * Revision 1.1.8.7  1996/10/28  17:32:20  Hans_Graves
 * 	MME-01402. Added TimeStamp support to Callbacks.
 * 	[1996/10/28  16:56:21  Hans_Graves]
 * 
 * Revision 1.1.8.6  1996/10/12  17:18:11  Hans_Graves
 * 	Added ScImageSize().
 * 	[1996/10/12  16:53:38  Hans_Graves]
 * 
 * Revision 1.1.8.5  1996/09/18  23:45:46  Hans_Graves
 * 	Added ScFileClose() proto; ISIZE() macro
 * 	[1996/09/18  23:37:33  Hans_Graves]
 * 
 * Revision 1.1.8.4  1996/08/20  22:11:48  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:23  Bjorn_Engberg]
 * 
 * Revision 1.1.8.3  1996/05/24  22:21:27  Hans_Graves
 * 	Added ScPatScaleIDCT8x8i_S proto
 * 	[1996/05/24  21:56:31  Hans_Graves]
 * 
 * Revision 1.1.8.2  1996/05/07  19:55:49  Hans_Graves
 * 	Added BI_DECHUFFDIB
 * 	[1996/05/07  17:24:17  Hans_Graves]
 * 
 * Revision 1.1.6.9  1996/04/17  16:38:36  Hans_Graves
 * 	Change NT bitstream buffer sizes from 32 to 64-bit
 * 	[1996/04/17  16:37:04  Hans_Graves]
 * 
 * Revision 1.1.6.8  1996/04/15  21:08:39  Hans_Graves
 * 	Define ScBitBuff_t and ScBitString_t as dword or qword
 * 	[1996/04/15  21:05:46  Hans_Graves]
 * 
 * Revision 1.1.6.7  1996/04/10  21:47:16  Hans_Graves
 * 	Added definition for EXTERN
 * 	[1996/04/10  21:23:23  Hans_Graves]
 * 
 * Revision 1.1.6.6  1996/04/09  16:04:32  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:04  Hans_Graves]
 * 
 * Revision 1.1.6.5  1996/04/01  16:23:09  Hans_Graves
 * 	NT porting
 * 	[1996/04/01  16:15:48  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/03/20  22:32:46  Hans_Graves
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.6.2 **}
 * 		{** Merge revision:	1.1.6.3 **}
 * 	{** End **}
 * 	Added protos for IDCT1x1,1x2,2x1,2x2,3x3,4x4,6x6
 * 	[1996/03/20  22:25:47  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/03/16  19:22:51  Karen_Dintino
 * 	added NT port changes
 * 	[1996/03/16  19:20:07  Karen_Dintino]
 * 
 * Revision 1.1.6.2  1996/03/08  18:46:27  Hans_Graves
 * 	Added proto for ScScaleIDCT8x8m_S()
 * 	[1996/03/08  18:41:45  Hans_Graves]
 * 
 * Revision 1.1.4.14  1996/02/07  23:23:50  Hans_Graves
 * 	Added prototype for ScFileSeek()
 * 	[1996/02/07  23:18:32  Hans_Graves]
 * 
 * Revision 1.1.4.13  1996/02/01  17:15:50  Hans_Graves
 * 	Added ScBSSkipBitsFast() and ScBSPeekBitsFast() macros
 * 	[1996/02/01  17:14:17  Hans_Graves]
 * 
 * Revision 1.1.4.12  1996/01/24  19:33:18  Hans_Graves
 * 	Added prototype for ScScaleIDCT8x8i_S
 * 	[1996/01/24  18:13:51  Hans_Graves]
 * 
 * Revision 1.1.4.11  1996/01/08  20:15:13  Bjorn_Engberg
 * 	Added one more cast to avoid warnings.
 * 	[1996/01/08  20:14:55  Bjorn_Engberg]
 * 
 * Revision 1.1.4.10  1996/01/08  16:41:21  Hans_Graves
 * 	Added protos for more IDCT routines.
 * 	[1996/01/08  15:44:17  Hans_Graves]
 * 
 * Revision 1.1.4.9  1996/01/02  18:31:13  Bjorn_Engberg
 * 	Added casts to avoid warning messages when compiling.
 * 	[1996/01/02  15:02:16  Bjorn_Engberg]
 * 
 * Revision 1.1.4.8  1995/12/07  19:31:18  Hans_Graves
 * 	Added protos for ScFDCT8x8s_C() and ScIDCT8x8s_C(), Added ScBSAlignPutBits() macro.
 * 	[1995/12/07  17:58:36  Hans_Graves]
 * 
 * Revision 1.1.4.7  1995/11/16  12:33:34  Bjorn_Engberg
 * 	Add BI_BITFIELDS to IsRGBPacked macro
 * 	[1995/11/16  12:33:17  Bjorn_Engberg]
 * 
 * Revision 1.1.4.6  1995/10/13  21:01:42  Hans_Graves
 * 	Added macros for format classes.
 * 	[1995/10/13  20:59:15  Hans_Graves]
 * 
 * Revision 1.1.4.5  1995/09/22  19:41:00  Hans_Graves
 * 	Moved ValidBI_BITFIELDSKinds to SC_convert.h
 * 	[1995/09/22  19:40:42  Hans_Graves]
 * 
 * Revision 1.1.4.4  1995/09/20  18:27:59  Hans_Graves
 * 	Added Bjorn's NT defs
 * 	[1995/09/15  13:21:00  Hans_Graves]
 * 
 * Revision 1.1.4.3  1995/09/14  12:35:22  Hans_Graves
 * 	Added ScCopyClipToPacked422() prototypes.
 * 	[1995/09/14  12:34:58  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:45  Hans_Graves
 * 	Added ScScaleIDCT8x8(). Added buffer Type to queues.
 * 	[1995/09/13  14:29:10  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/09/11  19:17:23  Hans_Graves
 * 	Moved ValidateBI_BITFIELDS() prototype to SC_convert.h - Removed mmsystem.h include.
 * 	[1995/09/11  19:14:27  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/09/11  18:51:25  Farokh_Morshed
 * 	Support BI_BITFIELDS format
 * 	[1995/09/11  18:50:48  Farokh_Morshed]
 * 
 * Revision 1.1.2.16  1995/08/31  14:15:43  Farokh_Morshed
 * 	transfer BI_BITFIELDS stuff to SV.h
 * 	[1995/08/31  14:15:20  Farokh_Morshed]
 * 
 * Revision 1.1.2.15  1995/08/31  13:51:53  Farokh_Morshed
 * 	{** Merge Information **}
 * 		{** Command used:	bsubmit **}
 * 		{** Ancestor revision:	1.1.2.13 **}
 * 		{** Merge revision:	1.1.2.14 **}
 * 	{** End **}
 * 	Add BI_BITFIELDS support
 * 	[1995/08/31  13:50:46  Farokh_Morshed]
 * 
 * Revision 1.1.2.14  1995/08/29  22:17:05  Hans_Graves
 * 	Fixed-up Bitstream prototypes. Added BI_ image formats and defined BI_DECSEPYUV411DIB == BI_YU12SEP
 * 	[1995/08/29  22:15:27  Hans_Graves]
 * 
 * Revision 1.1.2.13  1995/08/14  19:40:26  Hans_Graves
 * 	Added Flush, ScCopySubClip_S() and ScCopyRev_S() prototypes.
 * 	[1995/08/14  18:43:11  Hans_Graves]
 * 
 * Revision 1.1.2.12  1995/07/21  17:41:01  Hans_Graves
 * 	Mirrored Callbacks with MME structure/naming.
 * 	[1995/07/21  17:30:04  Hans_Graves]
 * 
 * Revision 1.1.2.11  1995/07/17  22:01:31  Hans_Graves
 * 	Added BufSize and BufType to ScCallback_t.
 * 	[1995/07/17  21:42:45  Hans_Graves]
 * 
 * Revision 1.1.2.10  1995/07/12  19:48:23  Hans_Graves
 * 	Added H261_FILE type.
 * 	[1995/07/12  19:33:18  Hans_Graves]
 * 
 * Revision 1.1.2.9  1995/07/11  15:24:30  Hans_Graves
 * 	Fixed ScCopySubClip and ScCopyRev macros.
 * 	[1995/07/11  15:24:09  Hans_Graves]
 * 
 * Revision 1.1.2.8  1995/07/11  14:50:44  Hans_Graves
 * 	Added prototypes for sc_mc2.s and sc_copy2.s
 * 	[1995/07/11  14:23:18  Hans_Graves]
 * 
 * Revision 1.1.2.7  1995/06/27  13:54:21  Hans_Graves
 * 	Added STREAM_USE_NET and prototype for ScBSCreateFromNet()
 * 	[1995/06/26  21:00:17  Hans_Graves]
 * 
 * Revision 1.1.2.6  1995/06/22  21:35:03  Hans_Graves
 * 	Moved filetypes from SV.h to here
 * 	[1995/06/22  21:29:11  Hans_Graves]
 * 
 * Revision 1.1.2.5  1995/06/21  18:37:58  Hans_Graves
 * 	Added prototype for ScBSPutBytes()
 * 	[1995/06/21  18:36:43  Hans_Graves]
 * 
 * Revision 1.1.2.4  1995/06/15  21:17:59  Hans_Graves
 * 	Added prototypes for sc_copy.c
 * 	[1995/06/15  20:41:40  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/06/01  19:35:36  Hans_Graves
 * 	Added prototype for ScCopyClip()
 * 	[1995/06/01  19:31:28  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:20  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:17:35  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/03  19:26:38  Hans_Graves
 * 	Included in SLIB (Oct 95)
 * 	[1995/05/03  19:26:26  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/04/17  18:04:26  Hans_Graves
 * 	Added math prototypes and defs. Expanding Bitstream defs.
 * 	[1995/04/17  18:02:16  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/04/07  19:18:43  Hans_Graves
 * 	Inclusion in SLIB
 * 	[1995/04/07  19:04:13  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/


#ifndef _SC_H_
#define _SC_H_

#define SLIB_VERSION 0x300

/************************* Debug Handling ***********************/
#ifdef _VERBOSE_
#define sc_vprintf printf
#else
#define sc_vprintf
#endif

#ifdef _DEBUG_
#define sc_dprintf printf
#else
#define sc_dprintf
#endif

#ifdef _TEST_
#define sc_tprintf(test, msg)  if (test) printf(msg)
#else
#define sc_tprintf
#endif

#ifdef _SLIBDEBUG_
#define _SlibDebug(test, statements) { if (test) { statements; } }
#else
#define _SlibDebug(test, statements)
#endif

#ifndef EXTERN
#ifdef __cplusplus
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern "C"
#else
#define EXTERN __declspec( dllexport ) extern "C"
#endif
#else
#if !defined(WIN32) || defined(STATIC_BUILD)
#define EXTERN extern
#else
#define EXTERN __declspec( dllexport ) extern
#endif
#endif /* __cplusplus */
#endif /* EXTERN */

#ifndef PRIVATE_EXTERN
#ifdef __cplusplus
#define PRIVATE_EXTERN extern "C"
#else /* __cplusplus */
#define PRIVATE_EXTERN extern
#endif /* __cplusplus */
#endif /* PRIVATE_EXTERN */

#ifdef WIN32
/*
 * These b* routines are mem* routines on NT.
 */
#define bcopy(_src_,_dst_,_len_) memcpy(_dst_,_src_,_len_)
#define bzero(_dst_,_len_)	 memset(_dst_,0,_len_)
#define bcmp(_src_,_dst_,_len_)  memcmp(_src_,_dst_,_len_)
/*
 * These cma routines are doing nothing for NT.
 * Avoid lots of ifdefs on the code by defining
 * null macros for them. 
 */
#define cma_mutex_lock(foo)
#define cma_mutex_unlock(foo)
#endif /* WIN32 */

/************************* Elementary Types ***********************/
/*
#ifndef UNALIGNED
#if defined(WIN95) || defined(INTEL)
#define UNALIGNED
#else
#define UNALIGNED __unaligned
#endif
#endif
*/
#ifndef u_char
#if defined( __VMS ) || defined( WIN32 )
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 32 bits */
#else
typedef unsigned char  u_char;			/*  8 bits */
typedef unsigned short u_short;			/* 16 bits */
typedef unsigned int   u_int;			/* 32 bits */
typedef unsigned long  u_long;			/* 64 bits */
typedef unsigned int   UINT;
#endif
#endif /* u_char */

#ifndef WIN32
#ifndef byte   /* 8 bit */
#define byte   char
#endif
#endif /* !WIN32 */

#ifndef word   /* 16 bit */
#define word   short
#endif /* word */

#ifndef dword  /* 32 bit */
#define dword  int
#endif /* dword */

#ifndef qword  /* 64 bit */
#if defined(__VMS) || defined(WIN32)
#define qword  _int64
#else
#define qword  long
#endif
#endif /* qword */

#define MIN_WORD     ((-32767)-1)
#define MAX_WORD     ( 32767)
#define MIN_DWORD    ((-2147483647)-1)
#define MAX_DWORD    ( 2147483647)

/************************** Definitions ****************************/
#define RETURN_ON_ERROR(A)      {if (A) return (A);}

#ifndef NULL
#define NULL   0L
#endif

#ifndef TRUE
#define TRUE  1 
#define FALSE 0
#endif

#ifndef WIN32
#ifndef FAR
#define FAR
#endif
#endif

#ifndef PI
#define PI      3.14159265358979
#define PI4     PI/4
#define PI64    PI/64
#endif

/*
** public parameter settings
*/
/* Algorithm Flags - video */
#define PARAM_ALGFLAG_HALFPEL  0x0001  /* Half pixel accuracy */
#define PARAM_ALGFLAG_SKIPPEL  0x0002  /* Skip-pixel error calculation */
#define PARAM_ALGFLAG_PB       0x0004  /* PB frame encoding */
#define PARAM_ALGFLAG_SAC      0x0008  /* Syntax Arithmetic Coding */
#define PARAM_ALGFLAG_UMV      0x0010  /* Unrestricted Motion Vectors */
#define PARAM_ALGFLAG_ADVANCED 0x0020  /* Advanced Prediction Mode */
/* Algorithm Flags - audio */
#define PARAM_ALGFLAG_VAD      0x1000  /* Voice Activity Detection (G.723) */
/* Format Extensions */
#define PARAM_FORMATEXT_RTPA   0x0001  /* RTP Mode A */
#define PARAM_FORMATEXT_RTPB   0x0002  /* RTP Mode B */
#define PARAM_FORMATEXT_RTPC   0x0004  /* RTP Mode C */

/* Frame types */
#define FRAME_TYPE_NONE        0x0000
#define FRAME_TYPE_I           0x0001  /* Key frame */
#define FRAME_TYPE_P           0x0002  /* Partial frame */
#define FRAME_TYPE_B           0x0004  /* Bi-directional frame */
#define FRAME_TYPE_D           0x0008  /* Preview frame */

/************************** Formats (FOURCC's) ***************************/
/*
** Image formats
*/
#define BI_MSH261DIB            mmioFOURCC('M','2','6','1')
#define BI_MSH263DIB            mmioFOURCC('M','2','6','3')
#define BI_DECH261DIB           mmioFOURCC('D','2','6','1')
#define BI_DECH263DIB           mmioFOURCC('D','2','6','3')
#define BI_DECJPEGDIB           mmioFOURCC('J','P','E','G')
#define BI_DECMJPGDIB           mmioFOURCC('M','J','P','G')
#define BI_DECYUVDIB            mmioFOURCC('D','Y','U','V')
#define BI_DECXIMAGEDIB         mmioFOURCC('D','X','I','M')	
#define BI_DECSEPYUVDIB         mmioFOURCC('D','S','Y','U')
#define BI_DECMPEGDIB           mmioFOURCC('D','M','P','G')
#define BI_DECHUFFDIB           mmioFOURCC('D','H','U','F')
#define BI_DECSEPRGBDIB         mmioFOURCC('D','S','R','G')
#define BI_DECGRAYDIB           mmioFOURCC('D','G','R','Y')
#define BI_YVU9SEP              mmioFOURCC('Y','V','U','9')
#define BI_YU12SEP              mmioFOURCC('Y','U','1','2')
#define BI_YU16SEP              mmioFOURCC('Y','U','1','6')
#define BI_DECSEPYUV411DIB      mmioFOURCC('Y','U','1','2')
#define BI_S422                 mmioFOURCC('S','4','2','2')
#define BI_YUY2                 mmioFOURCC('Y','U','Y','2')

/*
 * FYI - Other image formats that are defined elsewhere:
 */
#if 0
#define BI_RGB              0
#define BI_BITFIELDS        3
#define BICOMP_JFIF         mmioFOURCC('J','F','I','F')
#endif

/*
 * Macros to identify classes of image formats.
 */
#define IsJPEG(s)         (((s) == JPEG_DIB)            || \
                           ((s) == MJPG_DIB))
#define IsYUV422Packed(s) (((s) == BI_DECYUVDIB)        || \
                           ((s) == BI_S422)             || \
                           ((s) == BI_YUY2))
#define IsYUV422Sep(s)    (((s) == BI_DECSEPYUVDIB)     || \
                           ((s) == BI_YU16SEP))
#define IsYUV411Sep(s)    (((s) == BI_DECSEPYUV411DIB)  || \
                           ((s) == BI_YU12SEP))
#define IsYUV1611Sep(s)   (((s) == BI_YVU9SEP))
#define IsYUVSep(s)       ((IsYUV422Sep(s))             || \
                           (IsYUV411Sep(s))             || \
                           (IsYUV1611Sep(s)))
#define IsYUV(s)          ((IsYUV422Packed(s))          || \
                           (IsYUVSep(s)))

#define IsRGBPacked(s)    (((s) == BI_RGB)              || \
                           ((s) == BI_DECXIMAGEDIB)     || \
                           ((s) == BI_BITFIELDS))
#define IsRGBSep(s)       (((s) == BI_DECSEPRGBDIB))
#define IsRGB(s)          ((IsRGBPacked(s))             || \
                           (IsRGBSep(s)))

#define IsGray(s)         (((s) == BI_DECGRAYDIB))

#define ISIZE(w,h,c) \
        (IsYUV411Sep(c)) ? ((w) * (h) * 3 / 2) : \
                ((IsYUV1611Sep(c)) ? \
                        ((w) * (h) * 9 / 8) : \
                                ((IsYUV422Sep(c) || IsYUV422Packed(c)) ? \
                                        ((w) * (h) * 2) : ((w) * (h) * 3)));

/*
** File Types (returned from ScGetFileType)
*/
#define UNKNOWN_FILE        0
#define AVI_FILE            201
#define MPEG_VIDEO_FILE     202
#define MPEG_AUDIO_FILE     203
#define MPEG_SYSTEM_FILE    204
#define JFIF_FILE           205
#define QUICKTIME_JPEG_FILE 206
#define GSM_FILE            207
#define WAVE_FILE           208
#define PCM_FILE            209
#define H261_FILE           210
#define AC3_FILE            211

/*
** Callback messages
*/
#define CB_RELEASE_BUFFER       1   /* buffer finished */
#define CB_END_BUFFERS          2   /* no more buffers */
#define CB_RESET_BUFFERS        3   /* reset to beginning */
#define CB_SEQ_HEADER           4   /* sequence header */
#define CB_SEQ_END              5   /* sequence end */
#define CB_FRAME_FOUND          6   /* frame found */
#define CB_FRAME_READY          7   /* frame completed */
#define CB_FRAME_START          8   /* frame starting to be processed */
#define CB_PROCESSING           9   /* processing data */
#define CB_CODEC_DONE          10   /* codec done ended */

/*
** Data types for callback message
*/
#define CB_DATA_NONE            0x0000 /* no data */
#define CB_DATA_COMPRESSED      0x0001 /* data is compressed */
#define CB_DATA_IMAGE           0x0002 /* data is decompressed image */
#define CB_DATA_AUDIO           0x0004 /* data is decompressed audio */
/*
** Frame flags for callback message
*/
#define CB_FLAG_TYPE_KEY        0x0001 /* key frame */
#define CB_FLAG_TYPE_MPEGB      0x0002 /* MPEG B-Frame */
#define CB_FLAG_FRAME_DROPPED   0x0008 /* frame dropped */
#define CB_FLAG_FRAME_BAD       0x0010 /* could not de/compress */
/*
** Action values in response to callback message
*/
#define CB_ACTION_WAIT          0x0000 /* wait - callback still busy */
#define CB_ACTION_CONTINUE      0x0001 /* accept a frame */
#define CB_ACTION_DROP          0x0002 /* drop a frame */
#define CB_ACTION_DUPLICATE     0x0004 /* duplicate a frame */
#define CB_ACTION_END           0x0080 /* end de/compression */

/* These are old definitions
#define CLIENT_CONTINUE        CB_ACTION_CONTINUE
#define CLIENT_ABORT           CB_ACTION_END
#define CLIENT_PROCESS         CB_ACTION_CONTINUE
#define CLIENT_DROP            CB_ACTION_DROP
#define CB_IMAGE_BUFFER_READY  CB_FRAME_READY
#define CB_PICTURE_FOUND       CB_FRAME_FOUND
#define CB_PICTURE_PROCEESSED  CB_FRAME_READY
#define CB_FRAME               CB_FRAME_FOUND
*/


/*
 * Stream sources/destinations
 */
#define STREAM_USE_SAME     -1
#define STREAM_USE_NULL     0
#define STREAM_USE_QUEUE    1
#define STREAM_USE_FILE     2
#define STREAM_USE_BUFFER   3
#define STREAM_USE_DEVICE   4
#define STREAM_USE_STDOUT   5
#define STREAM_USE_NET      6
#define STREAM_USE_NET_TCP  6  /* reliable transport */
#define STREAM_USE_NET_UDP  7  /* unreliable transport */

/************************** Type Definitions *******************************/
typedef int           ScStatus_t;
typedef void         *ScHandle_t;
typedef unsigned char ScBoolean_t;
#if !defined( _VMS ) && !defined( WIN32 )
/* typedef long          _int64; */
#endif

/*
** Bitstream stuff
*/
#if defined( _VMS ) || defined( WIN95 )
#define SC_BITBUFFSZ    32
typedef unsigned dword ScBitBuff_t;
typedef unsigned dword ScBitString_t;
#else
#define SC_BITBUFFSZ    64
typedef unsigned qword ScBitBuff_t;
typedef unsigned qword ScBitString_t;
#endif
#define SC_BITBUFFMASK  (ScBitBuff_t)-1
#define ALIGNING        8
#define ScBSPreLoad(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWord(bs);
#define ScBSPreLoadW(bs, bits) if ((int)bs->shift<(bits)) sc_BSLoadDataWordW(bs);
#define ScBSByteAlign(bs) { \
      int len=bs->shift%8; \
      if (len) { \
        bs->OutBuff=(bs->OutBuff<<len)|(bs->InBuff>>(SC_BITBUFFSZ-len)); \
        bs->InBuff<<=len; bs->CurrentBit+=len; bs->shift-=len; } \
        }
#define ScBSAlignPutBits(bs) if (bs->shift%8) \
                               ScBSPutBits(bs, 0, 8-(bs->shift%8));
#define ScBSBitPosition(bs)  (bs->CurrentBit)
#define ScBSBytePosition(bs) (bs->CurrentBit>>3)
#define ScBSBufferedBytes(bs) (bs->bufftop)
#define ScBSBufferedBytesUsed(bs) (bs->buffp)
#define ScBSBufferedBytesUnused(bs) (bs->bufftop-bs->buffp)
#define ScBSSkipBit(bs)      ScBSSkipBits(bs, 1)
#define ScBSSkipBitsFast(bs, len) { if ((u_int)(len)<=bs->shift) { \
     if ((len)==SC_BITBUFFSZ) \
       { bs->OutBuff=bs->InBuff; bs->InBuff=0; } \
     else { \
       bs->OutBuff=(bs->OutBuff<<(len))|(bs->InBuff>>(SC_BITBUFFSZ-(len))); \
       bs->InBuff<<=(len); } \
       bs->CurrentBit+=len; bs->shift-=len; \
     } else ScBSSkipBits(bs, len); }
#define ScBSSkipBitFast(bs) ScBSSkipBitsFast(bs, 1)
#define ScBSPeekBitsFast(bs, len) (!(len) ? 0 \
     : (((len)<=bs->shift || !sc_BSLoadDataWord(bs)) && (len)==SC_BITBUFFSZ \
            ? bs->OutBuff : (bs->OutBuff >> (SC_BITBUFFSZ-len))) )
#define ScBSPeekBitsFull(bs, result) \
        { ScBSPreLoad(bs, SC_BITBUFFSZ); result = bs->OutBuff; }

/*
** Sort stuff
*/
typedef struct ScSortDouble_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortDouble_t;

typedef struct ScSortFloat_s {
  int    index;   /* index to actual data */
  double num;     /* the number to sort by */
} ScSortFloat_t;

/*
** ScBuf_s structure used in Buffer/Image Queue management.
** Contains info for one buffer.
*/
struct ScBuf_s {
  u_char *Data;                 /* Pointer to buffer's data            */
  int    Size;                  /* Length of buffer in bytes           */
  int    Type;                  /* Type of buffer                      */
  struct ScBuf_s *Prev;         /* Pointer to previous buffer in queue */
};

/*
** Buffer queue structure. One for each queue.
*/
typedef struct ScQueue_s {
  int NumBufs;                  /* Number of buffers currently in queue */
  struct ScBuf_s *head, *tail;  /* pointers to head & tail of queue     */
} ScQueue_t;

/*
** ScCallbackInfo_t passes info back & forth during callback
*/
typedef struct ScCallbackInfo_s {
  int     Message;    /* Callback reason: CB_FRAME_READY, etc. */
  int     DataType;   /* Buffer data type */
  u_char *Data;       /* Pointer to data buffer. */
  dword   DataSize;   /* Length of data buffer */
  dword   DataUsed;   /* Actual bytes used in buffer */
  void   *UserData;   /* User defined data */
  qword   TimeStamp;  /* Timestamp of decompressed img/audio */
                      /* relative to start of sequence */
  dword   Flags;      /* decomp/compression details */
  int     Action;     /* drop frame or continue */
  dword   Value;      /* a value for special flags/actions */
  void   *Format;     /* BITMAPINFOHEADER or WAVEFORMATEX */
} ScCallbackInfo_t;

typedef qword ScBSPosition_t;
/*
** State info for the input bitstream
*/
typedef struct ScBitstream_s {
  dword DataSource;             /* STREAM_USE_BUFFER, _USE_QUEUE,_USE_FILE,   */
                                /* or _USE_DEVICE                             */
  char Mode;                    /* 'r'=read, 'w'=write, 'b'=both              */
  ScQueue_t *Q;                 /* Buffer Queue (STREAM_USE_QUEUE)            */
  int (*Callback)(ScHandle_t,   /* Callback to supply Bufs (STREAM_USE_QUEUE) */
             ScCallbackInfo_t *, void *);
  int (*FilterCallback)(struct  /* Callback to filter data from bitstream     */
               ScBitstream_s *);
  unsigned qword FilterBit;     /* Bit to call filter callback at             */
  unsigned char  InFilterCallback; /* TRUE when FilterCallback is busy           */
  ScHandle_t     Sch;           /* Handle passed to Callback                  */
  dword          DataType;      /* Data type passed to Callback               */
  void          *UserData;      /* User Data passed to Callback               */
  int            FileFd;        /* File descriptor (STREAM_USE_FILE/NET)      */
  unsigned char *RdBuf;         /* Buf to use if (_USE_BUFFER,_USE_FILE)      */
  unsigned dword RdBufSize;     /* Size of RdBuf                              */
  char           RdBufAllocated;/* = TRUE if RdBuf was internally allocated   */
  dword          Device;        /* Device to use (STREAM_USE_DEVICE)          */
  ScBitBuff_t    InBuff, OutBuff; /* 64-bit or 32-bit data buffers            */
  unsigned int   shift;         /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;    /* Current bit position in bitstream          */
  unsigned char *buff;          /* pointer to bitstream data buffer           */
  unsigned dword buffstart;     /* byte offset of start of buff               */
  unsigned dword buffp;         /* byte offset in buffer                      */
  unsigned dword bufftop;       /* number of bytes in buffer                  */
  ScBoolean_t    EOI;           /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;         /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstream_t;

/*
** Bitstream context block to save current position of input stream
*/
typedef struct ScBitstreamSave_s {
  ScBitBuff_t    InBuff, OutBuff;  /* 64-bit or 32-bit data buffers              */
  unsigned dword shift;            /* Shift value for current bit position       */
  ScBSPosition_t CurrentBit;       /* Current bit position in bitstream          */
  unsigned char *buff;             /* pointer to bitstream data buffer           */
  unsigned dword buffp;            /* byte offset in buffer                      */
  ScBoolean_t    EOI;              /* = TRUE when no more data in data source    */
  ScBoolean_t    Flush;            /* = TRUE to signal a flush at next 32/64 bit */
} ScBitstreamSave_t;


/************************** Prototypes *****************************/
/*
 * sc_file.c
 */
PRIVATE_EXTERN ScBoolean_t ScFileExists(char *filename);
PRIVATE_EXTERN int         ScFileOpenForReading(char *filename);
PRIVATE_EXTERN int         ScFileOpenForWriting(char *filename, ScBoolean_t truncate);
PRIVATE_EXTERN ScStatus_t  ScFileSize(char *filename, unsigned qword *size);
PRIVATE_EXTERN dword       ScFileRead(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN dword       ScFileWrite(int fd, void *buffer, unsigned dword bytes);
PRIVATE_EXTERN ScStatus_t  ScFileSeek(int fd, qword bytepos);
PRIVATE_EXTERN void        ScFileClose(int fd);
PRIVATE_EXTERN ScStatus_t  ScFileMap(char *filename, int *fd, u_char **buffer,
                                         unsigned qword *size);
PRIVATE_EXTERN ScStatus_t  ScFileUnMap(int fd, u_char *buffer, unsigned int size);
PRIVATE_EXTERN int         ScGetFileType(char *filename);

/*
 * sc_mem.c
 */
PRIVATE_EXTERN void     *ScAlloc(unsigned long bytes);
PRIVATE_EXTERN void     *ScAlloc2(unsigned long bytes, char *name);
PRIVATE_EXTERN void     *ScCalloc(unsigned long bytes);
PRIVATE_EXTERN void      ScFree(void *);
PRIVATE_EXTERN int       ScMemCheck(char *array,int test,int num);
EXTERN char     *ScPaMalloc(int);
EXTERN void      ScPaFree(void *);
EXTERN int       getpagesize();

/*
 * sc_util.c
 */
extern int       sc_Dummy();
PRIVATE_EXTERN unsigned int ScImageSize(unsigned int fourcc, int w, int h, int bits);
extern void      ScReadCommandSwitches(char *argv[],int argc,
                                 void (*error_routine)(),char *,...);
extern void      ScShowBuffer(unsigned char *, int);
extern void      ScShowBufferFloat(float *, int);
extern void      ScShowBufferInt(int *, int);
extern int       ScDumpChar(unsigned char *ptr, int nbytes, int startpos);



/*
 * sc_errors.c
 */
PRIVATE_EXTERN ScStatus_t ScGetErrorText (int errno, char *ReturnMsg, u_int MaxChars);
PRIVATE_EXTERN char *ScGetErrorStr(int errno);
extern char _serr_msg[80];

/*
 * sc_buf.c
 */
PRIVATE_EXTERN ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *BS));
PRIVATE_EXTERN ScStatus_t ScBSCreate(ScBitstream_t **BS);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS,
                                    u_char *Buffer, unsigned int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS,
                                ScHandle_t Sch, int DataType, ScQueue_t *Q,
                         int (*Callback)(ScHandle_t,ScCallbackInfo_t *,void *),
                         void *UserData);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS,int FileFd,
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd, 
                                u_char *Buffer, int BufSize);
PRIVATE_EXTERN ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device);
PRIVATE_EXTERN ScStatus_t ScBSDestroy(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlush(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSFlushSoon(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSReset(ScBitstream_t *BS);
PRIVATE_EXTERN ScStatus_t ScBSResetCounters(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSPeekBit(ScBitstream_t *BS);
PRIVATE_EXTERN ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length);

PRIVATE_EXTERN int ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length);
PRIVATE_EXTERN int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, 
                              u_int length, u_int *ret_length,
                              ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length);
PRIVATE_EXTERN int        ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, 
                                                     int len);
PRIVATE_EXTERN ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer,
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, 
                                                 u_int length);
PRIVATE_EXTERN ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit);
PRIVATE_EXTERN int        ScBSGetBit(ScBitstream_t *BS);

PRIVATE_EXTERN ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos);
PRIVATE_EXTERN int        ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, int word_len);
PRIVATE_EXTERN int        ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBefore(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopBeforeW(ScBitstream_t *BS,ScBitString_t seek_word,int word_len);
PRIVATE_EXTERN int        ScBSSeekAlignStopAt(ScBitstream_t *BS,
                                      ScBitString_t seek_word,
                                      int word_len, unsigned long end_byte_pos);
extern ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS);
extern ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t Buff);

PRIVATE_EXTERN ScStatus_t ScBufQueueCreate(ScQueue_t **Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueDestroy(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size,
                                   int Type);
PRIVATE_EXTERN ScStatus_t ScBufQueueRemove(ScQueue_t *Q);
PRIVATE_EXTERN int        ScBufQueueGetNum(ScQueue_t *Q);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data,
                                                          int *Size);
PRIVATE_EXTERN ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data,
                                               int *Size, int *Type);


/*
** sc_math.c
*/
/* #define ScAbs(val) (val > 0.0) ? val : -val */
extern float ScAbs(float val);
extern double ScSqr(double x);
extern double ScDistance(double x1, double y1, double z1,
                         double x2, double y2, double z2);
extern void  ScDigrv4(float *real, float *imag, int n);
extern float ScArcTan(float Q,float I);

/*
** sc_dct.c
*/
extern void ScFDCT(float in_block[32], float out_block1[32],
                   float out_block2[32]);
extern void ScIFDCT(float in_block[32], float out_block[32]);
extern void ScFDCT8x8_C(float *ipbuf, float *outbuf);
extern void ScFDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_dct2.c
*/
extern void ScFDCT8x8_S(float *ipbuf, float *outbuf);

/*
** sc_idct.c
*/
extern void ScIDCT8x8(int *outbuf);
extern void ScScaleIDCT8x8_C(float *ipbuf, int *outbuf);
extern void ScIDCT8x8s_C(short *inbuf, short *outbuf);

/*
** sc_idct_scaled.c
*/
extern void ScScaleIDCT8x8i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT8x8i128_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT1x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x1i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT2x2i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT3x3i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT4x4i_C(int *inbuf, int *outbuf);
extern void ScScaleIDCT6x6i_C(int *inbuf, int *outbuf);

/*
** sc_idct2.s
*/
extern void ScIDCT8x8s_S(short *inbuf, short *outbuf);
extern void ScScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_idct3.s
*/
extern void ScScaleIDCT8x8m_S(int *inbuf);

/*
** sc_idctp2.s
*/
extern void ScPatScaleIDCT8x8i_S(int *inbuf, int *outbuf);

/*
** sc_fft.c
*/
extern void  ScFFTtrl(float *real,float *imag,int n,int max_fft,float *c1,
                      float *s1,float *c2,float *s2,float *c3,float *s3);
extern void  ScFFTtl(float *real, float *imag, int n, int max_fft, float *c1,
                     float *s1, float *c2, float *s2, float *c3, float *s3);
extern void  ScFFTt4l(float *real, float *imag, int n, int *angle_increment,
                      int max_fft, float *c1, float *s1, float *c2, float *s2,
                      float *c3, float *s3);

/*
** sc_sort.c
*/
extern void ScSortDoubles(ScSortDouble_t *a, int n);

/*
** sc_copy.c
*/
extern void ScCopyClip_C(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_C(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_C(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_C(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopyRev_C(unsigned int *yptr, float *Idctptr, int Inc);
extern void ScCopyMV8_C(unsigned char *mvbuf, unsigned int *pbuf,
                        int mvinc, int pwidth);
extern void ScLoopFilter_C(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyBlock_C(unsigned char *linmemu, unsigned char *linmemv,
                 int xpos, unsigned char *blkmemu,
                 unsigned char *blkmemv, int cwidth, int wsis);
extern void ScCopyMB_C(unsigned char *ysrc, int xpos, unsigned char *ymb,
                  int ywidth, int yywidth);
extern void ScCopyMB8_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_C(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);

/*
** sc_copy2.s
*/
extern void ScCopyClip_S(int *buf, unsigned int *pos, int inc);
extern void ScCopyClipToPacked422_S(int *buf, unsigned char *pos, int inc);
extern void ScCopyAddClip_S(unsigned char *mvbuf, int *idctbuf,
                unsigned int *pbuf, int mvinc, int pwidth);
extern void ScCopySubClip_S(unsigned char *mvbuf, float *idctbuf, 
                unsigned int *pbuf, int mvinc, int pinc);
extern void ScCopyRev_S(unsigned int *yptr, float *Idctptr, int yinc);
extern void ScLoopFilter_S(unsigned char *input, unsigned int *work, int inc);
extern void ScCopyMV8_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMV16_S(unsigned char *mvbuf, unsigned int *pbuf,
                         int mvinc, int pwidth);
extern void ScCopyMB8_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScCopyMB16_S(unsigned char *ysrc, unsigned char *ymb,
                         int ywidth, int yywidth);
extern void ScAvgMV_S(unsigned char *, unsigned char *);


/*
** sc_mc2.s
*/
extern void ScMCy8(unsigned char *, unsigned char *, int);
extern void ScMCy16(unsigned char *, unsigned char *, int);
extern void ScMCx8(unsigned char *, unsigned char *, int);
extern void ScMCx16(unsigned char *, unsigned char *, int);
extern void ScMCxy8(unsigned char *, unsigned char *, int);
extern void ScMCxy16(unsigned char *, unsigned char *, int);

/*
**  macros for using C or assembly versions
*/
#ifdef USE_C
#define ScCopyClip             ScCopyClip_C
#define ScCopyClipToPacked422  ScCopyClipToPacked422_C
#define ScCopyAddClip          ScCopyAddClip_C
#define ScCopySubClip          ScCopySubClip_C
#define ScCopyRev              ScCopyRev_C
#define ScLoopFilter           ScLoopFilter_C
#define ScCopyMV8              ScCopyMV8_C
#define ScCopyMV16             ScCopyMV16_C
#define ScCopyMB8              ScCopyMB8_C
#define ScCopyMB16             ScCopyMB16_C
#define ScAvgMV                ScAvgMV_C
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScScaleIDCT8x8i_C
#define ScFDCT8x8              ScFDCT8x8_C
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_C
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_C
#else /* USE_C */
#define ScCopyClip             ScCopyClip_S
#define ScCopyClipToPacked422  ScCopyClipToPacked422_S
#define ScCopyAddClip          ScCopyAddClip_S
#define ScCopySubClip          ScCopySubClip_S
#define ScCopyRev              ScCopyRev_S
#define ScLoopFilter           ScLoopFilter_S
#define ScCopyMV8              ScCopyMV8_S
#define ScCopyMV16             ScCopyMV16_S
#define ScCopyMB8              ScCopyMB8_S
#define ScCopyMB16             ScCopyMB16_S
#define ScAvgMV                ScAvgMV_S
#define ScScaleIDCT8x8         ScScaleIDCT8x8_C
#define ScScaleIDCT8x8i        ScScaleIDCT8x8i_C
#define ScScaleIDCT8x8i128     ScScaleIDCT8x8i128_C
#define ScPatScaleIDCT8x8i     ScPatScaleIDCT8x8i_S
#define ScFDCT8x8              ScFDCT8x8_S
#define ScFDCT8x8s             ScFDCT8x8s_C
#define ScIDCT8x8s             ScIDCT8x8s_S
#define ScIDCT8x8sAndCopy      ScIDCT8x8sAndCopy_S
#endif /* USE_C */

#endif /* _SC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\scon_api.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: scon_api.c,v $
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1997                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
 * SLIB Conversion API
 */

/*
#define _SLIBDEBUG_
*/

#include "scon_int.h"
#include "SC_err.h"
#include "SC_conv.h"

#ifdef WIN32
#include <mmsystem.h>
#endif

#ifdef _SLIBDEBUG_
#include "sc_debug.h"

#define _DEBUG_     1  /* detailed debuging statements */
#define _VERBOSE_   1  /* show progress */
#define _VERIFY_    1  /* verify correct operation */
#define _WARN_      1  /* warnings about strange behavior */
#endif


static unsigned dword sconTranslateFourCC(unsigned dword FourCC)
{
  switch (FourCC)
  {
      case BI_DECYUVDIB:     /* YUV 4:2:2 Packed */
      case BI_YUY2:          /* YUV 4:2:2 Packed */
          return(BI_YUY2);
      case BI_YU16SEP:       /* YUV 4:2:2 Planar */
      case BI_DECSEPYUVDIB:  /* YUV 4:2:2 Planar */
          return(BI_YU16SEP);
      case BI_YU12SEP:       /* YUV 4:1:1 Planar */
      case BI_RGB:           /* RGB */
      case BI_BITFIELDS:     /* RGB masked */
#ifndef WIN32
      case BI_DECXIMAGEDIB:  /* Unix Ximage RGB */
#endif /* !WIN32 */
      case BI_YVU9SEP:       /* YUV 16:1:1 Planar */
      default:
          return(FourCC);
  }
}

static void sconInitInfo(SconInfo_t *Info)
{
  _SlibDebug(_DEBUG_, printf("sconInitInfo()\n") );
  Info->Mode = SCON_MODE_NONE;
  Info->InputInited = FALSE;
  Info->OutputInited = FALSE;
  Info->Flip = FALSE;
  Info->SameFormat = TRUE;
  Info->ScaleUp = FALSE;
  Info->ScaleDown = FALSE;
  Info->FImage = NULL;
  Info->FImageSize = 0;
  Info->SImage = NULL;
  Info->SImageSize = 0;
  Info->Table = NULL;
  Info->TableSize = 0;
  Info->dbg = NULL;
}

static void sconValidateInfo(SconInfo_t *Info)
{
  if (Info->Mode==SCON_MODE_VIDEO)
  {
    if (Info->InputInited && Info->OutputInited)
    {
      SconVideoInfo_t *in_vinfo=&Info->Input.vinfo;
      SconVideoInfo_t *out_vinfo=&Info->Output.vinfo;
      Info->Flip=(in_vinfo->NegHeight!=out_vinfo->NegHeight)?TRUE:FALSE;
      sconCalcImageSize(in_vinfo);
      sconCalcImageSize(out_vinfo);
      Info->ScaleDown=(in_vinfo->Pixels>out_vinfo->Pixels)?TRUE:FALSE;
      Info->ScaleUp=(in_vinfo->Pixels<out_vinfo->Pixels)?TRUE:FALSE;
      if (!Info->ScaleDown && !Info->ScaleUp && in_vinfo->Width>out_vinfo->Width)
        Info->ScaleUp=TRUE;
      in_vinfo->FourCC=sconTranslateFourCC(in_vinfo->FourCC);
      out_vinfo->FourCC=sconTranslateFourCC(out_vinfo->FourCC);
      if (in_vinfo->BPP==out_vinfo->BPP && 
          in_vinfo->FourCC==out_vinfo->FourCC)
        Info->SameFormat=TRUE;
      else
        Info->SameFormat=FALSE;
    }
  }
}

static void sconBMHtoVideoInfo(BITMAPINFOHEADER *bmh, SconVideoInfo_t *vinfo)
{
  vinfo->Width=bmh->biWidth;
  if (bmh->biHeight<0) /* height is negative */
  {
    vinfo->Height=-bmh->biHeight;
    vinfo->NegHeight=TRUE;
  }
  else /* height is positive */
  {
    vinfo->Height=bmh->biHeight;
    vinfo->NegHeight=FALSE;
  }
  vinfo->FourCC=bmh->biCompression;
  vinfo->BPP=bmh->biBitCount;
  vinfo->Stride=vinfo->Width*((vinfo->BPP+7)>>3);
  /* RGB bit masks */
  vinfo->Rmask=0;
  vinfo->Gmask=0;
  vinfo->Bmask=0;
  vinfo->RGBmasks=0;
  if (vinfo->FourCC==BI_BITFIELDS || vinfo->FourCC==BI_RGB ||
      vinfo->FourCC==BI_DECXIMAGEDIB)
  {
    if (vinfo->BPP==32 || vinfo->BPP==24)
    {
      vinfo->Rmask=0xFF0000;
      vinfo->Gmask=0x00FF00;
      vinfo->Bmask=0x0000FF;
    }
    else if (vinfo->BPP==16) /* RGB 565 */
    {
      vinfo->Rmask=0xF800;
      vinfo->Gmask=0x07E0;
      vinfo->Bmask=0x001F;
    }
    if (vinfo->FourCC==BI_BITFIELDS &&
        bmh->biSize>=sizeof(BITMAPINFOHEADER)+3*4)
    {
      DWORD *MaskPtr = (DWORD *)&bmh[1];
      if (MaskPtr[0] && MaskPtr[1] && MaskPtr[2])
      {
        /* get bit masks */
        vinfo->Rmask=MaskPtr[0];
        vinfo->Gmask=MaskPtr[1];
        vinfo->Bmask=MaskPtr[2];
      }
    }
    if (vinfo->Rmask==0xF800 && vinfo->Gmask==0x07E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x07E0 && vinfo->Bmask==0xF800)
      vinfo->RGBmasks=565;
    else if (vinfo->Rmask==0x7C00 && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x001F)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0x001F && vinfo->Gmask==0x03E0 && vinfo->Bmask==0x7C00)
      vinfo->RGBmasks=555;
    else if (vinfo->Rmask==0xFF0000 && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0x0000FF)
      vinfo->RGBmasks=888;
    else if (vinfo->Rmask==0x0000FF && vinfo->Gmask==0x00FF00 && vinfo->Bmask==0xFF0000)
      vinfo->RGBmasks=888;
  }
}

SconStatus_t SconOpen(SconHandle_t *handle, SconMode_t smode,
                      void *informat, void *outformat)
{
  SconInfo_t *Info;
  if (smode==SCON_MODE_VIDEO)
  {
    if ((Info = (SconInfo_t *)ScAlloc(sizeof(SconInfo_t))) == NULL)
      return(SconErrorMemory);
    sconInitInfo(Info);
    Info->Mode=smode;
    if (informat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)informat, &Info->Input.vinfo);
      Info->InputInited = TRUE;
    }
    if (outformat)
    {
      sconBMHtoVideoInfo((BITMAPINFOHEADER *)outformat, &Info->Output.vinfo);
      Info->OutputInited = TRUE;
    }
    sconValidateInfo(Info);
    *handle=(SconHandle_t)Info;
    return(SconErrorNone);
  }
  else
    return(SconErrorBadMode);
}

SconStatus_t SconClose(SconHandle_t handle)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  _SlibDebug(_VERBOSE_, printf("SconClose()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (Info->Table)
    ScPaFree(Info->Table);
  if (Info->FImage)
    ScPaFree(Info->FImage);
  if (Info->SImage)
    ScPaFree(Info->SImage);
  ScFree(Info);
  return(SconErrorNone);
}

/*
** Name: SconIsSame
** Desc: Return true if input and output formats are identical.
** Return: TRUE   input == output format
**         FALSE  input != out format
*/
SconBoolean_t SconIsSame(SconHandle_t handle)
{
  if (handle)
  {
    SconInfo_t *Info=(SconInfo_t *)handle;

    if (Info->Mode==SCON_MODE_VIDEO)
    {
      if (Info->SameFormat && !Info->Flip && !Info->ScaleUp && !Info->ScaleDown)
        return(TRUE);
    }
  }
  return(FALSE);
}

SconStatus_t SconConvert(SconHandle_t handle, void *inbuf, dword inbufsize,
                                              void *outbuf, dword outbufsize)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status;
  _SlibDebug(_VERBOSE_, printf("SconConvert()\n") );
  if (!handle)
    return(SconErrorBadHandle);
  if (inbuf==NULL || outbuf==NULL)
    return(SconErrorBadArgument);
  if (Info->Mode==SCON_MODE_VIDEO)
    status=sconConvertVideo(Info, inbuf, inbufsize, outbuf, outbufsize);
  else
    status=SconErrorBadMode;
  return(status);
}

SconStatus_t SconSetParamInt(SconHandle_t handle, SconParamType_t ptype,
                             SconParameter_t param, long value)
{
  SconInfo_t *Info=(SconInfo_t *)handle;
  SconStatus_t status=SconErrorNone;
  if (!handle)
    return(SconErrorBadHandle);
  _SlibDebug(_DEBUG_, printf("SconSetParamInt(stream=%d, param=%d, %d)\n",
                   stream, param, value) );
  switch (param)
  {
    case SCON_PARAM_STRIDE:
          _SlibDebug(_DEBUG_,
                printf("SconSetParamInt(SCON_PARAM_STRIDE)\n") );
          if (Info->Mode==SCON_MODE_VIDEO)
          {
            if (ptype==SCON_INPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Input.vinfo.Stride=(long)value;
            if (ptype==SCON_OUTPUT || ptype==SCON_INPUT_AND_OUTPUT)
              Info->Output.vinfo.Stride=(long)value;
          }
          else
            status=SconErrorBadMode;
          break;
    default:
          return(SconErrorUnsupportedParam);
  }
  return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_buf.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_buf.c,v $
 * Revision 1.1.8.4  1996/12/12  20:54:41  Hans_Graves
 * 	Fixed reading of last odd bits.
 * 	[1996/12/12  20:54:05  Hans_Graves]
 *
 * Revision 1.1.8.3  1996/11/13  16:10:46  Hans_Graves
 * 	Tom's changes to ScBSGetBitsW() and ScBSSeekAlignStopBeforeW().
 * 	[1996/11/13  15:57:34  Hans_Graves]
 *
 * Revision 1.1.8.2  1996/11/08  21:50:32  Hans_Graves
 * 	Added ScBSGetBitsW(), ScBSSkipBitsW() and sc_BSLoadDataWordW() for AC3.
 * 	[1996/11/08  21:25:52  Hans_Graves]
 *
 * Revision 1.1.6.4  1996/04/17  16:38:33  Hans_Graves
 * 	Correct some type casting to support 64-bit buffers under NT
 * 	[1996/04/17  16:36:08  Hans_Graves]
 *
 * Revision 1.1.6.3  1996/04/15  21:08:37  Hans_Graves
 * 	Declare mask and imask as ScBitString_t
 * 	[1996/04/15  21:06:32  Hans_Graves]
 *
 * Revision 1.1.6.2  1996/04/01  16:23:05  Hans_Graves
 * 	Replace File I/O with ScFile calls
 * 	[1996/04/01  16:22:27  Hans_Graves]
 *
 * Revision 1.1.4.7  1996/02/19  14:29:25  Bjorn_Engberg
 * 	Enable FILTER_SUPPORT for NT, so Mview can play audio.
 * 	This is only until we port the MPEG Systems code to NT.
 * 	[1996/02/19  14:29:07  Bjorn_Engberg]
 *
 * Revision 1.1.4.6  1996/02/01  17:15:48  Hans_Graves
 * 	Added FILTER_SUPPORT ifdef; disabled it
 * 	[1996/02/01  17:13:29  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/08  16:41:12  Hans_Graves
 * 	Remove NT compiler warnings, and minor fixes for NT.
 * 	[1996/01/08  14:14:10  Hans_Graves]
 *
 * Revision 1.1.4.3  1995/11/06  18:47:37  Hans_Graves
 * 	Added support for small buffer: 1-7 bytes
 * 	[1995/11/06  18:46:49  Hans_Graves]
 *
 * Revision 1.1.4.2  1995/09/13  14:51:34  Hans_Graves
 * 	Added ScBufQueueGetHeadExt() and ScBufQueueAddExt().
 * 	[1995/09/13  14:47:11  Hans_Graves]
 *
 * Revision 1.1.2.18  1995/08/30  19:37:49  Hans_Graves
 * 	Fixed compiler warning about #else and #elif.
 * 	[1995/08/30  19:36:15  Hans_Graves]
 *
 * Revision 1.1.2.17  1995/08/29  22:17:04  Hans_Graves
 * 	Disabled debugging statements.
 * 	[1995/08/29  22:11:38  Hans_Graves]
 *
 * 	PTT 00938 - MPEG Seg Faulting fixes, Repositioning problem.
 * 	[1995/08/29  22:04:06  Hans_Graves]
 *
 * Revision 1.1.2.16  1995/08/14  19:40:24  Hans_Graves
 * 	Added Flush routines. Some optimization.
 * 	[1995/08/14  18:40:33  Hans_Graves]
 *
 * Revision 1.1.2.15  1995/08/02  15:26:58  Hans_Graves
 * 	Fixed writing bitstreams directly to files.
 * 	[1995/08/02  14:11:00  Hans_Graves]
 *
 * Revision 1.1.2.14  1995/07/28  20:58:37  Hans_Graves
 * 	Initialized all variables in callback messages.
 * 	[1995/07/28  20:52:04  Hans_Graves]
 *
 * Revision 1.1.2.13  1995/07/28  17:36:04  Hans_Graves
 * 	Fixed END_BUFFER callback from GetNextBuffer()
 * 	[1995/07/28  17:31:30  Hans_Graves]
 *
 * Revision 1.1.2.12  1995/07/27  18:28:52  Hans_Graves
 * 	Fixed buffer queues in PutData and StoreDataWord.
 * 	[1995/07/27  18:23:30  Hans_Graves]
 *
 * Revision 1.1.2.11  1995/07/27  12:20:35  Hans_Graves
 * 	Renamed SvErrorClientAbort to SvErrorClientEnd
 * 	[1995/07/27  12:19:12  Hans_Graves]
 *
 * Revision 1.1.2.10  1995/07/21  17:40:59  Hans_Graves
 * 	Renamed Callback related stuff. Added DataType.
 * 	[1995/07/21  17:26:48  Hans_Graves]
 *
 * Revision 1.1.2.9  1995/07/17  22:01:27  Hans_Graves
 * 	Added Callback call in PutData().
 * 	[1995/07/17  21:50:49  Hans_Graves]
 *
 * Revision 1.1.2.8  1995/07/12  19:48:21  Hans_Graves
 * 	Added Queue debugging statements.
 * 	[1995/07/12  19:30:37  Hans_Graves]
 *
 * Revision 1.1.2.7  1995/07/07  20:11:23  Hans_Graves
 * 	Fixed ScBSGetBit() so it returns the bit.
 * 	[1995/07/07  20:07:27  Hans_Graves]
 *
 * Revision 1.1.2.6  1995/06/27  13:54:17  Hans_Graves
 * 	Added ScBSCreateFromNet() and STREAM_USE_NET cases.
 * 	[1995/06/27  13:27:38  Hans_Graves]
 *
 * Revision 1.1.2.5  1995/06/21  18:37:56  Hans_Graves
 * 	Added ScBSPutBytes()
 * 	[1995/06/21  18:37:08  Hans_Graves]
 *
 * Revision 1.1.2.4  1995/06/15  21:17:55  Hans_Graves
 * 	Changed return type for GetBits() and PeekBits() to ScBitString_t. Added some debug statements.
 * 	[1995/06/15  20:40:54  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/06/09  18:33:28  Hans_Graves
 * 	Fixed up some problems with Bitstream reads from Buffer Queues
 * 	[1995/06/09  16:27:50  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/05/31  18:07:25  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:05:37  Hans_Graves]
 *
 * Revision 1.1.2.3  1995/04/17  18:41:05  Hans_Graves
 * 	Added ScBSPutBits, BSStoreWord, and BSPutData functions
 * 	[1995/04/17  18:40:44  Hans_Graves]
 *
 * Revision 1.1.2.2  1995/04/07  18:22:55  Hans_Graves
 * 	Bitstream and Buffer Queue functions pulled from Sv sources.
 * 	     Added functionality and cleaned up API.
 * 	[1995/04/07  18:21:58  Hans_Graves]
 *
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Bitstream and queue routines
**
** Note: For reading, "BS->shift" refers to the number of bits stored across
**       BS->OutBuff and BS->InBuff
*/
/*
#define _SLIBDEBUG_
*/

#include "SC.h"
#include "SC_err.h"
#include <string.h>
#ifdef WIN32
#include <io.h>
#include <windows.h>
#include <assert.h>
#endif

#ifdef _SLIBDEBUG_
#include <stdio.h>
#define _DEBUG_   0  /* detailed debuging statements */
#define _VERBOSE_ 0  /* show progress */
#define _VERIFY_  1  /* verify correct operation */
#define _WARN_    1  /* warnings about strange behavior */
#define _QUEUE_   0  /* show queue progress */
#define _DUMP_    0  /* dump out buffer data in hex */

int _debug_getbits=TRUE;
long _debug_start=0, _debug_stop=0;
#endif

#define USE_FAST_SEEK   0  /* fast seeking for words in the bistream */

#define FILTER_SUPPORT  0  /* data filtering callback support */

#ifdef __VMS
#define USE_MASK_TABLES
#else
#define USE_MASK_TABLES
#endif

#ifdef USE_MASK_TABLES
/* to mask the n least significant bits of an integer */
#if SC_BITBUFFSZ == 64
const static ScBitString_t mask[65] =
{
(ScBitString_t)0x0000000000000000,(ScBitString_t)0x0000000000000001,
(ScBitString_t)0x0000000000000003,(ScBitString_t)0x0000000000000007,
(ScBitString_t)0x000000000000000f,(ScBitString_t)0x000000000000001f,
(ScBitString_t)0x000000000000003f,(ScBitString_t)0x000000000000007f,
(ScBitString_t)0x00000000000000ff,(ScBitString_t)0x00000000000001ff,
(ScBitString_t)0x00000000000003ff,(ScBitString_t)0x00000000000007ff,
(ScBitString_t)0x0000000000000fff,(ScBitString_t)0x0000000000001fff,
(ScBitString_t)0x0000000000003fff,(ScBitString_t)0x0000000000007fff,
(ScBitString_t)0x000000000000ffff,(ScBitString_t)0x000000000001ffff,
(ScBitString_t)0x000000000003ffff,(ScBitString_t)0x000000000007ffff,
(ScBitString_t)0x00000000000fffff,(ScBitString_t)0x00000000001fffff,
(ScBitString_t)0x00000000003fffff,(ScBitString_t)0x00000000007fffff,
(ScBitString_t)0x0000000000ffffff,(ScBitString_t)0x0000000001ffffff,
(ScBitString_t)0x0000000003ffffff,(ScBitString_t)0x0000000007ffffff,
(ScBitString_t)0x000000000fffffff,(ScBitString_t)0x000000001fffffff,
(ScBitString_t)0x000000003fffffff,(ScBitString_t)0x000000007fffffff,
(ScBitString_t)0x00000000ffffffff,(ScBitString_t)0x00000001ffffffff,
(ScBitString_t)0x00000003ffffffff,(ScBitString_t)0x00000007ffffffff,
(ScBitString_t)0x0000000fffffffff,(ScBitString_t)0x0000001fffffffff,
(ScBitString_t)0x0000003fffffffff,(ScBitString_t)0x0000007fffffffff,
(ScBitString_t)0x000000ffffffffff,(ScBitString_t)0x000001ffffffffff,
(ScBitString_t)0x000003ffffffffff,(ScBitString_t)0x000007ffffffffff,
(ScBitString_t)0x00000fffffffffff,(ScBitString_t)0x00001fffffffffff,
(ScBitString_t)0x00003fffffffffff,(ScBitString_t)0x00007fffffffffff,
(ScBitString_t)0x0000ffffffffffff,(ScBitString_t)0x0001ffffffffffff,
(ScBitString_t)0x0003ffffffffffff,(ScBitString_t)0x0007ffffffffffff,
(ScBitString_t)0x000fffffffffffff,(ScBitString_t)0x001fffffffffffff,
(ScBitString_t)0x003fffffffffffff,(ScBitString_t)0x007fffffffffffff,
(ScBitString_t)0x00ffffffffffffff,(ScBitString_t)0x01ffffffffffffff,
(ScBitString_t)0x03ffffffffffffff,(ScBitString_t)0x07ffffffffffffff,
(ScBitString_t)0x0fffffffffffffff,(ScBitString_t)0x1fffffffffffffff,
(ScBitString_t)0x3fffffffffffffff,(ScBitString_t)0x7fffffffffffffff,
(ScBitString_t)0xffffffffffffffff
};
/* inverse mask */
const static ScBitString_t imask[65] =
{
(ScBitString_t)0xffffffffffffffff,(ScBitString_t)0xfffffffffffffffe,
(ScBitString_t)0xfffffffffffffffc,(ScBitString_t)0xfffffffffffffff8,
(ScBitString_t)0xfffffffffffffff0,(ScBitString_t)0xffffffffffffffe0,
(ScBitString_t)0xffffffffffffffc0,(ScBitString_t)0xffffffffffffff80,
(ScBitString_t)0xffffffffffffff00,(ScBitString_t)0xfffffffffffffe00,
(ScBitString_t)0xfffffffffffffc00,(ScBitString_t)0xfffffffffffff800,
(ScBitString_t)0xfffffffffffff000,(ScBitString_t)0xffffffffffffe000,
(ScBitString_t)0xffffffffffffc000,(ScBitString_t)0xffffffffffff8000,
(ScBitString_t)0xffffffffffff0000,(ScBitString_t)0xfffffffffffe0000,
(ScBitString_t)0xfffffffffffc0000,(ScBitString_t)0xfffffffffff80000,
(ScBitString_t)0xfffffffffff00000,(ScBitString_t)0xffffffffffe00000,
(ScBitString_t)0xffffffffffc00000,(ScBitString_t)0xffffffffff800000,
(ScBitString_t)0xffffffffff000000,(ScBitString_t)0xfffffffffe000000,
(ScBitString_t)0xfffffffffc000000,(ScBitString_t)0xfffffffff8000000,
(ScBitString_t)0xfffffffff0000000,(ScBitString_t)0xffffffffe0000000,
(ScBitString_t)0xffffffffc0000000,(ScBitString_t)0xffffffff80000000,
(ScBitString_t)0xffffffff00000000,(ScBitString_t)0xfffffffe00000000,
(ScBitString_t)0xfffffffc00000000,(ScBitString_t)0xfffffff800000000,
(ScBitString_t)0xfffffff000000000,(ScBitString_t)0xffffffe000000000,
(ScBitString_t)0xffffffc000000000,(ScBitString_t)0xffffff8000000000,
(ScBitString_t)0xffffff0000000000,(ScBitString_t)0xfffffe0000000000,
(ScBitString_t)0xfffffc0000000000,(ScBitString_t)0xfffff80000000000,
(ScBitString_t)0xfffff00000000000,(ScBitString_t)0xffffe00000000000,
(ScBitString_t)0xffffc00000000000,(ScBitString_t)0xffff800000000000,
(ScBitString_t)0xffff000000000000,(ScBitString_t)0xfffe000000000000,
(ScBitString_t)0xfffc000000000000,(ScBitString_t)0xfff8000000000000,
(ScBitString_t)0xfff0000000000000,(ScBitString_t)0xffe0000000000000,
(ScBitString_t)0xffc0000000000000,(ScBitString_t)0xff80000000000000,
(ScBitString_t)0xff00000000000000,(ScBitString_t)0xfe00000000000000,
(ScBitString_t)0xfc00000000000000,(ScBitString_t)0xf800000000000000,
(ScBitString_t)0xf000000000000000,(ScBitString_t)0xe000000000000000,
(ScBitString_t)0xc000000000000000,(ScBitString_t)0x8000000000000000,
(ScBitString_t)0x0000000000000000
};
#else
const static ScBitString_t mask[33] =
{
  0x00000000,0x00000001,0x00000003,0x00000007,
  0x0000000f,0x0000001f,0x0000003f,0x0000007f,
  0x000000ff,0x000001ff,0x000003ff,0x000007ff,
  0x00000fff,0x00001fff,0x00003fff,0x00007fff,
  0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
  0x000fffff,0x001fffff,0x003fffff,0x007fffff,
  0x00ffffff,0x01ffffff,0x03ffffff,0x07ffffff,
  0x0fffffff,0x1fffffff,0x3fffffff,0x7fffffff,
  0xffffffff
};
/* inverse mask */
const static ScBitString_t imask[33] =
{
  0xffffffff,0xfffffffe,0xfffffffc,0xfffffff8,
  0xfffffff0,0xffffffe0,0xffffffc0,0xffffff80,
  0xffffff00,0xfffffe00,0xfffffc00,0xfffff800,
  0xfffff000,0xffffe000,0xffffc000,0xffff8000,
  0xffff0000,0xfffe0000,0xfffc0000,0xfff80000,
  0xfff00000,0xffe00000,0xffc00000,0xff800000,
  0xff000000,0xfe000000,0xfc000000,0xf8000000,
  0xf0000000,0xe0000000,0xc0000000,0x80000000,
  0x00000000
};
#endif
#endif USE_MASK_TABLES
/*********************** Bitstream/Buffer Management *************************/
/*
** sc_GetNextBuffer()
** Release current buffer and return info about buffer at head of queue
** Callbacks are made to 1) release old buffer and 2) ask for more buffers
*/
static u_char *sc_GetNextBuffer(ScBitstream_t *BS, int *BufSize)
{
  u_char *Data;
  int Size;
  ScCallbackInfo_t CB;
  ScQueue_t *Q=BS->Q;

  _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer(Q=%p)\n", Q) );
  if (ScBufQueueGetNum(Q))
  {
    /*
    ** Get pointer to current buffer so we can release it with a callback
    */
    ScBufQueueGetHead(Q, &Data, &Size);

    /*
    ** Remove current buffer from head of queue, replacing it with next in line
    */
    ScBufQueueRemove(Q);

    /*
    ** Make callback to client to tell that old buffer can be reused.
    ** Client may tell us to abort processing. If so, return 0 for BufSize.
    */
    if (BS->Callback && Data) {
      CB.Message = CB_RELEASE_BUFFER;
      CB.Data  = Data;
      CB.DataSize = Size;
      CB.DataUsed = Size;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action  = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      _SlibDebug(_DEBUG_,
         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                CB.Data, CB.Action) );
      if (CB.Action == CB_ACTION_END)
      {
        *BufSize = 0;
        return(NULL);
      }
    }
  }

  /*
  ** If there's no more buffers in queue, make a callback telling client.
  ** Hopefully, client will call ScAddBuffer to add one or more buffers.
  ** If not, or if client tells us to abort, return 0 for BufSize.
  */
  if (!ScBufQueueGetNum(Q)) {
    if (BS->Callback) {
      CB.Message = CB_END_BUFFERS;
      CB.Data     = NULL;
      CB.DataSize = 0;
      CB.DataUsed = 0;
      CB.DataType = BS->DataType;
      CB.UserData = BS->UserData;
      CB.Action   = CB_ACTION_CONTINUE;
      (*(BS->Callback))(BS->Sch, &CB, NULL);
      if (CB.Action == CB_ACTION_END)
      {
	_SlibDebug(_DEBUG_,
           printf("sc_GetNextBuffer() CB.Action = CB_ACTION_END\n") );
        *BufSize = 0;
        return(NULL);
      }
      else
        _SlibDebug(_VERBOSE_, printf("sc_GetNextBuffer() CB.Action = %d\n",
                                  CB.Action) );
    }
    if (!ScBufQueueGetNum(Q)) {
      _SlibDebug(_DEBUG_, printf("sc_GetNextBuffer() no more buffers\n") );
      *BufSize = 0;
      return(NULL);
    }
  }

  /*
  ** Get & return pointer & size of new current buffer
  */
  ScBufQueueGetHead(Q, &Data, BufSize);
  _SlibDebug(_VERBOSE_, printf("New buffer: Addr = 0x%p, size = %d\n",
                                  Data, *BufSize) );
  return(Data);
}

/*************************** Bitstream Management ***************************/
/* Name:  ScBSSetFilter
** Purpose: Set the callback used to filter out data from the Bitstream
*/
ScStatus_t ScBSSetFilter(ScBitstream_t *BS,
                    int (*Callback)(ScBitstream_t *))
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->FilterCallback=Callback;
  BS->FilterBit=BS->CurrentBit;
  BS->InFilterCallback=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreate
** Purpose: Open a Bitstream (no data source)
*/
ScStatus_t ScBSCreate(ScBitstream_t **BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreate()\n"));

  if ((*BS = (ScBitstream_t *)ScAlloc(sizeof(ScBitstream_t))) == NULL)
    return(ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_NULL;
  (*BS)->Mode='r';
  (*BS)->Q=NULL;
  (*BS)->Callback=NULL;
  (*BS)->FilterCallback=NULL;
  (*BS)->FilterBit=0;
  (*BS)->InFilterCallback=FALSE;
  (*BS)->Sch=0;
  (*BS)->DataType=0;
  (*BS)->UserData=NULL;
  (*BS)->FileFd=0;
  (*BS)->RdBuf=NULL;
  (*BS)->RdBufSize=0;
  (*BS)->RdBufAllocated=FALSE;
  (*BS)->shift=0;
  (*BS)->CurrentBit=0;
  (*BS)->buff=0;
  (*BS)->buffstart=0;
  (*BS)->buffp=0;
  (*BS)->bufftop=0;
  (*BS)->OutBuff = 0;
  (*BS)->InBuff = 0;
  (*BS)->Flush = FALSE;
  (*BS)->EOI = FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBuffer
** Purpose: Open a Bitstream using a single Buffer as a data source
*/
ScStatus_t ScBSCreateFromBuffer(ScBitstream_t **BS, u_char *Buffer,
                                    unsigned int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (!Buffer)
     return(ScErrorBadPointer);
  if (BufSize <= 0)
    return(ScErrorBadArgument);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_BUFFER;
  (*BS)->RdBuf=Buffer;
  (*BS)->RdBufSize=BufSize;
  (*BS)->RdBufAllocated=FALSE;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromBufferQueue
** Purpose: Open a Bitstream using a Buffer Queue as a data source
*/
ScStatus_t ScBSCreateFromBufferQueue(ScBitstream_t **BS, ScHandle_t Sch,
                                  int DataType, ScQueue_t *Q,
                    int (*Callback)(ScHandle_t,ScCallbackInfo_t *, void *),
                    void *UserData)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBufferQueue()\n") );
  if (!Q)
     return(ScErrorNullStruct);
  if (!Callback)
     return(ScErrorBadPointer);
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_QUEUE;
  (*BS)->Q=Q;
  (*BS)->Callback=Callback;
  (*BS)->Sch=Sch;
  (*BS)->DataType=DataType;
  (*BS)->UserData=UserData;
  return(ScErrorNone);
}


/* Name:  ScBSCreateFromFile
** Purpose: Open a Bitstream using a file as a data source
*/
ScStatus_t ScBSCreateFromFile(ScBitstream_t **BS, int FileFd,
                                 u_char *Buffer, int BufSize)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromFile()\n") );

  if (BufSize < SC_BITBUFFSZ)
    return(ScErrorBadArgument);
  if (FileFd < 0)
    return(ScErrorBadArgument);

  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_FILE;
  (*BS)->FileFd=FileFd;
  if (Buffer==NULL)  /* if no buffer provided, alloc one */
  {
    if (((*BS)->RdBuf=(u_char *)ScAlloc(BufSize))==NULL)
    {
      ScFree(*BS);
      *BS=NULL;
      return (ScErrorMemory);
    }
    (*BS)->RdBufAllocated=TRUE;
  }
  else
  {
    (*BS)->RdBufAllocated=FALSE;
    (*BS)->RdBuf=Buffer;
  }
  (*BS)->RdBufSize=BufSize;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromNet
** Purpose: Open a Bitstream using a network socket as a data source
*/
ScStatus_t ScBSCreateFromNet(ScBitstream_t **BS, int SocketFd,
                                u_char *Buffer, int BufSize)
{
  ScStatus_t stat;
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromNet(SocketFd=%d)\n", SocketFd) );
  stat=ScBSCreateFromFile(BS, SocketFd, Buffer, BufSize);
  if (stat!=NoErrors)
    return(stat);
  (*BS)->DataSource = STREAM_USE_NET;
  return(ScErrorNone);
}

/* Name:  ScBSCreateFromDevice
** Purpose: Open a Bitstream using a device (i.e. WAVE_MAPPER)
*/
ScStatus_t ScBSCreateFromDevice(ScBitstream_t **BS, int device)
{
  _SlibDebug(_VERBOSE_, printf("ScBSCreateFromBuffer()\n") );
  if (ScBSCreate(BS) != ScErrorNone)
     return (ScErrorMemory);

  (*BS)->DataSource = STREAM_USE_DEVICE;
  (*BS)->Device=device;
  return(ScErrorNone);
}


/*
** Name:    ScBSSeekToPosition()
** Purpose: Position the bitstream to a specific byte offset.
*/
ScStatus_t ScBSSeekToPosition(ScBitstream_t *BS, unsigned long pos)
{
#ifndef SEEK_SET
#define SEEK_SET 0
#endif
  ScCallbackInfo_t CB;
  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekToPosition(pos=%d 0x%X) from %d (0x%X)\n",
                       pos, pos, ScBSBytePosition(BS),ScBSBytePosition(BS)) );
  BS->shift=0;
  BS->OutBuff = 0;
  BS->InBuff = 0;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (pos==0)
          {
            if (BS->Mode=='w')
            {
              BS->buff = BS->RdBuf;
              BS->bufftop = BS->RdBufSize;
            }
            else
            {
              BS->buff = 0;
              BS->bufftop = 0;
            }
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else
            BS->EOI = TRUE;
          break;
    case STREAM_USE_QUEUE:
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop) && pos>0)
          {
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          else /* use callback to reset buffer position */
          {
            int datasize;
            /* Release the current buffer */
            if (BS->Callback && BS->buff)
            {
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data = BS->buff;
              CB.DataSize = BS->bufftop;
              CB.DataUsed = BS->buffp;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*(BS->Callback))(BS->Sch, &CB, NULL);
              _SlibDebug(_VERBOSE_,
                         printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
            }
            /* Remove all buffers from queue */
            while (ScBufQueueGetNum(BS->Q))
            {
              ScBufQueueGetHead(BS->Q, &CB.Data, &datasize);
              ScBufQueueRemove(BS->Q);
              if (BS->Callback && CB.Data)
              {
                CB.Message = CB_RELEASE_BUFFER;
                CB.DataSize = datasize;
                CB.DataUsed = 0;
                CB.DataType = BS->DataType;
                CB.UserData = BS->UserData;
                CB.Action  = CB_ACTION_CONTINUE;
                (*(BS->Callback))(BS->Sch, &CB, NULL);
                _SlibDebug(_VERBOSE_,
                           printf("Callback: RELEASE_BUFFER. Addr = 0x%x, Client response = %d\n",
                           CB.Data, CB.Action) );
              }
            }
            BS->buffp=0;
            BS->buff=NULL;
            if (CB.Action == CB_ACTION_END)
            {
              BS->EOI = TRUE;
              return(ScErrorClientEnd);
            }
            else
            {
              BS->buffstart=pos;
              BS->bufftop=0;
              BS->EOI = FALSE;
            }
          }
          break;
    case STREAM_USE_FILE:
          /*
          ** check if the desired position is within the
          ** current buffer
          */
          if (pos>=BS->buffstart && pos<(BS->buffstart+BS->bufftop))
          {
            _SlibDebug(_VERBOSE_, printf("pos is in BS->buff, BS->bufftop=%d\n",
                                        BS->bufftop) );
            BS->buffp=pos-BS->buffstart;
            BS->EOI = FALSE;
          }
          /* otherwise seek to it */
	  else if (ScFileSeek(BS->FileFd, pos)==NoErrors)
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X)\n",pos,pos) );
            BS->buffstart=pos;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = FALSE;
          }
          else
          {
            _SlibDebug(_VERBOSE_, printf("seek(%d 0x%X) failed\n",pos,pos) );
            BS->buffstart=0;
            BS->bufftop=0;
            BS->buffp=0;
            BS->EOI = TRUE;
          }
          break;
    default:
          BS->buffstart=0;
          BS->EOI = FALSE;
  }
  BS->CurrentBit=pos<<3;
  _SlibDebug(_VERBOSE_, printf("ScBSSeekToPosition() done\n") );
  return(ScErrorNone);
}

/*
** Name:    ScBSReset()
** Purpose: Reset the bitstream back to the beginning.
*/
ScStatus_t ScBSReset(ScBitstream_t *BS)
{
  _SlibDebug(_VERBOSE_, printf("ScBSReset()\n") );
  BS->EOI=FALSE;
  if (BS->DataSource==STREAM_USE_FILE)
  {
    /*
    ** for files always empty buffer and seek to beginning
    ** just in case the file descriptor was used for something else
    */
    _SlibDebug(_VERBOSE_, printf("seek(0)\n") );
	ScFileSeek(BS->FileFd, 0);
    BS->bufftop=0;  /* empty buffer */
    BS->buffp=0;
    BS->buffstart=0;
  }
  BS->Flush=FALSE;
  return(ScBSSeekToPosition(BS, 0));
}

/*
** Name:    sc_BSGetData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
** Returns: TRUE if data read
**          FALSE if none read (EOI)
*/
static u_int sc_BSGetData(ScBitstream_t *BS)
{
  int BufSize;

  _SlibDebug(_VERBOSE_, printf("sc_BSGetData\n") );
  BS->buffp = 0;
  if (BS->EOI)
  {
    BS->buff = NULL;
    BS->bufftop = 0;
    return(FALSE);
  }
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          if (BS->buff == BS->RdBuf)
          {
            BS->buff = NULL;
            BS->bufftop = 0;
          }
          else
          {
            BS->buff = BS->RdBuf;
            BS->bufftop = BS->RdBufSize;
          }
          break;
    case STREAM_USE_QUEUE:
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() QUEUE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BS->buff = sc_GetNextBuffer(BS, &BufSize);
          BS->bufftop = BufSize;
          break;
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
    case STREAM_USE_FILE:
          BS->buff = BS->RdBuf;
          BS->buffstart+=BS->bufftop;
          _SlibDebug(_VERIFY_ && BS->buffstart<(BS->CurrentBit/8),
            printf("ScBSGetData() FILE buffstart(%d/0x%X) < currentbyte(%d/0x%X)\n",
             BS->buffstart, BS->buffstart, BS->CurrentBit/8, BS->CurrentBit/8);
            return(FALSE) );
          BufSize = ScFileRead(BS->FileFd, BS->buff, BS->RdBufSize);
          if (BufSize<0)
            BS->bufftop = 0;
          else
            BS->bufftop = BufSize;
          _SlibDebug(_VERBOSE_,
                      printf("%d bytes read from fd %d: BytePosition=%d (0x%X) RdBufSize=%d\n buffstart=%d (0x%X)",
                        BS->bufftop,BS->FileFd,ScBSBytePosition(BS),
                        ScBSBytePosition(BS),BS->RdBufSize,
                        BS->buffstart,BS->buffstart) );
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->bufftop   =10240;
          BS->buffstart+=10240;
          break;
  }
  _SlibDebug(_DUMP_ && BS->buff && BS->bufftop &&
                      BS->DataSource==STREAM_USE_QUEUE,
            printf("sc_BSGetData():\n");
            ScDumpChar(BS->buff, BS->bufftop, BS->buffstart);
            if (BS->bufftop>0x8000)  /* show end of buffer */
              ScDumpChar(BS->buff+BS->bufftop-0x500, 0x500,
                         BS->buffstart+BS->bufftop-0x500) );

  if (BS->buff && BS->bufftop)
    return(TRUE);
  else
    return(FALSE);
}

/*
** Name:    sc_BSPutData()
** Purpose: Set the bitstream pointer to the next buffer in the buffer
**          queue, or if we're using simple file IO, read from the file.
*/
static ScStatus_t sc_BSPutData(ScBitstream_t *BS)
{
  ScStatus_t stat;
  int written;

  _SlibDebug(_VERBOSE_, printf("sc_BSPutData\n") );
  BS->Flush=FALSE;
  switch (BS->DataSource)
  {
    case STREAM_USE_BUFFER:
          stat=ScErrorEndBitstream;
          break;
    case STREAM_USE_QUEUE:
          if (BS->Callback)
          {
            ScCallbackInfo_t CB;
            if (BS->buff)
            {
              _SlibDebug(_VERBOSE_, printf("Callback CB_RELEASE_BUFFERS\n"));
              CB.Message = CB_RELEASE_BUFFER;
              CB.Data  = BS->buff;
              CB.DataSize = BS->buffp;
              CB.DataUsed = CB.DataSize;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action  = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              BS->buff = 0;
              BS->bufftop = 0;
              BS->buffp=0;
              if (CB.Action == CB_ACTION_END)
                return(ScErrorClientEnd);
            }
            else
              BS->bufftop = 0;
            if (!BS->Q)
              stat=ScErrorEndBitstream;
            else
            {
              _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
              CB.Message  = CB_END_BUFFERS;
              CB.Data     = NULL;
              CB.DataSize = 0;
              CB.DataUsed = 0;
              CB.DataType = BS->DataType;
              CB.UserData = BS->UserData;
              CB.Action   = CB_ACTION_CONTINUE;
              (*BS->Callback)(BS->Sch, &CB, NULL);
              if (CB.Action != CB_ACTION_CONTINUE ||
                   ScBufQueueGetNum(BS->Q)==0)
                stat=ScErrorEndBitstream;
              else
              {
                int size;
                ScBufQueueGetHead(BS->Q, &BS->buff, &size);
                BS->bufftop=size;
                ScBufQueueRemove(BS->Q);
                if (!BS->buff || size<=0)
                  stat=ScErrorEndBitstream;
                else
                  stat=NoErrors;
              }
            }
          }
          else
          {
            BS->buff = 0;
            BS->bufftop = 0;
          }
          BS->buffp=0;
          break;
    case STREAM_USE_FILE:
    case STREAM_USE_NET:
    case STREAM_USE_NET_UDP:
          if (BS->buffp>0)
          {
            written=ScFileWrite(BS->FileFd, BS->buff, BS->buffp);
            _SlibDebug(_VERBOSE_,
                       printf("%d bytes written to fd %d (buffer=%d bytes)\n",
                                             written, BS->FileFd, BS->buffp) );
            _SlibDebug(_DUMP_,
                printf("sc_BSPutData():\n");
                ScDumpChar(BS->buff, BS->buffp, BS->buffstart));
            if (written<(int)BS->buffp)
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop=0;
              stat=ScErrorEndBitstream;
            }
            else
            {
              BS->buff = BS->RdBuf;
              BS->buffp=0;
              BS->bufftop = BS->RdBufSize;
              stat=NoErrors;
            }
          }
          break;
    case STREAM_USE_NULL:
          BS->buff = NULL;
          BS->buffp=0;
          BS->bufftop = 10240;
          break;
    default:
          stat=ScErrorEndBitstream;
  }

  return(stat);
}

/*
** Name:    sc_BSLoadDataWord
** Purpose: Copy a longword from the bitstream buffer into local working buffer
*/
ScStatus_t sc_BSLoadDataWord(ScBitstream_t *BS)
{
  int i, bcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_char *buff=BS->buff+buffp;

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[7];
    InBuff|=(ScBitBuff_t)buff[6]<<8;
    InBuff|=(ScBitBuff_t)buff[5]<<16;
    InBuff|=(ScBitBuff_t)buff[4]<<24;
    InBuff|=(ScBitBuff_t)buff[3]<<32;
    InBuff|=(ScBitBuff_t)buff[2]<<40;
    InBuff|=(ScBitBuff_t)buff[1]<<48;
    InBuff|=(ScBitBuff_t)buff[0]<<56;
    _SlibDebug(_VERIFY_ && (u_char)((InBuff>>24)&0xFF)!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[4](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (u_char)(InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<8;
    InBuff|=(ScBitBuff_t)buff[1]<<16;
    InBuff|=(ScBitBuff_t)buff[0]<<24;
    _SlibDebug(_VERIFY_ && (InBuff>>24)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/8; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    bcount = SC_BITBUFFSZ/8;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    bcount = BS->bufftop - buffp;
    for (InBuff=0, i = bcount; i > 0; i--, buff++)
      InBuff = (InBuff << 8) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+bcount;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/8) - bcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d bytes got %d bytes.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        bcount+=i;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(bcount*8);
      }
      else
      {
        bcount = SC_BITBUFFSZ/8;
        while (i > 0)
        {
	  InBuff = (InBuff << 8) | (ScBitBuff_t)BS->buff[BS->buffp++];
          i--;
        }
      }
    }
    else if (bcount==0)
      BS->EOI = TRUE;
    else
      InBuff <<= SC_BITBUFFSZ-bcount*8;
  }

  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWord(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=bcount*8;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(bcount*8);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=bcount*8;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}
/*
** Name:    sc_BSLoadDataWordW
** Purpose: Copy a longword from the bitstream buffer into local working buffer
**		** This version operates a word at a time for Dolby **
*/
ScStatus_t sc_BSLoadDataWordW(ScBitstream_t *BS)
{
  int i, wcount;
  register ScBitBuff_t InBuff;
  const int shift=BS->shift;
  const u_int buffp=BS->buffp;
  register u_short *buff=(u_short *)BS->buff+(buffp/2);

  _SlibDebug(_DEBUG_,
          printf("sc_BSLoadDataWord(BS=%p) shift=%d bit=%d byte=%d (0x%X)\n",
          BS, BS->shift, BS->CurrentBit, BS->CurrentBit/8, BS->CurrentBit/8) );
  /* If we have plenty of room, use fast path */
  if (BS->bufftop - buffp >= SC_BITBUFFSZ/8)
  {
#if SC_BITBUFFSZ == 64
    InBuff=(ScBitBuff_t)buff[3];
    InBuff|=(ScBitBuff_t)buff[2]<<16;
    InBuff|=(ScBitBuff_t)buff[1]<<32;
    InBuff|=(ScBitBuff_t)buff[0]<<48;
    _SlibDebug(_VERIFY_ && (InBuff>>24)&0xFFFF!=buff[4],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, (InBuff>>24)&0xFF, buff[4]) );
    _SlibDebug(_VERIFY_ && (InBuff>>56)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>56(%X)!=buff[0](%X)\n",
           BS, (InBuff>>56), buff[0]) );
#elif SC_BITBUFFSZ == 32
    InBuff=(ScBitBuff_t)buff[1];
    InBuff|=(ScBitBuff_t)buff[0]<<16;
    _SlibDebug(_VERIFY_ && (InBuff>>16)!=buff[0],
           printf("sc_BSLoadDataWord(BS=%p) InBuff>>24(%X)!=buff[0](%X)\n",
           BS, InBuff>>24, buff[0]) );
#else
    printf("SC_BITBUFFSZ <> 32\n");
    for (InBuff=0, i = SC_BITBUFFSZ/16; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
#endif
    BS->buffp=buffp+SC_BITBUFFSZ/8;
    wcount = SC_BITBUFFSZ/16;
  }
  /* Near or at end of buffer */
  else
  {
    /* Get remaining bytes */
    wcount = (BS->bufftop - buffp)/2;
    for (InBuff=0, i = wcount; i > 0; i--, buff++)
      InBuff = (InBuff << 16) | (ScBitBuff_t)*buff;
    BS->buffp=buffp+wcount*2;
    /* Attempt to get more data - if successful, shuffle rest of bytes */
    if (sc_BSGetData(BS))
    {
	  int wordp=BS->buffp/2;	/* Pointer is stored as a byte count, but we need words */

      BS->EOI = FALSE;
      i = (SC_BITBUFFSZ/16) - wcount;
      if (i>(int)BS->bufftop)
      {
        _SlibDebug(_WARN_,
           printf("ScBSLoadDataWord() Got small buffer. Expected %d words got %d words.\n",
                     i, BS->bufftop) );
        i=BS->bufftop;
        wcount+=i;
        while (i >= 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
        InBuff<<=SC_BITBUFFSZ-(wcount*16);
      }
      else
      {
        wcount = SC_BITBUFFSZ/16;
        while (i > 0)
        {
	  InBuff = (InBuff << 16) | (ScBitBuff_t)((u_short *)BS->buff)[wordp++];
          i--;
        }
      }
	  BS->buffp=wordp*2;
    }
    else
      BS->EOI = TRUE;
  }
  _SlibDebug(_VERIFY_ && BS->shift>SC_BITBUFFSZ,
           printf("sc_BSLoadDataWordW(BS=%p) shift (%d) > SC_BITBUFFSZ (%d)\n",
           BS, BS->shift, SC_BITBUFFSZ) );
  if (!shift) /* OutBuff is empty */
  {
    BS->OutBuff = InBuff;
    BS->InBuff = 0;
    BS->shift=wcount*16;
  }
  else if (shift<SC_BITBUFFSZ)
  {
    BS->OutBuff |= InBuff >> shift;
    BS->InBuff = InBuff << (SC_BITBUFFSZ-shift);
    BS->shift=shift+(wcount*16);
  }
  else /* shift == SC_BITBUFFSZ - OutBuff is full */
  {
    BS->InBuff = InBuff;
    BS->shift=wcount*16;
  }
  _SlibDebug(_VERIFY_,
    if (BS->shift<SC_BITBUFFSZ)
    {
      if (BS->OutBuff & (SC_BITBUFFMASK>>BS->shift))
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of OutBuff: shift=%d\n", BS, BS->shift);
      else if (BS->InBuff)
        printf("sc_BSLoadDataWord(BS=%p) Non-zero bits in InBuff: shift=%d\n",
           BS, BS->shift);
    }
    else if (BS->InBuff&(SC_BITBUFFMASK>>(BS->shift-SC_BITBUFFSZ)))
      printf("sc_BSLoadDataWord(BS=%p) Non-zero bits to right of InBuff: shift=%d\n", BS->shift);
    if ((BS->CurrentBit%8) && !(BS->shift%8))
      printf("sc_BSLoadDataWord(BS=%p) CurrentBit (%d) and shift (%d) not aligned.\n", BS, BS->CurrentBit, BS->shift);
    if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
    {
      printf("sc_BSLoadDataWord(BS=%p) (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", BS, (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
      BS->EOI = TRUE;
      return(ScErrorEndBitstream);
    }
  );
  return(NoErrors);
}

/*
** Name:    sc_BSStoreDataWord
** Purpose: Copy a longword from the local working buffer to the
**          bitstream buffer
*/
ScStatus_t sc_BSStoreDataWord(ScBitstream_t *BS, ScBitBuff_t OutBuff)
{
  int i, bcount, shift=SC_BITBUFFSZ-8;
  ScStatus_t stat=NoErrors;

  _SlibDebug(_VERBOSE_,
             printf("sc_BSStoreDataWord(0x%lX 0x%lX) buffp=%d\n",
                            OutBuff>>32, OutBuff&0xFFFFFFFF, BS->buffp) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  if (!BS->buff || BS->bufftop<=0)
  {
    if (BS->DataSource==STREAM_USE_QUEUE)
    {
      if (BS->Callback && BS->Q)
      {
        ScCallbackInfo_t CB;
        _SlibDebug(_DEBUG_, printf("Callback CB_END_BUFFERS\n") );
        CB.Message  = CB_END_BUFFERS;
        CB.Data     = NULL;
        CB.DataSize = 0;
        CB.DataUsed = 0;
        CB.DataType = BS->DataType;
        CB.UserData = BS->UserData;
        CB.Action   = CB_ACTION_CONTINUE;
        (*BS->Callback)(BS->Sch, &CB, NULL);
        if (CB.Action != CB_ACTION_CONTINUE || ScBufQueueGetNum(BS->Q)==0)
        {
          BS->EOI = TRUE;
          return(ScErrorEndBitstream);
        }
        else
        {
          int size;
          ScBufQueueGetHead(BS->Q, &BS->buff, &size);
          BS->bufftop=size;
          ScBufQueueRemove(BS->Q);
          if (!BS->buff || size<=0)
          {
            BS->EOI = TRUE;
            return(ScErrorEndBitstream);
          }
          BS->EOI = FALSE;
        }
      }
      else
      {
        BS->EOI = TRUE;
        return(ScErrorEndBitstream);
      }
    }
    else if (BS->RdBuf)
    {
      BS->buff=BS->RdBuf;
      BS->bufftop=BS->RdBufSize;
    }
  }
  bcount = BS->bufftop - BS->buffp;
  /* If we have plenty of room, use fast path */
  if (bcount >= SC_BITBUFFSZ>>3) {
    u_char *buff=BS->buff+BS->buffp;
#if SC_BITBUFFSZ == 64
    buff[0]=(unsigned char)(OutBuff>>56);
    buff[1]=(unsigned char)(OutBuff>>48);
    buff[2]=(unsigned char)(OutBuff>>40);
    buff[3]=(unsigned char)(OutBuff>>32);
    buff[4]=(unsigned char)(OutBuff>>24);
    buff[5]=(unsigned char)(OutBuff>>16);
    buff[6]=(unsigned char)(OutBuff>>8);
    buff[7]=(unsigned char)OutBuff;
#elif SC_BITBUFFSZ == 32
    buff[0]=(unsigned char)(OutBuff>>24);
    buff[1]=(unsigned char)(OutBuff>>16);
    buff[2]=(unsigned char)(OutBuff>>8);
    buff[3]=(unsigned char)OutBuff;
#else
    for (bcount = SC_BITBUFFSZ/8; bcount; shift-=8, bcount--, buff++)
      *buff=(Buff>>shift)&0xFF;
#endif
    BS->buffp+=SC_BITBUFFSZ/8;
    if (BS->Flush && sc_BSPutData(BS)!=NoErrors)
      BS->EOI=TRUE;
  }
  else /* Near end of buffer */
  {
    /* Fill up current buffer */
    for (i=0; i<bcount; shift-=8, i++)
      BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    /* Commit the buffer */
    if ((stat=sc_BSPutData(BS))==NoErrors)
    {
      /* Successful, so copy rest of bytes to new buffer */
      bcount = (SC_BITBUFFSZ>>3) - bcount;
      for (i=0; i<bcount; shift-=8, i++)
        BS->buff[BS->buffp++]=(unsigned char)(OutBuff>>shift);
    }
    else
      BS->EOI=TRUE;
  }
  BS->Mode='w';
  return(stat);
}

/*
** ScBSSkipBits()
** Skip a certain number of bits
**
*/
ScStatus_t ScBSSkipBits(ScBitstream_t *BS, u_int length)
{
  register u_int skipbytes, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBits(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBits(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoad(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBits() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipbytes=length>>3;
  skipbits=length%8;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBits() Skipping odd amount: skipbytes=%d skipbits=%d\n",
               skipbytes, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipbytes>=(BS->bufftop - BS->buffp))
  {
    /* discard current block of data */
    BS->CurrentBit+=(BS->bufftop - BS->buffp)<<3;
    skipbytes-=BS->bufftop - BS->buffp;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipbytes)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipbytes;
    BS->CurrentBit+=skipbytes<<3;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoad(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBitsW()
** Skip a certain number of bits
** ** Dolby version **
*/
ScStatus_t ScBSSkipBitsW(ScBitstream_t *BS, u_int length)
{
  register u_int skipwords, skipbits;
  register int shift;
  _SlibDebug(_DEBUG_, printf("ScBSSkipBitsW(%d): Byte offset = 0x%X\n",length,
                                                    ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSSkipBitsW(%d) length==0\n", length) );
  _SlibDebug(_WARN_ && length>SC_BITBUFFSZ,
         printf("ScBSSkipBits(%d) length > SC_BITBUFFSZ (%d)\n",
                        length, SC_BITBUFFSZ) );
  if (length<=SC_BITBUFFSZ)
    ScBSPreLoadW(BS, length);
  if ((shift=BS->shift)>0)
  {
    if (length<=(u_int)shift) /* all the bits are already in OutBuff & InBuff */
    {
      if (length==SC_BITBUFFSZ)
      {
        BS->OutBuff=BS->InBuff;
        BS->InBuff=0;
      }
      else
      {
        BS->OutBuff=(BS->OutBuff<<length)|(BS->InBuff>>(SC_BITBUFFSZ-length));
        BS->InBuff<<=length;
      }
      BS->CurrentBit+=length;
      BS->shift=shift-length;
      return(NoErrors);
    }
    else /* discard all the bits in OutBuff & InBuff */
    {
      length-=shift;
      BS->OutBuff=BS->InBuff=0;
      BS->CurrentBit+=shift;
      BS->shift=0;
    }
  }
  _SlibDebug(_VERIFY_ && (BS->shift || BS->CurrentBit%8),
            printf("ScBSSkipBitsW() Bad Alignment - shift=%d CurrentBit=%d\n",
                BS->shift, BS->CurrentBit) );

  skipwords=length>>4;
  skipbits=length%16;
  _SlibDebug(_WARN_ && skipbits,
     printf("ScBSSkipBitsW() Skipping odd amount: skipwords=%d skipbits=%d\n",
               skipwords, skipbits) );
  if (BS->EOI)
    return(ScErrorEndBitstream);
  while (skipwords>=(BS->bufftop - BS->buffp)/2)
  {
    /* discard current block of data */
    BS->CurrentBit+=((BS->bufftop - BS->buffp)/2)<<4;
    skipwords-=(BS->bufftop - BS->buffp)/2;
    BS->buffp=0;
    /* get another block */
    if (sc_BSGetData(BS))
      BS->EOI = FALSE;
    else
    {
      BS->EOI = TRUE;
      BS->shift=0;
      return(ScErrorEndBitstream);
    }
  }
  if (skipwords)
  {
    /* skip forward in current block of data */
    BS->buffp+=skipwords*2;
    BS->CurrentBit+=skipwords<<4;
  }
  if (skipbits)
  {
    /* skip odd number of bits - between 0 and 7 bits */
    ScBSPreLoadW(BS, skipbits);
    BS->OutBuff<<=skipbits;
    BS->CurrentBit += skipbits;
    BS->shift-=skipbits;
  }
  return(NoErrors);
}


/*
** ScBSSkipBytes()
** Skip a certain number of bytes
**
*/
ScStatus_t ScBSSkipBytes(ScBitstream_t *BS, u_int length)
{
  return(ScBSSkipBits(BS, length<<3));
}


/*
** ScBSPeekBits()
** Return the next length bits from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBits(ScBitstream_t *BS, u_int length)
{
  _SlibDebug(_DEBUG_,
         printf("ScBSPeekBits(%d): Byte offset = 0x%X OutBuff=0x%lX\n",length,
                                   ScBSBytePosition(BS),BS->OutBuff) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSPeekBits(%d) length==0\n", length) );
  if (length==0)
    return(0);
  ScBSPreLoad(BS, length);
  _SlibDebug(_VERIFY_ && BS->shift<length,
    printf("ScBSPeekBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}


/*
** ScBSPeekBit()
** Return the next bit from the bitstream without
** removing it.
*/
int ScBSPeekBit(ScBitstream_t *BS)
{
  _SlibDebug(_DEBUG_,
             printf("ScBSPeekBit(): Byte offset = 0x%X OutBuff=0x%lX\n",
                                   ScBSBytePosition(BS),BS->OutBuff) );
  ScBSPreLoad(BS, 1);
  return((int)(BS->OutBuff >> (SC_BITBUFFSZ-1)));
}


/*
** ScBSPeekBytes()
** Return the next length bytes from the bitstream without
** removing them.
*/
ScBitString_t ScBSPeekBytes(ScBitstream_t *BS, u_int length)
{
  if (length==0)
    return(0);
  length*=8;
  ScBSPreLoad(BS, length);
  if (length == SC_BITBUFFSZ)
    return(BS->OutBuff);
  else
    return(BS->OutBuff >> (SC_BITBUFFSZ-length));
}

/*
** ScBSGetBytes()
** Return the next length bytes from the bitstream
*/
ScStatus_t ScBSGetBytes(ScBitstream_t *BS, u_char *buffer, u_int length,
                                                 u_int *ret_length)
{
  int i, shift;
  unsigned int offset=0;
  _SlibDebug(_VERBOSE_, printf("ScBSGetBytes(%d): Byte offset = 0x%X\n",
                             length, ScBSBytePosition(BS)) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBytes(%d) length==0\n", length) );

  if (BS->EOI)
  {
    *ret_length=0;
    return(ScErrorEndBitstream);
  }
  if (length<(SC_BITBUFFSZ>>3))
  {
    while (offset<length && !BS->EOI)
    {
      *(buffer+offset)=(unsigned char)ScBSGetBits(BS,8);
      offset++;
    }
    *ret_length=offset;
    if (BS->EOI)
      return(ScErrorEndBitstream);
    else
      return(ScErrorNone);
  }
  else if (BS->bufftop>0)
  {
    ScBSByteAlign(BS);
    shift=BS->shift;
    /* remove bytes already in OutBuff and InBuff */
    for (i=0; shift>0 && offset<length; i++, shift-=8, offset++)
    {
      *(buffer+offset)=(unsigned char)(BS->OutBuff>>(SC_BITBUFFSZ-8));
      if (shift<=SC_BITBUFFSZ) /* only bits in OutBuff */
        BS->OutBuff <<= 8;
      else
      {
        BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
        BS->InBuff<<=8;
      }
    }
    BS->shift=shift;
    BS->CurrentBit+=i*8;
  }
  while (offset<length)
  {
    i=BS->bufftop-BS->buffp;
    if (offset+i>length)
      i=length-offset;
    memcpy(buffer+offset, BS->buff+BS->buffp, i);
    offset+=i;
    BS->buffp+=i;
    BS->CurrentBit+=i<<3;
    _SlibDebug(_VERIFY_,
         if ((BS->CurrentBit+BS->shift)/8!=BS->buffstart+BS->buffp)
         {
           printf("ScBSGetBytes() (CurrentBit+shift)/8 (%d) <> buffstart+buffp (%d)\n", (BS->CurrentBit+BS->shift)/8, BS->buffstart+BS->buffp);
           BS->EOI = TRUE;
           return(ScErrorEndBitstream);
         } );
    if (offset<length)
      if (!sc_BSGetData(BS))
      {
        BS->EOI = TRUE;
        *ret_length=offset;
        return(ScErrorEndBitstream);
      }
  }
  *ret_length=offset;
  return(ScErrorNone);
}

/*
** ScBSGetBits()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBits(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBits(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBits(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBits(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoad(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSGetBitsW()
** Return the next length bits from the bitstream
*/
ScBitString_t ScBSGetBitsW(ScBitstream_t *BS, u_int length)
{
  ScBitString_t val;

  _SlibDebug(_DEBUG_ && _debug_getbits,
             printf("ScBSGetBitsW(%d): Byte offset = 0x%X shift=%d ",
                             length, ScBSBytePosition(BS), BS->shift) );
  _SlibDebug(_VERIFY_ && length>SC_BITBUFFSZ,
         printf("ScBSPeekBits(%d) length > SC_BITBUFFSZ\n", length) );
  _SlibDebug(_WARN_ && length==0,
         printf("ScBSGetBitsW(%d) length==0\n", length) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit<(BS->CurrentBit+length))
  {
    const int tmp=BS->FilterBit-BS->CurrentBit;
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X GetBits(%d/%d)\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS),
                  tmp, length-tmp) );
    if (tmp>0)
    {
      length-=tmp;
      val=ScBSGetBitsW(BS,tmp)<<length;
    }
    else
      val=0;
    _SlibDebug(_VERIFY_ && (BS->FilterBit != BS->CurrentBit),
          printf("ScBSGetBits() FilterCallback not at FilterBit (%d) CurrentBit=%d\n", BS->FilterBit, BS->CurrentBit) );

    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
  else
    val=0;
  if (!length)
    return(val);
#else
  if (!length)
    return(0);
#endif
  ScBSPreLoadW(BS, length);
  if (BS->shift<length) /* End of Input - ran out of bits */
  {
#if FILTER_SUPPORT
    val |= BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#else
    val = BS->OutBuff >> (SC_BITBUFFSZ-length); /* return whatever's there */
#endif
    BS->shift=0;
    BS->OutBuff=0;
    return(val);
  }
  else
  {
    _SlibDebug(_VERIFY_ && BS->shift<length,
     printf("ScBSGetBits(%d) shift (%d) < length (%d) at byte pos %d (0x%X)\n",
             length, BS->shift, length, BS->CurrentBit/8, BS->CurrentBit/8) );
    if (length!=SC_BITBUFFSZ)
    {
      const ScBitBuff_t OutBuff=BS->OutBuff;
      const ScBitString_t InBuff=BS->InBuff;
      const int shift=BS->shift;
#if FILTER_SUPPORT
      val |= OutBuff >> (SC_BITBUFFSZ-length);
#else
      val = OutBuff >> (SC_BITBUFFSZ-length);
#endif
      BS->OutBuff=(OutBuff<<length)|(InBuff>>(SC_BITBUFFSZ-length));
      BS->InBuff = InBuff<<length;
      BS->shift=shift-length;
      BS->CurrentBit += length;
    }
    else /* length == SC_BITBUFFSZ */
    {
      val = BS->OutBuff;
      BS->OutBuff = BS->InBuff;
      BS->InBuff = 0;
      BS->shift-=SC_BITBUFFSZ;
      BS->CurrentBit += SC_BITBUFFSZ;
    }
  }
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}


/*
** ScBSGetBit()
** Put a single bit onto the bitstream
*/
int ScBSGetBit(ScBitstream_t *BS)
{
  int val;
  _SlibDebug(_DEBUG_ && _debug_getbits,
    printf("ScBSGetBit(): Byte offset = 0x%X shift=%d ",
                                         ScBSBytePosition(BS), BS->shift) );

#if FILTER_SUPPORT
  if (BS->FilterCallback && BS->InFilterCallback==FALSE
      && BS->FilterBit==BS->CurrentBit)
  {
    BS->InFilterCallback=TRUE;
    _SlibDebug(_DEBUG_,
          printf("FilterCallback at bitpos=0x%X bytepos=0x%X\n",
                  ScBSBitPosition(BS), ScBSBytePosition(BS)) );
    BS->FilterBit=(BS->FilterCallback)(BS);
    BS->InFilterCallback=FALSE;
  }
#endif

  ScBSPreLoad(BS, 1);
  if (!BS->EOI)
  {
    const ScBitBuff_t OutBuff=BS->OutBuff;
    val=(int)(OutBuff>>(SC_BITBUFFSZ-1));
    if (--BS->shift>=SC_BITBUFFSZ)
    {
      const ScBitBuff_t InBuff=BS->InBuff;
      BS->OutBuff = (OutBuff<<1)|(InBuff >> (SC_BITBUFFSZ-1));
      BS->InBuff = InBuff<<1;
    }
    else
      BS->OutBuff = OutBuff<<1;
    BS->CurrentBit++;
  }
  else
    val=0;
  _SlibDebug(_DEBUG_ && _debug_getbits, printf(" Return 0x%lX\n",val) );
  return(val);
}

/*
** ScBSPutBits()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBits(ScBitstream_t *BS, ScBitString_t bits, u_int length)
{
  ScStatus_t stat;
  const int newshift=BS->shift+length;

  if (length<SC_BITBUFFSZ)
    bits &= ((ScBitString_t)1<<length)-1;
  _SlibDebug(_DEBUG_, printf("ScBSPutBits(0x%lX, %d): Byte offset = 0x%X ",
                                       bits, length, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_&&length<SC_BITBUFFSZ && bits>=((ScBitString_t)1<<length),
            printf("ScBSPutBits(%d): bits (0x%X) to large\n", length, bits) );
  if (!length)
    return(NoErrors);
  else if (newshift < SC_BITBUFFSZ)
  {
    BS->OutBuff=(BS->OutBuff<<length) | bits;
    BS->shift=newshift;
    stat=NoErrors;
  }
  else if (newshift == SC_BITBUFFSZ)
  {
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<length)|bits);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    const int bitsavail=SC_BITBUFFSZ-BS->shift;
    const int bitsleft=length-bitsavail;
    const ScBitString_t outbits=bits>>bitsleft;
    _SlibDebug(_DEBUG_, printf("ScBSPutBits(%d) Storing 0x%lX\n",
                               length, (BS->OutBuff<<bitsavail)|outbits) );
    stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<bitsavail)|outbits);
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsleft>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsleft (%d)\n",
               bitsleft) );
    _SlibDebug(_VERIFY_ && (bitsavail<=0 || bitsavail>=SC_BITBUFFSZ),
               printf("ScBSPutBits(%d) bad bitsavail (%d)\n", bitsavail) );
#if 1
    BS->OutBuff=bits & (((ScBitBuff_t)1<<bitsleft)-1);
#else
    BS->OutBuff=bits-(outbits<<bitsleft);
#endif
    BS->shift=bitsleft;
  }
  BS->CurrentBit += length;
  return(stat);
}

/*
** ScBSPutBytes()
** Put a number of bits onto the bitstream
*/
ScStatus_t ScBSPutBytes(ScBitstream_t *BS, u_char *buffer, u_int length)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERIFY_, printf("ScBSPutBytes(length=%d): Byte offset = 0x%X ",
                                        length, ScBSBytePosition(BS)) );

  while (stat==NoErrors && length>0)
  {
    stat=ScBSPutBits(BS, (ScBitString_t)*buffer, 8);
    buffer++;
    length--;
  }
  return(stat);
}

/*
** ScBSPutBit()
** Put a single bit onto the bitstream
*/
ScStatus_t ScBSPutBit(ScBitstream_t *BS, char bit)
{
  ScStatus_t stat;
  const int shift=BS->shift;

  _SlibDebug(_DEBUG_, printf("ScBSPutBit(0x%lX): Byte offset = 0x%X ",
                                                bit, ScBSBytePosition(BS)) );
  _SlibDebug(_VERIFY_ && bit>1, printf("ScBSPutBit(): bit>1") );
  if (shift < (SC_BITBUFFSZ-1))
  {
    BS->OutBuff<<=1;
    if (bit)
      BS->OutBuff|=1;
    BS->shift=shift+1;
    stat=NoErrors;
  }
  else if (shift == SC_BITBUFFSZ-1)
  {
    if (bit)
      stat=sc_BSStoreDataWord(BS, (BS->OutBuff<<1)+1);
    else
      stat=sc_BSStoreDataWord(BS, BS->OutBuff<<1);
    BS->OutBuff=0;
    BS->shift=0;
  }
  else
  {
    _SlibDebug(_DEBUG_, printf("BS Storing(0x%lX)\n", BS->OutBuff) );
    stat=sc_BSStoreDataWord(BS, BS->OutBuff);
    BS->OutBuff=bit;
    BS->shift=1;
  }
  BS->CurrentBit++;
  return(stat);
}

/*
** Name:    ScBSGetBitsVarLen()
** Purpose: Return bits from the bitstream. # bits depends on table
*/
int ScBSGetBitsVarLen(ScBitstream_t *BS, const int *table, int len)
{
  int index, lookup;

  index=(int)ScBSPeekBits(BS, len);
  lookup = table[index];
  _SlibDebug(_DEBUG_,
     printf("ScBSGetBitsVarLen(len=%d): Byte offset=0x%X table[%d]=0x%X Return=%d\n",
                      len, ScBSBytePosition(BS), index, lookup, lookup >> 6) );
  ScBSGetBits(BS, lookup & 0x3F);
  return(lookup >> 6);
}


#ifndef ScBSBitPosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBitPosition()
** Purpose: Return the absolute bit position in the stream
*/
long ScBSBitPosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit);
}
#endif

#ifndef ScBSBytePosition
/* Now is a macro in SC.h */
/*
** Name:    ScBSBytePosition()
** Purpose: Return the absolute byte position in the stream
*/
long ScBSBytePosition(ScBitstream_t *BS)
{
  return(BS->CurrentBit>>3);
}
#endif

/*
** Name:    ScBSSeekAlign()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
** Return:  Returns TRUE if the sync was found otherwise it returns FALSE.
*/
int ScBSSeekAlign(ScBitstream_t *BS, ScBitString_t seek_word, int word_len)
{
  _SlibDebug(_VERBOSE_,
            printf("ScBSSeekAlign(BS=%p, seek_word=0x%x, word_len=%d)\n",
                                    BS, seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlign(BS=%p) word_len=0\n", BS) );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );

#if USE_FAST_SEEK
  if (word_len%8==0 && word_len<=32 && !BS->EOI)  /* do a fast seek */
  {
    unsigned char *buff, nextbyte;
    const unsigned char byte1=(seek_word>>(word_len-8))&0xFF;
    int bytesinbuff;
    seek_word-=((ScBitString_t)byte1)<<word_len;
    word_len-=8;
    _SlibDebug(_VERIFY_ && seek_word >= (ScBitString_t)1<<word_len,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    if (BS->buffp>=(BS->shift/8)) /* empty OutBuff & InBuff */
    {
      BS->shift=0;
      BS->OutBuff=0;
      BS->InBuff=0;
      BS->buffp-=BS->shift/8;
    }
    else while (BS->shift) /* search whats in OutBuff & InBuff first */
    {
      _SlibDebug(_DEBUG_,
              printf("ScBSSeekAlign() Fast searching OutBuff & InBuff\n") );
      nextbyte=BS->OutBuff>>(SC_BITBUFFSZ-8);
      BS->shift-=8;
      BS->OutBuff=(BS->OutBuff<<8)|(BS->InBuff>>(SC_BITBUFFSZ-8));
      BS->InBuff<<=8;
      BS->CurrentBit+=8;
      if (nextbyte==byte1
            && (word_len==0 || ScBSPeekBits(BS, word_len)==seek_word))
      {
        /* found seek_word in buffer */
        ScBSSkipBits(BS, word_len);
        return(!BS->EOI);
      }
    }
    _SlibDebug(_VERIFY_ && BS->shift,
       printf("ScBSSeekAlign(BS=%p) shift (%d) <> 0\n", BS, BS->shift) );
    _SlibDebug(_VERIFY_ && BS->OutBuff,
       printf("ScBSSeekAlign(BS=%p) OutBuff (0x%lX) <> 0\n", BS, BS->OutBuff) );
    _SlibDebug(_VERIFY_ && BS->InBuff,
       printf("ScBSSeekAlign(BS=%p) InBuff (0x%lX) <> 0\n", BS, BS->InBuff) );

    bytesinbuff=BS->bufftop-BS->buffp;
    if (bytesinbuff<=0) /* Get more data if all out */
    {
      if (!sc_BSGetData(BS))
      {
        BS->EOI=TRUE;
        return(FALSE);
      }
      bytesinbuff=BS->bufftop;
    }
    buff=BS->buff+BS->buffp;
    switch (word_len/8)
    {
      case 0: /* word length = 1 byte */
              while (1)
              {
                if (*buff++==byte1)
                {
                  BS->buffp=buff-BS->buff;
                  BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                  _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X at pos %d (0x%X)\n",
                                 byte1, BS->CurrentBit/8, BS->CurrentBit/8) );
                  _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte1,
                    printf("ScBSSeekAlign() bad position for buffp\n") );
                  return(TRUE);
                }
                if ((--bytesinbuff)==0)
                {
                  if (!sc_BSGetData(BS))
                  {
                    BS->EOI=TRUE;
                    return(FALSE);
                  }
                  buff=BS->buff;
                  bytesinbuff=BS->bufftop;
                }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
              }
              break;
      case 1: /* word length = 2 bytes */
              {
                const unsigned char byte2=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      BS->buffp=buff-BS->buff;
                      BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                       printf("ScBSSeekAlign() Found %X %X at pos %d (0x%X)\n",
                            byte1, byte2, BS->CurrentBit/8, BS->CurrentBit/8) );
                      _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte2,
                         printf("ScBSSeekAlign() bad position for buffp\n") );
                      return(TRUE);
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 2: /* word length = 3 bytes */
              {
                const unsigned char byte2=(seek_word>>8)&0xFF;
                const unsigned char byte3=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        BS->buffp=buff-BS->buff;
                        BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                      _SlibDebug(_DEBUG_,
                    printf("ScBSSeekAlign() Found %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                        _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte3,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                        return(TRUE);
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
      case 3: /* word length = 4 bytes */
              {
                const unsigned char byte2=(seek_word>>16)&0xFF;
                const unsigned char byte3=(seek_word>>8)&0xFF;
                const unsigned char byte4=seek_word&0xFF;
                while (1)
                {
                  if (*buff++==byte1)
                  {
                    if ((--bytesinbuff)==0)
                    {
                      BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                      if (!sc_BSGetData(BS))
                      {
                        BS->EOI=TRUE;
                        return(FALSE);
                      }
                      buff=BS->buff;
                      bytesinbuff=BS->bufftop;
                    }
                    if (*buff++==byte2)
                    {
                      if ((--bytesinbuff)==0)
                      {
                        BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                        if (!sc_BSGetData(BS))
                        {
                          BS->EOI=TRUE;
                          return(FALSE);
                        }
                        buff=BS->buff;
                        bytesinbuff=BS->bufftop;
                      }
                      if (*buff++==byte3)
                      {
                        if ((--bytesinbuff)==0)
                        {
                          BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                          if (!sc_BSGetData(BS))
                          {
                            BS->EOI=TRUE;
                            return(FALSE);
                          }
                          buff=BS->buff;
                          bytesinbuff=BS->bufftop;
                        }
                        if (*buff++==byte4)
                        {
                          BS->buffp=buff-BS->buff;
                          BS->CurrentBit=(BS->buffstart+BS->buffp)*8;
                          _SlibDebug(_DEBUG_,
                 printf("ScBSSeekAlign() Found %X %X %X %X at pos %d (0x%X)\n",
                                 byte1, byte2, byte3, byte4,
                                 BS->CurrentBit/8, BS->CurrentBit/8) );
                          _SlibDebug(_VERIFY_ && BS->buff[BS->buffp-1]!=byte4,
                           printf("ScBSSeekAlign() bad position for buffp\n") );
                          return(TRUE);
                        }
                      }
                    }
                  }
                  if ((--bytesinbuff)==0)
                  {
                    BS->CurrentBit=(BS->buffstart+buff-BS->buff)*8;
                    if (!sc_BSGetData(BS))
                    {
                      BS->EOI=TRUE;
                      return(FALSE);
                    }
                    buff=BS->buff;
                    bytesinbuff=BS->bufftop;
                  }
                  _SlibDebug(_VERIFY_ && bytesinbuff<=0,
                printf("ScBSSeekAlign() bytesinbuff (%d)<=0\n", bytesinbuff) );
                }
              }
              break;
       default:
              _SlibDebug(_VERIFY_,
                printf("ScBSSeekAlign() Bad fast word length %d\n", word_len) );
              break;
    }
  }
  else
#endif
  {  /* a slow seek */
    ScBitString_t val;
    const ScBitString_t maxi = ((ScBitString_t)1 << word_len)-(ScBitString_t)1;
    val = ScBSGetBits(BS, word_len);
    _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
    while ((val&maxi)!=seek_word && !BS->EOI)
      val = (val<<8)|ScBSGetBits(BS, 8);
    _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  }
  _SlibDebug(_WARN_,
            _debug_stop=BS->CurrentBit;
            if ((_debug_stop-_debug_start)>word_len)
              printf("ScBSSeekAlign() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
             );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlign() Exit with %s\n",
                                  BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopAt()
** Purpose: Seeks for a byte aligned word in the bit stream
**          and places the bit stream pointer right after its
**          found position.
**          Searches only until end_byte_pos is reached.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopAt(ScBitstream_t *BS, ScBitString_t seek_word,
                        int word_len, unsigned long end_byte_pos)
{
  ScBSPosition_t end_bit_pos=end_byte_pos<<3;
  ScBitString_t val;
  const ScBitString_t maxi = ((ScBitString_t)1 << word_len) - 1;

  _SlibDebug(_VERBOSE_,
       printf("ScBSSeekAlignStopAt(seek_word=0x%x, word_len=%d, end=%d)\n",
                                      seek_word, word_len, end_byte_pos) );
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);

  ScBSByteAlign(BS)
  if (ScBSBytePosition(BS)>=end_byte_pos)
    return(FALSE);
  if ((BS->CurrentBit+word_len)>end_bit_pos)
  {
    ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
    return(FALSE);
  }
  val = ScBSGetBits(BS, word_len);
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  while ((val&maxi)!=seek_word && !BS->EOI)
  {
    if ((BS->CurrentBit+word_len)>end_bit_pos)
    {
      ScBSSkipBits(BS, (unsigned int)(end_bit_pos-BS->CurrentBit));
      _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
      return(FALSE);
    }
    val <<= 8;
    val |= ScBSGetBits(BS, 8);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopAt() Exit with %s\n",
                                       BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBefore()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekAlignStopBefore(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBefore() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 8);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekStopBefore()
** Purpose: Seeks for a word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSSeekStopBefore(ScBitstream_t *BS, ScBitString_t seek_word, 
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_, 
             printf("ScBSSeekStopBefore(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,  
              printf("ScBSSeekStopBefore() word_len=0\n") );

  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBits(BS, 1);
    ScBSPreLoad(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_, 
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBefore() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekStopBefore() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSSeekAlignStopBeforeW()
** Purpose: Seeks for a byte aligned word in the bit stream,
**          if found, places the bit stream pointer right at the beginning
**          of the word.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
**
** NB: This version uses Dolby style word loading for bitstream
*/
int ScBSSeekAlignStopBeforeW(ScBitstream_t *BS, ScBitString_t seek_word,
                                               int word_len)
{
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSSeekAlignStopBeforeW(seek_word=0x%x, word_len=%d)\n",
                                      seek_word, word_len) );
  _SlibDebug(_VERIFY_ && !word_len,
              printf("ScBSSeekAlignStopBeforeW() word_len=0\n") );

  ScBSByteAlign(BS)
  _SlibDebug(_VERIFY_, _debug_start=BS->CurrentBit );
  _SlibDebug(_DEBUG_, _debug_getbits=FALSE );
  /* make sure there's at least word_len bits in OutBuff */
  ScBSPreLoadW(BS, word_len);
  while ((BS->OutBuff>>iword_len)!=seek_word && !BS->EOI)
  {
    ScBSSkipBitsW(BS, 8);
    ScBSPreLoadW(BS, word_len);
  }
  _SlibDebug(_DEBUG_, _debug_getbits=TRUE );
  _SlibDebug(_WARN_,
           _debug_stop=BS->CurrentBit;
           if ((_debug_stop-_debug_start)>word_len)
             printf("ScBSSeekAlignStopBeforeW() Moved %d bits (%d bytes) byte pos 0x%X->0x%X\n",
                   _debug_stop-_debug_start, (_debug_stop-_debug_start)/8,
                   _debug_start/8, _debug_stop/8)
            );

  _SlibDebug(_DEBUG_, printf("ScBSSeekAlignStopBeforeW() Exit with %s\n",
                                   BS->EOI ? "FALSE" : "TRUE") );
  return(!BS->EOI);
}

/*
** Name:    ScBSGetBytesStopBefore()
** Purpose: Gets all the bytes until seek_word (byte aligned)
**          is encountered.
**          Searches only until 'length' bytes are read.
** Return:  Returns TRUE if the word was found otherwise it returns FALSE.
*/
int ScBSGetBytesStopBefore(ScBitstream_t *BS, u_char *buffer, u_int length,
                           u_int *ret_length, ScBitString_t seek_word,
                           int word_len)
{
  unsigned long offset=0;
  const int iword_len=SC_BITBUFFSZ-word_len;

  _SlibDebug(_VERBOSE_,
             printf("ScBSGetBytesStopBefore(seek_word=0x%x, word_len=%d)\n",
                                       seek_word, word_len) );
  ScBSByteAlign(BS)
  ScBSPreLoad(BS, word_len);
  while ((BS->OutBuff>>iword_len) != seek_word &&
             offset<length && !BS->EOI)
  {
    *buffer = (unsigned char)ScBSGetBits(BS, 8);
    buffer++;
    offset++;
    ScBSPreLoad(BS, word_len);
  }

  *ret_length=offset;
  _SlibDebug(_DEBUG_,
             printf("ScBSGetBytesStopBefore(ret_length=%d) Exit with %s\n",
               *ret_length, (BS->EOI||offset>=length) ? "FALSE" : "TRUE") );
  if (BS->EOI || offset>=length)
    return(FALSE);
  else
    return(TRUE);
}

/*
** Name:    ScBSFlush()
** Purpose: Flushes data from the buffers
*/
ScStatus_t ScBSFlush(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() In\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if ((BS->Mode=='w' || BS->Mode=='b') && BS->buffp>0)
  {
    if (BS->shift>0) /* some remaining bits in internal buffers */
    {
      /* byte align last bits */
      ScBSAlignPutBits(BS);
      if (BS->buffp>=BS->bufftop)
        stat=sc_BSPutData(BS);
      /* Copy the remaining bytes in OutBuff to the current buffer */
      while (BS->shift>0 && BS->buffp<BS->bufftop)
      {
        BS->shift-=8;
        BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
      }
      stat=sc_BSPutData(BS);
      if (BS->shift>0) /* still some bytes left */
      {
        while (BS->shift>0 && BS->buffp<BS->bufftop)
        {
          BS->shift-=8;
          BS->buff[BS->buffp++]=(unsigned char)(BS->OutBuff>>BS->shift);
        }
        stat=sc_BSPutData(BS);
      }
    }
    else
      stat=sc_BSPutData(BS);
  }
  ScBSReset(BS);  /* release and re-initialize buffer pointers */
  _SlibDebug(_VERBOSE_, printf("ScBSFlush() Out\n") );
  return(stat);
}

/*
** Name:    ScBSResetCounters()
** Purpose: Resets the bit position counters to zero
*/
ScStatus_t ScBSResetCounters(ScBitstream_t *BS)
{
  if (!BS)
    return(ScErrorBadPointer);
  BS->CurrentBit=0;
  return(NoErrors);
}

/*
** Name:    ScBSFlushSoon()
** Purpose: Flushes data from the buffers at the next
**          32 or 64 bit boundary
*/
ScStatus_t ScBSFlushSoon(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSFlushSoon()\n") );
  if (!BS)
    return(ScErrorBadPointer);

  if (BS->Mode=='w' || BS->Mode=='b')
    BS->Flush=TRUE;
  return(stat);
}

/*
** Name:    ScBSDestroy()
** Purpose: Destroys a bitstream (Closes and frees associated memory)
**          created using ScBSCreateFromBufferQueue() or
**          ScBSCreateFromFile()
*/
ScStatus_t ScBSDestroy(ScBitstream_t *BS)
{
  ScStatus_t stat=NoErrors;
  _SlibDebug(_VERBOSE_, printf("ScBSDestroy\n") );
  if (!BS)
    return(ScErrorBadPointer);

/* We won't flush automatically
  if (BS->Mode=='w' || BS->Mode=='b')
    ScBSFlush(BS);
*/
  if (BS->RdBufAllocated)
    ScFree(BS->RdBuf);
  ScFree(BS);
  return(stat);
}

/*********************** Buffer/Image Queue Management ***********************/
/*                                                                           */
/* ScBufQueueCreate()  - Create a buffer queue                               */
/* ScBufQueueDestroy() - Destroy a buffer queue                              */
/* ScBufQueueAdd()     - Add a buffer to tail of a queue                     */
/* ScBufQueueRemove()  - Remove the buffer at the head of a queue            */
/* ScBufQueueGetNum()  - Return number of buffers in a queue                 */
/* ScBufQueueGetHead() - Return info about buffer at head of a queue         */
/*                                                                           */
/*****************************************************************************/


ScStatus_t ScBufQueueCreate(ScQueue_t **Q)
{
  if ((*Q = (ScQueue_t *)ScAlloc(sizeof(ScQueue_t))) == NULL)
    return(ScErrorMemory);
  (*Q)->NumBufs = 0;
  (*Q)->head = (*Q)->tail = NULL;
  _SlibDebug(_QUEUE_, printf("ScBufQueueCreate() Q=%p\n",*Q) );
  return(NoErrors);
}

ScStatus_t ScBufQueueDestroy(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy(Q=%p)\n",Q) );
  if (!Q)
    return(ScErrorBadArgument);
  _SlibDebug(_QUEUE_, printf("ScBufQueueDestroy()\n") );

  while (ScBufQueueGetNum(Q))
    ScBufQueueRemove(Q);

  ScFree(Q);
  return(NoErrors);
}

ScStatus_t ScBufQueueAdd(ScQueue_t *Q, u_char *Data, int Size)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueAddExt(ScQueue_t *Q, u_char *Data, int Size, int Type)
{
  struct ScBuf_s *b;

  if (!Q)
    return(ScErrorBadPointer);

  if ((b = (struct ScBuf_s *)ScAlloc(sizeof(struct ScBuf_s))) == NULL)
    return(ScErrorMemory);

  _SlibDebug(_QUEUE_, printf("ScBufQueueAdd(Q=%p, Data=0x%p, Size=%d)\n",
                                   Q,Data,Size) );
  b->Data = Data;
  b->Size = Size;
  b->Type = Type;
  b->Prev = NULL;

  if (!Q->tail)
    Q->tail = Q->head = b;
  else {
    Q->tail->Prev = b;
    Q->tail = b;
  }
  Q->NumBufs++;
  return(NoErrors);
}

ScStatus_t ScBufQueueRemove(ScQueue_t *Q)
{
  struct ScBuf_s *head;
  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove(Q=%p)\n",Q) );

  if (!Q)
    return(ScErrorBadPointer);

  if (!(head = Q->head))
    return(ScErrorBadQueueEmpty);

  _SlibDebug(_QUEUE_, printf("ScBufQueueRemove() Data=%p Size=%d\n",
                            Q->head->Data,Q->head->Size) );
  Q->head = head->Prev;
  if (!Q->head)
    Q->tail = NULL;
  Q->NumBufs--;
  ScFree(head);
  return(NoErrors);
}

int ScBufQueueGetNum(ScQueue_t *Q)
{
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetNum(Q=%p) num=%d\n",
                             Q, Q ? Q->NumBufs : 0) );
  return(Q ? Q->NumBufs : 0);
}

ScStatus_t ScBufQueueGetHead(ScQueue_t *Q, u_char **Data, int *Size)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHead() Data=%p Size=%d\n",
                               Q->head->Data,Q->head->Size) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  return(NoErrors);
}

ScStatus_t ScBufQueueGetHeadExt(ScQueue_t *Q, u_char **Data, int *Size,
                                 int *Type)
{
  if (!Q || !Q->head) {
    if (Data) *Data = NULL;
    if (Size) *Size = 0;
    if (Type) *Type = 0;
    return(NoErrors);
  }
  _SlibDebug(_QUEUE_, printf("ScBufQueueGetHeadExt() Data=%p Size=%d Type=%d\n",
                               Q->head->Data,Q->head->Size,Q->head->Type) );
  if (Data) *Data = Q->head->Data;
  if (Size) *Size = Q->head->Size;
  if (Type) *Type = Q->head->Type;
  return(NoErrors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_dct.c ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: sc_dct.c,v $
 * Revision 1.1.4.6  1996/01/08  16:41:14  Hans_Graves
 * 	Moved IDCT routines to sc_idct.c
 * 	[1996/01/08  15:31:42  Hans_Graves]
 *
 * Revision 1.1.4.5  1996/01/02  18:30:42  Bjorn_Engberg
 * 	Got rid of compiler warnings: Added Casts, Removed unused local variables.
 * 	[1996/01/02  15:23:37  Bjorn_Engberg]
 * 
 * Revision 1.1.4.4  1995/12/28  18:16:55  Bjorn_Engberg
 * 	Define floorf = floor for NT since NT does not have floorf.
 * 	[1995/12/28  17:10:31  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1995/12/07  19:31:16  Hans_Graves
 * 	Added ScFDCT8x8s_C() and ScIDCT8x8s_C to be used by MPEG encoder
 * 	[1995/12/07  17:43:21  Hans_Graves]
 * 
 * Revision 1.1.4.2  1995/09/13  14:51:40  Hans_Graves
 * 	Added ScScaleIDCT8x8().
 * 	[1995/09/13  14:40:56  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:07:33  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  16:08:02  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/
/*
** Filename: sc_dct.c
** DCT related functions.
** (Pulled from MPEG/JPEG Decode & Encode source.)
*/

#include <math.h>
#include "SC.h"

/*-----------------------------------------------------------------------
                Forward Discrete Cosine Transform
 -------------------------------------------------------------------------*/

#define F (float)
#define RSQ2    F 0.7071067811865
#define COSM1P3 F 1.3065629648764
#define COS1M3  F 0.5411961001462
#define COS3    F 0.3826834323651

#ifdef WIN32
#define floorf  F floor
#endif /* WIN32 */

/*
** Name:    ScIFDCT
** Purpose: IFDCT takes the fast inverse DCT of 32 data points
*/
void ScIFDCT(float in_block[32], float out_block[32])
{
        static float            cpi4,cpi8,c3pi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,s3pi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init=0;

        float                   temp;
        float                   c0,c1,c2,c3,c4,c5,c6,c7,c8;
        float                   c9,c10,c11,c12,c13,c14,c15;
        float                   c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;
        float                   *out_block_ptr;
        float                   *in_block_ptr;
/* initialization.  This is to be done only once. */

        if(init==0) {
        /* establish internal variables */
	  cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (3.0*PI/8.0);     c3pi8 = F cos(temp);   s3pi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
	  init++;
        }

        /* rearrange coefficients to do bit reversed ordering */

          in_block_ptr = &in_block[0];
          d0  = *in_block_ptr++ * F 1.414213562; /******** normalization ********/

          d16 = *in_block_ptr++;
                  d8  = *in_block_ptr++;
          d24 = *in_block_ptr++;
                  e4  = *in_block_ptr++;
          d20 = *in_block_ptr++;
                  d12 = *in_block_ptr++;
          d28 = *in_block_ptr++;
          d2  = *in_block_ptr++;
          d18 = *in_block_ptr++;
                  d10 = *in_block_ptr++;
          d26 = *in_block_ptr++;
                  e6  = *in_block_ptr++;
          d22 = *in_block_ptr++;
                  d14 = *in_block_ptr++;
          d30 = *in_block_ptr++;
          d1  = *in_block_ptr++;
          d17 = *in_block_ptr++;
                  d9  = *in_block_ptr++;
          d25 = *in_block_ptr++;
                  e5  = *in_block_ptr++;
          d21 = *in_block_ptr++;
                  d13 = *in_block_ptr++;
          d29 = *in_block_ptr++;
          d3  = *in_block_ptr++;
          d19 = *in_block_ptr++;
                  d11 = *in_block_ptr++;
          d27 = *in_block_ptr++;
                  e7  = *in_block_ptr++;
          d23 = *in_block_ptr++;
                  d15 = *in_block_ptr++;
          d31 = *in_block_ptr++;

        /* first stage of fast idct */

          c16=spi64*d16-cpi64*d31;
          c31=spi64*d31+cpi64*d16;

          c17=s17pi64*d17-c17pi64*d30;
          c30=s17pi64*d30+c17pi64*d17;

          c18=s9pi64*d18-c9pi64*d29;
          c29=s9pi64*d29+c9pi64*d18;

          c19=s25pi64*d19-c25pi64*d28;
          c28=s25pi64*d28+c25pi64*d19;

          c20=s5pi64*d20-c5pi64*d27;
          c27=s5pi64*d27+c5pi64*d20;

          c21=s21pi64*d21-c21pi64*d26;
          c26=s21pi64*d26+c21pi64*d21;

          c22=s13pi64*d22-c13pi64*d25;
          c25=s13pi64*d25+c13pi64*d22;

          c23=s29pi64*d23-c29pi64*d24;
          c24=s29pi64*d24+c29pi64*d23;

        /* second stage of fast idct */

          e8=spi32*d8-cpi32*d15;
          e15=spi32*d15+cpi32*d8;

          e9=c7pi32*d9-s7pi32*d14;
          e14=c7pi32*d14+s7pi32*d9;

          e10=s5pi32*d10-c5pi32*d13;
          e13=s5pi32*d13+c5pi32*d10;

          e11=c3pi32*d11-s3pi32*d12;
          e12=c3pi32*d12+s3pi32*d11;

                  d16=c17+c16;
          e17=c16-c17;
          e18=c19-c18;
                  d19=c18+c19;
                  d20=c21+c20;
          e21=c20-c21;
          e22=c23-c22;
                  d23=c22+c23;
                  d24=c25+c24;
          e25=c24-c25;
          e26=c27-c26;
                  d27=c26+c27;
                  d28=c29+c28;
          e29=c28-c29;
          e30=c31-c30;
                  d31=c30+c31;

        /* third stage of fast idct */

          d4=spi16*e4-cpi16*e7;
          d7=spi16*e7+cpi16*e4;

          d5=c3pi16*e5-s3pi16*e6;
          d6=c3pi16*e6+s3pi16*e5;

                c8=e9+e8;
          d9=e8-e9;
          d10=e11-e10;
                c11=e10+e11;
                c12=e13+e12;
          d13=e12-e13;
          d14=e15-e14;
                c15=e14+e15;

          d17= -cpi16*e17+spi16*e30;
          d30=cpi16*e30+spi16*e17;

          d18= -spi16*e18-cpi16*e29;
          d29=spi16*e29-cpi16*e18;

          d21=c3pi16*e26-s3pi16*e21;
          d26=c3pi16*e21+s3pi16*e26;

          d22= -s3pi16*e25-c3pi16*e22;
          d25= -s3pi16*e22+c3pi16*e25;

        /* fourth stage of fast idct */

          c0=cpi4*(d1+d0);
          c1=cpi4*(d0-d1);
          c2= -cpi8*d3+spi8*d2;
          c3= cpi8*d2+spi8*d3;
                  e4=d5+d4;
          c5=d4-d5;
          c6=d7-d6;
                  e7=d6+d7;
          c9=spi8*d14-cpi8*d9;
          c14=spi8*d9+cpi8*d14;

          c10= -cpi8*d13-spi8*d10;
          c13= -cpi8*d10+spi8*d13;
                  e16=d19+d16;
          c19=d16-d19;
                  e17=d18+d17;
          c18=d17-d18;
          c20=d23-d20;
                  e23=d20+d23;
          c21=d22-d21;
                  e22=d21+d22;
                  e24=d27+d24;
          c27=d24-d27;
                  e25=d26+d25;
          c26=d25-d26;
          c28=d31-d28;
                  e31=d28+d31;
          c29=d30-d29;
                  e30=d29+d30;

        /* fifth stage of fast idct */

          e0=c3+c0;
          e3=c0-c3;
          e1=c2+c1;
          e2=c1-c2;
          e5=cpi4*(c6-c5);
          e6=cpi4*(c6+c5);
                  d8=c11+c8;
          e11=c8-c11;
                  d9=c10+c9;
          e10=c9-c10;
          e12=c15-c12;
                  d15=c12+c15;
          e13=c14-c13;
                  d14=c13+c14;
          e18=spi8*c29-cpi8*c18;
          e29=spi8*c18+cpi8*c29;

          e19=spi8*c28-cpi8*c19;
          e28=spi8*c19+cpi8*c28;

          e20= -cpi8*c27-spi8*c20;
          e27= -cpi8*c20+spi8*c27;

          e21= -cpi8*c26-spi8*c21;
          e26= -cpi8*c21+spi8*c26;

        /* sixth stage of fast dct */

          d0=e0+e7;
          d7=e0-e7;

          d1=e1+e6;
          d6=e1-e6;

          d2=e2+e5;
          d5=e2-e5;

          d3=e3+e4;
          d4=e3-e4;

          d10=cpi4*(e13-e10);
          d13=cpi4*(e13+e10);

          d11=cpi4*(e12-e11);
          d12=cpi4*(e12+e11);

                  c16=e23+e16;
          d23=e16-e23;

                  c17=e22+e17;
          d22=e17-e22;

                  c18=e21+e18;
          d21=e18-e21;

                  c19=e20+e19;
          d20=e19-e20;

          d24=e31-e24;
                  c31=e24+e31;

          d25=e30-e25;
                  c30=e25+e30;

          d26=e29-e26;
                  c29=e26+e29;

          d27=e28-e27;
                  c28=e27+e28;

        /* seventh stage of fast dct */

          c0=d0+d15;
          c15=d0-d15;

          c1=d1+d14;
          c14=d1-d14;

          c2=d2+d13;
          c13=d2-d13;

          c3=d3+d12;
          c12=d3-d12;

          c4=d4+d11;
          c11=d4-d11;

          c5=d5+d10;
          c10=d5-d10;

          c6=d6+d9;
          c9=d6-d9;

          c7=d7+d8;
          c8=d7-d8;

          c20=cpi4*(d27-d20);
          c27=cpi4*(d27+d20);

          c21=cpi4*(d26-d21);
          c26=cpi4*(d26+d21);

          c22=cpi4*(d25-d22);
          c25=cpi4*(d25+d22);

          c23=cpi4*(d24-d23);
          c24=cpi4*(d24+d23);


        /* last stage of fast idct */
          out_block_ptr = &out_block[0];
          *out_block_ptr++ = c0+c31;
          *out_block_ptr++ = c1+c30;
          *out_block_ptr++ = c2+c29;
          *out_block_ptr++ = c3+c28;
          *out_block_ptr++ = c4+c27;
          *out_block_ptr++ = c5+c26;
          *out_block_ptr++ = c6+c25;
          *out_block_ptr++ = c7+c24;
          *out_block_ptr++ = c8+c23;
          *out_block_ptr++ = c9+c22;
          *out_block_ptr++ = c10+c21;
          *out_block_ptr++ = c11+c20;
          *out_block_ptr++ = c12+c19;
          *out_block_ptr++ = c13+c18;
          *out_block_ptr++ = c14+c17;
          *out_block_ptr++ = c15+c16;
          *out_block_ptr++ = -c16+c15;
          *out_block_ptr++ = -c17+c14;
          *out_block_ptr++ = -c18+c13;
          *out_block_ptr++ = -c19+c12;
          *out_block_ptr++ = -c20+c11;
          *out_block_ptr++ = -c21+c10;
          *out_block_ptr++ = -c22+c9;
          *out_block_ptr++ = -c23+c8;
          *out_block_ptr++ = -c24+c7;
          *out_block_ptr++ = -c25+c6;
          *out_block_ptr++ = -c26+c5;
          *out_block_ptr++ = -c27+c4;
          *out_block_ptr++ = -c28+c3;
          *out_block_ptr++ = -c29+c2;
          *out_block_ptr++ = -c30+c1;
          *out_block_ptr++ = -c31+c0;
}

/*
 * Name:    ScFDCT
 * Purpose: FDCT takes the fast forward DCT of 32 data points
 * optimize: 21%
 */
void ScFDCT(float in_block[32],float out_block1[32],float out_block2[32])
{
        static float            cpi4,cpi8,cpi16,c3pi16;
        static float            cpi32,c3pi32,c5pi32,c7pi32;
        static float            spi8,spi16,s3pi16;
        static float            spi32,s3pi32,s5pi32,s7pi32;
        static float            cpi64,c17pi64,c9pi64,c25pi64,c5pi64,c21pi64;
        static float            c13pi64,c29pi64;
        static float            spi64,s17pi64,s9pi64,s25pi64,s5pi64,s21pi64;
        static float            s13pi64,s29pi64;

        static int              init = 1;

        register float          c0,c1,c2,c3,c4,c5,c6,c7,c8;
        register float          c9,c10,c11,c12,c13,c14,c15;
        register float          c16,c17,c18,c19,c20,c21,c22;
        float                   c23,c24,c25,c26,c27,c28,c29;
        float                   c30,c31;
        float                   d0,d1,d2,d3,d4,d5,d6,d7,d8;
        float                   d9,d10,d11,d12,d13,d14,d15;
        float                   d16,d17,d18,d19,d20,d21,d22;
        float                   d23,d24,d25,d26,d27,d28,d29;
        float                   d30,d31;
        float                   e0,e1,e2,e3,e4,e5,e6,e7,e8;
        float                   e9,e10,e11,e12,e13,e14,e15;
        float                   e16,e17,e18,e19,e20,e21,e22;
        float                   e23,e24,e25,e26,e27,e28,e29;
        float                   e30,e31;

/* initialization.  This is to be done only once. */

        if(init) {
        /* establish internal variables */
          float   temp;
          cpi4 = F cos(PI/4.0);
          temp = F (PI/8.0);          cpi8 = F cos(temp);    spi8 = F sin(temp);
          temp = F (PI/16.0);        cpi16 = F cos(temp);   spi16 = F sin(temp);
          temp = F (3.0*PI/16.0);   c3pi16 = F cos(temp);  s3pi16 = F sin(temp);
          temp = F (PI/32.0);        cpi32 = F cos(temp);   spi32 = F sin(temp);
          temp = F (3.0*PI/32.0);   c3pi32 = F cos(temp);  s3pi32 = F sin(temp);
          temp = F (5.0*PI/32.0);   c5pi32 = F cos(temp);  s5pi32 = F sin(temp);
          temp = F (7.0*PI/32.0);   c7pi32 = F cos(temp);  s7pi32 = F sin(temp);
          temp = F (PI/64.0);        cpi64 = F cos(temp);   spi64 = F sin(temp);
          temp = F (17.0*PI/64.0); c17pi64 = F cos(temp); s17pi64 = F sin(temp);
          temp = F (9.0*PI/64.0);   c9pi64 = F cos(temp);  s9pi64 = F sin(temp);
          temp = F (25.0*PI/64.0); c25pi64 = F cos(temp); s25pi64 = F sin(temp);
          temp = F (5.0*PI/64.0);   c5pi64 = F cos(temp);  s5pi64 = F sin(temp);
          temp = F (21.0*PI/64.0); c21pi64 = F cos(temp); s21pi64 = F sin(temp);
          temp = F (13.0*PI/64.0); c13pi64 = F cos(temp); s13pi64 = F sin(temp);
          temp = F (29.0*PI/64.0); c29pi64 = F cos(temp); s29pi64 = F sin(temp);
          init = 0;
        }

        /* first stage of fast dct */

          c0= in_block[0] + in_block[31];
          c1= in_block[1] + in_block[30];
          c2= in_block[2] + in_block[29];
          c3= in_block[3] + in_block[28];
          c4= in_block[4] + in_block[27];
          c5= in_block[5] + in_block[26];
          c6= in_block[6] + in_block[25];
          c7= in_block[7] + in_block[24];
          c8= in_block[8] + in_block[23];
          c9= in_block[9] + in_block[22];
          c10= in_block[10] + in_block[21];
          c11= in_block[11] + in_block[20];
          c12= in_block[12] + in_block[19];
          c13= in_block[13] + in_block[18];
          c14= in_block[14] + in_block[17];
          c15= in_block[15] + in_block[16];

                  d16= in_block[15] - in_block[16];
                  d17= in_block[14] - in_block[17];
                  d18= in_block[13] - in_block[18];
                  d19= in_block[12] - in_block[19];
          c20= in_block[11] - in_block[20];
          c21= in_block[10] - in_block[21];
          c22= in_block[9] - in_block[22];
          c23= in_block[8] - in_block[23];
          c24= in_block[7] - in_block[24];
          c25= in_block[6] - in_block[25];
          c26= in_block[5] - in_block[26];
          c27= in_block[4] - in_block[27];
                  d28= in_block[3] - in_block[28];
                  d29= in_block[2] - in_block[29];
                  d30= in_block[1] - in_block[30];
                  d31= in_block[0] - in_block[31];

        /* second stage of fast dct */

          d0=c0+c15;
          d1=c1+c14;
          d2=c2+c13;
          d3=c3+c12;
          d4=c4+c11;
          d5=c5+c10;
          d6=c6+c9;
          d7=c7+c8;
                  e8=c7-c8;
                  e9=c6-c9;
          d10=c5-c10;
          d11=c4-c11;
          d12=c3-c12;
          d13=c2-c13;
                  e14=c1-c14;
                  e15=c0-c15;
          d20=cpi4*(c27-c20);
          d21=cpi4*(c26-c21);
          d22=cpi4*(c25-c22);
          d23=cpi4*(c24-c23);
          d24=cpi4*(c24+c23);
          d25=cpi4*(c25+c22);
          d26=cpi4*(c26+c21);
          d27=cpi4*(c27+c20);

        /* third stage of fast dct */

          e0=d0+d7;
          e1=d1+d6;
          e2=d2+d5;
          e3=d3+d4;
                  c4=d3-d4;
          e5=d2-d5;
          e6=d1-d6;
                  c7=d0-d7;
          e10=cpi4*(d13-d10);
          e11=cpi4*(d12-d11);
          e12=cpi4*(d12+d11);
          e13=cpi4*(d13+d10);
                c16=d23+d16;
                c17=d22+d17;
          e18=d21+d18;
          e19=d20+d19;
          e20=d19-d20;
          e21=d18-d21;
                  c22=d17-d22;
                  c23=d16-d23;
                  c24=d31-d24;
                  c25=d30-d25;
          e26=d29-d26;
          e27=d28-d27;
          e28=d27+d28;
          e29=d26+d29;
                  c30=d25+d30;
                  c31=d24+d31;

        /* fourth stage of fast dct */

          c0=e3+e0;
          c1=e2+e1;
          c2=e1-e2;
          c3=e0-e3;
          c5=cpi4*(e6-e5);
          c6=cpi4*(e6+e5);
                  d8=e11+e8;
          c9=e10+e9;
          c10=e9-e10;
                  d11=e8-e11;
                  d12=e15-e12;
          c13=e14-e13;
          c14=e13+e14;
                  d15=e12+e15;
          c18=spi8*e29-cpi8*e18;
          c19=spi8*e28-cpi8*e19;
          c20= -cpi8*e27-spi8*e20;
          c21= -cpi8*e26-spi8*e21;
          c26= -cpi8*e21+spi8*e26;
          c27= -cpi8*e20+spi8*e27;
          c28=spi8*e19+cpi8*e28;
          c29=spi8*e18+cpi8*e29;

        /* fifth stage of fast dct */

                  d0=cpi4*(c1+c0);              /*done*/
                  d1=cpi4*(c0-c1);              /*done*/
                  d2=cpi8*c3+spi8*c2;           /*done*/
                  d3= -cpi8*c2+spi8*c3;         /*done*/
          d4=c5+c4;
          d5=c4-c5;
          d6=c7-c6;
          d7=c6+c7;
          d9=spi8*c14-cpi8*c9;
          d10= -cpi8*c13-spi8*c10;
          d13= -cpi8*c10+spi8*c13;
          d14=spi8*c9+cpi8*c14;
                  e16=c19+c16;
          d17=c18+c17;
          d18=c17-c18;
                  e19=c16-c19;
                  e20=c23-c20;
          d21=c22-c21;
          d22=c21+c22;
                  e23=c20+c23;
                  e24=c27+c24;
          d25=c26+c25;
          d26=c25-c26;
                  e27=c24-c27;
                  e28=c31-c28;
          d29=c30-c29;
          d30=c29+c30;
                  e31=c28+c31;

        /* sixth stage of fast dct */
                  e4=cpi16*d7+spi16*d4;         /*done*/
                  e5=s3pi16*d6+c3pi16*d5;       /*done*/
                  e6= -s3pi16*d5+c3pi16*d6;     /*done*/
                  e7= -cpi16*d4+spi16*d7;       /*done*/
          e8=d9+d8;
          e9=d8-d9;
          e10=d11-d10;
          e11=d10+d11;
          e12=d13+d12;
          e13=d12-d13;
          e14=d15-d14;
          e15=d14+d15;
          e17=spi16*d30-cpi16*d17;
          e18= -cpi16*d29-spi16*d18;
          e29= -cpi16*d18+spi16*d29;
          e30=spi16*d17+cpi16*d30;

          e21=c3pi16*d26-s3pi16*d21;
          e22= -s3pi16*d25-c3pi16*d22;
          e25= -s3pi16*d22+c3pi16*d25;
          e26=c3pi16*d21+s3pi16*d26;

        /* seventh stage of fast dct */

                  d8=cpi32*e15+spi32*e8;        /*done*/
                  d9=s7pi32*e14+c7pi32*e9;      /*done*/
                  d10=c5pi32*e13+s5pi32*e10;    /*done*/
                  d11=s3pi32*e12+c3pi32*e11;    /*done*/
                  d12= -s3pi32*e11+c3pi32*e12;  /*done*/
                  d13= -c5pi32*e10+s5pi32*e13;  /*done*/
                  d14= -s7pi32*e9+c7pi32*e14;   /*done*/
                  d15= -cpi32*e8+spi32*e15;     /*done*/
          c16=e17+e16;
          c17=e16-e17;
          c18=e19-e18;
          c19=e18+e19;
          c20=e21+e20;
          c21=e20-e21;
          c22=e23-e22;
          c23=e22+e23;
          c24=e25+e24;
          c25=e24-e25;
          c26=e27-e26;
          c27=e26+e27;
          c28=e29+e28;
          c29=e28-e29;
          c30=e31-e30;
          c31=e30+e31;


        /* last stage of fast dct */

          d16=cpi64*c31+spi64*c16;      /*done*/
          d17=c17pi64*c30+s17pi64*c17;  /*done*/
          d18=c9pi64*c29+s9pi64*c18;    /*done*/
          d19=c25pi64*c28+s25pi64*c19;  /*done*/
          d20=c5pi64*c27+s5pi64*c20;    /*done*/
          d21=c21pi64*c26+s21pi64*c21;  /*done*/
          d22=c13pi64*c25+s13pi64*c22;  /*done*/
          d23=c29pi64*c24+s29pi64*c23;  /*done*/
          d24= -c29pi64*c23+s29pi64*c24;/*done*/
          d25= -c13pi64*c22+s13pi64*c25;/*done*/
          d26= -c21pi64*c21+s21pi64*c26;/*done*/
          d27= -c5pi64*c20+s5pi64*c27;  /*done*/
          d28= -c25pi64*c19+s25pi64*c28;/*done*/
          d29= -c9pi64*c18+s9pi64*c29;  /*done*/
          d30= -c17pi64*c17+s17pi64*c30;/*done*/
          d31= -cpi64*c16+spi64*c31;    /*done*/

        /* rearrange coefficients to undo bit reversed ordering */
          out_block2[16] = -d0;/******** normalization done in window********/
          out_block2[15] = -d16;
          out_block2[14] = -d8;
          out_block2[13] = -d24;
          out_block2[12] = -e4;
          out_block2[11] = -d20;
          out_block2[10] = -d12;
          out_block2[9] = -d28;
          out_block2[8] = -d2;
          out_block2[7] = -d18;
          out_block2[6] = -d10;
          out_block2[5] = -d26;
          out_block2[4] = -e6;
          out_block2[3] = -d22;
          out_block2[2] = -d14;
          out_block2[1] = -d30;
          out_block2[0] = -d1;

          out_block1[0] =d1;
          out_block1[1] =d17;
          out_block1[2] =d9;
          out_block1[3] =d25;
          out_block1[4] =e5;
          out_block1[5] =d21;
          out_block1[6] =d13;
          out_block1[7] =d29;
          out_block1[8] =d3;
          out_block1[9] =d19;
          out_block1[10] =d11;
          out_block1[11] =d27;
          out_block1[12] =e7;
          out_block1[13] =d23;
          out_block1[14] =d15;
          out_block1[15] =d31;
          out_block1[16] = F 0;
}

/*
** Name:      ScFDCT8x8_C
** Purpose:   2-d Forward DCT (C version).  Customized for (8x8) blocks
**            "c" version
**
*/
void ScFDCT8x8_C(float *ipbuf, float *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        register float *spptr, *interptr;
        register float *spptr_int;
        float tempptr[64];


        spptr_int = ipbuf;
        interptr = tempptr;

        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr_int[0] + spptr_int[7];
           t7  = spptr_int[0] - spptr_int[7];
           t1  = spptr_int[1] + spptr_int[6];
           t6  = spptr_int[1] - spptr_int[6];
           t2  = spptr_int[2] + spptr_int[5];
           t5  = spptr_int[2] - spptr_int[5];
           t3  = spptr_int[3] + spptr_int[4];
           t4  = spptr_int[3] - spptr_int[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           interptr[16]  = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr_int +=  8;
           interptr++;
        }


        spptr = tempptr;
        interptr = outbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = spptr[0] + spptr[7];
           t7  = spptr[0] - spptr[7];
           t1  = spptr[1] + spptr[6];
           t6  = spptr[1] - spptr[6];
           t2  = spptr[2] + spptr[5];
           t5  = spptr[2] - spptr[5];
           t3  = spptr[3] + spptr[4];
           t4  = spptr[3] - spptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           interptr[32]  = t0 - t1;
           interptr[0]   = t0 + t1;
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           interptr[16] = t2 + t3;
           interptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           interptr[8]  = t5 + t6;
           interptr[56] = t5 - t6;
           interptr[24] = t7 - t4;
           interptr[40] = t7 + t4;

           spptr +=  8;
           interptr++;
       }
}

static const float dct_constants[64] = {
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.09011998,   F 0.06497288,   F 0.06897485,   F 0.07664075,
       F 0.09011998,   F 0.11470097,   F 0.16652001,   F 0.32664075,
   F 0.09567086,   F 0.06897485,   F 0.07322331,   F 0.08136138,
       F 0.09567086,   F 0.12176590,   F 0.17677669,   F 0.34675997,
   F 0.10630377,   F 0.07664074,   F 0.08136138,   F 0.09040392,
       F 0.10630377,   F 0.13529903,   F 0.19642374,   F 0.38529903,
   F 0.12500000,   F 0.09011998,   F 0.09567086,   F 0.10630377,
       F 0.12500000,   F 0.15909483,   F 0.23096988,   F 0.45306373,
   F 0.15909483,   F 0.11470097,   F 0.12176590,   F 0.13529903,
       F 0.15909483,   F 0.20248929,   F 0.29396889,   F 0.57664073,
   F 0.23096988,   F 0.16652001,   F 0.17677669,   F 0.19642374,
       F 0.23096988,   F 0.29396892,   F 0.42677671,   F 0.83715260,
   F 0.45306373,   F 0.32664075,   F 0.34675995,   F 0.38529903,
       F 0.45306373,   F 0.57664073,   F 0.83715260,   F 1.64213395
};

/*
** Name:      ScFDCT8x8s_C
** Purpose:   2-d Forward DCT (C version) for (8x8) blocks
**
*/
void ScFDCT8x8s_C(short *inbuf, short *outbuf)
{
        int i;
        register float t0, t1, t2, t3, t4, t5, t6, t7, tmp;
        float *tempptr, tempbuf[64];
        const float *cptr=dct_constants;

        tempptr=tempbuf;
        /*
        ** Perform Row Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = F (inbuf[0] + inbuf[7]);
           t7  = F (inbuf[0] - inbuf[7]);
           t1  = F (inbuf[1] + inbuf[6]);
           t6  = F (inbuf[1] - inbuf[6]);
           t2  = F (inbuf[2] + inbuf[5]);
           t5  = F (inbuf[2] - inbuf[5]);
           t3  = F (inbuf[3] + inbuf[4]);
           t4  = F (inbuf[3] - inbuf[4]);

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;

           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           tempptr[32]  = t0 - t1;
           tempptr[0]   = t0 + t1;
           t2 += t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp;


           /*  Compute B2   */
           tempptr[16]  = t2 + t3;
           tempptr[48] = t3 - t2;

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           tempptr[8]  = t5 + t6;
           tempptr[56] = t5 - t6;
           tempptr[24] = t7 - t4;
           tempptr[40] = t7 + t4;

           inbuf +=  8;
           tempptr++;
        }


        tempptr = tempbuf;

        /*
        ** Perform Column Computations
        */
        for (i = 0; i < 8; i++) {
           /* Compute A3  */
           t0  = tempptr[0] + tempptr[7];
           t7  = tempptr[0] - tempptr[7];
           t1  = tempptr[1] + tempptr[6];
           t6  = tempptr[1] - tempptr[6];
           t2  = tempptr[2] + tempptr[5];
           t5  = tempptr[2] - tempptr[5];
           t3  = tempptr[3] + tempptr[4];
           t4  = tempptr[3] - tempptr[4];

           /* Compute A2   */
           tmp = t0;
           t0 += t3;
           t3  = tmp - t3;

           tmp = t1;
           t1 += t2;
           t2  = tmp - t2;

           t4  = -t4 - t5;
           t5 += t6;
           t6 += t7;

           /*  Compute A1 */
           outbuf[32]  = (short) floorf((t0 - t1)*cptr[4]+0.499999);
           outbuf[0]   = (short) floorf((t0 + t1)*cptr[0]+0.499999);
           t2 = t2+t3;

           /*  Compute M */
           t2  = t2*RSQ2 ;
           t5  = t5*RSQ2 ;
           tmp = (t6 - t4)*COS3;
           t4  = -t4*COSM1P3 - tmp;
           t6  = COS1M3*t6 + tmp ;

           /*  Compute B2   */
           outbuf[16] = (short) floorf((t2 + t3)*cptr[2]+0.499999);
           outbuf[48] = (short) floorf((t3 - t2)*cptr[6]+0.499999);

           tmp = t5;
           t5 += t7;
           t7 -= tmp;

           /*  Compute PB1  */
           outbuf[8]  = (short) floorf((t5 + t6)*cptr[1]+0.499999);
           outbuf[56] = (short) floorf((t5 - t6)*cptr[7]+0.499999);
           outbuf[24] = (short) floorf((t7 - t4)*cptr[3]+0.499999);
           outbuf[40] = (short) floorf((t7 + t4)*cptr[5]+0.499999);

           tempptr += 8;
           cptr    += 8;
           outbuf++;
       }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\codecs\dec\dech263\sc_conv.h ===
/*
 * @DEC_COPYRIGHT@
 */
/*
 * HISTORY
 * $Log: SC_convert.h,v $
 * Revision 1.1.9.4  1996/09/29  22:19:34  Hans_Graves
 * 	Added stride argument to ScYuv411ToRgb()
 * 	[1996/09/29  21:27:43  Hans_Graves]
 *
 * Revision 1.1.9.3  1996/09/18  23:45:50  Hans_Graves
 * 	Added protos for ScRgbToYuv411(), 411sTo422i, 411sTo422s,
 * 	and 1611PlanarTo411
 * 	[1996/09/18  23:31:09  Hans_Graves]
 * 
 * Revision 1.1.9.2  1996/08/20  22:11:52  Bjorn_Engberg
 * 	For NT - Made several routines public to support JV3.DLL and SOFTJPEG.DLL.
 * 	[1996/08/20  21:53:26  Bjorn_Engberg]
 * 
 * Revision 1.1.6.5  1996/04/11  20:22:02  Hans_Graves
 * 	Removed protos for GetDitherTemplate10/15(), their static now.
 * 	[1996/04/11  20:05:44  Hans_Graves]
 * 
 * Revision 1.1.6.4  1996/04/10  21:47:19  Hans_Graves
 * 	Added _S after assembly routines
 * 	[1996/04/10  21:21:54  Hans_Graves]
 * 
 * Revision 1.1.6.3  1996/04/09  16:04:34  Hans_Graves
 * 	Added USE_C ifdef.
 * 	[1996/04/09  14:48:31  Hans_Graves]
 * 
 * Revision 1.1.6.2  1996/03/29  22:21:02  Hans_Graves
 * 	Cleaned up convert protos
 * 	[1996/03/29  21:46:48  Hans_Graves]
 * 
 * Revision 1.1.4.4  1996/01/08  16:20:39  Bjorn_Engberg
 * 	Got rid of compiler warning messages.
 * 	[1996/01/08  15:23:14  Bjorn_Engberg]
 * 
 * Revision 1.1.4.3  1996/01/02  18:31:15  Bjorn_Engberg
 * 	Added and improved function prototypes.
 * 	[1996/01/02  15:03:03  Bjorn_Engberg]
 * 
 * Revision 1.1.4.2  1995/12/07  19:31:21  Hans_Graves
 * 	Added prototype for ScConvert422PlanarTo411_C()
 * 	[1995/12/07  17:44:41  Hans_Graves]
 * 
 * Revision 1.1.2.18  1995/11/30  20:17:04  Hans_Graves
 * 	Renamed ScYuvToRgb() to ScYuv422toRgb()
 * 	[1995/11/30  20:10:09  Hans_Graves]
 * 
 * Revision 1.1.2.17  1995/11/28  22:47:31  Hans_Graves
 * 	Added prototype for ScYuv1611ToRgb()
 * 	[1995/11/28  21:34:55  Hans_Graves]
 * 
 * Revision 1.1.2.16  1995/11/17  21:31:25  Hans_Graves
 * 	Added prototype for ScYuv411ToRgb()
 * 	[1995/11/17  20:51:27  Hans_Graves]
 * 
 * Revision 1.1.2.15  1995/10/17  15:37:05  Karen_Dintino
 * 	Move DitherTemplate routines from render to common
 * 	[1995/10/17  15:36:49  Karen_Dintino]
 * 
 * Revision 1.1.2.14  1995/10/13  16:57:16  Bjorn_Engberg
 * 	Added prototypes for routines in sc_convert_yuv.c
 * 	[1995/10/13  16:48:55  Bjorn_Engberg]
 * 
 * Revision 1.1.2.13  1995/10/10  21:43:04  Bjorn_Engberg
 * 	Modified RgbToYuv prototype declarations.
 * 	[1995/10/10  21:10:52  Bjorn_Engberg]
 * 
 * Revision 1.1.2.12  1995/10/06  20:46:29  Farokh_Morshed
 * 	Change ScRgbInterlToYuvInterl to take a Bmh by reference
 * 	[1995/10/06  20:46:06  Farokh_Morshed]
 * 
 * Revision 1.1.2.11  1995/10/02  19:30:52  Bjorn_Engberg
 * 	Added more BI_BITFIELDS formats.
 * 	[1995/10/02  18:15:47  Bjorn_Engberg]
 * 
 * Revision 1.1.2.10  1995/09/26  15:58:48  Paul_Gauthier
 * 	Fix mono JPEG to interlaced 422 YUV conversion
 * 	[1995/09/26  15:58:12  Paul_Gauthier]
 * 
 * Revision 1.1.2.9  1995/09/22  12:58:40  Bjorn_Engberg
 * 	Changed uchar to u_char in a function prototype.
 * 	[1995/09/22  12:48:40  Bjorn_Engberg]
 * 
 * Revision 1.1.2.8  1995/09/20  17:39:19  Karen_Dintino
 * 	Add RGB support to JPEG
 * 	[1995/09/20  17:37:04  Karen_Dintino]
 * 
 * Revision 1.1.2.7  1995/09/18  19:47:49  Paul_Gauthier
 * 	Added conversion of MPEG planar 4:1:1 to interleaved 4:2:2
 * 	[1995/09/18  19:46:15  Paul_Gauthier]
 * 
 * Revision 1.1.2.6  1995/09/15  18:17:47  Farokh_Morshed
 * 	Move ValidBI_BITFIELDSKinds from SC.h to SC_convert.h
 * 	[1995/09/15  18:17:19  Farokh_Morshed]
 * 
 * Revision 1.1.2.5  1995/09/14  14:40:35  Karen_Dintino
 * 	Move RgbToYuv out of rendition
 * 	[1995/09/14  14:25:20  Karen_Dintino]
 * 
 * Revision 1.1.2.4  1995/09/11  19:17:25  Hans_Graves
 * 	Added ValidateBI_BITFIELDS() prototype.
 * 	[1995/09/11  19:14:45  Hans_Graves]
 * 
 * Revision 1.1.2.3  1995/08/03  15:01:09  Hans_Graves
 * 	Added prototype for ScConvert422ToYUV_char()
 * 	[1995/08/03  15:00:49  Hans_Graves]
 * 
 * Revision 1.1.2.2  1995/05/31  18:09:23  Hans_Graves
 * 	Inclusion in new SLIB location.
 * 	[1995/05/31  15:22:50  Hans_Graves]
 * 
 * $EndLog$
 */
/*****************************************************************************
**  Copyright (c) Digital Equipment Corporation, 1995                       **
**                                                                          **
**  All Rights Reserved.  Unpublished rights reserved under the  copyright  **
**  laws of the United States.                                              **
**                                                                          **
**  The software contained on this media is proprietary  to  and  embodies  **
**  the   confidential   technology   of  Digital  Equipment  Corporation.  **
**  Possession, use, duplication or  dissemination  of  the  software  and  **
**  media  is  authorized  only  pursuant  to a valid written license from  **
**  Digital Equipment Corporation.                                          **
**                                                                          **
**  RESTRICTED RIGHTS LEGEND Use, duplication, or disclosure by  the  U.S.  **
**  Government  is  subject  to  restrictions as set forth in Subparagraph  **
**  (c)(1)(ii) of DFARS 252.227-7013, or in FAR 52.227-19, as applicable.   **
******************************************************************************/

/*
** Filename: SC_convert.h
** Purpose:  Header info for using conversion routines.
*/

#include "SC.h"

enum ValidBI_BITFIELDSKinds {
  pRGB,		/* 32-bit 00RRGGBB special case */
  pBGR,		/* 32-bit 00BBGGRR special case */
  pRGB555,	/* 16-bit 0RRRRRGGGGGBBBBB special case */
  pRGB565,	/* 16-bit RRRRRGGGGGGBBBBB special case */
  pRGBnnn,	/* 16-bit general case */
  InvalidBI_BITFIELDS
};

/*********************** Prototypes *************************/
/*
** sc_convert.c
*/
EXTERN enum ValidBI_BITFIELDSKinds ValidateBI_BITFIELDS(LPBITMAPINFOHEADER lpbi);
EXTERN int ScIsUpsideDown(BITMAPINFOHEADER *lpbiIn,
			  BITMAPINFOHEADER *lpbiOut);
extern BITMAPINFOHEADER *ScCreateBMHeader(int width, int height, int bpp,
                                 int format, int ncolors);
extern ScStatus_t ScConvertSepYUVToOther(BITMAPINFOHEADER *InBmh,
				 BITMAPINFOHEADER *OutBmh,
				 u_char *OutImage,
				 u_char *YData, u_char *CbData, u_char *CrData);
extern ScStatus_t ScYuv422ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScYuv411ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y,
                         u_char *Cb, u_char *Cr, u_char *ImageOut,
                         int width, int height, long stride);
extern ScStatus_t ScYuv1611ToRgb (BITMAPINFOHEADER *Bmh, u_char *Y, u_char *Cb,
                        u_char *Cr, u_char *ImageOut);
extern ScStatus_t ScConvertRGB24sTo422i_C(BITMAPINFOHEADER *Bmh,
                              u_char *R, u_char *G, u_char *B, u_short *ImageOut);
extern ScStatus_t ScConvertRGB24To411s_C(u_char *inimage,
                        u_char *Y, u_char *U, u_char *V, int width, int height);
extern ScStatus_t ScConvertRGB555To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
extern ScStatus_t ScConvertRGB565To411s_C(u_char *inimage, u_char *outimage,
                                         int width, int height);
EXTERN ScStatus_t ScRgbInterlToYuvInterl (LPBITMAPINFOHEADER Bmh, int Width,
			int Height, u_char *ImageIn, u_short *ImageOut);
extern ScStatus_t ScConvert422ToYUV_char_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern int ScConvert422ToBlockYUV(u_char *, int, float *, float *, float *,
                                    int, int);
extern void ScConvertSep422ToBlockYUV (u_char *RawImage, int bpp,
                            float *Comp1, float *Comp2, float *Comp3,
                            int Width, int Height);
extern void ScConvertGrayToBlock (u_char *RawImage, int bpp,
                       float *Comp1, int Width, int Height);
extern int ScSepYUVto422i_C(u_char *Y, u_char *U,
                            u_char *V, u_char *ImageOut,
                            u_int width, u_int height);
extern ScStatus_t ScConvert422PlanarTo411_C (u_char *RawImage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern void ScConvert422PlanarTo422i_C(u_char *Y, u_char *Cb,
				     u_char *Cr, u_char *ImageOut,
				     long width, long height );
extern void ScConvert422iTo422s_C(u_char *InImage,
                                  u_char *Y, u_char *Cb, u_char *Cr, 
                                  long width, long height);
extern void ScConvert422iTo422sf_C(u_char *InImage, int bpp,
                                  float *Y, float *U, float *V, 
                                  long width, long height);
extern void ScConvert411sTo422i_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern void ScConvert411sTo422s_C(u_char *Y, u_char *Cb,
			          u_char *Cr, u_char *ImageOut,
				  long width, long height );
extern ScStatus_t ScConvert1611sTo411s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert411sTo1611s_C (u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422s_C(u_char *inimage,
                         u_char *Y, u_char *U, u_char *V,
                         int Width, int Height);
extern ScStatus_t ScConvert1611sTo422i_C(u_char *inimage, u_char *outimage,
                                         int Width, int Height);
extern ScSt