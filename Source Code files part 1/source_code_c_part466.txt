ntrol to load the enginenew.dll.
            LOG_Internet(_T("SelfUpdate Already Complete, Updated Binary Available, Waiting for Rename."));
            hr = IU_SELFUPDATE_USENEWDLL;
            goto CleanUp;
        }
    case SELFUPDATE_IN_PROGRESS:
    default:
        {
			if (!fStartUpdate)
			{
				//
				// if asked to check update status but not to do actual update,
				// then this reg key flag tells the engine not update complete yet.
				//
				hr = S_FALSE;	// signal TRUE for engine need update
				goto CleanUp;
			}

            if (WAIT_TIMEOUT != WaitForSingleObject(g_hEngineLoadQuit, 0))
            {
                LOG_ErrorMsg(E_ABORT);
                hr = E_ABORT;
                goto CleanUp;
            }

            // The RegKey indicates that a SelfUpdate is in Progress Now. We need to make sure this is
            // actually true. If a previous attempt at selfupdate was aborted because the machine rebooted
            // we could be in a false state. The 'default' state of teh DownloadEvent is Signaled (TRUE).
            // If the current State is TRUE then the SelfUpdate is actually 'NOT' in progress.

            // Find out the current state of the DownloadEvent
            dwWaitResult = WaitForSingleObject(hDownloadEvent, 0);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                // The Event State is still Signaled (TRUE), so the selfupdate is not in progress
                ResetEvent(hDownloadEvent); // mark that this Process will Perform the SelfUpdate by Resetting the Download Event
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
                if (fSynch)
                {
                    hr = BeginSelfUpdate();
                    if (FAILED(hr))
                    {
                        LOG_Error(_T("BeginSelfUpdate Failed"));
                        goto CleanUp;
                    }
                }
                else
                {
                    fAsyncSelfUpdateStarted = TRUE;
                    // launch SelfUpdate Asynchronously.
                    dwRet = StartSelfUpdateProcess(evtQuit, pUpdateComClass, punkUpdateCompleteListener); // inline function
                    if (ERROR_SUCCESS != dwRet)
                    {
                        LOG_ErrorMsg(dwRet);
                        hr = HRESULT_FROM_WIN32(dwRet);
                        goto CleanUp;
                    }
                }
            }
            else 
            {
                // The Event State is not Signaled (FALSE), everythings ok with the current selfupdate
                // Now we need to either start a thread to wait for the complete and immediately return, 'or' 
                // wait for the selfupdate to finish (synchronous or asynchronous selfupdate).
                if (fSynch)
                {
                    // we need to wait for the event to change back to signaled state. Should indicate the
                    // selfupdate is finished.
                    // before we start the wait, we will release our mutex, since we really aren't doing anything
                    // with the registry anymore
                    ReleaseMutex(hMutex);
                    CloseHandle(hMutex);
                    hMutex = NULL;

					aHandles[0] = g_hEngineLoadQuit;	// index 0
					aHandles[1] = hDownloadEvent;

                    dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*120 seconds*/ 120000, QS_ALLINPUT);
                    if (WAIT_TIMEOUT == dwWaitResult)
                    {
                        // Timed Out Waiting for SelfUpdate to Complete. May just be really slow, go ahead
                        // and use the old DLL for now.
                        LOG_ErrorMsg(IU_SELFUPDATE_TIMEOUT);
                        hr = IU_SELFUPDATE_TIMEOUT;
                        goto CleanUp;
                    }
                    if (ERROR_REQUEST_ABORTED == dwWaitResult)
                    {
                        goto CleanUp;
                    }
                    if (WAIT_OBJECT_0 == dwWaitResult)
                    {
						//
						// index 0 (g_hEngineLoadQuit) was signaled
						//
					   hr = E_ABORT;
					   LOG_ErrorMsg(hr);
					   goto CleanUp;
                    }
                    hr = IU_SELFUPDATE_USENEWDLL;
                    goto CleanUp;
                }
                else
                {
					//
                    // asked to update in async mode, but found someone else
					// already started the update process
					//
					PMONITOR_DATA pMonitorData = (PMONITOR_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MONITOR_DATA));

					if (NULL == pMonitorData)
					{
	                    hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					else
					{
						DWORD dwThreadId = 0;
						hr = S_OK;
						pMonitorData->hProcess = hDownloadEvent;
						pMonitorData->evtControlQuit = evtQuit;
						pMonitorData->pUpdateComClass = pUpdateComClass;
						pMonitorData->punkCallback = punkUpdateCompleteListener;
                        HANDLE hThread = NULL;
                        hThread = CreateThread(NULL, 0, MonitorUpdateCompleteProc, pMonitorData, 0, &dwThreadId);
						if (NULL == hThread)
						{
							HeapFree(GetProcessHeap(), 0, pMonitorData);
							//
							// otherwise, the memory allocated will be released by the thread procedure
							//
							hr = HRESULT_FROM_WIN32(GetLastError());
							LOG_ErrorMsg(hr);
							goto CleanUp;
						}
                        else
                        {
                            CloseHandle(hThread); // don't leak the thread handle
                        }
					}	

                    goto CleanUp;
                }
            }
            break;
        }
    }

CleanUp:
    // always release the mutex, there are cases during the selfupdate check that can fail, in which
    // case they fall through to here. If the mutex is free'd when its not ours the call simply fails.
    if (NULL != hMutex)
    {
        ReleaseMutex(hMutex); 
        CloseHandle(hMutex);
        hMutex = NULL;
    }

    if (fAsyncSelfUpdateStarted)
    {
        // if an Asynchronous SelfUpdate has been started we want to wait for it to
        // get the DownloadEvent before we close it. There would be a possible Race 
        // condition where the selfupdate process would 'create' the event, instead
        // of 'opening' the event in its 'reset' state. If this happened another
        // process could come along, find that the event state is signaled instead of
        // reset and assume the selfupdate process had terminated.

        // Wait for the DownloadEventSync event to be signaled. We'll put a timeout of
        // 30 seconds (should be more than sufficient for the new process to start and
        // set the event).
		aHandles[0] = g_hEngineLoadQuit;	// index 0
		aHandles[1] = hDownloadEventSync;

        dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);
        if (WAIT_TIMEOUT == dwWaitResult)
        {
            // go ahead and log that we timed out waiting. 
            LOG_Internet(_T("Timeout Elapsed while waiting for SelfUpdate Process to open the DownloadSync Event"));
        }
		if (ERROR_REQUEST_ABORTED == dwWaitResult)
		{
            // go ahead and log that a WM_QUIT, WM_CLOSE, or WM_DESTROY. 
            LOG_Internet(_T("Received WM_QUIT, WM_CLOSE, or WM_DESTROY while waiting for SelfUpdate Process to open the DownloadSync Event"));
		}
		if (WAIT_OBJECT_0 == dwWaitResult)
		{
            LOG_Internet(_T("g_hEngineLoadQuit signaled while waiting for SelfUpdate Process to open the DownloadSync Event"));
			hr = E_ABORT;
		}
    }
    if (NULL != hDownloadEvent)
    {
        CloseHandle(hDownloadEvent);
        hDownloadEvent = NULL;
    }
    if (NULL != hDownloadEventSync)
    {
        CloseHandle(hDownloadEventSync);
        hDownloadEventSync = NULL;
    }

	if (NULL != hkey)
	{
		RegCloseKey(hkey);
	}

	if (SUCCEEDED(hr))
	{
		LogMessage(SZ_SELF_UPDATE_CHECK);
	}
	else
	{
		LogError(hr, SZ_SELF_UPDATE_CHECK);
	}

    return hr;
}

inline DWORD StartSelfUpdateProcess(HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener)
{
    TCHAR szRunDll32Path[MAX_PATH+1];
    TCHAR szCommandLine[MAX_PATH+1];
    TCHAR szDirectory[MAX_PATH+1];
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    DWORD dwRet = ERROR_SUCCESS;
	DWORD dwThreadId;
	PMONITOR_DATA pMonitorData;
	HRESULT hr=S_OK;

    if (0 == GetSystemDirectory(szDirectory, ARRAYSIZE(szDirectory)))
    {
        return GetLastError();
    }
    
	hr=PathCchCombine(szRunDll32Path,ARRAYSIZE(szRunDll32Path),szDirectory, RUNDLL32);
	if(FAILED(hr))
		return HRESULT_CODE(hr);

    if (!FileExists(szRunDll32Path))
    {
        // probably running on W9x, look in the Windows Folder Instead
        if (0 == GetWindowsDirectory(szDirectory, ARRAYSIZE(szDirectory)))
        {
            return GetLastError();
        }

        hr=PathCchCombine(szRunDll32Path,ARRAYSIZE(szRunDll32Path),szDirectory, RUNDLL32);
		if(FAILED(hr))
			return HRESULT_CODE(hr);
			
        if (!FileExists(szRunDll32Path))
        {
            // we're toast.. can't find rundll32.exe .. bye-bye
            return ERROR_FILE_NOT_FOUND;
        }
    }

    // now form the path to the iuctl.dll .. we'll trust nothing and 'get' the module filename
    // instead of assuming its in the system folder.
    GetModuleFileName(GetModuleHandle(IUCTL), szDirectory, ARRAYSIZE(szDirectory));

	hr=StringCchPrintfEx(szCommandLine,ARRAYSIZE(szCommandLine),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("\"%s\" \"%s\"%s"), szRunDll32Path, szDirectory, RUNDLLCOMMANDLINE);

	if(FAILED(hr))
		return HRESULT_CODE(hr);
	
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    if (!CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
    {
        dwRet = GetLastError();
        return dwRet;
    }

	//
	// create a thread that can be used to monitor the completeness of
	// this update process
	//
	pMonitorData = (PMONITOR_DATA)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(MONITOR_DATA));
	if (NULL != pMonitorData)
	{
		pMonitorData->hProcess = pi.hProcess;	// return process handle so we know when it's done
		pMonitorData->evtControlQuit = evtQuit;
		pMonitorData->pUpdateComClass = pUpdateComClass;
		pMonitorData->punkCallback = punkUpdateCompleteListener;
        HANDLE hThread = NULL;
        hThread = CreateThread(NULL, 0, MonitorUpdateCompleteProc, pMonitorData, 0, &dwThreadId);
		if (NULL == hThread)
		{
			HeapFree(GetProcessHeap(), 0, pMonitorData);
			//
			// otherwise, the memory allocated will be released by the thread procedure
			//
		}
        else
        {
            CloseHandle(hThread);
        }
	}	

    return dwRet;
}


/////////////////////////////////////////////////////////////////////////////
//
// thread procedure to determine when to signal caller
// the update process has be gone
//
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI MonitorUpdateCompleteProc(LPVOID lpv)
{
	HRESULT hr;
	HWND hWnd;
	CUpdate* pUpdateClass = NULL;
	IUnknown* punkCallback = NULL;
	PMONITOR_DATA pData;
	HANDLE hEvents[2];
	DWORD dwRet, dwErr = 0;
	MSG msg;
	
	LOG_Block("MonitorUpdateCompleteProc");

	if (NULL == lpv)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return 0x1;	// impossible!
	}
	
	pData = (PMONITOR_DATA) lpv;

	hEvents[0]		= pData->hProcess;
	hEvents[1]		= pData->evtControlQuit;
	punkCallback	= pData->punkCallback;
	pUpdateClass	= pData->pUpdateComClass;
	if (pUpdateClass)
	{
		hWnd = pUpdateClass->GetEventWndClass().GetEvtHWnd();
	}

	//
	// this data allcoated by parent thread, we are responsible to release it
	//
	HeapFree(GetProcessHeap(), 0, lpv);

	if (NULL == pUpdateClass)
	{
		//
		// even we catch the update completeness, without this pointer we can not 
		// modify the init state so this COM will still not usable. We bail
		// 
		return 0;
	}

	//
	// wait till process gone or quit signal
	//
	while (TRUE)
	{
		dwRet = MsgWaitForMultipleObjects(ARRAYSIZE(hEvents), hEvents, FALSE, INFINITE, QS_ALLINPUT);
		switch (dwRet)
		{
			case WAIT_OBJECT_0:
				//
				// process done, get return code
				//
				GetExitCodeProcess(hEvents[0], &dwErr);

				if (0x0 == dwErr)
				{
					//
					// we are done with no error, then pump the
					// init state to ready state
					//
					dwErr = pUpdateClass->ChangeControlInitState(2);
				}

				//
				// signal event
				//
				if (NULL != hWnd)
				{
					PostMessage(hWnd, UM_EVENT_SELFUPDATE_COMPLETE, 0, (LPARAM)dwErr);
					LOG_Out(_T("Fired event OnComplete()"));
				}
				//
				// signal callback
				//
				if (NULL != punkCallback)
				{
					IUpdateCompleteListener* pCallback = NULL;
					if (FAILED(hr = punkCallback->QueryInterface(IID_IUpdateCompleteListener, (void**) &pCallback)))
					{
						LOG_ErrorMsg(hr);
					}
					else
					{
						pCallback->OnComplete(dwErr);
						pCallback->Release();
						LOG_Out(_T("Returned from callback API OnComplete()"));
					}
				}
				return 0;
				break;

			case WAIT_OBJECT_0 + 1:
				//
				// got global Quit event
				//
				LOG_Out(_T("Found quit event!"));
				return 1;
				break;

			case WAIT_OBJECT_0 + ARRAYSIZE(hEvents):
				//
				// got message
				//
				while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
				{
					if (WM_QUIT == msg.message)
					{
						LOG_Out(_T("Found WM_QUIT message. Leaving..."));
						return 1;
					}
					DispatchMessage(&msg);
				}
				break;
		}

	} 
	
	return 0;	// never reach here
}




HRESULT BeginSelfUpdate()
{
    LOG_Block("BeginSelfUpdate()");
    DWORD dwRet;
    DWORD dwStatus;
    DWORD dwSize;
    HRESULT hr = S_OK;
    HKEY hkey = NULL;					// PreFast
    TCHAR szIUDir[MAX_PATH+1];
    TCHAR szLocalPath[MAX_PATH+1];
    TCHAR szSystemDir[MAX_PATH+1];
    TCHAR szTargetDLLName[MAX_PATH+1];
	LPTSTR pszSelfUpdateCabUrl = NULL;
    HANDLE hDownloadEventSync = NULL;	// PreFast
    HANDLE hDownloadEvent = NULL;		// PreFast
    HANDLE hMutex = NULL;				// PreFast
    MSG msg;
	BOOL fBetaSelfUpdate = FALSE;
    HMODULE hNewEngine = NULL;
    PFN_CompleteSelfUpdateProcess fpnCompleteSelfUpdateProcess = NULL;

    // The SelfUpdate process is done while the SELFUPDATE_IN_PROGRESS event is 'reset'. We
    // do everything we can to make sure we 'open' this event in the reset state, but if for
    // some reason the event is not there we will create it in the reset state.
    hDownloadEvent = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_IN_PROGRESS);
    if (NULL == hDownloadEvent)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

    // The SELFUPDATE_EVENT_SYNC is the mechanism we use to 'try' to keep the SELFUPDATE_IN_PROGRESS
    // event alive and in the 'reset' state until this function can open it and keep it in that state.
    // This should prevent a race condition caused when the SelfUpdateCheck function closes the Event
    // before this function can open it. If this happens another process could start the selfupdate check
    // process and find the SELFUPDATE_IN_PROGRESS event in the wrong state.
    hDownloadEventSync = CreateEvent(NULL, TRUE, FALSE, IU_EVENT_SELFUPDATE_EVENT_SYNC);
    if (NULL == hDownloadEventSync)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(hr);
        goto CleanUp;
    }

    // tell the SelfUpdateCheck client that we have the SELFUPDATE_IN_PROGRESS event, so it can
    // release its handle to it.
    SetEvent(hDownloadEventSync); 

    // release our handle to the SELFUPDATE_EVENT_SYNC event.
    CloseHandle(hDownloadEventSync);
    hDownloadEventSync = NULL;

	// Get Self-Update Server URL
	pszSelfUpdateCabUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszSelfUpdateCabUrl);

	EnterCriticalSection(&g_csUrlAgent);

	if (FAILED(hr = g_pIUUrlAgent->PopulateData()))
	{
		LOG_Error(_T("failed to populate data in g_pIUUrlAgent (%lx)"), hr);
	}

	LeaveCriticalSection(&g_csUrlAgent);
	CleanUpIfFailedAndMsg(g_pIUUrlAgent->GetSelfUpdateServer(pszSelfUpdateCabUrl, INTERNET_MAX_URL_LENGTH));

    // Download the SelfUpdate CAB
    GetIndustryUpdateDirectory(szIUDir);

    hr=PathCchCombine(szLocalPath,ARRAYSIZE(szLocalPath),szIUDir, ENGINECAB);

	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    hr = IUDownloadFile(pszSelfUpdateCabUrl, szLocalPath, TRUE, TRUE);

    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    DeleteFile(szLocalPath); // clean up the CAB in the IU Folder

    // Now we 'should' have IUENGINE.DLL from the SelfUpdate CAB in the IU Folder.
    // IUENGINE.DLL is self-signed so we don't need a Catalog File (IUENGINE.CAT)
	// NTRAID#NTBUG9-435844-2001/07/16-waltw WU: IU: IUCTL: Remove code to register CAT file when updating iuengine.dll

    // Copy the DLL to the new Engine DLL Name
    GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));

    hr=PathCchCombine(szTargetDLLName,ARRAYSIZE(szTargetDLLName), szSystemDir, ENGINENEWDLL);
	
	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }


    hr=PathCchCombine(szLocalPath,ARRAYSIZE(szLocalPath),szIUDir, ENGINEDLL);
	if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }


    CopyFile(szLocalPath, szTargetDLLName, FALSE);

    DeleteFile(szLocalPath); // clean up the DLL in the IU Folder now that its been copied to the systemdir.

    // Now We've successfully downloaded the new IUEngine - we need to call an entry point in this Engine to 
    // Chain any SelfUpdate steps the Engine needs to do. It is possible the engine may need to download an
    // additional component, or do some registry configuration work. So we'll load the new Engine and call the
    // CompleteSelfUpdateProcess entrypoint.
	//
	// We don't need LoadLibraryFromSystemDir here since we have the full path and
	// iuengine isn't a Side-By-Side module.
    hNewEngine = LoadLibrary(szTargetDLLName);
    if (NULL == hNewEngine)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }
    fpnCompleteSelfUpdateProcess = (PFN_CompleteSelfUpdateProcess) GetProcAddress(hNewEngine, "CompleteSelfUpdateProcess");
    if (NULL == fpnCompleteSelfUpdateProcess)
    {
        LOG_ErrorMsg(ERROR_INVALID_DLL);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        goto CleanUp;
    }

    // Call the New Engine to let it finish its SelfUpdate Process
    hr = fpnCompleteSelfUpdateProcess();
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // Now update the registry information about the SelfUpdate process being Complete
    hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_SELFUPDATE_REGCHECK);
    if (NULL == hMutex)
    {
        dwRet = GetLastError();
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;
    }

	HANDLE aHandles[2];

	aHandles[0] = g_hEngineLoadQuit;	// index 0
	aHandles[1] = hMutex;

    // Finish the Registry Settings
    dwRet= MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/ 30000, QS_ALLINPUT);

    if (WAIT_TIMEOUT == dwRet)
    {
        LOG_Internet(_T("Timed Out while waiting for IU_MUTEX_SELFUPDATE_REGCHECK Mutex"));
        // NOTE: If we failed to RegCheck Mutex after 30 seconds something is probably wrong in another
        // process. However, we don't want to leave the registry showing a selfupdate is still in progress
        // so we'll just go ahead and update the registry.
    }
    if (ERROR_REQUEST_ABORTED == dwRet)
    {
        goto CleanUp;
    }
    if (WAIT_OBJECT_0 == dwRet)
    {
		//
		// index 0 (g_hEngineLoadQuit) was signaled
		//
	   hr = E_ABORT;
	   LOG_ErrorMsg(hr);
	   goto CleanUp;
    }

    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ | KEY_WRITE, &hkey);
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
        goto CleanUp;   
    }
    dwStatus = SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED;
    dwRet = RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
    if (ERROR_SUCCESS != dwRet)
    {
        LOG_ErrorMsg(dwRet);
        hr = HRESULT_FROM_WIN32(dwRet);
    }
    
CleanUp:
    if (NULL != hNewEngine)
    {
        FreeLibrary(hNewEngine);
        hNewEngine = NULL;
    }
    if (NULL != hMutex)
    {
        ReleaseMutex(hMutex); // doesn't matter whether we got the mutex or not, if we didn't this will just fail.
        CloseHandle(hMutex);
        hMutex = NULL;
    }
    if (NULL != hDownloadEvent)
    {
        // Tell any clients that are waiting for the selfupdate process to finish that we're now done.
        SetEvent(hDownloadEvent);
        CloseHandle(hDownloadEvent);
        hDownloadEvent = NULL;
    }
    if (NULL != hDownloadEventSync)
    {
        CloseHandle(hDownloadEventSync);
        hDownloadEventSync = NULL;
    }
	if (NULL != hkey)
	{
		RegCloseKey(hkey);
	}
	SafeHeapFree(pszSelfUpdateCabUrl);
    return hr;
}

HRESULT PingEngineUpdate(
						HMODULE hEngineModule,
						PHANDLE phQuitEvents,
						UINT nQuitEventCount,
						LPCTSTR ptszLiveServerUrl,
						LPCTSTR ptszCorpServerUrl,
						DWORD dwError,
						LPCTSTR ptszClientName
						)
{
	LOG_Block("PingEngineUpdate");

	HRESULT hr;
	BOOL fFreeEngModule = FALSE;
	PFN_PingIUEngineUpdateStatus pfnPingIUEngineUpdateStatus;

	if (NULL == hEngineModule)
	{
		// try loading iuenginenew.dll first
		hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
		if (NULL != hEngineModule)
		{
			LOG_Internet(_T("Loaded IUENGINENEW.DLL"));
		}
		else
		{
			LOG_Internet(_T("Loaded IUENGINE.DLL"));
			hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));
		}
		//
		// If load engine succeeded, we'll need to unload it later
		//
		if (NULL != hEngineModule)
		{
			fFreeEngModule = TRUE;
		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
	}

	//
	// If we got an iuengine.dll (either passed in or loaded ourselves), call PingIUEngineUpdateStatus
	//
	if (NULL != hEngineModule)
	{
		pfnPingIUEngineUpdateStatus = (PFN_PingIUEngineUpdateStatus) GetProcAddress(hEngineModule, "PingIUEngineUpdateStatus");

		if (NULL != pfnPingIUEngineUpdateStatus)
		{
			hr = pfnPingIUEngineUpdateStatus(
								phQuitEvents,
								nQuitEventCount,
								ptszLiveServerUrl,
								ptszCorpServerUrl,
								dwError,
								ptszClientName
								);

		}
		else
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
	}

	if (TRUE == fFreeEngModule)
	{
		FreeLibrary(hEngineModule);
	}

	return hr;
}


//
// this function wraps up DownloadIUIdent() and CIUUrlAgent::PopulateData(), since we use it
// in both selfupd.cpp and loadengine.cpp.
//
HRESULT DownloadIUIdent_PopulateData()
{
	LOG_Block("DownloadIUIdent_PopulateData");
	HRESULT hr = S_OK;

	//
	// Look for any specified iuident Server Location in the Registry (Overrides Default)
	//
	LPTSTR pszTempUrlBuffer = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszTempUrlBuffer);

	if (FAILED(hr = g_pIUUrlAgent->GetOriginalIdentServer(pszTempUrlBuffer, INTERNET_MAX_URL_LENGTH)))
	{
		LOG_Error(_T("failed to get original ident server URL (%lx)"), hr);
		goto CleanUp;
	}

	TCHAR szIUDir[MAX_PATH];

	//GetIndustryUpdateDirectory(szIUDir);

	//
	// ensure WU directory exist and correctly ACL'ed
	//
	CleanUpIfFalseAndSetHrMsg(!GetWUDirectory(szIUDir, ARRAYSIZE(szIUDir), TRUE), HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));
	hr = CreateDirectoryAndSetACLs(szIUDir, TRUE);
	CleanUpIfFailedAndMsg(hr);

	if (FAILED(hr = DownloadIUIdent(
						g_hEngineLoadQuit,
						pszTempUrlBuffer,
						szIUDir, 
						0,
						(S_OK == g_pIUUrlAgent->IsIdentFromPolicy()))))
	{
		LOG_Error(_T("iuident download failed (%lx)"), hr);
		goto CleanUp;
	}

	EnterCriticalSection(&g_csUrlAgent);

	if (FAILED(hr = g_pIUUrlAgent->PopulateData()))
	{
		LOG_Error(_T("failed to populate data in g_pIUUrlAgent (%lx)"), hr);
	}

	LeaveCriticalSection(&g_csUrlAgent);

CleanUp:
	SafeHeapFree(pszTempUrlBuffer);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

MAJORCOMP=windows.com
MINORCOMP=iuctl

TARGETNAME=iuctl
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\IUCtl.def

#
# Compiler settings
#
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=..\StdAfx.h
# USE_STL=1
# USE_MSVCRT=1
# USE_VCCOM=1
# USE_CRTDLL=1

#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1

C_DEFINES=$(C_DEFINES) -D_USRDLL

ATL_VER=30
USE_CRTDLL=1
USE_STATIC_ATL=1
ATL_DLL_IMPL=1
#BROWSER_INFO=1

#
# force rebuild of .idl on bcz
#
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_SERVERDIR=$(O)
MIDL_TLBDIR=$(O)

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

TARGETLIBS=\
       $(SDK_LIB_PATH)\oleaut32.lib		    \
       $(SDK_LIB_PATH)\ole32.lib		    \
       $(SDK_LIB_PATH)\kernel32.lib		    \
       $(SDK_LIB_PATH)\user32.lib		    \
       $(SDK_LIB_PATH)\advapi32.lib		    \
       $(SDK_LIB_PATH)\shell32.lib		    \
       $(SDK_LIB_PATH)\advapi32.lib		    \
       $(SDK_LIB_PATH)\advpack.lib                  \
       $(SDK_LIB_PATH)\uuid.lib			    \
       $(SDK_LIB_PATH)\shlwapi.lib                  \
       $(SDK_LIB_PATH)\version.lib                  \
       $(WULIB)\trust\$(WUBLDTYPE)\$(O)\trust.lib               \
       $(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib             \
       $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib	            \
       $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib              \
       $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib             \
       $(WULIB)\urlagent\$(WUBLDTYPE)\$(O)\urlagent.lib	            \
       $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib	            \
       $(SDK_LIB_PATH)\msvcrt.lib

#
# how about - gdi32.lib, comdlg32.lib, odbc32.lib, odbccp32.lib?
# they are showing up in the ATL project settings.
#

INCLUDES=$(INCLUDES);..\..\inc;..\.;$(BASEDIR)\public\internal\windows\inc;$(BASEDIR)\public\internal\enduser\inc;

SOURCES= ..\iuctl.idl               \
         ..\IUCtl.rc                \
         ..\StdAfx.cpp              \
         ..\IUCtl.cpp               \
         ..\Update.cpp              \
         ..\ProgressListener.cpp    \
         ..\UpdateCompleteListener.cpp \
         ..\Detection.cpp           \
         ..\EvtMsgWnd.cpp           \
         ..\iudl.cpp                \
         ..\selfupd.cpp		    \
         ..\loadengine.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\updatecompletelistener.cpp ===
// ProgressListener.cpp : Implementation of CProgressListener
#include "stdafx.h"
#include "IUCtl.h"
#include "UpdateCompleteListener.h"

/////////////////////////////////////////////////////////////////////////////
// CUpdateCompleteListener


/////////////////////////////////////////////////////////////////////////////
// OnComplete()
//
// Notify the listener when the engine update is complete.
// Input:	the result of engine update
//	
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdateCompleteListener::OnComplete(/*[in]*/ LONG lErrorCode)
{
	// TODO: Add your implementation code here

	//
	// usually you should change state of a synchronization object so
	// the thread that is waiting for the engine update complete 
	// can be notified by checking the state of this object
	//

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\selfupd.h ===
#ifndef __SELFUPD_H_
#define __SELFUPD_H_

#include <wincrypt.h>
#include <mscat.h>
#include <wininet.h>
#include <iucommon.h>
#include <urllogging.h>

const DWORD SELFUPDATE_NONE = 0;
const DWORD SELFUPDATE_IN_PROGRESS = 1;
const DWORD SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED = 2;

const TCHAR IU_MUTEX_SELFUPDATE_REGCHECK[] = _T("{14649649-37d9-4cd4-aaaf-f066bc0c0b47}");
const TCHAR IU_EVENT_SELFUPDATE_IN_PROGRESS[] = _T("{a6c7e065-cca9-44e6-a951-ae4327845fe0}");
const TCHAR IU_EVENT_SELFUPDATE_EVENT_SYNC[] = _T("{ed3ce20f-8479-4c1a-85ae-7a58ad6dc83e}");

#if defined(__WUIUTEST)
const TCHAR WU_SERVER_URL[] = _T("http://iudev/");
#else
const TCHAR WU_SERVER_URL[] = _T("http://windowsupdate.microsoft.com/v4/");
#endif

const TCHAR IDENT_VERSION[] = _T("Version");
const TCHAR IDENT_IUSELFUPDATE[] = _T("IUSelfUpdate");
const TCHAR IDENT_IUBETASELFUPDATE[] = _T("IUBetaSelfUpdate");
const TCHAR REGKEY_IDENT_SERV[] = _T("IdentServer");
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_SELFUPDATESTATUS[] = _T("SelfUpdateStatus");
const TCHAR REGVAL_SELFUPDATEVERSION[] = _T("SelfUpdateVersion");
const TCHAR REGVAL_BETASELFUPDATE[] = _T("BetaSelfUpdate");

const TCHAR IUCTL[] = _T("iuctl.dll");
const TCHAR ENGINEDLL[] = _T("iuengine.dll");
const TCHAR ENGINENEWDLL[] = _T("iuenginenew.dll");
const TCHAR ENGINECAB[] = _T("iuengine.cab");
const TCHAR RUNDLL32[] = _T("rundll32.exe");
const TCHAR RUNDLLCOMMANDLINE[] = _T(",BeginSelfUpdate");

// MSCAT32 support (CryptCAT API's)
const TCHAR MSCAT32DLL[] = _T("mscat32.dll");

// CryptCat Function Pointer Types
typedef BOOL (*PFN_CryptCATAdminAcquireContext)(OUT HCATADMIN *phCatAdmin, 
                                                IN const GUID *pgSubsystem, 
                                                IN DWORD dwFlags);
typedef HCATINFO (*PFN_CryptCATAdminAddCatalog)(IN HCATADMIN hCatAdmin, 
                                            IN WCHAR *pwszCatalogFile, 
                                            IN OPTIONAL WCHAR *pwszSelectBaseName, 
                                            IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATCatalogInfoFromContext)(IN HCATINFO hCatInfo,
                                                   IN OUT CATALOG_INFO *psCatInfo,
                                                   IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseCatalogContext)(IN HCATADMIN hCatAdmin,
                                                       IN HCATINFO hCatInfo,
                                                       IN DWORD dwFlags);
typedef BOOL (*PFN_CryptCATAdminReleaseContext)(IN HCATADMIN hCatAdmin,
                                                IN DWORD dwFlags);

// Determines if a selfupdate is needed, or is already in process. If a selfupdate is needed it will trigger
// RunDll32 to instantiate a second instance of the control and have it call the BeginSelfUpdate() entrypoint.
class CUpdate;
HRESULT SelfUpdateCheck(BOOL fSynch, BOOL fStartUpdate, HANDLE evtQuit, CUpdate* pUpdateComClass, IUnknown* punkUpdateCompleteListener);

// EntryPointCalled by RunDll32.exe to actually do the selfupdate process.
HRESULT BeginSelfUpdate();

HRESULT PingEngineUpdate(
						HMODULE hEngineModule,
						PHANDLE phQuitEvents,
						UINT nQuitEventCount,
						LPCTSTR ptszLiveServerUrl,
						LPCTSTR ptszCorpServerUrl,
						DWORD dwError,
						LPCTSTR ptszClientName = NULL);

// this function wraps up DownloadIUIdent() and CIUUrlAgent::PopulateData(), since we use it
// in both selfupd.cpp and loadengine.cpp.
HRESULT DownloadIUIdent_PopulateData();

#endif //__SELFUPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED_)
#define AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define STRSAFE_NO_DEPRECATE

#include <atlbase.h>
#include <objsafe.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <strsafe.h>
#include <MISTSAFE.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A986663F_FF6F_4B1E_8364_B1CB06AEDFD3__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\update.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Update.h
//
//  Owner:  JHou
//
//  Description:
//
//   Industry Update v1.0 client control stub - Declaration of the CUpdate
//
//
//  Revision History:
//
//  Date		Author		Desc
//	~~~~		~~~~~~		~~~~
//  9/15/2000	JHou		created.
//
//=======================================================================
#ifndef __UPDATE_H_
#define __UPDATE_H_

#include "resource.h"       // main symbols
#include "IUCtl.h"
#include "IUCtlCP.h"
#include "EvtMsgWnd.h"
#include <iu.h>				// for HIUENGINE


// BOOL IsThisUpdate2();



class CMyComClassFactory : public CComClassFactory
{
public:
	// IClassFactory
   STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
   {
	   HRESULT hr = CComClassFactory::CreateInstance(pUnkOuter, riid, ppvObj);

	   if (SUCCEEDED(hr))
	   {
		   //
		   // allocate thread global variables, thread handle
		   //

	   }

	   return hr;

   }
};



/////////////////////////////////////////////////////////////////////////////
// CUpdate
class ATL_NO_VTABLE CUpdate : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CUpdate, &CLSID_Update>,
	public IObjectWithSiteImpl<CUpdate>,
	public IObjectSafety,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CUpdate>,
	public IProvideClassInfo2Impl<&CLSID_Update, NULL, &LIBID_IUCTLLib>,
	public IDispatchImpl<IUpdate, &IID_IUpdate, &LIBID_IUCTLLib>,
	public CProxyIUpdateEvents<CUpdate>
{
public:
	CUpdate();
    ~CUpdate();
	//
	// impl of object safety for scripting
	//
	ULONG InternalRelease();
	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);

	DECLARE_REGISTRY_RESOURCEID(IDR_UPDATE)

/* 
we decided to use the new Win32 API GetControlUpdateInfo() to expose these
data and let a wrapper control to call it so we won't have reboot issue on 
OS prior to WinXP

	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)
	{
		UINT nResID = IsThisUpdate2() ? IDR_UPDATE2 : IDR_UPDATE;
		return _Module.UpdateRegistryFromResource(nResID, bRegister);
	}
*/
DECLARE_NOT_AGGREGATABLE(CUpdate)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdate)
	COM_INTERFACE_ENTRY(IUpdate)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IObjectSafety)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CUpdate)
	CONNECTION_POINT_ENTRY(DIID_IUpdateEvents)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IUpdate
public:


	DECLARE_CLASSFACTORY_EX(CMyComClassFactory);


	/////////////////////////////////////////////////////////////////////////////
	//
	// Initialize() API must be called before any other API will function
	//
	// If any other API is called before the control is initialized, 
	// that API will return OLE_E_BLANK, signalling this OLE control is an 
	// uninitialized object (although in this case it's a bit different from 
	// its original meaning)
	//
	// Parameters:
	//
	//	lInitFlag - IU_INIT_CHECK, cause Initialize() download ident and check if any
	//				of the components need updated. currently we support control version
	//				check and engine version check. Return value is a bit mask
	//
	//			  - IU_INIT_UPDATE_SYNC, cause Initialize() kicks off update engine
	//				process if already called by IU_INIT_CHECK and a new engine is available.
	//				When API returns, the update process is finished.
	//
	//			  - IU_INIT_UPDATE_ASYNC, cause Initialize() kicks off update engine
	//				process in Asynchronized mode if already called by IU_INIT_CHECK and
	//				a new engine is available. This API will return right after the 
	//				update process starts. 
	//
	//	punkUpdateCompleteListener - this is a pointer to a user-implemented 
	//				COM callback feature. It contains only one function OnComplete() that
	//				will be called when the engine update is done.
	//				This value can be NULL.
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Initialize)(
						  /*[in]*/ LONG lInitFlag, 
						  /*[in]*/ IUnknown* punkUpdateCompleteListener, 
						  /*[out, retval]*/ LONG* plRetVal);

	
	/////////////////////////////////////////////////////////////////////////////
	// GetSystemSpec()
	//
	// Gets the basic system specs.
	// Input:
	// bstrXmlClasses - a list of requested classes in xml format, NULL if any.
	//				    For example:
	//				    <devices>
	//				    <class name="video"/>
	//				    <class name="sound" id="2560AD4D-3ED3-49C6-A937-4368C0B0E06A"/>
	//				    </devices>
	// Output:
	// pbstrXmlDetectionResult - the detection result in xml format.
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetSystemSpec)(BSTR	bstrXmlClasses,
							 BSTR*	pbstrXmlDetectionResult);

	/////////////////////////////////////////////////////////////////////////////
	// GetManifest()
	//
	// Gets a catalog base on the specified information.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlSystemSpec - the detected system specifications in xml
	// bstrXmlQuery - the user query infomation in xml
	// Output:
	// pbstrXmlCatalog - the xml catalog retrieved
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetManifest)(BSTR			bstrXmlClientInfo,
						   BSTR			bstrXmlSystemSpec,
						   BSTR			bstrXmlQuery,
						   BSTR*		pbstrXmlCatalog);

	/////////////////////////////////////////////////////////////////////////////
	// Detect()
	//
	// Do detection.
	// Input:
	// bstrXmlCatalog - the xml catalog portion containing items to be detected 
    // Output:
	// pbstrXmlItems - the detected items in xml format
    //                 e.g.
    //                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Detect)(BSTR		bstrXmlCatalog, 
					  BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// Download()
	//
	// Do synchronized downloading.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
	// bstrDestinationFolder - the destination folder. Null will use the default IU folder
	// lMode - indicates throttled or fore-ground downloading mode
	// punkProgressListener - the callback function pointer for reporting download progress
	// Output:
	// pbstrXmlItems - the items with download status in xml format
	//                 e.g.
	//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(Download)(BSTR		bstrXmlClientInfo,
						BSTR		bstrXmlCatalog, 
						BSTR		bstrDestinationFolder,
						LONG		lMode,
						IUnknown*	punkProgressListener,
						BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// DownloadAsync()
	//
	// Download asynchronously -  the method will return before completion.
	// Input:
	// bstrXmlClientInfo - the credentials of the client in xml format
	// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
	// bstrDestinationFolder - the destination folder. Null will use the default IU folder
	// lMode - indicates throttled or fore-ground downloading mode
	// punkProgressListener - the callback function pointer for reporting download progress
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
	// Output:
    // pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
	//                      parameter (an empty string is passed), it will generate a new UUID,
    //                      in which case, the caller will be responsible to free the memory of
	//                      the string buffer that holds the generated UUID using SysFreeString(). 
    //                      Otherwise, it returns the value passed by bstrUuidOperation.        
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(DownloadAsync)(BSTR		bstrXmlClientInfo,
							 BSTR		bstrXmlCatalog, 
							 BSTR		bstrDestinationFolder,
							 LONG		lMode,
							 IUnknown*	punkProgressListener, 
							 BSTR		bstrUuidOperation,
							 BSTR*		pbstrUuidOperation);

	/////////////////////////////////////////////////////////////////////////////
    // Install()
	//
	// Do synchronized installation.
	// Input:
    // bstrXmlCatalog - the xml catalog portion containing items to be installed 
	// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
	//                          result as described in the result schema.  Install uses this
	//                          to know whether the items were downloaded and if so where they
	//                          were downloaded to so that it can install the items
	// lMode - indicates different installation mode
    // punkProgressListener - the callback function pointer for reporting install progress
	// Output:
    // pbstrXmlItems - the items with installation status in xml format
    //                 e.g.
    //                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(Install)(BSTR         bstrXmlClientInfo,
                       BSTR			bstrXmlCatalog,
					   BSTR			bstrXmlDownloadedItems,
					   LONG			lMode,
					   IUnknown*	punkProgressListener,
					   BSTR*		pbstrXmlItems);

	/////////////////////////////////////////////////////////////////////////////
	// InstallAsync()
	//
	// Install Asynchronously.
    // Input:
	// bstrXmlCatalog - the xml catalog portion containing items to be installed
	// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
	//                          result as described in the result schema.  Install uses this
	//                          to know whether the items were downloaded and if so where they
	//                          were downloaded to so that it can install the items
	// lMode - indicates different installation mode
    // punkProgressListener - the callback function pointer for reporting install progress
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
	// Output:
    // pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
	//                      parameter (an empty string is passed), it will generate a new UUID,
    //                      in which case, the caller will be responsible to free the memory of
	//                      the string buffer that holds the generated UUID using SysFreeString(). 
    //                      Otherwise, it returns the value passed by bstrUuidOperation.        
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(InstallAsync)(BSTR        bstrXmlClientInfo,
                            BSTR		bstrXmlCatalog,
							BSTR		bstrXmlDownloadedItems,
							LONG		lMode,
							IUnknown*	punkProgressListener, 
							BSTR		bstrUuidOperation,
							BSTR*		pbstrUuidOperation);

	
	/////////////////////////////////////////////////////////////////////////////
	// SetOperationMode()
	//
	// Set the operation mode
    // Input:
    // bstrUuidOperation - an id provided by the client to provide further
	//                     identification to the operation as indexes may be reused.
    // lMode - a bitmask for the following mode:
	//						UPDATE_COMMAND_PAUSE 
	//						UPDATE_COMMAND_RESUME
	//						UPDATE_COMMAND_CANCEL
	//						UPDATE_NOTIFICATION_COMPLETEONLY
	//						UPDATE_NOTIFICATION_ANYPROGRESS
	//						UPDATE_NOTIFICATION_1PCT
	//						UPDATE_NOTIFICATION_5PCT
	//						UPDATE_NOTIFICATION_10PCT
	//						UPDATE_SHOWUI
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(SetOperationMode)(BSTR		bstrUuidOperation,
								LONG		lMode);
	/**
	*
	* Get the mode of a specified operation.
	*
	* @param bstrUuidOperation: same as in SetOperationMode()
	* @param plMode - the retval for the mode found in a bitmask for:
	*					(value in brackets [] means default)
	*					UPDATE_COMMAND_PAUSE (TRUE/[FALSE])
	*					UPDATE_COMMAND_RESUME (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_COMPLETEONLY (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_ANYPROGRESS ([TRUE]/FALSE)
	*					UPDATE_NOTIFICATION_1PCT (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_5PCT (TRUE/[FALSE])
	*					UPDATE_NOTIFICATION_10PCT (TRUE/[FALSE])
	*					UPDATE_SHOWUI (TRUE/[FALSE])
	*
	*/

	STDMETHOD(GetOperationMode)(
					/*[in]*/ BSTR bstrUuidOperation, 
					/*[out,retval]*/ LONG* plMode
					);

	
	/**
	* 
	* Retrieve a property of this control
	*		Calling this method will not cause the engine loaded
	*
	* @param lProperty - the identifier to flag which property need retrieved
	*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
	*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
	*
	* @param varValue - the value to retrieve
	*					
	*/
	STDMETHOD(GetProperty)(
					/*[in]*/ LONG lProperty, 
					/*[out,retval]*/ VARIANT* pvarValue
					);

	/**
	* 
	* Set a property of this control
	*		Calling this method will not cause the engine loaded
	*
	* @param lProperty - the identifier to flag which property need changed
	*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
	*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
	*
	* @param varValue - the value to change
	*
	*/
	STDMETHOD(SetProperty)(
					/*[in]*/ LONG lProperty, 
					/*[in]*/ VARIANT varValue
					);


	/////////////////////////////////////////////////////////////////////////////
    // GetHistory()
	//
	// Get the history log.
	// Input:
    // bstrDateTimeFrom - the start date and time for which a log is required.
	//                    This is a string in ANSI format (YYYY-MM-DDTHH-MM). 
	//                    If the string is empty, there will be no date restriction 
	//                    of the returned history log.
    // bstrDateTimeTo - the end date and time for which a log is required.
	//                  This is a string in ANSI format (YYYY-MM-DDTHH-MM).
	//                  If the string is empty, there will be no date restriction
	//                  of the returned history log.
	// bstrClient - the name of the client that initiated the action. If this parameter 
	//              is null or an empty string, then there will be no filtering based 
	//              on the client.
	// bstrPath - the path used for download or install. Used in the corporate version 
	//            by IT managers. If this parameter is null or an empty string, then 
	//            there will be no filtering based on the path.
	// Output:
	// pbstrLog - the history log in xml format
	/////////////////////////////////////////////////////////////////////////////
    STDMETHOD(GetHistory)(BSTR		bstrDateTimeFrom,
						  BSTR		bstrDateTimeTo,
						  BSTR		bstrClient,
						  BSTR		bstrPath,
						  BSTR*		pbstrLog);


	/////////////////////////////////////////////////////////////////////////////
	//
	// Primarily expose shlwapi BrowseForFolder API, can also do checking
	// on R/W access if flagged so.
	//
	// @param bstrStartFolder - the folder from which to start. If NULL or empty str
	//							is being passed in, then start from desktop
	//
	// @param flag - validating check 
	//							UI_WRITABLE for checking write access, OK button may disabled. 
	//							UI_READABLE for checking read access, OK button may disabled. 
	//							NO_UI_WRITABLE for checking write access, return error if no access
	//							NO_UI_READABLE for checking read access,  return error if no access
	//							0 (default) for no checking.
	//
	// @param pbstrFolder - returned folder if a valid folder selected
	//
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(BrowseForFolder)(BSTR bstrStartFolder, 
							   LONG flag, 
							   BSTR* pbstrFolder);



    /////////////////////////////////////////////////////////////////////////////
    //
    // Allows the Caller to Request the Control to do a Reboot 
    //
    /////////////////////////////////////////////////////////////////////////////
    STDMETHOD(RebootMachine)();


    /////////////////////////////////////////////////////////////////////////////
    //
    // Make the other control can be unloaded from IE/OLE
    //
    /////////////////////////////////////////////////////////////////////////////
	STDMETHOD(PrepareSelfUpdate)(/*[in]*/ LONG lStep);



    /////////////////////////////////////////////////////////////////////////////
	//
	// Helper API to let the caller (script) knows the necessary information 
	// when Initialize() returns control need updated.
	//
	// For the current implementation, bstrClientName is ignored, and
	// the returned bstr has format:
	//	"<version>|<url>"
	// where:
	//	<version> is the expacted version number of the control
	//	<url> is the base url to get the control if this is a CorpWU policy controlled machine,
	//		  or empty if this is a consumer machine (in that case caller, i.e., script, knows
	//		  the default base url, which is the v4 live site)
	//
	// Script will need these two pieces of information in order to make a right <OBJECT> tag
	// for control update.
	//
    /////////////////////////////////////////////////////////////////////////////
	STDMETHOD(GetControlExtraInfo)(/*[in]*/ BSTR bstrClientName, 
								 /*[out,retval]*/ BSTR *pbstrExtraInfo);




	//
	// override IObjectWithSiteImpl function to get the site pointer
	//
	STDMETHOD(SetSite)(IUnknown* pSite);

	HRESULT ChangeControlInitState(LONG lNewState);

	inline CEventMsgWindow& GetEventWndClass() {return m_EvtWindow;};

private:

	HANDLE		m_evtControlQuit;

	DWORD		m_dwMode;

	DWORD		m_dwSafety;

	HMODULE     m_hEngineModule;

	HIUENGINE	m_hIUEngine;	// Life of this handle must be within scope of valid m_hEngineModule

	BOOL		m_fUseCompression;

    BOOL        m_fOfflineMode;

	HRESULT		m_hValidated;	// E_FAIL: initialized, 
								// S_OK: validated, 
								// INET_E_INVALID_URL: bad URL, don't continue

	LONG		m_lInitState;	// 0 - not initialized
								// 1 - need update
								// 2 - initialized, ready to work
	DWORD		m_dwUpdateInfo;	// result of first Initialize() call

	IUnknown*	m_pClientSite;

	TCHAR		m_szReqControlVer[64];


	//
	// private function
	//

	/////////////////////////////////////////////////////////////////////////////
	// 
	// Security feature: make sure if the user of this control is
	// a web page then the URL can be found in iuident.txt
	//
	// This function should be called after iuident refreshed.
	//
	// Return: TRUE/FALSE, to tell if we can continue
	//					
	/////////////////////////////////////////////////////////////////////////////
	HRESULT	ValidateControlContainer(void);



	/////////////////////////////////////////////////////////////////////////////
	// UnlockEngine()
	//
	// release the engine dll if ref cnt of engine is down to zero
	/////////////////////////////////////////////////////////////////////////////
	HRESULT	UnlockEngine();


	/////////////////////////////////////////////////////////////////////////////
	// GetPropUpdateInfo()
	//
	// get the latest iuident.txt, find out the version requirement, then
	// compare with the current file version data to determine
	// if we will update anything if the engine get loaded.
	//
	/////////////////////////////////////////////////////////////////////////////
	HRESULT DetectEngine(BOOL* pfUpdateAvail);


	/////////////////////////////////////////////////////////////////////////////
	// event handling members
	/////////////////////////////////////////////////////////////////////////////
	CEventMsgWindow m_EvtWindow;

	/////////////////////////////////////////////////////////////////////////////
	// synchronization object to make sure we lock/unlock engine correctly 
	// in multi-threaded cases
	/////////////////////////////////////////////////////////////////////////////
	CRITICAL_SECTION m_lock;
	BOOL m_gfInit_csLock;

//	BOOL m_fIsThisUpdate2;

};

#endif //__UPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\updatecompletelistener.h ===
// ProgressListener.h : Declaration of the CProgressListener

#ifndef __UPDATECOMPLETELISTENER
#define __UPDATECOMPLETELISTENER

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CProgressListener
class ATL_NO_VTABLE CUpdateCompleteListener : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUpdateCompleteListener, &CLSID_UpdateCompleteListener>,
	public IUpdateCompleteListener
{
public:
	CUpdateCompleteListener()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPDATECOMPLETELISTENER)
DECLARE_NOT_AGGREGATABLE(CUpdateCompleteListener)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdateCompleteListener)
	COM_INTERFACE_ENTRY(IUpdateCompleteListener)
END_COM_MAP()

// IProgressListener
public:

	/////////////////////////////////////////////////////////////////////////////
	// OnComplete()
	//
	// Notify the listener when the engine update is complete.
	// Input:	the result of engine update
	//	
	/////////////////////////////////////////////////////////////////////////////
	STDMETHOD(OnComplete)(/*[in]*/ LONG lErrorCode);
};

#endif //__UPDATECOMPLETELISTENER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\browse.cpp ===
//=======================================================================
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Browse.cpp
//
//  Owner:  EdDude
//
//  Description:
//
//      Implements the CBrowseFolder class.
//
//      Browse for a Folder for downloads.
//
//=======================================================================

#include "iuengine.h"
#include <shlobj.h>
#include <logging.h>
#include <fileutil.h>
#include "Browse.h"

//************************************************************************
//
// IUENGINE.DLL EXPORTED API BrowseForFolder()
//
//************************************************************************
HRESULT CEngUpdate::BrowseForFolder(BSTR bstrStartFolder, 
						LONG flag, 
						BSTR* pbstrFolder)
{
	LOG_Block("BrowseForFolder()");
	TCHAR szFolder[MAX_PATH];
	HRESULT hr = E_FAIL;
	CBrowseFolder br(flag);

	USES_IU_CONVERSION;

	LPTSTR lpszStartFolder = OLE2T(bstrStartFolder);

	LOG_Out(_T("BroseForFolder passed in start folder %s, flag %x"), lpszStartFolder, (DWORD)flag);

	if (IUBROWSE_NOBROWSE & flag)
	{
		//
		// if not browse dlgbox required, the purpose of this call is 
		// to validate the folder
		//
		DWORD dwRet = ValidateFolder(lpszStartFolder, (IUBROWSE_WRITE_ACCESS & flag));
		hr = (ERROR_SUCCESS == dwRet) ? S_OK : HRESULT_FROM_WIN32(dwRet);

		if (SUCCEEDED(hr))
		{
			*pbstrFolder = SysAllocString(T2OLE(lpszStartFolder));
		}
	}
	else
	{
		//
		// pop up the browse dlgbox
		//
		hr = br.BrowseFolder(NULL, lpszStartFolder, szFolder, ARRAYSIZE(szFolder));
		if (SUCCEEDED(hr))
		{
			*pbstrFolder = SysAllocString(T2OLE(szFolder));
		}

	}

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		*pbstrFolder = NULL;
	}

	return hr;
}













//
//Only allow one of these dialogs at a time.
//
bool CBrowseFolder::s_bBrowsing = false;

//
//Max length of compacted path string in dialog status line (so it doesn't get too long).
//
#define MAX_BROWSEDLG_COMPACT_PATH   30

//
//Ctor
//
CBrowseFolder::CBrowseFolder(LONG lFlag)
    :   m_hwParent(0)
{
	m_szFolder[0] = _T('\0');
	
	m_fValidateWrite	= 0 == (IUBROWSE_WRITE_ACCESS & lFlag) ? FALSE : TRUE;
	m_fValidateUI		= 0 == (IUBROWSE_AFFECT_UI & lFlag) ? FALSE : TRUE;

}


//
//Dtor
//
CBrowseFolder::~CBrowseFolder()
{
}


//----------------------------------------------------------------------
// BrowseCallbackProc
//
//  Callback procedure used by SHBrowseForFolder() API call.
//
//	This callback function handles the initialization of the browse dialog and when
//	the user changes the selection in the tree-view.  We want to keep updating the 
//	g_szBrowsePath buffer with selection changes until the user clicks OK.
//  
// Returns: 
//  0
//
//----------------------------------------------------------------------
int CALLBACK CBrowseFolder::_BrowseCallbackProc( HWND hwDlg, UINT uMsg, LPARAM lParam, LPARAM lpData )
{    
    CBrowseFolder* pThis = (CBrowseFolder*) lpData;
    int iRet = 0;
    BOOL bValidated = FALSE;
    
    switch(uMsg)
    {
    case BFFM_INITIALIZED:
        {
			//
            // Initialize the dialog with the OK button and m_szFolder
			//
			bValidated = (ERROR_SUCCESS == ValidateFolder(pThis->m_szFolder, pThis->m_fValidateWrite) || !pThis->m_fValidateUI);
            SendMessage(hwDlg, BFFM_ENABLEOK, 0, bValidated);
			//
			// 469738 IU - BrowseForFolder shows incorrect selection when passed in a start folder name
			//
			// Always select the folder passed in regardless of the bValidated flag
			//
			SendMessage(hwDlg, BFFM_SETSELECTION, TRUE, (LPARAM) pThis->m_szFolder);

            return 0;
            break;

        } //case BFFM_INITIALIZED
        
    case BFFM_SELCHANGED:
        {
            HRESULT hr = S_OK;
            TCHAR pszPath[MAX_PATH];
            LPITEMIDLIST pidl = (LPITEMIDLIST) lParam;

            //
            // Validate folder with a status message
            //
            if (SHGetPathFromIDList(pidl, pszPath))
            {
				//
				// if it's file system, validate the path
				//
                bValidated = (ERROR_SUCCESS == ValidateFolder(pszPath, pThis->m_fValidateWrite) || !pThis->m_fValidateUI);

				if (bValidated)
				{
				    hr = StringCchCopyEx(pThis->m_szFolder, ARRAYSIZE(pThis->m_szFolder), pszPath,
				                         NULL, NULL, MISTSAFE_STRING_FLAGS);
				    if (FAILED(hr))
				    {
				        pThis->m_szFolder[0] = _T('\0');

				        // since we've failed, just set bValidated to FALSE and use that failure path
				        bValidated = FALSE;
				    }
				}

				SendMessage(hwDlg, BFFM_ENABLEOK, 0, bValidated);
				if (bValidated)
				{
					//SendMessage(hwDlg, BFFM_SETSTATUSTEXT, 0, (LPARAM) (LPCTSTR)pszCompactPath);
					SendMessage(hwDlg, BFFM_SETSTATUSTEXT, 0, (LPARAM) (LPCTSTR)pszPath);
				}
            }

            break;

        } //case BFFM_SELCHANGED

    } //switch(uMsg)

    return iRet;
}  


//----------------------------------------------------------------------
// 
// main public function
//
//----------------------------------------------------------------------
HRESULT CBrowseFolder::BrowseFolder(HWND hwParent, LPCTSTR lpszDefaultPath, 
                                    LPTSTR szPathSelected, DWORD cchPathSelected)
{
	HRESULT			hr = S_OK;
	BROWSEINFO		br;
	LPCITEMIDLIST	pidl;

	LOG_Block("BrowseFolder");

	m_szFolder[0] = szPathSelected[0] = _T('\0');

	//
	//Only allow one of thes Browse dialogs at a time.
	//
	if (s_bBrowsing)
	{
		hr = HRESULT_FROM_WIN32(ERROR_BUSY);
		LOG_ErrorMsg(hr);
		return hr;
	}
	else
	{
		s_bBrowsing = true;
	}

	m_hwParent = hwParent;
	hr = StringCchCopyEx(m_szFolder, ARRAYSIZE(m_szFolder), lpszDefaultPath, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	if (FAILED(hr))
	{
	    m_szFolder[0] = _T('\0');
		LOG_ErrorMsg(hr);
		return hr;
	}

	//
	//Browse dialog parameters
	//
    br.hwndOwner		= hwParent;
	br.pidlRoot			= NULL;			            //rooted at desktop
	br.pszDisplayName	= NULL;	
	br.lpszTitle		= NULL;
	br.ulFlags			= BIF_RETURNONLYFSDIRS|BIF_STATUSTEXT;     //only want FS dirs, and a status line
	br.lpfn				= _BrowseCallbackProc;
	br.lParam			= (__int3264)this;
	br.iImage			= 0;

	//
	// Popup browse dialog
	//
	pidl = SHBrowseForFolder(&br);

    if (0 == pidl)
    {
		//
        // Cancel pressed
		//
		LOG_Out(_T("User clicked CANCEL button!"));
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    else
    {
		//
		// 469729  IU - BrowseForFolder does not return error when passed IUBROWSE_WRITE_ACCESS flag
		//
		// For the case of IUBROWSE_WRITE_ACCESS, but **NO** IUBROWSE_AFFECT_UI flag, the user may
		// have selected a folder that has no write access and clicked OK, which will return the
		// folder with no write access. We have to call ValidateFolder once again here. We
		// probably shouldn't allow IUBROWSE_WRITE_ACCESS without IUBROWSE_AFFECT_UI, but since
		// we do we have to have this fix.
		//
		if (m_fValidateWrite && ERROR_SUCCESS != ValidateFolder(m_szFolder, m_fValidateWrite))
		{
			LOG_Out(_T("We should have write access to the folder, but don't -- return E_ACCESSDENIED"));
			hr = E_ACCESSDENIED;
		}
		//
		// Return the folder even if E_ACCESSDENIED, so caller can advise user
		//

    	hr = StringCchCopyEx(szPathSelected, cchPathSelected, m_szFolder, 
    	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    	if (FAILED(hr))
    	{
    	    szPathSelected[0] = _T('\0');
    		LOG_ErrorMsg(hr);
    	}
		
		LOG_Out(_T("User selected path %s"), m_szFolder);
		LPMALLOC pMalloc = NULL;
		if (SUCCEEDED(SHGetMalloc(&pMalloc)) && NULL != pMalloc)
		{
			pMalloc->Free((LPVOID) pidl);
			pMalloc->Release();
		}
		/*
		throughout MSDN, there is no mentioning of what to do if failed to get shell malloc object.
		so, we'll have to assume SHGetMalloc() never fail.
		else
		{
			CoTaskMemFree((void*)pidl);
		}
		*/
        pidl = 0;
    }

    s_bBrowsing = false;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuctl\update.cpp ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Update.cpp
//
//  Owner:  JHou
//
//  Description:
//
//   Industry Update v1.0 client control stub - Implementation of CUpdate
//
//
//  Revision History:
//
//  Date		Author		Desc
//	~~~~		~~~~~~		~~~~
//  9/15/2000	JHou		created.
//
//=======================================================================
#include "stdafx.h"
#include "iu.h"
#include "iucommon.h"
#include "IUCtl.h"
#include "Update.h"
#include "iudl.h"
#include "selfupd.h"
#include "loadengine.h"
#include <logging.h>
#include <fileutil.h>
#include <trust.h>
#include <osdet.h>
#include <exdisp.h>
#include <UrlAgent.h>
#include <wusafefn.h>

typedef BOOL (WINAPI* pfn_InternetCrackUrl)(LPCTSTR, DWORD, DWORD, LPURL_COMPONENTS);

extern HANDLE g_hEngineLoadQuit;
extern CIUUrlAgent *g_pIUUrlAgent;

#define Initialized		(2 == m_lInitState)


/////////////////////////////////////////////////////////////////////////////
//
// declaration of function template for CoFreeUnusedLibrariesEx(), which is
// available on Win98+ and Win2000+ only, in ole32.dll
//
/////////////////////////////////////////////////////////////////////////////
typedef void (WINAPI * PFN_CoFreeUnusedLibrariesEx)	(IN DWORD dwUnloadDelay, 
														 IN DWORD dwReserved);
extern "C" const CLSID CLSID_Update2;
typedef HRESULT (STDMETHODCALLTYPE* PROC_RegServer)(void);

DWORD MyGetModuleFileName(HMODULE hModule, LPTSTR pszBuf, DWORD cchBuf);
BOOL IsThisUpdate2();

/////////////////////////////////////////////////////////////////////////////
// CUpdate

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
/////////////////////////////////////////////////////////////////////////////
CUpdate::CUpdate()
    : m_EvtWindow(this),
      m_dwSafety(0),
	  m_dwMode(0x0),
	  m_hValidated(E_FAIL),				// container not validated yet
	  m_fUseCompression(TRUE),
      m_fOfflineMode(FALSE),
      m_hEngineModule(NULL),
	  m_pClientSite(NULL),
	  m_lInitState(0L),
	  m_dwUpdateInfo(0x0),
	  m_hIUEngine(NULL)
{
	m_szReqControlVer[0] = _T('\0');
	m_gfInit_csLock = SafeInitializeCriticalSection(&m_lock);
	m_evtControlQuit = CreateEvent(NULL, TRUE, FALSE, NULL);
    m_EvtWindow.Create();

	/* 
	we decided to use the new Win32 API GetControlUpdateInfo() to expose these
	data and let a wrapper control to call it so we won't have reboot issue on 
	OS prior to WinXP


	//
	// try to free unused libraries
	//
	HMODULE hOle32Dll = LoadLibrary(_T("ole32.dll"));
	if (NULL != hOle32Dll)
	{
		//
		// The min platforms support CoFreeUnusedLibrariesEx() are W2K and W98
		// so we can't call it directly
		//
		PFN_CoFreeUnusedLibrariesEx pFreeLib = (PFN_CoFreeUnusedLibrariesEx)
													GetProcAddress(hOle32Dll, 
																   "CoFreeUnusedLibrariesEx");
		if (NULL != pFreeLib)
		{
			//
			// ask to release the unused library immediately, this will cause the COM objects
			// that being released (e.g., set obj to nothing) unloaded from memory immediately, 
			// so in control update case we can safely jump to a to use <OBJECT> with codebase 
			// to update the control and it won't cause reboot even though on this page we already 
			// loaded the control
			//
			pFreeLib(0, 0);
		}
		FreeLibrary(hOle32Dll);
	}

	//
	// figure out if we are upate 2, we are if this module name ends with "2.dll"
	//
	m_fIsThisUpdate2 = ::IsThisUpdate2();

  */

}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
/////////////////////////////////////////////////////////////////////////////
CUpdate::~CUpdate()
{
    m_EvtWindow.Destroy();

	if(m_gfInit_csLock)
	{
		DeleteCriticalSection(&m_lock);
	}
	if (NULL != m_evtControlQuit)
	{
		CloseHandle(m_evtControlQuit);
	}
	SafeReleaseNULL(m_pClientSite);
}


/////////////////////////////////////////////////////////////////////////////
// GetInterfaceSafetyOptions()
//
// Retrieves the safety options supported by the object.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;
	if (riid == IID_IDispatch)
	{
		*pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
		*pdwEnabledOptions = m_dwSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER;
	}
	else
	{
		*pdwSupportedOptions = 0;
		*pdwEnabledOptions = 0;
		hr = E_NOINTERFACE;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetInterfaceSafetyOptions()
//
// Makes the object safe for initialization or scripting.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	// If we're being asked to set our safe for scripting option then oblige
	if (riid == IID_IDispatch)
	{
		// Store our current safety level to return in GetInterfaceSafetyOptions
		m_dwSafety = dwEnabledOptions & dwOptionSetMask;
		return S_OK;
	}
	return E_NOINTERFACE;
}


/////////////////////////////////////////////////////////////////////////////
// InterfaceSupportsErrorInfo()
//
// Indicates whether the interface identified by riid supports the 
// IErrorInfo interface
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::InterfaceSupportsErrorInfo(REFIID riid)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	static const IID* arr[] = 
	{
		&IID_IUpdate
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// GetSystemSpec()
//
// Gets the basic system specs.
// Input:
// bstrXmlClasses - a list of requested classes in xml format, NULL if any.
//				    For example:
//				    <devices>
//				    <class name="video"/>
//				    <class name="sound" id="2560AD4D-3ED3-49C6-A937-4368C0B0E06A"/>
//				    </devices>
// Return:
// pbstrXmlDetectionResult - the detection result in xml format.
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetSystemSpec(BSTR	bstrXmlClasses,
									BSTR*	pbstrXmlDetectionResult)
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::GetSystemSpec");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetSystemSpec pfnGetSystemSpec = (PFN_GetSystemSpec)GetProcAddress(m_hEngineModule, "EngGetSystemSpec");
        DWORD dwFlags = 0x0;

        if (m_fOfflineMode)
        {
            dwFlags |= FLAG_OFFLINE_MODE;
        }

        if (NULL != m_hIUEngine && NULL != pfnGetSystemSpec)
		{
			hr = pfnGetSystemSpec(m_hIUEngine, bstrXmlClasses, dwFlags, pbstrXmlDetectionResult);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}
	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetManifest()
//
// Gets a catalog base on the specified information.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlSystemSpec - the detected system specifications in xml
// bstrXmlQuery - the user query infomation in xml
// Return:
// pbstrXmlCatalog - the xml catalog retrieved
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetManifest(BSTR			bstrXmlClientInfo,
								  BSTR			bstrXmlSystemSpec,
								  BSTR			bstrXmlQuery,
								  BSTR*			pbstrXmlCatalog)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetManifest");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetManifest pfnGetManifest = (PFN_GetManifest)GetProcAddress(m_hEngineModule, "EngGetManifest");

		if (NULL != m_hIUEngine && NULL != pfnGetManifest)
		{
			DWORD dwFlags = 0x0;
			
			if (m_fUseCompression)
			{
				dwFlags |= FLAG_USE_COMPRESSION;
			}
			
			hr = pfnGetManifest(m_hIUEngine, bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, dwFlags, pbstrXmlCatalog);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Detect()
//
// Do detection.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be detected 
// Output:
// pbstrXmlItems - the detected items in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Detect(BSTR		bstrXmlCatalog, 
							 BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Detect");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Detect pfnDetect = (PFN_Detect)GetProcAddress(m_hEngineModule, "EngDetect");
        DWORD dwFlags = 0x0;

        if (m_fOfflineMode)
        {
            dwFlags |= FLAG_OFFLINE_MODE;
        }

		if (NULL != m_hIUEngine && NULL != pfnDetect)
		{
			hr = pfnDetect(m_hIUEngine, bstrXmlCatalog, dwFlags, pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Download()
//
// Do synchronized downloading.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Download(BSTR			bstrXmlClientInfo,
							   BSTR			bstrXmlCatalog, 
							   BSTR			bstrDestinationFolder,
							   LONG			lMode,
							   IUnknown*	punkProgressListener,
							   BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Download");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Download pfnDownload = (PFN_Download)GetProcAddress(m_hEngineModule, "EngDownload");

		if (NULL != m_hIUEngine && NULL != pfnDownload)
		{
			hr = pfnDownload(m_hIUEngine,
							 bstrXmlClientInfo,
							 bstrXmlCatalog,
							 bstrDestinationFolder,
							 lMode,
							 punkProgressListener,
							 m_EvtWindow.GetEvtHWnd(),	// should we send event msg for sync download?
							 pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DownloadAsync()
//
// Download asynchronously -  the method will return before completion.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::DownloadAsync(BSTR		bstrXmlClientInfo,
									BSTR		bstrXmlCatalog, 
									BSTR		bstrDestinationFolder,
									LONG		lMode,
									IUnknown*	punkProgressListener, 
									BSTR		bstrUuidOperation,
									BSTR*		pbstrUuidOperation)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::DownloadAsync");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // if we are in offline mode we can't download from the internet.
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_DownloadAsync pfnDownloadAsync = (PFN_DownloadAsync)GetProcAddress(m_hEngineModule, "EngDownloadAsync");

		if (NULL != m_hIUEngine && NULL != pfnDownloadAsync)
		{
			hr = pfnDownloadAsync(m_hIUEngine,
								  bstrXmlClientInfo,
								  bstrXmlCatalog,
								  bstrDestinationFolder,
								  lMode,
								  punkProgressListener,
								  m_EvtWindow.GetEvtHWnd(),
								  bstrUuidOperation,
								  pbstrUuidOperation);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Install()
//
// Do synchronized installation.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// lMode - indicates different installation mode
// punkProgressListener - the callback function pointer for reporting install progress
// Output:
// pbstrXmlItems - the items with installation status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Install(BSTR      bstrXmlClientInfo,
                              BSTR		bstrXmlCatalog,
							  BSTR		bstrXmlDownloadedItems,
							  LONG		lMode,
							  IUnknown*	punkProgressListener,
							  BSTR*		pbstrXmlItems)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::Install");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // make sure offline mode parameter is set if SetProperty() Offline Mode was Set
        lMode |= UPDATE_OFFLINE_MODE;
    }

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_Install pfnInstall = (PFN_Install)GetProcAddress(m_hEngineModule, "EngInstall");

		if (NULL != m_hIUEngine && NULL != pfnInstall)
		{
			hr = pfnInstall(m_hIUEngine,
							bstrXmlClientInfo,
                            bstrXmlCatalog,
							bstrXmlDownloadedItems,
							lMode,
							punkProgressListener,
							m_EvtWindow.GetEvtHWnd(),
							pbstrXmlItems);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// InstallAsync()
//
// Install Asynchronously.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// lMode - indicates different installation mode
// punkProgressListener - the callback function pointer for reporting install progress
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::InstallAsync(BSTR         bstrXmlClientInfo,
                                   BSTR			bstrXmlCatalog,
								   BSTR			bstrXmlDownloadedItems,
								   LONG			lMode,
								   IUnknown*	punkProgressListener, 
								   BSTR			bstrUuidOperation,
								   BSTR*		pbstrUuidOperation)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::InstallAsync");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

    if (m_fOfflineMode)
    {
        // make sure offline mode parameter is set if SetProperty() Offline Mode was Set
        lMode |= UPDATE_OFFLINE_MODE;
    }

    //
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_InstallAsync pfnInstallAsync = (PFN_InstallAsync)GetProcAddress(m_hEngineModule, "EngInstallAsync");

		if (NULL != m_hIUEngine && NULL != pfnInstallAsync)
		{
			hr = pfnInstallAsync(m_hIUEngine,
								 bstrXmlClientInfo,
                                 bstrXmlCatalog,
								 bstrXmlDownloadedItems,
								 lMode,
								 punkProgressListener,
								 m_EvtWindow.GetEvtHWnd(),
								 bstrUuidOperation,
								 pbstrUuidOperation);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// SetOperationMode()
//		Set the operation status.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_COMMAND_PAUSE
//				UPDATE_COMMAND_RESUME
//				UPDATE_COMMAND_CANCEL
//				UPDATE_NOTIFICATION_COMPLETEONLY
//				UPDATE_NOTIFICATION_ANYPROGRESS
//				UPDATE_NOTIFICATION_1PCT
//				UPDATE_NOTIFICATION_5PCT
//				UPDATE_NOTIFICATION_10PCT
//				UPDATE_SHOWUI
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::SetOperationMode(
								BSTR	bstrUuidOperation,
								LONG	lMode)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::SetOperationMode");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_SetOperationMode pfnSetOperationMode = (PFN_SetOperationMode)GetProcAddress(m_hEngineModule, "EngSetOperationMode");

		if (NULL != m_hIUEngine && NULL != pfnSetOperationMode)
		{
			hr = pfnSetOperationMode(m_hIUEngine, bstrUuidOperation, lMode);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetHistory()
//
// Get the history log.
// Input:
// bstrDateTimeFrom - the start date and time for which a log is required.
//                    This is a string in ANSI format (YYYY-MM-DDTHH-MM). 
//                    If the string is empty, there will be no date restriction 
//                    of the returned history log.
// bstrDateTimeTo - the end date and time for which a log is required.
//                  This is a string in ANSI format (YYYY-MM-DDTHH-MM).
//                  If the string is empty, there will be no date restriction
//                  of the returned history log.
// bstrClient - the name of the client that initiated the action. If this parameter 
//              is null or an empty string, then there will be no filtering based 
//              on the client.
// bstrPath - the path used for download or install. Used in the corporate version 
//            by IT managers. If this parameter is null or an empty string, then 
//            there will be no filtering based on the path.
// Output:
// pbstrLog - the history log in xml format
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetHistory(BSTR		bstrDateTimeFrom,
								 BSTR		bstrDateTimeTo,
								 BSTR		bstrClient,
								 BSTR		bstrPath,
								 BSTR*		pbstrLog)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetHistory");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetHistory pfnGetHistory = (PFN_GetHistory)GetProcAddress(m_hEngineModule, "EngGetHistory");

		if (NULL != m_hIUEngine && NULL != pfnGetHistory)
		{
			hr = pfnGetHistory(m_hIUEngine,
							   bstrDateTimeFrom,
							   bstrDateTimeTo,
							   bstrClient,
							   bstrPath,
							   pbstrLog);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}


	}
    
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// private overriding function InternalRelease(), to unlock the engine
// if the reference (before the release) is 1, i.e., the last ref
// count about to be released
//
/////////////////////////////////////////////////////////////////////////////
ULONG CUpdate::InternalRelease()
{
	if (1 == m_dwRef)
	{
		//
		// the control is going to really gone, we need to make sure that 
		// if the engine is loaded, we unload it here.
		//
		UnlockEngine();
		CleanupDownloadLib();
	}

	return CComObjectRootEx<CComMultiThreadModel>::InternalRelease();
}

/////////////////////////////////////////////////////////////////////////////
// UnlockEngine()
//
// release the engine dll if ref cnt of engine is down to zero
/////////////////////////////////////////////////////////////////////////////
HRESULT CUpdate::UnlockEngine()
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	TCHAR szSystemDir[MAX_PATH];
    TCHAR szEngineDllPath[MAX_PATH];
    TCHAR szEngineNewDllPath[MAX_PATH];
	int iVerCheck = 0;
	HRESULT hr = S_OK;

	SetEvent(m_evtControlQuit);

	EnterCriticalSection(&m_lock);

	if (NULL != m_hEngineModule)
	{
		//
		// We have to delete the engine instance we are using. This will clean up
		// all resources, stop threads, etc. for the instance we own.
		//
		PFN_DeleteEngUpdateInstance pfnDeleteEngUpdateInstance = (PFN_DeleteEngUpdateInstance) GetProcAddress(m_hEngineModule, "DeleteEngUpdateInstance");

		if (NULL != pfnDeleteEngUpdateInstance)
		{
			pfnDeleteEngUpdateInstance(m_hIUEngine);
		}

		//
		// Cleanup any global threads (it checks to see if we are last instance)
		//
		PFN_ShutdownGlobalThreads pfnShutdownGlobalThreads = (PFN_ShutdownGlobalThreads) GetProcAddress(m_hEngineModule, "ShutdownGlobalThreads");

		if (NULL != pfnShutdownGlobalThreads)
		{
			pfnShutdownGlobalThreads();
		}

		//
		// unload engine
		//
		FreeLibrary(m_hEngineModule);
        m_hEngineModule = NULL;
        m_lInitState = 0; // mark as uninitialized

		//
		// get path of enginenew.dll
		//
		GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir));
		hr = PathCchCombine(szEngineNewDllPath, ARRAYSIZE(szEngineNewDllPath), szSystemDir,ENGINENEWDLL);
		if (FAILED(hr))
		{
			return hr;
		}

		//
		// see if we should try to update the engine (locally)
		//
		HKEY hkey = NULL;
		DWORD dwStatus = 0;
		DWORD dwSize = sizeof(dwStatus);
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
		{
			RegQueryValueEx(hkey, REGVAL_SELFUPDATESTATUS, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		}
		if (FileExists(szEngineNewDllPath) && 
			S_OK == VerifyFileTrust(szEngineNewDllPath, NULL, ReadWUPolicyShowTrustUI()) &&
			SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
		{
			// an iuenginenew.dll exists, try replacing the engine.dll This will fail if this is
			// not the last process using the engine. This is not a problem, when that process
			// finishes it will rename the DLL.
			hr = PathCchCombine(szEngineDllPath, ARRAYSIZE(szEngineDllPath), szSystemDir,ENGINEDLL);
			if (FAILED(hr))
			{
				return hr;
			}
			if (SUCCEEDED(CompareFileVersion(szEngineDllPath, szEngineNewDllPath, &iVerCheck)) &&
				iVerCheck < 0 &&
				TRUE == MoveFileEx(szEngineNewDllPath, szEngineDllPath, MOVEFILE_REPLACE_EXISTING))
			{
				// Rename was Successful.. reset RegKey Information about SelfUpdate Status
				// Because the rename was successful we know no other processes are interacting
				// It should be safe to set the reg key.
				dwStatus = 0;	// PreFast
				RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
			}
		}
		else if (SELFUPDATE_COMPLETE_UPDATE_BINARY_REQUIRED == dwStatus)
		{
			// registry indicates rename required, but enginenew DLL does not exist. Reset registry
			dwStatus = 0;
			RegSetValueEx(hkey, REGVAL_SELFUPDATESTATUS, 0, REG_DWORD, (LPBYTE)&dwStatus, sizeof(dwStatus));
		}
        if (NULL != hkey)
        {
            RegCloseKey(hkey);
        }
	}

	LeaveCriticalSection(&m_lock);
	ResetEvent(m_evtControlQuit);

	return S_OK;
}




/**
*
* Get the mode of a specified operation.
*
* @param bstrUuidOperation: same as in SetOperationMode()
* @param plMode - the retval for the mode found in a bitmask for:
*					(value in brackets [] means default)
*					UPDATE_COMMAND_PAUSE (TRUE/[FALSE])
*					UPDATE_COMMAND_RESUME (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_COMPLETEONLY (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_ANYPROGRESS ([TRUE]/FALSE)
*					UPDATE_NOTIFICATION_1PCT (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_5PCT (TRUE/[FALSE])
*					UPDATE_NOTIFICATION_10PCT (TRUE/[FALSE])
*					UPDATE_SHOWUI (TRUE/[FALSE])
*
*/
STDMETHODIMP CUpdate::GetOperationMode(BSTR bstrUuidOperation, LONG *plMode)
{
	HRESULT hr = E_FAIL;
	LOG_Block("CUpdate::GetOperationMode");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_GetOperationMode pfnGetOperationMode = (PFN_GetOperationMode)GetProcAddress(m_hEngineModule, "EngGetOperationMode");

		if (NULL != m_hIUEngine && NULL != pfnGetOperationMode)
		{
			hr = pfnGetOperationMode(m_hIUEngine, bstrUuidOperation, plMode);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}

	}
    
	return hr;
}




/**
* 
* Set a property of this control
*		Calling this method will not cause the engine loaded
*
* @param lProperty - the identifier to flag which property need changed
*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
*
* @param varValue - the value to change
*
*/
STDMETHODIMP CUpdate::SetProperty(LONG lProperty, VARIANT varValue)
{
	LOG_Block("CUpdate::SetProperty");
	HRESULT hr = S_OK;

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	switch(lProperty)
	{
	case UPDATE_PROP_USECOMPRESSION:
		if (VT_BOOL != varValue.vt)
		{
			hr = E_INVALIDARG;
			LOG_ErrorMsg(hr);
		}
		else
		{
			m_fUseCompression = (VARIANT_TRUE == varValue.boolVal) ? TRUE : FALSE;
		}
		break;
    case UPDATE_PROP_OFFLINEMODE:
        if (VT_BOOL != varValue.vt)
        {
            hr = E_INVALIDARG;
            LOG_ErrorMsg(hr);
        }
        else
        {
            m_fOfflineMode = (VARIANT_TRUE == varValue.boolVal) ? TRUE : FALSE;
        }
        break;
	default:
		return E_NOTIMPL;
	}

	return S_OK;
}



/**
* 
* Retrieve a property of this control
*		Calling this method will not cause the engine loaded
*
* @param lProperty - the identifier to flag which property need retrieved
*						UPDATE_PROP_OFFLINEMODE (TRUE/[FALSE])
*						UPDATE_PROP_USECOMPRESSION ([TRUE]/FALSE)
*
* @param varValue - the value to retrieve
*					
*/
STDMETHODIMP CUpdate::GetProperty(LONG lProperty, VARIANT *pvarValue)
{
	LOG_Block("CUpdate::GetProperty");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

	if (NULL == pvarValue)
	{
		return E_INVALIDARG;
	}
	
	VariantInit(pvarValue);

	switch(lProperty)
	{
	case UPDATE_PROP_USECOMPRESSION:
		pvarValue->vt = VT_BOOL;
		pvarValue->boolVal = (m_fUseCompression) ? VARIANT_TRUE : VARIANT_FALSE;
		break;
    case UPDATE_PROP_OFFLINEMODE:
        pvarValue->vt = VT_BOOL;
        pvarValue->boolVal = (m_fOfflineMode) ? VARIANT_TRUE : VARIANT_FALSE;
        break;
	default:
		return E_NOTIMPL;
	}

	return S_OK;
}



/////////////////////////////////////////////////////////////////////////////
//
// Primarily expose shlwapi BrowseForFolder API, can also do checking
// on R/W access if flagged so.
//
// @param bstrStartFolder - the folder from which to start. If NULL or empty str
//							is being passed in, then start from desktop
//
// @param flag - validating check 
//							UI_WRITABLE for checking write access, OK button may disabled. 
//							UI_READABLE for checking read access, OK button may disabled. 
//							NO_UI_WRITABLE for checking write access, return error if no access
//							NO_UI_READABLE for checking read access,  return error if no access
//							0 (default) for no checking.
//
// @param pbstrFolder - returned folder if a valid folder selected
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::BrowseForFolder(BSTR bstrStartFolder, LONG flag, BSTR* pbstrFolder)
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::BrowseForFolder");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
		//
		// engine is current, delegate the call to engine
		//
		PFN_BrowseForFolder pfnBrowseForFolder = (PFN_BrowseForFolder)GetProcAddress(m_hEngineModule, "EngBrowseForFolder");

		if (NULL != m_hIUEngine && NULL != pfnBrowseForFolder)
		{
			hr = pfnBrowseForFolder(m_hIUEngine, bstrStartFolder, flag, pbstrFolder);
		}
		else
		{
			LOG_ErrorMsg(ERROR_INVALID_DLL);
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
		}
	}
    
	return hr;
}

/**
*
* Allows the Caller to Request the Control to do a Reboot 
*
*/
STDMETHODIMP CUpdate::RebootMachine()
{
	HRESULT hr = E_FAIL;

	LOG_Block("CUpdate::RebootMachine");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}

 	//
	// load the engine if it's not up-to-date
	//
	if (Initialized && SUCCEEDED(hr = ValidateControlContainer()))
	{
        PFN_RebootMachine pfnRebootMachine = (PFN_RebootMachine)GetProcAddress(m_hEngineModule, "EngRebootMachine");

        if (NULL != m_hIUEngine && NULL != pfnRebootMachine)
        {
            hr = pfnRebootMachine(m_hIUEngine);
        }
        else
        {
            LOG_ErrorMsg(ERROR_INVALID_DLL);
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DLL);
        }
    }
    return hr;
}

//
//  Override of IObjectWithSite::SetSite()
//  Internet Explorer QIs for IObjectWithSite, and calls this method
//  with a pointer to its IOleClientSite
//
STDMETHODIMP CUpdate::SetSite(IUnknown* pSite)
{
	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	SafeReleaseNULL(m_pClientSite);
    m_pClientSite = pSite;
	if (NULL != m_pClientSite)
		m_pClientSite->AddRef();
    return IObjectWithSiteImpl<CUpdate>::SetSite(pSite);
}




/**
* 
* Security feature: make sure if the user of this control is
* a web page then the URL can be found in iuident.txt
*
* This function should be called after iuident refreshed.
*
* Return: TRUE/FALSE, to tell if we can continue
*					
*/


const TCHAR IDENT_IUSERVERCACHE[]		= _T("IUServerURLs");
const TCHAR IDENT_IUSERVERCOUNT[]		= _T("ServerCount");
const TCHAR IDENT_IUSERVER[]			= _T("Server");



HRESULT CUpdate::ValidateControlContainer(void)
{
	LOG_Block("ValidateControlContainer");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	IServiceProvider* pISP = NULL;
	IWebBrowserApp* pWeb = NULL;
	BSTR bstrUrl = NULL;
	LPTSTR lpszUrl = NULL;
#if !(defined(_UNICODE) || defined(UNICODE))
	// ANSI build
	LPSTR lpszAnsiUrl = NULL;
#endif
	TCHAR szIUDir[MAX_PATH];
	TCHAR szIdentFile[MAX_PATH];
	TCHAR szServer[32];
	LPTSTR szValidURL = NULL;
			
	if (E_FAIL != m_hValidated)
	{
		//
		// has been invalidated already
		//
		LOG_Internet(_T("Validate result: %s"), SUCCEEDED(m_hValidated) ? _T("S_OK") : _T("INET_E_INVALID_URL"));
		return m_hValidated;
	}
	//
	// check to see if the container is a web page/site, if
	// not done so yet.
	//
	if (NULL != m_pClientSite)
	{
		//
		// this is a web site!
		//
		m_hValidated = INET_E_INVALID_URL;
		LOG_Internet(_T("Found control called by a web page"));

		if (SUCCEEDED(m_pClientSite->QueryInterface(IID_IServiceProvider, (void**)&pISP)) &&
			NULL != pISP &&
			SUCCEEDED(pISP->QueryService(IID_IWebBrowserApp, IID_IWebBrowserApp, (void**)&pWeb)) &&
			NULL != pWeb &&
			SUCCEEDED(pWeb->get_LocationURL(&bstrUrl)) && 
			NULL != bstrUrl)
		{
#if defined(_UNICODE) || defined(UNICODE)
			lpszUrl = bstrUrl;
#else		// ANSI build
			int nBufferLength = WideCharToMultiByte(CP_ACP, 0, bstrUrl, -1, NULL, 0, NULL, NULL);

			lpszAnsiUrl = (LPSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBufferLength);
			if (NULL == lpszAnsiUrl || 0 == nBufferLength)
			{
				//
				// Unfortunately, we return this error in place of E_OUTOFMEMORY, but the most
				// likely scenario that would cause this would be a security attack (bad URL)
				//
				goto CleanUp;	// Will return INET_E_INVALID_URL
			}

			WideCharToMultiByte(CP_ACP, 0, bstrUrl, -1, lpszAnsiUrl, nBufferLength, NULL, NULL);
			lpszUrl = lpszAnsiUrl;
#endif

			LOG_Internet(_T("Web address = %s"), lpszUrl);

			//
			// no matter what protocol specified in this URL
			// (can be anything: http, ftp, UNC, path...)
			// we just need to verify it against iuident.txt
			//

			szValidURL = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			if (NULL == szValidURL)
			{
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				LOG_ErrorMsg(E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}
			
			GetIndustryUpdateDirectory(szIUDir);
			m_hValidated = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir,IDENTTXT);
			if (FAILED(m_hValidated))
			{
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				SafeHeapFree(szValidURL);
				LOG_ErrorMsg(m_hValidated);
				return m_hValidated;
			}

			// Fix of bug 557430: IU: Security: Use InternetCrackUrl to verify server url used by control.
			URL_COMPONENTS urlComp;
			ZeroMemory(&urlComp, sizeof(urlComp));
			urlComp.dwStructSize = sizeof(urlComp);

			// Only interested in the hostname
			LPTSTR pszHostName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			urlComp.lpszHostName = pszHostName;
			urlComp.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

#if defined(UNICODE)
			pfn_InternetCrackUrl pfnInternetCrackUrl = (pfn_InternetCrackUrl)GetProcAddress(
					GetModuleHandle(_T("wininet.dll")), "InternetCrackUrlW");
#else
			pfn_InternetCrackUrl pfnInternetCrackUrl = (pfn_InternetCrackUrl)GetProcAddress(
					GetModuleHandle(_T("wininet.dll")), "InternetCrackUrlA");
#endif

			if (pfnInternetCrackUrl != NULL)
			{
				BOOL fRet = (*pfnInternetCrackUrl)(lpszUrl, 0, 0, &urlComp);
				if (fRet==FALSE) {
					SafeHeapFree(pszHostName);
					m_hValidated = INET_E_INVALID_URL;
					goto CleanUp;
				}
			}
			else
			{
				SafeHeapFree(pszHostName);
				SafeReleaseNULL(pISP);
				SafeReleaseNULL(pWeb);
				SysFreeString(bstrUrl);
				SafeHeapFree(szValidURL);
				m_hValidated = ERROR_PROC_NOT_FOUND;
				LOG_ErrorMsg(m_hValidated);
				return m_hValidated;		
			}
				
			//
			// get number to servers to compare
			//
			int iServerCnt = GetPrivateProfileInt(IDENT_IUSERVERCACHE,
											  IDENT_IUSERVERCOUNT,
											  -1,
											  szIdentFile);
			
			//
			// loop through 
			//
			URL_COMPONENTS urlCompi;
			m_hValidated = INET_E_INVALID_URL;
			for (INT i=1; i<=iServerCnt; i++)
			{
				StringCchPrintfEx(szServer,ARRAYSIZE(szServer),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%d"), IDENT_IUSERVER, i);
			
				//
				// get valid server from iuident
				//
				GetPrivateProfileString(IDENT_IUSERVERCACHE,
										szServer,
										_T(""),
										szValidURL,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				ZeroMemory(&urlCompi, sizeof(urlCompi));
				urlCompi.dwStructSize = sizeof(urlCompi);

				LPTSTR pszHostNamei = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				urlCompi.lpszHostName = pszHostNamei;
				urlCompi.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

				if (TRUE == (*pfnInternetCrackUrl)(szValidURL, 0, 0, &urlCompi))
				{
					if (0 == lstrcmpi(urlComp.lpszHostName, urlCompi.lpszHostName))
					{
						//
						// Found the current site URL is in this valid URL domain!
						//
						LogMessage("Windows Update Web Site has a valid address: %ls", bstrUrl);
						m_hValidated = S_OK;
						SafeHeapFree(pszHostNamei);
						break;
					}
				}
				SafeHeapFree(pszHostNamei);
			}
			SafeHeapFree(pszHostName);
		}
	}
	else
	{
		//
		// NTRAID#NTBUG9-436604-2001/07/17-waltw  Security fix: block possible user system information
		// leak to non WU callers
		//
		// If the COM user doesn't call SetSite on our IObjectWithSiteImpl to set m_pClientSite or doesn't
		// support IID_IWebBrowserApp functionality on the client site then we won't support them since
		// we can't validate the URL that invoked us
		//
		m_hValidated = INET_E_INVALID_URL;
	}

CleanUp:
	SafeReleaseNULL(pISP);
	SafeReleaseNULL(pWeb);
	SysFreeString(bstrUrl);
	SafeHeapFree(szValidURL);

	LOG_Internet(_T("Validate result: %s"), SUCCEEDED(m_hValidated) ? _T("S_OK") : _T("INET_E_INVALID_URL"));

	if (FAILED(m_hValidated) && NULL != lpszUrl)
	{
#if defined(UNICODE) || defined(_UNICODE)
		LogError(m_hValidated, "Site URL %ls is not valid", lpszUrl);
#else
		LogError(m_hValidated, "Site URL %s is not valid", lpszUrl);
#endif
	}


#if !(defined(UNICODE) || defined(_UNICODE))
	if (NULL != lpszAnsiUrl)
	{
		HeapFree(GetProcessHeap(), 0, (LPVOID) lpszAnsiUrl);
	}
#endif

	return m_hValidated;
}



/////////////////////////////////////////////////////////////////////////////
//
// PRIVATE DetectEngine()
//
// download the ident and find out if need to update engine
//
// Note that this function itself is not thread safe. Need to call it
// inside critical section
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CUpdate::DetectEngine(BOOL *pfUpdateAvail)
{
	LOG_Block("GetPropUpdateInfo()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_OK;

	if (NULL == pfUpdateAvail)
	{
		return E_INVALIDARG;
	}

	*pfUpdateAvail = FALSE;

	//
	// get the latest ident
	//
	if (NULL == m_hEngineModule)
	{
		//
        // This is the first load of the engine for this instance, check for selfupdate first.
        // First step is to check for an updated iuident.cab and download it.
		//

		//
        // Only Download the Ident if we are NOT in Offline Mode
		//
        if (!m_fOfflineMode)
		{
		    //
			// download iuident and populate g_pIUUrlAgent
			//
			if (FAILED(hr = DownloadIUIdent_PopulateData()))
			{
				LOG_ErrorMsg(hr);
				return hr;
			}

			//
			// check engine update info. Note that since 2nd pram is FALSE
			// means don't do any actual update, therefore its 1st argument
			// is also ignored.
			//
            hr = SelfUpdateCheck(
								 FALSE,			// async update? ignored now
								 FALSE,			// don't do actual update
								 m_evtControlQuit, // quit event.
								 NULL,			// no event firing
								 NULL			// no callback needed
								 );

            if (IU_SELFUPDATE_FAILED == hr)
            {
                LOG_Error(_T("SelfUpdate Failed, using current Engine DLL"));
			    hr = S_FALSE; // not fatal, let the existing engine work
            }

            *pfUpdateAvail = (S_FALSE == hr);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
// Initialize() API must be called before any other API will function
//
// If any other API is called before the control is initialized, 
// that API will return OLE_E_BLANK, signalling this OLE control is an 
// uninitialized object (although in this case it's a bit different from 
// its original meaning)
//
// Parameters:
//
//	lInitFlag - IU_INIT_CHECK, cause Initialize() download ident and check if any
//				of the components need updated. currently we support control version
//				check and engine version check. Return value is a bit mask
//
//			  - IU_INIT_UPDATE_SYNC, cause Initialize() kicks off update engine
//				process if already called by IU_INIT_CHECK and a new engine is available.
//				When API returns, the update process is finished.
//
//			  - IU_INIT_UPDATE_ASYNC, cause Initialize() kicks off update engine
//				process in Asynchronized mode if already called by IU_INIT_CHECK and
//				a new engine is available. This API will return right after the 
//				update process starts. 
//
//	punkUpdateCompleteListener - this is a pointer to a user-implemented 
//				COM callback feature. It contains only one function OnComplete() that
//				will be called when the engine update is done.
//				This value can be NULL.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::Initialize(LONG lInitFlag, IUnknown *punkUpdateCompleteListener, LONG *plRetVal)
{
	HRESULT hr = S_OK;

	LOG_Block("Initialize()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	TCHAR szFilePath[MAX_PATH + 1] = {0};
	FILE_VERSION verControl;
	int   iCompareResult = 0;
	DWORD dwErr = 0;
    char szAnsiRequiredControlVersion[64];

	LOG_Out(_T("Parameters: (0x%08x, 0x%08x, 0x%08x)"), lInitFlag, punkUpdateCompleteListener, plRetVal);

	//
	// we should to previlidge check first.
	//
	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		return HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED);
	}
	if (0x0 == GetLogonGroupInfo())
	{
		//
		// if the current logon is neither member of admins nor power users
		// or windows update is disabled, there is no need to continue
		//
		return E_ACCESSDENIED;
	}


	USES_CONVERSION;
	
	EnterCriticalSection(&m_lock);

	LPTSTR ptszLivePingServerUrl = NULL;
	LPTSTR ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pIUUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}

	if (IU_INIT_CHECK == lInitFlag)
	{
		// RAID: 453770 IU - IUCTL - Initialize check returns Engine update required
		// after downloading new engine using Initialize Sync/Async
		// Fix: initialize dwFlag to 0 rather than m_dwUpdateInfo (carried forward
		// previous IU_UPDATE_ENGINE_BIT even when new engine had been brought down).
		DWORD dwFlag = 0;
		BOOL fEngineUpdate = FALSE;

		FILE_VERSION verCurrent;


		CleanUpIfFalseAndSetHrMsg((NULL == plRetVal), E_INVALIDARG);

		hr = DetectEngine(&fEngineUpdate);
		if (IU_SELFUPDATE_USENEWDLL == hr)
		{
			//
			// found engine already been updated by someone,
			// but not renamed to iuengine.dll yet
			//
			// doesn't matter to us,since we always try
			// to load enginenew before we try to load eng.
			//
			hr = S_OK;
		}

		if (g_pIUUrlAgent->HasBeenPopulated())
		{
			ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
			CleanUpFailedAllocSetHrMsg(ptszLivePingServerUrl);

			if (FAILED(g_pIUUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get live ping server URL"));
				SafeHeapFree(ptszLivePingServerUrl);
			}
		}

		CleanUpIfFailedAndMsg(hr);

		if (fEngineUpdate)
		{
			dwFlag = IU_UPDATE_ENGINE_BIT;
		}

		//
		// get required version number of iuctl from iuident
		//

        GetIndustryUpdateDirectory(szFilePath);
		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), IDENTTXT));

		(void) GetPrivateProfileString(
									_T("IUControl"), 
									_T("ControlVer"), 
									_T("0.0.0.0"), 
									m_szReqControlVer, 
									ARRAYSIZE(m_szReqControlVer), 
									szFilePath);

#ifdef UNICODE
        WideCharToMultiByte(CP_ACP, 0, m_szReqControlVer, -1, szAnsiRequiredControlVersion, 
            sizeof(szAnsiRequiredControlVersion), NULL, NULL);
		ConvertStringVerToFileVer(szAnsiRequiredControlVersion, &verControl);
#else
		ConvertStringVerToFileVer(m_szReqControlVer, &verControl);
#endif

		//
		// get current iuctl.dll version number
		//
		szFilePath[0] = _T('\0');
		if (0 == GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuctl.dll")));

		//
		// change for bug fix 488487 by charlma 11/30/2001
		// in order to output file ver to freelog, we dig out verionn here:
		//

		//
		// if we failed to get the version, GetFileVersion() alraedy produced debug log. 
		// we just use 0.0.0.0 to do compare, since in that case we need to update it!
		//
		ZeroMemory((void*)(&verCurrent), sizeof(verCurrent));
		if (GetFileVersion(szFilePath, &verCurrent))
		{
			LogMessage("Current iuctl.dll version: %d.%d.%d.%d", 
										verCurrent.Major, 
										verCurrent.Minor, 
										verCurrent.Build, 
										verCurrent.Ext);
		}
		iCompareResult = CompareFileVersion(verCurrent, verControl);

		//CleanUpIfFailedAndSetHrMsg(CompareFileVersion(szFilePath, verControl, &iCompareResult));

		if (iCompareResult < 0)
		{
			//
			// if current control dll (szFilePath) has lower version
			// then the one specified in ident
			//
			dwFlag |= IU_UPDATE_CONTROL_BIT;

#if defined(UNICODE) || defined(_UNICODE)
			LogMessage("IUCtl needs update to %ls", m_szReqControlVer);
#else
			LogMessage("IUCtl needs update to %s", m_szReqControlVer);
#endif
		}

		//
		// also output engine version
		//
		if ((0 != GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)) &&
			SUCCEEDED(hr = PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuenginenew.dll"))) &&
			GetFileVersion(szFilePath, &verCurrent)) ||
			(0 != GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath)) &&
			SUCCEEDED(hr = PathCchAppend(szFilePath, ARRAYSIZE(szFilePath), _T("iuengine.dll"))) &&
			GetFileVersion(szFilePath, &verCurrent))
			)
		{
			LogMessage("Current iuengine.dll version: %d.%d.%d.%d", 
										verCurrent.Major, 
										verCurrent.Minor, 
										verCurrent.Build, 
										verCurrent.Ext);
		}

					
		*plRetVal = (LONG) dwFlag;
		m_dwUpdateInfo = dwFlag;

		if (0x0 == dwFlag)
		{
			//
			// no update needed. move to READY stage
			//
			m_lInitState = 2;
		}
		else
		{
			m_lInitState = 1; // we have update work to do!
		}
	}
	else
	{
		BOOL fSync = (IU_INIT_UPDATE_SYNC == lInitFlag);

		if (!fSync && (IU_INIT_UPDATE_ASYNC != lInitFlag))
		{
			//
			// unknown flag
			//
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}

		if (1 != m_lInitState || (m_dwUpdateInfo & IU_UPDATE_CONTROL_BIT))
		{
			//
			// if we are not indicated that update needed. this 
			// call shouldn't happen at all!
			//
			SetHrMsgAndGotoCleanUp(E_UNEXPECTED);
		}

		//
		// we need to check update again before we kick off the 
		// actual update process since we don't know when last
		// time you get the info saying we need to update. Probably
		// it's already been updated, or is being updated.
		//
		// so we call the check function again but this time tell 
		// the check function that if update needed then do it.
		//
		hr = SelfUpdateCheck(fSync, TRUE, m_evtControlQuit, this, punkUpdateCompleteListener);
		if (IU_SELFUPDATE_USENEWDLL == hr)
		{
			//
			// found engine already been updated by someone,
			// but not renamed to iuengine.dll yet
			//
			// doesn't matter to us,since we always try
			// to load enginenew before we try to load eng.
			//
			m_lInitState = 2;
			hr = S_OK;
		}


		if (fSync && SUCCEEDED(hr))
		{
			//
			// synchronized update done and successful
			//
			m_lInitState = 2;
		}


		if (NULL != plRetVal)
		{
			*plRetVal = (LONG)hr;	// result pass out: 0 or error code

		}
	}

	if (2 == m_lInitState)
	{
		if (NULL == m_hEngineModule)
		{
			//
			// check if iuengine new exist and validate the file
			//
			TCHAR szEnginePath[MAX_PATH + 1];
			TCHAR szEngineNewPath[MAX_PATH + 1];
			int cch = 0;
			int iVerCheck = 0;

			cch = GetSystemDirectory(szEnginePath, ARRAYSIZE(szEnginePath));
			CleanUpIfFalseAndSetHrMsg(cch == 0 || cch >= ARRAYSIZE(szEnginePath), HRESULT_FROM_WIN32(GetLastError()));

			(void) StringCchCopy(szEngineNewPath, ARRAYSIZE(szEngineNewPath), szEnginePath);

			hr = PathCchAppend(szEnginePath, ARRAYSIZE(szEnginePath), ENGINEDLL);
			CleanUpIfFailedAndMsg(hr);

			hr = PathCchAppend(szEngineNewPath, ARRAYSIZE(szEngineNewPath), ENGINENEWDLL);
			CleanUpIfFailedAndMsg(hr);

			//
			// try to verify trust of engine new
			//
			if (FileExists(szEngineNewPath) && 
				S_OK == VerifyFileTrust(szEngineNewPath, NULL, ReadWUPolicyShowTrustUI()) &&
				SUCCEEDED(CompareFileVersion(szEnginePath, szEngineNewPath, &iVerCheck)) &&
				iVerCheck < 0)
			{	
				//
				// load the engine
				//
				m_hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
			}
			if (NULL != m_hEngineModule)
			{
				LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
			}
			else
			{
				LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
				m_hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));

				if (NULL == m_hEngineModule)
				{
					dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
				}
			}

			//
			// If load engine succeeded, get a CEngUpdate instance and start aynsc misc worker threads
			//
			if (NULL != m_hEngineModule)
			{
#if defined(DBG)
				// Log error if m_hIUEngine isn't NULL
				if (NULL != m_hIUEngine)
				{
					LOG_Error(_T("m_hIUEngine should be NULL here!"));
				}
#endif

				PFN_CreateEngUpdateInstance pfnCreateEngUpdateInstance =
					(PFN_CreateEngUpdateInstance) GetProcAddress(m_hEngineModule, "CreateEngUpdateInstance");

				if (NULL != pfnCreateEngUpdateInstance)
				{
					m_hIUEngine = pfnCreateEngUpdateInstance();
				}

				if (NULL == m_hIUEngine)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					FreeLibrary(m_hEngineModule);
					m_hEngineModule = NULL;
				}
				else
				{
					//
					// If load engine and create instance succeeded, start aynsc misc worker threads
					//
					PFN_AsyncExtraWorkUponEngineLoad pfnAsyncExtraWorkUponEngineLoad = 
						(PFN_AsyncExtraWorkUponEngineLoad) GetProcAddress(m_hEngineModule, "AsyncExtraWorkUponEngineLoad");

					if (NULL != pfnAsyncExtraWorkUponEngineLoad)
					{
						pfnAsyncExtraWorkUponEngineLoad();
					}
				}
			}
				
		}

		if (IU_INIT_UPDATE_ASYNC == lInitFlag && SUCCEEDED(hr))
		{
			//
			// this is a rare case: the previous Iniitalize() call tells
			// that engine update needed, but now, when we try to update it
			// in async mode, we found it's no longer true.
			// Must be some other process already complete the engine update
			// task since then. But it may or may not completed the change
			// file name process yet.
			//
			// For us, we just need to signal that we are done to update.
			//

			//
			// signal callback
			//
			IUpdateCompleteListener* pCallback = NULL;
			if (NULL != punkUpdateCompleteListener && (SUCCEEDED(hr = punkUpdateCompleteListener->QueryInterface(IID_IUpdateCompleteListener, (void**) &pCallback))))
			{
				pCallback->OnComplete(dwErr);
				pCallback->Release();
				LOG_Out(_T("Returned from callback API OnComplete()"));
			}
			else
			{
				//
				// signal event if user has not passed in a progress listner IUnknown ptr
				//
				HWND hWnd = m_EvtWindow.GetEvtHWnd();

				if (NULL != hWnd)
				{
					PostMessage(hWnd, UM_EVENT_SELFUPDATE_COMPLETE, 0, (LPARAM)dwErr);
					LOG_Out(_T("Fired event OnComplete()"));
				}
			}


			hr = S_OK;	
		}
	}

CleanUp:

	PingEngineUpdate(
					m_hEngineModule,
					&g_hEngineLoadQuit,
					1,
					ptszLivePingServerUrl,
					ptszCorpPingServerUrl,
					hr,
					_T("IU_SITE"));		// Only the site (other than test) calls this function

	LeaveCriticalSection(&m_lock);

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);
	return hr;
}




HRESULT CUpdate::ChangeControlInitState(LONG lNewState)
{
	HRESULT hr = S_OK;
	LOG_Block("ChangeControlInitState()");

	if (!m_gfInit_csLock)
	{
		return E_OUTOFMEMORY;
	}

	EnterCriticalSection(&m_lock);
	m_lInitState = lNewState;
	if (2 == m_lInitState && NULL == m_hEngineModule)
	{
		//
		// load the engine
		//
		m_hEngineModule = LoadLibraryFromSystemDir(_T("iuenginenew.dll"));
		if (NULL != m_hEngineModule)
		{
			LOG_Internet(_T("IUCtl Using IUENGINENEW.DLL"));
		}
		else
		{
			LOG_Internet(_T("IUCtl Using IUENGINE.DLL"));
			m_hEngineModule = LoadLibraryFromSystemDir(_T("iuengine.dll"));

			if (NULL == m_hEngineModule)
			{
				DWORD dwErr = GetLastError();
				LOG_ErrorMsg(dwErr);
				hr = HRESULT_FROM_WIN32(dwErr);
			}
		}
		//
		// Create the CEngUpdate instance
		//
		if (NULL != m_hEngineModule)
		{
#if defined(DBG)
			// Log error if m_hIUEngine isn't NULL
			if (NULL != m_hIUEngine)
			{
				LOG_Error(_T("m_hIUEngine should be NULL here!"));
			}
#endif
			PFN_CreateEngUpdateInstance pfnCreateEngUpdateInstance =
				(PFN_CreateEngUpdateInstance) GetProcAddress(m_hEngineModule, "CreateEngUpdateInstance");

			if (NULL != pfnCreateEngUpdateInstance)
			{
				m_hIUEngine = pfnCreateEngUpdateInstance();
			}

			if (NULL == m_hIUEngine)
			{
				hr = E_OUTOFMEMORY;
				LOG_ErrorMsg(hr);
				FreeLibrary(m_hEngineModule);
				m_hEngineModule = NULL;
			}
		}
	}
	LeaveCriticalSection(&m_lock);

	return hr;
}





STDMETHODIMP CUpdate::PrepareSelfUpdate(LONG lStep)
{
	return E_NOTIMPL;
}





/////////////////////////////////////////////////////////////////////////////
//
// Helper API to let the caller (script) knows the necessary information 
// when Initialize() returns control need updated.
//
// For the current implementation, bstrClientName is ignored, and
// the returned bstr has format:
//	"<version>|<url>"
// where:
//	<version> is the expacted version number of the control
//	<url> is the base url to get the control if this is a CorpWU policy controlled machine,
//		  or empty if this is a consumer machine (in that case caller, i.e., script, knows
//		  the default base url, which is the v4 live site)
//
// Script will need these two pieces of information in order to make a right <OBJECT> tag
// for control update.
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CUpdate::GetControlExtraInfo(BSTR bstrClientName, BSTR *pbstrExtraInfo)
{
	return E_NOTIMPL;
}



/////////////////////////////////////////////////////////////////////////////
//
// new Win32 API called by wrapper control to retrieve update info
//
// 
/////////////////////////////////////////////////////////////////////////////
int GetControlUpdateInfo(LPTSTR lpszUpdateInfo, int cchBufferSize)
{
	LOG_Block("GetControlUpdateInfo()");
	
	HRESULT hr = S_OK;
	int nSize = 0;
	BOOL fCorpUser = FALSE, fBetaSelfUpdate = FALSE;
	FILE_VERSION fvCurrentCtl, fvCurrentEngine;

	TCHAR szDir[MAX_PATH];
	TCHAR szFile[MAX_PATH];
	TCHAR szExpectedEngVer[64];	// 64 should be more then enough
	TCHAR szExpectedCtlVer[64];	// if not enough, then it's bad data anyway

	HKEY hKey;

	DWORD dwErr = ERROR_SUCCESS;	// error code for this API

	if (1 == IsWindowsUpdateUserAccessDisabled())
	{
		dwErr = ERROR_SERVICE_DISABLED;
		LOG_ErrorMsg(ERROR_SERVICE_DISABLED);
		goto CleanUp;
	}
	if (0x0 == GetLogonGroupInfo())
	{
		dwErr = ERROR_ACCESS_DENIED;
		goto CleanUp;
	}


	if (FAILED(hr = DownloadIUIdent_PopulateData()))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}

	//
	// get current control ver
	//
	GetSystemDirectory(szDir, ARRAYSIZE(szDir));
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IUCTL);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
	if (!GetFileVersion(szFile, &fvCurrentCtl))
	{
		ZeroMemory(&fvCurrentCtl, sizeof(fvCurrentCtl));
	}


	//
	// get current engine ver
	//
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,ENGINENEWDLL);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
	if (!GetFileVersion(szFile, &fvCurrentEngine))
	{
		//
		// if no engine new there, check engine ver
		//
		hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,ENGINEDLL);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			dwErr = hr;
			goto CleanUp;
		}
		if (!GetFileVersion(szFile, &fvCurrentEngine))
		{
			ZeroMemory(&fvCurrentCtl, sizeof(fvCurrentEngine));
		}
	}

	//
	// check if this is beta code
	//
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL,0, KEY_READ, &hKey))
    {
		// Check for Beta IU SelfUpdate Handling Requested
		DWORD dwStatus = 0;
		DWORD dwSize = sizeof(dwStatus);
		DWORD dwRet = RegQueryValueEx(hKey, REGVAL_BETASELFUPDATE, NULL, NULL, (LPBYTE)&dwStatus, &dwSize);
		if (1 == dwStatus)
		{
			fBetaSelfUpdate = TRUE;
		}
		RegCloseKey(hKey);
    }


	//
	// get expected control ver
	//
    GetIndustryUpdateDirectory(szDir);
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IDENTTXT);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
    GetPrivateProfileString(_T("IUControl"), 
							_T("ControlVer"), 
							_T(""), 
							szExpectedCtlVer, 
							ARRAYSIZE(szExpectedCtlVer), 
							szFile);
    if ('\0' == szExpectedCtlVer[0])
    {
		//
        // no selfupdate available, no server version information. bad ident?
		//
        dwErr = ERROR_FILE_CORRUPT;
		goto CleanUp;
    }


	//
	// get expected engine ver
	//
    GetIndustryUpdateDirectory(szDir);
	hr = PathCchCombine(szFile, ARRAYSIZE(szFile), szDir,IDENTTXT);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		dwErr = hr;
		goto CleanUp;
	}
    GetPrivateProfileString(fBetaSelfUpdate ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
							IDENT_VERSION, 
							_T(""), 
							szExpectedEngVer, 
							ARRAYSIZE(szExpectedEngVer), 
							szFile);
    if ('\0' == szExpectedEngVer[0])
    {
		//
        // no selfupdate available, no server version information. bad ident?
		//
        dwErr = ERROR_FILE_CORRUPT;
		goto CleanUp;
    }


	hr = g_pIUUrlAgent->IsIdentFromPolicy();
	if (FAILED(hr))
	{
		dwErr = (DWORD)hr;
		goto CleanUp;
	}

	fCorpUser = (S_OK == hr) ? TRUE : FALSE;
	hr = S_OK;

	//
	// contscut data
	// the constructed buffer will be in format
	// <CurrentCtlVer>|<ExpCtlVer>|CurrentEngVer>|<ExpEngVer>|<baseUrl>
	//
	nSize = wnsprintf(lpszUpdateInfo, cchBufferSize, _T("%d.%d.%d.%d|%s|%d.%d.%d.%d|%s|%d"),
				fvCurrentCtl.Major, fvCurrentCtl.Minor, fvCurrentCtl.Build, fvCurrentCtl.Ext,
				szExpectedCtlVer,
				fvCurrentEngine.Major, fvCurrentEngine.Minor, fvCurrentEngine.Build, fvCurrentEngine.Ext,
				szExpectedEngVer,
				fCorpUser ? 1 : 0);

	if (nSize < 0)
	{
		nSize = 0;
		dwErr = ERROR_INSUFFICIENT_BUFFER;
		goto CleanUp;
	}
			
CleanUp:

	SetLastError(dwErr);

	return nSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\cdmp.h ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.h
//
//
//  Description:
//
//      CDM internal header
//
//=======================================================================

#ifndef _CDMP_H
#define _CDMP_H

#include <winspool.h>
#include <winsprlp.h>	// private header containing EPD_ALL_LOCAL_AND_CLUSTER define
#include <winnt.h>
#include <iuxml.h>

#if defined(__cplusplus)
extern "C" {
#endif

#define MAX_INDEX_TO_SEARCH 100 //range to find unique file names for hardware_XXX.xml

//
// Unicode text files require a magic header (first byte of file must be 0xFF and second 0xFE).
//
const BYTE UNICODEHDR[] = { 0xFF, 0xFE };


class CDeviceInstanceIdArray
{
public:
	CDeviceInstanceIdArray();
	~CDeviceInstanceIdArray();

	int Add(LPCWSTR pszDIID);
	LPWSTR operator[](int index);
	int Size() { return m_nCount; }
	void FreeAll();

private:
	LPWSTR* m_ppszDIID;
	int m_nCount;
	int m_nPointers;
};
//
// Used to control functionality of GetPackage() : NOTE that pBstrCatalog is always
// allocated and returned unless function fails.
//
typedef enum {	GET_PRINTER_INFS,	// writes generated printer INF's to path returned in lpDownloadPath
				DOWNLOAD_DRIVER,	// downloads driver to path returned in lpDownloadPath
				GET_CATALOG_XML		// returns catalog BSTR only - no download or INF created
} ENUM_GETPKG;

HRESULT GetPackage(	ENUM_GETPKG eFunction,
					PDOWNLOADINFO pDownloadInfo,
					LPTSTR lpDownloadPath,
					DWORD cchDownloadPath,
					BSTR* pbstrXmlCatalog);		// must be freed by caller if allocated

// called by DownloadUpdatedFiles()
HRESULT GetDownloadPath(BSTR bstrXmlItems, LPTSTR szPath);

HRESULT OpenUniqueProviderInfName(
						IN		LPCTSTR  szDirPath,
						IN		LPCTSTR  pszProvider,
						IN OUT	LPTSTR	 pszFilePath,
						IN      DWORD    cchFilePath,
                        IN      LPTSTR** ppszUniqueProviderNameArray,
                        IN OUT  PDWORD   pdwProviderArrayLength,
						OUT		HANDLE&  hFile);
HRESULT WriteInfHeader(LPCTSTR pszProvider, HANDLE& hFile);
HRESULT PruneAndBuildPrinterINFs(BSTR bstrXmlPrinterCatalog, LPTSTR lpDownloadPath, DRIVER_INFO_6* paDriverInfo6, DWORD dwDriverInfoCount);
HRESULT GetInstalledPrinterDriverInfo(const OSVERSIONINFO* pOsVersionInfo, DRIVER_INFO_6** ppaDriverInfo6, DWORD* pdwDriverInfoCount);

//
// Located in sysspec.cpp, but used in cdmp.cpp and sysspec.cpp
//
HRESULT AddPrunedDevRegProps(HDEVINFO hDevInfoSet,
									PSP_DEVINFO_DATA pDevInfoData,
									CXmlSystemSpec& xmlSpec,
									LPTSTR pszMatchingID,			// pszMatchingID and pszDriverVer should be NULL or
									LPTSTR pszDriverVer,			// point to valid strings
									DRIVER_INFO_6* paDriverInfo6,	// OK if this is NULL (no installed printer drivers)
									DWORD dwDriverInfoCount,
									BOOL fIsSysSpecCall);			// Called by GetSystemSpec and GetPackage, with slightly different behavior

HRESULT GetMultiSzDevRegProp(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, DWORD dwProperty, LPTSTR* ppMultiSZ);
HRESULT GetPropertyFromSetupDiReg(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPCTSTR szProperty, LPTSTR *ppszData);
HRESULT GetPropertyFromSetupDi(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, ULONG ulProperty, LPTSTR* ppszProperty);

HRESULT DoesHwidMatchPrinter(
					DRIVER_INFO_6* paDriverInfo6,			// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,				// count of structs in paDriverInfo6 array
					LPCTSTR pszMultiSZ,						// Hardware or Compatible MultiSZ to compare with installed drivers
					BOOL* pfHwidMatchesInstalledPrinter		// [OUT] set TRUE if we match an installed printer driver
);

HRESULT AddIDToXml(LPCTSTR pszMultiSZ, CXmlSystemSpec& xmlSpec, DWORD dwProperty,
						  DWORD& dwRank, HANDLE_NODE& hDevices, LPCTSTR pszMatchingID, LPCTSTR pszDriverVer);


HRESULT GetMatchingDeviceID(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, LPTSTR* ppszMatchingID, LPTSTR* ppszDriverVer);

//called by InternalLogDriverNotFound()
HRESULT OpenUniqueFileName(
					IN LPTSTR lpBuffer, 
					IN DWORD  cchBuffer,
					OUT HANDLE &hFile
);


#if defined(__cplusplus)
}	// end extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\cdmp.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmp.cpp
//
//  Description:
//
//      CDM auxiliary functions
//
//			called by DownloadUpdatedFiles()
//				GetDownloadPath
//			
//			called by InternalLogDriverNotFound()
//				OpenUniqueFileName
//
//=======================================================================

#include <iuengine.h>
#include <shlwapi.h>
#include <ras.h>
#include <tchar.h>
#include <winver.h>

#include <download.h>
#include <wininet.h>
#include <fileutil.h>
#include "iuxml.h"
#include <wuiutest.h>
#include <StringUtil.h>

#include <cdm.h>
#include "cdmp.h"
#include "schemamisc.h"
#include <safefile.h>

const DWORD MAX_INF_STRING = 512;	// From DDK docs "General Syntax Rules for INF Files" section

const OLECHAR szXmlClientInfo[] = L"<clientInfo xmlns=\"x-schema:http://schemas.windowsupdate.com/iu/clientInfo.xml\" clientName=\"CDM\" />";

const OLECHAR szXmlPrinterCatalogQuery[] = L"<query><dObjQueryV1 procedure=\"printercatalog\"></dObjQueryV1></query>";
const OLECHAR szXmlDriverDownloadQuery[] = L"<query><dObjQueryV1 procedure=\"driverupdates\"></dObjQueryV1></query>";

/////////////////////////////////////////////////////////////////////////////
// CXmlDownloadResult
class CXmlDownloadResult : public CIUXml
{
public:
	CXmlDownloadResult();

	~CXmlDownloadResult();

	HRESULT LoadXMLDocumentItemStatusList(BSTR bstrXml);
	//
	// Expose m_pItemNodeList so it can be used directly
	//
	IXMLDOMNodeList*	m_pItemStatusNodeList;

private:
	IXMLDOMDocument*	m_pDocResultItems;
};

/////////////////////////////////////////////////////////////////////////////
// CXmlDownloadResult
/////////////////////////////////////////////////////////////////////////////

CXmlDownloadResult::CXmlDownloadResult()
 : m_pDocResultItems(NULL), m_pItemStatusNodeList(NULL)
{
}


CXmlDownloadResult::~CXmlDownloadResult()
{
	SafeReleaseNULL(m_pDocResultItems);
	SafeReleaseNULL(m_pItemStatusNodeList);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentItemStatusList()
//
// Load an XML Document from string and create the list of items
//
// Calls to Download produce return status in the following (example) XML format:
//
// <?xml version="1.0"?>
// <items xmlns="x-schema:http://schemas.windowsupdate.com/iu/resultschema.xml">
// 	<itemStatus xmlns="">
// 		<identity name="nvidia.569">nvidia.569
// 		<publisherName>nvidia</publisherName>
// 		</identity>
// 		<downloadStatus value="COMPLETE" errorCode="100"/>
// 	</itemStatus>
// </items>
// 
// We expose m_pItemNodeList so it can be used directly to retrieve the value
// attribute of the <downloadStatus /> item.
//
// NOTE: for CDM there will only be one item downloaded at a time, so the list
// will only contain a single <itemStatus/> element.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlDownloadResult::LoadXMLDocumentItemStatusList(BSTR bstrXml)
{
	LOG_Block("CXmlDownloadResult::LoadXMLDocumentItemStatusList");

	HRESULT hr = S_OK;
	BSTR bstrAllDocumentItems = NULL;

	if (NULL == bstrXml || m_pDocResultItems || m_pItemStatusNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	CleanUpIfFailedAndSetHr(LoadXMLDoc(bstrXml, &m_pDocResultItems));
	//
	// Get a list of all <itemStatus/> elements anywhere in the document
	//
	if (NULL == (bstrAllDocumentItems = SysAllocString(L"//itemStatus")))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	if (NULL == (m_pItemStatusNodeList = FindDOMNodeList(m_pDocResultItems, bstrAllDocumentItems)))
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}

CleanUp:

	SysFreeString(bstrAllDocumentItems);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CXmlPrinterCatalogList
class CXmlPrinterCatalogList : public CIUXml
{
public:
	CXmlPrinterCatalogList();

	~CXmlPrinterCatalogList();

	HRESULT LoadXMLDocumentAndGetCompHWList(BSTR bstrXml);
	//
	// Expose m_pCompHWNodeList so it can be used directly
	//
	IXMLDOMNodeList*	m_pCompHWNodeList;

private:
	IXMLDOMDocument*	m_pDocCatalogItems;
};

/////////////////////////////////////////////////////////////////////////////
// CXmlPrinterCatalogList
/////////////////////////////////////////////////////////////////////////////

CXmlPrinterCatalogList::CXmlPrinterCatalogList()
 : m_pDocCatalogItems(NULL), m_pCompHWNodeList(NULL)
{
}


CXmlPrinterCatalogList::~CXmlPrinterCatalogList()
{
	SafeReleaseNULL(m_pDocCatalogItems);
	SafeReleaseNULL(m_pCompHWNodeList);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentAndGetCompHWList()
//
// Load an XML Document from string and create the list of
//    <compatibleHardware/> elements.
//
// "printercatalog" SOAP queries sent via GetManifest return a list of
// all printers for the given platform in the following format (validates against
// http://schemas.windowsupdate.com/iu/catalogschema.xml) having the following
// characteristics:
//
//   * <catalog clientType="CONSUMER">
//   * Only a single <provider> with <identity name="printerCatalog">printerCatalog</identity>
//   * returned <platform/> is not used by CDM
//   * <item/> identity and <platform> are likewise ignored by CDM
//   * Under item/detection/compatibleHardware/device the driverName, driverProvider, mfgName,
//     and driverVer attributes, as well as hwid string are extracted and used to build
//     printer INF files.
//   * Algorithms in this class take advantage of the fact that driverProvider attributes
//     are serialized (e.g. grouped in order by driverProvider), however this is not a requirement.
//   * Note that <item/> elements can contain more than one <compatibleHardware/> element,
//     but the complete list of <compatibleHardware/> elements provides all printers in
//     the given catalog
//
// Sample start of a "printerCatalog" catalog:
// ------------------------------------------
//	  <?xml version="1.0" ?> 
//	- <catalog clientType="CONSUMER">
//		- <provider>
//		  <identity name="printerCatalog">printerCatalog</identity> 
//		  <platform>ver_platform_win32_nt.5.0.x86.en</platform> 
//		+ <item installable="1">
//			  <identity name="hp.3">hp.3</identity> 
//			- <detection>
//				- <compatibleHardware>
//					- <device isPrinter="1">
//						  <printerInfo driverName="HP PSC 500" driverProvider="Hewlett-Packard Co." mfgName="HP" /> 
//						  <hwid rank="0" driverVer="1999-12-14">DOT4PRT\HEWLETT-PACKARDPSC_59784</hwid> 
//					  </device>
//				  </compatibleHardware>
//				- <compatibleHardware>
//				... etc.
//			  </detection>
//		  </item>
//		+ <item installable="1">
//		... etc.
//
//
// Likewise, driver information for requested PnP drivers is returned in catalog
// items.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlPrinterCatalogList::LoadXMLDocumentAndGetCompHWList(BSTR bstrXml)
{
	LOG_Block("CXmlPrinterCatalogList::LoadXMLDocumentAndGetCompHWList");

	HRESULT hr = S_OK;
	BSTR bstrAllDocumentItems = NULL;

	if (NULL == bstrXml || m_pDocCatalogItems || m_pCompHWNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	CleanUpIfFailedAndSetHr(LoadXMLDoc(bstrXml, &m_pDocCatalogItems));
	//
	// Get a list of all <item/> elements anywhere in the document
	//
	if (NULL == (bstrAllDocumentItems = SysAllocString(L"//compatibleHardware")))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	if (NULL == (m_pCompHWNodeList = FindDOMNodeList(m_pDocCatalogItems, bstrAllDocumentItems)))
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}

CleanUp:
	SysFreeString(bstrAllDocumentItems);

	return hr;
}


///////////////////////////////////////////////////////////////////
//
// Locally defined LPTSTR array - dynamically expands
//
///////////////////////////////////////////////////////////////////

#define NUM_DIIDPTR_ALLOC 10

CDeviceInstanceIdArray::CDeviceInstanceIdArray()
: m_ppszDIID(NULL), m_nCount(0), m_nPointers(0)
{
}

CDeviceInstanceIdArray::~CDeviceInstanceIdArray()
{
	LOG_Block("CDeviceInstanceIdArray::~CDeviceInstanceIdArray");

	FreeAll();
	//
	// Free the array of LPTSTRs
	//
	SafeHeapFree(m_ppszDIID);
	m_nPointers = 0;
}

void CDeviceInstanceIdArray::FreeAll()
{
	LOG_Block("CDeviceInstanceIdArray::Free");

	if (NULL != m_ppszDIID && 0 < m_nCount)
	{
		//
		// Free the strings
		//
		for (int i = 0; i < m_nCount; i++)
		{
			SafeHeapFree(*(m_ppszDIID+i));
		}
		m_nCount = 0;
	}
}

int CDeviceInstanceIdArray::Add(LPCWSTR pszDIID)
{
	HRESULT hr;
	LPWSTR  pszIDtoAdd = NULL;
	DWORD   cch;

	LOG_Block("CDeviceInstanceIdArray::Add");

	if (NULL == pszDIID)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return -1;
	}

	//
	// Allocate or realloc space for NUM_DIIDPTR_ALLOC LPSTRs
	//
	if (NULL == m_ppszDIID)
	{
		m_ppszDIID = (LPWSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(LPWSTR) * NUM_DIIDPTR_ALLOC);

		if(NULL == m_ppszDIID)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return -1;
		}
		m_nPointers = NUM_DIIDPTR_ALLOC;
	}
	else if (m_nCount == m_nPointers)
	{
		//
		// We've used all our allocated pointers, realloc more
		//
		LPWSTR* ppTempDIID;
		//
		// Increase number of pointers currently allocated by NUM_DIIDPTR_ALLOC
		//
		ppTempDIID =  (LPWSTR*) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_ppszDIID,
			(sizeof(LPWSTR) * (m_nPointers + NUM_DIIDPTR_ALLOC))  );

		if(NULL == ppTempDIID)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return -1;
		}

		m_ppszDIID = ppTempDIID;
		m_nPointers += NUM_DIIDPTR_ALLOC;
	}

	//
	// Alloc memory for to hold the DIID and copy it
	//
	cch = (lstrlenW(pszDIID) + 1);
	if (NULL == (pszIDtoAdd = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, cch * sizeof(WCHAR))))
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		goto CleanUp;
	}

	hr = StringCchCopyExW(pszIDtoAdd, cch, pszDIID, NULL, NULL, MISTSAFE_STRING_FLAGS);
	if (FAILED(hr))
	{
	    HeapFree(GetProcessHeap(), 0, pszIDtoAdd);
	    pszIDtoAdd = NULL;
	    goto CleanUp;
	}

	*(m_ppszDIID+m_nCount) = pszIDtoAdd;
	m_nCount++;

CleanUp:

	if (NULL == pszIDtoAdd)
	{
		return -1;
	}
	else
	{
#if defined(_UNICODE) || defined(UNICODE)
		LOG_Driver(_T("%s added to list"), pszIDtoAdd);
#else
		LOG_Driver(_T("%S added to list"), pszIDtoAdd);
#endif
		return m_nCount - 1;
	}
}


LPWSTR CDeviceInstanceIdArray::operator[](int index)
{
	LOG_Block("CDeviceInstanceIdArray::operator[]");

	if (0 > index || m_nCount < index + 1)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return NULL;
	}

	return *(m_ppszDIID+index);
}

///////////////////////////////////////////////////////////////////

// Gets a path to the directory that cdm.dll has copied the install cabs to
// and returns the length of the path.
// Note: The input buffer must be at least MAX_PATH size.

HRESULT GetDownloadPath(
	IN		BSTR bstrXmlCatalog,	// Catalog we passed to Download (only contains one item)
	IN		BSTR bstrXmlDownloadedItems,
	IN OUT	LPTSTR lpDownloadPath,	// Local directory where extracted files were placed.
	IN OUT  DWORD  cchDownloadPath
)
{
	USES_IU_CONVERSION;

	LOG_Block("GetDownloadPath");
	
	HRESULT hr = S_OK;

	BSTR bstrDownloadPath = NULL;
	BSTR bstrItem = NULL;

	CXmlItems* pxmlDownloadedItems = NULL;
	CXmlCatalog catalog;
	HANDLE_NODE hCatalogItem;
	HANDLE_NODE hProvider;
	HANDLE_NODELIST hItemList;
	HANDLE_NODELIST hProviderList;

	if (NULL == bstrXmlCatalog || NULL == lpDownloadPath || NULL == bstrXmlDownloadedItems || 0 == cchDownloadPath)
	{
		CleanUpIfFailedAndSetHr(E_INVALIDARG);
	}

	lpDownloadPath[0] = _T('\0');

	//
	// Load the XML and get the <item/> list and node of first item (only one in CDM case)
	//
	CleanUpIfFailedAndSetHr(catalog.LoadXMLDocument(bstrXmlCatalog, g_pCDMEngUpdate->m_fOfflineMode));

	hProviderList = catalog.GetFirstProvider(&hProvider);
	if (HANDLE_NODELIST_INVALID == hProviderList || HANDLE_NODE_INVALID == hProvider)
	{
		CleanUpIfFailedAndSetHr(E_INVALIDARG);
	}
	
	hItemList = catalog.GetFirstItem(hProvider, &hCatalogItem);
	if (HANDLE_NODELIST_INVALID == hItemList || HANDLE_NODE_INVALID == hProvider)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	//
	// Construct CXmlItems for read
	//
	CleanUpFailedAllocSetHrMsg(pxmlDownloadedItems = new CXmlItems(TRUE));

	CleanUpIfFailedAndMsg(pxmlDownloadedItems->LoadXMLDocument(bstrXmlDownloadedItems));
	
    hr = pxmlDownloadedItems->GetItemDownloadPath(&catalog, hCatalogItem, &bstrDownloadPath);
    if (NULL == bstrDownloadPath)
    {
        LOG_Driver(_T("Failed to get Item Download Path from ReturnSchema"));
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        goto CleanUp;
    }

    hr = StringCchCopyEx(lpDownloadPath, cchDownloadPath, OLE2T(bstrDownloadPath),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;

CleanUp:

	if (pxmlDownloadedItems)
	{
		delete pxmlDownloadedItems;
	}
	
	SysFreeString(bstrDownloadPath);
	SysFreeString(bstrItem);

	return hr;
}

// called by InternalDriverNotFound(...)
// Find a file name not used so far into which hardware xml information will be inserted
// The file name will be in format hardware_xxx.xml where xxx is in range [1..MAX_INDEX_TO_SEARCH]
// The position file found last time is remembered and new search will start from the next position
// Caller is supposed to close handle and delete file
//  pszFilePath	IN OUT : allocated and freed by caller. Buffer to store unique file name found: MUST be MAX_PATH
//  hFile		OUT    : store a handle to the opened file
//return S_OK if Unique File Name found 
//return E_INVALIDARG if buffer pointer is NULL (must be called with MAX_PATH length buffer)
//return E_FAIL if all qualified file names already taken
HRESULT OpenUniqueFileName(
						IN OUT	LPTSTR pszFilePath, 
						IN      DWORD  cchFilePath,
						OUT		HANDLE &hFile
)
{
	LOG_Block("OpenUniqueFileName");

	static DWORD dwFileIndex = 1;
	int nCount = 0;
	const TCHAR FILENAME[] = _T("Hardware_");
	const TCHAR FILEEXT[] = _T("xml");
	TCHAR szDirPath[MAX_PATH + 1];
	HRESULT hr;

	if (NULL == pszFilePath || 0 == cchFilePath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	pszFilePath[0] = _T('\0');

	GetIndustryUpdateDirectory(szDirPath);
	LOG_Out(_T("Directory to search unique file names: %s"), szDirPath);

	hFile = INVALID_HANDLE_VALUE;
	do 
	{
	    hr = StringCchPrintfEx(pszFilePath, cchFilePath, NULL, NULL, MISTSAFE_STRING_FLAGS,
	                           _T("%s%s%d.%s"), szDirPath, FILENAME, dwFileIndex, FILEEXT);
	    if (FAILED(hr))
	    {
	        LOG_ErrorMsg(hr);
	        return hr;
	    }
	    
		hFile = CreateFile(pszFilePath, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
		if (INVALID_HANDLE_VALUE == hFile) 
		{
			//
			// Could test for ERROR_FILE_EXISTS == dwErr (expected) and bail on other errors indicating
			// a more serious problem, however this return isn't doc'ed in the JAN 2001 SDK, and the
			// documented ERROR_ALREADY_EXISTS applies instead to CREATE_ALWAYS or OPEN_ALWAYS.
			//
			LOG_Out(_T("%s already exists"), pszFilePath);
			dwFileIndex ++;
			nCount ++;
			if (dwFileIndex > MAX_INDEX_TO_SEARCH)
			{
				dwFileIndex = 1;
			}
		}
		else 
		{
			break; //first available file name found
		}
	}while(nCount < MAX_INDEX_TO_SEARCH );
	
	if (nCount == MAX_INDEX_TO_SEARCH ) 
	{
		LOG_Out(_T("All %d file names have been taken"), nCount);
		LOG_ErrorMsg(E_FAIL);
		return E_FAIL;
	}

	LOG_Out(_T("Unique file name %s opened for GENERIC_WRITE using CreateFile"), pszFilePath);
	dwFileIndex++; //next time skip file name found this time
	if (dwFileIndex > MAX_INDEX_TO_SEARCH)
	{
		//
		// Start again at the beginning - maybe one of earlier files has been deleted by HelpCenter...
		//
		dwFileIndex = 1;
	}
	return S_OK;
}

HRESULT WriteInfHeader(LPCTSTR pszProvider, HANDLE& hFile)
{
	LOG_Block("WriteInfHeader");

	const TCHAR HEADER_START[] =
			_T("[Version]\r\n")
			_T("Signature=\"$Windows NT$\"\r\n")
			_T("Provider=%PRTPROV%\r\n")
			_T("ClassGUID={4D36E979-E325-11CE-BFC1-08002BE10318}\r\n")
			_T("Class=Printer\r\nCatalogFile=webntprn.cat\r\n")
			_T("\r\n")
			_T("[ClassInstall32.NT]\r\n")
			_T("AddReg=printer_class_addreg\r\n")
			_T("\r\n")
			_T("[printer_class_addreg]\r\n")
			_T("HKR,,,,%%PrinterClassName%%\r\n")
			_T("HKR,,Icon,,\"-4\"\r\n")
			_T("HKR,,Installer32,,\"ntprint.dll,ClassInstall32\"\r\n")
			_T("HKR,,NoDisplayClass,,1\r\n")
			_T("HKR,,EnumPropPages32,,\"printui.dll,PrinterPropPageProvider\"\r\n")
			_T("\r\n")
			_T("[Strings]\r\n")
			_T("PRTPROV=\"");

	const TCHAR HEADER_END[] = 
			_T("\"\r\n")
			_T("PrinterClassName=\"Printer\"\r\n")
			_T("\r\n");

	HRESULT hr = S_OK;
	DWORD dwWritten;

	if (NULL == pszProvider || hFile == INVALID_HANDLE_VALUE)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

#if defined(_UNICODE) || defined(UNICODE)
	//
	// Write Unicode Header
	//
	if (0 == WriteFile(hFile, (LPCVOID) &UNICODEHDR, sizeof(UNICODEHDR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
#endif
	//
	// Write the first part of INF header
	//
	if (0 == WriteFile(hFile, HEADER_START, sizeof(HEADER_START) - sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
	//
	// Write the provider string
	//
	if (0 == WriteFile(hFile, (LPCVOID) pszProvider, lstrlen(pszProvider) * sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}
	//
	// Write the remainder of the INF header
	//
	if (0 == WriteFile(hFile, HEADER_END, sizeof(HEADER_END) - sizeof(TCHAR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}

CleanUp:

	if (FAILED(hr) && INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	return hr;
}

//
// pszFilePath must be >= MAX_PATH characters
//
HRESULT OpenUniqueProviderInfName(
						IN		LPCTSTR  szDirPath,
						IN		LPCTSTR  pszProvider,
						IN OUT	LPTSTR	 pszFilePath,
						IN      DWORD    cchFilePath,
                        IN      LPTSTR** ppszUniqueProviderNameArray,
                        IN OUT  PDWORD   pdwProviderArrayLength,
						OUT		HANDLE&  hFile
)
{
	LOG_Block("OpenUniqueProviderInfName");

	const TCHAR FILEROOT[] = _T("PList_");
	const TCHAR FILEEXT[] = _T("inf");
	DWORD dwErr;
	HRESULT hr = E_INVALIDARG;

	hFile = INVALID_HANDLE_VALUE;

	if (NULL == pszFilePath || NULL == pszProvider || NULL == szDirPath || 0 == cchFilePath || 
        NULL == ppszUniqueProviderNameArray || NULL == *ppszUniqueProviderNameArray || NULL == pdwProviderArrayLength)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	pszFilePath[0] = _T('\0');

    // The Unique Provider Inf Names are based on the Index of the ProviderMapArray that the Provider name matches
    // The Array is Pre-Allocated to 20 Providers (more than we should need)
    BOOL fIndexFound = FALSE;
    DWORD dwIndex;
    DWORD dwLength;
    for (dwIndex = 0; dwIndex < *pdwProviderArrayLength; dwIndex++)
    {
        // First check if we've reached a NULL entry in the Array, this indicates we haven't found a match yet
        // and we need to add our Provider to this location
        if ((*ppszUniqueProviderNameArray)[dwIndex] == NULL)
        {
            dwLength = lstrlen(pszProvider) + 1;
            (*ppszUniqueProviderNameArray)[dwIndex] = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
            if (NULL == (*ppszUniqueProviderNameArray)[dwIndex])
            {
                dwErr = GetLastError();
                LOG_ErrorMsg(dwErr);
                return HRESULT_FROM_WIN32(dwErr);
            }
            hr = StringCchCopyEx((*ppszUniqueProviderNameArray)[dwIndex], dwLength, pszProvider, NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                SafeHeapFree((*ppszUniqueProviderNameArray)[dwIndex]);
                return hr;
            }
            fIndexFound = TRUE;
            break;
        }

        // Now Compare the Current Provider Entry to see if they Match (case-sensitive compare)
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 0, 
            (*ppszUniqueProviderNameArray)[dwIndex], -1, pszProvider, -1))
        {
            fIndexFound = TRUE;
            break;
        }
    }

    if (!fIndexFound)
    {
        // This indicates we finished looping the array and didn't not find a match AND did not have a empty Entry to 
        // place this provider in. So we now need to ReAlloc the Array. Our goal is of course to never have to do this,
        // but we support it anyway.
        DWORD dwNewProviderArrayLength = *pdwProviderArrayLength * 2; // double
        LPTSTR* ppszTemp = (LPTSTR *) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *ppszUniqueProviderNameArray, dwNewProviderArrayLength * sizeof(LPTSTR));
        if (NULL == ppszTemp)
        {
            dwErr = GetLastError();
            LOG_ErrorMsg(dwErr);
            return HRESULT_FROM_WIN32(dwErr);
        }
        *pdwProviderArrayLength = dwNewProviderArrayLength;
        *ppszUniqueProviderNameArray = ppszTemp; // Since this was 'realloced', the previous memory block should be cleared up.

        // Now increment the current Index counter and place the new Provider in that location.
        dwIndex++;
        dwLength = lstrlen(pszProvider) + 1;
        (*ppszUniqueProviderNameArray)[dwIndex] = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
        if (NULL == (*ppszUniqueProviderNameArray)[dwIndex])
        {
            dwErr = GetLastError();
            LOG_ErrorMsg(dwErr);
            return HRESULT_FROM_WIN32(dwErr);
        }
        hr = StringCchCopyEx((*ppszUniqueProviderNameArray)[dwIndex], dwLength, pszProvider, NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            SafeHeapFree((*ppszUniqueProviderNameArray)[dwIndex]);
            return hr;
        }
    }

    // We now have a Provider Index Value (dwIndex) that matches our Provider

    hr = StringCchPrintfEx(pszFilePath, cchFilePath, NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%s%s%d.%s"), szDirPath, FILEROOT, dwIndex, FILEEXT);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
		pszFilePath[0] = _T('\0');
        return hr;
    }

	//
	// Try to open an existing INF of this name. If this fails try to create then init the file.
	//
	hFile = CreateFile(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL,
						OPEN_EXISTING, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
	if (INVALID_HANDLE_VALUE == hFile) 
	{
		hFile = CreateFile(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL,
							CREATE_NEW, FILE_ATTRIBUTE_NOT_CONTENT_INDEXED, NULL);
		if (INVALID_HANDLE_VALUE == hFile) 
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			pszFilePath[0] = _T('\0');
			return HRESULT_FROM_WIN32(dwErr);
		}
		//
		// Write the INF "Header" information to the new file
		//
		if (FAILED( hr = WriteInfHeader(pszProvider, hFile)))
		{
			pszFilePath[0] = _T('\0');
			return hr;
		}
	}

	return S_OK;
}

HRESULT OfferThisPrinterDriver(
					DRIVER_INFO_6* paDriverInfo6,	// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,		// count of structs in paDriverInfo6 array
					IXMLDOMNode* pCompHWNode,		// <compatibleHardware> node from catalog
					BOOL* pfOfferDriver,			// [OUT] If TRUE offer this driver - remainder of outputs are valid
					VARIANT& vDriverName,			// [OUT]
					VARIANT& vDriverVer,			// [OUT]
					VARIANT& vDriverProvider,		// [OUT]
					VARIANT& vMfgName,				// [OUT]
					BSTR* pbstrHwidText)			// [OUT]
{
	USES_IU_CONVERSION;

	LOG_Block("OfferThisPrinterDriver");

	HRESULT hr = S_OK;
	IXMLDOMNode* pDriverNameNode = NULL;
	IXMLDOMNode* pDriverProviderNode = NULL;
	IXMLDOMNode* pMfgNameNode = NULL;
	IXMLDOMNode* pPInfoNode = NULL;
	IXMLDOMNode* pHwidNode = NULL;
	IXMLDOMNode* pDriverVerNode = NULL;
	IXMLDOMNamedNodeMap* pAttribMap = NULL;
	LPCTSTR pszCompareHwid = NULL;
#if !(defined(_UNICODE) || defined(UNICODE))
	//
	// We need to special-case ANSI since we can't use pointers into pbstrHwidText, which is wide
	//
	TCHAR szHwid[MAX_INF_STRING + 1];
#endif

	if (
		NULL == pCompHWNode	||
		NULL == pfOfferDriver ||
		NULL == pbstrHwidText)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	VariantInit(&vDriverName);
	VariantInit(&vDriverVer);
	VariantInit(&vDriverProvider);
	VariantInit(&vMfgName);
	*pfOfferDriver = TRUE;
	*pbstrHwidText = NULL;

	//
	// Get the first <printerInfo/> node of the item (we expect at least one else fail)
	//
	CleanUpIfFailedAndSetHrMsg(pCompHWNode->selectSingleNode(KEY_CDM_PINFO, &pPInfoNode));
	//
	// 517297 Ignore non-printer HWIDs in OfferThisPrinterDriver
	//
	// We may get device nodes that are not marked isPrinter="1" and do not have the <printerInfo/>
	// element. We don't offer these device nodes, but it is not an error.
	//
	if (NULL == pPInfoNode)
	{
		//
		// Change S_FALSE back to S_OK, but don't offer this device
		//
		hr = S_OK;
		*pfOfferDriver = FALSE;
		goto CleanUp;
	}

	CleanUpIfFailedAndSetHrMsg(pPInfoNode->get_attributes(&pAttribMap));
	if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// suck out the printerInfo attributes
	//
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERNAME, &pDriverNameNode));
	if (NULL == pDriverNameNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERPROVIDER, &pDriverProviderNode));
	if (NULL == pDriverProviderNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_MFGNAME, &pMfgNameNode));
	if (NULL == pMfgNameNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// pAttribMap will be reused later, free it here
	//
	SafeReleaseNULL(pAttribMap);
	
	CleanUpIfFailedAndSetHrMsg(pDriverNameNode->get_nodeValue(&vDriverName));
	CleanUpIfFailedAndSetHrMsg(pDriverProviderNode->get_nodeValue(&vDriverProvider));
	CleanUpIfFailedAndSetHrMsg(pMfgNameNode->get_nodeValue(&vMfgName));
	if (VT_BSTR != vDriverName.vt || VT_BSTR != vDriverProvider.vt || VT_BSTR != vMfgName.vt)
	{
		CleanUpIfFailedAndSetHrMsg(E_FAIL);
	}
	//
	// Get the first <hwid/> node of the item (we expect at least one else fail)
	//
	CleanUpIfFailedAndSetHrMsg(pCompHWNode->selectSingleNode(KEY_CDM_HWIDPATH, &pHwidNode));
	if (NULL == pHwidNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

	CleanUpIfFailedAndSetHrMsg(pHwidNode->get_attributes(&pAttribMap));
	if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
	//
	// suck out the DriverVer attribute
	//
	CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(KEY_DRIVERVER, &pDriverVerNode));
	if (NULL == pDriverVerNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

	CleanUpIfFailedAndSetHrMsg(pDriverVerNode->get_nodeValue(&vDriverVer));
	if (VT_BSTR != vDriverVer.vt)
	{
		CleanUpIfFailedAndSetHrMsg(E_FAIL);
	}
	//
	// Get the <hwid/> text
	//
	// NOTE: Each item is restricted to a single <hwid/> element due to INF syntax,
	// however our catalog schema doesn't make similar restrictions and currently our
	// backend doesn't distinguish between <hwid/> and <compid/> values, so it is
	// possible we could get more than one <hwid/> returned. For the purpose of
	// generating INFs for Add Printer Wizard, any <hwid/> from the CAB will do.
	//
	CleanUpIfFailedAndSetHrMsg(pHwidNode->get_text(pbstrHwidText));

#if !(defined(_UNICODE) || defined(UNICODE))
    hr = StringCchCopyEx(szHwid, ARRAYSIZE(szHwid), OLE2T(*pbstrHwidText), 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
	LOG_Driver(_T("Got \"%s\" from XML for compare to DRIVER_INFO_6."), szHwid);
#else
	LOG_Driver(_T("Got \"%s\" from XML for compare to DRIVER_INFO_6."), *pbstrHwidText);
#endif

	if (NULL == paDriverInfo6 || 0 == dwDriverInfoCount)
	{
		LOG_Driver(_T("WARNING: We're missing information (maybe no installed printer drivers), so we won't prune"));
		goto CleanUp;
	}

#if !(defined(_UNICODE) || defined(UNICODE))
		pszCompareHwid = szHwid;
#else
		pszCompareHwid = (LPCTSTR) *pbstrHwidText;
#endif

	for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
	{
		if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
		{
			continue;
		}

		//
		// Use case-insensitive compares (paDriverInfo6 is different case from pszCompareHwid)
		//
		if (0 != lstrcmpi(pszCompareHwid, (paDriverInfo6 + dwCount)->pszHardwareID))
		{
			continue;
		}
		//
		// Else we have a hardware match - check the other attributes for exact match
		//
		if (0 != lstrcmpi(OLE2T(vDriverName.bstrVal), (paDriverInfo6 + dwCount)->pName) ||
			0 != lstrcmpi(OLE2T(vDriverProvider.bstrVal), (paDriverInfo6 + dwCount)->pszProvider) ||
			0 != lstrcmpi(OLE2T(vMfgName.bstrVal), (paDriverInfo6 + dwCount)->pszMfgName))
		{
			//
			LOG_Driver(_T("Prune this driver: it doesn't match all the attributes of the installed driver"));
			*pfOfferDriver = FALSE;
			goto CleanUp;
		}
		//
		// The driver matches, but make sure it has a newer DriverVer than the installed driver
		//
		LOG_Driver(_T("Driver item in catalog is compatible with installed driver"));

		SYSTEMTIME systemTime;
		if (0 == FileTimeToSystemTime((CONST FILETIME*) &((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
		//
		// Convert to ISO ISO 8601 prefered format (yyyy-mm-dd) so we can string compare with catalog BSTR
		//
		WCHAR wszDriverVer[11];

    	hr = StringCchPrintfExW(wszDriverVer, ARRAYSIZE(wszDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                L"%04d-%02d-%02d", systemTime.wYear, systemTime.wMonth, systemTime.wDay);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
			goto CleanUp;
        }

		if (0 < lstrcmpW(vDriverVer.bstrVal, wszDriverVer))
		{
			LOG_Driver(_T("WU DriverVer (%s) is > installed (%s)"), vDriverVer.bstrVal, wszDriverVer);
			*pfOfferDriver = TRUE;
			goto CleanUp;
		}
		else
		{
			LOG_Driver(_T("Prune this driver: WU DriverVer (%s) is <= installed (%s)"), vDriverVer.bstrVal, wszDriverVer);
			*pfOfferDriver = FALSE;
#if defined(__WUIUTEST)
			// DriverVer Override for ==
			HKEY hKey;
			int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
			if (ERROR_SUCCESS == error)
			{
				DWORD dwSize = sizeof(DWORD);
				DWORD dwValue;
				error = RegQueryValueEx(hKey, REGVAL_ALLOW_EQUAL_DRIVERVER, 0, 0, (LPBYTE) &dwValue, &dwSize);
				if (ERROR_SUCCESS == error && 1 == dwValue)
				{
					//
					// If DriverVers are equal (we already installed a driver from WU, allow it anyway
					//
					if (0 == lstrcmpW(vDriverVer.bstrVal, wszDriverVer))
					{
						*pfOfferDriver = TRUE;
						LOG_Driver(_T("WU DriverVer (%s) is = installed (%s), WUIUTEST override and offer"), vDriverVer.bstrVal, wszDriverVer);
					}
				}

				RegCloseKey(hKey);
			}
#endif
			goto CleanUp;
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		if (NULL != pfOfferDriver)
		{
			*pfOfferDriver = FALSE;
		}

		if (NULL != pbstrHwidText)
		{
			SafeSysFreeString(*pbstrHwidText);
		}
		VariantClear(&vDriverName);
		VariantClear(&vDriverVer);
		VariantClear(&vDriverProvider);
		VariantClear(&vMfgName);
	}

	SafeReleaseNULL(pDriverNameNode);
	SafeReleaseNULL(pDriverProviderNode);
	SafeReleaseNULL(pMfgNameNode);
	SafeReleaseNULL(pPInfoNode);
	SafeReleaseNULL(pHwidNode);
	SafeReleaseNULL(pDriverVerNode);
	SafeReleaseNULL(pAttribMap);

	return hr;
}

HRESULT GetInstalledPrinterDriverInfo(const OSVERSIONINFO* pOsVersionInfo, DRIVER_INFO_6** ppaDriverInfo6, DWORD* pdwDriverInfoCount)
{
	LOG_Block("GetInstalledPrinterDriverInfo");

	HRESULT hr = S_OK;
	DWORD dwBytesNeeded;

	if (NULL == pOsVersionInfo || NULL == ppaDriverInfo6 || NULL == pdwDriverInfoCount)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pdwDriverInfoCount = 0;
	*ppaDriverInfo6 = NULL;

	LPTSTR pszEnvironment;

	if (VER_PLATFORM_WIN32_WINDOWS == pOsVersionInfo->dwPlatformId)
	{
		//
		// Don't pass an environment string for Win9x
		//
		pszEnvironment = NULL;
	}
	else if (5 <= pOsVersionInfo->dwMajorVersion && 1 <= pOsVersionInfo->dwMinorVersion)
	{
		//
		// Use EPD_ALL_LOCAL_AND_CLUSTER only on Whistler and up
		//
		pszEnvironment = EPD_ALL_LOCAL_AND_CLUSTER;
	}
	else
	{
		//
		// From V3 sources (hard-coded for NT)
		//
		pszEnvironment = _T("all");
	}

	if(!EnumPrinterDrivers(NULL, pszEnvironment, 6, NULL, 0, &dwBytesNeeded, pdwDriverInfoCount))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError() || (0 == dwBytesNeeded))
		{
			LOG_Driver(_T("No printer drivers enumerated"));
		}
		else
		{
			//
			// Allocate the requested buffer
			//
			CleanUpFailedAllocSetHrMsg(*ppaDriverInfo6 = (DRIVER_INFO_6*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesNeeded));

			//
			// Fill in DRIVER_INFO_6 array
			//
			if (!EnumPrinterDrivers(NULL, pszEnvironment, 6, (LPBYTE) *ppaDriverInfo6, dwBytesNeeded, &dwBytesNeeded, pdwDriverInfoCount))
			{
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			LOG_Driver(_T("%d printer drivers found"), *pdwDriverInfoCount);
			//
			// Validate the driver elements for each printer driver. 
			//
			for (DWORD dwCount = 0; dwCount < *pdwDriverInfoCount; dwCount++)
			{
				if (   NULL == (*ppaDriverInfo6 + dwCount)->pszHardwareID
					|| NULL == (*ppaDriverInfo6 + dwCount)->pszProvider
					|| NULL == (*ppaDriverInfo6 + dwCount)->pszMfgName
					|| NULL == (*ppaDriverInfo6 + dwCount)->pName  )
				{
					LOG_Driver(_T("Skiping driver with incomplete ID info: set pszHardwareID = NULL"));
					//
					// We use pszHardwareID == NULL to invalidate incomplete entry
					//
					(*ppaDriverInfo6 + dwCount)->pszHardwareID = NULL;
					continue;
				}
			}
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppaDriverInfo6);
		*ppaDriverInfo6 = NULL;
		*pdwDriverInfoCount = 0;
	}

	return hr;
}

//
// Build and write to disk Printer INFs constructed from printer items available
// on this platform. Also prunes printer drivers that would conflict with installed
// drivers (e.g. Unidriver vs. Monolithic, etc.).
//
HRESULT PruneAndBuildPrinterINFs(BSTR bstrXmlPrinterCatalog, LPTSTR lpDownloadPath, DWORD cchDownloadPath, DRIVER_INFO_6* paDriverInfo6, DWORD dwDriverInfoCount)
{
	USES_IU_CONVERSION;

	LOG_Block("PruneAndBuildPrinterINFs");

	HRESULT hr;
	HANDLE hFile = INVALID_HANDLE_VALUE;
	const TCHAR SZ_PLISTDIR[] = _T("CDMPlist\\");
	DWORD dwWritten;
	LONG lLength;

	VARIANT vDriverName;
	VARIANT vDriverVer;
	VARIANT vDriverProvider;
	VARIANT vMfgName;

	VariantInit(&vDriverName);
	VariantInit(&vDriverVer);
	VariantInit(&vDriverProvider);
	VariantInit(&vMfgName);

	BOOL fOfferDriver = FALSE;

	BSTR bstrHwidText = NULL;

	IXMLDOMNode* pCompHWNode = NULL;

	LPTSTR pszInfDirPath = NULL;
	LPTSTR pszInfFilePath = NULL;
	LPOLESTR pwszDriverProvider = NULL;
	LPTSTR pszMfgName = NULL;
	LPTSTR pszDriverName = NULL;
	LPTSTR pszInstallSection = NULL;
    LPTSTR* ppszUniqueProviderNameArray = NULL;

	CXmlPrinterCatalogList xmlItemList;

	if (NULL == bstrXmlPrinterCatalog || NULL == lpDownloadPath || 0 == cchDownloadPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

    // Allocate the ppszUniqueProviderNameArray initially to a value of 60 pointers 
    DWORD dwProviderArrayLength = 60;
    ppszUniqueProviderNameArray = (LPTSTR *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwProviderArrayLength * sizeof(LPTSTR));
    if (NULL == ppszUniqueProviderNameArray)
    {
        SetHrMsgAndGotoCleanUp(E_OUTOFMEMORY);
    }

	lpDownloadPath[0] = _T('\0');
	//
	// Dynamically allocate buffers (PreFast warning 831: This function uses 5884 bytes of stack,
	// consider moving some data to heap.)
	//
	pszInfDirPath		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof(TCHAR));
	pszInfFilePath		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof(TCHAR));
	pwszDriverProvider	= (LPOLESTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(OLECHAR));
	pszMfgName			= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));
	pszDriverName		= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));
	pszInstallSection	= (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_INF_STRING * sizeof(TCHAR));

	if (NULL == pszInfDirPath ||
		NULL == pszInfFilePath ||
		NULL == pwszDriverProvider ||
		NULL == pszMfgName ||
		NULL == pszDriverName ||
		NULL == pszInstallSection	)
	{
		SetHrMsgAndGotoCleanUp(E_OUTOFMEMORY);
	}

	//
	// Create the directory for the INFs after deleting any existing directory
	//
	GetIndustryUpdateDirectory((LPTSTR) pszInfDirPath);
	if ((MAX_PATH) < (lstrlen(pszInfDirPath) + ARRAYSIZE(SZ_PLISTDIR) + 1))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

    // pszInfDirPath was alloced to be MAX_PATH above
    hr = PathCchAppend(pszInfDirPath, MAX_PATH, SZ_PLISTDIR);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

	//
	// Delete any existing INFs and recreate the directory - we'll get fresh content
	//
	LOG_Driver(_T("SafeDeleteFolderAndContents: %s"), pszInfDirPath);
	(void) SafeDeleteFolderAndContents(pszInfDirPath, SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR);

	hr = CreateDirectoryAndSetACLs(pszInfDirPath, TRUE);
	CleanUpIfFailedAndMsg(hr);

	//
	// Load the XML and get the <compatibleHardware/> list and number of items
	//
	// NOTE: each <compatibleHardware/> element contains a single unique driver.
	// In the event we get duplicates with different driverVer's we really don't care
	// as the last one will overright the previous instances and Add Printer Wizard
	// doesn't look at driverVer (we prune if it's too old).
	//
	CleanUpIfFailedAndSetHr(xmlItemList.LoadXMLDocumentAndGetCompHWList(bstrXmlPrinterCatalog));
	CleanUpIfFailedAndSetHrMsg(xmlItemList.m_pCompHWNodeList->get_length(&lLength));

	for (LONG l = 0; l < lLength; l++)
	{
		//
		// Get the next <item/> node from list
		//
		CleanUpIfFailedAndSetHrMsg(xmlItemList.m_pCompHWNodeList->nextNode(&pCompHWNode));
		if (NULL == pCompHWNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);
		//
		// Check the driver against installed printer drivers for compatibility and prune if
		//  incompatible or DriverVer <= installed DriverVer.
		//
		CleanUpIfFailedAndSetHr(OfferThisPrinterDriver(paDriverInfo6, dwDriverInfoCount, pCompHWNode, &fOfferDriver, \
									vDriverName, vDriverVer, vDriverProvider, vMfgName, &bstrHwidText));

		SafeReleaseNULL(pCompHWNode);

		if (!fOfferDriver)								
		{
			LOG_Driver(_T("Pruning hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s"),\
				OLE2T(bstrHwidText), OLE2T(vDriverVer.bstrVal),  \
				OLE2T(vDriverName.bstrVal), OLE2T(vDriverProvider.bstrVal), OLE2T(vMfgName.bstrVal) );

            VariantClear(&vDriverName);
            VariantClear(&vDriverVer);
            VariantClear(&vDriverProvider);
            VariantClear(&vMfgName);
            SafeSysFreeString(bstrHwidText);
            continue;
		}

		LOG_Driver(_T("Adding hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s to INF"),\
			OLE2T(bstrHwidText), OLE2T(vDriverVer.bstrVal),  \
			OLE2T(vDriverName.bstrVal), OLE2T(vDriverProvider.bstrVal), OLE2T(vMfgName.bstrVal) );

		if (0 != lstrcmpiW(pwszDriverProvider, vDriverProvider.bstrVal))
		{

            // pwszDriverProvider was alloced to be MAX_INF_STRING * sizeof(OLECHAR) above.
            hr = StringCchCopyExW(pwszDriverProvider, MAX_INF_STRING, vDriverProvider.bstrVal,
                                  NULL, NULL, MISTSAFE_STRING_FLAGS);
            CleanUpIfFailedAndSetHr(hr);
			//
			// Open pszInfFilePath and initialize with "header" an INF file based on pwszDriverProvider.
			// If it already exists, just open it (and return existing pszInfFilePath) 
			//
            // pszInfFilePath is allocated to be MAX_PATH above.
			CleanUpIfFailedAndSetHr(OpenUniqueProviderInfName(pszInfDirPath, OLE2T(pwszDriverProvider), pszInfFilePath, MAX_PATH, &ppszUniqueProviderNameArray, &dwProviderArrayLength, hFile));
			//
			// Once the file is initialized, we don't need to keep it open
			//
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
		}
		//
		// Write the mfgName in the [Manufacturer] section, for example
		// [Manufacturer]
		// "Ricoh"="Ricoh"
		//
		// ISSUE-2001/02/05-waltw Could optimize by caching last known name like provider above...

		
		// pszMfgName is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszMfgName, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("\"%s\""), (LPCTSTR) OLE2T(vMfgName.bstrVal));
        CleanUpIfFailedAndSetHr(hr);

		if (0 == WritePrivateProfileString(_T("Manufacturer"), pszMfgName, pszMfgName, pszInfFilePath))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		// pszDriverName is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszDriverName, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("\"%s\""), OLE2T(vDriverName.bstrVal));
        CleanUpIfFailedAndSetHr(hr);
        
		// pszInstallSection is alloced to be MAX_INF_STRING characters above
    	hr = StringCchPrintfEx(pszInstallSection, MAX_INF_STRING, NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("InstallSection,\"%s\""), OLE2T(bstrHwidText));
        CleanUpIfFailedAndSetHr(hr);
		//
		// Write printer item in [mfgName] section, for example:
		// [RICOH]
		// "RICOH Aficio 850 PCL 6"=InstallSection,"LPTENUM\RICOHAFICIO_850F1B7"
		if (0 == WritePrivateProfileString(OLE2T(vMfgName.bstrVal), pszDriverName, pszInstallSection, pszInfFilePath))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

        VariantClear(&vDriverName);
        VariantClear(&vDriverVer);
        VariantClear(&vDriverProvider);
        VariantClear(&vMfgName);
        SafeSysFreeString(bstrHwidText);
	}

CleanUp:

	if(SUCCEEDED(hr))
	{
        hr = StringCchCopyEx(lpDownloadPath, cchDownloadPath, pszInfDirPath,
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
			lpDownloadPath[0] = _T('\0');
            LOG_ErrorMsg(hr);
        }
	}

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

    // Clear up the ppszUniqueProviderNameArray
    if (NULL != ppszUniqueProviderNameArray)
    {
        for (DWORD dwIndex = 0; dwIndex < dwProviderArrayLength; dwIndex++)
        {
            if (NULL == ppszUniqueProviderNameArray[dwIndex])
            {
                break; // done
            }
            SafeHeapFree(ppszUniqueProviderNameArray[dwIndex]);
        }
        SafeHeapFree(ppszUniqueProviderNameArray);
    }

	VariantClear(&vDriverName);
	VariantClear(&vDriverVer);
	VariantClear(&vDriverProvider);
	VariantClear(&vMfgName);

	SafeHeapFree(pszInfDirPath);
	SafeHeapFree(pszInfFilePath);
	SafeHeapFree(pwszDriverProvider);
	SafeHeapFree(pszMfgName);
	SafeHeapFree(pszDriverName);
	SafeHeapFree(pszInstallSection);
	SafeSysFreeString(bstrHwidText);

	SafeReleaseNULL(pCompHWNode);

	return hr;
}

BOOL HwidMatchesDeviceInfo(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA deviceInfoData, LPCTSTR pszHardwareID)
{
	LOG_Block("HwidMatchesDeviceInfo");

	HRESULT hr = S_OK;
	LPTSTR pszMultiHwid = NULL;
	LPTSTR pszMultiCompid = NULL;
	LPTSTR pszTemp;

	//
	// Get the Hardware and Compatible Multi-SZ strings so we can prune printer devices before commiting to XML.
	//
	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, &deviceInfoData, SPDRP_HARDWAREID, &pszMultiHwid));

	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, &deviceInfoData, SPDRP_COMPATIBLEIDS, &pszMultiCompid));
	//
	// Do we have a match with an enumerated device HWID or Compatible ID?
	//
	if (NULL != pszMultiHwid)
	{
		for(pszTemp = pszMultiHwid; *pszTemp; pszTemp += (lstrlen(pszTemp) + 1))
		{
			if (0 == lstrcmpi(pszTemp, pszHardwareID))
			{
				LOG_Driver(_T("This deviceInfoData matches HWID %s"), pszHardwareID);
				goto CleanUp;
			}
		}
	}

	if (NULL != pszMultiCompid)
	{
		for(pszTemp = pszMultiCompid; *pszTemp; pszTemp += (lstrlen(pszTemp) + 1))
		{
			if (0 == lstrcmpi(pszTemp, pszHardwareID))
			{
				LOG_Driver(_T("This deviceInfoData matches HWID %s"), pszHardwareID);
				goto CleanUp;
			}
		}
	}
	//
	// We didn't find a match
	//
	LOG_Driver(_T("Failed to find a matching HWID or Printer ID for %s"), pszHardwareID);
	hr = E_FAIL;

CleanUp:

	SafeHeapFree(pszMultiHwid);
	SafeHeapFree(pszMultiCompid);

	return (SUCCEEDED(hr));
}


// This function is called to download the actual package.
//
// If this function is successfull then it returns S_OK. If the case of a
// failure this function returns an error code.

HRESULT GetPackage(
	IN	ENUM_GETPKG eFunction,			// Function to be performed by GetPackage
	IN	PDOWNLOADINFO pDownloadInfo,	// DownloadInformation structure describing package to be read from server
	OUT LPTSTR lpDownloadPath,			// Pointer to local directory on the client computer system
										// where the downloaded files are to be stored. NOTE: OK to pass NULL if
										// GET_CATALOG_XML == eFunction.
    IN  DWORD cchDownloadPath,
	OUT BSTR* pbstrXmlCatalog			// On SUCCESS, catalog is always allocated - caller must call SysFreeString()
)
{
	USES_IU_CONVERSION;

	LOG_Block("GetPackage");

	HRESULT hr;

	BSTR bstrXmlSystemSpec = NULL;
	BSTR bstrXmlClientInfo = NULL;
	BSTR bstrXmlQuery = NULL;
	BSTR bstrXmlDownloadedItems = NULL;
	BSTR bstrDownloadStatus = NULL;
	BSTR bstrStatusValue = NULL;
	BSTR bstrProvider = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrName = NULL;
	BSTR bstrHardwareID = NULL;
	BSTR bstrDriverVer = NULL;

	IU_PLATFORM_INFO iuPlatformInfo;
	HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
	SP_DEVINFO_DATA devInfoData;
	DRIVER_INFO_6* paDriverInfo6 = NULL;
	DWORD dwDriverInfoCount = 0;
	LPCTSTR pszHardwareID = NULL;	// pDownloadInfo LPCWSTR converted to ANSI (automatically freed by IU_CONVERSION)
									// OR just points to LPCWSTR pDownloadInfo->lpHardwareIDs or ->lpDeviceInstanceID 
	DWORD dwDeviceIndex;
	BOOL fHwidMatchesInstalledPrinter = FALSE;
	BOOL fAPWNewPrinter = FALSE;
	HANDLE_NODE hPrinterDevNode = HANDLE_NODE_INVALID;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;
	DWORD dwCount;

	CXmlSystemSpec xmlSpec;
	CXmlDownloadResult xmlItemStatusList;
	IXMLDOMNode* pItemStatus = NULL;
	IXMLDOMNode* pStatusNode = NULL;
	IXMLDOMNode* pValueNode = NULL;
	IXMLDOMNamedNodeMap* pAttribMap = NULL;
	VARIANT vStatusValue;

	LPTSTR	pszMatchingID = NULL;
	LPTSTR	pszDriverVer= NULL;

	//
	// Initialize variant before any possible jump to CleanUp (BUG: 467098)
	//
	VariantInit(&vStatusValue);

	if (NULL == pDownloadInfo ||
		(NULL == lpDownloadPath && GET_CATALOG_XML != eFunction) ||
		NULL == pbstrXmlCatalog ||
		NULL == g_pCDMEngUpdate)
	{
		hr = E_INVALIDARG;
		return E_INVALIDARG;
	}

	if (NULL != lpDownloadPath && cchDownloadPath > 0)
	{
		lpDownloadPath[0] = _T('\0');
	}
	*pbstrXmlCatalog = NULL;

	//
	// Get iuPlatformInfo, but remember to clean up BSTRs on function exit
	//
	CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));

	//
	// Get array of DRIVER_INFO_6 holding info on installed printer drivers. Only allocates and returns
	// memory for appropriate platforms that have printer drivers already installed.
	//
	CleanUpIfFailedAndSetHr(GetInstalledPrinterDriverInfo((OSVERSIONINFO*) &iuPlatformInfo.osVersionInfoEx, &paDriverInfo6, &dwDriverInfoCount));

	//
	// Build common bstrXmlClientInfo and parts of bstrXmlSystemSpec
	//
	if (NULL == (bstrXmlClientInfo = SysAllocString((OLECHAR*) &szXmlClientInfo)))
	{
		CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
	}

	//
	// Add Computer System
	//
	CleanUpIfFailedAndSetHr(AddComputerSystemClass(xmlSpec));

	//
	// Add Platform
	//
	CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));
	//
	// Add OS & USER Locale information
	//
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, TRUE));

	//
	// If GET_PRINTER_INFS, we are retrieving a list of supported printers (V3 PLIST format) rather than a driver
	//
	switch (eFunction)
	{
	case GET_PRINTER_INFS:
		{
			CleanUpFailedAllocSetHrMsg(bstrXmlQuery = SysAllocString(szXmlPrinterCatalogQuery));

			CleanUpIfFailedAndSetHr(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec));

			//
			// GetManifest will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}

			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, FLAG_USE_COMPRESSION, pbstrXmlCatalog));

			LOG_XmlBSTR(*pbstrXmlCatalog);

			//
			// Now, convert the returned pbstrXmlCatalog to an inf file per provider and write to a temporary location
			//
			CleanUpIfFailedAndSetHr(PruneAndBuildPrinterINFs(*pbstrXmlCatalog, lpDownloadPath, cchDownloadPath, paDriverInfo6, dwDriverInfoCount));
			break;
		}

	case DOWNLOAD_DRIVER:
	case GET_CATALOG_XML:
		{
			//
			// Put either the Hardware & Compatible ID from the DeviceInstanceID or printer info from DRIVER_INFO_6
			// or <hwid> passed by APW into a systemspec to pass to server with driver query.
			//
			if (NULL != pDownloadInfo->lpDeviceInstanceID)
			{
				if (INVALID_HANDLE_VALUE == (hDevInfoSet = (HDEVINFO)SetupDiCreateDeviceInfoList(NULL, NULL)))
				{
					Win32MsgSetHrGotoCleanup(GetLastError());
				}
				//
				// This is the Device Instance ID for an installed hardware device
				//
				ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
				devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

#if !(defined(_UNICODE) || defined(UNICODE))
				// OK to cast away const-ness since OLE2T copies string for ANSI
				pszHardwareID = OLE2T(const_cast<LPWSTR>(pDownloadInfo->lpDeviceInstanceID));
				CleanUpFailedAllocSetHrMsg(pszHardwareID);
#else
				pszHardwareID = pDownloadInfo->lpDeviceInstanceID;
#endif
				if (!SetupDiOpenDeviceInfo(hDevInfoSet, pszHardwareID, 0, 0, &devInfoData))
				{
					Win32MsgSetHrGotoCleanup(GetLastError());
				}
			}
			else if (NULL != pDownloadInfo->lpHardwareIDs)
			{
				// one hardware id for a package - either printers or w9x if we cannot find device instance ID
				// if architecture is not the same as current archtecture we need to prefix it
				SYSTEM_INFO sysInfo;
				GetSystemInfo(&sysInfo);
				
				if (pDownloadInfo->dwArchitecture != (DWORD) sysInfo.wProcessorArchitecture)
				{
					// Supporting PRINT_ENVIRONMENT_INTEL and PRINT_ENVIRONMENT_ALPHA prefixes
					// was V3 legacy functionality that was never used (originally intended to
					// support installation of non-native architecture drivers on print servers).
					// Since this feature isn't required or expected by the print team for
					// Windows Update functionality, we simply retain the compare as a sanity
					// check in case one of our clients forgets this.
					SetHrMsgAndGotoCleanUp(E_NOTIMPL);
				}

#if !(defined(_UNICODE) || defined(UNICODE))
				// OK to cast away const-ness since OLE2T copies string for ANSI
				pszHardwareID = OLE2T(const_cast<LPWSTR>(pDownloadInfo->lpHardwareIDs));
				CleanUpFailedAllocSetHrMsg(pszHardwareID);
#else
				pszHardwareID = pDownloadInfo->lpHardwareIDs;
#endif

				//
				// First see if we can match an installed printer driver HWID to the pszHardwareID
				//
				for (dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
				{
					if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
					{
						LOG_Driver(_T("Skipping NULL printer driver index %d"), dwCount);
						continue;
					}

					//
					// Use case-insensitive compares (paDriverInfo6 is different case from pszHardwareID)
					//
					if (0 != lstrcmpi(pszHardwareID, (paDriverInfo6 + dwCount)->pszHardwareID))
					{
						continue;
					}

					LOG_Driver(_T("Found match with an installed printer driver dwCount = %d"), dwCount);
					fHwidMatchesInstalledPrinter = TRUE;
					break;
				}

				if (!fHwidMatchesInstalledPrinter)
				{
					LOG_Driver(_T("Didn't find an installed printer driver with a matching HWID, enumerating the PnP IDs..."));
					//
					// We couldn't find a matching installed printer, so now
					// enumerate all the PnP IDs and try to find a matching node to
					// add to the system spec
					//
					if (INVALID_HANDLE_VALUE == (hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES)))
					{
						Win32MsgSetHrGotoCleanup(GetLastError());
					}
		
					ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
					devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
					BOOL fRet;
					dwDeviceIndex = 0;
					while (fRet = SetupDiEnumDeviceInfo(hDevInfoSet, dwDeviceIndex++, &devInfoData))
					{
						//
						// Find a matching ID (could spit out Device Instance ID using SetupDiGetDeviceInstanceId for debug)
						//
						if (HwidMatchesDeviceInfo(hDevInfoSet, devInfoData, pszHardwareID))
						{
							break;
						}
					}

					if (!fRet)
					{
						//
						// We hit the end of the list without finding a match
						//
						if (ERROR_NO_MORE_ITEMS == GetLastError())
						{
							LOG_Driver(_T("Couldn't find a matching device instance enumerating the PnP devices - must be APW request for new printer"));
							fAPWNewPrinter = TRUE;
						}
						else
						{
							Win32MsgSetHrGotoCleanup(GetLastError());
						}
					}
				}
			}
			else
			{
				SetHrMsgAndGotoCleanUp(E_INVALIDARG);
			}
			//
			// We either found a matching printer driver or PnP device instance - add it to the system spec.
			// if DriverVer > installed DriverVer - for printer we have additional requirements
			//
			//
			if (fHwidMatchesInstalledPrinter)
			{
				//
				// Open a <device> element to write the printer info
				//
				bstrProvider = T2BSTR((paDriverInfo6 + dwCount)->pszProvider);
				bstrMfgName = T2BSTR((paDriverInfo6 + dwCount)->pszMfgName);
				bstrName = T2BSTR((paDriverInfo6 + dwCount)->pName);

				CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, \
					bstrMfgName, bstrName, &hPrinterDevNode));

				SafeSysFreeString(bstrProvider);
				SafeSysFreeString(bstrMfgName);
				SafeSysFreeString(bstrName);
				//
				// Convert ftDriverDate to ISO 8601 prefered format (yyyy-mm-dd)
				//
				SYSTEMTIME systemTime;
				if (0 == FileTimeToSystemTime((CONST FILETIME*) &((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
				{
					LOG_Error(_T("FileTimeToSystemTime failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				TCHAR szDriverVer[11];

            	hr = StringCchPrintfEx(szDriverVer, ARRAYSIZE(szDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                       _T("%04d-%02d-%02d"), systemTime.wYear, systemTime.wMonth, systemTime.wDay);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
				
				// Always rank 0 and never fIsCompatible
				bstrHardwareID = T2BSTR((paDriverInfo6 + dwCount)->pszHardwareID);
				bstrDriverVer = T2BSTR(szDriverVer);

				CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, \
							bstrHardwareID, bstrDriverVer));

				SafeSysFreeString(bstrHardwareID);
				SafeSysFreeString(bstrDriverVer);

				xmlSpec.SafeCloseHandleNode(hPrinterDevNode);

#if defined(DBG)
				//
				// Need to copy strings to non-const for OLE2T conversion (ANSI)
				//
				TCHAR szbufHardwareID[MAX_PATH];
				TCHAR szbufDriverName[MAX_PATH];
				TCHAR szbufDriverProvider[MAX_PATH];
				TCHAR szbufMfgName[MAX_PATH];

                hr = StringCchCopyEx(szbufHardwareID, ARRAYSIZE(szbufHardwareID),
                                     (paDriverInfo6 + dwCount)->pszHardwareID,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufDriverName, ARRAYSIZE(szbufDriverName),
                                     (paDriverInfo6 + dwCount)->pName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufDriverProvider, ARRAYSIZE(szbufDriverProvider),
                                     (paDriverInfo6 + dwCount)->pszProvider,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                hr = StringCchCopyEx(szbufMfgName, ARRAYSIZE(szbufMfgName),
                                     (paDriverInfo6 + dwCount)->pszMfgName,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
				
				LOG_Driver(_T("Offering Printer hwid = %s, driverVer = %s, driverName = %s, driverProvider = %s, driverMfgr = %s"),\
					(LPTSTR) szbufHardwareID, (LPTSTR) szDriverVer,  \
					(LPTSTR) szbufDriverName, (LPCWSTR) szbufDriverProvider, \
					(LPTSTR) szbufMfgName );
#endif
			}
			else if (fAPWNewPrinter)
			{
				if (NULL == pDownloadInfo->lpFile)
				{
					//
					// We need to "fake" a <hwid/> element with the ID passed in. User is trying to install
					// a printer driver picked in the Add Printer Wizard that doesn't already exist on the
					// system.
					//
					DWORD dwRank;
					dwRank = 0;
					CleanUpIfFailedAndSetHr(AddIDToXml(pszHardwareID, xmlSpec, SPDRP_HARDWAREID, dwRank, hDevices, NULL, NULL));
					if (HANDLE_NODE_INVALID != hDevices)
					{
						xmlSpec.SafeCloseHandleNode(hDevices);
					}
				}
				else
				{
					//
					// 516376 Changes required in CDM to fix the APW <-> CDM  bug found for multi-Provider scenario
					//
					// APW will pass a MULTI-SZ string containing (in this order) the following strings in the
					// previously unused lpFile member of DOWNLOADINFO if it wishes to specify provider.
					//
					// This string is not required (for convenience and backwards compatibility) but
					// if the lpFile member passed to CDM is non-NULL, it must contain all three strings
					// as follows:
					//   String 1: driver provider
					//   String 2: manufacturer name
					//   String 3: driver name
#if !(defined(_UNICODE) || defined(UNICODE))
					//
					// We will never support this functionality on Win9x
					//
					CleanUpIfFailedAndSetHr(E_NOTIMPL);
#else					
					LPCWSTR pszProvider = pDownloadInfo->lpFile;
					int nLenProvider = lstrlen(pszProvider);
					if (NULL == pszProvider + nLenProvider + 1)
					{
						CleanUpIfFailedAndSetHr(E_INVALIDARG);
					}
					LPCWSTR pszMfgName = pszProvider + nLenProvider + 1;
					int nLenMfgName = lstrlen(pszMfgName);
					if (NULL == pszMfgName + nLenMfgName + 1)
					{
						CleanUpIfFailedAndSetHr(E_INVALIDARG);
					}
					LPCWSTR pszDriverName = pszMfgName + nLenMfgName + 1;

					//
					// Open a <device> element to write the printer info
					//
					bstrProvider = SysAllocString(pszProvider);
					bstrMfgName = SysAllocString(pszMfgName);
					bstrName = SysAllocString(pszDriverName);

					if (NULL == bstrProvider || NULL == bstrMfgName || NULL == bstrName)
					{
						CleanUpIfFailedAndSetHr(E_OUTOFMEMORY);
					}

					CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, \
						bstrMfgName, bstrName, &hPrinterDevNode));

					SafeSysFreeString(bstrProvider);
					SafeSysFreeString(bstrMfgName);
					SafeSysFreeString(bstrName);

					// Always rank 0 and never fIsCompatible and no driverVer
					CleanUpFailedAllocSetHrMsg(bstrHardwareID = SysAllocString(pszHardwareID));

					CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, \
								bstrHardwareID));

					SafeSysFreeString(bstrHardwareID);

					xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
#endif
				}
			}
			else
			{
				//
				// Get DriverVer for the PnP ID and check that offered driver is greater using the 
				// hDevInfoSet and devInfoData matched above while enumerating
				//
				CleanUpIfFailedAndSetHr(GetMatchingDeviceID(hDevInfoSet, &devInfoData, &pszMatchingID, &pszDriverVer));
				//
				// Add <device/> we matched and want to download to XML
				//
				CleanUpIfFailedAndSetHr(AddPrunedDevRegProps(hDevInfoSet, &devInfoData, xmlSpec, \
													pszMatchingID, pszDriverVer, paDriverInfo6, dwDriverInfoCount, FALSE));
			}

			//
			// Get the query string
			//
			CleanUpFailedAllocSetHrMsg(bstrXmlQuery = SysAllocString(szXmlDriverDownloadQuery));
			//
			// Get the bstrXmlSystemSpec
			//
			CleanUpIfFailedAndSetHr(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec));

			LOG_XmlBSTR(bstrXmlSystemSpec);

			//
			// GetManifest will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}
			//
			// Call GetManifest to see if the server has anything that matches our system spec
			//
			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, \
												FLAG_USE_COMPRESSION, pbstrXmlCatalog));

			LOG_XmlBSTR( *pbstrXmlCatalog);

			//
			// If we are just getting the catalog we're done
			//
			if (GET_CATALOG_XML == eFunction)
			{
				break;
			}

			//
			// Download will ResetEvent, so check before calling
			//
			if (WaitForSingleObject(g_pCDMEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
			{
				CleanUpIfFailedAndSetHrMsg(E_ABORT);
			}
			//
			// Call Download passing it the catalog we got from GetManifest
			//
			CleanUpIfFailedAndSetHrMsg(g_pCDMEngUpdate->Download(bstrXmlClientInfo, *pbstrXmlCatalog, NULL, 0, NULL, NULL, &bstrXmlDownloadedItems));

			LOG_XmlBSTR(bstrXmlDownloadedItems);

			//
			// Verify that the package was downloaded
			//
			CleanUpIfFailedAndSetHr(xmlItemStatusList.LoadXMLDocumentItemStatusList(bstrXmlDownloadedItems));
			//
			// Get the first [only] item in the list
			//
			CleanUpIfFailedAndSetHr(xmlItemStatusList.m_pItemStatusNodeList->nextNode(&pItemStatus));
			if (NULL == pItemStatus) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			//
			// Get the first <downloadStatus/> node of the statusItem (we expect at least one else fail)
			//
			if (NULL == (bstrDownloadStatus = SysAllocString(L"downloadStatus")))
			{
				CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
			}

			CleanUpIfFailedAndSetHrMsg(pItemStatus->selectSingleNode(bstrDownloadStatus, &pStatusNode));
			if (NULL == pStatusNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			CleanUpIfFailedAndSetHr(pStatusNode->get_attributes(&pAttribMap));
			if (NULL == pAttribMap) CleanUpIfFailedAndSetHrMsg(E_FAIL);
			//
			// suck out the <downloadStatus/> value attributes
			//
			if (NULL == (bstrStatusValue = SysAllocString((OLECHAR*) L"value")))
			{
				CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
			}
			CleanUpIfFailedAndSetHrMsg(pAttribMap->getNamedItem(bstrStatusValue, &pValueNode));
			if (NULL == pValueNode) CleanUpIfFailedAndSetHrMsg(E_FAIL);

			CleanUpIfFailedAndSetHrMsg(pValueNode->get_nodeValue(&vStatusValue));
			if (VT_BSTR != vStatusValue.vt)
			{
				CleanUpIfFailedAndSetHrMsg(E_FAIL);
			}

			if (0 != lstrcmpW((LPWSTR) vStatusValue.bstrVal, L"COMPLETE"))
			{
				CleanUpIfFailedAndSetHrMsg(E_FAIL);
			}
			//
			// Now copy the path to the buffer we were passed
			//
			CleanUpIfFailedAndSetHr(GetDownloadPath(*pbstrXmlCatalog, bstrXmlDownloadedItems, lpDownloadPath, cchDownloadPath));
			//
			// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
			//
			hr = DecompressFolderCabs(lpDownloadPath);
			if (S_OK != hr)
			{
				CleanUpIfFailedAndSetHr(E_FAIL);
			}

			break;
		}

	default:
		{
			CleanUpIfFailedAndSetHr(E_INVALIDARG);
			break;
		}
	}	// switch (eFunction)
	

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevInfoSet)
	{
		SetupDiDestroyDeviceInfoList(hDevInfoSet);
	}

	if (HANDLE_NODE_INVALID != hPrinterDevNode)
	{
		xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
	}

	if (HANDLE_NODE_INVALID != hDevices)
	{
		xmlSpec.SafeCloseHandleNode(hDevices);
	}

	SafeReleaseNULL(pItemStatus);
	SafeReleaseNULL(pStatusNode);
	SafeReleaseNULL(pValueNode);
	SafeReleaseNULL(pAttribMap);

	SafeHeapFree(paDriverInfo6);
	SafeHeapFree(pszMatchingID);
	SafeHeapFree(pszDriverVer);

	VariantClear(&vStatusValue);

	SysFreeString(bstrXmlSystemSpec);
	SysFreeString(bstrXmlClientInfo);
	SysFreeString(bstrXmlQuery);
	SysFreeString(bstrXmlDownloadedItems);
	SysFreeString(bstrDownloadStatus);
	SysFreeString(bstrStatusValue);
	SysFreeString(bstrProvider);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrName);
	SysFreeString(bstrHardwareID);
	SysFreeString(bstrDriverVer);
	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrXmlCatalog);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\browse.h ===
//=======================================================================
//
//  Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.
//
//  File:   Browse.h
//
//  Owner:  EdDude
//
//  Description:
//
//      Implements the CBrowseFolder class.
//
//      Browse for a Folder for downloads.
//
// ======================================================================
//
// History:
//
// Date		Who			What
// ----		---			---------------------------------------
// 01/18/01	charlma		copy to IU control project, and modify
//
//=======================================================================

#ifndef _BROWSE_H_
#define _BROWSE_H_


//----------------------------------------------------------------------
// CBrowseFolder
//
//      Browse for a Folder for downloads.
//----------------------------------------------------------------------  
class CBrowseFolder
{

public:
	CBrowseFolder(LONG lFlag);
    ~CBrowseFolder();

	HRESULT BrowseFolder(HWND hwParent, LPCTSTR lpszDefaultPath, 
	                     LPTSTR szPathSelected, DWORD cchPathSelected);


private:

	CBrowseFolder() {};	// disable default constructor

    static bool s_bBrowsing;
	static int CALLBACK _BrowseCallbackProc( HWND hwDlg, UINT uMsg, LPARAM lParam, LPARAM lpData );

	HWND	m_hwParent;
	BOOL	m_fValidateWrite;
	BOOL	m_fValidateUI;	// FALSE if OK button not affected, TRUE if need to disable UI if validation fail
	TCHAR	m_szFolder[MAX_PATH];
};


#endif // _BROWSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\detect.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   detect.cpp
//
//  Description:
//
//      Implementation for the Detect() function
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"

#include <logging.h>
#include <StringUtil.h>
#include <download.h>
#include "schemamisc.h"
#include "expression.h"
#include <iucommon.h>


//
// define constants used in this file
//
#define C_INDEX_STATUS_INSTALLED	0
#define C_INDEX_STATUS_UPTODATE		1
#define C_INDEX_STATUS_NEWVERSION	2
#define C_INDEX_STATUS_EXCLUDED		3
#define	C_INDEX_STATUS_FORCE		4
#define C_INDEX_STATUS_COMPUTER		5	// <computerSystem>
#define C_INDEX_ARRAY_SIZE			6


//
// declare macros used in this cpp file
//

/** 
* deckare the constants used to manipulate the result of Detect() method
*/
/**
* used in <detection> tag, to tell the detection result. This result
* should overwrite the rest of <expression>, if any
*/
extern const LONG     IUDET_INSTALLED;							/* mask for <installed> result */
extern const LONG     IUDET_INSTALLED_NULL;					/* mask for <installed> missing */
extern const LONG     IUDET_UPTODATE;							/* mask for <upToDate> result */
extern const LONG     IUDET_UPTODATE_NULL;						/* mask for <upToDate> missing */
extern const LONG     IUDET_NEWERVERSION;						/* mask for <newerVersion> result */
extern const LONG     IUDET_NEWERVERSION_NULL;					/* mask for <newerVersion> missing */
extern const LONG     IUDET_EXCLUDED;							/* mask for <excluded> result */
extern const LONG     IUDET_EXCLUDED_NULL;						/* mask for <excluded> missing */
extern const LONG     IUDET_FORCE;								/* mask for <force> result */
extern const LONG     IUDET_FORCE_NULL;						/* mask for <force> missing */
extern const LONG	   IUDET_COMPUTER;							// mask for <computerSystem> result
extern const LONG	   IUDET_COMPUTER_NULL;						// <computerSystem> missing


const DetResultMask[6][2] = {
	{IUDET_INSTALLED, IUDET_INSTALLED_NULL},
	{IUDET_UPTODATE, IUDET_UPTODATE_NULL},
	{IUDET_NEWERVERSION, IUDET_NEWERVERSION_NULL},
	{IUDET_EXCLUDED, IUDET_EXCLUDED_NULL},
	{IUDET_FORCE, IUDET_FORCE_NULL},
	{IUDET_COMPUTER, IUDET_COMPUTER_NULL}
};
					


//
// local macros
//
#define ReturnIfHrFail(hr)		if (FAILED(hr)) {LOG_ErrorMsg(hr); return hr;}
#define GotoCleanupIfNull(p)	if (p) goto CleanUp
#define SetDetResultFromDW(arr, index, dw, bit, bitNull)	\
								if (bitNull == (dw & bitNull)) \
									arr[index] = -1; \
								else \
									arr[index] = (bit == (dw & bit)) ? 1 : 0;
		






/////////////////////////////////////////////////////////////////////////
//
// Private function DoDetection()
//		do detection on one item
//		
//	Input:
//		one item node
//
//	Output:
//		detect result: array of integer, each represents a result
//		of one element. indexes are defined as C_INDEX_STATUS_XXX
//		value:	<0	expresison not present
//				=0	evalues to FALSE
//				>0	evalues to TRUE
//
//
//	Return:
//		S_OK if everything fine or error code
/////////////////////////////////////////////////////////////////////////
HRESULT 
DoDetection(
	IXMLDOMNode*	pNode,			// one item node
	BOOL			fIsItemNode,	// need to go down 1 level to get detection node
	int*			pResultArray	// array of result
)
{
	LOG_Block("DoDetection");

	int					i;
	BOOL				fRet = FALSE;
	BOOL				fNeedReleaseNode = FALSE;
	HRESULT				hr = S_OK;
	BSTR				bstrNodeName	= NULL;
	BSTR				bstrText		= NULL;
	IXMLDOMNode*		pDetectionNode	= NULL;
	IXMLDOMNode*		pDetectionChild = NULL;
	IXMLDOMNode*		pExpression		= NULL;



	USES_IU_CONVERSION;

	if (fIsItemNode)
	{
		hr = pNode->selectSingleNode(KEY_DETECTION, &pDetectionNode);
		if (S_FALSE == hr || NULL == pDetectionNode)
		{
			hr = E_INVALIDARG;	// no detection node found!
			LOG_ErrorMsg(hr);
			return hr;
		}
	}
	else
	{
		pDetectionNode = pNode;
	}

	if (NULL == pDetectionNode)
	{
		//
		// no detection node. Legal schema though.
		// nothing we can do, so bail out.
		//
		LOG_XML(_T("no detection node found for this item! Returns S_FALSE, so it won't be reported"));
		return S_FALSE;
	}


	//
	// initialize result array
	//
	for (i = 0; i < C_INDEX_ARRAY_SIZE; i++)
	{
		pResultArray[i] = -1;
	}


	//
	// detection node may have a list of child nodes, each child node has
	// a different name for different purpose of detection.
	// each child node contains one and only one expression node
	//
	LOG_XML(_T("No costom detection DLL found. Detection children..."));

	(void) pDetectionNode->get_firstChild(&pDetectionChild);


	while (NULL != pDetectionChild)
	{
		//
		// for each child, see if it is a known detection child
		//
		(void) pDetectionChild->get_nodeName(&bstrNodeName);

		static const BSTR C_DETX_NAME[] = {
										KEY_INSTALLED, 
										KEY_UPTODATE, 
										KEY_NEWERVERSION, 
										KEY_EXCLUDED, 
										KEY_FORCE,
										KEY_COMPUTERSYSTEM
		};
		for (i = 0; i < ARRAYSIZE(C_DETX_NAME); i++)
		{
			if (CompareBSTRsEqual(bstrNodeName, C_DETX_NAME[i]))
			{
				//
				// found this child node is a known detection node
				//
				if (C_INDEX_STATUS_COMPUTER == i)
				{
					//
					// if this is the computerSystem detection, 
					// then we ignore all child nodes, just do a simple
					// function call to find out if this machine matches
					// the manufacturer and model
					//
					hr = DetectComputerSystem(pDetectionChild, &fRet);
				}
				else
				//
				// get the expression node from this child node
				//
				if (SUCCEEDED(hr = pDetectionChild->get_firstChild(&pExpression)))
				{

					if (NULL != pExpression)
					{
						hr = DetectExpression(pExpression, &fRet);
						LOG_XML(_T("Detection result for tag %s = %d, returns 0x%08x"), OLE2T(bstrNodeName), fRet?1:0, hr);
					}
					else
					{
						//
						// if there is no child, this is an empty detection type, 
						// then we will treat this as "ALWAYS TRUE", and reset hr so
						// this "always true" result can be sent out
						//
						fRet = TRUE;
						hr = S_OK;
					}
					
					SafeReleaseNULL(pExpression);

				}

				//
				// store the detection result
				//
				pResultArray[i] = (fRet) ? 1 : 0;

				break;	// done with current node
			}
		}

		SafeSysFreeString(bstrNodeName);


		if (FAILED(hr))
		{
			//
			// report error to log file
			//
			IXMLDOMNode* pIdentityNode = NULL, *pProviderNode = NULL;
			BSTR bstrIdentStr = NULL;
			char* pNodeType = (fIsItemNode) ? "Provider:" : "Item:";

			//
			// we need to find out the identity string of this node
			//
			if (fIsItemNode)
			{
				//
				// this is an item node, containing identity node
				//
				(void)FindNode(pNode, KEY_IDENTITY, &pIdentityNode);
			}
			else
			{
				//
				// this is the detection node of a provider
				//
				if (SUCCEEDED(pNode->get_parentNode(&pProviderNode)) && NULL != pProviderNode)
				{
					(void)FindNode(pProviderNode, KEY_IDENTITY, &pIdentityNode);
				}

			}


			//
			// if we have a valid identity node
			//
			if (NULL != pIdentityNode &&
				SUCCEEDED(UtilGetUniqIdentityStr(pIdentityNode, &bstrIdentStr, 0x0)) &&
				NULL != bstrIdentStr)
			{
				//
				// output log about the error
				//
#if defined(UNICODE) || defined(_UNICODE)
					LogError(hr, "Found error during detection %hs %ls", pNodeType, bstrIdentStr);
#else

					LogError(hr, "Found error during detection %s %s", pNodeType,  OLE2T(bstrIdentStr));
#endif
					SysFreeString(bstrIdentStr);
			}
			SafeReleaseNULL(pProviderNode);
			SafeReleaseNULL(pIdentityNode);

			//
			// if any one detection returns fail, then this detection node is
			// not valid - it means something wrong in the detection
			// data. we will just ignore this detection, no output for it.
			//
			break;
		}

		//
		// try next detection child
		//
		IXMLDOMNode* pNextNode = NULL;
		pDetectionChild->get_nextSibling(&pNextNode);
		SafeReleaseNULL(pDetectionChild);
		pDetectionChild = pNextNode;
	}

	SafeReleaseNULL(pDetectionChild);
	if (fIsItemNode)
	{
		SafeReleaseNULL(pDetectionNode);
	}
	
	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// public function Detect()
//
// Do detection.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be detected 
// Output:
// pbstrXmlItems - the detected items in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1" force="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Detect(BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems)
{
	HRESULT				hr				= S_OK;
	IXMLDOMNodeList*	pProviderList	= NULL;
	IXMLDOMNodeList*	pProvChildList	= NULL;
	IXMLDOMNode*		pCurProvider	= NULL;
	IXMLDOMNode*		pCurNode		= NULL;
	CXmlCatalog			xmlCatalog;
	CXmlItems			ItemList;					// result item list
	HANDLE_NODE			hNode;
	int					DetStatus[C_INDEX_ARRAY_SIZE];
	int					i;

	DWORD				dwDownloadFlags	= 0;

	LOG_Block("Detect()");

//#if defined(_DEBUG) || defined(DEBUG)
	USES_IU_CONVERSION;
//#endif

	if (NULL == bstrXmlCatalog || NULL == pbstrXmlItems)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	LOG_XML(_T("Catalog=%s"), OLE2T(bstrXmlCatalog));

    // Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
    if (dwFlags & FLAG_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	//
	// Convert bstrXmlCatalog to XMLDOM
	//
	hr = xmlCatalog.LoadXMLDocument(bstrXmlCatalog, m_fOfflineMode);
	ReturnIfHrFail(hr);
	LOG_XML(_T("Catalog has been loaded into XMLDOM"));

	//
	// get the list of providers from catalog 
	//
	pProviderList = xmlCatalog.GetProviders();
	if (NULL == pProviderList)
	{
		LOG_Error(_T("No provider found!"));
		return E_INVALIDARG;
	}

	//
	// get the first provider
	//
	(void) pProviderList->nextNode(&pCurProvider);

	//
	// for each provider, process their item list
	//
	while (NULL != pCurProvider)
	{
		//
		// get the children list from this node
		//
		pCurProvider->get_childNodes(&pProvChildList);

		if (NULL != pProvChildList)
		{
			long n;
			//
			// loop through the list to process each item of catalog
			//
			long iProvChildren = 0;
			pProvChildList->get_length(&iProvChildren);


			BOOL	fProviderOkay = TRUE;
			BSTR	bstrHref = NULL;

			//
			// process each child of this provider to see
			// if there is any detection node or any item node,
			//
			for (n = 0; n < iProvChildren && fProviderOkay; n++)
			{
				pProvChildList->get_item(n, &pCurNode);

				BOOL fIsItemNode = DoesNodeHaveName(pCurNode, KEY_ITEM);

				if (fIsItemNode ||
					DoesNodeHaveName(pCurNode, KEY_DETECTION))
				{
					//
					// initialize the status result array
					//
					for (i = 0; i < C_INDEX_ARRAY_SIZE; i++)
					{
						DetStatus[i] = -1;	// init to not present
					}

					//
					// detect each pression of this detection node of this item
					// error reported inside this function
					//
					if (S_OK == DoDetection(pCurNode, fIsItemNode, DetStatus))
					{
						//
						// add the item to the item list
						//
						if (SUCCEEDED(ItemList.AddItem(fIsItemNode ? pCurNode : pCurProvider, &hNode)) && HANDLE_NODE_INVALID != hNode)
						{
							//
							// update the detection status result of this item
							//
							ItemList.AddDetectResult(
													 hNode, 
													 DetStatus[C_INDEX_STATUS_INSTALLED],
													 DetStatus[C_INDEX_STATUS_UPTODATE],
													 DetStatus[C_INDEX_STATUS_NEWVERSION],
													 DetStatus[C_INDEX_STATUS_EXCLUDED],
													 DetStatus[C_INDEX_STATUS_FORCE],
													 DetStatus[C_INDEX_STATUS_COMPUTER]
													);
							ItemList.SafeCloseHandleNode(hNode);
						}
					}
				}

				SafeReleaseNULL(pCurNode);

			} // end of this item 

			//SafeReleaseNULL(pCurNode); // in case it's not item node


		} // end of non-empty node list of this provider

		//
		// finished processing the current provider
		//
		SafeReleaseNULL(pProvChildList);
		SafeReleaseNULL(pCurProvider);

		//
		// try to get a hold of the next provider
		//
		(void) pProviderList->nextNode(&pCurProvider);

	} // end of iterating provider list

	
	//
	// output the detection reuslt as an item list
	//
	ItemList.GetItemsBSTR(pbstrXmlItems);

	LOG_XML(_T("Result=%s"), *pbstrXmlItems);

	//
	// done
	//
	SafeReleaseNULL(pProviderList);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\cdmi.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   cdmi.cpp
//
//  Description:
//
//      Functions exported by IUEngine.dll for use by CDM.DLL
//
//          InternalDetFilesDownloaded
//			InternalDownloadGetUpdatedFiles
//			InternalDownloadUpdatedFiles
//			InternalFindMatchingDriver
//			InternalLogDriverNotFound
//			InternalQueryDetectionFiles
//
//=======================================================================
#include "iuengine.h"
#include "cdmp.h"

#include <setupapi.h>
#include <cfgmgr32.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include <osdet.h>
#include <fileutil.h>
#include "iuxml.h"
#include <wuiutest.h>

const CHAR SZ_APW_LIST[] = "Downloading printer list for Add Printer Wizard";
const CHAR SZ_FIND_MATCH[] = "Finding matching driver";
const CHAR SZ_OPENING_HS[] = "Opening Help and Support with: ";


void WINAPI InternalDetFilesDownloaded(
    IN  HANDLE hConnection
)
{
	LOG_Block("InternalDetFilesDownloaded");
	//
	// NOTE: This function is only used by WinME to expand the
	//       V3 buckets.cab (see commented out code below) and has no use
	//		 in V4 (IU) but remains for backwards compatibility of the export API.
	//
	LOG_ErrorMsg(E_NOTIMPL);
}

// Win 98 entry point
// This function allows Windows 98 to call the same entry points as NT.
// The function returns TRUE if the download succeeds and FALSE if it
// does not.
//
// Win 98 DOWNLOADINFO
// typedef struct _DOWNLOADINFOWIN98
// {
//		DWORD		dwDownloadInfoSize;	// size of this structure				- validate param (not validated in V3)
// 		LPTSTR		lpHardwareIDs;		// multi_sz list of Hardware PnP IDs	- only use first string
// 		LPTSTR		lpCompatIDs;		// multi_sz list of compatible IDs		- never used
// 		LPTSTR		lpFile;				// File name (string)					- never used
// 		OSVERSIONINFO	OSVersionInfo;	//OSVERSIONINFO from GetVersionEx()		- never used
// 		DWORD		dwFlags;			//Flags									- never used
// 		DWORD		dwClientID;			//Client ID								- never used
// } DOWNLOADINFOWIN98, *PDOWNLOADINFOWIN98;
// 
// typedef struct _DOWNLOADINFO {
//     DWORD          dwDownloadInfoSize;
//     LPCWSTR        lpHardwareIDs;				- copied from DOWNLOADINFOWIN98 using T2OLE()
//     LPCWSTR        lpDeviceInstanceID;			- in V3, match was sometimes found and this was filled in
//													-	but for IU we just let InternalDownloadUpdatedFiles do it all
//     LPCWSTR        lpFile;
//     OSVERSIONINFOW OSVersionInfo;
//     DWORD          dwArchitecture;				- set to PROCESSOR_ARCHITECTURE_UNKNOWN per V3 code
//     DWORD          dwFlags;
//     DWORD          dwClientID;
//     LCID           localid;						- not set in V3
// } DOWNLOADINFO, *PDOWNLOADINFO;

BOOL InternalDownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,	//The win98 download info structure is
												//slightly different that the NT version
												//so this function handles conversion.
	IN OUT LPTSTR			lpDownloadPath,		//returned Download path to the downloaded
												//cab files.
	IN UINT					uSize				//size of passed in download path buffer.
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalDownloadGetUpdatedFiles");

	if (NULL == pDownloadInfoWin98 ||
		NULL == pDownloadInfoWin98->lpHardwareIDs ||
		sizeof(DOWNLOADINFOWIN98) != pDownloadInfoWin98->dwDownloadInfoSize)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

    HRESULT hr;
	BOOL fOK = FALSE;
	DOWNLOADINFO info;
	ZeroMemory(&info, sizeof(info));
	info.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
	info.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
	//
	// NOTE: In V3 sources, we only use the _first_ HWID in the Multi_SZ pDownloadInfoWin98->lpHardwareIDs
	// and compare that against all enumerated hardware IDs.
	// In IU, this compare will be done in InternalDownloadUpdatedFiles, so we just pass through
	// the HWID
	//

	// Prefast - using too much stack, so move HWIDBuff to heap
	LPWSTR pwszHWIDBuff = (LPWSTR) HeapAlloc(GetProcessHeap(), 0, HWID_LEN);
	if (NULL != pwszHWIDBuff)
	{
        // buffer size obtained from HeapAlloc call above.
        hr = StringCbCopyExW(pwszHWIDBuff, HWID_LEN, T2OLE(pDownloadInfoWin98->lpHardwareIDs),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SafeHeapFree(pwszHWIDBuff);
            LOG_ErrorMsg(hr);
            return FALSE;
        }
        	    
		info.lpHardwareIDs = pwszHWIDBuff;

		WCHAR wszbufPath[MAX_PATH];
		UINT uRequiredSize;
		//
		// We no longer have context handles, so just pass 1 to make InternalDownloadUpdatedFiles happy.
		//
		fOK = InternalDownloadUpdatedFiles((HANDLE) 1, NULL,  &info, wszbufPath,
									uSize * (sizeof(WCHAR)/sizeof(TCHAR)), &uRequiredSize);
	}
	else
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
	}

	if (fOK)
	{
		hr = StringCbCopyEx(lpDownloadPath, uSize, OLE2T(pwszHWIDBuff), 
		                    NULL, NULL, MISTSAFE_STRING_FLAGS | STRSAFE_NO_TRUNCATION);
	    if (FAILED(hr))
	        fOK = FALSE;
	}
	
	SafeHeapFree(pwszHWIDBuff);

    return fOK;
}

//This function downloads the specified CDM package. The hConnection handle must have
//been returned from the OpenCDMContext() API.
//
//This function Returns TRUE if download is successful GetLastError() will return
//the error code indicating the reason that the call failed.

BOOL WINAPI InternalDownloadUpdatedFiles(
	IN  HANDLE        hConnection,		//Connection handle from OpenCDMContext() API.
	IN  HWND          hwnd,				//Window handle for call context
	IN  PDOWNLOADINFO pDownloadInfo,	//download information structure describing
										//package to be read from server
	OUT LPWSTR        lpDownloadPath,	//local computer directory location of the
										//downloaded files
	IN  UINT          uSize,				// Not Used (we require the buffer to be a WCHAR buffer
											// MAX_PATH characters long)
	OUT PUINT         /*puRequiredSize*/	// Not used (we don't validate uSize - see comments inline)
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalDownloadUpdatedFiles");

	TCHAR szDownloadPathTmp[MAX_PATH];
	BSTR bstrXmlCatalog = NULL;
	HRESULT hr = S_OK;
	BOOL fPlist = FALSE;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	// Since all current platforms call DownloadUpdatedFiles with MAX_PATH TCHARS, we will just
	// require MAX_PATH for all callers.
	//
	// UNFORTUNATELY, NewDev passes up uSize in bytes and the Printer folks pass us characters,
	// so there is no way to validate this parameter. In addition, we won't bother validating
	// puRequiredSize since we never use it (would be return chars or bytes?)
	if (NULL == pDownloadInfo || NULL == lpDownloadPath || NULL == hConnection)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (g_pCDMEngUpdate->m_fOfflineMode)
	{
		SetLastError(ERROR_REM_NOT_LIST);
		return FALSE;
	}

	//
	// Check to see if this is a printer catalog request. Note: 3FBF5B30-DEB4-11D1-AC97-00A0C903492B
	// is not defined in any system or private headers and is copied from
	// \\index2\ntsrc\printscan\print\spooler\splsetup\util.c (or equiv.)
	//
	// Only the first string passed in lpHardwareIDs is relevant to this test
	fPlist = (	NULL != pDownloadInfo->lpHardwareIDs && 
				CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
					L"3FBF5B30-DEB4-11D1-AC97-00A0C903492B", -1, pDownloadInfo->lpHardwareIDs, -1)
			 );

	OSVERSIONINFO osVersionInfo;
	ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFO));
	osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!GetVersionEx(&osVersionInfo))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	//
	// Only support printers for Win2K up & WinME
	//
	if ( fPlist &&
		!(	(	// Win2K (NT 5.0) up
				(VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId) &&
				(4 < osVersionInfo.dwMajorVersion)
			)
			||
			(	// WinME (or higher)
				(VER_PLATFORM_WIN32_WINDOWS == osVersionInfo.dwPlatformId) &&
				(90	<= osVersionInfo.dwMinorVersion)
			)
		 )
	   )
	{
		CleanUpIfFailedAndSetHrMsg(E_NOTIMPL);
	}
	
	hr = GetPackage(fPlist ? GET_PRINTER_INFS : DOWNLOAD_DRIVER,
						pDownloadInfo, szDownloadPathTmp, ARRAYSIZE(szDownloadPathTmp), &bstrXmlCatalog);
	if (FAILED(hr))
	{
		lpDownloadPath[0] = 0;
		//
		// Map an HRESULT to a WIN32 error value
		// Note: This assumes that WIN32 errors fall in the range -32k to 32k,
		// same as HRESULT_FROM_WIN32 that packaged them into HRESULT.
		//
		SetLastError(hr & 0x0000FFFF);
		goto CleanUp;
	}
	else
	{
        // The comment above says that different callers pass in different types
        //  of values for uSize, so the function assumes that the buffer is MAX_PATH.
        //  Attempting to find out if we can force callers into this function to 
        //  do the right thing.  For now, assume buffer is MAX_PATH.
	    hr = StringCchCopyExW(lpDownloadPath, MAX_PATH, T2OLE(szDownloadPathTmp),
	                          NULL, NULL, MISTSAFE_STRING_FLAGS);
	    if (FAILED(hr))
	    {
	        SetLastError(HRESULT_CODE(hr));
	        goto CleanUp;
	    }
	    
		LOG_Driver(_T("Downloaded files for %s located at %S"), pDownloadInfo->lpHardwareIDs, lpDownloadPath);
		goto CleanUp;
	}

CleanUp:

	SysFreeString(bstrXmlCatalog);

	if (fPlist)
	{
		if (SUCCEEDED(hr))
		{
			LogMessage(SZ_APW_LIST);
		}
		else
		{
			LogError(hr, SZ_APW_LIST);
		}
	}
	else
	{
		if (SUCCEEDED(hr))
		{
			LogMessage("Downloaded driver for %ls at %ls", pDownloadInfo->lpHardwareIDs, lpDownloadPath);
		}
		else
		{
			LogError(hr, "Driver download failed for %ls", pDownloadInfo->lpHardwareIDs);
		}
	}

	return SUCCEEDED(hr);
}

BOOL WINAPI  InternalFindMatchingDriver(
	IN  HANDLE			hConnection,
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
) {
	LOG_Block("InternalFindMatchingDriver");

	BSTR bstrXmlCatalog = NULL;
	BSTR bstrHWID = NULL;
	BSTR bstrDisplayName = NULL;
	BSTR bstrDriverName = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrDriverProvider = NULL;
	BSTR bstrDriverVer = NULL;
	BSTR bstrArchitecture = NULL;



	HRESULT hr = S_OK;
	CXmlCatalog* pCatalog = NULL;
	HANDLE_NODE hCatalogItem;
	HANDLE_NODE hProvider;
	HANDLE_NODELIST hItemList;
	HANDLE_NODELIST hProviderList;
	BOOL fIsPrinter;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return FALSE;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	if (NULL == pDownloadInfo || NULL == pWuDriverInfo || NULL == hConnection)
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	if (g_pCDMEngUpdate->m_fOfflineMode)
	{
		SetLastError(ERROR_REM_NOT_LIST);
		return FALSE;
	}

	CleanUpFailedAllocSetHrMsg(pCatalog = (CXmlCatalog*) new CXmlCatalog);

	//
	// Get the catalog XML
	//
	CleanUpIfFailedAndSetHr(GetPackage(GET_CATALOG_XML, pDownloadInfo, NULL, 0, &bstrXmlCatalog));
	//
	// Load the XML and get the <item/> list and node of first item (only one in CDM case)
	//
	CleanUpIfFailedAndSetHr(pCatalog->LoadXMLDocument(bstrXmlCatalog, g_pCDMEngUpdate->m_fOfflineMode));

	hProviderList = pCatalog->GetFirstProvider(&hProvider);
	if (HANDLE_NODELIST_INVALID == hProviderList || HANDLE_NODE_INVALID == hProvider)
	{
		hr = S_FALSE;
		goto CleanUp;
	}
	
	hItemList = pCatalog->GetFirstItem(hProvider, &hCatalogItem);
	if (HANDLE_NODELIST_INVALID == hItemList || HANDLE_NODE_INVALID == hProvider)
	{
		hr = S_FALSE;
		goto CleanUp;
	}
	//
	// Populate pWuDriverInfo with data from the catalog
	//
	CleanUpIfFailedAndSetHr(pCatalog->GetDriverInfoEx(hCatalogItem,
													&fIsPrinter,
													&bstrHWID,
													&bstrDriverVer,
													&bstrDisplayName,
													&bstrDriverName,
													&bstrDriverProvider,
													&bstrMfgName,
													&bstrArchitecture));
	
    hr = StringCchCopyExW(pWuDriverInfo->wszHardwareID, 
                          ARRAYSIZE(pWuDriverInfo->wszHardwareID), 
                          bstrHWID,
                          NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;

    hr = StringCchCopyExW(pWuDriverInfo->wszDescription, 
                          ARRAYSIZE(pWuDriverInfo->wszDescription), 
                          bstrDisplayName,
                          NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        goto CleanUp;
    
	//
	// Convert from ISO to DriverVer date format
	//
	// DriverVer: "mm-dd-yyyy" <--> ISO 8601: "yyyy-mm-dd"
	//     index:  0123456789                  0123456789
	//
    if (ARRAYSIZE(pWuDriverInfo->wszDriverVer) >= 11 && 
        SysStringLen(bstrDriverVer) == 10)
    {
    	pWuDriverInfo->wszDriverVer[0]  = bstrDriverVer[5];
    	pWuDriverInfo->wszDriverVer[1]  = bstrDriverVer[6];
    	pWuDriverInfo->wszDriverVer[2]  = L'-';
    	pWuDriverInfo->wszDriverVer[3]  = bstrDriverVer[8];
    	pWuDriverInfo->wszDriverVer[4]  = bstrDriverVer[9];
    	pWuDriverInfo->wszDriverVer[5]  = L'-';
    	pWuDriverInfo->wszDriverVer[6]  = bstrDriverVer[0];
    	pWuDriverInfo->wszDriverVer[7]  = bstrDriverVer[1];
    	pWuDriverInfo->wszDriverVer[8]  = bstrDriverVer[2];
    	pWuDriverInfo->wszDriverVer[9]  = bstrDriverVer[3];
    	pWuDriverInfo->wszDriverVer[10] = L'\0';
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto CleanUp;
    }
    

	if(fIsPrinter)
	{
        hr = StringCchCopyExW(pWuDriverInfo->wszMfgName, 
                              ARRAYSIZE(pWuDriverInfo->wszMfgName), 
                              bstrMfgName,
                              NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCopyExW(pWuDriverInfo->wszProviderName, 
                              ARRAYSIZE(pWuDriverInfo->wszProviderName), 
                              bstrDriverProvider,
                              NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
	}

CleanUp:

	if (S_OK == hr)
	{
		LogMessage("Found matching driver for %ls, %ls, %ls", bstrHWID, bstrDisplayName, bstrDriverVer);
	}
	else
	{
		if (S_FALSE == hr)
		{
			if (pDownloadInfo->lpDeviceInstanceID)
			{
				LogMessage("Didn't find matching driver for %ls", pDownloadInfo->lpDeviceInstanceID);
			}
			else if (pDownloadInfo->lpHardwareIDs)
			{
				LogMessage("Didn't find matching driver for %ls", pDownloadInfo->lpHardwareIDs);
			}
			else
			{
				LogMessage("Didn't find matching driver"); 
			}
		}
		else	// error happened
		{
			if (pDownloadInfo->lpDeviceInstanceID)
			{
				LogError(hr, "%s for %ls", SZ_FIND_MATCH, pDownloadInfo->lpDeviceInstanceID);
			}
			else if (pDownloadInfo->lpHardwareIDs)
			{
				LogError(hr, "%s for %ls", SZ_FIND_MATCH, pDownloadInfo->lpHardwareIDs);
			}
			else
			{
				LogError(hr, SZ_FIND_MATCH); 
			}
		}

	}

	SysFreeString(bstrXmlCatalog);
	SysFreeString(bstrHWID);
	SysFreeString(bstrDisplayName);
	SysFreeString(bstrDriverName);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrDriverProvider);
	SysFreeString(bstrDriverVer);
	SysFreeString(bstrArchitecture);

	if (NULL != pCatalog)
	{
		delete pCatalog;
	}

	return SUCCEEDED(hr);
}


// supports offline logging
// hConnection NOT used at all
// no network connection or osdet.dll needed for languauge, SKU, platform detection 
void WINAPI InternalLogDriverNotFound(
    IN  HANDLE hConnection,
	IN LPCWSTR lpDeviceInstanceID,
	IN DWORD dwFlags				// dwFlags could be either 0 or BEGINLOGFLAG from NEWDEV
) {
	USES_IU_CONVERSION;

	LOG_Block("InternalLogDriverNotFound");

#if !(defined(_UNICODE) || defined(UNICODE))
	LOG_ErrorMsg(E_NOTIMPL);
	return;
#else

	HRESULT hr = E_FAIL;
	DWORD dwBytes;
	TCHAR* pszBuff = NULL;
	ULONG ulLength;
	DWORD dwDeviceCount = 0;
	DWORD dwRank = 0;

	TCHAR szUniqueFilename[MAX_PATH] = _T("");
	DWORD dwWritten;
	DEVINST devinst;
	bool fXmlFileError = false;
	HANDLE hFile = NULL;
	BSTR bstrXmlSystemSpec = NULL;
	BSTR bstrThisID = NULL;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;

	static CDeviceInstanceIdArray apszDIID; //device instance id list
	LPWSTR pDIID = NULL; //Device Instance ID

	CXmlSystemSpec xmlSpec;

	if (NULL == g_pCDMEngUpdate)
	{
		SetLastError(ERROR_OUTOFMEMORY);
		return;
	}

	//
	// Reset Quit Event in case client retries after a SetOperationMode
	//
	ResetEvent(g_pCDMEngUpdate->m_evtNeedToQuit);

	//
	// Only allow BEGINLOGFLAG or no flags
	//
	if (!(0 == dwFlags || BEGINLOGFLAG == dwFlags))
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}
	//
	// If no flags, then lpDeviceInstanceID must be valid
	//
	if (0 == dwFlags && NULL == lpDeviceInstanceID)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	LogMessage("Started process to regester driver not found with Help Center. Not completing this process may not be error.");

	IU_PLATFORM_INFO iuPlatformInfo;
	//
	// We need iuPlatformInfo for both <platform> and <devices> elements
	// NOTE: iuPlatformInfo is initialized by DetectClientIUPlatform, and BSTRs must be
	//       freed in CleanUp (don't just there before this call).
	//
	CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));

	//
	// Should only be called on Whistler up except CHK builds can run on Win2K
	//
	if (  !( (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion) &&
			(0 < iuPlatformInfo.osVersionInfoEx.dwMinorVersion)	 )	)
	{
		LOG_Driver(_T("Should only be called on Whistler or greater"));
		CleanUpIfFailedAndSetHr(E_NOTIMPL);
	}

	if (NULL != lpDeviceInstanceID)
	{
		LOG_Driver(_T("DeviceInstanceID is %s"), lpDeviceInstanceID);
		
		//
		// Add the DeviceInstanceID to the list
		//
		if (-1 == apszDIID.Add(lpDeviceInstanceID))
		{
			goto CleanUp;
		}
	}


	if (0 == (dwFlags & BEGINLOGFLAG) || 0 == apszDIID.Size())
	{
		// not last log request or nothing to log
		LOG_Driver(_T("Won't log to hardware_XXX.xml until we get BEGINLOGFLAG when we have cached at least 1 HWID"));
		return;
	}

	////////////////////////////////////////////
	// ELSE, WRITE XML FILE and call HelpCenter
	////////////////////////////////////////////

	hr = OpenUniqueFileName(szUniqueFilename, ARRAYSIZE(szUniqueFilename), hFile);
	if (S_OK != hr) 
	{
		fXmlFileError = true;
		goto CleanUp;
	}

	//
	// Write Unicode Header
	//
	if (0 == WriteFile(hFile, (LPCVOID) &UNICODEHDR, ARRAYSIZE(UNICODEHDR), &dwWritten, NULL))
	{
		SetHrMsgAndGotoCleanUp(GetLastError());
	}

	//
	// Add Platform
	//
	CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));

	//
	// Add OS Locale information
	//
	CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));

	//
	// Initialize pszBuff to one NULL character
	//
	CleanUpFailedAllocSetHrMsg(pszBuff = (TCHAR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(TCHAR)));

	for (int i = 0; i < apszDIID.Size(); i++)
	{
		TCHAR* pszTemp;
		pDIID = apszDIID[i];
		
		//
		// NTBUG9#151928 - Log both hardware and compatible IDs of the device that matches lpDeviceInstanceID
		//

		LOG_Driver(_T("Log device instance with id %s"), pDIID);
		//
		// NOTE: We will ignore MatchingDeviceID's since we won't be called by DevMgr unless there is no installed
		// driver. This will allow test harnesses to call this function with valid DeviceInstanceIDs for the
		// test client to generate XML.
		//
		if (CR_SUCCESS == CM_Locate_DevNodeW(&devinst, (LPWSTR) pDIID, 0))
		{
			dwRank = 0;
			//
			// Open a <device> element
			//
			BSTR bstrDeviceInstance = SysAllocString(pDIID);
			CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(bstrDeviceInstance, -1, NULL, NULL, NULL, &hDevices));
			SafeSysFreeString(bstrDeviceInstance);

			//
			// Log all the hardware IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, NULL, &ulLength, 0))
			{
				CleanUpFailedAllocSetHrMsg(pszTemp = (TCHAR*) HeapReAlloc(GetProcessHeap(), 0, (LPVOID) pszBuff, ulLength));
				pszBuff = pszTemp;

				if (CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_HARDWAREID, NULL, pszBuff, &ulLength, 0))
				{
					for (TCHAR* pszThisID = pszBuff; *pszThisID; pszThisID += (lstrlen(pszThisID) + 1))
					{
						dwDeviceCount++;
						LOG_Driver(_T("<hwid/>: %s, rank: %d"), pszThisID, dwRank);
						bstrThisID = T2BSTR(pszThisID);
						CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, FALSE, dwRank++, bstrThisID, NULL));
						SafeSysFreeString(bstrThisID);
					}
				}
			}

			//
			// Log all the compatible IDs
			//
			ulLength = 0;
			if (CR_BUFFER_SMALL == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, NULL, &ulLength, 0))
			{
				CleanUpFailedAllocSetHrMsg(pszTemp = (TCHAR*) HeapReAlloc(GetProcessHeap(), 0, (LPVOID) pszBuff, ulLength));
				pszBuff = pszTemp;

				if (CR_SUCCESS == CM_Get_DevNode_Registry_Property(devinst, CM_DRP_COMPATIBLEIDS, NULL, pszBuff, &ulLength, 0))
				{
					for (TCHAR* pszThisID = pszBuff; *pszThisID; pszThisID += (lstrlen(pszThisID) + 1))
					{
						dwDeviceCount++;
						LOG_Driver(_T("<compid/>: %s, rank: %d"), pszThisID, dwRank);
						bstrThisID = T2BSTR(pszThisID);
						CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, TRUE, dwRank++, bstrThisID, NULL));
						SafeSysFreeString(bstrThisID);
					}
				}
			}

			if (HANDLE_NODE_INVALID != hDevices)
			{
				xmlSpec.SafeCloseHandleNode(hDevices);
			}
		}
	}
	
	//
	// Write the XML to the file
	//
	if (SUCCEEDED(xmlSpec.GetSystemSpecBSTR(&bstrXmlSystemSpec)))
	{
		if (0 == WriteFile(hFile, (LPCVOID) OLE2T(bstrXmlSystemSpec),
							lstrlenW(bstrXmlSystemSpec) * sizeof(TCHAR), &dwWritten, NULL))
		{
			SetHrMsgAndGotoCleanUp(GetLastError());
		}
	}
	else
	{
		fXmlFileError = true;
	}

CleanUp:

	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	if (NULL != hFile)
	{
		CloseHandle(hFile);
	}

	SafeSysFreeString(bstrXmlSystemSpec);
	SafeSysFreeString(bstrThisID);

	//
	// We've already written everything in list, init so we can start over
	//
	apszDIID.FreeAll();
	SafeHeapFree(pszBuff);

	//
	// Open Help Center only if we have valid xml and one or more devices
	//
	if (!fXmlFileError && 0 < dwDeviceCount)
	{
		DWORD dwLen;
		LPTSTR pszSECommand = NULL;	// INTERNET_MAX_URL_LENGTH

		//
		// Allocate buffers
		//
		pszBuff = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszBuff)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			DeleteFile(szUniqueFilename);
			return;
		}

		pszSECommand = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszSECommand)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			SafeHeapFree(pszBuff);
			DeleteFile(szUniqueFilename);
			return;
		}

		//
		// Manually canonicalize second '?' in base string as excaped "%3F"
		//
		const static TCHAR tszBase[] =
			_T("hcp://services/layout/xml?definition=hcp://system/dfs/viewmode.xml&topic=hcp://system/dfs/uplddrvinfo.htm%3F");

		LOG_Driver(_T("Filename: %s"), szUniqueFilename);
		//
		// Canonicalize the filename once (i.e. ' ' -> %20) into pszBuff
		//
		dwLen = INTERNET_MAX_URL_LENGTH;
		if (!InternetCanonicalizeUrl(szUniqueFilename, pszBuff, &dwLen, 0))
		{
			LOG_ErrorMsg(GetLastError());
			SafeHeapFree(pszBuff);
			SafeHeapFree(pszSECommand);
			DeleteFile(szUniqueFilename);
			return;
		}

		LOG_Driver(_T("Filename canonicalized once: %s"), pszBuff);

		//
		// Concatinate canonicalized filename on to end of base reusing tszBuff1
		//
		// We don't need to check length since we know length of tszBase + MAX_PATH canonicalized
		// string won't exceed INTERNET_MAX_URL_LENGTH;
		//

		// pszSECommand was allocated to be INTERNET_MAX_URL_LENGTH TCHARs above.
		hr = StringCchPrintfEx(pszSECommand, INTERNET_MAX_URL_LENGTH, 
		                       NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("%s%s"), tszBase, pszBuff);
		if (SUCCEEDED(hr))
		{
    		LOG_Driver(_T("Opening HelpCenter via Shell Execute: \"%s\""), (LPCTSTR) pszSECommand);

#if defined(UNICODE) || defined(_UNICODE)
    		LogMessage("%s\"%S\"", SZ_OPENING_HS, pszSECommand);
#else
    		LogMessage("%s\"%s\"", SZ_OPENING_HS, pszSECommand);
#endif
    		//
    		// Call HelpCenter
    		//
    		ShellExecute(NULL, NULL, pszSECommand, NULL, NULL, SW_SHOWNORMAL);
		}
		else
		{
			LOG_ErrorMsg(hr);
		}

		SafeHeapFree(pszBuff);
		SafeHeapFree(pszSECommand);

		return;
	}
	else
	{ 
		//
		// Remove the generated file
		//
		LOG_Driver(_T("fXmlFileError was true or no devices were added - deleting %s"), szUniqueFilename);
		DeleteFile(szUniqueFilename);
	}

	return;

#endif	// UNICODE is defined
}

//
// Currently, this function is not implemented for Whistler or IU (called by V3 AU on WinME
// to support offline driver cache).
//
int WINAPI InternalQueryDetectionFiles(
    IN  HANDLE							/* hConnection */, 
	IN	void*							/* pCallbackParam */, 
	IN	PFN_QueryDetectionFilesCallback	/* pCallback */
) {
	LOG_Block("InternalQueryDetectionFiles");

	LOG_ErrorMsg(E_NOTIMPL);

	return 0;
}

void InternalSetGlobalOfflineFlag(BOOL fOfflineMode)
{
	//
	// Called once exclusively by CDM. This property is used
	// to maintain backwards compatibility with the XPClient
	// V4 version of CDM (single-instance design). See also
	// the comments in the exported ShutdownThreads function.
	//
	// Unfortunately, we can't report errors to CDM, but we check the
	// global before dereferencing (except here which has an HRESULT).
	//

	if (SUCCEEDED(CreateGlobalCDMEngUpdateInstance()))
	{
		g_pCDMEngUpdate->m_fOfflineMode = fOfflineMode;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\delexdl.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   delexdl.cpp
//
//  Description:
//
//      Function exported by IUEngine.dll to do extra work upon 
//		the engine Dll gets loaded, including:
//		(1) clean up old download folders
//		(2) download security data
//
//=======================================================================
#include "iuengine.h"
#include <wuiutest.h>
#include <fileutil.h>
#include <stringutil.h>
#include <trust.h>
#include <download.h>
#include <freelog.h>
#include <advpub.h>			// for ExtractFiles
#include <WaitUtil.h>
#include <urllogging.h>
#include <safefile.h>

#define GotoCleanUpIfAskedQuit				if (WaitForSingleObject(g_evtNeedToQuit, 0) == WAIT_OBJECT_0) {goto CleanUp;}


//
// Default expiration time is 30 days (30 days * 24 hrs * 60 min * 60 sec)
//
// Since the default time has a very large granularity, we don't account for the
// documented differences between FILETIME for different platforms and file systems
// (see MSDN for details).
//
const DWORD DEFAULT_EXPIRED_SECONDS = 2592000;

const int NanoSec100PerSec = 10000000;		// number of 100 nanoseconds per second (FILETIME unit)

DWORD WINAPI DeleteFoldersThreadProc(LPVOID lpv);

void AsyncDeleteExpiredDownloadFolders(void);


//=========================================================================
//
// exported public function called by control after the engine loaded.
//
//=========================================================================
void WINAPI AsyncExtraWorkUponEngineLoad()
{
	//
	// Only do this the first time we are loaded (not for every client / instance)
	//
	if (0 == InterlockedExchange(&g_lDoOnceOnLoadGuard, 1))
	{
		AsyncDeleteExpiredDownloadFolders();
	}
}



//-------------------------------------------------------------------------
//
// Creates a thread that searches WUTemp folders for old downloaded content
// that has not been deleted.
//
// Since it is not critical that this function succeed, we don't return
// errors.
//
//-------------------------------------------------------------------------
void AsyncDeleteExpiredDownloadFolders()
{
	LOG_Block("DeleteExpiredDownloadFolders");

	DWORD dwThreadId;
	HANDLE hThread;

	//
	// Create thread and let it run until it finishes or g_evtNeedToQuit gets signaled
	//
    InterlockedIncrement(&g_lThreadCounter);

    hThread = CreateThread(NULL, 0, DeleteFoldersThreadProc, (LPVOID) NULL, 0, &dwThreadId);
    if (NULL == hThread)
    {
        LOG_ErrorMsg(GetLastError());
		InterlockedDecrement(&g_lThreadCounter);
        return;
    }

	CloseHandle(hThread);
}


//-------------------------------------------------------------------------
//
// DeleteFoldersThreadProc()
//
//	thread function to clean up expired download folders
//	
//-------------------------------------------------------------------------
DWORD WINAPI DeleteFoldersThreadProc(LPVOID /*lpv*/)
{
	LOG_Block("DeleteFoldersThreadProc");

	DWORD dwExpiredSeconds = DEFAULT_EXPIRED_SECONDS;
	HRESULT hr;
	FILETIME ftExpired;
	ULARGE_INTEGER u64ft;
	ULARGE_INTEGER u64Offset;
	DWORD dwRet;

#if defined(__WUIUTEST)
	// Override DEFAULT_EXPIRED_SECONDS
	HKEY hKey;
	int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
	if (ERROR_SUCCESS == error)
	{
		DWORD dwSize = sizeof(DWORD);
		DWORD dwValue;
		error = RegQueryValueEx(hKey, REGVAL_DEFAULT_EXPIRED_SECONDS, 0, 0, (LPBYTE) &dwExpiredSeconds, &dwSize);
		if (ERROR_SUCCESS == error)
		{
			LOG_Driver(_T("DEFAULT_EXPIRED_SECONDS changed to %d seconds"), dwExpiredSeconds);
		}

		RegCloseKey(hKey);
	}
#endif

	GetSystemTimeAsFileTime(&ftExpired);

	u64ft.u.LowPart = ftExpired.dwLowDateTime;
	u64ft.u.HighPart = ftExpired.dwHighDateTime;

	u64Offset.u.LowPart = NanoSec100PerSec;
	u64Offset.u.HighPart = 0;
	u64Offset.QuadPart *= dwExpiredSeconds;
	u64ft.QuadPart -= u64Offset.QuadPart;

	ftExpired.dwLowDateTime = u64ft.u.LowPart;
	ftExpired.dwHighDateTime = u64ft.u.HighPart;
	//
	// Get list of drives we will search
	//
	TCHAR szDriveStrBuffer[MAX_PATH + 2];
	TCHAR szWUTempPath[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFindFile = INVALID_HANDLE_VALUE;

	LPTSTR pszRootPathName;

	//
	// If quit was signaled before we were scheduled, just bail
	//
	GotoCleanUpIfAskedQuit;

	//
	// Make sure we are double-null terminated by zeroing buffer and lying about size
	//
	ZeroMemory(szDriveStrBuffer, sizeof(szDriveStrBuffer));

	if (0 == (dwRet = GetLogicalDriveStrings(ARRAYSIZE(szDriveStrBuffer) - 2, (LPTSTR) szDriveStrBuffer))
		|| (ARRAYSIZE(szDriveStrBuffer) - 2) < dwRet)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	for (pszRootPathName = szDriveStrBuffer; NULL != *pszRootPathName; pszRootPathName += lstrlen(pszRootPathName) + 1)
	{
		//
		// Only look for szIUTemp on fixed drives
		//
		if (DRIVE_FIXED == GetDriveType(pszRootPathName))
		{
			//
			// Create the dir path
			//
            hr = StringCchCopyEx(szWUTempPath, ARRAYSIZE(szWUTempPath), pszRootPathName,
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    continue;
			}

			hr = PathCchAppend(szWUTempPath, ARRAYSIZE(szWUTempPath), IU_WUTEMP);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    continue;
			}

			DWORD dwAttr;

			dwAttr = GetFileAttributes(szWUTempPath);

			if (dwAttr != 0xFFFFFFFF && (FILE_ATTRIBUTE_DIRECTORY & dwAttr))
			{
				//
				// Look for directories older than ftExpired
				//
				// NOTE:When we add support for AU and/or Drizzle we should add a
				// file to the folder to override the default delete time. 
				// We should synchronize access to this file by opening exclusive.
				//

				// Find the first file in the directory
    			hr = PathCchAppend(szWUTempPath, ARRAYSIZE(szWUTempPath), _T("\\*.*"));
    			if (FAILED(hr))
    			{
    			    LOG_ErrorMsg(hr);
			        continue;
    			}

				if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szWUTempPath, &fd)))
				{
					LOG_ErrorMsg(GetLastError());
			        continue;
				}

				do 
				{
					if (
						(CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						fd.cFileName, -1, TEXT("."), -1)) ||
						(CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						fd.cFileName, -1, TEXT(".."), -1))
					) continue;
					
					if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
						//
						// If directory creation time < expired time delete the directory
						//
						if (-1 == CompareFileTime(&fd.ftCreationTime, &ftExpired))
						{
							TCHAR szDirPath[MAX_PATH];

                            hr = StringCchCopyEx(szDirPath, ARRAYSIZE(szDirPath), pszRootPathName,
                                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}

                			hr = PathCchAppend(szDirPath, ARRAYSIZE(szDirPath), IU_WUTEMP);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}

                			hr = PathCchAppend(szDirPath, ARRAYSIZE(szDirPath), fd.cFileName);
                			if (FAILED(hr))
                			{
                			    LOG_ErrorMsg(hr);
            			        continue;
                			}
							
							(void) SafeDeleteFolderAndContents(szDirPath, SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR);
						}
					}

					GotoCleanUpIfAskedQuit;

				} while (FindNextFile(hFindFile, &fd));// Find the next entry
			}
		}

	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}

    InterlockedDecrement(&g_lThreadCounter);
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\download.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   downld.cpp
//
//  Description:
//
//      Implementation for the Download() function
//
//=======================================================================

#include "iuengine.h"   // PCH - must include first
#include <iu.h>
#include <iucommon.h>
#include <download.h>
#include <trust.h>
#include <wininet.h>
#include <fileutil.h>
#include <shlwapi.h>
#include "iuxml.h"
#include "history.h"
#include <schemakeys.h>
//#include <serverPing.h> changed to use urllogging.h.
#include <intshcut.h>
#include <schemamisc.h>
#include <WaitUtil.h>
#include <urllogging.h>

#define MAX_CORPORATE_PATH      100

// named mutex used to update historical speed/time information in the registry.
const TCHAR IU_MUTEX_HISTORICALSPEED_REGUPDATE[] = _T("{5f3255a9-9051-49b1-80b9-aac31c092af4}");
const TCHAR IU_READMORE_LINK_NAME[] = _T("ReadMore.url");
const CHAR  SZ_DOWNLOAD_FINISHED[] = "Download finished";

const LONG     UPDATE_COMMAND                    = 0x0000000F;

typedef struct IUDOWNLOADSTARTUPINFO
{
    BSTR bstrClientName;
    BSTR bstrXmlCatalog;
    BSTR bstrDestinationFolder;
    LONG lMode;
    IUnknown *punkProgressListener;
    HWND hwnd;
    BSTR bstrUuidOperation;
	CEngUpdate* pEngUpdate;
} IUDOWNLOADSTARTUPINFO, *PIUDOWNLOADSTARTUPINFO;


// --------------------------------------------------------------------
// function forward declarations
// --------------------------------------------------------------------

//
// Callback function to provide status from the downloader
//
BOOL WINAPI DownloadCallback(VOID* pCallbackData, DWORD dwStatus, DWORD dwBytesTotal, DWORD dwBytesComplete, BSTR bstrXmlData, LONG* plCommandRequest);

//
// thread function used by DownloadAsync
// 
DWORD WINAPI DownloadThreadProc(LPVOID lpv);

/////////////////////////////////////////////////////////////////////////////
// CreateReadMoreLink()
//
// If the item contains a "description/descriptionText/details" node, suck
// out the URL and create a shortcut for it in the destination folder
//
// Input:
// pxmlCatalog          - CXmlCatalog containing downloaded items
// hItem                - Handle to current download item in the catalog
// pszDestinationFolder - Folder where item is downloaded
//
// Return:
//  S_OK    - Wrote the ReadMore.htm link
//  S_FALSE - details node didn't exist in item
//  <other> - HRESULT returned from calling other functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateReadMoreLink(CXmlCatalog* pxmlCatalog, HANDLE_NODE hItem, LPCTSTR pszDestinationFolder)
{
    USES_IU_CONVERSION;

    LOG_Block("CreateReadMoreLink");

    IXMLDOMNode*                pItemNode = NULL;
    IXMLDOMNode*                pReadMoreNode = NULL;
    IUniformResourceLocator*    purl = NULL;
    IPersistFile*               ppf = NULL;
    HRESULT                     hr;
    TCHAR                       szShortcut[MAX_PATH];
    BSTR                        bstrURL = NULL;

    if (NULL == pxmlCatalog || HANDLE_NODE_INVALID == hItem || NULL == pszDestinationFolder)
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }

    //
    // Get <item> node in catalog
    //
    if (NULL == (pItemNode = pxmlCatalog->GetDOMNodebyHandle(hItem)))
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }
    //
    // Get node containing ReadMore URL, or S_FALSE if it doesn't exist
    //
    hr = pItemNode->selectSingleNode(KEY_READMORE, &pReadMoreNode);
    if (S_OK != hr)
    {
        if (S_FALSE != hr)
        {
            LOG_ErrorMsg(hr);
        }
        goto CleanUp;
    }

    //
    // suck out the href attribute
    //
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pReadMoreNode, KEY_HREF, &bstrURL));

    // Get pointers to the IID_IUniformResourceLocator and IID_IPersistFile interfaces
    // on the CLSID_InternetShortcut object
    CleanUpIfFailedAndSetHrMsg(CoCreateInstance(CLSID_InternetShortcut, \
                                    NULL,                               \
                                    CLSCTX_INPROC_SERVER,               \
                                    IID_IUniformResourceLocator,        \
                                    (LPVOID*)&purl));

    CleanUpIfFailedAndSetHrMsg(purl->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf));
    
    // We want to check the URL we got from the Manifest Data to make sure it is a HTTP URL, not some local file spec
    URL_COMPONENTS UrlComponents;
    // Break down the URL to get the Protocol Used
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    TCHAR       szScheme[32];
    szScheme[0] = _T('\0');
    
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszScheme       = szScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(szScheme);

    if (!InternetCrackUrl(OLE2T(bstrURL), 0, 0, &UrlComponents))
    {
        LOG_ErrorMsg(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }

    if (szScheme[0] == _T('\0') || (0 != lstrcmpi(szScheme, _T("http")) && 0 != lstrcmpi(szScheme, _T("https"))))
    {
        // If the Scheme was undeterminable, or the scheme is not HTTP then we shouldn't trust this URL.
        LOG_ErrorMsg(E_UNEXPECTED);
        goto CleanUp;
    }
    
    //
    // Set the URL, form the shortcut path, and write the link
    //
    CleanUpIfFailedAndSetHrMsg(purl->SetURL(OLE2T(bstrURL), 0));

    hr = StringCchCopyEx(szShortcut, ARRAYSIZE(szShortcut), pszDestinationFolder, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

    hr = PathCchAppend(szShortcut, ARRAYSIZE(szShortcut), IU_READMORE_LINK_NAME);
    CleanUpIfFailedAndSetHrMsg(hr);

    CleanUpIfFailedAndSetHrMsg(ppf->Save(T2OLE(szShortcut), FALSE));

CleanUp:

    SysFreeString(bstrURL);
    // pItemNode is owned by CXmlCatalog, don't release
    SafeReleaseNULL(pReadMoreNode);
    SafeReleaseNULL(ppf);
    SafeReleaseNULL(purl);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CreateItemDependencyList()
//
// If the item contains a "dependencies" node, we want to walk
// the dependendant Item List and list the proper order that installs should
// be done in. If a dependant Item is not available in the current catalog it
// will be ignored.
//
// Input:
// pxmlCatalog          - CXmlCatalog containing downloaded items
// hItem                - Handle to current download item in the catalog
// pszDestinationFolder - Folder where item is downloaded
//
// Return:
//  S_OK    - Dependency List Written
//  S_FALSE - No Dependencies Available
//  <other> - HRESULT returned from calling other functions
/////////////////////////////////////////////////////////////////////////////
HRESULT CreateItemDependencyList(CXmlCatalog* pxmlCatalog, HANDLE_NODE hItem, LPCTSTR pszDestinationFolder)
{
    HRESULT hr = S_FALSE;

    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;
    int iDependentItemOrder = 1;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwBytesWritten;
    TCHAR szFileName[MAX_PATH];
    char szWriteBuffer[MAX_PATH + 12]; // max_path is the safe length for the identitystr plus room for the order information
    BSTR bstrIdentityStr = NULL;
    BOOL fWroteItem = FALSE;
    
    USES_IU_CONVERSION;
    
    hDependentItemList = pxmlCatalog->GetFirstItemDependency(hItem, &hDependentItem);
    if (HANDLE_NODELIST_INVALID != hDependentItemList)
    {
        hr = PathCchCombine(szFileName, ARRAYSIZE(szFileName), pszDestinationFolder, _T("order.txt"));
        if (FAILED(hr))
        {
            pxmlCatalog->CloseItem(hDependentItem);
            pxmlCatalog->CloseItemList(hDependentItemList);
            return hr;
        }
        
        hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            pxmlCatalog->CloseItem(hDependentItem);
            pxmlCatalog->CloseItemList(hDependentItemList);
            return hr;
        }

        hr = S_OK;
        while (hr == S_OK)
        {
            if (HANDLE_NODELIST_INVALID != hDependentItem)
            {
                pxmlCatalog->GetIdentityStr(hDependentItem, &bstrIdentityStr);

                hr = StringCchPrintfExA(szWriteBuffer, ARRAYSIZE(szWriteBuffer), NULL, NULL, MISTSAFE_STRING_FLAGS,
                                        "%d = %s\r\n", iDependentItemOrder, OLE2A(bstrIdentityStr));
                if (FAILED(hr))
                {
                    SafeSysFreeString(bstrIdentityStr);
                    pxmlCatalog->CloseItem(hDependentItem);
                    pxmlCatalog->CloseItemList(hDependentItemList);
                    return hr;
                }
                
                WriteFile(hFile, szWriteBuffer, lstrlenA(szWriteBuffer), &dwBytesWritten, NULL); 
                iDependentItemOrder++;

                SafeSysFreeString(bstrIdentityStr);
                pxmlCatalog->CloseItem(hDependentItem);
                fWroteItem = TRUE;
            }
            hr = pxmlCatalog->GetNextItemDependency(hDependentItemList, &hDependentItem);
        }

        pxmlCatalog->CloseItemList(hDependentItemList);
        CloseHandle(hFile);
        if (!fWroteItem)
            DeleteFile(szFileName); // no dependencies written

        if (SUCCEEDED(hr))
            hr = S_OK; // convert S_FALSE to S_OK, we successfully wrote the dependencylist
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// _Download()
//
// Do synchronous downloading.
// Input:
// bstrClientName - the name of the client, for history logging use
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - bitmask indicates throttled/foreground and notification options
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT _Download(BSTR bstrClientName, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                        IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrXmlItems,
						CEngUpdate* pEngUpdate)
{
    LOG_Block("Download()");

    HRESULT     hr = S_OK;
    HRESULT     hrGlobalItemFailure = S_OK;
    LPTSTR      lpszClientInfo = NULL;
    TCHAR       szBaseDestinationFolder[MAX_PATH];
    TCHAR       szDestinationFolder[MAX_PATH];
    TCHAR       szItemPath[MAX_PATH];
    LPTSTR      pszCabUrl = NULL;
    HANDLE_NODE hCatalogItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hProviderList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hProvider = HANDLE_NODE_INVALID;
    HANDLE_NODE hXmlItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hItemCabList = HANDLE_NODELIST_INVALID;
    BSTR        bstrCabUrl = NULL;
    BSTR        bstrLocalFileName = NULL;
    BSTR        bstrProviderName = NULL;
    BSTR        bstrProviderPublisher = NULL;
    BSTR        bstrProviderUUID = NULL;
    BSTR        bstrProviderIdentityStr = NULL;
    BSTR        bstrItemPath = NULL;
    BSTR        bstrInstallerType = NULL;
    BSTR        bstrLanguage = NULL;
    BSTR        bstrPlatformDir = NULL;
    BSTR        bstrTemp = NULL;
    BSTR        bstrCRC = NULL;
    BOOL        fCabPatchAvail;
    BOOL        fReboot;
    BOOL        fExclusive;
    LONG        lCommandCount;
    LONG        lCabSize = 0;
    LPTSTR      pszLocalFileName = NULL;
    LPTSTR      pszAllocatedFileName = NULL;
    BOOL        fNTFSDriveAvailable = FALSE;
    TCHAR       szFileSystemType[12];
    TCHAR       szLargestFATDrive[4];
    int         iMaxNTFSDriveFreeSpace = 0;
    int         iMaxDriveFreeSpace = 0;
    BOOL        fCorpCase = FALSE;
    BOOL        fContinue = TRUE;   // for async mode
    BOOL        fUseSuppliedPath = FALSE;
    long        n;
    DWORD       dwBytesDownloaded = 0;
    DWORD       dwCount1, dwCount2, dwElapsedTime;
    DWORD       dwTotalElapsedTime = 0;
    DWORD       dwTotalBytesDownloaded = 0;
    DWORD       dwWaitResult;
    DWORD       dwHistoricalSpeed = 0;
    DWORD       dwHistoricalTime = 0;
    DWORD       dwSize;
    DWORD       dwRet;
    HKEY        hkeyIU = NULL;
    HANDLE      hMutex = NULL;
    DCB_DATA    CallbackData;

    {
        CXmlCatalog xmlCatalog;
        CXmlItems   xmlItemList;
		LPTSTR		ptszLivePingServerUrl = NULL;
		LPTSTR		ptszCorpPingServerUrl = NULL;
		DWORD		dwFlags = 0;

        // clear any previous cancel event
        ResetEvent(pEngUpdate->m_evtNeedToQuit);

        ZeroMemory(&CallbackData, sizeof(CallbackData));
		CallbackData.pOperationMgr = &pEngUpdate->m_OperationMgr;

        USES_IU_CONVERSION;

        CIUHistory  history;

        lpszClientInfo = OLE2T(bstrClientName);

		if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
		{
			if (FAILED(g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get live ping server URL"));
				SafeHeapFree(ptszLivePingServerUrl);
			}
		}
		else
		{
			LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
		}

		if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
		{
			if (FAILED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Out(_T("failed to get corp WU ping server URL"));
				SafeHeapFree(ptszCorpPingServerUrl);
			}
		}
		else
		{
			LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
		}

		CUrlLog pingSvr(lpszClientInfo, ptszLivePingServerUrl, ptszCorpPingServerUrl); 

		SafeHeapFree(ptszLivePingServerUrl);
		SafeHeapFree(ptszCorpPingServerUrl);

		if (FAILED(hr = g_pUrlAgent->IsClientSpecifiedByPolicy(lpszClientInfo)))
		{
            LOG_ErrorMsg(hr);
            goto CleanUp;
		}

		//
		// Set the flags for use by DownloadFile
		//
		if (S_FALSE == hr)
		{
			dwFlags = 0;
			hr = S_OK;
		}
		else // S_OK
		{
			dwFlags = WUDF_DONTALLOWPROXY;
			LOG_Internet(_T("WUDF_DONTALLOWPROXY set"));
		}

        pszCabUrl = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
        if (NULL == pszCabUrl)
        {
            dwRet = GetLastError();
            hr = HRESULT_FROM_WIN32(dwRet);
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

 
        CallbackData.bstrOperationUuid = (NULL == bstrUuidOperation) ? NULL : SysAllocString(bstrUuidOperation);
        CallbackData.hEventFiringWnd = hWnd;
        if (NULL != punkProgressListener)
        {
            // get the IProgressListener interface pointer from the IUnknown pointer.. If the 
            // interface is not supported the pProgressListener is set to NULL
            punkProgressListener->QueryInterface(IID_IProgressListener, (void**)&CallbackData.pProgressListener);
        }
        else
        {
            CallbackData.pProgressListener = NULL;
        }

        // Check for Corporate Download Handling Mode
        if ((DWORD) lMode & (DWORD) UPDATE_CORPORATE_MODE)
        {
            fCorpCase = TRUE;
        }

        // Check for Progress Notification Requested Mode
        if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_10PCT)
        {
            CallbackData.flProgressPercentage = (float).10;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_5PCT)
        {
            CallbackData.flProgressPercentage = (float).05;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_1PCT)
        {
            CallbackData.flProgressPercentage = (float).01;
        }
        else if ((DWORD) lMode & (DWORD) UPDATE_NOTIFICATION_COMPLETEONLY)
        {
            CallbackData.flProgressPercentage = (float) 1;
        }
        else
        {
            CallbackData.flProgressPercentage = 0;
        }

        if (NULL != bstrDestinationFolder && 0 < SysStringLen(bstrDestinationFolder))
        {
            if (SysStringLen(bstrDestinationFolder) > MAX_CORPORATE_PATH)
            {
                hr = E_INVALIDARG;
                LOG_ErrorMsg(hr);
                LogMessage("Catalog Download Path Greater Than (%d)", MAX_CORPORATE_PATH);
                goto CleanUp;
            }

            // Caller specified a Base Path - Set this Flag so we don't create our temp folder
            // structure under this path.
            fUseSuppliedPath = TRUE;

            //
            // user passed in a designated path, this is to signal the 
            // download-no-install case, usually for corporate site
            //

            hr = StringCchCopyEx(szBaseDestinationFolder, 
                                 ARRAYSIZE(szBaseDestinationFolder), 
                                 OLE2T(bstrDestinationFolder),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
            
            //
            // verify that we have write access to this folder
            // --- most likely it's a UNC path
            //
            DWORD dwErr = ValidateFolder(szBaseDestinationFolder, TRUE);
            if (ERROR_SUCCESS != dwErr)
            {
                LOG_ErrorMsg(dwErr);
                goto CleanUp;
            }

            //
            // Find out if this Path is a UNC
            //
            if ('\\' == szBaseDestinationFolder[0] && '\\' == szBaseDestinationFolder[1])
            {
                // correct the path to the UNC to get the available space
                hr = StringCchCopyEx(szDestinationFolder, ARRAYSIZE(szDestinationFolder),
                                     szBaseDestinationFolder, 
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }

                LPTSTR pszWalk = szDestinationFolder;
                pszWalk += 2; // skip the double slash
                pszWalk = StrChr(pszWalk, '\\'); // find the next slash (separate machine and share name)
                pszWalk += 1;
                pszWalk = StrChr(pszWalk, '\\'); // try to find the next slash (end of share name)
                if (NULL == pszWalk)
                {
                    // no trailing slash and no further path information
                    hr = PathCchAddBackslash(szDestinationFolder, ARRAYSIZE(szBaseDestinationFolder));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        goto CleanUp;
                   }
                }
                else
                {
                    // this path has a trailing slash (may have more path information, truncate after the slash)
                    pszWalk += 1;
                    *pszWalk = '\0';
                }
                GetFreeDiskSpace(szDestinationFolder, &iMaxDriveFreeSpace);
            }
            else
            {
                // path must be a local drive
                GetFreeDiskSpace(szBaseDestinationFolder[0], &iMaxDriveFreeSpace);
            }
        }
        else
        {
            //
            // user passed in NULL as the destination folder, 
            // it means this is the normal case to download and install
            // updates for this machine. we will try to find the 
            // drive with the most free space
            //
            TCHAR szDriveList[MAX_PATH];
            GetLogicalDriveStrings(MAX_PATH, szDriveList);
            LPTSTR pszCurrent = szDriveList;
            int iSize;

            //
            // find the local fixed drive with the 'most' free space
            //
            while (NULL != pszCurrent && *pszCurrent != _T('\0'))
            {
                fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                if (DRIVE_FIXED == GetDriveType(pszCurrent))
                {
                    hr = GetFreeDiskSpace(*pszCurrent, &iSize);
                    if (FAILED(hr))
                    {
                        LOG_Error(_T("Error Reading Drive Space %c, hr = 0x%08x"), *pszCurrent, hr);
                        pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
                        continue;
                    }

                    if (!GetVolumeInformation(pszCurrent, NULL, 0, NULL, NULL, NULL, szFileSystemType, ARRAYSIZE(szFileSystemType)))
                    {
                        DWORD dwErr = GetLastError();
                        LOG_Error(_T("Error Reading VolumeInfo for Drive %c, GLE = %d"), *pszCurrent, dwErr);
                        pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
                        continue;
                    }
                    if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						szFileSystemType, -1, _T("NTFS"), -1))
                    {
                        fNTFSDriveAvailable = TRUE;
                        if (iSize > iMaxNTFSDriveFreeSpace)
                        {
                            iMaxNTFSDriveFreeSpace = iSize;
                            hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), pszCurrent,
                                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
                            if (FAILED(hr))
                            {
                                LOG_ErrorMsg(hr);
                                continue;
                            }
                        }
                    }
                    else
                    {
                        // we want to keep track of non NTFS drive sizes in case there the largest
                        // NTFS drive size is too small, but a FAT partition has enough space. In this
                        // case we want to fall back to the FAT partition. Note: this is a behavior change
                        // from the initial design where we treated NTFS and FAT as mutually exclusive with
                        // NTFS always winning.
                        if (iSize > iMaxDriveFreeSpace)
                        {
                            iMaxDriveFreeSpace = iSize;
                            if (!fNTFSDriveAvailable)
                            {
                                // if no NTFS drive is available save this drive letter as the preferred
                                hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }

                                hr = StringCchCopyEx(szLargestFATDrive, ARRAYSIZE(szLargestFATDrive), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }
                                
                            }
                            else
                            {
                                // NTFS drive exists, save this drive as a back up choice for the size check.
                                hr = StringCchCopyEx(szLargestFATDrive, ARRAYSIZE(szLargestFATDrive), pszCurrent,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                                if (FAILED(hr))
                                {
                                    LOG_ErrorMsg(hr);
                                    continue;
                                }
                            }
                        }
                    }
                }
                pszCurrent += (lstrlen(pszCurrent) + 1);    // skip current and null terminater
            }

            if (!fContinue)
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }

            if ((0 == iMaxDriveFreeSpace) && (0 == iMaxNTFSDriveFreeSpace))
            {
                //
                // running on a system with no local drives?
                //
                hr = E_FAIL;
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }

        //
        // load the XML document into the XmlCatalog Class
        //
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
            goto CleanUp;
        }

        hr = xmlCatalog.LoadXMLDocument(bstrXmlCatalog, pEngUpdate->m_fOfflineMode);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        // We need to find the total estimated size of the download we're about to do.
        // We'll walk the XML Catalog getting Size Info for each item.
        hr = xmlCatalog.GetTotalEstimatedSize(&CallbackData.lTotalDownloadSize);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        CallbackData.lTotalDownloaded = 0;

        //
        // added by JHou - bug#314: download does not detect available free space on local hard drive
        //
        // The lTotalDownloadSize is the size of the download in Bytes, the MaxDriveSpace is in KBytes
        if ((CallbackData.lTotalDownloadSize / 1024) > ((fNTFSDriveAvailable) ? iMaxNTFSDriveFreeSpace : iMaxDriveFreeSpace))
        {
            // Before we bail out of the download we need to look to see if we excluded a chose a NTFS drive
            // over a FAT drive. If the NTFS drive doesn't have enough space, but a FAT drive does we want to 
            // go ahead and allow the use of the FAT drive. This is a change in spec'd behavior per bug: 413079
            if ((CallbackData.lTotalDownloadSize / 1024) < iMaxDriveFreeSpace)
            {
                // no error.. a FAT partition has enough free space, use it instead
                hr = StringCchCopyEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), szLargestFATDrive,
                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
            }
            else
            {
                // tried both NTFS and FAT partitions.. none have enough space.. bail out.
                dwRet = ERROR_DISK_FULL;
                LOG_ErrorMsg(dwRet);
                hr = HRESULT_FROM_WIN32(dwRet);
                // need to write items result information for each item indicating it failed because of diskspace
                hrGlobalItemFailure = HRESULT_FROM_WIN32(dwRet);
            }
        }

        if (SUCCEEDED(hrGlobalItemFailure))
        {
            if (!fUseSuppliedPath)
            {
                // When a destination folder is specified, we don't need to add anything to it. If no path
                // is specified we pick a drive letter, so we need to add the WUTemp directory
                // to that base path.
                hr = StringCchCatEx(szBaseDestinationFolder, ARRAYSIZE(szBaseDestinationFolder), IU_WUTEMP,
                                    NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    goto CleanUp;
                }
            }
			//
			// 500953 Allow Power Users to access WUTEMP
			//
			if (FAILED(hr = CreateDirectoryAndSetACLs(szBaseDestinationFolder, TRUE)))
			{
				LOG_ErrorMsg(hr);
				hrGlobalItemFailure = hr;
			}
			DWORD dwAttr = GetFileAttributes(szBaseDestinationFolder);
			if (INVALID_FILE_ATTRIBUTES == dwAttr || 0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr))
			{
				//
				// Only create directory if it doesn't already exist (Power Users can't
				// SetFileAttributes if an administrator created the directory originally).
				//
				if (!fUseSuppliedPath &&
					!SetFileAttributes(szBaseDestinationFolder, FILE_ATTRIBUTE_HIDDEN))
				{
					DWORD dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
					hrGlobalItemFailure = HRESULT_FROM_WIN32(dwRet);
				}
			}

#if defined(UNICODE) || defined(_UNICODE)
            LogMessage("Download destination root folder is: %ls", szBaseDestinationFolder);
#else
            LogMessage("Download destination root folder is: %s", szBaseDestinationFolder);
#endif
       
            if (fCorpCase)
            {
                history.SetDownloadBasePath(szBaseDestinationFolder);
            }
        }

        //
        // loop through each provider in the catalog, then each item in the provider
        //
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
            goto CleanUp;
        }

        hProviderList = xmlCatalog.GetFirstProvider(&hProvider);
        while (fContinue && HANDLE_NODE_INVALID != hProvider)
        {
            xmlCatalog.GetIdentity(hProvider, &bstrProviderName, &bstrProviderPublisher, &bstrProviderUUID);

            xmlCatalog.GetIdentityStr(hProvider, &bstrProviderIdentityStr);

            //
            // Get the Enumerator List of Items in this Provider, and get the first item
            //
            hCatalogItemList = xmlCatalog.GetFirstItem(hProvider, &hItem);
            if ((HANDLE_NODELIST_INVALID == hCatalogItemList) || (HANDLE_NODE_INVALID == hItem))
            {
                // No Items under this Provider
                xmlCatalog.GetNextProvider(hProviderList, &hProvider);
                continue;
            }
            while (fContinue && HANDLE_NODE_INVALID != hItem)
            {
                if (FAILED(hrGlobalItemFailure))
                {
                    xmlItemList.AddItem(&xmlCatalog, hItem, &hXmlItem);
                    bstrTemp = T2BSTR(_T(""));
                    xmlItemList.AddDownloadPath(hXmlItem, bstrTemp);
                    SafeSysFreeString(bstrTemp);
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_FAILED, /*no download path*/_T(""), lpszClientInfo, hrGlobalItemFailure);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_FAILED, hrGlobalItemFailure);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }
                LONG lCallbackRequest = 0;  // check if user set something in callback

                xmlCatalog.GetIdentityStr(hItem, &bstrItemPath);
                if (NULL == bstrItemPath)
                {
                    LOG_Download(_T("Failed to Get Identity String for an Item"));
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }

                //
                // send out status to caller to tell which item we are about to download
                //
                BSTR bstrXmlItemForCallback = NULL;
                if (SUCCEEDED(xmlCatalog.GetBSTRItemForCallback(hItem, &bstrXmlItemForCallback)))
                {
                    CallbackData.lCurrentItemSize = 0;
                    DownloadCallback(&CallbackData, 
                                     DOWNLOAD_STATUS_ITEMSTART, 
                                     0,
                                     0, 
                                     bstrXmlItemForCallback, 
                                     &lCallbackRequest);
                    SafeSysFreeString(bstrXmlItemForCallback);
                    bstrXmlItemForCallback = NULL;
                    if (UPDATE_COMMAND_CANCEL == lCallbackRequest)
                    {
						LOG_Out(_T("Download Callback received UPDATE_COMMAND_CANCEL"));
                        SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
                        fContinue = FALSE;
                    }
                    else
                    {
                        //
                        // check the global quit event. If quit, then server ping treat it as a cancel.
                        //
                        fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                    }
                    if (!fContinue)
                    {
                        continue;   // or break, same effect.
                    }
                }
                else
                {
                    //
                    // something wrong with this item, so we should skip it
                    //
                    continue;
                }

                if (fCorpCase)
                {
                    LPCTSTR szName = NULL;
                    
                    // Corporate Folder Path is Constructed from Several Item Elements
                    // Software | Driver\<Locale>\<ProviderIdentity>\<Platform>\<ItemIdentity>.<version>
                    xmlCatalog.GetItemInstallInfo(hItem, &bstrInstallerType, &fExclusive, &fReboot, &lCommandCount);
                    if (NULL == bstrInstallerType)
                    {
                        LOG_Download(_T("Missing InstallerType Info for Item %ls"), bstrItemPath);
                        goto doneCorpCase;
                    }

                    if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						(LPCWSTR)bstrInstallerType, -1, L"CDM", -1))
                    {
                        szName = _T("Driver");
                    }
                    else
                    {
                        szName = _T("Software");
                    }

                    hr = StringCchCopyEx(szItemPath, ARRAYSIZE(szItemPath), szName, NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                        goto doneCorpCase;

                    xmlCatalog.GetItemLanguage(hItem, &bstrLanguage);
                    xmlCatalog.GetCorpItemPlatformStr(hItem, &bstrPlatformDir);
                    if (NULL == bstrLanguage || NULL == bstrPlatformDir)
                    {
                        LOG_Download(_T("Missing Language or Platform Info for Item %ls"), bstrItemPath);
                        goto doneCorpCase;
                    }
                
                    hr = PathCchCombine(szDestinationFolder, ARRAYSIZE(szDestinationFolder), szBaseDestinationFolder, szItemPath);
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrLanguage));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrProviderIdentityStr));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrPlatformDir));
                    if (FAILED(hr))
                        goto doneCorpCase;
                    
                    hr = PathCchAppend(szDestinationFolder, ARRAYSIZE(szDestinationFolder), OLE2T(bstrItemPath));
                    if (FAILED(hr))
                        goto doneCorpCase;
doneCorpCase:
                    SafeSysFreeString(bstrInstallerType);
                    SafeSysFreeString(bstrLanguage);
                    SafeSysFreeString(bstrPlatformDir);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        SafeSysFreeString(bstrItemPath);
                        xmlCatalog.CloseItem(hItem);
                        xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                        continue;
                    }
                }
                else
                {
                    hr = PathCchCombine(szDestinationFolder, ARRAYSIZE(szDestinationFolder), szBaseDestinationFolder, OLE2T(bstrItemPath));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        SafeSysFreeString(bstrItemPath);
                        xmlCatalog.CloseItem(hItem);
                        xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                        continue;
                    }
                }

                if (FAILED(hr = CreateDirectoryAndSetACLs(szDestinationFolder, TRUE)))
				{
					LOG_ErrorMsg(hr);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
					SafeSysFreeString(bstrItemPath);
					continue;
				}

                //
                // Now get the collection of CodeBases for this Item
                //
                hItemCabList = xmlCatalog.GetItemFirstCodeBase(hItem, &bstrCabUrl, &bstrLocalFileName, &bstrCRC, &fCabPatchAvail, &lCabSize);
                if ((HANDLE_NODELIST_INVALID == hItemCabList) || (NULL == bstrCabUrl))
                {
                    // No Cabs for this Item?? skip it.
                    LOG_Download(_T("Item: %ls has no cabs, Skipping"), bstrItemPath);
                    SafeSysFreeString(bstrItemPath);
                    xmlCatalog.CloseItem(hItem);
                    xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                    continue;
                }

                while (fContinue && NULL != bstrCabUrl)
                {
                    LPTSTR pszTempCabUrl = OLE2T(bstrCabUrl);

                    // pszCabUrl is allocated to be INTERNET_MAX_URL_LENGTH above.
                    hr = StringCchCopyEx(pszCabUrl, INTERNET_MAX_URL_LENGTH, pszTempCabUrl, 
                                         NULL, NULL, MISTSAFE_STRING_FLAGS);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                 
                    SafeMemFree(pszTempCabUrl);
                    
                    if (NULL != bstrLocalFileName && SysStringLen(bstrLocalFileName) > 0)
                    {
                        if (NULL != pszAllocatedFileName)
                        {
                            MemFree(pszAllocatedFileName);
                        }
                        pszAllocatedFileName = OLE2T(bstrLocalFileName);
                    }
                    else
                    {
                        //
                        // has not specified file name, use the same file name in URL
                        //
                        // search for the last forward slash (will separate the URL from the filename)
                        LPTSTR lpszLastSlash = StrRChr(pszCabUrl, NULL, _T('/'));
                        if (NULL != lpszLastSlash)
                        {
                            // last slash was found, skip to next character (will be the beginning of the filename)
                            lpszLastSlash++;
                        }
                        pszLocalFileName = lpszLastSlash;
                    }
                    // Download the Cab - Store Information for Progress Callbacks

                    dwBytesDownloaded = 0;
                    CallbackData.lCurrentItemSize = lCabSize;
                    dwCount1 = GetTickCount();
                    hr = DownloadFile(pszCabUrl, // fileurl to download
                                      szDestinationFolder, // destination folder for file
                                      (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName, // use AllocatedFileName if possible, else use localfilename
                                      &dwBytesDownloaded, // bytes downloaded for this file
                                      &pEngUpdate->m_evtNeedToQuit,  // quit event array
                                      1,  // number of events
                                      DownloadCallback, // callback function
                                      &CallbackData, // data structure for callback function
                                      dwFlags);
                    if (FAILED(hr))
                    {
                        //
                        // added by JHou: bug335292 - Temporary folder not deleted when network plug removed
                        //
                        // only empty folder can be deleted successfully so if RemoveDirectory() failed that
                        // may because it's not empty which means it's ok
                        if (RemoveDirectory(szDestinationFolder) && fCorpCase)
                        {
                            HRESULT hrCopy;
                            // If this Directory was successfully removed and this is the Corp Case we should
                            // try to remove its parents up to the base directory.
                            TCHAR szCorpDestinationFolderRemove[MAX_PATH];
                            
                            hrCopy = StringCchCopyEx(szCorpDestinationFolderRemove,
                                                     ARRAYSIZE(szCorpDestinationFolderRemove),
                                                     szDestinationFolder,
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS);
                            if (FAILED(hrCopy))
                            {
                                LOG_ErrorMsg(hrCopy);
                                break;
                            }
                            
                            LPTSTR pszBackslash = NULL;
                            PathRemoveBackslash(szBaseDestinationFolder); // strip any trailing backslashes - need to normalize this to compare when we're done walking the folder tree
                            for (;;)
                            {
                                pszBackslash = StrRChr(szCorpDestinationFolderRemove, NULL, '\\');
                                if (NULL == pszBackslash)
                                    break; // unexpected
                                *pszBackslash = '\0';
                                if (0 == StrCmp(szCorpDestinationFolderRemove, szBaseDestinationFolder))
                                    break; // reached the base directory, done removing directories;
                                if (!RemoveDirectory(szCorpDestinationFolderRemove))
                                    break; // couldn't remove folder at this level, assume folder not empty, leave the rest of the structure intact.
                            }
                        }

                        if (E_ABORT == hr)
                        {
                            LOG_Download(_T("DownloadFile function returns E_ABORT while downloading %s."), pszCabUrl);
#if defined(UNICODE) || defined(_UNICODE)
                            LogError(hr, "Download cancelled while processing file %ls", pszCabUrl);
#else
                            LogError(hr, "Download cancelled while processing file %s", pszCabUrl);
#endif
                        }
                        else
                        {
                            LOG_Download(_T("Download Failed for URL: %s, Skipping remaining files for this Item"), pszCabUrl);
#if defined(UNICODE) || defined(_UNICODE)
                            LogError(hr, "Downloading file %ls, skipping remaining files for this Item", pszCabUrl);
#else
                            LogError(hr, "Downloading file %s, skipping remaining files for this Item", pszCabUrl);
#endif
                        }
                        SafeSysFreeString(bstrCabUrl);
                        //
                        // since one file got error, we can exit the file loop for the current item
                        // because missing one file will make this item not usable.
                        //
                        break;  
                    }
                    dwCount2 = GetTickCount();
                    if (0 != dwBytesDownloaded)
                    {
                        if (dwCount1 < dwCount2) // normal case, no roll-over
                        {
                            dwElapsedTime = dwCount2 - dwCount1;
                        }
                        else
                        {
                            // roll-over case, should almost never happen
                            dwElapsedTime = (0xFFFFFFFF - dwCount1) + dwCount2;
                        }

                        dwTotalBytesDownloaded += dwBytesDownloaded;
                        dwTotalElapsedTime += dwElapsedTime;
                    }

                    // Form the full Path and Filename of the file we just downloaded
                    hr = PathCchCombine(szItemPath, ARRAYSIZE(szItemPath), szDestinationFolder, 
                                                     (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName);
                    if (FAILED(hr))
                    {
                        DeleteFile(szItemPath);
                        break;
                    }
                    
                    // Verify CRC
                    //---------------
                    if (NULL != bstrCRC)
                    {
                        TCHAR szCRCHash[CRC_HASH_STRING_LENGTH] = {'\0'};
                        hr = StringCchCopyEx(szCRCHash, ARRAYSIZE(szCRCHash), OLE2T(bstrCRC), NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hr))
                        {
                            // Something was wrong with the BSTR we got back from XML. Fail Safely, delete the file.
                            // The Failed HR will fail the item
                            DeleteFile(szItemPath);
                            break;
                        }
                        hr = VerifyFileCRC(szItemPath, szCRCHash);
                        if (HRESULT_FROM_WIN32(ERROR_CRC) == hr || FAILED(hr))
                        {
                            // The File CRC's Did Not Match, or we had a problem Calculating the CRC. Fail Safely, delete the file.
                            // The Failed HR will fail the item
                            DeleteFile(szItemPath);
                            break;
                        }
                    }

                    // Check Trust
                    //---------------
                    hr = VerifyFileTrust(szItemPath, 
                                         NULL, 
                                         ReadWUPolicyShowTrustUI()
                                         );
                    if (FAILED(hr))
                    {
                        // File Was Not Trusted - Need to Delete it and fail the item
                        DeleteFile(szItemPath);
                        break;
                    }

#if defined(UNICODE) || defined(_UNICODE)
                    LogMessage("Downloaded file %ls", pszCabUrl);
                    LogMessage("Local path %ls", szItemPath);
#else
                    LogMessage("Downloaded file %s", pszCabUrl);
                    LogMessage("Local path %s", szItemPath);
#endif

                    SafeSysFreeString(bstrCabUrl);
                    SafeSysFreeString(bstrLocalFileName);
                    SafeSysFreeString(bstrCRC);
                    bstrCabUrl = bstrLocalFileName = NULL;
                    fContinue = SUCCEEDED(xmlCatalog.GetItemNextCodeBase(hItemCabList, &bstrCabUrl, &bstrLocalFileName, &bstrCRC, &fCabPatchAvail, &lCabSize)) &&
                                (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                }

 
                // Write XMLItems entry for this download result
                xmlItemList.AddItem(&xmlCatalog, hItem, &hXmlItem);
                bstrTemp = T2BSTR(szDestinationFolder);
                xmlItemList.AddDownloadPath(hXmlItem, bstrTemp);
                SafeSysFreeString(bstrTemp);

                //
                // For "corporate" download write ReadMore Link before writing history (in case we fail
                //
                if (TRUE == fCorpCase)
                {
                    //
                    // Ignore errors as we want to keep downloaded cab anyway
                    //
                    (void) CreateReadMoreLink(&xmlCatalog, hItem, szDestinationFolder);
                    (void) CreateItemDependencyList(&xmlCatalog, hItem, szDestinationFolder);
                }

                //
                // Also add download history for this item
                //
                if (SUCCEEDED(hr))
                {
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, szDestinationFolder, lpszClientInfo);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_COMPLETE);
                }
                else
                {
                    history.AddHistoryItemDownloadStatus(&xmlCatalog, hItem, HISTORY_STATUS_FAILED, szDestinationFolder, lpszClientInfo, hr);
                    xmlItemList.AddDownloadStatus(hXmlItem, KEY_STATUS_FAILED, hr);
                }

                //
                // ping server to report the download status for this item
                //
                {
                    BSTR bstrIdentityPing = NULL;
                    if (SUCCEEDED(xmlCatalog.GetIdentityStrForPing(hItem, &bstrIdentityPing)))
                    {
						URLLOGSTATUS status = SUCCEEDED(hr) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed;
                        if (E_ABORT == hr)
                        {
                            //
                            // user/system cancelled the current process
                            //
							status = URLLOGSTATUS_Cancelled;
                        }
                        pingSvr.Ping(
									TRUE,						// on-line
									URLLOGDESTINATION_DEFAULT,	// going live or corp WU ping server
									&pEngUpdate->m_evtNeedToQuit,			// pt to cancel events
									1,							// number of events
									URLLOGACTIVITY_Download,	// activity
									status,						// status code
									hr,							// error code, can be 0 or 1
									OLE2T(bstrIdentityPing),	// itemID
									NULL						// no device data can be given during dld phase
									);
                    }

                    SafeSysFreeString(bstrIdentityPing);
                    //SafeSysFreeString(bstrPlatformPing);
                    //SafeSysFreeString(bstrLanguagePing);
                }

                xmlCatalog.CloseItemList(hItemCabList);

                //
                // done with this item, fire itemcomplete event
                //
                DownloadCallback(&CallbackData, DOWNLOAD_STATUS_ITEMCOMPLETE, CallbackData.lCurrentItemSize, 0, NULL, &lCallbackRequest);

                SafeSysFreeString(bstrItemPath);
                // get the next item. hItem will be HANDLE_NODE_INVALID when there are no
                // remaining items.
                xmlCatalog.CloseItem(hItem);
                xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                if (UPDATE_COMMAND_CANCEL == lCallbackRequest)
                {
					LOG_Out(_T("Download Callback received UPDATE_COMMAND_CANCEL"));
                    SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
                    fContinue = FALSE;
                }
                else
                {
                    //
                    // check the global quit event. If quit, then server ping treat it as a cancel.
                    // TODO: also need to check the operation quit event!
                    //
                    fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                }
            }

            xmlCatalog.CloseItemList(hCatalogItemList);

            SafeSysFreeString(bstrProviderName);
            SafeSysFreeString(bstrProviderPublisher);
            SafeSysFreeString(bstrProviderUUID);
            SafeSysFreeString(bstrProviderIdentityStr);
            xmlCatalog.CloseItem(hProvider);
            xmlCatalog.GetNextProvider(hProviderList, &hProvider);
            fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
        }

        xmlCatalog.CloseItemList(hProviderList);

        RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkeyIU);
        hMutex = CreateMutex(NULL, FALSE, IU_MUTEX_HISTORICALSPEED_REGUPDATE);


        if ((0 != dwTotalBytesDownloaded) && (0 != dwTotalElapsedTime) && (NULL != hkeyIU) && (NULL != hMutex))
        {
			HANDLE aHandles[2];

			aHandles[0] = hMutex;
			aHandles[1] = pEngUpdate->m_evtNeedToQuit;

            dwWaitResult = MyMsgWaitForMultipleObjects(ARRAYSIZE(aHandles), aHandles, FALSE, /*30 seconds*/30000, QS_ALLINPUT);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                // convert elapsed time from milliseconds to seconds
                dwTotalElapsedTime = dwTotalElapsedTime / 1000;
                if (0 == dwTotalElapsedTime)
                    dwTotalElapsedTime = 1; // minimum one second

                // we have the mutex, go ahead and read/write the reg information.  
                dwSize = sizeof(dwHistoricalSpeed);
                RegQueryValueEx(hkeyIU, REGVAL_HISTORICALSPEED, NULL, NULL, (LPBYTE)&dwHistoricalSpeed, &dwSize);
                dwSize = sizeof(dwHistoricalTime);
                RegQueryValueEx(hkeyIU, REGVAL_TIMEELAPSED, NULL, NULL, (LPBYTE)&dwHistoricalTime, &dwSize);

                // We need to get the Bytes Downloaded to add the bytes just downloaded
                DWORD dwHistoricalBytes = dwHistoricalSpeed * dwHistoricalTime; // could be 0 if no previous history was recorded
                dwHistoricalBytes += dwTotalBytesDownloaded; // new byte count
                dwHistoricalTime += dwTotalElapsedTime; // new time count
                dwHistoricalSpeed = dwHistoricalBytes / dwHistoricalTime; // calculate new speed bytes/second
                RegSetValueEx(hkeyIU, REGVAL_HISTORICALSPEED, NULL, REG_DWORD, (LPBYTE)&dwHistoricalSpeed, sizeof(dwHistoricalSpeed));
                RegSetValueEx(hkeyIU, REGVAL_TIMEELAPSED, NULL, REG_DWORD, (LPBYTE)&dwHistoricalTime, sizeof(dwHistoricalTime));
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
                hMutex = NULL;
            }
        }

		//
		// We pass in pEngUpdate->m_evtNeedToQuit to MyMsgWaitForMultipleObjects above so it will exit immediately
		// but don't bother to handle the WAIT_OBJECT_0 + 1 case there since the if statement may not
		// execute and even if this is the case we still need to check pEngUpdate->m_evtNeedToQuit below anyway.
		//
        if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
        {
            hr = E_ABORT;
        }

CleanUp:

        //
        // add HRESULT in case the download failed before the download loop
        //
        if (S_OK != hr)
        {
            xmlItemList.AddGlobalErrorCodeIfNoItems(hr);
        }

        //
        // generate result
        //
        xmlItemList.GetItemsBSTR(pbstrXmlItems);

        SafeSysFreeString(CallbackData.bstrOperationUuid);
    
        SafeHeapFree(pszCabUrl);

        SafeSysFreeString(bstrCabUrl);
        SafeSysFreeString(bstrLocalFileName);
        SafeSysFreeString(bstrProviderName);
        SafeSysFreeString(bstrProviderPublisher);
        SafeSysFreeString(bstrProviderUUID);
        SafeSysFreeString(bstrProviderIdentityStr);
        SafeSysFreeString(bstrItemPath);
        SafeSysFreeString(bstrInstallerType);
        SafeSysFreeString(bstrLanguage);
        SafeSysFreeString(bstrPlatformDir);
        SafeSysFreeString(bstrTemp);

        if (NULL != hkeyIU)
        {
            RegCloseKey(hkeyIU);
            hkeyIU = NULL;
        }

        if (NULL != hMutex)
        {
            // shouldn't need to release, if hmutex is still valid at this point we were unable to 
            // get the mutex 
            CloseHandle(hMutex);
            hMutex = NULL;
        }
    }

    //
    // notify that we are completed
    //
    if (NULL != punkProgressListener || NULL != hWnd)
    {
        DownloadCallback(&CallbackData, DOWNLOAD_STATUS_OPERATIONCOMPLETE, 0, 0, *pbstrXmlItems, NULL); 
    }

    if (SUCCEEDED(hr))
    {
        LogMessage("%s %s", SZ_SEE_IUHIST, SZ_DOWNLOAD_FINISHED);
    }
    else
    {
        LogError(hr, "%s %s", SZ_SEE_IUHIST, SZ_DOWNLOAD_FINISHED);
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// Download()
//
// Do synchronous downloading.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - bitmask indicates throttled/foreground and notification options
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with download status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" downloaded="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Download(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                        IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems)
{
    CXmlClientInfo clientInfo;
    BSTR bstrClientName = NULL;

    HRESULT hr;

    LOG_Block("Download()");

    LogMessage("Download started");

    hr = clientInfo.LoadXMLDocument(bstrXmlClientInfo, m_fOfflineMode);
    CleanUpIfFailedAndMsg(hr);

    hr = clientInfo.GetClientName(&bstrClientName);
    CleanUpIfFailedAndMsg(hr);

    hr = _Download(
                    bstrClientName, 
                    bstrXmlCatalog, 
                    bstrDestinationFolder, 
                    lMode, 
                    punkProgressListener, 
                    hWnd, 
                    NULL,                   // no op id needed for sync download
                    pbstrXmlItems,
					this);

CleanUp:

    SysFreeString(bstrClientName);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadAsync()
//
// Download asynchronously -  the method will return before completion.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlCatalog - the xml catalog portion containing items to be downloaded
// bstrDestinationFolder - the destination folder. Null will use the default IU folder
// lMode - indicates throttled or fore-ground downloading mode
// punkProgressListener - the callback function pointer for reporting download progress
// hWnd - the event msg window handler passed from the stub
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID,
//                      in which case, the caller will be responsible to free the memory of
//                      the string buffer that holds the generated UUID using SysFreeString(). 
//                      Otherwise, it returns the value passed by bstrUuidOperation.        
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::DownloadAsync(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
                             IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation)
{
    HRESULT  hr = S_OK;
    BSTR     bstrClientName = NULL;
    DWORD    dwThreadId = 0x0;
    DWORD    dwErr = 0x0;
    HANDLE   hThread = NULL;
    GUID     guid;
    LPWSTR   lpswClientInfo = NULL;
    LPOLESTR pwszUuidOperation = NULL;
    PIUDOWNLOADSTARTUPINFO pStartupInfo = NULL;
    HANDLE   hHeap = GetProcessHeap();
    CXmlClientInfo clientInfo;

    LOG_Block("DownloadAsync()");

    LogMessage("Asynchronous Download started");

    USES_IU_CONVERSION;

    //
    // validate parameters:
    //  if no catalog, or no return var, or no client info, this function can do nothing.
    //
    if ((NULL == bstrXmlCatalog) ||
        (NULL == bstrXmlClientInfo) ||
        (SysStringLen(bstrXmlCatalog) == 0) ||
        (SysStringLen(bstrXmlClientInfo) == 0))
    {
        hr = E_INVALIDARG;
        CleanUpIfFailedAndMsg(hr);
    }

    //
    // validate the client info
    //
    hr = clientInfo.LoadXMLDocument(bstrXmlClientInfo, m_fOfflineMode);
    CleanUpIfFailedAndMsg(hr);

    hr = clientInfo.GetClientName(&bstrClientName);
    CleanUpIfFailedAndMsg(hr);

    if (NULL == (pStartupInfo = (PIUDOWNLOADSTARTUPINFO) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(IUDOWNLOADSTARTUPINFO))))
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    pStartupInfo->bstrClientName = SysAllocString(bstrClientName);
    pStartupInfo->bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
    pStartupInfo->hwnd = hWnd;
    pStartupInfo->lMode = lMode;
    pStartupInfo->punkProgressListener = punkProgressListener;
	pStartupInfo->pEngUpdate = this;
    if (NULL != bstrDestinationFolder && SysStringLen(bstrDestinationFolder) > 0)
    {
        LOG_Download(_T("Caller specified destination folder=%s"), OLE2T(bstrDestinationFolder));
        pStartupInfo->bstrDestinationFolder = SysAllocString(bstrDestinationFolder);
    }

    //
    // session id is required for download operation
    //
    if (NULL != bstrUuidOperation && SysStringLen(bstrUuidOperation) > 0)
    {
        LOG_Download(_T("User passed in UUID %s"), OLE2T(bstrUuidOperation));
        pStartupInfo->bstrUuidOperation = SysAllocString(bstrUuidOperation);
        if (NULL != pbstrUuidOperation)
        {
            *pbstrUuidOperation = SysAllocString(bstrUuidOperation);
        }
    }
    else
    {
        //
        // if user doesn't have an operation id, we generate one
        //
        hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        hr = StringFromCLSID(guid, &pwszUuidOperation);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        pStartupInfo->bstrUuidOperation = SysAllocString(pwszUuidOperation);
        if (NULL != pbstrUuidOperation)
        {
            *pbstrUuidOperation = SysAllocString(pwszUuidOperation);
        }
        LOG_Download(_T("UUID generated %s"), OLE2T(pwszUuidOperation));
        CoTaskMemFree(pwszUuidOperation);
    }
    

    InterlockedIncrement(&m_lThreadCounter);
	if (NULL != pStartupInfo->punkProgressListener)
	{
		//
		// since this is an async operation, to prevent caller free this object after 
		// this call returns, we pump up ref count here. The thread proc will 
		// release refcount after it finishes the work
		//
		pStartupInfo->punkProgressListener->AddRef();
	}

    hThread = CreateThread(NULL, 0, DownloadThreadProc, (LPVOID)pStartupInfo, 0, &dwThreadId);
    
    if (NULL == hThread)
    {
        //
        // clean up allocated strings in pStartupInfo.
        //
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        LOG_ErrorMsg(hr);
		SafeRelease(pStartupInfo->punkProgressListener);
        InterlockedDecrement(&m_lThreadCounter);
    }
    else
    {
        LOG_Download(_T("Download thread generated successfully"));
    }

CleanUp:
    if (FAILED(hr))
    {
        LogError(hr, "Asynchronous Download failed during startup");

        if (NULL != pStartupInfo)
        {
            SysFreeString(pStartupInfo->bstrDestinationFolder);
            SysFreeString(pStartupInfo->bstrXmlCatalog);
            SysFreeString(pStartupInfo->bstrClientName);
            SysFreeString(pStartupInfo->bstrUuidOperation);
            HeapFree(hHeap, 0, pStartupInfo);
        }
    }

    SysFreeString(bstrClientName);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DownloadCallback()
//
// Callback Function to recieve progress from IU Downloader. 
// 
// Input:
// pCallbackData - void pointer to DCB_DATA structure
// dwStatus - Current Download Status
// dwBytesTotal - Total Bytes of File being Downloaded
// dwBytesComplete - Bytes Downloaded so far
// bstrCompleteResult - Contains Item Result XML
//
// Output:
// plCommandRequest - Used to Instruct the Downloader to continue, abort, suspend...
//
// Return:
// 0 - always, exit code is irrelevant since calling thread doesn't check the
// status of this thread after creation.
/////////////////////////////////////////////////////////////////////////////
BOOL WINAPI DownloadCallback(VOID* pCallbackData, DWORD dwStatus, DWORD dwBytesTotal, DWORD dwBlockSizeDownloaded, BSTR bstrXmlData, LONG* plCommandRequest)
{
    LOG_Block("DownloadCallback()");

    HRESULT hr;
    LONG lUpdateMask = 0;
    float flNewPercentage;
    EventData evtData;
    char szProgressSize[64] = {'\0'};
    BOOL fPostWaitSuccess = TRUE;
    ZeroMemory((LPVOID) &evtData, sizeof(evtData));

    USES_IU_CONVERSION;

    P_DCB_DATA pCallbackParam = (P_DCB_DATA) pCallbackData;

    if (NULL != pCallbackParam->bstrOperationUuid)
    {
        evtData.bstrUuidOperation = SysAllocString(pCallbackParam->bstrOperationUuid);
        LOG_Download(_T("Found UUID=%s"), OLE2T(evtData.bstrUuidOperation));
    }

    if (dwBytesTotal != pCallbackParam->lCurrentItemSize && DOWNLOAD_STATUS_ITEMCOMPLETE != dwStatus)
    {
        pCallbackParam->lTotalDownloadSize = (pCallbackParam->lTotalDownloadSize - pCallbackParam->lCurrentItemSize) + dwBytesTotal;
        pCallbackParam->lCurrentItemSize = dwBytesTotal;
    }

    // Keep the Total Downloaded Bytes Counter
    if (0 != dwBlockSizeDownloaded && DOWNLOAD_STATUS_ITEMCOMPLETE != dwStatus)
        pCallbackParam->lTotalDownloaded += dwBlockSizeDownloaded;

    LOG_Download(_T("dwStatus=0x%08x"), dwStatus);

    //
    // if the Status is DOWNLOAD_STATUS_FILECOMPLETE we are done with this File
    //
    evtData.fItemCompleted = (dwStatus == DOWNLOAD_STATUS_ITEMCOMPLETE);

    switch (dwStatus)
    {
    case DOWNLOAD_STATUS_ITEMSTART:

        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnItemStart(pCallbackParam->bstrOperationUuid, 
                bstrXmlData, &evtData.lCommandRequest);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd)
            {
                evtData.bstrXmlData = bstrXmlData;
                SendMessage(pCallbackParam->hEventFiringWnd, UM_EVENT_ITEMSTART, 0, LPARAM(&evtData));
                evtData.bstrXmlData = NULL;
            }
        }


        break;

    case DOWNLOAD_STATUS_OK:    // simple progress update
    case DOWNLOAD_STATUS_ITEMCOMPLETE:
        if (0 != pCallbackParam->flProgressPercentage)
        {
            // we need to give progress callbacks on given percentage increments
            flNewPercentage = ((float)pCallbackParam->lTotalDownloaded / pCallbackParam->lTotalDownloadSize);
            if (((flNewPercentage - pCallbackParam->flLastPercentage) >= pCallbackParam->flProgressPercentage) ||
                ((1.0 - flNewPercentage) < 0.0001 && 1 != pCallbackParam->flProgressPercentage))
            {
                // The Difference between LastPercentComplete and CurrentPercentComplete complies with the 
                // Progress Percentage granuluarity OR the percentage is 100 (complete)
                if (evtData.fItemCompleted)
                {
                    //wsprintfA(szProgressSize, "%d", (int)flNewPercentage); // float should be 1.0, cast as int will be 1
                    //
                    // when we notify the user this "item", not file, completed, we don't need
                    // to pass out any percentage info.
                    //
                    szProgressSize[0] = _T('\0');
                }
                else
                {
                    if ((1.0 - flNewPercentage) < 0.0001)
                    {
                        if (ARRAYSIZE(szProgressSize) >= 2)
                        {
                            szProgressSize[0] = _T('1');
                            szProgressSize[1] = _T('\0');
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        hr = StringCchPrintfExA(szProgressSize, ARRAYSIZE(szProgressSize),
                                                NULL, NULL, MISTSAFE_STRING_FLAGS,
                                                ".%02d", (int)(flNewPercentage*100)); // string equivilant of a float
                        if (FAILED(hr))
                        {
                            LOG_ErrorMsg(hr);
                            break;
                        }
                    }
                }
                pCallbackParam->flLastPercentage = flNewPercentage;
            }
            else
            {
                // don't make a callback
                break;
            }
        }
        else
        {
            // No percentage callback was requested.. just give the byte values.
            if (dwStatus == DOWNLOAD_STATUS_ITEMCOMPLETE)
            {
                szProgressSize[0] = _T('\0');
            }
            else
            {
                hr = StringCchPrintfExA(szProgressSize, ARRAYSIZE(szProgressSize),
                                        NULL, NULL, MISTSAFE_STRING_FLAGS,
                                        "%lu:%lu", (ULONG)pCallbackParam->lTotalDownloadSize, (ULONG)pCallbackParam->lTotalDownloaded);
                if (FAILED(hr))
                {
                    LOG_ErrorMsg(hr);
                    break;
                }
            }
        }
        evtData.bstrProgress = SysAllocString(A2OLE(szProgressSize));
        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnProgress(pCallbackParam->bstrOperationUuid, 
                evtData.fItemCompleted, evtData.bstrProgress, &evtData.lCommandRequest);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd)
            {
                SendMessage(pCallbackParam->hEventFiringWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
            }
        }
        break;

    case DOWNLOAD_STATUS_OPERATIONCOMPLETE:
        if (NULL != pCallbackParam->pProgressListener)
        {
            pCallbackParam->pProgressListener->OnOperationComplete(pCallbackParam->bstrOperationUuid,
                bstrXmlData);
        }
        else
        {
            // only use event window if no progresslistener interface was given
            if (NULL != pCallbackParam->hEventFiringWnd) 
            {
                evtData.bstrXmlData = bstrXmlData;
                fPostWaitSuccess = WUPostEventAndBlock(pCallbackParam->hEventFiringWnd, 
                                                       UM_EVENT_COMPLETE, 
                                                       &evtData);
            }
        }

        // Look for an existing Operation in the Mgr, and update the Complete Result if available.
        if (pCallbackParam->pOperationMgr->FindOperation(OLE2T(pCallbackParam->bstrOperationUuid), &lUpdateMask, NULL))
        {
            pCallbackParam->pOperationMgr->UpdateOperation(OLE2T(pCallbackParam->bstrOperationUuid), lUpdateMask, bstrXmlData);
        }
        break;
    case DOWNLOAD_STATUS_ABORTED:
    case DOWNLOAD_STATUS_ERROR:
        //
        // abort case: user should know. nothing to report
        // error case: progress callback doesn't give us any way of telling the caller that its an error, no reason to send the callback
        // the itemcomplete callback will have the error status for the item.
        //
        break;
    }
    
    if (NULL != plCommandRequest) // we made a callback and the command request value was retrieved
    {
        *plCommandRequest = (LONG)((DWORD) evtData.lCommandRequest & (DWORD) UPDATE_COMMAND);
        LOG_Download(_T("Command returned: 0x%08x"), *plCommandRequest);
    }

    // don't free up the strings below unless the wait succeeded in 
    //  WUPostEventAndBlock.  If we do free the strings up and the wait didn't
    //  succeed, then we run the risk of AVing ourselves.  Note that fPostWaitSuccess
    //  is initialized to TRUE so if we will free these BSTRs if WUPostEventAndBlock
    //  is not called.
    if (fPostWaitSuccess)
    {
        SysFreeString(evtData.bstrProgress);
        SysFreeString(evtData.bstrUuidOperation);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadThreadProc()
//
// Thread Proc for Async Download. Retrieves the startup information from
// the input param and calls Download() from this seperate thread. The calling
// thread returns immediately.
// 
// Input:
// lpv - void pointer to IUDOWNLOADSTARTINFO struct containing all information
//       needed to call Download()
//
// Return:
// 0 - always, exit code is irrelevant since calling thread doesn't check the
// status of this thread after creation.
/////////////////////////////////////////////////////////////////////////////
DWORD WINAPI DownloadThreadProc(LPVOID lpv)
{
    LOG_Block("DownloadThreadProc()");
    //
    // in this new thread need to call CoInitialize again
    // but since we don't know who the caller is, what threading they
    // are using, so we just use single apartment
    //
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        LogError(hr, "Asynchronous Download thread exiting");
        LOG_ErrorMsg(hr);
        return 0;
    }
    LOG_Download(_T("CoInitialize called successfully"));

    PIUDOWNLOADSTARTUPINFO pStartupInfo = (PIUDOWNLOADSTARTUPINFO)lpv;
    BSTR bstrXmlItems = NULL;

    LOG_Download(_T("Download thread started, now the thread count=%d"), pStartupInfo->pEngUpdate->m_lThreadCounter);

    //
    // call synchronized download function in this thread
    //
    _Download(
        pStartupInfo->bstrClientName, 
        pStartupInfo->bstrXmlCatalog, 
        pStartupInfo->bstrDestinationFolder, 
        pStartupInfo->lMode, 
        pStartupInfo->punkProgressListener, 
        pStartupInfo->hwnd, 
        pStartupInfo->bstrUuidOperation,
        &bstrXmlItems,
		pStartupInfo->pEngUpdate);
    
    //
    // pStartupInfo is a buffer allocated by calling thread, when we are done, we need to 
    // free it here
    //
    SysFreeString(pStartupInfo->bstrDestinationFolder);
    SysFreeString(pStartupInfo->bstrXmlCatalog);
    SysFreeString(pStartupInfo->bstrClientName);
    SysFreeString(pStartupInfo->bstrUuidOperation);
    SysFreeString(bstrXmlItems);
	SafeRelease(pStartupInfo->punkProgressListener);		// so the caller can free this object

    CoUninitialize();
    LOG_Download(_T("CoUninitialize called"));

    InterlockedDecrement(&(pStartupInfo->pEngUpdate->m_lThreadCounter));

    HeapFree(GetProcessHeap(), 0, pStartupInfo);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\engmain.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   engmain.cpp
//
//  Description:
//
//      DllMain and globals for the IUEngine DLL
//
//=======================================================================

#include "iuengine.h"
#include "iucommon.h"
#include "download.h"
#include <limits.h>


//***********************************************************************
// 
// The following definitions are copied from IUCtl.IDL.
// If IUCtl.IDL is changed, these constants need to be
// changed accordingly
//
//***********************************************************************


/**
* the following two groups of constants can be used to construct
* lMode parameter of the following APIs:
*		Download()
*		DownloadAsync()
*		Install()
*		InstallAsync()
*
* Obviousely, you can only pick one from each group to make up
* lMode parameter.
*
*/
const LONG		UPDATE_NOTIFICATION_DEFAULT			= 0x00000000;    
const LONG		UPDATE_NOTIFICATION_ANYPROGRESS		= 0x00000000;
const LONG		UPDATE_NOTIFICATION_COMPLETEONLY	= 0x00010000;
const LONG		UPDATE_NOTIFICATION_1PCT			= 0x00020000;
const LONG		UPDATE_NOTIFICATION_5PCT			= 0x00040000;
const LONG		UPDATE_NOTIFICATION_10PCT			= 0x00080000;

/**
* constant can also be used for SetOperationMode() and GetOperationMode()
*/
const LONG		UPDATE_MODE_THROTTLE				= 0x00000100;    

/**
* constant can be used by Download() and DownloadAsync(), which will
* tell these API's to use Corporate directory structure for destination folder.
*/
const LONG		UPDATE_CORPORATE_MODE			= 0x00000200;    

/**
* constant can be used by Install() and InstallAsync(). Will disable all
* internet related features
*/
const LONG      UPDATE_OFFLINE_MODE                 = 0x00000400;

/**
* constants for SetOperationMode() API
*/
const LONG		UPDATE_COMMAND_PAUSE				= 0x00000001;
const LONG		UPDATE_COMMAND_RESUME				= 0x00000002;
const LONG		UPDATE_COMMAND_CANCEL				= 0x00000004;

/**
* constants for GetOperationMode() API
*/
const LONG		UPDATE_MODE_PAUSED					= 0x00000001;
const LONG		UPDATE_MODE_RUNNING					= 0x00000002;
const LONG		UPDATE_MODE_NOTEXISTS				= 0x00000004;


/**
* constants for SetProperty() and GetProperty() API
*/
const LONG		UPDATE_PROP_USECOMPRESSION			= 0x00000020;
const LONG      UPDATE_PROP_OFFLINEMODE             = 0x00000080;

/**
* constants for BrowseForFolder() API
*	IUBROWSE_WRITE_ACCESS - validate write access on selected folder
*	IUBROWSE_AFFECT_UI - write-access validation affect OK button enable/disable
*	IUBROWSE_NOBROWSE - do not show browse folder dialog box. validate path passed-in only
*
*	default:
*		pop up browse folder dialog box, not doing any write-access validation
*		
*/
const LONG		IUBROWSE_WRITE_ACCESS				= 1;
const LONG		IUBROWSE_AFFECT_UI					= 2;
const LONG		IUBROWSE_NOBROWSE					= 4;


CEngUpdate*  g_pCDMEngUpdate;		// single global instance used by CDM within the process
CRITICAL_SECTION g_csCDM;			// used to serialize access to g_pCDMEngUpdate
CRITICAL_SECTION g_csGlobalClasses;	// used to serialize access to CSchemaKeys::Initialize() and
BOOL gfInit_csCDM, gfInit_csGC;
									// CSchemaKeys::Uninitialize()
ULONG g_ulGlobalClassRefCount;			// Reference count to track how many CEngUpdate instances are
									// using the g_pGlobalSchemaKeys object
LONG g_lDoOnceOnLoadGuard;			// Used to prevent AsyncExtraWorkUponEngineLoad() from doing
									// any work after the first time it is called.

//
// Used to control shutdown of global threads
//
LONG g_lThreadCounter;
HANDLE g_evtNeedToQuit;
CUrlAgent *g_pUrlAgent = NULL;


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		//
		// create a global CUrlAgent object
		//
		if (NULL == (g_pUrlAgent = new CUrlAgent) ||
			FAILED(g_pUrlAgent->PopulateData()))
		{
			return FALSE;
		}
			
		DisableThreadLibraryCalls(hInstance);
        g_hinst = hInstance;

		gfInit_csCDM = SafeInitializeCriticalSection(&g_csCDM);
		gfInit_csGC = SafeInitializeCriticalSection(&g_csGlobalClasses);

		//
		// each global thread when started, should increase this counter
		// before exit, should decrease this counter,
		// such that ShutdownGlobalThreads() knows when it can return
		//
		g_lThreadCounter = 0;

		//
		// create a manual-reset event with init state non-signaled. 
		// each global thread will check this event, when signalled, it means
		// the thread should exit ASAP.
		//
		g_evtNeedToQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

		//
		// Initialize free logging
		//
		InitFreeLogging(_T("IUENGINE"));
		LogMessage("Starting");

		if (!gfInit_csCDM ||!gfInit_csGC)
		{
			LogError(E_FAIL, "InitializeCriticalSection");
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (NULL != g_evtNeedToQuit)
		{
			CloseHandle(g_evtNeedToQuit);
		}

		if (NULL != g_pUrlAgent)
		{
			delete g_pUrlAgent;
		}

		if (gfInit_csCDM)
		{
			DeleteCriticalSection(&g_csCDM);
		}
		if (gfInit_csGC)
		{
			DeleteCriticalSection(&g_csGlobalClasses);
		}

		//
		// Shutdown free logging
		//
		LogMessage("Shutting down");
		TermFreeLogging();
    }
    return TRUE;
}


// ----------------------------------------------------------------------
//
// DLL API: CompleteSelfUpdateProcess()
//
// call by IUCtl.dll after downloading the new IUEngine.dll to complete
// any selfupdate steps beyond update the engine itself.
// 
// ----------------------------------------------------------------------
HRESULT WINAPI CompleteSelfUpdateProcess()
{
    LOG_Block("CompleteSelfUpdateProcess()");
    HRESULT hr = S_OK;

    // Nothing to do yet, just return S_OK.

	LogMessage("IUEngine update completed");
    return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: PingIUEngineUpdateStatus
//
// Used by iuctl.dll to ping status of iuengine.dll supdate
// 
// ----------------------------------------------------------------------
HRESULT WINAPI PingIUEngineUpdateStatus(
				PHANDLE phQuitEvents,			// ptr to handles for cancelling the operation
				UINT nQuitEventCount,			// number of handles
				LPCTSTR ptszLiveServerUrl,
				LPCTSTR ptszCorpServerUrl,
				DWORD dwError,					// error code
				LPCTSTR ptszClientName			// client name string
)
{
	HRESULT hr;

	if (NULL == phQuitEvents || 1 > nQuitEventCount)
	{
		return E_INVALIDARG;
	}

	CUrlLog pingSvr(
				NULL == ptszClientName ? _T("iu") : ptszClientName,
				ptszLiveServerUrl,
				ptszCorpServerUrl);

	hr = pingSvr.Ping(
					TRUE,							// force online
					URLLOGDESTINATION_DEFAULT,		// going to live or corp WU server
					phQuitEvents,					// pt to cancel events
					nQuitEventCount,				// number of events
					URLLOGACTIVITY_Initialization,	// activity
					SUCCEEDED(dwError) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed,	// status code
					dwError							// error code
				);

	return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: CreateEngUpdateInstance()
//
// Returns a CEngUpdate instance pointer cast to HIUENGINE, or NULL if it fails.
// 
// ----------------------------------------------------------------------
HIUENGINE WINAPI CreateEngUpdateInstance()
{
	LOG_Block("CreateEngUpdateInstance");

	return reinterpret_cast<HIUENGINE>(new CEngUpdate);
}

// ----------------------------------------------------------------------
//
// DLL API: DeleteEngUpdateInstance()
//
// Returns a CEngUpdate instance pointer, or NULL if it fails.
// 
// ----------------------------------------------------------------------
void WINAPI DeleteEngUpdateInstance(HIUENGINE hIUEngine)
{
	LOG_Block("DeleteEngUpdateInstance");

	if (NULL != hIUEngine)
	{
		delete (reinterpret_cast<CEngUpdate*>(hIUEngine));
	}
}

// ----------------------------------------------------------------------
//
// DLL API: Stubs to export CEngUpdate functionality across DLL boundry
//
// ----------------------------------------------------------------------

HRESULT EngGetSystemSpec(HIUENGINE hIUEngine, BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetSystemSpec(bstrXmlClasses, dwFlags, pbstrXmlDetectionResult);
}

HRESULT EngGetManifest(HIUENGINE hIUEngine, BSTR	bstrXmlClientInfo, BSTR	bstrXmlSystemSpec, BSTR	bstrXmlQuery, DWORD dwFlags, BSTR *pbstrXmlCatalog)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetManifest(bstrXmlClientInfo, bstrXmlSystemSpec, bstrXmlQuery, dwFlags, pbstrXmlCatalog);
}

HRESULT EngDetect(HIUENGINE hIUEngine, BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Detect(bstrXmlCatalog, dwFlags, pbstrXmlItems);
}

HRESULT EngDownload(HIUENGINE hIUEngine,BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder,
					LONG lMode, IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Download(bstrXmlClientInfo, bstrXmlCatalog, bstrDestinationFolder,
					lMode, punkProgressListener, hWnd, pbstrXmlItems);
}

HRESULT EngDownloadAsync(HIUENGINE hIUEngine,BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog,
						 BSTR bstrDestinationFolder, LONG lMode, IUnknown *punkProgressListener, 
						HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->DownloadAsync(bstrXmlClientInfo, bstrXmlCatalog,
						bstrDestinationFolder, lMode, punkProgressListener, 
						hWnd, bstrUuidOperation, pbstrUuidOperation);
}

HRESULT EngInstall(HIUENGINE hIUEngine,
				   BSTR bstrXmlClientInfo,
                   BSTR	bstrXmlCatalog,
				   BSTR bstrXmlDownloadedItems,
				   LONG lMode,
				   IUnknown *punkProgressListener,
				   HWND hWnd,
				   BSTR *pbstrXmlItems)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->Install(bstrXmlClientInfo,
                   bstrXmlCatalog,
				   bstrXmlDownloadedItems,
				   lMode,
				   punkProgressListener,
				   hWnd,
				   pbstrXmlItems);
}

HRESULT EngInstallAsync(HIUENGINE hIUEngine,
						BSTR bstrXmlClientInfo,
                        BSTR bstrXmlCatalog,
						BSTR bstrXmlDownloadedItems,
						LONG lMode,
						IUnknown *punkProgressListener,
						HWND hWnd,
						BSTR bstrUuidOperation,
                        BSTR *pbstrUuidOperation)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->InstallAsync(bstrXmlClientInfo,
                        bstrXmlCatalog,
						bstrXmlDownloadedItems,
						lMode,
						punkProgressListener,
						hWnd,
						bstrUuidOperation,
                        pbstrUuidOperation);
}

HRESULT EngSetOperationMode(HIUENGINE hIUEngine, BSTR bstrUuidOperation, LONG lMode)
{
	//
	// 502965 Windows Error Reporting bucket 2096553: Hang following NEWDEV.DLL!CancelDriverSearch
	//
	// Special-case this function for NULL == hIUEngine to allow access
	// by CDM to g_pCDMEngUpdate for CDM.DLL's in .NET Server / SP1 and later
	//
	if (NULL == hIUEngine)
	{
		if (NULL == g_pCDMEngUpdate)
		{
			return E_INVALIDARG;
		}
		else
		{
			return g_pCDMEngUpdate->SetOperationMode(bstrUuidOperation, lMode);
		}
	}
	else
	{
		//
		// Normal case (instance handle passed in)
		//
		return (reinterpret_cast<CEngUpdate*>(hIUEngine))->SetOperationMode(bstrUuidOperation, lMode);
	}
}

HRESULT EngGetOperationMode(HIUENGINE hIUEngine, BSTR bstrUuidOperation, LONG* plMode)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetOperationMode(bstrUuidOperation, plMode);
}

HRESULT EngGetHistory(HIUENGINE hIUEngine,
	BSTR		bstrDateTimeFrom,
	BSTR		bstrDateTimeTo,
	BSTR		bstrClient,
	BSTR		bstrPath,
	BSTR*		pbstrLog)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->GetHistory(bstrDateTimeFrom, bstrDateTimeTo, bstrClient, bstrPath, pbstrLog);
}

HRESULT EngBrowseForFolder(HIUENGINE hIUEngine,
						   BSTR bstrStartFolder, 
						LONG flag, 
						BSTR* pbstrFolder)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->BrowseForFolder(bstrStartFolder, flag, pbstrFolder);
}

HRESULT EngRebootMachine(HIUENGINE hIUEngine)
{
	if (NULL == hIUEngine)
	{
		return E_INVALIDARG;
	}

	return (reinterpret_cast<CEngUpdate*>(hIUEngine))->RebootMachine();
}

// ----------------------------------------------------------------------
//
// DLL API: CreateGlobalCDMEngUpdateInstance()
//
// Initializes the single (global) CEngUpdate instance to be used by CDM
// 
// ----------------------------------------------------------------------
HRESULT WINAPI CreateGlobalCDMEngUpdateInstance()
{
	LOG_Block("CreateGlobalCDMEngUpdateInstance");

	HRESULT hr = S_OK;

	EnterCriticalSection(&g_csCDM);

	if (NULL != g_pCDMEngUpdate)
	{
		LOG_Error(_T("Another thread in process is already using CDM functionality"));
		hr = E_ACCESSDENIED;
		goto CleanUp;
	}

	CleanUpFailedAllocSetHrMsg(g_pCDMEngUpdate = new CEngUpdate);

CleanUp:

	LeaveCriticalSection(&g_csCDM);

	return hr;
}

// ----------------------------------------------------------------------
//
// DLL API: DeleteGlobalCDMEngUpdateInstance()
//
// Deletes the single (global) CEngUpdate instance used by CDM.
// 
// ----------------------------------------------------------------------
HRESULT WINAPI DeleteGlobalCDMEngUpdateInstance()
{
	LOG_Block("DeleteGlobalCDMEngUpdateInstance");

	HRESULT hr = S_OK;

	EnterCriticalSection(&g_csCDM);

	//
	// Unfortunately (due to backwards compatibility with XPClient V4 CDM)
	// we can't tell if this was reached via CDM calling UnloadIUEngine
	// or some other client (e.g. AU) within the scope of a CDM instance.
	//
	// As a result, CDM's instance could get deleted at the wrong time
	// causing further calls to CDM to fail with E_INVALIDARG. Nothing
	// we can do about it because we reach hear after the other client's
	// instance is already deleted, so we can't use g_ulGlobalClassRefCount
	// as a guard against this. However AU and CDM should never be in the
	// same process, so we should be OK. CDM will coexist with instances
	// created via the iuctl COM object since they never call then old
	// ShutdownThreads export.
	//
	if (NULL != g_pCDMEngUpdate)
	{
		delete g_pCDMEngUpdate;
		g_pCDMEngUpdate = NULL;
		LOG_Driver(_T("CDM's global instance of CEngUpdate was deleted"));
	}
	//
	// ELSE this would be the case when iuctl!UnLoadIUEngine is
	// called from a client other than CDM, such as AU
	//
	LeaveCriticalSection(&g_csCDM);

	return hr;
}

CEngUpdate::CEngUpdate()
{
	LOG_Block("CEngUpdate::CEngUpdate");

	HRESULT hr;
	//
	// each thread when start, should increase this counter
	// before exit, should decrease this counter,
	// such that ShutdownInstanceThreads() knows when it can return
	//
	m_lThreadCounter = 0;

	//
	// create a manual-reset event with init state non-signaled. 
	// each thread will check this event, when signalled, it means
	// the thread should exit ASAP.
	//
	m_evtNeedToQuit = CreateEvent(NULL, TRUE, FALSE, NULL);

	//
	// If needed, create a global CSchemaKeys object, but always
	// keep global ref count so we know when to delete
	//
	EnterCriticalSection(&g_csGlobalClasses);

	//
	// Construct the global object
	//
	if (NULL == g_pGlobalSchemaKeys)
	{
		g_pGlobalSchemaKeys = new CSchemaKeys;
	}

#if defined(DBG)
	//
	// We don't worry about this for practical purposes (will fail to construct
	// CEngUpdate before we reach this limit), but maybe on ia64 with huge
	// amounts of memory in a test scenario?
	//
	if (ULONG_MAX == g_ulGlobalClassRefCount)
	{
		LOG_Error(_T("g_ulGlobalClassRefCount is already ULONG_MAX and we are trying to add another"));
	}
#endif

	g_ulGlobalClassRefCount++;
	LOG_Out(_T("g_ulGlobalClassRefCount is now %d"), g_ulGlobalClassRefCount);

	LeaveCriticalSection(&g_csGlobalClasses);
}

CEngUpdate::~CEngUpdate()
{
	LOG_Block("CEngUpdate::~CEngUpdate");

	HRESULT hr;
	//
	// First shut down any outstanding threads
	//
	this->ShutdownInstanceThreads();

    if (NULL != m_evtNeedToQuit)
	{
		CloseHandle(m_evtNeedToQuit);
	}
	//
	// Always Uninitialize global CSchemaKeys object
	//
	EnterCriticalSection(&g_csGlobalClasses);

#if defined(DBG)
	//
	// Paranoid check for coding error
	//
	if (0 == g_ulGlobalClassRefCount)
	{
		LOG_Error(_T("Unbalanced calls to CEngUpdate ctor and dtor"));
	}
#endif

	g_ulGlobalClassRefCount--;
	LOG_Out(_T("g_ulGlobalClassRefCount is now %d"), g_ulGlobalClassRefCount);

	if (0 == g_ulGlobalClassRefCount)
	{
		//
		// The last CEngUpdate instance is going away, delete the
		// global CSchemaKeys object
		//
		if (NULL != g_pGlobalSchemaKeys)
		{
			delete g_pGlobalSchemaKeys;
			g_pGlobalSchemaKeys = NULL;
		}
		else
		{
			LOG_Error(_T("Unexpected NULL == g_pGlobalSchemaKeys"));
		}

		CleanupDownloadLib();
	}

	LeaveCriticalSection(&g_csGlobalClasses);
}

// ----------------------------------------------------------------------
//
// ShutdownInstanceThreads()
// 
// called by CEngUpdate::~CEngUpdate to shut down any outstanding
// threads before the control can end
//
// ----------------------------------------------------------------------
void WINAPI CEngUpdate::ShutdownInstanceThreads()
{
	LOG_Block("ShutdownInstanceThreads");

	if (NULL != m_evtNeedToQuit)
	{
		//
		// notify all threads go away
		//
		SetEvent(m_evtNeedToQuit);
		
		LOG_Out(_T("Shutdown event has been signalled"));

		//
		// wait all threads to quit
		// I don't think we should have a time limit here
		// since if we quit before all threads quit,
		// it's almost sure that AV will happen.
		//
        MSG msg;
		while (m_lThreadCounter > 0)
		{
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
		}

		LOG_Out(_T("All threads appeared gone."));

		//
		// reset the signal
		//
		ResetEvent(m_evtNeedToQuit);
	}
}

HRESULT CEngUpdate::RebootMachine()
{
    LOG_Block("RebootMachine()");

    HRESULT hr = S_OK;
    DWORD dwRet;
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    // Check if we're running on NT, if we are, we need to see if we have Privileges to Reboot
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        HANDLE hToken;
        TOKEN_PRIVILEGES tkp;
        if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
        {
            dwRet = GetLastError();
            LOG_ErrorMsg(dwRet);
            hr = HRESULT_FROM_WIN32(dwRet);
            return hr;
        }

        LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (!AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
        {
            dwRet = GetLastError();
            LOG_ErrorMsg(dwRet);
            hr = HRESULT_FROM_WIN32(dwRet);
            return hr;
        }
    }

    //
    // shutdown the system and force all applications to close
    //
    ExitWindowsEx(EWX_REBOOT, 0);
    return hr;
}


// ----------------------------------------------------------------------
//
// DLL Public API: ShutdownThreads()
// 
// called by unlockengine form control to shut down any outstanding
// threads before the control can end
//
// ----------------------------------------------------------------------
void WINAPI ShutdownThreads()
{
	LOG_Block("ShutdownThreads");

	//
	// To maintain XPClient V4 CDM compatibility with the iuengine.dll, we
	// use the following hack to create and delete the global instance
	// of CEngUpdate:
	//
	// After CDM calls LoadIUEngine, it calls SetGlobalOfflineFlag,
	// which we hook and call CreateGlkobalCDMEngUpdateInstance.
	//
	// When CDM calls UnLoadIUEngine, the function calls the old
	// single-instance ShutdownThreads export, which we now use
	// to call DeleteGlobalCDMEngUpdateInstance. CEngUpdate does
	// its own ShutdownThreads call in it's destructor.
	//
	DeleteGlobalCDMEngUpdateInstance();

	//
	// If we are the last client, shutdown the global threads
	//
	ShutdownGlobalThreads();
}

void WINAPI ShutdownGlobalThreads()
{
	LOG_Block("ShutdownGlobalThreads");
	//
	// Now shut down any global (not CEngUpdate instance) threads
	// if there are no CEngUpdate instances left (last client is exiting)
	//
	if (NULL != g_evtNeedToQuit && 0 == g_ulGlobalClassRefCount)
	{
		//
		// notify all threads go away
		//
		SetEvent(g_evtNeedToQuit);
		
		LOG_Out(_T("Shutdown event has been signalled"));

		//
		// wait all threads to quit
		// I don't think we should have a time limit here
		// since if we quit before all threads quit,
		// it's almost sure that AV will happen.
		//
        MSG msg;
		while (g_lThreadCounter > 0)
		{
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
		}

		LOG_Out(_T("All global threads appear gone."));

		//
		// reset the signal
		//
		ResetEvent(g_evtNeedToQuit);
	}
}

COperationMgr::COperationMgr() : m_pOperationInfoList(NULL)
{
}

COperationMgr::~COperationMgr()
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pNext;
    while (pCurrent)
    {
        pNext = pCurrent->pNext;
        if (NULL != pCurrent->bstrOperationResult)
        {
            SafeSysFreeString(pCurrent->bstrOperationResult);
        }
        HeapFree(GetProcessHeap(), 0, pCurrent);
        pCurrent = pNext;
    }
}


BOOL COperationMgr::AddOperation(LPCTSTR pszOperationID, LONG lUpdateMask)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pLastOperation = NULL;
    PIUOPERATIONINFO pNewOperation = NULL;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    // try to find the operation if its already here
    while (pCurrent)
    {
        pLastOperation = pCurrent;
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            // match
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        // not found, or no operations in list yet
        pNewOperation = (IUOPERATIONINFO *) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IUOPERATIONINFO));
        if (NULL == pNewOperation)
        {
            // out of memory, can't persist operation info.. 
            return FALSE;
        }

        lstrcpyn(pNewOperation->szOperationUUID, pszOperationID, ARRAYSIZE(pNewOperation->szOperationUUID));
        pNewOperation->lUpdateMask = lUpdateMask;

        if (NULL == m_pOperationInfoList)
        {
            m_pOperationInfoList = pNewOperation;
        }
        else
        {
            if (NULL != pLastOperation)
            {
                pLastOperation->pNext = pNewOperation;
            }
        }
    }
    else
    {
        // found the existing operation.. update it.
        pCurrent->lUpdateMask = lUpdateMask;
        SafeSysFreeString(pCurrent->bstrOperationResult); // reset result, new download request
    }
    return TRUE;
}

BOOL COperationMgr::FindOperation(LPCTSTR pszOperationID, PLONG plUpdateMask, BSTR *pbstrOperationResult)
{
    BOOL fFound = FALSE;
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            fFound = TRUE;
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (pCurrent)
    {
        if (plUpdateMask)
            *plUpdateMask = pCurrent->lUpdateMask;

        if (pbstrOperationResult)
        {
            if (NULL != pCurrent->bstrOperationResult)
            {
                *pbstrOperationResult = SysAllocString(pCurrent->bstrOperationResult);
            }
            else
            {
                *pbstrOperationResult = NULL;
            }
        }
    }
    return fFound;
}

BOOL COperationMgr::RemoveOperation(LPCTSTR pszOperationID)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;
    PIUOPERATIONINFO pLastOperation = NULL;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            break;
        }
        pLastOperation = pCurrent;
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        return FALSE; // not found
    }
    else
    {
        if (pCurrent == m_pOperationInfoList) // only operation in list
        {
            m_pOperationInfoList = NULL;
        }
        else
        {
            pLastOperation->pNext = pCurrent->pNext;
        }
    }

    SafeSysFreeString(pCurrent->bstrOperationResult);
    HeapFree(GetProcessHeap(), 0, pCurrent);

    return TRUE;
}

BOOL COperationMgr::UpdateOperation(LPCTSTR pszOperationID, LONG lUpdateMask, BSTR bstrOperationResult)
{
    PIUOPERATIONINFO pCurrent = m_pOperationInfoList;

    if (NULL == pszOperationID)
    {
        return FALSE;
    }

    while (pCurrent)
    {
        if (0 == StrCmpI(pszOperationID, pCurrent->szOperationUUID))
        {
            break;
        }
        pCurrent = pCurrent->pNext;
    }

    if (NULL == pCurrent)
    {
        return FALSE; // not found
    }

    pCurrent->lUpdateMask = lUpdateMask;
    SafeSysFreeString(pCurrent->bstrOperationResult);
    if (NULL != bstrOperationResult)
    {
        pCurrent->bstrOperationResult = SysAllocString(bstrOperationResult);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// WUPostMessageAndBlock()
//
// Since COM doesn't like to have COM calls made while processing a SendMessage
//  message, we need to use PostMessage instead.  However, using PostMessage
//  isn't synchronous, so what we need to do is create an event, do the post,
//  and wait on the event.  When the WndProc at the other end of the post is 
//  done, it will signal the event and we can unblock.
// Input:
//  hwnd: hwnd to post to
//  Msg:  message value
//  pevtData: pointer to an EventData structure to send as the LPARAM. We fill
//             in the hevDoneWithMessage field with the event we allocate.
// Return:
//  TRUE if we successfully waited for the message processing to complete
//   and FALSE otherwise
//  
/////////////////////////////////////////////////////////////////////////////
BOOL WUPostEventAndBlock(HWND hwnd, UINT Msg, EventData *pevtData)
{
    BOOL    fRet = TRUE;

    // ok, so this is funky: if we are in the thread that owns the HWND, then
    //  just maintain previous semantics and call SendMessage (yes, this means
    //  effectively not fixing the bug for this case, but nobody should be 
    //  using the synchronus download or install functions.)
    if (GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
    {
        SendMessage(hwnd, Msg, 0, (LPARAM)pevtData);
    }
    else
    {
        DWORD dw;
        
        // alloc the event we're going to wait on & fill in the field of the
        //  EventData structure.  If this fails, we can't really go on, so 
        //  bail
        pevtData->hevDoneWithMessage = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (pevtData->hevDoneWithMessage == NULL)
            return TRUE;

        // do the post
        PostMessage(hwnd, Msg, 0, (LPARAM)pevtData);

        // wait for the WndProc to signal that it's done.
        dw = WaitForSingleObject(pevtData->hevDoneWithMessage, INFINITE);

        // cleanup & return
        CloseHandle(pevtData->hevDoneWithMessage);
        pevtData->hevDoneWithMessage = NULL;
        
        fRet = (dw == WAIT_OBJECT_0);
    }
    
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\expression.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   expression.h
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      header file for expression related functions
//
//=======================================================================


#ifndef __EXPRESSOIN_HEADER_INCLUDED__

#include "iuengine.h"
#include <msxml.h>

//----------------------------------------------------------------------
//
// public function DetectExpression()
//	retrieve the data from the express node, 
//	and do actual detection work
//
//	Input:
//		expression node
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------
HRESULT 
DetectExpression(
	IXMLDOMNode* pExpression,	// expression node
	BOOL *pfResult
);



//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyExists node
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyExists(
	IXMLDOMNode* pRegKeyExistsNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectRegKeyValue()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyValue(
	IXMLDOMNode* pRegKeyValueNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectRegKeySubstring()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeySubstring(
	IXMLDOMNode* pRegKeySubstringNode,
	BOOL *pfResult
);




//----------------------------------------------------------------------
//
// Helper function DetectRegVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegVersion(
	IXMLDOMNode* pRegKeyVersionNode,
	BOOL *pfResult
);


//----------------------------------------------------------------------
//
// Helper function DetectFileExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileExists(
	IXMLDOMNode* pFileExistsNode,
	BOOL *pfResult
);

//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileVersion(
	IXMLDOMNode* pFileVersionNode,
	BOOL *pfResult
);



//----------------------------------------------------------------------
//
// Helper function DetectComputerSystem()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		computerSystem node
//
//	Return:
//		detection result TRUE/FALSE. Default is FALSE for
//		anything wrong inside this function, plus the return
//		code as error code
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectComputerSystem(
	IXMLDOMNode* pComputerSystemNode,
	BOOL *pfResult
);





#define __EXPRESSOIN_HEADER_INCLUDED__
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\iuengine.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuengine.cpp
//
//  Description:
//
//      PCH module for IUEngine DLL
//
//=======================================================================

#include "iuengine.h"

//
// NOTE:	Do not put anything else in this PCH file - add additional
//			common includes to iuengine.h instead.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\expression.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   expression.CPP
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      Implement function related to detection expressions
//
//=======================================================================

#include "iuengine.h"
#include "SchemaMisc.h"
#include "expression.h"

#include <RegUtil.h>
#include <FileUtil.h>
#include <StringUtil.h>
#include <shlwapi.h>

#include "SchemaKeys.h"
#include "iucommon.h"


//
// include IDetection interface
//

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_
MIDL_DEFINE_GUID(IID, IID_IDetection,0x8E2EF6DC,0x0AB8,0x4FE0,0x90,0x49,0x3B,0xEA,0x45,0x06,0xBF,0x8D);


#ifndef __IDetection_FWD_DEFINED__
#define __IDetection_FWD_DEFINED__
typedef interface IDetection IDetection;
#endif 	/* __IDetection_FWD_DEFINED__ */


#ifndef __IDetection_INTERFACE_DEFINED__
#define __IDetection_INTERFACE_DEFINED__

/* interface IDetection */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDetection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E2EF6DC-0AB8-4FE0-9049-3BEA4506BF8D")
    IDetection : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Detect( 
            /* [in] */ BSTR bstrXML,
            /* [out] */ DWORD *pdwDetectionResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDetectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDetection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDetection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDetection * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IDetection * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IDetection * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IDetection * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDetection * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Detect )( 
            IDetection * This,
            /* [in] */ BSTR bstrXML,
            /* [out] */ DWORD *pdwDetectionResult);
        
        END_INTERFACE
    } IDetectionVtbl;

    interface IDetection
    {
        CONST_VTBL struct IDetectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDetection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDetection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDetection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDetection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDetection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDetection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDetection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDetection_Detect(This,bstrXML,pdwDetectionResult)	\
    (This)->lpVtbl -> Detect(This,bstrXML,pdwDetectionResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IDetection_Detect_Proxy( 
    IDetection * This,
    /* [in] */ BSTR bstrXML,
    /* [out] */ DWORD *pdwDetectionResult);


void __RPC_STUB IDetection_Detect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IDetection_INTERFACE_DEFINED__ */

//
// deckare the constants used to manipulate the result of Detect() method
//

//
// First group, used in <expression> tag, to tell the detection result. This result
// should combined with other expression(s) at the same level
//
const DWORD     IUDET_BOOL              = 0x00000001;	// mask 
const DWORD     IUDET_FALSE             = 0x00000000;	// expression detect FALSE 
const DWORD     IUDET_TRUE              = 0x00000001;	// expression detect TRUE 
const DWORD     IUDET_NULL              = 0x00000002;	// expression detect data missing

//
// Second group, used in <detection> tag, to tell the detection result. This result
// should overwrite the rest of <expression>, if any
//
extern const LONG      IUDET_INSTALLED         = 0x00000010;   /* mask for <installed> result */
extern const LONG      IUDET_INSTALLED_NULL    = 0x00000020;   /* <installed> missing */
extern const LONG      IUDET_UPTODATE          = 0x00000040;   /* mask for <upToDate> result */
extern const LONG      IUDET_UPTODATE_NULL     = 0x00000080;   /* <upToDate> missing */
extern const LONG      IUDET_NEWERVERSION      = 0x00000100;   /* mask for <newerVersion> result */
extern const LONG      IUDET_NEWERVERSION_NULL = 0x00000200;   /* <newerVersion> missing */
extern const LONG      IUDET_EXCLUDED          = 0x00000400;   /* mask for <excluded> result */
extern const LONG      IUDET_EXCLUDED_NULL     = 0x00000800;   /* <excluded> missing */
extern const LONG      IUDET_FORCE             = 0x00001000;   /* mask for <force> result */
extern const LONG      IUDET_FORCE_NULL        = 0x00002000;   /* <force> missing */
extern const LONG		IUDET_COMPUTER			= 0x00004000;	// mask for <computerSystem> result
extern const LONG		IUDET_COMPUTER_NULL		= 0x00008000;	// <computerSystem> missing





#define GotoCleanupIfNull(p)	if (NULL==p) goto CleanUp
#define GotoCleanupHR(hrCode)	hr = hrCode; LOG_ErrorMsg(hr); goto CleanUp


// ----------------------------------------------------------------------
//
// public helper function to convert a bstr value to
// version status enum value, if possible
//
// ----------------------------------------------------------------------
BOOL ConvertBstrVersionToEnum(BSTR bstrVerVerb, _VER_STATUS *pEnumVerVerb)
{
	//
	// convert the versionStatus in bstr into enum
	//
	if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_HI))
	{
		*pEnumVerVerb = DETX_HIGHER;
	}
	else if (CompareBSTRsEqual(bstrVerVerb,KEY_VERSTATUS_HE))
	{
		*pEnumVerVerb = DETX_HIGHER_OR_EQUAL;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_EQ))
	{
		*pEnumVerVerb = DETX_SAME;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_LE))
	{
		*pEnumVerVerb = DETX_LOWER_OR_EQUAL;
	}
	else if (CompareBSTRsEqual(bstrVerVerb, KEY_VERSTATUS_LO))
	{
		*pEnumVerVerb = DETX_LOWER;
	}
	else
	{
		return FALSE;
	}

	return TRUE;
}






//----------------------------------------------------------------------
//
// public function DetectExpression()
//	retrieve the data from the express node, 
//	and do actual detection work
//
//	Input:
//		expression node
//		LPCTSTR			lpcsDllPath,	// path that this provider saved the cust detection Dll
//
//	Return:
//		TRUE/FALSE, detection result
//
//----------------------------------------------------------------------
HRESULT DetectExpression(IXMLDOMNode* pExpression, BOOL *pfResult)
{
	HRESULT				hr			= E_INVALIDARG;
	int					iRet		= -1;
	BOOL				fRet		= TRUE;
	IXMLDOMNodeList*	pChildList	= NULL;
	IXMLDOMNode*		pCandidate	= NULL;

	BSTR				bstrName = NULL;
	BSTR				bstrKey = NULL, 
						bstrEntry = NULL, 
						bstrValue = NULL;
	
	LPCTSTR				lpszKeyComputer = NULL;

	LOG_Block("DetectExpression()");

	USES_IU_CONVERSION;
	

	if (NULL == pExpression || NULL == pfResult)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}


	*pfResult = TRUE;

	//
	// retrieve all child nodes
	//
	(void)pExpression->get_childNodes(&pChildList);
	if (NULL == pChildList)
	{
		LOG_XML(_T("Empty expression found!"));
		GotoCleanupHR(E_INVALIDARG);
	}

	//
	// get the first child
	//
	(void)pChildList->nextNode(&pCandidate);
	if (NULL == pCandidate)
	{
		LOG_XML(_T("empty child list for passed in expresson node!"));
		GotoCleanupHR(E_INVALIDARG);
	}

	//
	// loop through each child node, find out the type
	// of node, call actual detection func accordingly
	//
	lpszKeyComputer = OLE2T(KEY_COMPUTERSYSTEM);
	CleanUpFailedAllocSetHrMsg(lpszKeyComputer);

	while (NULL != pCandidate)
	{
		CleanUpIfFailedAndSetHrMsg(pCandidate->get_nodeName(&bstrName));

		LPTSTR lpszName = OLE2T(bstrName);
		CleanUpFailedAllocSetHrMsg(lpszName);

		if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYEXISTS, 
										-1))
		{
			//
			// call detection function
			//
			hr = DetectRegKeyExists(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYVALUE, 
										-1))
		{
			//
			// process RegKeyValue expression
			//
			hr = DetectRegKeyValue(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYSUBSTR, 
										-1))
		{
			//
			// process RegKeySubstring expression
			//
			hr = DetectRegKeySubstring(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_REGKEYVERSION, 
										-1))
		{
			//
			// process RegVersion expression
			//
			hr = DetectRegVersion(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_FILEVERSION, 
										-1))
		{
			//
			// process FileVersion expression
			//
			hr = DetectFileVersion(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_FILEEXISTS, 
										-1))
		{
			//
			// process FileExists expression
			//
			hr = DetectFileExists(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										lpszKeyComputer, 
										-1))
		{
			//
			// process computerSystem check
			//
			hr = DetectComputerSystem(pCandidate, pfResult);
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_AND, 
										-1))
		{
			//
			// process AND expression
			//
			IXMLDOMNodeList*	pSubExpList = NULL;
			IXMLDOMNode*		pSubExp = NULL;
			long				lLen = 0;

			//
			// get child list
			//
			pCandidate->get_childNodes(&pSubExpList);
			if (NULL == pSubExpList)
			{
				LOG_XML(_T("Found no children of AND expression"));
				GotoCleanupHR(E_INVALIDARG);
			}

			pSubExpList->get_length(&lLen);
			fRet = TRUE;
			for (long i = 0; i < lLen && fRet; i++)
			{
				//
				// each child should be an expression
				// process it. if false, then short-cut.
				//
				pSubExpList->get_item(i, &pSubExp);
				if (NULL == pSubExp)
				{
					pSubExpList->Release();
					pSubExpList = NULL;
					LOG_XML(_T("Failed to get the #%d sub-expression in this AND expression"), i);
					GotoCleanupHR(E_INVALIDARG);		
				}
				hr = DetectExpression(pSubExp, &fRet);
				SafeReleaseNULL(pSubExp);
				if (FAILED(hr))
				{
					//
					// if found something wrong in recursion, don't continue
					//
					break;
				}
			}
			SafeReleaseNULL(pSubExpList);
			*pfResult = fRet;
		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_OR, 
										-1))
		{
			//
			// process OR expression
			//
			IXMLDOMNodeList*	pSubExpList = NULL;
			IXMLDOMNode*		pSubExp = NULL;
			long				lLen = 0;

			//
			// get child list
			//
			pCandidate->get_childNodes(&pSubExpList);
			if (NULL == pSubExpList)
			{
				LOG_XML(_T("Found no children of OR expression"));
				GotoCleanupHR(E_INVALIDARG);
			}

			pSubExpList->get_length(&lLen);
			fRet = FALSE;
			for (long i = 0; i < lLen && !fRet; i++)
			{
				//
				// each child is one expression
				// do it one by one
				//
				pSubExpList->get_item(i, &pSubExp);
				if (NULL == pSubExp)
				{
					pSubExpList->Release();
					pSubExpList = NULL;
					LOG_XML(_T("Failed to get the #%d sub-expression in this OR expression"), i);
					GotoCleanupHR(E_INVALIDARG);		
				}
				hr = DetectExpression(pSubExp, &fRet);
				SafeReleaseNULL(pSubExp);

				if (FAILED(hr))
				{
					//
					// if found something wrong in recursion, don't continue
					//
					break;
				}
			}
			SafeReleaseNULL(pSubExpList);
			*pfResult = fRet;

		}
		else if (CSTR_EQUAL == CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										lpszName, 
										-1, 
										KEY_NOT, 
										-1))
		{
			//
			// process NOT expression
			//
			IXMLDOMNode*		pSubExp = NULL;
			//
			// get the only child
			//
			pCandidate->get_firstChild(&pSubExp);
			if (NULL == pSubExp)
			{
				LOG_XML(_T("Failed to get first child in NOT expression"));
				GotoCleanupHR(E_INVALIDARG);
			}
			//
			// the child must be an expression, process it
			//
			hr = DetectExpression(pSubExp, &fRet);
			if (SUCCEEDED(hr))
			{
				fRet = !fRet;	// flip the result for NOT expression
				*pfResult = fRet;
			}
			else
			{
				LOG_ErrorMsg(hr);
			}
			SafeReleaseNULL(pSubExp);
		}

		if (FAILED(hr))
		{
			goto CleanUp;
		}

		if (!*pfResult)
		{
			//
			// if found one expression FALSE, the whole thing false, so
			// no need to continue
			//
			break;
		}
		SafeReleaseNULL(pCandidate);
		pChildList->nextNode(&pCandidate);
		SafeSysFreeString(bstrName);
	}
		




CleanUp:
	SafeReleaseNULL(pCandidate);
	SafeReleaseNULL(pChildList);
	SysFreeString(bstrName);
	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyExists node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyExists(
	IXMLDOMNode* pRegKeyExistsNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeyExists");
	
	HRESULT	hr = E_INVALIDARG;
	BOOL	fRet = FALSE;
	LPTSTR	lpszKey = NULL, lpszEntry = NULL;
	BSTR	bstrKey = NULL, bstrEntry = NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (FindNodeValue(pRegKeyExistsNode, KEY_KEY, &bstrKey))
	{
		lpszKey = OLE2T(bstrKey);
		CleanUpFailedAllocSetHrMsg(lpszKey);

		//
		// find the optional entry value
		//
		if (FindNodeValue(pRegKeyExistsNode, KEY_ENTRY, &bstrEntry))
		{
			lpszEntry = OLE2T(bstrEntry);
			CleanUpFailedAllocSetHrMsg(lpszEntry);
		}

		*pfResult = RegKeyExists(lpszKey, lpszEntry);

		hr = S_OK;
	}

CleanUp:
	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectRegKeyExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeyValue(
	IXMLDOMNode* pRegKeyValueNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeyValue");

	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszValue	= NULL;
	BSTR	bstrKey		= NULL, 
			bstrEntry	= NULL, 
			bstrValue	= NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeyValueNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}


	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeyValueNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeyValueNode, KEY_VALUE, &bstrValue))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszValue = OLE2T(bstrValue);
	CleanUpFailedAllocSetHrMsg(lpszValue);

	*pfResult = RegKeyValueMatch((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszValue);
	hr = S_OK;
CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;

}



//----------------------------------------------------------------------
//
// Helper function DetectRegKeySubstring()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------

HRESULT
DetectRegKeySubstring(
	IXMLDOMNode* pRegKeySubstringNode,
	BOOL *pfResult
)
{
	LOG_Block("DetectRegKeySubstring");

	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszValue	= NULL;
	BSTR	bstrKey		= NULL,
			bstrEntry	= NULL,
			bstrValue	= NULL;

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeySubstringNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeySubstringNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeySubstringNode, KEY_VALUE, &bstrValue))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszValue = OLE2T(bstrValue);
	CleanUpFailedAllocSetHrMsg(lpszValue);

	*pfResult = RegKeySubstring((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszValue);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrValue);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectRegVersion(
	IXMLDOMNode* pRegKeyVersionNode,
	BOOL *pfResult
)
{
	HRESULT	hr			= E_INVALIDARG;
	BOOL	fRet		= FALSE;
	LPTSTR	lpszKey		= NULL, 
			lpszEntry	= NULL, 
			lpszVersion = NULL;
	BSTR	bstrVerVerb	= NULL,
			bstrKey		= NULL,
			bstrEntry	= NULL,
			bstrVersion	= NULL;

	_VER_STATUS verStatus;

	LOG_Block("DetectRegVersion()");

	USES_IU_CONVERSION;

	//
	// find the key value
	//
	if (!FindNodeValue(pRegKeyVersionNode, KEY_KEY, &bstrKey))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	lpszKey = OLE2T(bstrKey);
	CleanUpFailedAllocSetHrMsg(lpszKey);

	LOG_XML(_T("Found Key=%s"), lpszKey);


	//
	// find the optional entry value
	//
	if (FindNodeValue(pRegKeyVersionNode, KEY_ENTRY, &bstrEntry))
	{
		lpszEntry = OLE2T(bstrEntry);
		CleanUpFailedAllocSetHrMsg(lpszEntry);
		LOG_XML(_T("Found optional entry=%s"), lpszEntry);
	}

	//
	// find the value to compare
	//
	if (!FindNodeValue(pRegKeyVersionNode, KEY_VERSION, &bstrVersion))
	{
		goto CleanUp;
	}

	lpszVersion = OLE2T(bstrVersion);
	CleanUpFailedAllocSetHrMsg(lpszVersion);
	LOG_XML(_T("Version found from node: %s"), lpszVersion);

	//
	// get the attribute versionStatus, a version compare verb
	//
	if (S_OK != (hr = GetAttribute(pRegKeyVersionNode, KEY_VERSIONSTATUS, &bstrVerVerb)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}
	LOG_XML(_T("Version verb found from node: %s"), OLE2T(bstrVerVerb));

	//
	// convert the versionStatus in bstr into enum
	//
	if (!ConvertBstrVersionToEnum(bstrVerVerb, &verStatus))
	{
		SafeSysFreeString(bstrVerVerb);
		goto CleanUp;
	}


	*pfResult = RegKeyVersion((LPCTSTR)lpszKey, (LPCTSTR)lpszEntry, (LPCTSTR)lpszVersion, verStatus);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrKey);
	SysFreeString(bstrEntry);
	SysFreeString(bstrVersion);
	SysFreeString(bstrVerVerb);
	
	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileVersion()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileVersion(
	IXMLDOMNode* pFileVersionNode,
	BOOL *pfResult
)
{
	BOOL	fRet = FALSE;
	BOOL	fFileExists = FALSE;
	HRESULT	hr = E_INVALIDARG;
	IXMLDOMNode* pFilePathNode = NULL;
	TCHAR	szFilePath[MAX_PATH];
	int		iFileVerComp;
	LPTSTR	lpszTimeStamp = NULL,
			lpszVersion = NULL;
	
	BSTR	bstrTime	= NULL,
			bstrVersion	= NULL,
			bstrVerState= NULL;
	

	FILE_VERSION fileVer;
	_VER_STATUS verStatus;

	LOG_Block("DetectFileVersion()");

	USES_IU_CONVERSION;

	if (NULL == pfResult || NULL == pFileVersionNode)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	*pfResult = FALSE;	

	//
	// find the version value
	//
	if (!FindNodeValue(pFileVersionNode, KEY_VERSION, &bstrVersion))
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (NULL == (lpszVersion = OLE2T(bstrVersion)))
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		goto CleanUp;
	}
	
	LOG_XML(_T("Version=%s"), lpszVersion);

	if (!ConvertStringVerToFileVer(T2A(lpszVersion), &fileVer))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;	// bad version string
	}

	//
	// find the file path value
	//
	//if (!FindNodeValue(pFileVersionNode, KEY_FILEPATH, &bstrFile))
	if (!FindNode(pFileVersionNode, KEY_FILEPATH, &pFilePathNode) ||
		NULL == pFilePathNode ||
		FAILED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szFilePath)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;		// no file path found!
	}

	LOG_XML(_T("File=%s"), szFilePath);

	//
	// check if file exist
	//
	fFileExists = FileExists(szFilePath);

	//
	// get the attribute versionStatus, a version compare verb
	//
	if (S_OK != GetAttribute(pFileVersionNode, KEY_VERSIONSTATUS, &bstrVerState))
	{
		goto CleanUp;	// no version status found
	}
	LOG_XML(_T("VersionStatus=%s"), OLE2T(bstrVerState));

	if (!ConvertBstrVersionToEnum(bstrVerState, &verStatus))
	{
		//
		// bad version enum, shouldn't happen since the manifest has
		// been loaded into XMLDOM
		//
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// get optional timestamp
	//
	if (S_OK == GetAttribute(pFileVersionNode, KEY_TIMESTAMP, &bstrTime))
	{
		TCHAR szFileTimeStamp[20];
		LPTSTR lpXmlTimeStamp = OLE2T(bstrTime);
		CleanUpFailedAllocSetHrMsg(lpXmlTimeStamp);

		//
		// find out the file creation time stamp
		//
		int iCompare;
		if (!fFileExists || !GetFileTimeStamp(szFilePath, szFileTimeStamp, 20))
		{
			//szFileTimeStamp[0] = '\0';	// we don't have a timestamp to compare
			//
			// for timestamp compare, it's date/time ISO format compare, i.e., 
			// in alphabetical order, so empty timestamp always smaller.
			//
			iCompare = -1;
		}
		else
		{

			//
			// compare file timestamp, if szFileTimeStamp < lpXmlTimeStamp, -1
			//
			int iCompVal = CompareString(
										MAKELCID(0x0409, SORT_DEFAULT), 
										NORM_IGNORECASE,
										szFileTimeStamp, 
										-1, 
										lpXmlTimeStamp, 
										-1);
			iCompare = (CSTR_EQUAL == iCompVal) ? 0 : ((CSTR_LESS_THAN == iCompVal) ? -1 : +1);
		}

		switch (verStatus)
		{
		case DETX_LOWER:
			fRet = (iCompare < 0);
			break;
		case DETX_LOWER_OR_EQUAL:
			fRet = (iCompare <= 0);
			break;
		case DETX_SAME:
			fRet = (iCompare == 0);
			break;
		case DETX_HIGHER_OR_EQUAL:
			fRet = (iCompare >= 0);
			break;
		case DETX_HIGHER:
			fRet = (iCompare > 0);
			break;
		}
		*pfResult = fRet;

		if (!fRet)
		{
			//
			// false, not need to continue
			//
			hr = S_OK;
			goto CleanUp;
		}
	}
	
	//
	// compare file version: if a < b, -1; a > b, +1
	//
	if (!fFileExists || (FAILED(CompareFileVersion((LPCTSTR)szFilePath, fileVer, &iFileVerComp))))
	{
		//
		// failed to compare version - file may doesn't have a version data.
		// in this case, we assume the file need to compare have version 0,0,0,0, and force
		// the comparision oontinue.
		//
		FILE_VERSION verNoneExists = {0,0,0,0};
		iFileVerComp = CompareFileVersion(verNoneExists, fileVer);
	}

	switch (verStatus)
	{
	case DETX_LOWER:
		fRet = (iFileVerComp < 0);
		break;
	case DETX_LOWER_OR_EQUAL:
		fRet = (iFileVerComp <= 0);
		break;
	case DETX_SAME:
		fRet = (iFileVerComp == 0);
		break;
	case DETX_HIGHER_OR_EQUAL:
		fRet = (iFileVerComp >= 0);
		break;
	case DETX_HIGHER:
		fRet = (iFileVerComp > 0);
		break;
	}

	*pfResult = fRet;

	hr = S_OK;

CleanUp:
	SysFreeString(bstrTime);
	SysFreeString(bstrVersion);
	SysFreeString(bstrVerState);
	SafeReleaseNULL(pFilePathNode);
	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectFileExists()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		RegKeyValue node
//
//	Return:
//		int - detection result: -1=none, 0=FALSE, 1=TRUE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectFileExists(
	IXMLDOMNode* pFileExistsNode,
	BOOL *pfResult
)
{
	BOOL	fRet = FALSE;
	HRESULT hr = E_INVALIDARG;
	TCHAR	szFilePath[MAX_PATH];
	IXMLDOMNode* pFilePathNode = NULL;
	_VER_STATUS verStatus;

	USES_IU_CONVERSION;

	LOG_Block("DetectFileExists()");

	if (NULL == pFileExistsNode || NULL == pfResult)
	{
		return E_INVALIDARG;
	}

	//
	// find the version value
	//
	if (!FindNode(pFileExistsNode, KEY_FILEPATH, &pFilePathNode) ||
		NULL == pFilePathNode ||
		FAILED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szFilePath)))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		*pfResult = FileExists((LPCTSTR)szFilePath);
		hr = S_OK;
	}

	SafeReleaseNULL(pFilePathNode);

	return hr;
}




//----------------------------------------------------------------------
//
// Helper function DetectComputerSystem()
//	retrieve the data from the node, 
//	and do actual detection work
//
//	Input:
//		computerSystem node
//
//	Return:
//		detection result TRUE/FALSE
//
//	Assumption:
//		input parameter not NULL
//
//----------------------------------------------------------------------
HRESULT
DetectComputerSystem(
	IXMLDOMNode* pComputerSystemNode,
	BOOL *pfResult
)
{
	HRESULT hr = E_INVALIDARG;

	LOG_Block("DetectComputerSystem()");

	BSTR bstrManufacturer = NULL;
	BSTR bstrModel = NULL;
	BSTR bstrSupportURL = NULL;
	BSTR bstrXmlManufacturer = NULL;
	BSTR bstrXmlModel = NULL;


	if (NULL == pComputerSystemNode || NULL == pfResult)
	{
		LOG_ErrorMsg(hr);
		return hr;
	}

	*pfResult = FALSE;	// anything wrong, result should be FALSE and return error

	//
	// get manufecturer and model from XML node
	//
	hr = GetAttribute(pComputerSystemNode, KEY_MANUFACTURER, &bstrXmlManufacturer);
	CleanUpIfFailedAndMsg(hr);

	//
	// optional model
	//
	GetAttribute(pComputerSystemNode, KEY_MODEL, &bstrXmlModel);
	
	//
	// find out real manufectuer and model of this machine
	//
	hr = GetOemBstrs(bstrManufacturer, bstrModel, bstrSupportURL);
	CleanUpIfFailedAndMsg(hr);

	//
	// compare to see if manufacturer and model match.
	// mafufacturer match required. If no model provided in xml
	// then no check on model performed.
	//
	// definition of match: both empty or bstr compare equal
	// definition of empty: bstr NULL or string length zero
	//
	*pfResult = (
		(((NULL == bstrXmlManufacturer || SysStringLen(bstrXmlManufacturer) == 0) && // xml data empty and
		  (NULL == bstrManufacturer || SysStringLen(bstrManufacturer) == 0)) ||		// machine manufecturer empty, or
		 CompareBSTRsEqual(bstrManufacturer, bstrXmlManufacturer)) &&				// manufacturer same as xml data, also, 
		 ((NULL == bstrXmlModel) ||													// xml data empty or
		  CompareBSTRsEqual(bstrModel, bstrXmlModel)));								// model matches xml data

	LOG_Out(_T("XML: %ls (%ls), Machine: %ls (%ls), Return: %hs"), 
		(LPCWSTR)bstrManufacturer,
		(LPCWSTR)bstrModel,
		(LPCWSTR)bstrXmlManufacturer,
		(LPCWSTR)bstrXmlModel,
		((*pfResult) ? "True" : "False"));

CleanUp:

	SysFreeString(bstrManufacturer);
	SysFreeString(bstrModel);
	SysFreeString(bstrSupportURL);
	SysFreeString(bstrXmlManufacturer);
	SysFreeString(bstrXmlModel);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\history.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   History.h
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      Class to handle history log
//
//=======================================================================

#include "iuxml.h"


// ----------------------------------------------------------------------
// 
// define the enum for download/install status
//
// ----------------------------------------------------------------------
enum _HISTORY_STATUS {
		HISTORY_STATUS_COMPLETE = 0,
		HISTORY_STATUS_IN_PROGRESS = 1,	// currently should be ignored of this!
		HISTORY_STATUS_FAILED = -1
};



// ----------------------------------------------------------------------
//
// define the class for history
//
// ----------------------------------------------------------------------

class CIUHistory
{
public:

	CIUHistory();
	~CIUHistory();

	// ------------------------------------------------------------------
	//
	// public function SetDownloadBasePath()
	//	this function should be called before AddHistoryItemDownloadStatus()
	//	for corporate case to set the download path that the user has input,
	//	so that we know where to save the history log.
	//	
	// ------------------------------------------------------------------
	HRESULT SetDownloadBasePath(LPCTSTR pszDownloadedBasePath);
	
	
	// ------------------------------------------------------------------
	//
	// public function AddHistoryItemDownloadStatus()
	//	this function should be called when you want to record the
	//	download status of this item. A new history item will be
	//	added to the history file
	//	
	// ------------------------------------------------------------------
	HRESULT AddHistoryItemDownloadStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enDownloadStatus,
				LPCTSTR lpcszDownloadedTo,
				LPCTSTR lpcszClient,
				DWORD dwErrorCode = 0
	);
				

	// ------------------------------------------------------------------
	//
	// public function AddHistoryItemInstallStatus()
	//	this function should be called when you want to record the
	//	install status of this item. This function will go to the
	//	existing history tree and find the first item that matches
	//	the identity of hCatalogItem, and assume that one as 
	//	the one you want to modify the install status
	//	
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT AddHistoryItemInstallStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enInstallStatus,
				LPCTSTR lpcszClient,
				BOOL fNeedsReboot,
				DWORD dwErrorCode = 0
	);


	// ------------------------------------------------------------------
	//
	// public function UpdateHistoryItemInstallStatus()
	//	this function should be called when you want to record the
	//	install status of this item. This function will go to the
	//	existing history tree and find the first item that matches
	//	the identity of hCatalogItem, and assume that one as 
	//	the one you want to modify the install status
	//	
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT UpdateHistoryItemInstallStatus(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				_HISTORY_STATUS enInstallStatus,
				BOOL fNeedsReboot,
				DWORD dwErrorCode /*= 0*/
	);


/*	// ------------------------------------------------------------------
	//
	// public function RetrieveItemDownloadPath()
	//	this function will go to the existing history tree and find
	//  the first item that matches the identity of hCatalogItem, and
	//  assume that's the one you want to retrieve the download path from
	//
	// return:
	//		HRESULT - S_OK if succeeded
	//				- E_HANDLE if can't find hCatalogItem from 
	//				  the current history log tree
	//				- or other HRESULT error
	//
	// ------------------------------------------------------------------
	HRESULT CIUHistory::RetrieveItemDownloadPath(
				CXmlCatalog* pCatalog, 
				HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
				BSTR* pbstrDownloadPath
	);
*/

	// ------------------------------------------------------------------
	//
	// public function ReadHistoryFromDisk()
	//	this function will read the history from the given file
	//
	// ------------------------------------------------------------------
	HRESULT ReadHistoryFromDisk(LPCTSTR lpszLogFile, BOOL fCorpAdmin = FALSE);


	// ------------------------------------------------------------------
	//
	// public function SaveHistoryToDisk()
	//	this function will re-read the history in exclusive mode, and
	//	merge the newly added data to the tree (so we don't overwrite
	//	new changes made by other instances of this control) and
	//	write it back 
	//
	// ------------------------------------------------------------------
	HRESULT SaveHistoryToDisk(void);


	// ------------------------------------------------------------------
	//
	// public function to set the client name 
	//
	//	a client name is used to put in history to denode who
	//	caused download/install happened.
	//
	// ------------------------------------------------------------------
	void SetClientName(BSTR bstrClientName);


	// ------------------------------------------------------------------
	//
	// public function GetHistory
	//
	//	read the current history XML file and convert it
	//	into bstr to pass out
	//
	// ------------------------------------------------------------------
	HRESULT GetHistoryStr(
					LPCTSTR lpszLogFile,
					BSTR BeginDateTime, 
					BSTR EndDateTime, 
					BSTR* pbstrHistory);

private:

	// ------------------------------------------------------------------
	//
	// private inline function GetBSTRStatus
	//
	// ------------------------------------------------------------------
	inline BSTR GetBSTRStatus(_HISTORY_STATUS enStatus)
	{
		BSTR bstrStatus = NULL;
		switch (enStatus)
		{
		case HISTORY_STATUS_COMPLETE:
			bstrStatus = SysAllocString(L"COMPLETE");
			break;
		case HISTORY_STATUS_IN_PROGRESS:
			bstrStatus = SysAllocString(L"IN_PROGRESS");
			break;
		default:
			bstrStatus = SysAllocString(L"FAILED");
		};
		return bstrStatus;
	};

	//
	// named mutex used to gain exclusive access to the history file
	//
	BOOL	m_fSavePending;
	HANDLE	m_hMutex;
	HRESULT m_ErrorCode;
	BSTR	m_bstrCurrentClientName;
	TCHAR	m_szLogFilePath[MAX_PATH];
	LPTSTR	m_pszDownloadBasePath;

	CXmlItems *m_pxmlExisting;
	CXmlItems *m_pxmlDownload;
	CXmlItems *m_pxmlInstall;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\install.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.cpp
//
//  Description:
//
//      Implementation for the Install() function
//
//=======================================================================

#include "iuengine.h"   // PCH - must include first
#include <iu.h>
#include <iucommon.h>
#include <trust.h>
#include <install.h>
#include <fileutil.h>
#include <shlwapi.h>
#include <srrestoreptapi.h>
#include <iuprogress.h>
#include "history.h"
#include "iuxml.h"
//#include <serverPing.h>
#include <logging.h>
#include <UrlLogging.h>

#include <setupapi.h>
#include <regstr.h>
#include <winspool.h>   // for DRIVER_INFO_6
#include <cdmp.h>
#include <cfgmgr32.h>

typedef struct tagDRIVERPREINSTALLINFO
{
    DWORD       dwPnPMatchCount;
    LPTSTR      pszDeviceInstance;
    LPTSTR      pszMostSpecificHWID;
    LPTSTR      pszPreviousMatchingID;
    LPTSTR      pszPreviousProvider;
    LPTSTR      pszPreviousManufacturer;
    LPTSTR      pszPreviousDriverName;
    LPTSTR      pszPreviousDriverVerDate;
    LPTSTR      pszPreviousDriverVerVersion;
    LPTSTR      pszPreviousDriverRank;
    ULONG       ulStatus;
    ULONG       ulProblemNumber;
} DRIVERPREINSTALLINFO, *PDRIVERPREINSTALLINFO;

HRESULT GetMatchingInstallInfo(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszHWID);
HRESULT CachePnPInstalledDriverInfo(PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszHWID);
HRESULT GetPnPInstallStatus(PDRIVERPREINSTALLINFO pDriverInfo);
HRESULT CacheInstalledPrinterDriverInfo(PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszDriverName, LPCTSTR pszHWID, LPCTSTR pszManufacturer, LPCTSTR pszProvider);

#define AVERAGE_IDENTITY_SIZE_PER_ITEM 200
#define SafeFreeLibrary(x) if (NULL != x) { FreeLibrary(x); x = NULL; }
const TCHAR SFCDLL[] = _T("sfc.dll");
const TCHAR SYSTEMRESTOREDESCRIPTION[] = _T("Windows Update V4");
const CHAR  SZ_INSTALL_FINISHED[] = "Install finished";
const CHAR  SZ_INSTALLASYNC_FAILED[] = "Asynchronous Install failed during startup";

typedef BOOL (WINAPI * PFN_SRSetRestorePoint)(PRESTOREPOINTINFO pRestorePtSpec, PSTATEMGRSTATUS pSMgrStatus);

typedef struct IUINSTALLSTARTUPINFO
{
    BSTR bstrXmlClientInfo;
    BSTR bstrXmlCatalog;
    BSTR bstrXmlDownloadedItems;
    BSTR bstrOperationUUID;
    LONG lMode;
    IUnknown *punkProgressListener;
    HWND hwnd;
    CEngUpdate* pEngUpdate;
} IUINSTALLSTARTUPINFO, *PIUINSTALLSTARTUPINFO;

DWORD WINAPI InstallThreadProc(LPVOID lpv);

class CIUInstall
{
public:
    CIUInstall(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrXmlDownloadedItems, BSTR bstrOperationUUID, LONG lMode, IUnknown *punkProgressListener, HWND hWnd);
    ~CIUInstall();

public:
    HRESULT ProcessInstallCatalog(CEngUpdate* pEngUpdate);
    HRESULT GetXmlItemsBSTR(BSTR *pbstrXmlItems);

private:
    HRESULT RecursiveInstallDependencies(HANDLE_NODE hItem, CEngUpdate* pEngUpdate);
    HRESULT DoInstall(HANDLE_NODE hItem, CEngUpdate* pEngUpdate);
    void RemoveDownloadTemporaryFolders(LPCTSTR pszComponentPath);
    void PingServerForInstall(HRESULT hr, HANDLE_NODE hItem, PHANDLE phEvtNeedToQuit, LPCTSTR lpszDeviceId=NULL, BOOL fExclusive=FALSE, PDRIVERPREINSTALLINFO pDriverInfo=NULL);

private:
    BSTR        m_bstrXmlClientInfo;
    BSTR        m_bstrClientName;
    BSTR        m_bstrXmlCatalog;
    BSTR        m_bstrOperationUUID;
    BSTR        m_bstrXmlResult;
    LONG        m_lMode;
    IProgressListener* m_pProgressListener;
    HWND        m_hWnd;

    CXmlCatalog m_xmlCatalog;
    CXmlItems   m_xmlItems;
    CXmlItems   *m_pxmlDownloadedItems;
    CXmlClientInfo m_xmlClientInfo;
    CIUHistory  m_history;
    CUrlLog     m_pingSvr;

    DWORD       m_dwStatus;

    LPTSTR      m_pszInstalledItemsList;
    LPTSTR      m_pszItemDownloadPathListForDelete;
    LONG        m_lInstalledItemsListAllocatedLength;
    LONG        m_lItemDownloadPathListForDeleteLength;

    LONG        m_lItemCount;
    LONG        m_lItemsCompleted;

    BOOL        m_fAbort;
    BOOL        m_fSomeItemsSuccessful;
};

CIUInstall::CIUInstall(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrXmlDownloadedItems, BSTR bstrOperationUUID, LONG lMode, IUnknown *punkProgressListener, HWND hWnd)
  : m_pProgressListener(NULL),
    m_bstrXmlClientInfo(NULL),
    m_bstrClientName(NULL),
    m_bstrXmlCatalog(NULL),
    m_bstrOperationUUID(NULL),
    m_bstrXmlResult(NULL),
    m_lMode(lMode),
    m_hWnd(hWnd),
    m_dwStatus(0),
    m_pszInstalledItemsList(NULL),
    m_pszItemDownloadPathListForDelete(NULL),
    m_lInstalledItemsListAllocatedLength(0),
    m_lItemDownloadPathListForDeleteLength(0),
    m_lItemCount(0),
    m_lItemsCompleted(0),
    m_fAbort(FALSE),
    m_fSomeItemsSuccessful(FALSE),
    m_pxmlDownloadedItems(NULL)
{
    USES_IU_CONVERSION;

    m_bstrXmlClientInfo = SysAllocString(bstrXmlClientInfo);
    m_bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
    m_bstrOperationUUID = SysAllocString(bstrOperationUUID);
    
    if (NULL != punkProgressListener)
    {
        punkProgressListener->QueryInterface(IID_IProgressListener, (void**)&m_pProgressListener);
    }

    m_pxmlDownloadedItems = new CXmlItems(TRUE);
    if (NULL != m_pxmlDownloadedItems)
    {
        m_pxmlDownloadedItems->LoadXMLDocument(bstrXmlDownloadedItems);
    }
}

CIUInstall::~CIUInstall()
{
    SysFreeString(m_bstrXmlClientInfo);
    SysFreeString(m_bstrClientName);
    SysFreeString(m_bstrXmlCatalog);
    SysFreeString(m_bstrOperationUUID);
    SafeReleaseNULL(m_pProgressListener);
    SafeHeapFree(m_pszInstalledItemsList);
    SafeHeapFree(m_pszItemDownloadPathListForDelete);
    SysFreeString(m_bstrXmlResult);

    if (NULL != m_pxmlDownloadedItems)
    {
        delete m_pxmlDownloadedItems;
    }
}

HRESULT CIUInstall::GetXmlItemsBSTR(BSTR *pbstrXmlItems)
{
    if (NULL != m_bstrXmlResult)
        *pbstrXmlItems = SysAllocString(m_bstrXmlResult);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Install()
//
// Do synchronous installation.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// punkProgressListener - the callback function pointer for reporting install progress
// hWnd - the event msg window handler passed from the stub
// Output:
// pbstrXmlItems - the items with installation status in xml format
//                 e.g.
//                 <id guid="2560AD4D-3ED3-49C6-A937-4368C0B0E06D" installed="1"/>
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::Install(BSTR bstrXmlClientInfo,
                       BSTR bstrXmlCatalog,
                       BSTR bstrXmlDownloadedItems,
                       LONG lMode,
                       IUnknown *punkProgressListener,
                       HWND hWnd,
                       BSTR *pbstrXmlItems)
{
    HRESULT hr;

    if ((DWORD) lMode & (DWORD) UPDATE_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

    LogMessage("Install started");

    CIUInstall iuInstall(bstrXmlClientInfo, bstrXmlCatalog, bstrXmlDownloadedItems, NULL, lMode, punkProgressListener, hWnd);
    hr = iuInstall.ProcessInstallCatalog(this);
    iuInstall.GetXmlItemsBSTR(pbstrXmlItems);

    return hr;
}

HRESULT CIUInstall::ProcessInstallCatalog(CEngUpdate* pEngUpdate)
{
    LOG_Block("ProcessInstallCatalog()");

    // clear any previous cancel event
    ResetEvent(pEngUpdate->m_evtNeedToQuit);

    HRESULT     hr = S_OK, hrString = S_OK;
    HANDLE_NODE hCatalogItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hProviderList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hProvider = HANDLE_NODE_INVALID;
    BSTR        bstrPlatform = NULL;
    BSTR        bstrUniqueIdentity = NULL;
    BSTR        bstrProviderName = NULL;
    BSTR        bstrProviderPublisher = NULL;
    BSTR        bstrProviderUUID = NULL;
    TCHAR       szUniqueIdentitySearch[MAX_PATH];
    HINSTANCE   hSystemRestoreDLL = NULL;
    PFN_SRSetRestorePoint fpnSRSetRestorePoint = NULL;
    RESTOREPOINTINFO restoreInfo;
    STATEMGRSTATUS   restoreStatus; 
    BOOL        fContinue = TRUE;
    LPTSTR ptszLivePingServerUrl = NULL;
    LPTSTR ptszCorpPingServerUrl = NULL;
    BOOL fPostWaitSuccess = TRUE;


    DWORD       dwStatus = 0;

    USES_IU_CONVERSION;

    EventData evtData;
    ZeroMemory((LPVOID) &evtData, sizeof(evtData));

    if (NULL == m_pxmlDownloadedItems)
    {
        // Error occured during object initialization, no Return Schema Available
        // Cannot continue
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    hr = m_xmlCatalog.LoadXMLDocument(m_bstrXmlCatalog, pEngUpdate->m_fOfflineMode);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    hr = m_xmlClientInfo.LoadXMLDocument(m_bstrXmlClientInfo, pEngUpdate->m_fOfflineMode);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    m_xmlClientInfo.GetClientName(&m_bstrClientName);
    if (NULL == m_bstrClientName)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    m_pingSvr.SetDefaultClientName(OLE2T(m_bstrClientName));

    if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
    {
        if (SUCCEEDED(g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH)))
        {
            m_pingSvr.SetLiveServerUrl(ptszLivePingServerUrl);
        }
        else
        {
            LOG_Out(_T("failed to get live ping server URL"));
        }
        SafeHeapFree(ptszLivePingServerUrl);
    }
    else
    {
        LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
    }

    if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
    {
        if (SUCCEEDED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
        {
            m_pingSvr.SetCorpServerUrl(ptszCorpPingServerUrl);
        }
        else
        {
            LOG_Out(_T("failed to get corp WU ping server URL"));
        }
        SafeHeapFree(ptszCorpPingServerUrl);
    }
    else
    {
        LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
    }

    m_xmlCatalog.GetItemCount(&m_lItemCount);
    SafeHeapFree(m_pszInstalledItemsList);
    m_lInstalledItemsListAllocatedLength = m_lItemCount * (AVERAGE_IDENTITY_SIZE_PER_ITEM * sizeof(TCHAR));
    m_pszInstalledItemsList = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_lInstalledItemsListAllocatedLength);
    if (NULL == m_pszInstalledItemsList)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    SafeHeapFree(m_pszItemDownloadPathListForDelete);
    m_lItemDownloadPathListForDeleteLength = m_lItemCount * (MAX_PATH * sizeof(TCHAR));
    m_pszItemDownloadPathListForDelete = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_lItemDownloadPathListForDeleteLength);
    if (NULL == m_pszItemDownloadPathListForDelete)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // try to load the System Restore DLL (sfc.dll).
    hSystemRestoreDLL = LoadLibraryFromSystemDir(SFCDLL);
    if (NULL != hSystemRestoreDLL)
    {
#ifdef UNICODE
        fpnSRSetRestorePoint = (PFN_SRSetRestorePoint)GetProcAddress(hSystemRestoreDLL, "SRSetRestorePointW");
#else
        fpnSRSetRestorePoint = (PFN_SRSetRestorePoint)GetProcAddress(hSystemRestoreDLL, "SRSetRestorePointA");
#endif
        if (NULL != fpnSRSetRestorePoint)
        {
            // Set the Restore Point
            ZeroMemory(&restoreInfo, sizeof(restoreInfo));
            ZeroMemory(&restoreStatus, sizeof(restoreStatus));
            restoreInfo.dwEventType = BEGIN_SYSTEM_CHANGE;
            restoreInfo.dwRestorePtType = APPLICATION_INSTALL;
            restoreInfo.llSequenceNumber = 0;

            hr = StringCchCopyEx(restoreInfo.szDescription, ARRAYSIZE(restoreInfo.szDescription),
                                 SYSTEMRESTOREDESCRIPTION,
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }

            if (!fpnSRSetRestorePoint(&restoreInfo, &restoreStatus))
            {
                // this will return FALSE if there is an error 'or' if its called from an OS without SystemRestore
                // support. SR is only supported on Professional and Personal SKU's of Whistler.
                if (ERROR_SUCCESS != restoreStatus.nStatus)
                {
                    LOG_Software(_T("Failed SRSetRestorePoint Call, Error was: 0x%x"), restoreStatus.nStatus);
                    LogError(restoreStatus.nStatus, "Install Set Restore Point");
                }
            }
        }
    }


    //
    // added by JHou for bug#433 in IU db: send 0:N OnProgress event before the install begins
    //
    TCHAR szProgress[64];
    hr = StringCchPrintfEx(szProgress, ARRAYSIZE(szProgress), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%lu:0"), (ULONG)m_lItemCount);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    evtData.bstrProgress = SysAllocString(T2OLE(szProgress));
    if (NULL != m_pProgressListener)
    {
        m_pProgressListener->OnProgress(m_bstrOperationUUID, VARIANT_FALSE, evtData.bstrProgress, &evtData.lCommandRequest);
    }
    else
    {
        if (NULL != m_hWnd)
        {
            evtData.fItemCompleted = FALSE;
            evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
            SendMessage(m_hWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
        }
    }

    //
    // Need to check for a cancel command returned from OnProgress
    //
    if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
    {
        LOG_Out(_T("OnProgress received UPDATE_COMMAND_CANCEL"));
        SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
        hr = E_ABORT;
        fContinue = FALSE;
    }

    // Install has a complexity in how we loop through to install each item. Basically
    // we have to handle any dependent Item installs before installing core Item
    // Since Detection will already have been done at this point we rely on the caller
    // to only give us the list of items that really need to be installed. What we'll do
    // is go through each item and before actually installing it we'll look for any 
    // dependent items that are also in the catalog. If they are in the Catalog then it is
    // assumed it needs to be installed. This check is done recursively for each item.

    // start the base item loop.
    hProviderList = m_xmlCatalog.GetFirstProvider(&hProvider);
    while (HANDLE_NODE_INVALID != hProvider && fContinue)
    {
        m_xmlCatalog.GetIdentity(hProvider, &bstrProviderName, &bstrProviderPublisher, &bstrProviderUUID);
        SafeSysFreeString(bstrProviderName);
        SafeSysFreeString(bstrProviderPublisher);
        SafeSysFreeString(bstrProviderUUID);

        // Get the Enumerator List of Items in this Catalog, and get the first item
        hCatalogItemList = m_xmlCatalog.GetFirstItem(hProvider, &hItem);
        if ((HANDLE_NODELIST_INVALID == hCatalogItemList) || (HANDLE_NODE_INVALID == hItem))
        {
            hr = E_FAIL;
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        //
        // loop through each item in the catalog, calling the installer for each one
        //
        while (HANDLE_NODE_INVALID != hItem && fContinue)
        {
            BSTR bstrXmlItemForCallback = NULL;
            if (SUCCEEDED(m_xmlCatalog.GetBSTRItemForCallback(hItem, &bstrXmlItemForCallback)))
            {
                if (NULL != m_pProgressListener)
                {
                    m_pProgressListener->OnItemStart(m_bstrOperationUUID, bstrXmlItemForCallback, &evtData.lCommandRequest);
                }
                else
                {
                    if (NULL != m_hWnd)
                    {
                        evtData.bstrXmlData = bstrXmlItemForCallback;
                        SendMessage(m_hWnd, UM_EVENT_ITEMSTART, 0, LPARAM(&evtData));
                        evtData.bstrXmlData = NULL;
                    }
                }
                SysFreeString(bstrXmlItemForCallback);
                bstrXmlItemForCallback = NULL;
                if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
                {
                    LOG_Out(_T("OnItemStart received UPDATE_COMMAND_CANCEL"));
                    SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit
                    hr = E_ABORT;
                    fContinue = FALSE;
                }
                else
                {
                    //
                    // check the global quit event. If quit, then server ping treat it as a cancel.
                    //
                    fContinue = (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
                }
                if (!fContinue)
                {
                    continue;   // or break, same effect.
                }
            }
            else
            {
                //
                // something wrong with this item, so we should skip it
                //
                // get the next item. hItem will be HANDLE_NODE_INVALID when there are no
                // remaining items.
                m_xmlCatalog.CloseItem(hItem);
                m_xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
                continue;
            }

            // We have an Item in the Catalog to be Installed. First Look for any Top
            // level dependencies
            hDependentItemList = m_xmlCatalog.GetFirstItemDependency(hItem, &hDependentItem);
            if (HANDLE_NODELIST_INVALID != hDependentItemList)
            {
                
                hr = S_OK;
                while (S_OK == hr)
                {
                    // walk each dependent Item and call the Recursive Installer
                    if (HANDLE_NODE_INVALID != hDependentItem)
                    {
                        // Check if we have installed this item already in this session
                        m_xmlCatalog.GetIdentityStr(hDependentItem, &bstrUniqueIdentity);
                        hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                                     NULL, NULL, MISTSAFE_STRING_FLAGS,
                                                     _T("%ls|"), bstrUniqueIdentity);
                        SafeSysFreeString(bstrUniqueIdentity);
                        if (FAILED(hrString))
                        {
                            // The string check for the unique identity is an optimization to prevent installing the same item more
                            // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                            // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                            LOG_ErrorMsg(hrString);
                        }
                        else
                        {
                            if (NULL != StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                            {
                                // we have already installed this item, skip to the next one.
                                m_xmlCatalog.CloseItem(hDependentItem);
                                hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                                continue;
                            }
                        }

                        // There is a Item in the Catalog that is a dependency of the Item we
                        // are installing and we haven't installed it yet, so Call the 
                        // RecursiveInstaller to handle this one first
                        hr = RecursiveInstallDependencies(hDependentItem, pEngUpdate);
                    }

                    // Get the next Dependent Item - will Return S_FALSE when there are
                    // no more items.
                    m_xmlCatalog.CloseItem(hDependentItem);
                    hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                }
                m_xmlCatalog.CloseItemList(hDependentItemList);
            }

            if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
            {
                m_xmlCatalog.CloseItem(hItem);
                goto CleanUp;
            }

            // Check if we have installed this item already in this session
            m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
            hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                         NULL, NULL, MISTSAFE_STRING_FLAGS,
                                         _T("%ls|"), bstrUniqueIdentity);
            SafeSysFreeString(bstrUniqueIdentity);
            if (FAILED(hrString))
            {
                // The string check for the unique identity is an optimization to prevent installing the same item more
                // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                LOG_ErrorMsg(hrString);
            }
            else
            {
                if (NULL == StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                {
                    // we have NOT installed this item in this session
                    hr = DoInstall(hItem, pEngUpdate);
                }
            }

            if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
            {
                m_xmlCatalog.CloseItem(hItem);
                goto CleanUp;
            }

            // get the next item. hItem will be HANDLE_NODE_INVALID when there are no
            // remaining items.
            m_xmlCatalog.CloseItem(hItem);
            m_xmlCatalog.GetNextItem(hCatalogItemList, &hItem);
        }
        m_xmlCatalog.CloseItem(hProvider);
        m_xmlCatalog.GetNextProvider(hProviderList, &hProvider);
    }

CleanUp:
    // BUG: 441316: Earlier in the install process we left the downloaded files on the machine to
    // support this bug which involves installing Multi Function Device Drivers, Now we want to enumerate
    // the list of download source paths and all folders/files from them.
    if (NULL != m_pszItemDownloadPathListForDelete)
    {
        LPTSTR pszWalk = m_pszItemDownloadPathListForDelete;
        LPTSTR pszChr = NULL;
        while (_T('\0') != *pszWalk)
        {
            pszChr = StrChr(pszWalk, _T('|'));
            if (NULL != pszChr)
            {
                *pszChr = _T('\0');
                // Call RemoveDownloadTemporaryFolders to delete this folder path
                RemoveDownloadTemporaryFolders(pszWalk);
                *pszChr = _T('|');
                pszWalk = pszChr + 1; // skip to next character
            }
        }
    }

    //
    // add HRESULT in case the install failed before the install loop
    //
    if (S_OK != hr)
    {
        m_xmlItems.AddGlobalErrorCodeIfNoItems(hr);
    }

    m_xmlItems.GetItemsBSTR(&m_bstrXmlResult); // get result for Caller and to Send OnOperationComplete
    if (NULL != m_pProgressListener)
    {
        m_pProgressListener->OnOperationComplete(m_bstrOperationUUID, m_bstrXmlResult);
    }
    else
    {
        if (NULL != m_hWnd)
        {
            if (NULL == evtData.bstrUuidOperation)
            {
                evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
            }
            evtData.bstrXmlData = SysAllocString(m_bstrXmlResult);
            evtData.fItemCompleted = TRUE;
            fPostWaitSuccess = WUPostEventAndBlock(m_hWnd, 
                                                   UM_EVENT_COMPLETE, 
                                                   &evtData);
        }
    }

    if ((NULL != fpnSRSetRestorePoint) && (ERROR_SUCCESS == restoreStatus.nStatus))
    {
        if (!m_fSomeItemsSuccessful)
        {
            // need to revert our systemrestore point, no successful installs were done.
            restoreInfo.dwEventType = END_SYSTEM_CHANGE;
            restoreInfo.dwRestorePtType = CANCELLED_OPERATION;
            restoreInfo.llSequenceNumber = restoreStatus.llSequenceNumber;
            fpnSRSetRestorePoint(&restoreInfo, &restoreStatus);
        }
        else
        {
            // signal the end of the restore point change.
            restoreInfo.dwEventType = END_SYSTEM_CHANGE;
            restoreInfo.llSequenceNumber = restoreStatus.llSequenceNumber;
            fpnSRSetRestorePoint(&restoreInfo, &restoreStatus);
            m_fSomeItemsSuccessful = FALSE;
        }
    }

    if (SUCCEEDED(hr))
    {
        LogMessage("%s %s", SZ_SEE_IUHIST, SZ_INSTALL_FINISHED);
    }
    else
    {
        LogError(hr, "%s %s", SZ_SEE_IUHIST, SZ_INSTALL_FINISHED);
    }
    
    fpnSRSetRestorePoint = NULL;
    SafeFreeLibrary(hSystemRestoreDLL);

    // don't free up the strings below unless the wait succeeded in 
    //  WUPostEventAndBlock.  If we do free the strings up and the wait didn't
    //  succeed, then we run the risk of AVing ourselves.  Note that fPostWaitSuccess
    //  is initialized to TRUE so if we will free these BSTRs if WUPostEventAndBlock
    //  is not called.
    if (fPostWaitSuccess)
    {
        SafeSysFreeString(evtData.bstrProgress);
        SafeSysFreeString(evtData.bstrUuidOperation);
        SafeSysFreeString(evtData.bstrXmlData);
    }
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// InstallAsync()
//
// Install Asynchronously.
// Input:
// bstrXmlCatalog - the xml catalog portion containing items to be installed
// bstrXmlDownloadedItems - the xml of downloaded items and their respective download 
//                          result as described in the result schema.  Install uses this
//                          to know whether the items were downloaded and if so where they
//                          were downloaded to so that it can install the items
// punkProgressListener - the callback function pointer for reporting install progress
// hWnd - the event msg window handler passed from the stub
// bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
// Output:
// pbstrUuidOperation - the operation ID. If it is not provided by the in bstrUuidOperation
//                      parameter (an empty string is passed), it will generate a new UUID.
//                      Otherwise, it allocates and copies the value passed by bstrUuidOperation.        
//                      The caller is responsible for freeing the memory returned in
//                      pbstrUuidOperation using SysFreeString(). 
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::InstallAsync(BSTR bstrXmlClientInfo,
                            BSTR bstrXmlCatalog,
                            BSTR bstrXmlDownloadedItems,
                            LONG lMode,
                            IUnknown *punkProgressListener,
                            HWND hWnd,
                            BSTR bstrUuidOperation,
                            BSTR *pbstrUuidOperation)
{
    HRESULT  hr = S_OK;
    DWORD    dwThreadId;
    DWORD    dwErr;
    HANDLE   hThread = NULL;
    GUID     guid;
    LPOLESTR pwszUuidOperation = NULL;
    PIUINSTALLSTARTUPINFO pStartupInfo;

    LOG_Block("InstallAsync()");

    LogMessage("Asynchronous Install started");

    if ((NULL == bstrXmlCatalog) || (NULL == pbstrUuidOperation))
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        LogError(hr, SZ_INSTALLASYNC_FAILED);
        return hr;
    }

    *pbstrUuidOperation = NULL;

    if (NULL == (pStartupInfo = (PIUINSTALLSTARTUPINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(IUINSTALLSTARTUPINFO))))
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        LogError(hr, SZ_INSTALLASYNC_FAILED);
        return hr;
    }

    if ((DWORD) lMode & (DWORD) UPDATE_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

    //
    // 481020 IU - Getting a blank for bstrUuidOperation in the
    // oIUControl_OnItemStart/OnProgress/OnOperationComplete events
    // when calling InstallAsync
    //
    // Also found that BSTRs were leaking (now freed), and that if bstrUuidOperation
    // was NULL or zero length, we need to generate a GUID, so this is done
    // prior to allocating (again) for pStartupInfo->bstrOperationUUID
    //
    if (NULL != bstrUuidOperation && SysStringLen(bstrUuidOperation) > 0)
    {
        *pbstrUuidOperation = SysAllocString(bstrUuidOperation);
    }
    else
    {
        hr = CoCreateGuid(&guid);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            LogError(hr, SZ_INSTALLASYNC_FAILED);
            return hr;
        }
        hr = StringFromCLSID(guid, &pwszUuidOperation);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            LogError(hr, SZ_INSTALLASYNC_FAILED);
            return hr;
        }
        *pbstrUuidOperation = SysAllocString(pwszUuidOperation);
        CoTaskMemFree(pwszUuidOperation);
    }


    pStartupInfo->lMode = lMode;
    pStartupInfo->hwnd = hWnd;
    pStartupInfo->punkProgressListener = punkProgressListener;
    pStartupInfo->pEngUpdate = this;
    pStartupInfo->bstrXmlClientInfo = SysAllocString(bstrXmlClientInfo);
    pStartupInfo->bstrXmlCatalog = SysAllocString(bstrXmlCatalog);
    pStartupInfo->bstrXmlDownloadedItems = SysAllocString(bstrXmlDownloadedItems);
    pStartupInfo->bstrOperationUUID = SysAllocString(*pbstrUuidOperation);

    LOG_XmlBSTR(pStartupInfo->bstrXmlClientInfo);
    LOG_XmlBSTR(pStartupInfo->bstrXmlCatalog);
    LOG_XmlBSTR(pStartupInfo->bstrXmlDownloadedItems);

    InterlockedIncrement(&m_lThreadCounter);

    if (NULL != pStartupInfo->punkProgressListener)
    {
        pStartupInfo->punkProgressListener->AddRef();
    }
    hThread = CreateThread(NULL, 0, InstallThreadProc, (LPVOID)pStartupInfo, 0, &dwThreadId);
    if (NULL == hThread)
    {
        dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
        LOG_ErrorMsg(hr);
        SysFreeString(pStartupInfo->bstrXmlClientInfo);
        SysFreeString(pStartupInfo->bstrXmlCatalog);
        SysFreeString(pStartupInfo->bstrXmlDownloadedItems);
        SysFreeString(pStartupInfo->bstrOperationUUID);
        SafeRelease(pStartupInfo->punkProgressListener);
        SafeHeapFree(pStartupInfo);
        SysFreeString(*pbstrUuidOperation);
        *pbstrUuidOperation = NULL;
        InterlockedDecrement(&m_lThreadCounter);
        LogError(hr, SZ_INSTALLASYNC_FAILED);
        return hr;
    }

    if (SUCCEEDED(hr))
    {
        LogMessage("Asynchronous Install completed startup");
    }
    else
    {
        LogError(hr, SZ_INSTALLASYNC_FAILED);
    }

    return hr;
}


DWORD WINAPI InstallThreadProc(LPVOID lpv)
{
    USES_IU_CONVERSION;

    LOG_Block("InstallThreadProc");

    PIUINSTALLSTARTUPINFO pStartupInfo = (PIUINSTALLSTARTUPINFO)lpv;
    HRESULT hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        LOG_Out(_T("CoInitialize called successfully"));
    }

    {
        // we need to scope this object so it destructs before we decrement our thread counter
        // If we didn't do this and the control was unloading while the thread closed we would fault
        // when the engine unloaded and this class was destructing.
        CIUInstall iuInstall(pStartupInfo->bstrXmlClientInfo, pStartupInfo->bstrXmlCatalog, pStartupInfo->bstrXmlDownloadedItems, pStartupInfo->bstrOperationUUID, pStartupInfo->lMode, pStartupInfo->punkProgressListener, pStartupInfo->hwnd);
        iuInstall.ProcessInstallCatalog(pStartupInfo->pEngUpdate);
    }

    SysFreeString(pStartupInfo->bstrXmlClientInfo);
    SysFreeString(pStartupInfo->bstrXmlCatalog);
    SysFreeString(pStartupInfo->bstrXmlDownloadedItems);
    SysFreeString(pStartupInfo->bstrOperationUUID);
    SafeRelease(pStartupInfo->punkProgressListener);

    if (SUCCEEDED(hr))
    {
        CoUninitialize();
        LOG_Out(_T("CoUninitialize called"));
    }

    InterlockedDecrement(&pStartupInfo->pEngUpdate->m_lThreadCounter);

    SafeHeapFree(pStartupInfo);

    return 0;
}

HRESULT CIUInstall::RecursiveInstallDependencies(HANDLE_NODE hItem, CEngUpdate* pEngUpdate)
{
    LOG_Block("RecursiveInstallDependencies()");
    BOOL fRet = FALSE;
    HRESULT hr = S_FALSE, hrString;

    HANDLE_NODE hDependentItemList = HANDLE_NODELIST_INVALID;
    HANDLE_NODE hDependentItem = HANDLE_NODE_INVALID;

    BSTR bstrUniqueIdentity = NULL;
    TCHAR szUniqueIdentitySearch[MAX_PATH];

    // Check to see if this item has dependencies
    hDependentItemList = m_xmlCatalog.GetFirstItemDependency(hItem, &hDependentItem);
    if (HANDLE_NODELIST_INVALID != hDependentItemList)
    {
        hr = S_OK;
        while (S_OK == hr)
        {
            // walk each dependent Item and call the Recursive Installer
            if (HANDLE_NODE_INVALID != hDependentItem)
            {
                // Check if we have installed this item already in this session
                m_xmlCatalog.GetIdentityStr(hDependentItem, &bstrUniqueIdentity);
                hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                             NULL, NULL, MISTSAFE_STRING_FLAGS,
                                             _T("%ls|"), bstrUniqueIdentity);
                SafeSysFreeString(bstrUniqueIdentity);
                if (FAILED(hrString))
                {

                    // The string check for the unique identity is an optimization to prevent installing the same item more
                    // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
                    // the item. There is no real problem with installing the same item more than once, its just ineffecient.
                    LOG_ErrorMsg(hrString);
                }
                else
                {
                    if (NULL != StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
                    {
                        // we have already installed this item, skip to the next one.
                        m_xmlCatalog.CloseItem(hDependentItem);
                        hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
                        continue;
                    }
                }

                // There is a Item in the Catalog that is a dependency of the Item we
                // are installing and we haven't installed it yet, so Call the 
                // RecursiveInstaller to handle this one first
                hr = RecursiveInstallDependencies(hDependentItem, pEngUpdate);
            }

            // Get the next Dependent Item - will Return S_FALSE when there are
            // no more items.
            m_xmlCatalog.CloseItem(hDependentItem);
            hr = m_xmlCatalog.GetNextItemDependency(hDependentItemList, &hDependentItem);
        }

        m_xmlCatalog.CloseItemList(hDependentItemList);
    }

    // if all installs have succeeded up to this point (hr should be S_FALSE when all 
    // nested installs have completed)
    if (SUCCEEDED(hr))
    {
        // No More Recursive Dependencies, Install This Item - Recursive Functions will unwind
        // Installing each nested item as it goes.
        // Check if we have installed this item already in this session
        m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
        hrString = StringCchPrintfEx(szUniqueIdentitySearch, ARRAYSIZE(szUniqueIdentitySearch),
                                     NULL, NULL, MISTSAFE_STRING_FLAGS,
                                     _T("%ls|"), bstrUniqueIdentity);
        SafeSysFreeString(bstrUniqueIdentity);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);

            // The string check for the unique identity is an optimization to prevent installing the same item more
            // than once in an install operation. If we cannot do this optimization, we will just go ahead and install
            // the item. There is no real problem with installing the same item more than once, its just ineffecient.
            hr = DoInstall(hItem, pEngUpdate);
        }
        else
        {
            if (NULL == StrStrI(m_pszInstalledItemsList, szUniqueIdentitySearch))
            {
                // we have NOT installed this item in this session
                hr = DoInstall(hItem, pEngUpdate);
            }
        }
    }
    return hr;
}


HRESULT CIUInstall::DoInstall(HANDLE_NODE hItem, CEngUpdate* pEngUpdate)
{
    LOG_Block("DoInstall()");
    HRESULT hr, hrString;

    USES_IU_CONVERSION;

    BSTR  bstrName = NULL;
    BSTR  bstrPublisherName = NULL;
    BSTR  bstrItemUUID = NULL;
    BSTR  bstrInstallerType = NULL;
    BSTR  bstrCommand = NULL;
    BSTR  bstrSwitches = NULL;
    BSTR  bstrCommandType = NULL;
    BSTR  bstrInfSection = NULL;
    BSTR  bstrItemDownloadPath = NULL;
    BSTR  bstrDriverName = NULL;
    BSTR  bstrHWID = NULL;
    BSTR  bstrDisplayName = NULL;
    BSTR  bstrUniqueIdentity = NULL;
    BSTR  bstrCodeBase = NULL;
    BSTR  bstrCRC = NULL;
    BSTR  bstrFileName = NULL;
    BSTR  bstrManufacturer = NULL;
    BSTR  bstrProvider = NULL;
    TCHAR szProgress[64];
    TCHAR szCommandType[64];
    TCHAR szInstallerType[256];
    TCHAR szItemSourcePath[MAX_PATH];
    TCHAR szCabFilePath[MAX_PATH];
    LPTSTR pszCabUrl = NULL;
    LPTSTR pszAllocatedFileName = NULL;
    LPTSTR pszLocalFileName = NULL;
    LONG  lItemCommandCount = 0;
    LONG  lListNeededLength = 0;
    LONG  lSize;
    BOOL  fInstallerNeedsReboot = FALSE;
    BOOL  fExclusive = FALSE;
    BOOL  fPatch;
    BOOL  fContinue = TRUE;
    BOOL  fIsPrinterDriverUpgrade = FALSE;
    PINSTALLCOMMANDINFO pCommandInfoArray = NULL;
    DWORD dwStatus = ITEM_STATUS_FAILED;
    HANDLE_NODE hXmlItem = HANDLE_NODE_INVALID;
    HANDLE_NODELIST hItemCodeBaseList = HANDLE_NODELIST_INVALID;
    EventData evtData;
    ZeroMemory((LPVOID) &evtData, sizeof(evtData));
    LPTSTR pszClientName = OLE2T(m_bstrClientName);
    DRIVERPREINSTALLINFO driverInfo;
    ZeroMemory(&driverInfo, sizeof(DRIVERPREINSTALLINFO));

    m_dwStatus = ITEM_STATUS_FAILED; // default install status to failure
    
    hr = m_xmlCatalog.GetIdentity(hItem, &bstrName, &bstrPublisherName, &bstrItemUUID);
    if (FAILED(hr))
    {
        LOG_Software(_T("Failed to get an Identity for an Item (invalid document??)"));
        LogError(hr, "Install failed to get an Item Identity");
        goto CleanUp;
    }

    hr = m_pxmlDownloadedItems->GetItemDownloadPath(&m_xmlCatalog, hItem, &bstrItemDownloadPath);
    if (NULL == bstrItemDownloadPath)
    {
        LOG_Software(_T("Failed to get Item Download Path"));
        if (SUCCEEDED(hr))
            hr = E_FAIL;
        LogError(hr, "Install couldn't get Item %ls Download Path", bstrName);
        goto CleanUp;
    }

    hr = StringCchCopyEx(szItemSourcePath, ARRAYSIZE(szItemSourcePath), 
                         OLE2T(bstrItemDownloadPath),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    SafeSysFreeString(bstrItemDownloadPath);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    

    hr = m_xmlCatalog.GetItemInstallInfo(hItem, &bstrInstallerType, &fExclusive, &fInstallerNeedsReboot, &lItemCommandCount);
    if (FAILED(hr))
    {
        LOG_Software(_T("Failed to get ItemInstallInfo for Item %ls"), bstrName);
        LogError(hr, "Failed to get Item %ls Install Information", bstrName);
        goto CleanUp;
    }

    LogMessage("Installing %ls item from publisher %ls", bstrInstallerType, bstrPublisherName);

    if (lItemCommandCount > 0)
    {
        // Allocate INSTALLCOMMANDINFO array and fill out with command info
        pCommandInfoArray = (PINSTALLCOMMANDINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
            sizeof(INSTALLCOMMANDINFO) * lItemCommandCount);
        if (NULL == pCommandInfoArray)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            LogError(hr, "Install Command processing");
            goto CleanUp;
        }
    }

    for (LONG lCnt = 0; lCnt < lItemCommandCount; lCnt++)
    {
        // Get Install Command Information for each Command
        m_xmlCatalog.GetItemInstallCommand(hItem, lCnt, &bstrCommandType, &bstrCommand, &bstrSwitches, &bstrInfSection);
        if (NULL == bstrCommandType || NULL == bstrCommand)
        {
            hr = E_INVALIDARG;
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LogMessage("Installer Command Type: %ls", bstrCommandType);

        // Copy the Command to Execute
        hr = StringCchCopyEx(pCommandInfoArray[lCnt].szCommandLine, ARRAYSIZE(pCommandInfoArray[lCnt].szCommandLine),
                             OLE2T(bstrCommand),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        hr = StringCchCopyEx(szCommandType, ARRAYSIZE(szCommandType), OLE2T(bstrCommandType),
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            szCommandType, -1, _T("INF"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_INF;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            szCommandType, -1, _T("ADVANCED_INF"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_ADVANCEDINF;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            szCommandType, -1, _T("EXE"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_EXE;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            szCommandType, -1, _T("WI"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_MSI;
        }
        else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            szCommandType, -1, _T("CUSTOM"), -1))
        {
            pCommandInfoArray[lCnt].iCommandType = COMMANDTYPE_CUSTOM;
        }
        else
        {
            LOG_Software(_T("Unable to determine Installer Type %s"), szCommandType);
            pCommandInfoArray[lCnt].iCommandType = 0; // unknown
        }

        // Copy the Command Line Parameters (if any)
        if (NULL != bstrSwitches)
        {
            hr = StringCchCopyEx(pCommandInfoArray[lCnt].szCommandParameters, ARRAYSIZE(pCommandInfoArray[lCnt].szCommandParameters),
                                 OLE2T(bstrSwitches),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }

        if (NULL != bstrInfSection)
        {
            hr = StringCchCopyEx(pCommandInfoArray[lCnt].szInfSection, ARRAYSIZE(pCommandInfoArray[lCnt].szInfSection),
                                 OLE2T(bstrInfSection),
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
        }
    
        SafeSysFreeString(bstrCommandType);
        SafeSysFreeString(bstrCommand);
        SafeSysFreeString(bstrSwitches);
        SafeSysFreeString(bstrInfSection);
    }

    // Before we start the install we need to verify the signature on all cabs of this item. This is to verify that they
    // haven't been tampered with between download and install (especially during non-consumer scenarios)
    hItemCodeBaseList = m_xmlCatalog.GetItemFirstCodeBase(hItem, &bstrCodeBase, &bstrFileName, &bstrCRC, &fPatch, &lSize);
    if ((HANDLE_NODELIST_INVALID == hItemCodeBaseList) || (NULL == bstrCodeBase))
    {
        LOG_Software(_T("Item %s has no Cabs, cannot verify signature"), bstrName);
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    while (fContinue && NULL != bstrCodeBase)
    {
        if (NULL != bstrFileName && SysStringLen(bstrFileName) > 0)
        {
            if (NULL != pszAllocatedFileName)
            {
                MemFree(pszAllocatedFileName);
            }
            pszAllocatedFileName = OLE2T(bstrFileName);
        }
        else // no special filename specified, use filename from URL
        {
            if (NULL != pszCabUrl)
            {
                MemFree(pszCabUrl);
            }
            pszCabUrl = OLE2T(bstrCodeBase);
            // search for the last forward slash (will separate the URL from the filename)
            LPTSTR pszLastSlash = StrRChr(pszCabUrl, NULL, _T('/'));
            // if the last slash was found, skip to next character (will be the beginning of the filename)
            if (NULL != pszLastSlash)
                pszLastSlash++;
            pszLocalFileName = pszLastSlash;
        }

        hr = PathCchCombine(szCabFilePath, ARRAYSIZE(szCabFilePath),
                            szItemSourcePath, (NULL != pszAllocatedFileName) ? pszAllocatedFileName : pszLocalFileName);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            m_xmlCatalog.CloseItemList(hItemCodeBaseList);
            goto CleanUp;
        }
        
        hr = VerifyFileTrust(szCabFilePath, 
                             NULL, 
                             ReadWUPolicyShowTrustUI()
                             );
        if (FAILED(hr))
        {
            // Cab File Failed Trust Validation
            LOG_ErrorMsg(hr);
            m_xmlCatalog.CloseItemList(hItemCodeBaseList);
            goto CleanUp;
        }
        SafeSysFreeString(bstrCodeBase);
        SafeSysFreeString(bstrFileName);
        SafeSysFreeString(bstrCRC);
        fContinue = SUCCEEDED(m_xmlCatalog.GetItemNextCodeBase(hItemCodeBaseList, &bstrCodeBase, &bstrFileName, &bstrCRC, &fPatch, &lSize)) &&
            (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) != WAIT_OBJECT_0);
    }

    // If this item is Exclusive we need to write something to the history to indicate that the install has started
    // Normally an exclusive item won't return control back to the installer so no other history information will be
    // available
    if (fExclusive)
    {
        m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_IN_PROGRESS, pszClientName, fInstallerNeedsReboot, S_OK);
        m_history.SaveHistoryToDisk();
        PingServerForInstall(hr, hItem, &(pEngUpdate->m_evtNeedToQuit), NULL, TRUE);    // ping exclusive item now
    }

    // Call Install Library with Item Information

    hr = StringCchCopyEx(szInstallerType, ARRAYSIZE(szInstallerType), OLE2T(bstrInstallerType),
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
        szInstallerType, -1, _T("SOFTWARE"), -1))
    {
        if (lItemCommandCount == 0)
        {
            LOG_Software(_T("Item %s has no Commands.. cannot install"), bstrName);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
        hr = InstallSoftwareItem(szItemSourcePath, fInstallerNeedsReboot, lItemCommandCount, pCommandInfoArray, &dwStatus);
    }
    else if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
        szInstallerType, -1, _T("CDM"), -1))
    {
        if (m_xmlCatalog.IsPrinterDriver(hItem))
        {
            m_xmlCatalog.GetPrinterDriverInfo(hItem, &bstrDriverName, &bstrHWID, &bstrManufacturer, &bstrProvider);

            // Need to determine if this is a previous installed printer driver and fill out the PREDRIVERINFO structure
            if (FAILED(hr = CacheInstalledPrinterDriverInfo(&driverInfo, (LPCTSTR)bstrDriverName, (LPCTSTR)bstrHWID, (LPCTSTR)bstrManufacturer, (LPCTSTR)bstrProvider)))
            {
                // Problem with the Catalog Data
                LOG_ErrorMsg(hr);
                goto CleanUp;
            }
            if (S_OK == hr)
            {
                fIsPrinterDriverUpgrade = TRUE;
            }
            SafeSysFreeString(bstrHWID);
            SafeSysFreeString(bstrManufacturer);
            SafeSysFreeString(bstrProvider);
        }

        // InstallPrinterDriver can only be called if the driver is a upgrade to a previously installed printer driver
        // otherwise the install will fail.
        if (fIsPrinterDriverUpgrade)
        {
            hr = InstallPrinterDriver(OLE2T(bstrDriverName), szItemSourcePath, NULL, &dwStatus);
            if (FAILED(hr))
            {
                LogError(hr, "Installing Printer Driver %ls", bstrDriverName);
            }
            SafeSysFreeString(bstrDriverName);
        }
        else
        {
            // Normal Device Driver or new Driver for a Printer Device
            if (SUCCEEDED(hr = m_xmlCatalog.GetDriverInfo(hItem, &bstrHWID, &bstrDisplayName)))
            {
                (void)CachePnPInstalledDriverInfo(&driverInfo, (LPCTSTR) bstrHWID);
                hr = InstallDriver(szItemSourcePath, OLE2T(bstrDisplayName), OLE2T(bstrHWID), &dwStatus);
            }

            if (FAILED(hr))
            {
                LogError(hr, "Installing PnP Driver %ls, %ls", bstrHWID, bstrDisplayName);
            }
			else
			{
				//
				// Attempt to get status of successfully installed driver, but don't fail
				//
				(void) GetPnPInstallStatus(&driverInfo);
			}
            SafeSysFreeString(bstrDisplayName);
        }
    }

    // Bug 441336: Deleting all files on a successful install of an item causes some problems with
    // Multi Function Device Drivers, these show up as multiple instances of the same 'item', share
    // the same downloaded driver package, but have different HWID's. The Item's all have different
    // identities because the calling application is making them unique when they recognize a MFD
    // driver package. We need to purposely leave the downloaded files installed until the 'very' end
    // of the installation process, so all items have a chance to be installed.
    // So, we will no longer perform this deletion step here, but will instead enumerate the InstalledItemsList
    // and remove the folders for each one.

    // Regardless of Success or Failure, update the Count of Items Installed
    m_lItemsCompleted++;

    // Add this Item to the InstalledItemsList
    m_xmlCatalog.GetIdentityStr(hItem, &bstrUniqueIdentity);
    lListNeededLength = (lstrlen(m_pszInstalledItemsList) + lstrlen(OLE2T(bstrUniqueIdentity)) + 2) * sizeof(TCHAR);
    if (lListNeededLength > m_lInstalledItemsListAllocatedLength)
    {
        // need to reallocate the installeditemlist
        LPTSTR pszNew = (LPTSTR) HeapReAlloc(GetProcessHeap(), 
                                             0, 
                                             m_pszInstalledItemsList, 
                                             m_lInstalledItemsListAllocatedLength * 2);

        if (NULL != pszNew)
        {
            m_pszInstalledItemsList = pszNew;
            m_lInstalledItemsListAllocatedLength *= 2;

            // only do this if the realloc worked, if it didn't we won't be adding more items
            hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength,
                               OLE2T(bstrUniqueIdentity),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }

            hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength, _T("|"),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }
        }
    }
    else
    {
        // only do this if the realloc worked, if it didn't we won't be adding more items
        hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength,
                           OLE2T(bstrUniqueIdentity),
                           NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);
        }

        hrString = StringCbCatEx(m_pszInstalledItemsList, m_lInstalledItemsListAllocatedLength, _T("|"),
                           NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hrString))
        {
            LOG_ErrorMsg(hrString);
        }
    }

    if (SUCCEEDED(hr))
    {
        lListNeededLength = (lstrlen(m_pszItemDownloadPathListForDelete) + lstrlen(szItemSourcePath) + 2) * sizeof(TCHAR);
        if (lListNeededLength > m_lItemDownloadPathListForDeleteLength)
        {
            // need to reallocate the downloadpathitemlist
            LPTSTR pszNew = (LPTSTR) HeapReAlloc(GetProcessHeap(),
                                                 0,
                                                 m_pszItemDownloadPathListForDelete,
                                                 m_lItemDownloadPathListForDeleteLength * 2);
            if (NULL != pszNew)
            {
                m_pszItemDownloadPathListForDelete = pszNew;
                m_lItemDownloadPathListForDeleteLength *= 2;

                // only do this if the realloc worked, if it didn't we won't be adding more items
                hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength,
                                   szItemSourcePath,
                                   NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hrString))
                {
                    LOG_ErrorMsg(hrString);
                }

                hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength, _T("|"),
                                   NULL, NULL, MISTSAFE_STRING_FLAGS);
                if (FAILED(hrString))
                {
                    LOG_ErrorMsg(hrString);
                }
            }
        }
        else
        {
            hrString = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength,
                               szItemSourcePath,
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }

            hr = StringCbCatEx(m_pszItemDownloadPathListForDelete, m_lItemDownloadPathListForDeleteLength, _T("|"),
                               NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hrString))
            {
                LOG_ErrorMsg(hrString);
            }
        }
    }

CleanUp:

    //
    // Could have gotten here with stale hr if client called SetOperationMode
    //
    if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
    {
        hr = E_ABORT;
    }

    m_xmlItems.AddItem(&m_xmlCatalog, hItem, &hXmlItem);

    if (ITEM_STATUS_SUCCESS_REBOOT_REQUIRED == dwStatus)
    {
        fInstallerNeedsReboot = TRUE;
    }

    if (ITEM_STATUS_FAILED == dwStatus)
    {
        if (fExclusive)
        {
            m_history.UpdateHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_FAILED, fInstallerNeedsReboot, hr);
        }
        else
        {
            m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_FAILED, pszClientName, fInstallerNeedsReboot, hr);
        }
        m_xmlItems.AddInstallStatus(hXmlItem, KEY_STATUS_FAILED, 0, hr);
    }
    else
    {
        // install completed successfully
        if (fExclusive)
        {
            m_history.UpdateHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, fInstallerNeedsReboot, 0);
        }
        else
        {
            m_history.AddHistoryItemInstallStatus(&m_xmlCatalog, hItem, HISTORY_STATUS_COMPLETE, pszClientName, fInstallerNeedsReboot, 0);
        }
        if (ITEM_STATUS_INSTALLED_ERROR == dwStatus)
        {
            LOG_Software(_T("Item Installed However there were Minor Errors"));
        }
        m_xmlItems.AddInstallStatus(hXmlItem, KEY_STATUS_COMPLETE, fInstallerNeedsReboot, 0);
        m_fSomeItemsSuccessful = TRUE; // any success in the install operation should set to true
    }

    //
    // ping server to report the download status for this item
    //
    if (!fExclusive)
    {
        //
        // if we haven't done so, ping server now
        //
        LPCTSTR pDeviceId = NULL;
        if (NULL != bstrDriverName) 
        {
            pDeviceId = OLE2T(bstrDriverName);
        }
        else if (NULL != bstrHWID)
        {
            pDeviceId = OLE2T(bstrHWID);
        }
        PingServerForInstall(hr, hItem, &(pEngUpdate->m_evtNeedToQuit), pDeviceId, FALSE, &driverInfo);
    }

    if ((DWORD) m_lMode & (DWORD) UPDATE_NOTIFICATION_COMPLETEONLY)
    {
        // Only Send OnOperationComplete, we won't send any progress messages.
    }
    else
    {
        // Send all Progress Messages
        hrString = StringCchPrintfEx(szProgress, ARRAYSIZE(szProgress), NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("%lu:%lu"), (ULONG)m_lItemCount, (ULONG)m_lItemsCompleted);
        if (SUCCEEDED(hrString))
        {
            evtData.bstrProgress = SysAllocString(T2OLE(szProgress));
            if (NULL != m_pProgressListener)
            {
                m_pProgressListener->OnProgress(m_bstrOperationUUID, VARIANT_TRUE, evtData.bstrProgress, &evtData.lCommandRequest);
            }
            else
            {
                if (NULL != m_hWnd)
                {
                    evtData.fItemCompleted = TRUE;
                    evtData.bstrUuidOperation = SysAllocString(m_bstrOperationUUID);
                    SendMessage(m_hWnd, UM_EVENT_PROGRESS, 0, LPARAM(&evtData));
                }
            }
        }
        else
        {
            LOG_ErrorMsg(hrString);
        }
        //
        // Need to check for a cancel command returned from OnProgress
        //
        if (UPDATE_COMMAND_CANCEL == evtData.lCommandRequest)
        {
            LOG_Out(_T("OnProgress received UPDATE_COMMAND_CANCEL"));
            SetEvent(pEngUpdate->m_evtNeedToQuit); // asked to quit, we'll handle it in WaitForSingleObject
        }
    }

    m_dwStatus = dwStatus; // return the status up the chain

    SafeHeapFree(pCommandInfoArray);
    SysFreeString(bstrName);
    SysFreeString(bstrPublisherName);
    SysFreeString(bstrItemUUID);
    SysFreeString(bstrInstallerType);
    SafeSysFreeString(bstrManufacturer);
    SafeSysFreeString(bstrProvider);
    SafeSysFreeString(bstrCommandType);
    SafeSysFreeString(bstrCommand);
    SafeSysFreeString(bstrSwitches);
    SafeSysFreeString(bstrInfSection);
    SafeSysFreeString(bstrHWID);
    SafeSysFreeString(bstrDriverName);
    SafeSysFreeString(evtData.bstrProgress);
    SafeSysFreeString(evtData.bstrUuidOperation);
	SafeHeapFree(driverInfo.pszDeviceInstance);
	SafeHeapFree(driverInfo.pszMostSpecificHWID);
	SafeHeapFree(driverInfo.pszPreviousDriverName);
	SafeHeapFree(driverInfo.pszPreviousDriverVerDate);
	SafeHeapFree(driverInfo.pszPreviousDriverVerVersion);
	SafeHeapFree(driverInfo.pszPreviousDriverRank);
	SafeHeapFree(driverInfo.pszPreviousManufacturer);
	SafeHeapFree(driverInfo.pszPreviousMatchingID);
	SafeHeapFree(driverInfo.pszPreviousProvider);

    //
    // Could have missed change during lengthy ping or OnProgress
    //
    if (WaitForSingleObject(pEngUpdate->m_evtNeedToQuit, 0) == WAIT_OBJECT_0)
    {
        hr = E_ABORT;
    }

    return hr;
}


//
// RemoveDownloadTemporaryFolders
//
// This helper function is called after the install is successfully finished
// in DoInstall() to delete the temporary component directory and all files underneath
//
void CIUInstall::RemoveDownloadTemporaryFolders(LPCTSTR pszComponentPath)
{
    LOG_Block("CIUInstall::RemoveDownloadTemporaryFolders()");

    HRESULT hr;
    TCHAR szBuffer[MAX_PATH], szDeleteFile[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hFind;

    hr = PathCchCombine(szBuffer, ARRAYSIZE(szBuffer), pszComponentPath, _T("*.*"));
    if (FAILED(hr))
    {
        LOG_ErrorMsg(hr);
        return;
    }

    hFind = FindFirstFile(szBuffer, &fd);
    BOOL fMore = (hFind != INVALID_HANDLE_VALUE);
    while (fMore)
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            hr = PathCchCombine(szDeleteFile, ARRAYSIZE(szDeleteFile), pszComponentPath, fd.cFileName);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto doneCurrentEntry;
            }
            
            if (!DeleteFile(szDeleteFile))
            {
                // Try waiting a bit before trying one last time. 
                Sleep(1000);
                DeleteFile(szDeleteFile);
            }
        }
        else if (_T('.') != fd.cFileName[0] && 
                 (_T('\0') != fd.cFileName[1] || 
                  (_T('.') != fd.cFileName[1] && _T('\0') != fd.cFileName[2])))
        {
            hr = PathCchCombine(szBuffer, ARRAYSIZE(szDeleteFile), pszComponentPath, fd.cFileName);
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto doneCurrentEntry;
            }
            RemoveDownloadTemporaryFolders(szBuffer);
        }
        
doneCurrentEntry:   
        fMore = FindNextFile(hFind, &fd);
    }
    if (hFind != INVALID_HANDLE_VALUE)
        FindClose(hFind);
            
    BOOL fSuccess = RemoveDirectory(pszComponentPath);
    if (!fSuccess)
    {
        // Try waiting a bit before trying one last time. 
        Sleep(1000);
        fSuccess = RemoveDirectory(pszComponentPath);
    }
}



//
// private utility function to ping server for installation activity. 
// since there are two places we do this, so wrap this in a function to safe size
//
void CIUInstall::PingServerForInstall(HRESULT hr, HANDLE_NODE hItem, PHANDLE phEvtNeedToQuit, LPCTSTR lpszDeviceId /*=NULL*/, BOOL fExclusive /*=FALSE*/, PDRIVERPREINSTALLINFO pDriverInfo /*=NULL*/)
{
    LOG_Block("CIUInstall::PingServerForInstall()");

	HRESULT hrTemp = S_OK;
    BSTR bstrIdentity = NULL;

    USES_IU_CONVERSION;

    if (SUCCEEDED(m_xmlCatalog.GetIdentityStrForPing(hItem, &bstrIdentity)))
    {
        BOOL fOnLine = (0 == ((DWORD) m_lMode & (DWORD) UPDATE_OFFLINE_MODE));
        URLLOGSTATUS status = SUCCEEDED(hr) ? URLLOGSTATUS_Success : URLLOGSTATUS_Failed;
        if (fExclusive)
        {
            status = URLLOGSTATUS_Pending;
        }
        if (m_fAbort)
        {
            //
            // user/system cancelled the current process
            //
            hr = E_ABORT;
            status = URLLOGSTATUS_Cancelled;
        }
        LPTSTR pszMessage = NULL; // String used to pass Pre Installed Driver Info
        LPCTSTR pszNull = _T("");
        if (NULL != pDriverInfo)
        {
			TCHAR szPingVersion[] = _T("1");
			DWORD dwLength = 0;
			// Initialize version length
			dwLength += 1;
			dwLength += lstrlen(szPingVersion);
            // Initialize Length to 5 (4 characters plus the | delimeter)
            dwLength += 5;
            // Get the Length of the pszMostSpecificHWID
            dwLength++; // add 1 for the | delimeter for each Field, except for the last field
            if (NULL != pDriverInfo->pszMostSpecificHWID)
            {
                dwLength += lstrlen(pDriverInfo->pszMostSpecificHWID); // length
            }
            // Get the Length of the pszPreviousDriverVerDate
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousDriverVerDate)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousDriverVerDate);
            }
            // Get the Length of the pszPreviousDriverVerVersion
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousDriverVerVersion)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousDriverVerVersion);
            }
            // Get the length of the pszPreviousRank
            dwLength++;
			if (NULL != pDriverInfo->pszPreviousDriverRank)
			{
				dwLength += lstrlen(pDriverInfo->pszPreviousDriverRank);
			}
            // Get the length of the ulStatus
            dwLength++;
            dwLength += 10; // formatted Hex String '0x00000000' = 10 chars
            // Get the length of the ulProblemNumber
            dwLength++;
            dwLength += 10; // formatted Hex String '0x00000000' = 10 chars
            // Get the length of the pszPreviousProvider
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousProvider)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousProvider);
            }
            // Get the length of the pszPreviousManufacturer
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousManufacturer)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousManufacturer);
            }
            // Get the length of the pszPreviousDriverName
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousDriverName)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousDriverName);
            }
            // Get the length of the pszPreviousMatchingID
            // Last Field, so no | delimeter added, BUT we need to add for the \0 termination
            dwLength++;
            if (NULL != pDriverInfo->pszPreviousMatchingID)
            {
                dwLength += lstrlen(pDriverInfo->pszPreviousMatchingID);
            }

            //  Format: <ping version>|[dwPnPMatchCount]|[pszMostSpecificHWID]|[pszPreviousDriverVerDate]|[pszPreviousDriverVerVersion]|
            //  [pszPreviousDriverRank]|[ulStatus]|[ulProblemNumber]|[pszPreviousProvider]|[pszPreviousManufacturer]|
            //  [pszPreviousDriverName]|[pszPreviousMatchingID]
			//
			//  NOTE: <ping version> starts with '1' and increments when message format changes
			//
            pszMessage = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
            if (NULL != pszMessage)
            {
                hrTemp = StringCchPrintfEx(pszMessage, dwLength, NULL, NULL, MISTSAFE_STRING_FLAGS,
                    _T("%s|%d|%s|%s|%s|%s|%#x|%#x|%s|%s|%s|%s"),
					szPingVersion,
                    pDriverInfo->dwPnPMatchCount,
                    (NULL != pDriverInfo->pszMostSpecificHWID) ? pDriverInfo->pszMostSpecificHWID : pszNull,
                    (NULL != pDriverInfo->pszPreviousDriverVerDate) ? pDriverInfo->pszPreviousDriverVerDate : pszNull,
                    (NULL != pDriverInfo->pszPreviousDriverVerVersion) ? pDriverInfo->pszPreviousDriverVerVersion : pszNull,
                    (NULL != pDriverInfo->pszPreviousDriverRank) ? pDriverInfo->pszPreviousDriverRank : pszNull,
                    pDriverInfo->ulStatus,
                    pDriverInfo->ulProblemNumber,
                    (NULL != pDriverInfo->pszPreviousProvider) ? pDriverInfo->pszPreviousProvider : pszNull,
                    (NULL != pDriverInfo->pszPreviousManufacturer) ? pDriverInfo->pszPreviousManufacturer : pszNull,
                    (NULL != pDriverInfo->pszPreviousDriverName) ? pDriverInfo->pszPreviousDriverName : pszNull,
                    (NULL != pDriverInfo->pszPreviousMatchingID) ? pDriverInfo->pszPreviousMatchingID : pszNull);
                if (FAILED(hrTemp))
                {
                    SafeHeapFree(pszMessage); // If the Printf failed NULL the pointer so the Ping doesn't get an Empty String or Garbage
                }
            }
        }

        m_pingSvr.Ping(
                    fOnLine,                        // on-line
                    URLLOGDESTINATION_DEFAULT,      // going to live or corp WU server
                    phEvtNeedToQuit,                // pt to cancel events
                    1,                              // number of events
                    URLLOGACTIVITY_Installation,    // activity
                    status,                         // status code
                    hr,								// error code
                    OLE2T(bstrIdentity),            // itemID
                    lpszDeviceId,                   // add'l device data for driver update
                    pszMessage                      // add'l device driver status info or NULL
                    );

        SafeHeapFree(pszMessage);
    }

    SafeSysFreeString(bstrIdentity);
}

inline BOOL DeviceInstanceMatchesHWID(LPTSTR pMultiSZ, LPCTSTR pszHWID)
{
    LOG_Block("DeviceInstanceMatchesHWID");

    if (NULL == pMultiSZ || NULL == pszHWID || pszHWID[0] == 0)
    {
        //
        // Nothing to match to
        //
        return FALSE;
    }

    // Now need to find the passed in HWID in the supplied MultiSZ string
    LPCTSTR pszTemp = NULL;
    for(pszTemp = pMultiSZ; *pszTemp; pszTemp += (lstrlen(pszTemp) + 1))
    {
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            pszTemp, -1, pszHWID, -1))
        {
            // matched
            return TRUE;
        }
    }
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// GetMatchingInstallInfo()
//
// Determine if this Device Matches the HWID of the Device we are Installing
// Input:
// hDevInfoSet  - SetupDi Device Info Set
// pDevInfoData - SetupDi Device Info Data for the current Device
// pDriverInfo  - Driver Pre Install Info Structure will be filled out if the device matches
// pszHWID      - HWID of the Device we are Installing
// 
// Output:
// HRESULT and pDriverInfo Structure Filled out
// NOTE: Fields in pDriverInfo are allocated and need to be free'd by the caller.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetMatchingInstallInfo(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszHWID)
{
    LOG_Block("GetMatchingInstallInfo");

    HRESULT hr = S_FALSE;
    LPTSTR pszMultiHwid = NULL;
    LPTSTR pszMultiCompid = NULL;
    DWORD dwLength = 0;
    DWORD dwNeeded = 0;
    OSVERSIONINFO osvi;

    if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == pDevInfoData || NULL == pszHWID || pszHWID[0] == 0)
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }
    //
    // Get the Hardware and Compatible Multi-SZ strings
    //
    // Note that GetMultiSzDevRegProp may return S_OK and a NULL *ppMultiSZ if the SRDP doesn't exist.
    //
    CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_HARDWAREID, &pszMultiHwid));

    CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_COMPATIBLEIDS, &pszMultiCompid));

    if (DeviceInstanceMatchesHWID(pszMultiHwid, pszHWID) || DeviceInstanceMatchesHWID(pszMultiCompid, pszHWID))
    {
        //
        // This device instance matches the HWID we are going to install, so update pDriverInfo
        //
        if (0 == pDriverInfo->dwPnPMatchCount)
        {
            // Update the Count and Fill out the DriverInfo structure
            pDriverInfo->dwPnPMatchCount++;
            dwLength = lstrlen(pszMultiHwid) + 1;
            // Write out the HWID
            pDriverInfo->pszMostSpecificHWID = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
            CleanUpFailedAllocSetHrMsg(pDriverInfo->pszMostSpecificHWID);
            hr = StringCchCopyEx(pDriverInfo->pszMostSpecificHWID, dwLength, pszMultiHwid, NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                SafeHeapFree(pDriverInfo->pszMostSpecificHWID);
            }
            // Write out the Device Instance Id
			dwNeeded = 0;
            if (!SetupDiGetDeviceInstanceId(hDevInfoSet, pDevInfoData, NULL, 0, &dwNeeded)
				&& 0 != dwNeeded
				&& ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                pDriverInfo->pszDeviceInstance = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNeeded * sizeof(TCHAR));
                if (NULL != pDriverInfo->pszDeviceInstance)
                {
                    if (!SetupDiGetDeviceInstanceId(hDevInfoSet, pDevInfoData, pDriverInfo->pszDeviceInstance, dwNeeded, NULL))
                    {
                        SafeHeapFree(pDriverInfo->pszDeviceInstance);
                    }
                }
            }
            // Write out the Matching HWID
            hr = GetPropertyFromSetupDiReg(hDevInfoSet, *pDevInfoData, REGSTR_VAL_MATCHINGDEVID, &pDriverInfo->pszPreviousMatchingID);
            if (FAILED(hr))
            {
				//
				// No REGSTR_VAL_MATCHINGDEVID so there is no driver installed. This is not an error.
				//
                SafeHeapFree(pDriverInfo->pszPreviousMatchingID);
				hr = S_OK;
            }
			else
			{
				//
				// Get as much additional data about the installed driver as possible, but don't fail
				//

				// Write out the Provider
				hr = GetPropertyFromSetupDiReg(hDevInfoSet, *pDevInfoData, REGSTR_VAL_PROVIDER_NAME, &pDriverInfo->pszPreviousProvider);
				if (FAILED(hr))
				{
					SafeHeapFree(pDriverInfo->pszPreviousProvider);
				}
				// Write out the Manufacturer
				hr = GetPropertyFromSetupDi(hDevInfoSet, *pDevInfoData, SPDRP_MFG, &pDriverInfo->pszPreviousManufacturer);
				if (FAILED(hr))
				{
					SafeHeapFree(pDriverInfo->pszPreviousManufacturer);
				}
				// Write out the Driver Date
				hr = GetPropertyFromSetupDiReg(hDevInfoSet, *pDevInfoData, REGSTR_VAL_DRIVERDATE, &pDriverInfo->pszPreviousDriverVerDate);
				if (FAILED(hr))
				{
					SafeHeapFree(pDriverInfo->pszPreviousDriverVerDate);
				}
				// Write out the Driver Version
				hr = GetPropertyFromSetupDiReg(hDevInfoSet, *pDevInfoData, REGSTR_VAL_DRIVERVERSION, &pDriverInfo->pszPreviousDriverVerVersion);
				if (FAILED(hr))
				{
					SafeHeapFree(pDriverInfo->pszPreviousDriverVerVersion);
				}
				// Write out the Rank of the Previous Driver
				ZeroMemory(&osvi, sizeof(osvi));
				osvi.dwOSVersionInfoSize = sizeof(osvi);
				GetVersionEx(&osvi);
				if (6 <= osvi.dwMajorVersion || (5 <= osvi.dwMajorVersion && 1 <= osvi.dwMinorVersion))
				{
					SP_DEVINSTALL_PARAMS DeviceInstallParams;
					SP_DRVINFO_DATA DriverInfoData;
					SP_DRVINSTALL_PARAMS DriverInstallParams;

					DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
					if (!SetupDiGetDeviceInstallParams(hDevInfoSet, pDevInfoData, &DeviceInstallParams))
					{
						goto SkipSignedCheck;
					}

					//
					// Set the following flags:
					//  - DI_FLAGSEX_INSTALLEDDRIVER - just get the installed driver.
					//  - DI_FLAGSEX_ALLOWEXCLUDEDRVS - allow excluded drivers.
					//
					DeviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);
					if (!SetupDiSetDeviceInstallParams(hDevInfoSet, pDevInfoData, &DeviceInstallParams))
					{
						goto SkipSignedCheck;
					}

					//
					// Build the list of drivers that contains just the installed driver.
					//
					if (!SetupDiBuildDriverInfoList(hDevInfoSet, pDevInfoData, SPDIT_COMPATDRIVER))
					{
						goto SkipSignedCheck;
					}

					//
					// There should only be one driver in the list, so select it (index 0).
					//
					DriverInfoData.cbSize = sizeof(DriverInfoData);
					if (!SetupDiEnumDriverInfo(hDevInfoSet, pDevInfoData, SPDIT_COMPATDRIVER, 0, &DriverInfoData))
					{
						goto SkipSignedCheck;
					}

					//
					// Get the SP_DRVINSTALL_PARAMS structure, which contains the rank.
					//
					DriverInstallParams.cbSize = sizeof(DriverInstallParams);
					if (!SetupDiGetDriverInstallParams(hDevInfoSet, pDevInfoData, &DriverInfoData, &DriverInstallParams))
					{
						goto SkipSignedCheck;
					}

					//
					// Cache the rank
					//
					const DWORD MAX_DWORD_HEX_CHARS = 11;	// "0x00000000 + NULL"
					pDriverInfo->pszPreviousDriverRank = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_DWORD_HEX_CHARS * sizeof(TCHAR));
					if (NULL != pDriverInfo->pszPreviousDriverRank)
					{
						if (FAILED(StringCchPrintfEx(pDriverInfo->pszPreviousDriverRank, MAX_DWORD_HEX_CHARS, NULL, NULL,\
							MISTSAFE_STRING_FLAGS, _T("%#x"), DriverInstallParams.Rank)))
						{
							SafeHeapFree(pDriverInfo->pszPreviousDriverRank);
						}
					}
						
SkipSignedCheck:
					NULL;
				}
			}
        }
        else
        {
            // just update the count, we already cached info on the first instance
            pDriverInfo->dwPnPMatchCount++;
        }
    }
CleanUp:
    SafeHeapFree(pszMultiHwid);
    SafeHeapFree(pszMultiCompid);
    return hr;
}

HRESULT CacheInstalledPrinterDriverInfo(PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszDriverName, LPCTSTR pszHWID, LPCTSTR pszManufacturer, LPCTSTR pszProvider)
{
    LOG_Block("CacheInstalledPrinterDriverInfo");
    HRESULT hr = S_FALSE;
	HRESULT hrTemp = S_OK;
    if (NULL == pDriverInfo || NULL == pszDriverName || NULL == pszHWID || NULL == pszManufacturer || NULL == pszProvider)
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }

    DWORD dwBytesNeeded, dwDriverCount, dwLength;
    DRIVER_INFO_6 *pDriverInfo6 = NULL;

	LPTSTR pszEnvironment;
    OSVERSIONINFO osvi;
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osvi))
    {
        // can't determine the OS, so can't call Enum Printer Drivers, nothing to do here.
        CleanUpIfFailedAndSetHrMsg(HRESULT_FROM_WIN32(GetLastError()));
    }
	if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId)
	{
		//
		// Don't pass an environment string for Win9x
		//
		pszEnvironment = NULL;
	}
	else if (5 <= osvi.dwMajorVersion && 1 <= osvi.dwMinorVersion)
	{
		//
		// Use EPD_ALL_LOCAL_AND_CLUSTER only on Whistler and up
		//
		pszEnvironment = EPD_ALL_LOCAL_AND_CLUSTER;
	}
	else
	{
		//
		// From V3 sources (hard-coded for NT)
		//
		pszEnvironment = _T("all");
	}
    if (!EnumPrinterDrivers(NULL, pszEnvironment, 6, NULL, 0, &dwBytesNeeded, &dwDriverCount))
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError() || (0 == dwBytesNeeded))
        {
            LOG_Driver(_T("No printer drivers enumerated"));
        }
        else
        {
            //
            // Allocate the requested buffer
            //
            CleanUpFailedAllocSetHrMsg(pDriverInfo6 = (DRIVER_INFO_6*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytesNeeded));
            
            // Fill out the DriverInfo6 Array
            if (!EnumPrinterDrivers(NULL, pszEnvironment, 6, (LPBYTE)pDriverInfo6, dwBytesNeeded, &dwBytesNeeded, &dwDriverCount))
            {
                CleanUpIfFailedAndSetHrMsg(HRESULT_FROM_WIN32(GetLastError()));
            }

            hr = S_FALSE; // init to no printer found
            // Find the specified Printer Driver Name, HWID, Manufacturer and Provider in the Device Info 6 Array
            for (DWORD dwCount = 0; dwCount < dwDriverCount; dwCount++)
            {
                if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
                    pszDriverName, -1, pDriverInfo6[dwCount].pName, -1))
                {
                    // does not match, skip to next Printer
                    continue;
                }
                // does match, now try to match the rest, any of them doesn't match means not the same printer driver
                if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
                    pszHWID, -1, pDriverInfo6[dwCount].pszHardwareID, -1))
                {
                    continue;
                }
                if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
                    pszManufacturer, -1, pDriverInfo6[dwCount].pszMfgName, -1))
                {
                    continue;
                }
                if (CSTR_EQUAL != CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
                    pszProvider, -1, pDriverInfo6[dwCount].pszProvider, -1))
                {
                    continue;
                }
                // if we get here, we found a matching printer driver
                hr = S_OK;
                // save the information in the DriverInfo structure
                if (0 == pDriverInfo->dwPnPMatchCount)
                {
                    pDriverInfo->dwPnPMatchCount++;
                    // Save the DriverName(Model)
                    dwLength = lstrlen(pszDriverName) + 1;
                    pDriverInfo->pszPreviousDriverName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszPreviousDriverName)
                    {
                        hrTemp = StringCchCopyEx(pDriverInfo->pszPreviousDriverName, dwLength, pszDriverName, NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszPreviousDriverName);
                        }
                    }
                    // Save the HWID
                    dwLength = lstrlen(pszHWID) + 1;
                    pDriverInfo->pszMostSpecificHWID = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszMostSpecificHWID)
                    {
                        hrTemp = StringCchCopyEx(pDriverInfo->pszMostSpecificHWID, dwLength, pszHWID, NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszMostSpecificHWID);
                        }
                    }
                    // Save the Provider
                    dwLength = lstrlen(pszProvider) + 1;
                    pDriverInfo->pszPreviousProvider = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszPreviousProvider)
                    {
                        hrTemp = StringCchCopyEx(pDriverInfo->pszPreviousProvider, dwLength, pszProvider, NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszPreviousProvider);
                        }
                    }
                    // Save the Manufacturer
                    dwLength = lstrlen(pszManufacturer) + 1;
                    pDriverInfo->pszPreviousManufacturer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszPreviousManufacturer)
                    {
                        hrTemp = StringCchCopyEx(pDriverInfo->pszPreviousManufacturer, dwLength, pszManufacturer, NULL, NULL, MISTSAFE_STRING_FLAGS);
                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszPreviousManufacturer);
                        }
                    }
                    // Save the Driver Date
                    SYSTEMTIME st;
                    ZeroMemory(&st, sizeof(SYSTEMTIME));
                    dwLength = 32; // Maximum Length for a Date String (00-00-0000)
                    pDriverInfo->pszPreviousDriverVerDate = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszPreviousDriverVerDate)
                    {
                        if (!FileTimeToSystemTime(&pDriverInfo6[dwCount].ftDriverDate, &st))
                        {
                            // use 00-00-0000 as the date
                            hrTemp = StringCchCopyEx(pDriverInfo->pszPreviousDriverVerDate, dwLength, _T("00-00-0000"), NULL, NULL, MISTSAFE_STRING_FLAGS);
                        }
                        else
                        {
                            hrTemp = StringCchPrintfEx(pDriverInfo->pszPreviousDriverVerDate, dwLength, NULL, NULL, MISTSAFE_STRING_FLAGS,
                                _T("%02d-%02d-%d"), st.wMonth, st.wDay, st.wYear);
                        }
                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszPreviousDriverVerDate);
                        }
                    }
                    // Save the Driver Version
                    dwLength = 32; // Maximum Length for a Driver Version String (xxxx.xxxx.xxxx.xxxx)
                    pDriverInfo->pszPreviousDriverVerVersion = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength * sizeof(TCHAR));
                    if (NULL != pDriverInfo->pszPreviousDriverVerVersion)
                    {
                        // Cast the DWORDLONG to a WORD * so we can access it as a WORD array
                        WORD *pwVersion = (WORD *)&pDriverInfo6[dwCount].dwlDriverVersion;
                        hrTemp = StringCchPrintfEx(pDriverInfo->pszPreviousDriverVerVersion, dwLength, NULL, NULL, MISTSAFE_STRING_FLAGS,
                            _T("%d.%d.%d.%d"), 
                            pwVersion[3],
                            pwVersion[2],
                            pwVersion[1],
                            pwVersion[0]);

                        if (FAILED(hrTemp))
                        {
                            SafeHeapFree(pDriverInfo->pszPreviousDriverVerVersion);
                        }
                    }
                }
                else
                {
                    pDriverInfo->dwPnPMatchCount++;
                }
            }
        }
    }
CleanUp:
    SafeHeapFree(pDriverInfo6);
    return hr;
}

HRESULT CachePnPInstalledDriverInfo(PDRIVERPREINSTALLINFO pDriverInfo, LPCTSTR pszHWID)
{
    LOG_Block("CachePnPInstalledDriverInfo");

    DWORD dwDeviceIndex = 0;
    HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA devInfoData;
    HRESULT hr = S_FALSE;

    if (NULL == pDriverInfo || NULL == pszHWID || pszHWID[0] == 0)
    {
        CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
    }

    if (INVALID_HANDLE_VALUE == (hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES)))
    {
        LOG_Error(_T("SetupDiGetClassDevs failed: 0x%08x"), GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
    devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    while (SetupDiEnumDeviceInfo(hDevInfoSet, dwDeviceIndex++, &devInfoData))
    {
        CleanUpIfFailedAndSetHr(GetMatchingInstallInfo(hDevInfoSet, &devInfoData, pDriverInfo, pszHWID));
    }

CleanUp:
    if (INVALID_HANDLE_VALUE != hDevInfoSet)
    {
        if (0 == SetupDiDestroyDeviceInfoList(hDevInfoSet))
        {
            LOG_Driver(_T("Warning: SetupDiDestroyDeviceInfoList failed: 0x%08x"), GetLastError());
        }
    }

    return hr;
}

HRESULT GetPnPInstallStatus(PDRIVERPREINSTALLINFO pDriverInfo)
{
    LOG_Block("GetPnPInstallStatus");

    if (NULL == pDriverInfo || NULL == pDriverInfo->pszDeviceInstance)
    {
        return E_INVALIDARG;
    }
    DEVINST hDevInst;
    if (CR_SUCCESS == CM_Locate_DevNode(&hDevInst, pDriverInfo->pszDeviceInstance, CM_LOCATE_DEVNODE_NORMAL))
    {
        (void)CM_Get_DevNode_Status(&pDriverInfo->ulStatus, &pDriverInfo->ulProblemNumber, hDevInst, 0);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\history.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   History.CPP
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//  Description:
//
//      Class to handle history log
//
//=======================================================================


#include "iuengine.h"
#include <iucommon.h>
#include <fileutil.h>
#include <StringUtil.h>
#include <shlwapi.h>	// for PathAppend() API
#include "history.h"

const TCHAR C_V3_LOG_FILE[]			= _T("wuhistv3.log");
const TCHAR C_LOG_FILE[]			= _T("iuhist.xml");
const TCHAR C_LOG_FILE_CORP[]		= _T("iuhist_catalog.xml");
const TCHAR C_LOG_FILE_CORP_ADMIN[]	= _T("iuhist_catalogAdmin.xml");
const OLECHAR	C_IU_CORP_SITE[]	= L"IU_CORP_SITE";
const OLECHAR	C_HISTORICALSPEED[]	= L"GetHistoricalSpeed";

//
// we use a global mutex name to let all clients, including services
// on terminal servers gain exclusive access for updating history on disk
//
#if defined(UNICODE) || defined(_UNICODE)
const TCHAR C_MUTEX_NAME[] = _T("Global\\6D7495AB-399E-4768-89CC-9444202E8412");
#else
const TCHAR C_MUTEX_NAME[] = _T("6D7495AB-399E-4768-89CC-9444202E8412");
#endif

#define CanSaveHistory					(NULL != m_hMutex)
#define ReturnFailedAllocSetHrMsg(x)	{if (NULL == (x)) {hr = E_OUTOFMEMORY; LOG_ErrorMsg(hr); return hr;}}



CIUHistory::CIUHistory()
 : m_pszDownloadBasePath(NULL),
   m_bstrCurrentClientName(NULL)
{
	LOG_Block("CIUHisotry::CIUHistory()");

	m_pxmlExisting = new CXmlItems(TRUE);
	m_pxmlDownload = new CXmlItems(FALSE);
	m_pxmlInstall = new CXmlItems(FALSE);

	m_hMutex = CreateMutex(
						   NULL,	// no security descriptor
						   FALSE,	// mutex object not owned, yet
						   C_MUTEX_NAME
						   );
	if (NULL == m_hMutex)
	{
		DWORD dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		m_ErrorCode = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
		LOG_Out(_T("Mutex created okay"));
		m_ErrorCode = S_OK;
	}

	m_fSavePending = FALSE;
}



CIUHistory::~CIUHistory()
{
	if (m_fSavePending)
	{
		SaveHistoryToDisk();
	}

	if (CanSaveHistory)
	{
		CloseHandle(m_hMutex);
	}

	if (NULL != m_pxmlExisting)
	{
		delete m_pxmlExisting;
	}

	if (NULL != m_pxmlDownload)
	{
		delete m_pxmlDownload;
	}

	if (NULL != m_pxmlInstall)
	{
		delete m_pxmlInstall;
	}

	SafeHeapFree(m_pszDownloadBasePath);
	SysFreeString(m_bstrCurrentClientName);
}



// ------------------------------------------------------------------
//
// public function SetDownloadBasePath()
//	this function should be called before AddHistoryItemDownloadStatus()
//	for corporate case to set the download path that the user has input,
//	so that we know where to save the history log.
//	
// ------------------------------------------------------------------
HRESULT CIUHistory::SetDownloadBasePath(LPCTSTR pszDownloadedBasePath)
{
	LOG_Block("SetDownloadBasePath()");

	if (NULL != pszDownloadedBasePath)
	{
        HRESULT hr = S_OK;
	    
		if (NULL != m_pszDownloadBasePath)
		{
			//
			// most likely user called SetDownloadBasePath() at least twice
			// within the same instance of this class
			//
			SafeHeapFree(m_pszDownloadBasePath);
		}

		
		m_pszDownloadBasePath = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof (TCHAR));
		if (NULL == m_pszDownloadBasePath)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			return E_OUTOFMEMORY;
		}

		hr = StringCchCopyEx(m_pszDownloadBasePath, MAX_PATH,  pszDownloadedBasePath,
		                     NULL, NULL, MISTSAFE_STRING_FLAGS);
		if (FAILED(hr))
		{
		    SafeHeapFree(m_pszDownloadBasePath);
		    LOG_ErrorMsg(hr);
		    return hr;
		}
		
		BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
		SetClientName(bstrCorpSite);
		SafeSysFreeString(bstrCorpSite);
	}
	return S_OK;
}
	

	
// ------------------------------------------------------------------
//
// public function AddHistoryItemDownloadStatus()
//	this function should be called when you want to record the
//	download status of this item. A new history item will be
//	added to the history file
//	
// ------------------------------------------------------------------
HRESULT CIUHistory::AddHistoryItemDownloadStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enDownloadStatus,
			LPCTSTR lpcszDownloadedTo,
			LPCTSTR lpcszClient,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("AddHistoryItemDownloadStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hDownloadItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlDownload);

	if (NULL == lpcszClient || _T('\0') == lpcszClient[0])
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrDownloadedTo = NULL;
	BSTR bstrClient = T2BSTR(lpcszClient);
	BSTR bstrDownloadStatus = GetBSTRStatus(enDownloadStatus);

	//
	// append a new node
	//
	hr = m_pxmlDownload->AddItem(pCatalog, hCatalogItem, &hDownloadItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlDownload->AddTimeStamp(hDownloadItem);
		if (0 != dwErrorCode)
		{
			m_pxmlDownload->AddDownloadStatus(hDownloadItem, bstrDownloadStatus, dwErrorCode);
		}
		else
		{
			m_pxmlDownload->AddDownloadStatus(hDownloadItem, bstrDownloadStatus);
		}

		bstrDownloadedTo = T2BSTR(lpcszDownloadedTo);
		m_pxmlDownload->AddDownloadPath(hDownloadItem, bstrDownloadedTo);
		m_pxmlDownload->AddClientInfo(hDownloadItem, bstrClient);
		m_pxmlDownload->CloseItem(hDownloadItem);

		m_fSavePending = TRUE;
	}

	SetClientName(bstrClient);
	SysFreeString(bstrDownloadedTo);
	SysFreeString(bstrClient);
	SysFreeString(bstrDownloadStatus);
	return hr;
}
			


// ------------------------------------------------------------------
//
// public function AddHistoryItemInstallStatus()
//	this function should be called when you want to record the
//	install status of this item. This function will go to the
//	existing history tree and find the first item that matches
//	the identity of hCatalogItem, and assume that one as 
//	the one you want to modify the install status
//	
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::AddHistoryItemInstallStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enInstallStatus,
			LPCTSTR lpcszClient,
			BOOL fNeedsReboot,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("AddHistoryItemInstallStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hInstallItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrClient = NULL;
	BSTR bstrInstallStatus = GetBSTRStatus(enInstallStatus);
	//
	// append a new node
	//
	hr = m_pxmlInstall->AddItem(pCatalog, hCatalogItem, &hInstallItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlInstall->AddTimeStamp(hInstallItem);
		if (0 != dwErrorCode)
		{
			m_pxmlInstall->AddInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot, dwErrorCode);
		}
		else
		{
			m_pxmlInstall->AddInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot);
		}
		bstrClient = T2BSTR(lpcszClient);
		m_pxmlInstall->AddClientInfo(hInstallItem, bstrClient);
		m_pxmlInstall->CloseItem(hInstallItem);
	
		m_fSavePending = TRUE;
	}

	SysFreeString(bstrClient);
	SysFreeString(bstrInstallStatus);
	return hr;
}



// ------------------------------------------------------------------
//
// public function UpdateHistoryItemInstallStatus()
//	this function should be called when you want to record the
//	install status of this item. This function will go to the
//	existing history tree and find the first item that matches
//	the identity of hCatalogItem, and assume that one as 
//	the one you want to modify the install status
//	
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::UpdateHistoryItemInstallStatus(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			_HISTORY_STATUS enInstallStatus,
			BOOL fNeedsReboot,
			DWORD dwErrorCode /*= 0*/
)
{
    LOG_Block("UpdateHistoryItemInstallStatus()");

	HRESULT	hr	= S_OK;

    HANDLE_NODE hInstallItem = HANDLE_NODE_INVALID;

	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	BSTR bstrInstallStatus = GetBSTRStatus(enInstallStatus);
	//
	// append a new node
	//
	hr = m_pxmlInstall->FindItem(pCatalog, hCatalogItem, &hInstallItem);
	if (SUCCEEDED(hr))
	{
		m_pxmlInstall->AddTimeStamp(hInstallItem);
		if (0 != dwErrorCode)
		{
			m_pxmlInstall->UpdateItemInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot, dwErrorCode);
		}
		else
		{
			m_pxmlInstall->UpdateItemInstallStatus(hInstallItem, bstrInstallStatus, fNeedsReboot);
		}
		m_pxmlInstall->CloseItem(hInstallItem);
	
		m_fSavePending = TRUE;
	}

	SysFreeString(bstrInstallStatus);
	return hr;
}



/*
// ------------------------------------------------------------------
//
// public function RetrieveItemDownloadPath()
//	this function will go to the existing history tree and find
//  the first item that matches the identity of hCatalogItem, and
//  assume that's the one you want to retrieve the download path from
//
// return:
//		HRESULT - S_OK if succeeded
//				- E_HANDLE if can't find hCatalogItem from 
//				  the current history log tree
//				- or other HRESULT error
//
// ------------------------------------------------------------------
HRESULT CIUHistory::RetrieveItemDownloadPath(
			CXmlCatalog* pCatalog, 
			HANDLE_NODE hCatalogItem,	// a handle points to node in catalog
			BSTR* pbstrDownloadPath
)
{
	HRESULT	hr = S_OK;

	if (NULL == m_Existing.'DocumentPtr())
	{
		//
		// need to read the existing history
		//
		WaitForSingleObject(m_hMutex, INFINITE);

		hr = ReadHistoryFromDisk(NULL);
		if (FAILED(hr))
		{
			//
			// if we can't load the existing history
			// we can't do anything here
			//
			ReleaseMutex(m_hMutex);
			return hr;
		}

		ReleaseMutex(m_hMutex);
	}

	hr = m_Existing.GetItemDownloadPath(pCatalog, hCatalogItem, pbstrDownloadPath);
	return hr;
}		
*/	
			
			
// ------------------------------------------------------------------
//
// public function ReadHistoryFromDisk()
//	this function will read the history from the given file
//
// if the file path is NULL, assumes default IU log file locally
//
// ------------------------------------------------------------------
HRESULT CIUHistory::ReadHistoryFromDisk(LPCTSTR lpszLogFile, BOOL fCorpAdmin /*= FALSE*/)
{
	LOG_Block("ReadHistoryFromDisk()");

	HRESULT hr = S_OK;
	TCHAR szLogPath[MAX_PATH];

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);

	//
	// check to see if we use designated path (comsumer)
	// or user-specified path (corporate)
	//
	if ((NULL == lpszLogFile || _T('\0') == lpszLogFile[0]) && !fCorpAdmin)
	{
		GetIndustryUpdateDirectory(szLogPath);
		hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE);
		if (FAILED(hr))
		{
		    LOG_ErrorMsg(hr);
		    return hr;
		}
	}
	else
	{
		//
		// this is corporate case to read log file from
		// a server location
		//
		if (fCorpAdmin)
		{
			GetIndustryUpdateDirectory(szLogPath);
			hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE_CORP_ADMIN);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
		}
		else
		{
			hr = StringCchCopyEx(szLogPath, ARRAYSIZE(szLogPath), lpszLogFile, 
			                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
			
			hr = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_LOG_FILE_CORP);
    		if (FAILED(hr))
    		{
    		    LOG_ErrorMsg(hr);
    		    return hr;
    		}
		}
	}

	//
	// if we are not passing in the class file path buffer,
	// then update the class path buffer with this new path
	//
	if (szLogPath != m_szLogFilePath)
	{
	    hr = StringCchCopyEx(m_szLogFilePath, ARRAYSIZE(m_szLogFilePath), szLogPath,
	                         NULL, NULL, MISTSAFE_STRING_FLAGS);
	    if (FAILED(hr))
	    {
		    LOG_ErrorMsg(hr);
		    return hr;
	    }
	}

	//
	// load the xml file
	//
	m_pxmlExisting->Clear();
	
	BSTR bstrLogPath = T2BSTR(szLogPath);
	hr = m_pxmlExisting->LoadXMLDocumentFile(bstrLogPath);
	SysFreeString(bstrLogPath);
		
	return hr;
}



// ------------------------------------------------------------------
//
// public function SaveHistoryToDisk()
//	this function will re-read the history in exclusive mode, and
//	merge the newly added data to the tree (so we don't overwrite
//	new changes made by other instances of this control) and
//	write it back 
//
// ------------------------------------------------------------------
HRESULT CIUHistory::SaveHistoryToDisk(void)
{
	LOG_Block("SaveHistoryToDisk()");

	HRESULT	hr = S_OK, hr2 = S_OK;
	BSTR bstrLogFilePath = NULL;

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);
	ReturnFailedAllocSetHrMsg(m_pxmlDownload);
	ReturnFailedAllocSetHrMsg(m_pxmlInstall);

	if (!CanSaveHistory)
	{
		return m_ErrorCode;
	}

	if (!m_fSavePending)
	{
		//
		// nothing to save
		//
		return S_OK;
	}

	//
	// first, we need to gain exclusive access
	// to the log file before reading it
	//
	// since this is not a long process, so I 
	// don't think we need to take care of WM_QUIT
	// message
	//
	WaitForSingleObject(m_hMutex, INFINITE);

	BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
	ReturnFailedAllocSetHrMsg(bstrCorpSite);

	if (!CompareBSTRsEqual(bstrCorpSite, m_bstrCurrentClientName))
	{
		SysFreeString(bstrCorpSite);
		//
		// re-read history file
		//
		hr = ReadHistoryFromDisk(NULL);

		//
		// comment out...if we get failure on reading, 
		// we recreate a new history file later when saving.
		//
		//if (FAILED(hr))
		//{
		//	//
		//	// if we can't load the existing history
		//	// we can't do anything here
		//	//
		//	ReleaseMutex(m_hMutex);
		//	return hr;
		//}

		//
		// merge changes:
		// 
		// loop through m_Download, insert each node to top of m_Existing
		//
		hr = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
		if (FAILED(hr))
		{
			ReleaseMutex(m_hMutex);
			return hr;
		}

		//
		// loop through m_Install, for each node in m_Install
		// find the one in m_Existing, update install status
		//
		hr = m_pxmlExisting->UpdateItemInstalled(m_pxmlInstall);
		if (FAILED(hr))
		{
			ReleaseMutex(m_hMutex);
			return hr;
		}

		//
		// save the xml file
		//
		bstrLogFilePath = T2BSTR(m_szLogFilePath);
		hr = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
		SafeSysFreeString(bstrLogFilePath);
		if (SUCCEEDED(hr))
		{
			m_fSavePending = FALSE;
		}
	}
	else
	{
		//
		// this is the corporate case...
		//
		SysFreeString(bstrCorpSite);
		if (NULL != m_pszDownloadBasePath && _T('\0') != m_pszDownloadBasePath[0])
		{
			//
			// re-read corp history from download base folder
			//
			ReadHistoryFromDisk(m_pszDownloadBasePath);

			//
			// merge new items downloaded
			// 
			hr = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
			if (FAILED(hr))
			{
				ReleaseMutex(m_hMutex);
				return hr;
			}

			//
			// save the xml file
			//
			bstrLogFilePath = T2BSTR(m_szLogFilePath);
			hr = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
			SafeSysFreeString(bstrLogFilePath);
		}
		//
		// re-read corp admin history from windowsupdate folder
		//
		ReadHistoryFromDisk(m_pszDownloadBasePath, TRUE);

		//
		// merge new items downloaded
		// 
		hr2 = m_pxmlExisting->MergeItemDownloaded(m_pxmlDownload);
		if (FAILED(hr2))
		{
			ReleaseMutex(m_hMutex);
			return hr2;
		}

		//
		// save the xml file
		//
		bstrLogFilePath = T2BSTR(m_szLogFilePath);
		hr2 = m_pxmlExisting->SaveXMLDocument(bstrLogFilePath);
		SafeSysFreeString(bstrLogFilePath);
		if (SUCCEEDED(hr) && SUCCEEDED(hr2))
		{
			m_fSavePending = FALSE;
		}
	}

	ReleaseMutex(m_hMutex);
	SysFreeString(bstrLogFilePath);
	hr = SUCCEEDED(hr) ? hr2 : hr;
	return hr;
}



// ------------------------------------------------------------------
//
// public function to set the client name 
//
//	a client name is used to put in history to denode who
//	caused download/install happened.
//
// ------------------------------------------------------------------
void CIUHistory::SetClientName(BSTR bstrClientName)
{
	if (NULL != m_bstrCurrentClientName)
	{
		SysFreeString(m_bstrCurrentClientName);
		m_bstrCurrentClientName = NULL;
	}
	if (NULL != bstrClientName)
	{
		m_bstrCurrentClientName = SysAllocString(bstrClientName);
	}
}



// ------------------------------------------------------------------
//
// public function GetHistory
//
//	read the current history XML file and convert it
//	into bstr to pass out
//
// ------------------------------------------------------------------
HRESULT CIUHistory::GetHistoryStr(
				LPCTSTR lpszLogFile,
				BSTR BeginDateTime, 
				BSTR EndDateTime, 
				BSTR* pbstrHistory)
{
	LOG_Block("GetHistoryStr()");

	HRESULT	hr	= S_OK;

	ReturnFailedAllocSetHrMsg(m_pxmlExisting);

	//
	// need to read the existing history
	//
	WaitForSingleObject(m_hMutex, INFINITE);

	BSTR bstrCorpSite = SysAllocString(C_IU_CORP_SITE);
	if (bstrCorpSite == NULL)
	{
	    hr = E_OUTOFMEMORY;
	    goto done;
	}

	if (CompareBSTRsEqual(bstrCorpSite, m_bstrCurrentClientName))
	{
		TCHAR szLogPath[MAX_PATH];
	    TCHAR szLogFileParam[MAX_PATH];

        if (lpszLogFile != NULL && lpszLogFile[0] != _T('\0'))
        {
    	    hr = StringCchCopyEx(szLogFileParam, ARRAYSIZE(szLogFileParam), lpszLogFile, 
    	                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    	    if (FAILED(hr))
    	    {
    	        LOG_ErrorMsg(hr);
    	        goto done;
    	    }

    	    hr = PathCchAddBackslash(szLogFileParam, ARRAYSIZE(szLogFileParam));
    	    if (FAILED(hr))
    	    {
    	        LOG_ErrorMsg(hr);
    	        goto done;
    	    }
        }
        else
        {
            szLogFileParam[0] = _T('\0');
        }
	    
		//
		// corporate case
		//
		GetIndustryUpdateDirectory(szLogPath);
		if (_T('\0') == szLogFileParam[0] || !lstrcmpi(szLogPath, szLogFileParam))
		{
			// corp admin history
			hr = ReadHistoryFromDisk(szLogPath, TRUE);
		}
		else
		{
			// corp history
			hr = ReadHistoryFromDisk(lpszLogFile);
		}
	}
	else
	{
	    HRESULT hrAppend;
		//
		// consumer case
		//
		hr = ReadHistoryFromDisk(NULL);

		//
		// migrate V3 history to iuhist.xml
		// - if succeeded, save the updated iuhist.xml file and delete wuhistv3.log
		// - if failed, just log error and keep using the current iuhist.xml
		//
		TCHAR szLogPath[MAX_PATH];
		GetWindowsUpdateV3Directory(szLogPath);
		hrAppend = PathCchAppend(szLogPath, ARRAYSIZE(szLogPath), C_V3_LOG_FILE);
		if (FAILED(hrAppend))
		{
		    LOG_ErrorMsg(hrAppend);
		    if (SUCCEEDED(hr))
		        hr = hrAppend;
		    goto done;
		}

		if (0xffffffff != GetFileAttributes(szLogPath))
		{
			// V3 history file "wuhistv3.log" exists, so start migration
			if (FAILED(m_pxmlExisting->MigrateV3History(szLogPath)))
			{
				LOG_Out(_T("Failed to migrate v3 consumer history"));
			}
			else
			{
				BSTR bstrLogFilePath = T2BSTR(m_szLogFilePath);
				if (FAILED(m_pxmlExisting->SaveXMLDocument(bstrLogFilePath)))
				{
					LOG_Out(_T("Failed to save the updated history file %s"), m_szLogFilePath);
				}
				else
				{
					DeleteFile(szLogPath);
				}
				SafeSysFreeString(bstrLogFilePath);
			}
		}
	}

done:
	ReleaseMutex(m_hMutex);
	SafeSysFreeString(bstrCorpSite);

	if (FAILED(hr))
	{
		//
		// if we can't load the existing history
		// we can't do anything here. Return empty string.
		//
		*pbstrHistory = SysAllocString(L"");
		LOG_Out(_T("Loading the history xml file failed"));
		return S_FALSE;
	}

	// 
	// traverse history tree, inspect each node
	// to see if time/clientName fit. If not, delete it
	// then output the string
	//
	hr = m_pxmlExisting->GetFilteredHistoryBSTR(BeginDateTime, EndDateTime, m_bstrCurrentClientName, pbstrHistory);

	return hr;
}



// *****************************************************************
//
// IUENGINE.DLL Public API:
//
// *****************************************************************

HRESULT WINAPI CEngUpdate::GetHistory(
	BSTR		bstrDateTimeFrom,
	BSTR		bstrDateTimeTo,
	BSTR		bstrClient,
	BSTR		bstrPath,
	BSTR*		pbstrLog)
{
	LOG_Block("GetHistory()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;
	BSTR		bsStart = NULL;
	BSTR		bsEnd = NULL;
	CIUHistory	cHistory;

	//
	// first, check to see if this is to ask historical speed
	//
	if (NULL != bstrClient && lstrcmpiW(C_HISTORICALSPEED, (LPWSTR)((LPOLESTR) bstrClient)) == 0)
	{
		HKEY	hKey = NULL;
		TCHAR	szSpeed[32];
		DWORD	dwSpeed = 0x0;
		DWORD	dwSize = sizeof(dwSpeed);
		LONG	lResult = ERROR_SUCCESS;

		//
		// get speed here from reg; if failure, dwSpeed remains to be 0.
		//	
		if (ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hKey)))
		{
			lResult = RegQueryValueEx(hKey, REGVAL_HISTORICALSPEED, NULL, NULL, (LPBYTE)&dwSpeed, &dwSize);
			RegCloseKey(hKey);

			if (ERROR_SUCCESS != lResult)
			{
				*pbstrLog = SysAllocString(L"0");
				LOG_Out(_T("GetHistoricalSpeed registry key not found, it must be no downloads happened yet"));
				return hr;
			}
		}
		else
		{
			*pbstrLog = SysAllocString(L"0");
			LOG_ErrorMsg((DWORD)lResult);
			return hr;
		}

		hr = StringCchPrintfEx(szSpeed, ARRAYSIZE(szSpeed), NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("%d"), dwSpeed);
		if (FAILED(hr))
		{
		    *pbstrLog = SysAllocString(L"0");
		    LOG_ErrorMsg(hr);
		    return hr;
		}
		*pbstrLog = SysAllocString(T2OLE(szSpeed));
	
		LOG_Out(_T("GetHistoricalSpeed get called! Return value %s"), szSpeed);
		return hr;
	}

	//
	// really asking history log
	//

	//
	// set the client name
	//
	if (NULL != bstrClient && SysStringLen(bstrClient) > 0)
	{
		LOG_Out(_T("Set client name as %s"), OLE2T(bstrClient));
		cHistory.SetClientName(bstrClient);
	}
	else
	{
		LOG_Out(_T("Set client name as NULL"));
		cHistory.SetClientName(NULL);
	}

	//
	// for script: they may pass empty string. we treat them
	// as NULL
	//
	if (NULL != bstrDateTimeFrom && SysStringLen(bstrDateTimeFrom) > 0)
	{
		LOG_Out(_T("DateTimeFrom=%s"), OLE2T(bstrDateTimeFrom));
		bsStart = bstrDateTimeFrom;
	}
	if (NULL != bstrDateTimeTo && SysStringLen(bstrDateTimeTo) > 0)
	{
		LOG_Out(_T("DateTimeTo=%s"), OLE2T(bstrDateTimeTo));
		bsEnd = bstrDateTimeTo;
	}

	//
	// we do NOT validate the format of these two date/time strings.
	// They are supposed to be in XML datetime format. If not, then
	// the returned history logs may be filtered incorrectly.
	//
	hr = cHistory.GetHistoryStr(OLE2T(bstrPath), bsStart, bsEnd, pbstrLog);

	SysFreeString(bsStart);
	SysFreeString(bsEnd);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\iuengine.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuengine.h
//
//  Description:
//
//      Common include file for IUEngine DLL
//
//=======================================================================

#ifndef __IUENGINE_H_
#define __IUENGINE_H_


#include <windows.h>
#include <tchar.h>
#include <ole2.h>
#include "..\inc\iu.h"
#include <logging.h>
#include <shlwapi.h>
#include <iucommon.h>
#include <osdet.h>
#include <UrlAgent.h>

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif


#include "schemakeys.h"

#include <mistsafe.h>
#include <wusafefn.h>


//***********************************************************************
// 
// The following constants are defined in engmain.cpp
//
//***********************************************************************


/**
* the following two groups of constants can be used to construct
* lMode parameter of the following APIs:
*		Download()
*		DownloadAsync()
*		Install()
*		InstallAsync()
*
* Obviousely, you can only pick one from each group to make up
* lMode parameter.
*
*/
extern const LONG UPDATE_NOTIFICATION_DEFAULT;
extern const LONG UPDATE_NOTIFICATION_ANYPROGRESS;
extern const LONG UPDATE_NOTIFICATION_COMPLETEONLY;
extern const LONG UPDATE_NOTIFICATION_1PCT;
extern const LONG UPDATE_NOTIFICATION_5PCT;
extern const LONG UPDATE_NOTIFICATION_10PCT;

/**
* constant can also be used for SetOperationMode() and GetOperationMode()
*/
extern const LONG UPDATE_MODE_THROTTLE;

/**
* constant can be used by Download() and DownloadAsync(), which will
* tell these API's to use Corporate directory structure for destination folder.
*/
extern const LONG UPDATE_CORPORATE_MODE;


/**
* constant can be used by Install() and InstallAsync(). Will disable all
* internet related features
*/
extern const LONG UPDATE_OFFLINE_MODE;

/**
* constants for SetOperationMode() API
*/
extern const LONG UPDATE_COMMAND_PAUSE;
extern const LONG UPDATE_COMMAND_RESUME;
extern const LONG UPDATE_COMMAND_CANCEL;

/**
* constants for GetOperationMode() API
*/
extern const LONG UPDATE_MODE_PAUSED;
extern const LONG UPDATE_MODE_RUNNING;
extern const LONG UPDATE_MODE_NOTEXISTS;


/**
* constants for SetProperty() and GetProperty() API
*/
extern const LONG UPDATE_PROP_USECOMPRESSION;
extern const LONG UPDATE_PROP_OFFLINEMODE;

/**
* constants for BrowseForFolder() API
*
*	IUBROWSE_WRITE_ACCESS - validate write access on selected folder
*	IUBROWSE_AFFECT_UI - write-access validation affect OK button enable/disable
*	IUBROWSE_NOBROWSE - do not show browse folder dialog box. validate path passed-in only
*
*	default:
*		pop up browse folder dialog box, not doing any write-access validation
*		
*/
extern const LONG IUBROWSE_WRITE_ACCESS;
extern const LONG IUBROWSE_AFFECT_UI;
extern const LONG IUBROWSE_NOBROWSE;

// constants for historical speed registry
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_HISTORICALSPEED[] = _T("HistoricalSpeed");	// in bytes/sec
const TCHAR REGVAL_TIMEELAPSED[] = _T("TimeElapsed");			// in seconds

// constant for default downloads folder name
const TCHAR IU_WUTEMP[] = _T("WUTemp");

//
// Globals for the IUEngine

extern LONG g_lThreadCounter;
extern HANDLE g_evtNeedToQuit;
extern CUrlAgent *g_pUrlAgent;

typedef struct IUOPERATIONINFO
{
    TCHAR szOperationUUID[64];
    LONG lUpdateMask;
    BSTR bstrOperationResult;
    IUOPERATIONINFO *pNext;
} IUOPERATIONINFO, *PIUOPERATIONINFO;
class COperationMgr
{
public:
    COperationMgr();
    ~COperationMgr();

    BOOL AddOperation(LPCTSTR pszOperationID, LONG lUpdateMask);
    BOOL RemoveOperation(LPCTSTR pszOperationID);
    BOOL FindOperation(LPCTSTR pszOperationID, PLONG plUpdateMask, BSTR *pbstrOperationResult);
    BOOL UpdateOperation(LPCTSTR pszOperationID, LONG lUpdateMask, BSTR bstrOperationResult);

private:
    PIUOPERATIONINFO m_pOperationInfoList;
};

//
// CEngUpdate class used to export apartment safe instances of the update class to WU clients (iuctl, AU, DU, CDM)
//

class CEngUpdate
{

public:

	CEngUpdate();
	~CEngUpdate();

public:
	HRESULT WINAPI GetSystemSpec(BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult);

	HRESULT WINAPI GetManifest(BSTR	bstrXmlClientInfo, BSTR	bstrXmlSystemSpec, BSTR	bstrXmlQuery, DWORD dwFlags, BSTR *pbstrXmlCatalog);

	HRESULT WINAPI Detect(BSTR bstrXmlCatalog, DWORD dwFlags, BSTR *pbstrXmlItems);

	HRESULT WINAPI Download(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
							IUnknown *punkProgressListener, HWND hWnd, BSTR *pbstrXmlItems);

	HRESULT WINAPI DownloadAsync(BSTR bstrXmlClientInfo, BSTR bstrXmlCatalog, BSTR bstrDestinationFolder, LONG lMode,
								 IUnknown *punkProgressListener, HWND hWnd, BSTR bstrUuidOperation, BSTR *pbstrUuidOperation);

	HRESULT WINAPI Install(BSTR bstrXmlClientInfo,
                       BSTR	bstrXmlCatalog,
					   BSTR bstrXmlDownloadedItems,
					   LONG lMode,
					   IUnknown *punkProgressListener,
					   HWND hWnd,
					   BSTR *pbstrXmlItems);

	HRESULT WINAPI InstallAsync(BSTR bstrXmlClientInfo,
                            BSTR bstrXmlCatalog,
							BSTR bstrXmlDownloadedItems,
							LONG lMode,
							IUnknown *punkProgressListener,
							HWND hWnd,
							BSTR bstrUuidOperation,
                            BSTR *pbstrUuidOperation);

	HRESULT WINAPI SetOperationMode(BSTR bstrUuidOperation, LONG lMode);

	HRESULT WINAPI GetOperationMode(BSTR bstrUuidOperation, LONG* plMode);

	HRESULT WINAPI GetHistory(
		BSTR		bstrDateTimeFrom,
		BSTR		bstrDateTimeTo,
		BSTR		bstrClient,
		BSTR		bstrPath,
		BSTR*		pbstrLog);

	HRESULT WINAPI BrowseForFolder(BSTR bstrStartFolder, 
							LONG flag, 
							BSTR* pbstrFolder);

	HRESULT WINAPI RebootMachine();

private:
	void WINAPI ShutdownInstanceThreads();	// called in dtor to shut down any outstanding threads

public:
	LONG m_lThreadCounter;
	HANDLE m_evtNeedToQuit;
	BOOL m_fOfflineMode;
	COperationMgr m_OperationMgr;
};

//
// CDM Internal Exports (called by IUCDM stub cdm.dll)
//

//
// We use a separate Real(tm) global for CDM to hold an instance of the CEngUpdate class,
// since it is never multiple instanced.
//
extern CEngUpdate* g_pCDMEngUpdate;

VOID WINAPI InternalDetFilesDownloaded(
    IN  HANDLE			hConnection
	);

BOOL InternalDownloadGetUpdatedFiles(
	IN PDOWNLOADINFOWIN98	pDownloadInfoWin98,
	IN OUT LPTSTR			lpDownloadPath,
	IN UINT					uSize
);

BOOL WINAPI InternalDownloadUpdatedFiles(
    IN  HANDLE        hConnection, 
    IN  HWND          hwnd,  
    IN  PDOWNLOADINFO pDownloadInfo, 
    OUT LPWSTR        lpDownloadPath, 
    IN  UINT          uSize, 
    OUT PUINT         puRequiredSize
    );


BOOL WINAPI InternalFindMatchingDriver(
    IN  HANDLE			hConnection, 
	IN  PDOWNLOADINFO	pDownloadInfo,
	OUT PWUDRIVERINFO	pWuDriverInfo
	);

VOID WINAPI InternalLogDriverNotFound(
    IN HANDLE	hConnection, 
	IN LPCWSTR  lpDeviceInstanceID,
	IN DWORD	dwFlags
	);

int WINAPI InternalQueryDetectionFiles(
    IN  HANDLE							hConnection, 
	IN	void*							pCallbackParam, 
	IN	PFN_QueryDetectionFilesCallback	pCallback
	);

void InternalSetGlobalOfflineFlag(
	IN BOOL fOfflineMode
	);

//
// GetSystemSpec functionality exported for use by CDM
//

class CXmlSystemSpec;

HRESULT AddComputerSystemClass(CXmlSystemSpec& xmlSpec);

HRESULT AddRegKeyClass(CXmlSystemSpec& xmlSpec);

HRESULT AddPlatformClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo);

HRESULT AddLocaleClass(CXmlSystemSpec& xmlSpec, BOOL fIsUser);

HRESULT AddDevicesClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo, BOOL fIsSysSpecCall);

//
// Misc. functionality
//

extern LONG g_lDoOnceOnLoadGuard;

void WINAPI DeleteExpiredDownloadFolders();

HRESULT WINAPI CreateGlobalCDMEngUpdateInstance();

HRESULT WINAPI DeleteGlobalCDMEngUpdateInstance();

void WINAPI ShutdownThreads();	// called by UnlockEnginge -- maintains backwards CDM compatibility

void WINAPI ShutdownGlobalThreads();	// called to shut down any outstanding global threads

#endif // __IUENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\setopsts.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   setopsts.cpp
//
//  Description:
//
//      Implementation for the GetOperationResult() function
//
//=======================================================================

#include "iuengine.h"


/////////////////////////////////////////////////////////////////////////////
// SetOperationMode()
//		Set the operation mode.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_COMMAND_PAUSE
//				UPDATE_COMMAND_RESUME
//				UPDATE_COMMAND_CANCEL
//
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::SetOperationMode(BSTR bstrUuidOperation, LONG lMode)
{
	LOG_Block("CEngUpdate::SetOperationMode");
    if (UPDATE_COMMAND_CANCEL != lMode)
        return E_INVALIDARG;

    // only supported operation mode is cancel
    SetEvent(m_evtNeedToQuit);
	LOG_Out(_T("Set m_evtNeedToQuit"));
    return S_OK;    
}



/////////////////////////////////////////////////////////////////////////////
// GetOperationMode()
//		Get the operation mode.
//
// Input:
//		bstrUuidOperation - an id provided by the client to provide further
//                     identification to the operation as indexes may be reused.
//		lMode - the mode affecting the operation:
//
//				UPDATE_MODE_PAUSED
//				UPDATE_MODE_RUNNING
//				UPDATE_MODE_NOTEXISTS
//				UPDATE_MODE_THROTTLE
//
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetOperationMode(BSTR bstrUuidOperation, LONG* plMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\iuxml.h ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuxml.h
//
//  Description:
//
//      Declaration of the CIUXml class
//
//=======================================================================

#ifndef __IUXML_H_
#define __IUXML_H_

#include <msxml.h>

#define HANDLE_NODE_INVALID     -1
#define HANDLE_NODELIST_INVALID -1

typedef DWORD   HANDLE_NODE;
typedef DWORD   HANDLE_NODELIST;

// Bitmap of existence of all possible system info classes
extern const DWORD  COMPUTERSYSTEM;
extern const DWORD  REGKEYS;
extern const DWORD  PLATFORM;
extern const DWORD  LOCALE;
extern const DWORD  DEVICES;


/////////////////////////////////////////////////////////////////////////////
// CIUXml
class CIUXml
{
public:
    CIUXml();
    virtual ~CIUXml();

    /////////////////////////////////////////////////////////////////////////////
    // SafeCloseHandleNode()
    //
    // User can explicitly can this function to release a node for reuse when 
    // writing a xml doc.
    /////////////////////////////////////////////////////////////////////////////
    void SafeCloseHandleNode(HANDLE_NODE& hNode);

    /////////////////////////////////////////////////////////////////////////////
    // SafeFindCloseHandle()
    //
    // User can explicitly can this function to release a nodelist for reuse when 
    // reading a xml doc.
    /////////////////////////////////////////////////////////////////////////////
    void SafeFindCloseHandle(HANDLE_NODELIST& hNodeList);

    /////////////////////////////////////////////////////////////////////////////
    // GetDOMNodebyHandle()
    //
    // Retrieve the xml node with the given index of m_ppNodeArray
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNode* GetDOMNodebyHandle(HANDLE_NODE hNode);

private:
    /////////////////////////////////////////////////////////////////////////////
    // Handle to the heap of the calling process, used for HeapAlloc()
    /////////////////////////////////////////////////////////////////////////////
    HANDLE  m_hHeap;

    /////////////////////////////////////////////////////////////////////////////
    // Length of the node array "m_ppNodeArray"
    /////////////////////////////////////////////////////////////////////////////
    DWORD   m_dwSizeNodeArray;

    /////////////////////////////////////////////////////////////////////////////
    // Length of the nodelist array "m_ppNodeListArray"
    /////////////////////////////////////////////////////////////////////////////
    DWORD   m_dwSizeNodeListArray;

    /////////////////////////////////////////////////////////////////////////////
    // InitNodeArray()
    //
    // Allocate or re-allocate memory for the node array "m_ppNodeArray"
    /////////////////////////////////////////////////////////////////////////////
    HRESULT InitNodeArray(BOOL fRealloc = FALSE);

    /////////////////////////////////////////////////////////////////////////////
    // InitNodeListArray()
    //
    // Allocate or re-allocate memory for the nodelist array "m_ppNodeListArray"
    /////////////////////////////////////////////////////////////////////////////
    HRESULT InitNodeListArray(BOOL fRealloc = FALSE);

    /////////////////////////////////////////////////////////////////////////////
    // GetNodeHandle()
    //
    // Look for the first un-used node from the "m_ppNodeArray" array,
    // including the memory allocation, if needed.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODE GetNodeHandle();

    /////////////////////////////////////////////////////////////////////////////
    // GetNodeListHandle()
    //
    // Look for the first un-used nodelist from the "m_ppNodeListArray" array,
    // including the memory allocation, if needed.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetNodeListHandle();

protected:
    /////////////////////////////////////////////////////////////////////////////
    // This array is used to keep track of different nodes that can remain
    // opened at the same time to write into; the index of the array will be
    // returned to caller as a HANDLE_NODE to perform writing against.
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNode**           m_ppNodeArray;

    /////////////////////////////////////////////////////////////////////////////
    // This array is used to keep track of different nodelists that can remain
    // opened at the same time to read from; the index of the array will be
    // returned to caller as a HANDLE_NODELIST to perform reading against.
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNodeList**       m_ppNodeListArray;

    /////////////////////////////////////////////////////////////////////////////
    // FindFirstDOMNode()
    //
    // Retrieve the first xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindFirstDOMNode()
    //
    // Retrieve the handle of first xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, HANDLE_NODE* phNode);

	/////////////////////////////////////////////////////////////////////////////
	// FindFirstDOMNode()
	//
	// Retrieve the first xml node with the given tag name in the given xml doc
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode);

	/////////////////////////////////////////////////////////////////////////////
	// FindFirstDOMNode()
	//
	// Retrieve the handle of first xml node with the given tag name in the given xml doc
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, HANDLE_NODE* phNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindNextDOMNode()
    //
    // Retrieve the next xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, IXMLDOMNode** ppNode);

    /////////////////////////////////////////////////////////////////////////////
    // FindNextDOMNode()
    //
    // Retrieve the handle of next xml node with the given tag name under the given parent node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindNextDOMNode(HANDLE_NODELIST hNodeList, HANDLE_NODE* phNode);

    /////////////////////////////////////////////////////////////////////////////
    // CreateDOMNodeWithHandle()
    //
    // Create an xml node of the given type
    // Return: index of the node array "m_ppNodeArray"; or -1 if failure.
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODE CreateDOMNodeWithHandle(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI = NULL);
};


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemSpec
class CXmlSystemSpec : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for SystemSpec
    /////////////////////////////////////////////////////////////////////////////
    CXmlSystemSpec();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for SystemSpec
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlSystemSpec();

    /////////////////////////////////////////////////////////////////////////////
    // AddComputerSystem()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddComputerSystem(BSTR bstrManufacturer,
                              BSTR bstrModel,
                              BSTR bstrSupportSite = NULL,
                              INT  iAdmin = -1,
                              INT  iWUDisabled = -1,
                              INT  iAUEnabled = -1,
							  BSTR bstrPID=NULL);

    /////////////////////////////////////////////////////////////////////////////
    // AddDriveSpace()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDriveSpace(BSTR bstrDrive, INT iKBytes);

    /////////////////////////////////////////////////////////////////////////////
    // AddReg()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddReg(BSTR bstrProvider);

    /////////////////////////////////////////////////////////////////////////////
    // AddPlatform()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddPlatform(BSTR bstrName);

    /////////////////////////////////////////////////////////////////////////////
    // AddProcessor()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddProcessor(BSTR bstrProcessor);

    /////////////////////////////////////////////////////////////////////////////
    // AddVersion()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddVersion(INT  iMajor = -1,
                       INT  iMinor = -1,
                       INT  iBuild = -1,
                       INT  iSPMajor = -1,
                       INT  iSPMinor = -1,
                       BSTR bstrTimeStamp = NULL);

    /////////////////////////////////////////////////////////////////////////////
    // AddSuite()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddSuite(BSTR bstrSuite);

    /////////////////////////////////////////////////////////////////////////////
    // AddProductType()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddProductType(BSTR bstrProductType);

    /////////////////////////////////////////////////////////////////////////////
    // AddLocale()
    //
    // We need to pass back a handle to differentiate different <locale> node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddLocale(BSTR bstrContext, HANDLE_NODE* phNodeLocale);

    /////////////////////////////////////////////////////////////////////////////
    // AddLanguage()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddLanguage(HANDLE_NODE hNodeLocale, BSTR bstrLocale);

    /////////////////////////////////////////////////////////////////////////////
    // AddDevice()
    //
    // We need to pass back a handle to differentiate different <device> node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDevice(BSTR bstrDeviceInstance,
                      INT  iIsPrinter,
                      BSTR bstrProvider,
                      BSTR bstrMfgName,
                      BSTR bstrDriverName,
                      HANDLE_NODE* phNodeDevice);

    /////////////////////////////////////////////////////////////////////////////
    // AddHWID()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddHWID(HANDLE_NODE hNodeDevice,
                    BOOL fIsCompatible,
                    UINT iRank,
                    BSTR bstrHWID,
                    BSTR bstrDriverVer = NULL);

    /////////////////////////////////////////////////////////////////////////////
    // GetSystemSpecBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetSystemSpecBSTR(BSTR *pbstrXmlSystemSpec);

private:
    IXMLDOMDocument*    m_pDocSystemSpec;
    IXMLDOMNode*        m_pNodeSystemInfo;
    IXMLDOMNode*        m_pNodeComputerSystem;
    IXMLDOMNode*        m_pNodeRegKeysSW;
    IXMLDOMNode*        m_pNodePlatform;
    IXMLDOMNode*        m_pNodeDevices;
};


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemClass
class CXmlSystemClass : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for SystemInfoClasses
    /////////////////////////////////////////////////////////////////////////////
    CXmlSystemClass();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for SystemInfoClasses
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlSystemClass();

    /////////////////////////////////////////////////////////////////////////////
    // LoadXMLDocument()
    //
    // Load an XML Document from string
    /////////////////////////////////////////////////////////////////////////////
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    /////////////////////////////////////////////////////////////////////////////
    // GetClasses()
    //
    // Return the bitmap of existence of all possible system info classes
    /////////////////////////////////////////////////////////////////////////////
    DWORD GetClasses();

private:
    IXMLDOMDocument*    m_pDocSystemClass;
};


/////////////////////////////////////////////////////////////////////////////
// CXmlCatalog
class CXmlCatalog : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Catalog
    /////////////////////////////////////////////////////////////////////////////
    CXmlCatalog();

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for Catalog
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlCatalog();

    /////////////////////////////////////////////////////////////////////////////
    // LoadXMLDocument()
    //
    // Load an XML Document from string
    /////////////////////////////////////////////////////////////////////////////
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemCount()
    //
    // Gets a Count of How Many Items are in this Catalog
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemCount(LONG *plItemCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetProviders()
    // 
    // Find a list of <provider> node in catalog xml
    /////////////////////////////////////////////////////////////////////////////
    IXMLDOMNodeList* GetProviders();

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstProvider()
    //
    // Find the first provider in catalog xml doc
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstProvider(HANDLE_NODE* phNodeProvider);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextProvider()
    //
    // Find the next provider in catalog xml doc
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextProvider(HANDLE_NODELIST hNodeListProvider, HANDLE_NODE* phNodeProvider);    

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItem()
    //
    // Find the first item in provider (parent) node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE hNodeProvider, HANDLE_NODE* phNodeItem);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next item in provider (parent) node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItemDependency()
    //
    // Find the first dependency item in Item Dependencies node
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItemDependency(HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next dependency item in the Item Dependencies node
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItemDependency(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);  

    /////////////////////////////////////////////////////////////////////////////
    // CloseItemList()
    //
    // Release the item nodelist
    /////////////////////////////////////////////////////////////////////////////
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetIdentity()
    //
    // Retrieve the unique name (identity) of the given provider or item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetIdentity(HANDLE_NODE hNode,
                        BSTR* pbstrName,
                        BSTR* pbstrPublisherName,
                        BSTR* pbstrGUID);

    /////////////////////////////////////////////////////////////////////////////
    // GetIdentityStr()
    //
    // Retrieve the string that can be used to uniquely identify an item.
    // This function defines the logic about what components can be used
    // to define the uniqueness of an item based on the 3 parts of data from
    // GetIdentity().
    //
    // The created string will be language neutral. That is, it can not
    // ensure the uniqueness for two items having the same <identity> node
    // except different only on <langauge> part inside <identity>
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetIdentityStr(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

	HRESULT GetIdentityStrForPing(HANDLE_NODE hNode,
                        BSTR* pbstrUniqIdentifierString);

    /////////////////////////////////////////////////////////////////////////////
    // GetBSTRItemForCallback()
    //
    // Create an item node as the passed-in node, have child nodes identity and
	// platform (anything uniquely idenitify this item) then output this 
	// item node data as string, then delete the crated node
    //
    /////////////////////////////////////////////////////////////////////////////
	HRESULT GetBSTRItemForCallback(HANDLE_NODE hItem, BSTR* pbstrXmlItemForCallback);

    /////////////////////////////////////////////////////////////////////////////
    // IsPrinterDriver()
    //
    // Retrieves from the Catalog whether this Item is a Printer Driver
    //
    /////////////////////////////////////////////////////////////////////////////
    BOOL IsPrinterDriver(HANDLE_NODE hNode);

    /////////////////////////////////////////////////////////////////////////////
    // GetDriverInfo()
    //
    // Retrieves the Driver Information from the Catalog for this Item. Returns
    // the Display Name and HWID for this driver - This is passed to the CDM 
    // installer
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetDriverInfo(HANDLE_NODE hNode, 
                          BSTR* pbstrHWID, 
                          BSTR* pbstrDisplayName);

    /////////////////////////////////////////////////////////////////////////////
    // GetPrinterDriverInfo()
    //
    // Retrieves the Printer Driver Information from the Catalog for this Item. 
    // Returns the DriverName and the Architecture - This is passed to the CDM
    // installer
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetPrinterDriverInfo(HANDLE_NODE hNode,
                                 BSTR* pbstrDriverName,
                                 BSTR* pbstrHWID,
								 BSTR* pbstrManufacturer,
								 BSTR* pbstrProvider);


	/////////////////////////////////////////////////////////////////////////////
	// GetDriverInfoEx()
	//
	// Combines functionality of IsPrinterDriver, GetDriverInfo, and
	// GetPrinterDriverInfo plus retreives MfgName and DriverProvider.
	// Used by FindMatchingDriver()
	//
	// If SUCCEEDES pbstrHWID, pbstrDriverVer, and pbstrDisplayName
	//    are always returned.
	// If SUCCEEDES && *pFIsPrinter == TRUE then pbstrDriverName,
	//    pbstrDriverProvider, and pbstrMfgName are returned.
	//
	// Currently pbstrArchitecture is never returned.
	//
	/////////////////////////////////////////////////////////////////////////////
    HRESULT CXmlCatalog::GetDriverInfoEx(HANDLE_NODE hNode,
                                         BOOL* pfIsPrinter,
                                         BSTR* pbstrHWID,
										 BSTR* pbstrDriverVer,
                                         BSTR* pbstrDisplayName,
                                         BSTR* pbstrDriverName,
                                         BSTR* pbstrDriverProvider,
                                         BSTR* pbstrMfgName,
                                         BSTR* pbstrArchitecture);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstPlatformStr()
    //
    // The input node pointer points to an item node has <platform> as its child.
    // This function will retrieve the first <platform> node from this item node and
    // convert the data inside <platform> into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemFirstPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrPlatform);
    
    /////////////////////////////////////////////////////////////////////////////
    // GetItemAllPlatformStr()
    //
    // The input node pointer points to an item node that has <platform> node(s).
    // This function will retrieve every <platform> node from this item node and
    // convert the data inside <platform> into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemAllPlatformStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbPlatforms, UINT* pnPlatformCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstLanguageStr()
    //
    // The input node pointer points to a node has <identity> as its child.
    // This function will retrieve the first <language> node from <identity> 
    // node 
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemFirstLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR* pbstrLanguage);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemAllLanguageStr()
    //
    // The input node pointer points to a node has <identity> as its child.
    // This function will retrieve every <language> node from <identity> node and
    // convert the data into an BSTR array to return.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemAllLanguageStr(HANDLE_NODE hNodeItem,
                        BSTR** ppbstrLanguage, UINT* pnLangCount);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemFirstCodeBase()
    //
    // Find the first codebase (path) of the given item
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetItemFirstCodeBase(HANDLE_NODE hNodeItem,
                                         BSTR* pbstrCodeBase,
                                         BSTR* pbstrName,
                                         BSTR* pbstrCRC,
                                         BOOL* pfPatchAvailable,
                                         LONG* plSize);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemNextCodeBase()
    //
    // Find the next codebase (path) of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemNextCodeBase(HANDLE_NODELIST hNodeListCodeBase,
                                BSTR* pbstrCodeBase,
                                BSTR* pbstrName,
                                BSTR* pbstrCRC,
                                BOOL* pfPatchAvailable,
                                LONG* plSize);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemInstallInfo()
    //
    // Retrieve the installation information of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemInstallInfo(HANDLE_NODE hNodeItem,
                               BSTR* pbstrInstallerType,
							   BOOL* pfExclusive,
                               BOOL* pfReboot,
                               LONG* plNumCommands);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetItemInstallCommand()
    //
    // Find the installation command type, command and switches of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemInstallCommand(HANDLE_NODE hNodeItem,
                                  INT   iOrder,
                                  BSTR* pbstrCommandType,
                                  BSTR* pbstrCommand,
                                  BSTR* pbstrSwitches,
                                  BSTR* pbstrInfSection);

    /////////////////////////////////////////////////////////////////////////////
    // CloseItem()
    //
    // Release the item node
    /////////////////////////////////////////////////////////////////////////////
    void CloseItem(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetTotalEstimatedSize()
    //
    // Get the Total Estimated Download Size of all Items based on Codebase Size
    HRESULT GetTotalEstimatedSize(LONG *plTotalSize);

    /////////////////////////////////////////////////////////////////////////////
    // FindItemByIdentity()
    //
    // Finds an Item in the Catalog that Matches the Supplied Identity                
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindItemByIdentity(IXMLDOMNode* pNodeIdentity, HANDLE_NODE* phNodeItem);

 /*   /////////////////////////////////////////////////////////////////////////////
    // IfSameIdentity()
    //
    // Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2);
*/

    /////////////////////////////////////////////////////////////////////////////
    // GetItemLanguage()
    //
    // Get the Language Entity from the Item Identity
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemLanguage(HANDLE_NODE hNodeItem, BSTR* pbstrLanguage);

    /////////////////////////////////////////////////////////////////////////////
    // GetCorpItemPlatformStr()
    //
    // Get the Simplified Platform String for an Item (uses the first available platform element)
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetCorpItemPlatformStr(HANDLE_NODE hNodeItem, BSTR* pbstrPlatformStr);
    

private:
    IXMLDOMDocument*    m_pDocCatalog;

    //
    // helper functions
    //

    //
    // get data from a version node and convert them into a string with
    // format: 
    //          VersionStr   = <Version>[,<SvcPackVer>[,<timeStamp>]]
    //          <Version>    = <Major>[.<Minor>[.<Build>]]
    //          <SvcPackVer> = <Major>[.<minor>]
    //
    //
    // Assumption:
    //          pszVersion points to a buffer LARGE ENOUGH to store
    //          any legal version number.
    //
    HRESULT getVersionStr(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);
    HRESULT getVersionStrWithoutSvcPack(IXMLDOMNode* pVersionNode, LPTSTR pszVersion);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemPlatformStr()
    //
    // The input node pointer points to a <platform> node.
    // This function will retrieve the data from this <platform> node and
    // convert the data into a string that can be used to
    // uniquely identify a platform.
    //
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetPlatformStr(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);
    HRESULT GetPlatformStrForPing(IXMLDOMNode* pNodePlatform, BSTR* pbstrPlatform);

private:

};


/////////////////////////////////////////////////////////////////////////////
// CXmlItems
class CXmlItems : public CIUXml
{
public:
    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Items; this is for write only
    /////////////////////////////////////////////////////////////////////////////
    CXmlItems();

    /////////////////////////////////////////////////////////////////////////////
    // Constructor
    //
    // Create IXMLDOMDocument* for Items; take TRUE for read, FALSE for write
    /////////////////////////////////////////////////////////////////////////////
    CXmlItems(BOOL fRead);

    /////////////////////////////////////////////////////////////////////////////
    // Destructor
    //
    // Release IXMLDOMDocument* for Items
    /////////////////////////////////////////////////////////////////////////////
    ~CXmlItems();

    /////////////////////////////////////////////////////////////////////////////
    // GetItemsDocumentPtr()
    //
    // Retrieve the items XML Document node
    /////////////////////////////////////////////////////////////////////////////
    inline IXMLDOMDocument* GetItemsDocumentPtr() { return m_pDocItems; };

    /////////////////////////////////////////////////////////////////////////////
    // Clear()
    //
    // Reset IXMLDOMDocument* for Items
    /////////////////////////////////////////////////////////////////////////////
    void Clear();

	/////////////////////////////////////////////////////////////////////////////
	// LoadXMLDocument()
	//
	// Load an XML Document from string
	/////////////////////////////////////////////////////////////////////////////
	HRESULT LoadXMLDocument(BSTR bstrXml);

	/////////////////////////////////////////////////////////////////////////////
	// LoadXMLDocumentFile()
	//
	// Load an XML Document from the specified file
	/////////////////////////////////////////////////////////////////////////////
	HRESULT LoadXMLDocumentFile(BSTR bstrFilePath);

    /////////////////////////////////////////////////////////////////////////////
    // SaveXMLDocument()
    //
    // Save an XML Document to the specified location
    /////////////////////////////////////////////////////////////////////////////
    HRESULT SaveXMLDocument(BSTR bstrFilePath);

	/////////////////////////////////////////////////////////////////////////////
	// AddGlobalErrorCodeIfNoItems()
	//
	// Add the errorCode attribute for <items> if there's no <itemStatus> child node
	/////////////////////////////////////////////////////////////////////////////
	HANDLE_NODELIST AddGlobalErrorCodeIfNoItems(DWORD dwErrorCode);

    /////////////////////////////////////////////////////////////////////////////
    // GetFirstItem()
    //
    // Find the first item in Items xml doc
    /////////////////////////////////////////////////////////////////////////////
    HANDLE_NODELIST GetFirstItem(HANDLE_NODE* phNodeItem);
        
    /////////////////////////////////////////////////////////////////////////////
    // GetNextItem()
    //
    // Find the next item in Items xml doc
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem);    
        
    /////////////////////////////////////////////////////////////////////////////
    // CloseItemList()
    //
    // Release the item nodelist
    /////////////////////////////////////////////////////////////////////////////
    void CloseItemList(HANDLE_NODELIST hNodeListItem);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemDownloadPath()
    //
    // Retrieve the download path of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemDownloadPath(HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemDownloadPath()
    //
    // Retrieve the download path of the given item in catalog
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemDownloadPath(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // CloseItem()
    //
    // Release the item node
    /////////////////////////////////////////////////////////////////////////////
    void CloseItem(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // FindItem()
    //
    // Input:
    // pNodeItem    - the <itemStatus> node of the install items xml; we need
    //                to find the corresponding <itemStatus> node in the existing 
    //                items xml with the identical <identity>, <platform> and 
    //                <client> nodes.
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in the existing items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT FindItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem, BOOL fIdentityOnly = FALSE);

	/////////////////////////////////////////////////////////////////////////////
	// FindItem()
	//
	// Input:
	// pCatalog		- the pointer to the CXmlCatalog object
	// hNodeItem	- the handle of the <item> node of the catalog xml; we need
	//                to find the corresponding <itemStatus> node in the existing 
	//                items xml with the identical <identity>, <platform> and 
	//                <client> nodes.
	// Output:
	// phNodeItem	- the handle we pass back to differentiate different
	//				  <itemStatus> node in items xml
	/////////////////////////////////////////////////////////////////////////////
	HRESULT FindItem(CXmlCatalog* pCatalog,	HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // MergeItemDownloaded()
    //
    // Insert items with download history into existing history
    /////////////////////////////////////////////////////////////////////////////
    HRESULT MergeItemDownloaded(CXmlItems *pHistoryDownload);

    /////////////////////////////////////////////////////////////////////////////
    // UpdateItemInstalled()
    //
    // Update items with installation history in existing history
    /////////////////////////////////////////////////////////////////////////////
    HRESULT UpdateItemInstalled(CXmlItems *pHistoryInstall);

    /////////////////////////////////////////////////////////////////////////////
    // UpdateItemInstallStatus()
    //
    // Update the install status of the given item
    /////////////////////////////////////////////////////////////////////////////
    HRESULT UpdateItemInstallStatus(HANDLE_NODE hNodeItem,
                                    BSTR bstrValue,
                                    INT iNeedsReboot = -1,
                                    DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddItem()
    //
    // Input:
    // pNodeItem    - the <item> node of the catalog xml; we need to read
    //                <identity> node, <description> node and <platform> nodes
    //                from it and write to the items xml (insert in front).
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // AddItem()
    //
    // Input:
    // pCatalog     - the pointer to the CXmlCatalog object
    // hNodeItem    - the handle of the <item> node of the catalog xml; we need
    //                to read <identity> node, <description> node and <platform>
    //                nodes from it and write to the items xml (insert in front).
    // Output:
    // phNodeItem   - the handle we pass back to differentiate different
    //                <itemStatus> node in items xml
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddItem(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem);
	
	/////////////////////////////////////////////////////////////////////////////
    // AddTimeStamp()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddTimeStamp(HANDLE_NODE hNodeItem);

    /////////////////////////////////////////////////////////////////////////////
    // AddDetectResult()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDetectResult(HANDLE_NODE hNodeItem,
                            INT iInstalled    = -1,
                            INT iUpToDate     = -1,
                            INT iNewerVersion = -1,
                            INT iExcluded     = -1,
                            INT iForce        = -1,
							INT iComputerSystem = -1);

    /////////////////////////////////////////////////////////////////////////////
    // AddDownloadStatus()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDownloadStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddDownloadPath()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddDownloadPath(HANDLE_NODE hNodeItem, BSTR bstrDownloadPath);

    /////////////////////////////////////////////////////////////////////////////
    // AddInstallStatus()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddInstallStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, BOOL fNeedsReboot, DWORD dwErrorCode = 0);

    /////////////////////////////////////////////////////////////////////////////
    // AddClientInfo()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT AddClientInfo(HANDLE_NODE hNodeItem, BSTR bstrClient);

	/////////////////////////////////////////////////////////////////////////////
	// MigrateV3History()
	//
	// Migrate V3 History: Consumer history only.
	/////////////////////////////////////////////////////////////////////////////
	HRESULT MigrateV3History(LPCTSTR pszHistoryFilePath);

    /////////////////////////////////////////////////////////////////////////////
    // GetItemsBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetItemsBSTR(BSTR *pbstrXmlItems);

    /////////////////////////////////////////////////////////////////////////////
    // GetFilteredHistoryBSTR()
    /////////////////////////////////////////////////////////////////////////////
    HRESULT GetFilteredHistoryBSTR(BSTR bstrBeginDateTime,
                                   BSTR bstrEndDateTime,
                                   BSTR bstrClient,
                                   BSTR *pbstrXmlHistory);

private:

	/////////////////////////////////////////////////////////////////////////////
	//
	// Initialize XML DOC node pointers before writing
	/////////////////////////////////////////////////////////////////////////////
	void Init();

/*    /////////////////////////////////////////////////////////////////////////////
    // IfSameClientInfo()
    //
    // Return TRUE if the two <client> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameClientInfo(IXMLDOMNode* pNodeClient1, IXMLDOMNode* pNodeClient2);

    /////////////////////////////////////////////////////////////////////////////
    // IfSameIdentity()
    //
    // Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2);

    /////////////////////////////////////////////////////////////////////////////
    // IfSamePlatform()
    //
    // Return TRUE if the two <platform> nodes are identical. Return FALSE otherwise.
    /////////////////////////////////////////////////////////////////////////////
    BOOL IfSamePlatform(IXMLDOMNode* pNodePlatform1, IXMLDOMNode* pNodePlatform2);
*/

    IXMLDOMDocument*    m_pDocItems;
    IXMLDOMNode*        m_pNodeItems;
};




/////////////////////////////////////////////////////////////////////////////
// CXmlClientInfo
class CXmlClientInfo
{
public:

    CXmlClientInfo();
    ~CXmlClientInfo();

    //
    // load and parse and validate an XML document from string
    //
    HRESULT LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode);

    //
    // retrieve client name attribute
    //
    HRESULT GetClientName(BSTR* pbstrClientName);

	inline IXMLDOMDocument* GetDocument() { return m_pDocClientInfo; }

private:
    IXMLDOMDocument*    m_pDocClientInfo;


};



#endif //__IUXML_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\sources.inc ===
!include $(WINDOWS_COM)\wu.inc

#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		IUEngine.DLL Implementation
#

MAJORCOMP=windows.com
MINORCOMP=iuengine

TARGETNAME=iuengine
TARGETPATH=obj
TARGETTYPE=DYNLINK
UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\IUEngine.def

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
PRECOMPILED_INCLUDE=..\iuengine.h
PRECOMPILED_CXX=1
USE_STATIC_ATL=1
ATL_DLL_IMPL=1
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1

#
# WUBUILD LAB will set this manually
#
# NT_SIGNCODE=1
USE_CRTDLL=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

TARGETLIBS=\
       $(SDK_LIB_PATH)\oleaut32.lib             \
       $(SDK_LIB_PATH)\ole32.lib                \
       $(SDK_LIB_PATH)\kernel32.lib             \
       $(SDK_LIB_PATH)\user32.lib               \
       $(SDK_LIB_PATH)\shlwapi.lib              \
       $(SDK_LIB_PATH)\ShFolder.Lib             \
       $(SDK_LIB_PATH)\shell32.lib              \
       $(SDK_LIB_PATH)\advapi32.lib             \
       $(SDK_LIB_PATH)\advpack.lib              \
       $(SDK_LIB_PATH)\uuid.lib                 \
       $(SDK_LIB_PATH)\wininet.lib              \
       $(SDK_LIB_PATH)\version.lib              \
       $(SDK_LIB_PATH)\setupapi.lib             \
       $(SDK_LIB_PATH)\winspool.lib             \
       $(SDK_LIB_PATH)\rpcrt4.lib               \
       $(SDK_LIB_PATH)\Rasapi32.lib             \
       $(WULIB)\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
       $(WULIB)\util\$(WUBLDTYPE)\$(O)\util.lib		\
       $(WULIB)\detect\$(WUBLDTYPE)\$(O)\detect.lib     \
       $(WULIB)\download\$(WUBLDTYPE)\$(O)\download.lib   \
       $(WULIB)\install\$(WUBLDTYPE)\$(O)\install.lib    \
       $(WULIB)\trust\$(WUBLDTYPE)\$(O)\trust.lib \
       $(WULIB)\urllogging\$(WUBLDTYPE)\$(O)\urllogging.lib \
       $(WULIB)\schemamisc\$(WUBLDTYPE)\$(O)\schemamisc.lib \
       $(WULIB)\urlagent\$(WUBLDTYPE)\$(O)\urlagent.lib \
       $(WULIB)\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib \

#
# how about - gdi32.lib, comdlg32.lib, odbc32.lib, odbccp32.lib?
# they are showing up in the ATL project settings.
#

INCLUDES=$(INCLUDES);..\..\inc;..\.;$(BASEDIR)\public\internal\windows\inc;$(BASEDIR)\public\internal\enduser\inc;$(BASEDIR)\public\internal\inetcore\inc;

SOURCES= \
        ..\engmain.cpp    \
        ..\detect.cpp     \
        ..\download.cpp   \
        ..\setopsts.cpp   \
        ..\install.cpp    \
        ..\manifest.cpp   \
        ..\sysspec.cpp    \
        ..\iuxml.cpp      \
        ..\expression.cpp \
        ..\history.cpp    \
        ..\cdmi.cpp       \
        ..\cdmp.cpp       \
	..\delexdl.cpp    \
        ..\browse.cpp	  \
	..\v3applog.cpp	  \
        ..\iuengine.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\iuxml.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   iuxml.cpp
//
//  Description:
//
//      Implementation for the CIUXml class
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"
#include <iucommon.h>
#include <fileutil.h>
#include <StringUtil.h>
#include <shlwapi.h>
#include <wininet.h>
#include "schemakeys.h"
#include "schemamisc.h"
#include "v3applog.h"

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; LOG_ErrorMsg(hr);	return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}
#define ReturnIfFail(x) {hr = x; if (FAILED(hr)) {LOG_ErrorMsg(hr); return hr;}}
#define SkipIfFail(x) {hr = x; if (FAILED(hr)) {hr = S_FALSE; continue;}}

const TCHAR IDENT_IUSCHEMA[]			= _T("IUSchema");
const TCHAR IDENT_IUSCHEMA_SYSTEMSPEC[]	= _T("SystemSpecSchema");
const TCHAR IDENT_IUSCHEMA_ITEMS[]		= _T("ResultSchema");

const WCHAR CORP_PLATFORM_DIR_NT4[]     = L"x86WinNT4";
const WCHAR CORP_PLATFORM_DIR_NT5[]     = L"x86win2k";
const WCHAR CORP_PLATFORM_DIR_W98[]     = L"x86Win98";
const WCHAR CORP_PLATFORM_DIR_W95[]     = L"x86Win95";
const WCHAR CORP_PLATFORM_DIR_WINME[]   = L"x86WinME";
const WCHAR CORP_PLATFORM_DIR_X86WHI[]  = L"x86WinXP";
const WCHAR CORP_PLATFROM_DIR_IA64WHI[] = L"ia64WinXP";


// Initial length of the node array "m_ppNodeArray"
const DWORD MAX_NODES = 16;

// Initial length of the node array "m_ppNodeListArray"
const DWORD MAX_NODELISTS = 16;

// Bitmap of existence of all possible system info classes
const DWORD	COMPUTERSYSTEM	= 0x00000001;
const DWORD	REGKEYS			= 0x00000010;
const DWORD	PLATFORM		= 0x00000100;
const DWORD	LOCALE			= 0x00001000;
const DWORD	DEVICES			= 0x00010000;


// The following are constants used for V3 history migration:
//
// Log line types
#define LOG_V2				"V2"             // line format for items migrated from V2
#define LOG_V3CAT			"V3CAT"			 // V3 Beta format (version 1)
#define LOG_V3_2			"V3_2"			 // V3 log line format (version 2)
#define LOG_PSS				"PSS"			 // Entry for PSS

// LOG_V2 format
//    V2|DATE|TIME|LOGSTRING|
//
// LOG_V3CAT format
//    V3CAT|PUID|OPERATION|TITLE|VERSION|DATESTRING|TIMESTRING|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_V3_2 format
//    V3_2|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//
// LOG_PSS format
//    PSS|PUID|OPERATION|TITLE|VERSION|TIMESTAMP|RECTYPE|RESULT|ERRORCODE|ERRORSTRING|
//

// operation type
#define LOG_INSTALL         "INSTALL"

// result
#define LOG_SUCCESS         "SUCCESS"
#define LOG_FAIL            "FAIL"
#define LOG_STARTED			"STARTED"      // started but reboot was required: exclusive items only

const WCHAR C_V3_CLIENTINFO[] = L"WU_V3";


/////////////////////////////////////////////////////////////////////////////
// CIUXml

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
/////////////////////////////////////////////////////////////////////////////
CIUXml::CIUXml()
 : m_dwSizeNodeArray(MAX_NODES),
   m_dwSizeNodeListArray(MAX_NODELISTS),
   m_ppNodeArray(NULL),
   m_ppNodeListArray(NULL)
{
	m_hHeap = GetProcessHeap();
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
/////////////////////////////////////////////////////////////////////////////
CIUXml::~CIUXml()
{
	DWORD	dwIndex;

	if (NULL != m_ppNodeArray)
	{
		for (dwIndex = 0; dwIndex < m_dwSizeNodeArray; dwIndex++)
		{
			SafeReleaseNULL(m_ppNodeArray[dwIndex]);
		}

		HeapFree(m_hHeap, 0, m_ppNodeArray);
		m_ppNodeArray = NULL;
	}

	if (NULL != m_ppNodeListArray)
	{
		for (dwIndex = 0; dwIndex < m_dwSizeNodeListArray; dwIndex++)
		{
			SafeReleaseNULL(m_ppNodeListArray[dwIndex]);
		}

		HeapFree(m_hHeap, 0, m_ppNodeListArray);
		m_ppNodeListArray = NULL;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SafeCloseHandleNode()
//
// User can explicitly can this function to release a node for reuse when 
// writing a xml doc.
/////////////////////////////////////////////////////////////////////////////
void CIUXml::SafeCloseHandleNode(HANDLE_NODE& hNode)
{
	if (HANDLE_NODE_INVALID != hNode)
	{
		SafeReleaseNULL(m_ppNodeArray[hNode]);
		hNode = HANDLE_NODE_INVALID;
	}
}


/////////////////////////////////////////////////////////////////////////////
// SafeFindCloseHandle()
//
// User can explicitly can this function to release a nodelist for reuse when 
// reading a xml doc.
/////////////////////////////////////////////////////////////////////////////
void CIUXml::SafeFindCloseHandle(HANDLE_NODELIST& hNodeList)
{
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeReleaseNULL(m_ppNodeListArray[hNodeList]);
		hNodeList = HANDLE_NODELIST_INVALID;
	}
}


/////////////////////////////////////////////////////////////////////////////
// InitNodeArray()
//
// Allocate or re-allocate memory for the node array "m_ppNodeArray"
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::InitNodeArray(BOOL fRealloc /*= FALSE*/)
{
	if (fRealloc)	// re-allocation
	{
		IXMLDOMNode** ppNodeArrayTemp = (IXMLDOMNode**)HeapReAlloc(m_hHeap,
																HEAP_ZERO_MEMORY,
																m_ppNodeArray,
																m_dwSizeNodeArray * sizeof(IXMLDOMNode*));
		if (NULL == ppNodeArrayTemp)
		{
	        return E_OUTOFMEMORY;
		}
		else
		{
			m_ppNodeArray = ppNodeArrayTemp;
		}
	}
	else			// initial allocation
	{
		m_ppNodeArray = (IXMLDOMNode**)HeapAlloc(m_hHeap,
												 HEAP_ZERO_MEMORY,
												 m_dwSizeNodeArray * sizeof(IXMLDOMNode*));
		if (NULL == m_ppNodeArray)
		{
	        return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// InitNodeListArray()
//
// Allocate or re-allocate memory for the nodelist array "m_ppNodeListArray"
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::InitNodeListArray(BOOL fRealloc /*= FALSE*/)
{
	if (fRealloc)	// re-allocation
	{
		IXMLDOMNodeList** ppNodeListArrayTemp = (IXMLDOMNodeList**)HeapReAlloc(m_hHeap,
																	HEAP_ZERO_MEMORY,
																	m_ppNodeListArray,
																	m_dwSizeNodeListArray * sizeof(IXMLDOMNodeList*));
		if (NULL == ppNodeListArrayTemp)
		{
	        return E_OUTOFMEMORY;
		}
		else
		{
			m_ppNodeListArray = ppNodeListArrayTemp;
		}
	}
	else			// initial allocation
	{
		m_ppNodeListArray = (IXMLDOMNodeList**)HeapAlloc(m_hHeap,
													HEAP_ZERO_MEMORY,
													m_dwSizeNodeListArray * sizeof(IXMLDOMNodeList*));
		if (NULL == m_ppNodeListArray)
		{
	        return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// GetNodeHandle()
//
// Look for the first un-used node from the "m_ppNodeArray" array,
// including the memory allocation, if needed.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODE CIUXml::GetNodeHandle()
{
	HRESULT	hr;
	DWORD	dwIndex;

	//
	// allocate memory for "m_ppNodeArray" array if this is the first time using it
	//
	if (NULL == m_ppNodeArray)
	{
		QuitIfFail(InitNodeArray());
		return 0;	// return the first element of the array
	}
		
	//
	// find the next node to use, or, if any node was used but closed, reuse it
	//
	for (dwIndex = 0; dwIndex < m_dwSizeNodeArray; dwIndex++)
	{
		if (NULL == m_ppNodeArray[dwIndex])
		{
			return dwIndex;
		}
	}

	//
	// all pre-allocated nodes are used up, so re-allocate longer array
	//
	m_dwSizeNodeArray += m_dwSizeNodeArray;	// double the size
	QuitIfFail(InitNodeArray(TRUE));		// re-allocation
	return dwIndex;

CleanUp:
    return HANDLE_NODE_INVALID;
}
	

/////////////////////////////////////////////////////////////////////////////
// GetNodeListHandle()
//
// Look for the first un-used nodelist from the "m_ppNodeListArray" array,
// including the memory allocation, if needed.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::GetNodeListHandle()
{
	HRESULT	hr;
	DWORD	dwIndex;

	//
	// allocate memory for "m_ppNodeListArray" array if this is the first time using it
	//
	if (NULL == m_ppNodeListArray)
	{
		QuitIfFail(InitNodeListArray());
		return 0;	// return the first element of the array
	}
		
	//
	// find the next nodelist to use, or, if any nodelist was used but closed, reuse it
	//
	for (dwIndex = 0; dwIndex < m_dwSizeNodeListArray; dwIndex++)
	{
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			return dwIndex;
		}
	}

	//
	// all pre-allocated nodelists are used up, so re-allocate longer array
	//
	m_dwSizeNodeListArray += m_dwSizeNodeListArray;	// double the size
	QuitIfFail(InitNodeListArray(TRUE));			// re-allocation
	return dwIndex;

CleanUp:
	return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// GetDOMNodebyHandle()
//
// Retrieve the xml node with the given index of m_ppNodeArray
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CIUXml::GetDOMNodebyHandle(HANDLE_NODE hNode)
{
	if (NULL != m_ppNodeArray && HANDLE_NODE_INVALID != hNode)
	{
		return m_ppNodeArray[hNode];
	}
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pParentNode)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex;
    dwIndex = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex)
	{
		LONG	lLength;
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex]));
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->nextNode(ppNode));
		if (NULL == *ppNode)
		{
			goto CleanUp;
		}
		return dwIndex;
	}

CleanUp:
	*ppNode = NULL;
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the handle of first xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, HANDLE_NODE* phNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pParentNode)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex1, dwIndex2;
    dwIndex1 = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex1)
	{
		LONG	lLength;
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex1]));
		if (NULL == m_ppNodeListArray[dwIndex1])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex1]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		dwIndex2 = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex2)
		{
			QuitIfFail(m_ppNodeListArray[dwIndex1]->nextNode(&m_ppNodeArray[dwIndex2]));
			if (NULL == m_ppNodeArray[dwIndex2])
			{
				goto CleanUp;
			}
			*phNode = dwIndex2;
			return dwIndex1;
		}
	}

CleanUp:
	*phNode = HANDLE_NODE_INVALID;
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex;
	IXMLDOMNode	*pParentNode = NULL;
    dwIndex = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex)
	{
		LONG		lLength;
		QuitIfFail(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex]));
		if (NULL == m_ppNodeListArray[dwIndex])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex]->nextNode(ppNode));
		if (NULL == *ppNode)
		{
			goto CleanUp;
		}
		SafeReleaseNULL(pParentNode);
		return dwIndex;
	}

CleanUp:
	*ppNode = NULL;
	SafeReleaseNULL(pParentNode);
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindFirstDOMNode()
//
// Retrieve the handle of first xml node with the given tag name in the given xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CIUXml::FindFirstDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, HANDLE_NODE* phNode)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODELIST_INVALID;
	}

	DWORD		dwIndex1, dwIndex2;
	IXMLDOMNode	*pParentNode = NULL;
    dwIndex1 = GetNodeListHandle();
	if (HANDLE_NODELIST_INVALID != dwIndex1)
	{
		LONG	lLength;
		QuitIfFail(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
		QuitIfFail(pParentNode->selectNodes(bstrName, &m_ppNodeListArray[dwIndex1]));
		if (NULL == m_ppNodeListArray[dwIndex1])
		{
			goto CleanUp;
		}
		QuitIfFail(m_ppNodeListArray[dwIndex1]->get_length(&lLength));
		if (lLength <= 0)
		{
			goto CleanUp;
		}
		dwIndex2 = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex2)
		{
			QuitIfFail(m_ppNodeListArray[dwIndex1]->nextNode(&m_ppNodeArray[dwIndex2]));
			if (NULL == m_ppNodeArray[dwIndex2])
			{
				goto CleanUp;
			}
			*phNode = dwIndex2;
			SafeReleaseNULL(pParentNode);
			return dwIndex1;
		}
	}

CleanUp:
	*phNode = HANDLE_NODE_INVALID;
	SafeReleaseNULL(pParentNode);
    return HANDLE_NODELIST_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// FindNextDOMNode()
//
// Retrieve the next xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::FindNextDOMNode(HANDLE_NODELIST hNodeList, IXMLDOMNode** ppNode)
{
	HRESULT		hr = E_FAIL;

	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		hr = m_ppNodeListArray[hNodeList]->nextNode(ppNode);
	}

    if (FAILED(hr) || NULL == *ppNode)
	{
		*ppNode = NULL;
		return E_FAIL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindNextDOMNode()
//
// Retrieve the handle of next xml node with the given tag name under the given parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT CIUXml::FindNextDOMNode(HANDLE_NODELIST hNodeList, HANDLE_NODE* phNode)
{
	HRESULT		hr = E_FAIL;
	DWORD		dwIndex = HANDLE_NODE_INVALID;

	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		dwIndex = GetNodeHandle();
		if (HANDLE_NODE_INVALID != dwIndex)
		{
			hr = m_ppNodeListArray[hNodeList]->nextNode(&m_ppNodeArray[dwIndex]);
		}
	}

    if (FAILED(hr) || NULL == m_ppNodeArray[dwIndex])
	{
		*phNode = HANDLE_NODE_INVALID;
		return E_FAIL;
	}
	*phNode = dwIndex;
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CreateDOMNodeWithHandle()
//
// Create an xml node of the given type
// Return: index of the node array "m_ppNodeArray"; or -1 if failure.
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODE CIUXml::CreateDOMNodeWithHandle(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI /*= NULL*/)
{
	USES_IU_CONVERSION;

	HRESULT		hr	= S_OK;
	if (NULL == pDoc)
	{
		hr = E_INVALIDARG;
		return HANDLE_NODE_INVALID;
	}

	DWORD		dwIndex;
    VARIANT		vType;
	VariantInit(&vType);

    vType.vt = VT_I2;
    vType.iVal = nType;

    dwIndex = GetNodeHandle();
	if (HANDLE_NODE_INVALID != dwIndex)
	{
		QuitIfFail(pDoc->createNode(vType, bstrName, bstrNamespaceURI, &m_ppNodeArray[dwIndex]));
		return dwIndex;
	}

CleanUp:
    return HANDLE_NODE_INVALID;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemSpec

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for SystemSpec
/////////////////////////////////////////////////////////////////////////////
CXmlSystemSpec::CXmlSystemSpec()
 : m_pDocSystemSpec(NULL),
   m_pNodeSystemInfo(NULL),
   m_pNodeComputerSystem(NULL),
   m_pNodeRegKeysSW(NULL),
   m_pNodePlatform(NULL),
   m_pNodeDevices(NULL)
{
    LOG_Block("CXmlSystemSpec()");

 	HRESULT hr = CoCreateInstance(CLSID_DOMDocument,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IXMLDOMDocument,
								  (void **) &m_pDocSystemSpec);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		IXMLDOMNode*	pNodeXML = NULL;
		BSTR bstrNameSpaceSchema = NULL;

		//
		// create the <?xml version="1.0"?> node
		//
		pNodeXML = CreateDOMNode(m_pDocSystemSpec, NODE_PROCESSING_INSTRUCTION, KEY_XML);
		if (NULL == pNodeXML) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocSystemSpec, pNodeXML));

		//
		// process the iuident.txt to find the SystemSpec schema path
		//
		TCHAR szIUDir[MAX_PATH];
		TCHAR szIdentFile[MAX_PATH];
		LPTSTR pszSystemSpecSchema = NULL;
		LPTSTR pszNameSpaceSchema = NULL;

		pszSystemSpecSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszSystemSpecSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
		pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszNameSpaceSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
	
		GetIndustryUpdateDirectory(szIUDir);
		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir,IDENTTXT);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		if (GetPrivateProfileString(IDENT_IUSCHEMA,
								IDENT_IUSCHEMA_SYSTEMSPEC,
								_T(""),
								pszSystemSpecSchema,
								INTERNET_MAX_URL_LENGTH,
								szIdentFile) == INTERNET_MAX_URL_LENGTH - 1)
		{
			LOG_Error(_T("SystemSpec schema buffer overflow"));
			goto CleanUp;
		}

		if ('\0' == pszSystemSpecSchema[0])
		{
			// no SystemSpec schema path specified in iuident.txt
			LOG_Error(_T("No schema path specified in iuident.txt for SystemSpec"));
			goto CleanUp;
		}

		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("x-schema:%s"), pszSystemSpecSchema);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}
		
		bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

		//
		// create the <systemInfo> node with the path of the schema
		//
		m_pNodeSystemInfo = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_SYSTEMINFO, bstrNameSpaceSchema);
		SafeSysFreeString(bstrNameSpaceSchema);
		if (NULL == m_pNodeSystemInfo) goto CleanUp;
		
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocSystemSpec, m_pNodeSystemInfo));

CleanUp:
		SafeReleaseNULL(pNodeXML);
		SafeHeapFree(pszSystemSpecSchema);
		SafeHeapFree(pszNameSpaceSchema);
	}
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for SystemSpec
/////////////////////////////////////////////////////////////////////////////
CXmlSystemSpec::~CXmlSystemSpec()
{
	SafeReleaseNULL(m_pNodeDevices);
	SafeReleaseNULL(m_pNodePlatform);
	SafeReleaseNULL(m_pNodeRegKeysSW);
	SafeReleaseNULL(m_pNodeComputerSystem);
	SafeReleaseNULL(m_pNodeSystemInfo);

	SafeReleaseNULL(m_pDocSystemSpec);
}


/////////////////////////////////////////////////////////////////////////////
// AddComputerSystem()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddComputerSystem(BSTR bstrManufacturer,
										  BSTR bstrModel,
										  BSTR bstrSupportSite /*= NULL*/,
										  INT  iAdmin /*= -1*/,
										  INT  iWUDisabled /*= -1*/,
										  INT  iAUEnabled /*= -1*/,
										  BSTR bstrPID)
{
	LOG_Block("AddComputerSystem()");

	HRESULT		hr = E_FAIL;

	m_pNodeComputerSystem = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_COMPUTERSYSTEM);
	if (NULL == m_pNodeComputerSystem) return hr;

	//
	// Manufacturer and Model are now optional (RAID#337879	IU: can't get latest IU controls to work with IU site)
	//
	if (NULL != bstrManufacturer)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_MANUFACTURER, bstrManufacturer));
	}
	if (NULL != bstrModel)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_MODEL, bstrModel));
	}
	if (NULL != bstrSupportSite)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_SUPPORTSITE, bstrSupportSite));
	}

	if (NULL != bstrPID)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_PID, bstrPID));
	}

	if (-1 != iAdmin)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_ADMINISTRATOR, iAdmin));
	}
	if (-1 != iWUDisabled)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_WU_DISABLED, iWUDisabled));
	}
	if (-1 != iAUEnabled)
	{
		ReturnIfFail(SetAttribute(m_pNodeComputerSystem, KEY_AU_ENABLED, iAUEnabled));
	}
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_pNodeComputerSystem));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDriveSpace()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddDriveSpace(BSTR bstrDrive, INT iKBytes)
{
	LOG_Block("AddDriveSpace()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodeDriveSpace = NULL;

	pNodeDriveSpace = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_DRIVESPACE);
	if (NULL == pNodeDriveSpace) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDriveSpace, KEY_DRIVE, bstrDrive));
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDriveSpace, KEY_KBYTES, iKBytes));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeComputerSystem, pNodeDriveSpace));

CleanUp:
	SafeReleaseNULL(pNodeDriveSpace);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddReg()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddReg(BSTR bstrProvider)
{
	LOG_Block("AddReg()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeRegKeys = NULL;
	IXMLDOMNode*	pNodeRegKeysHKLM = NULL;
	IXMLDOMNode*	pNodeRegValue = NULL;
	IXMLDOMNode*	pNodeRegValueText = NULL;

	if (NULL == m_pNodeRegKeysSW)
	{
		//
		// create the <regKeys> node
		//
		pNodeRegKeys = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REGKEYS);
		if (NULL == pNodeRegKeys) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeSystemInfo, pNodeRegKeys));

		//
		// create the <HKEY_LOCAL_MACHINE> node
		//
		pNodeRegKeysHKLM = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REG_HKLM);
		if (NULL == pNodeRegKeysHKLM) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegKeys, pNodeRegKeysHKLM));

		//
		// create the <SOFTWARE> node
		//
		m_pNodeRegKeysSW = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_REG_SW);
		if (NULL == m_pNodeRegKeysSW) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegKeysHKLM, m_pNodeRegKeysSW));
	}

	//
	// add the <value> node
	//
	pNodeRegValue = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_VALUE);
	if (NULL == pNodeRegValue) goto CleanUp;

	pNodeRegValueText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeRegValueText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeRegValueText, bstrProvider));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeRegValue, pNodeRegValueText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeRegKeysSW, pNodeRegValue));

CleanUp:
    if (FAILED(hr))
        SafeReleaseNULL(m_pNodeRegKeysSW);
	SafeReleaseNULL(pNodeRegKeys);
	SafeReleaseNULL(pNodeRegKeysHKLM);
	SafeReleaseNULL(pNodeRegValue);
	SafeReleaseNULL(pNodeRegValueText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddPlatform()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddPlatform(BSTR bstrName)
{
	LOG_Block("AddPlatform()");

	HRESULT		hr = E_FAIL;

	m_pNodePlatform = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PLATFORM);
	if (NULL == m_pNodePlatform) return hr;

	ReturnIfFail(SetAttribute(m_pNodePlatform, KEY_NAME, bstrName));
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_pNodePlatform));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddProcessor()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddProcessor(BSTR bstrProcessor)
{
	LOG_Block("AddProcessor()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeProcessor = NULL;
	IXMLDOMNode*	pNodeProcessorText = NULL;

	pNodeProcessor = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PROCESSORARCHITECTURE);
	if (NULL == pNodeProcessor) goto CleanUp;

	pNodeProcessorText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeProcessorText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeProcessorText, bstrProcessor));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeProcessor, pNodeProcessorText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeProcessor));

CleanUp:
	SafeReleaseNULL(pNodeProcessor);
	SafeReleaseNULL(pNodeProcessorText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddVersion()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddVersion(INT  iMajor /*= -1*/,
								   INT  iMinor /*= -1*/,
								   INT  iBuild /*= -1*/,
								   INT  iSPMajor /*= -1*/,
								   INT  iSPMinor /*= -1*/,
								   BSTR bstrTimeStamp /*= NULL*/)
{
	LOG_Block("AddVersion()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodeVersion = NULL;

	//
	// create the <version> node
	//
	pNodeVersion = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_VERSION);
	if (NULL == pNodeVersion) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeVersion));

	//
	// set the "major" attribute
	//
	if (-1 != iMajor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_MAJOR, iMajor));
	}

	//
	// set the "minor" attribute
	//
	if (-1 != iMinor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_MINOR, iMinor));
	}

	//
	// set the "build" attribute
	//
	if (-1 != iBuild)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_BUILD, iBuild));
	}

	//
	// set the "servicePackMajor" attribute
	//
	if (-1 != iSPMajor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_SERVICEPACKMAJOR, iSPMajor));
	}

	//
	// set the "servicePackMinor" attribute
	//
	if (-1 != iSPMinor)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_SERVICEPACKMINOR, iSPMinor));
	}

	//
	// set the "timestamp" attribute
	//
	if (NULL != bstrTimeStamp)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeVersion, KEY_TIMESTAMP, bstrTimeStamp));
	}

CleanUp:
	SafeReleaseNULL(pNodeVersion);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddSuite()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddSuite(BSTR bstrSuite)
{
	LOG_Block("AddSuite()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeSuite = NULL;
	IXMLDOMNode*	pNodeSuiteText = NULL;

	pNodeSuite = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_SUITE);
	if (NULL == pNodeSuite) goto CleanUp;

	pNodeSuiteText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeSuiteText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeSuiteText, bstrSuite));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeSuite, pNodeSuiteText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeSuite));

CleanUp:
	SafeReleaseNULL(pNodeSuite);
	SafeReleaseNULL(pNodeSuiteText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddProductType()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddProductType(BSTR bstrProductType)
{
	LOG_Block("AddProductType()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeProductType = NULL;
	IXMLDOMNode*	pNodeProductTypeText = NULL;

	pNodeProductType = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PRODUCTTYPE);
	if (NULL == pNodeProductType) goto CleanUp;

	pNodeProductTypeText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeProductTypeText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeProductTypeText, bstrProductType));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeProductType, pNodeProductTypeText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodePlatform, pNodeProductType));

CleanUp:
	SafeReleaseNULL(pNodeProductType);
	SafeReleaseNULL(pNodeProductTypeText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddLocale()
//
// We need to pass back a handle to differentiate different <locale> node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddLocale(BSTR bstrContext, HANDLE_NODE* phNodeLocale)
{
	LOG_Block("AddLocale()");

	HRESULT		hr = E_FAIL;

	*phNodeLocale = CreateDOMNodeWithHandle(m_pDocSystemSpec, NODE_ELEMENT, KEY_LOCALE);
	if (HANDLE_NODE_INVALID == *phNodeLocale) return hr;

	hr = SetAttribute(m_ppNodeArray[*phNodeLocale], KEY_CONTEXT, bstrContext);
	if (FAILED(hr))
	{
	    SafeCloseHandleNode(*phNodeLocale);
	    LOG_ErrorMsg(hr);
	    return hr;
	}
	ReturnIfFail(InsertNode(m_pNodeSystemInfo, m_ppNodeArray[*phNodeLocale]));
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddLanguage()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddLanguage(HANDLE_NODE hNodeLocale, BSTR bstrLocale)
{
	LOG_Block("AddLanguage()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeLanguage = NULL;
	IXMLDOMNode*	pNodeLanguageText = NULL;

	pNodeLanguage = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_LANGUAGE);
	if (NULL == pNodeLanguage) goto CleanUp;

	pNodeLanguageText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeLanguageText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeLanguageText, bstrLocale));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeLanguage, pNodeLanguageText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeLocale], pNodeLanguage));

CleanUp:
	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pNodeLanguageText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDevice()
//
// We need to pass back a handle to differentiate different <device> node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddDevice(BSTR bstrDeviceInstance, /*= NULL - optional attribute*/
								  INT  iIsPrinter /*= -1*/, 
								  BSTR bstrProvider /*= NULL*/,
								  BSTR bstrMfgName /*= NULL*/,
								  BSTR bstrDriverName /*= NULL*/,
								  HANDLE_NODE* phNodeDevice)
{
	LOG_Block("AddDevice()");

	HRESULT			hr = E_FAIL;
	IXMLDOMNode*	pNodePrinterInfo = NULL;

	if (NULL == m_pNodeDevices)
	{
		//
		// create the <devices> node
		//
		m_pNodeDevices = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_DEVICES);
		if (NULL == m_pNodeDevices) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeSystemInfo, m_pNodeDevices));
	}

	//
	// add the <device> node
	//
	*phNodeDevice = CreateDOMNodeWithHandle(m_pDocSystemSpec, NODE_ELEMENT, KEY_DEVICE);
	if (HANDLE_NODE_INVALID == *phNodeDevice) goto CleanUp;

	if (NULL != bstrDeviceInstance && 0 < lstrlenW(bstrDeviceInstance))
	{
		//
		// set optional deviceInstance attribute of <device>
		//
		CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[*phNodeDevice], KEY_DEVICEINSTANCE, bstrDeviceInstance));
	}

	if (-1 != iIsPrinter)
	{
		//
		// set isPrinter attribute of <device>
		//
		CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[*phNodeDevice], KEY_ISPRINTER, iIsPrinter));

		//
		// Add a <printerInfo> node within <device>
		//
		pNodePrinterInfo = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, KEY_PRINTERINFO);
		if (NULL != pNodePrinterInfo)
		{
			if (NULL != bstrProvider)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_DRIVERPROVIDER, bstrProvider));
			}
			if (NULL != bstrMfgName)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_MFGNAME, bstrMfgName));
			}
			if (NULL != bstrDriverName)
			{
				CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, bstrDriverName));
			}
			CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeDevice], pNodePrinterInfo));
		}
	}

	//
	// insert to <devices>
	//
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeDevices, m_ppNodeArray[*phNodeDevice]));

CleanUp:
	SafeReleaseNULL(pNodePrinterInfo);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddHWID()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::AddHWID(HANDLE_NODE hNodeDevice,
								BOOL fIsCompatible,
								UINT iRank,
								BSTR bstrHWID,
								BSTR bstrDriverVer /*= NULL*/)
{
	LOG_Block("AddHWID()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeHWID = NULL;
	IXMLDOMNode*	pNodeHWIDText = NULL;
	BSTR bstrNameHWID = NULL;

	if (fIsCompatible)
	{
		bstrNameHWID = SysAllocString(L"compid");
	}
	else
	{
		bstrNameHWID = SysAllocString(L"hwid");
	}

	pNodeHWID = CreateDOMNode(m_pDocSystemSpec, NODE_ELEMENT, bstrNameHWID);
	if (NULL == pNodeHWID) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeHWID, KEY_RANK, iRank));
	if (NULL != bstrDriverVer)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeHWID, KEY_DRIVERVER, bstrDriverVer));
	}
	pNodeHWIDText = CreateDOMNode(m_pDocSystemSpec, NODE_TEXT, NULL);
	if (NULL == pNodeHWIDText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeHWIDText, bstrHWID));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeHWID, pNodeHWIDText));
	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeDevice], pNodeHWID));

CleanUp:
	SafeReleaseNULL(pNodeHWID);
	SafeReleaseNULL(pNodeHWIDText);
	SysFreeString(bstrNameHWID);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetSystemSpecBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemSpec::GetSystemSpecBSTR(BSTR *pbstrXmlSystemSpec)
{
	LOG_Block("GetSystemSpecBSTR()");

	//
	// convert XML DOC into BSTR 
	//
	HRESULT hr = m_pDocSystemSpec->get_xml(pbstrXmlSystemSpec);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlSystemClass

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for SystemInfoClasses
/////////////////////////////////////////////////////////////////////////////
CXmlSystemClass::CXmlSystemClass()
 : m_pDocSystemClass(NULL)
{
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for SystemInfoClasses
/////////////////////////////////////////////////////////////////////////////
CXmlSystemClass::~CXmlSystemClass()
{
	SafeReleaseNULL(m_pDocSystemClass);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlSystemClass::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocSystemClass);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocSystemClass, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetClasses()
//
// Return the bitmap of existence of all possible system info classes
/////////////////////////////////////////////////////////////////////////////
DWORD CXmlSystemClass::GetClasses()
{
	LOG_Block("GetClasses()");

	DWORD				dwResult = 0;
    IXMLDOMNodeList*	pNodeList = NULL;

	BSTR bstrNameComputerSystem = SysAllocString(L"classes/computerSystem");
	BSTR bstrNameRegKeys = SysAllocString(L"classes/regKeys");
	BSTR bstrNamePlatform = SysAllocString(L"classes/platform");
	BSTR bstrNameLocale = SysAllocString(L"classes/locale");
	BSTR bstrNameDevices = SysAllocString(L"classes/devices");

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameComputerSystem);
	if (NULL != pNodeList)
	{
		dwResult |= COMPUTERSYSTEM;
		SafeReleaseNULL(pNodeList);
	}

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameRegKeys);
	if (NULL != pNodeList)
	{
		dwResult |= REGKEYS;
		SafeReleaseNULL(pNodeList);
	}
	
	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNamePlatform);
	if (NULL != pNodeList)
	{
		dwResult |= PLATFORM;
		SafeReleaseNULL(pNodeList);
	}
	
	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameLocale);
	if (NULL != pNodeList)
	{
		dwResult |= LOCALE;
		SafeReleaseNULL(pNodeList);
	}

	pNodeList = FindDOMNodeList(m_pDocSystemClass, bstrNameDevices);
	if (NULL != pNodeList)
	{
		dwResult |= DEVICES;
		SafeReleaseNULL(pNodeList);
	}
	
	SysFreeString(bstrNameComputerSystem);
	SysFreeString(bstrNameRegKeys);
	SysFreeString(bstrNamePlatform);
	SysFreeString(bstrNameLocale);
	SysFreeString(bstrNameDevices);
	return dwResult;
}


/////////////////////////////////////////////////////////////////////////////
// CXmlCatalog

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Catalog
/////////////////////////////////////////////////////////////////////////////
CXmlCatalog::CXmlCatalog()
 : m_pDocCatalog(NULL)
{
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for Catalog
/////////////////////////////////////////////////////////////////////////////
CXmlCatalog::~CXmlCatalog()
{
	SafeReleaseNULL(m_pDocCatalog);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocCatalog);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocCatalog, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemCount()
//
// Gets a Count of How Many Items are in this Catalog
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemCount(LONG *plItemCount)
{
    LOG_Block("GetItemCount()");
    HRESULT hr = E_FAIL;
    IXMLDOMNodeList *pItemList = NULL;

    QuitIfNull(plItemCount);
    QuitIfNull(m_pDocCatalog);


	IXMLDOMNode	*pParentNode = NULL;
	CleanUpIfFailedAndSetHrMsg(m_pDocCatalog->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));	
	CleanUpIfFailedAndSetHrMsg(pParentNode->selectNodes(KEY_ITEM_SEARCH, &pItemList));
    if (NULL == pItemList) goto CleanUp;

    CleanUpIfFailedAndSetHrMsg(pItemList->get_length(plItemCount));

CleanUp:
	SafeReleaseNULL(pParentNode);
    SafeReleaseNULL(pItemList);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetProviders()
// 
// Find a list of <provider> node in catalog xml
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* CXmlCatalog::GetProviders()
{
    LOG_Block("GetProviders()");

	IXMLDOMNodeList*	pNodeList = NULL;
	
	pNodeList = FindDOMNodeList(m_pDocCatalog, KEY_CATALOG_PROVIDER);
	
	return pNodeList;
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstProvider()
//
// Find the first provider in catalog xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstProvider(HANDLE_NODE* phNodeProvider)
{
    LOG_Block("GetFirstProvider()");

	HANDLE_NODELIST hNodeListProvider = FindFirstDOMNode(m_pDocCatalog, KEY_CATALOG_PROVIDER, phNodeProvider);
	
	return hNodeListProvider;
}
	
	
/////////////////////////////////////////////////////////////////////////////
// GetNextProvider()
//
// Find the next provider in catalog xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextProvider(HANDLE_NODELIST hNodeListProvider, HANDLE_NODE* phNodeProvider)
{
    LOG_Block("GetNextProvider()");

	return FindNextDOMNode(hNodeListProvider, phNodeProvider);
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstItem()
//
// Find the first item in provider (parent) node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstItem(HANDLE_NODE hNodeProvider, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetFirstItem()");

	HANDLE_NODELIST hNodeListItem = FindFirstDOMNode(m_ppNodeArray[hNodeProvider], KEY_ITEM, phNodeItem);

    return hNodeListItem;
}
	
	
/////////////////////////////////////////////////////////////////////////////
// GetNextItem()
//
// Find the next item in provider (parent) node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItem()");

	return FindNextDOMNode(hNodeListItem, phNodeItem);
}
	
/////////////////////////////////////////////////////////////////////////////
// GetFirstItemDependency()
//
// Find the first dependency item in Item Dependencies node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetFirstItemDependency(HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetFirstItemDependency");
    HRESULT hr;

    QuitIfNull(phNodeItem);

    IXMLDOMNode* pNodeDependencies = NULL;
    IXMLDOMNode* pNodeIdentity = NULL;
    HANDLE_NODELIST hNodeListItem = HANDLE_NODELIST_INVALID;
        
    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_DEPENDENCIES, &pNodeDependencies);
    QuitIfFail(hr);

    hNodeListItem = FindFirstDOMNode(pNodeDependencies, KEY_IDENTITY, &pNodeIdentity);
    if (HANDLE_NODELIST_INVALID != hNodeListItem)
    {
        // We found at least one Identity in this Dependencies key, Try to find the matching
        // Item in the Catalog and if found return as the phNodeItem
        FindItemByIdentity(pNodeIdentity, phNodeItem);
    }

CleanUp:
    SafeReleaseNULL(pNodeIdentity);
    SafeReleaseNULL(pNodeDependencies);

    return hNodeListItem;
}


/////////////////////////////////////////////////////////////////////////////
// GetNextItemDependency()
//
// Find the next dependency item in the Item Dependencies node
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetNextItemDependency(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItemDependency");
    HRESULT hr;

    QuitIfNull(phNodeItem);
    
    IXMLDOMNode* pNodeIdentity = NULL;

    hr = FindNextDOMNode(hNodeListItem, &pNodeIdentity);
    // This function is supposed to return S_FALSE when no more items are available
    // but FindNextDOMNode returns E_FAIL when it can't find the next node. So we won't
    // look at the return.
    // CleanUpIfFailedAndMsg(hr); 

    if (NULL != pNodeIdentity)
    {
        // We found another Identity in this Dependencies Key
        hr = FindItemByIdentity(pNodeIdentity, phNodeItem);
    }
    else 
    {
        hr = S_FALSE; // indicate to caller there are no more identities.
    }

    SafeReleaseNULL(pNodeIdentity);
    return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// CloseItemList()
//
// Release the item nodelist
/////////////////////////////////////////////////////////////////////////////
void CXmlCatalog::CloseItemList(HANDLE_NODELIST hNodeListItem)
{
	SafeFindCloseHandle(hNodeListItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetIdentity()
//
// Retrieve the unique name (identity) of the given provider or item
/////////////////////////////////////////////////////////////////////////////
//
// public version
//
HRESULT CXmlCatalog::GetIdentity(HANDLE_NODE hNode,
								 BSTR* pbstrName,
								 BSTR* pbstrPublisherName,
								 BSTR* pbstrGUID)
{
    LOG_Block("GetIdentity()");

	HRESULT		hr = E_FAIL;
	IXMLDOMNode*	pNodeIdentity = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pNodeIdentity));
	hr = Get3IdentiStrFromIdentNode(pNodeIdentity, pbstrName, pbstrPublisherName, pbstrGUID);

CleanUp:
	SafeReleaseNULL(pNodeIdentity);
	return hr;
}




/////////////////////////////////////////////////////////////////////////////
// GetIdentityStr()
//
// Retrieve the string that can be used to uniquely identify an object
// based on its <identity> node.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
// The created string will be language neutral. That is, it can not
// ensure the uniqueness for two items having the same <identity> node
// except different only on <langauge> part inside <identity>
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetIdentityStr(HANDLE_NODE hNode,
					BSTR* pbstrUniqIdentifierString)
{
	IXMLDOMNode* pIdentityNode = NULL;
	HRESULT hr = E_INVALIDARG;
	if (FindNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pIdentityNode) && NULL != pIdentityNode)
	{
		hr = UtilGetUniqIdentityStr(pIdentityNode, pbstrUniqIdentifierString, 0x0);
		SafeReleaseNULL(pIdentityNode);
	}
	return hr;
}

HRESULT CXmlCatalog::GetIdentityStrForPing(HANDLE_NODE hNode,
                    BSTR* pbstrUniqIdentifierString)
{
	IXMLDOMNode* pIdentityNode = NULL;
	HRESULT hr = E_INVALIDARG;
	if (FindNode(m_ppNodeArray[hNode], KEY_IDENTITY, &pIdentityNode) && NULL != pIdentityNode)
	{
		//
		// first, based on OP team's requirement, we try to look for <itemId> in the identity tag.
		// if it's there, use use that. If not, we use the publisherName.itemname thing.
		//
		if (FAILED(hr = GetAttribute(pIdentityNode, KEY_ITEMID, pbstrUniqIdentifierString)) || NULL == *pbstrUniqIdentifierString)
		{
			// hr = UtilGetUniqIdentityStr(pIdentityNode, pbstrUniqIdentifierString, SKIP_SERVICEPACK_VER);
			hr = E_INVALIDARG;
		}
		
		SafeReleaseNULL(pIdentityNode);
	}
	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// GetBSTRItemForCallback()
//
// Create an item node as the passed-in node, have child nodes identity and
// platform (anything uniquely idenitify this item) then output this 
// item node data as string, then delete the crated node
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetBSTRItemForCallback(HANDLE_NODE hItem, BSTR* pbstrXmlItemForCallback)
{
	HRESULT hr = E_INVALIDARG;
	IXMLDOMNode* pNewItemNode = NULL;
	IXMLDOMNode* pNewIdentityNode = NULL;
	IXMLDOMNode* pNewPlatformNode = NULL;
	IXMLDOMNode* pOldIdentityNode = NULL;
	IXMLDOMNode* pOldPlatformNode = NULL;
	IXMLDOMNode* p1 = NULL, *p2 = NULL;

	LOG_Block("CXmlCatalog::GetBSTRItemForCallback()");

	if (FAILED(hr = m_ppNodeArray[hItem]->cloneNode(VARIANT_FALSE, &pNewItemNode)) ||
		FAILED(hr = FindSingleDOMNode(m_ppNodeArray[hItem], KEY_IDENTITY, &pOldIdentityNode)) || 
		NULL == pOldIdentityNode ||
		FAILED(hr = pOldIdentityNode->cloneNode(VARIANT_TRUE, &pNewIdentityNode)) ||
		NULL == pNewIdentityNode ||
		FAILED(hr = pNewItemNode->appendChild(pNewIdentityNode, &p1)) || NULL == p1)	
	{
		if (S_FALSE == hr)
			hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// platform is optional
	//
	FindSingleDOMNode(m_ppNodeArray[hItem], KEY_PLATFORM, &pOldPlatformNode);
	if (pOldPlatformNode)
	{
		if (FAILED(hr = pOldPlatformNode->cloneNode(VARIANT_TRUE, &pNewPlatformNode)) ||
			NULL == pNewPlatformNode ||
			FAILED(hr = pNewItemNode->appendChild(pNewPlatformNode, &p2)) || NULL == p2)

		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}
	}
		
	pNewItemNode->get_xml(pbstrXmlItemForCallback);
	

CleanUp:
	SafeReleaseNULL(pOldIdentityNode);
	SafeReleaseNULL(pOldPlatformNode);
	SafeReleaseNULL(pNewIdentityNode);
	SafeReleaseNULL(pNewPlatformNode);
	SafeReleaseNULL(p1);
	SafeReleaseNULL(p2);
	SafeReleaseNULL(pNewItemNode);

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// IsPrinterDriver()
//
// Retrieves from the Catalog whether this Item is a Printer Driver
//
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlCatalog::IsPrinterDriver(HANDLE_NODE hNode)
{
    LOG_Block("IsPrinterDriver()");
    BOOL fRet = FALSE;
    HRESULT hr;

    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);

    int intIsPrinter = 0;
    GetAttribute(pNodeDevice, KEY_ISPRINTER, &intIsPrinter);

    if (1 == intIsPrinter)
    {
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

CleanUp:
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// GetDriverInfo()
//
// Retrieves the Driver Information from the Catalog for this Item. Returns
// the Display Name and HWID for this driver - This is passed to the CDM 
// installer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetDriverInfo(HANDLE_NODE hNode, 
                                   BSTR* pbstrHWID, 
                                   BSTR* pbstrDisplayName)
{
    HRESULT hr;
    LOG_Block("GetDriverInfo()");

    QuitIfNull(pbstrHWID);
    QuitIfNull(pbstrDisplayName);

    *pbstrHWID = NULL;
    *pbstrDisplayName = NULL;
    
    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodeHWID = NULL;
    IXMLDOMNode* pNodeDescription = NULL;
    IXMLDOMNode* pNodeDescriptionText = NULL;
    IXMLDOMNode* pNodeTitle = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDevice, KEY_HWID, &pNodeHWID);
    CleanUpIfFailedAndMsg(hr);

    GetText(pNodeHWID, pbstrHWID);

    hr = FindSingleDOMNode(pNodeDetection, KEY_DESCRIPTION, &pNodeDescription);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescription, KEY_DESCRIPTIONTEXT, &pNodeDescriptionText);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescriptionText, KEY_TITLE, &pNodeTitle);
    CleanUpIfFailedAndMsg(hr);

    GetText(pNodeTitle, pbstrDisplayName);

CleanUp:
    if (FAILED(hr))
    {
        SafeSysFreeString(*pbstrHWID);
        SafeSysFreeString(*pbstrDisplayName);
    }
    SafeReleaseNULL(pNodeTitle);
    SafeReleaseNULL(pNodeDescriptionText);
    SafeReleaseNULL(pNodeDescription);
    SafeReleaseNULL(pNodeHWID);
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetPrinterDriverInfo()
//
// Retrieves the Printer Driver Information from the Catalog for this Item. 
// Returns the DriverName and the Architecture - This is passed to the CDM
// installer
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetPrinterDriverInfo(HANDLE_NODE hNode,
                                 BSTR* pbstrDriverName,
                                 BSTR* pbstrHWID,
								 BSTR* pbstrManufacturer,
								 BSTR* pbstrProvider)
{
    HRESULT hr = S_OK;
    LOG_Block("GetPrinterDriverInfo()");

    QuitIfNull(pbstrDriverName);
    QuitIfNull(pbstrHWID);
	QuitIfNull(pbstrManufacturer);
	QuitIfNull(pbstrProvider);

    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodePrinterInfo = NULL;
	IXMLDOMNode* pNodeHWID = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
	hr = FindSingleDOMNode(pNodeDevice, KEY_HWID, &pNodeHWID);
	CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDevice, KEY_PRINTERINFO, &pNodePrinterInfo);
    CleanUpIfFailedAndMsg(hr);

	GetText(pNodeHWID, pbstrHWID);
    GetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, pbstrDriverName);
	GetAttribute(pNodePrinterInfo, KEY_DRIVERPROVIDER, pbstrProvider);
	GetAttribute(pNodePrinterInfo, KEY_MFGNAME, pbstrManufacturer);

CleanUp:
    SafeReleaseNULL(pNodePrinterInfo);
	SafeReleaseNULL(pNodeHWID);
	SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetDriverInfoEx()
//
// Combines functionality of IsPrinterDriver, GetDriverInfo, and
// GetPrinterDriverInfo plus retreives MfgName and DriverProvider.
// Used by FindMatchingDriver()
//
// If SUCCEEDES pbstrHWID, pbstrDriverVer, and pbstrDisplayName
//    are always returned.
// If SUCCEEDES && *pFIsPrinter == TRUE then pbstrDriverName,
//    pbstrDriverProvider, and pbstrMfgName are returned.
//
// Currently pbstrArchitecture is never returned.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetDriverInfoEx(	HANDLE_NODE hNode,
										BOOL* pfIsPrinter,
										BSTR* pbstrHWID,
										BSTR* pbstrDriverVer,
										BSTR* pbstrDisplayName,
                                        BSTR* pbstrDriverName,
										BSTR* pbstrDriverProvider,
										BSTR* pbstrMfgName,
                                        BSTR* pbstrArchitecture)
{
    HRESULT hr;
    LOG_Block("GetDriverInfoEx()");

    QuitIfNull(pbstrHWID);
	QuitIfNull(pbstrDriverVer);
	QuitIfNull(pbstrDisplayName);
	QuitIfNull(pbstrDriverName);
	QuitIfNull(pbstrDriverProvider);
	QuitIfNull(pbstrMfgName);
	QuitIfNull(pbstrArchitecture);
    
	*pbstrHWID = NULL;
	*pbstrDriverVer = NULL;
	*pbstrDisplayName = NULL;
	*pbstrDriverName = NULL;
	*pbstrDriverProvider = NULL;
	*pbstrMfgName = NULL;
	*pbstrArchitecture = NULL;
    
    IXMLDOMNode* pNodeDetection = NULL;
    IXMLDOMNode* pNodeCompatibleHardware = NULL;
    IXMLDOMNode* pNodeDevice = NULL;
    IXMLDOMNode* pNodeHWID = NULL;
    IXMLDOMNode* pNodeDescription = NULL;
    IXMLDOMNode* pNodeDescriptionText = NULL;
    IXMLDOMNode* pNodeTitle = NULL;
    IXMLDOMNode* pNodePrinterInfo = NULL;

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DETECTION, &pNodeDetection);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDetection, KEY_COMPATIBLEHARDWARE, &pNodeCompatibleHardware);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeCompatibleHardware, KEY_DEVICE, &pNodeDevice);
    CleanUpIfFailedAndMsg(hr);
	//
	// Is it a printer?
	//
	int intIsPrinter = 0;
    GetAttribute(pNodeDevice, KEY_ISPRINTER, &intIsPrinter);

    if (1 == intIsPrinter)
    {
        *pfIsPrinter = TRUE;
    }
    else
    {
        *pfIsPrinter = FALSE;
    }
	//
	// HWID and Driver Description
	//
    hr = FindSingleDOMNode(pNodeDevice, KEY_HWID, &pNodeHWID);
    CleanUpIfFailedAndMsg(hr);

    hr = GetText(pNodeHWID, pbstrHWID);
    CleanUpIfFailedAndMsg(hr);

	hr = GetAttribute(pNodeHWID, KEY_DRIVERVER, pbstrDriverVer);
    CleanUpIfFailedAndMsg(hr);

    hr = FindSingleDOMNode(m_ppNodeArray[hNode], KEY_DESCRIPTION, &pNodeDescription);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescription, KEY_DESCRIPTIONTEXT, &pNodeDescriptionText);
    CleanUpIfFailedAndMsg(hr);
    hr = FindSingleDOMNode(pNodeDescriptionText, KEY_TITLE, &pNodeTitle);
    CleanUpIfFailedAndMsg(hr);

    hr = GetText(pNodeTitle, pbstrDisplayName);
    CleanUpIfFailedAndMsg(hr);

	if (*pfIsPrinter)
	{
		//
		// Printer Attributes
		//
		hr = FindSingleDOMNode(pNodeDevice, KEY_PRINTERINFO, &pNodePrinterInfo);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_DRIVERNAME, pbstrDriverName);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_DRIVERPROVIDER, pbstrDriverProvider);
		CleanUpIfFailedAndMsg(hr);

		hr = GetAttribute(pNodePrinterInfo, KEY_MFGNAME, pbstrMfgName);
		CleanUpIfFailedAndMsg(hr);

		// NOTE: Currently the CatalogSchema site is not returning 
		// architecture for printers, and the schema doesn't require it
		// CDM is using a default string for now based on compile architecture
		// so we'll leave pbstrArchitecture NULL..
	}

CleanUp:
    if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrHWID);
		SafeSysFreeString(*pbstrDriverVer);
		SafeSysFreeString(*pbstrDisplayName);
		SafeSysFreeString(*pbstrDriverName);
		SafeSysFreeString(*pbstrDriverProvider);
		SafeSysFreeString(*pbstrMfgName);
		SafeSysFreeString(*pbstrArchitecture);
	}
    SafeReleaseNULL(pNodeTitle);
    SafeReleaseNULL(pNodeDescriptionText);
    SafeReleaseNULL(pNodeDescription);
    SafeReleaseNULL(pNodeHWID);
    SafeReleaseNULL(pNodeDevice);
    SafeReleaseNULL(pNodeCompatibleHardware);
    SafeReleaseNULL(pNodeDetection);
	SafeReleaseNULL(pNodePrinterInfo);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetItemPlatformStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the <platform> node from <identity> and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemFirstPlatformStr(HANDLE_NODE hNodeItem,
					BSTR* pbstrPlatform)
{
	HRESULT hr;

	IXMLDOMNode* pNodePlatform = NULL;

	LOG_Block("GetItemFirstPlatformStr");

	USES_IU_CONVERSION;

	//
	// get the first platform node from this item node
	//
	hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatform);
	CleanUpIfFailedAndMsg(hr);

	//
	// get platform data from this ndoe and convert it into string
	//
	hr = GetPlatformStrForPing(pNodePlatform, pbstrPlatform);

CleanUp:

	SafeReleaseNULL(pNodePlatform);

	//
	// since platform is not a required element in <item>, so we should not
	// return error if not found
	//
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
		*pbstrPlatform = NULL;
		hr = S_FALSE;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// GetItemAllPlatformStr()
//
// The input node pointer points to an item node that has <platform> node(s).
// This function will retrieve every <platform> node from this item node and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemAllPlatformStr(HANDLE_NODE hNodeItem,
					BSTR** ppbPlatforms, UINT* pnPlatformCount)
{
	LOG_Block("GetItemAllPlatformStr");

	HRESULT hr;
	IXMLDOMNodeList*	pPlatformList = NULL;
	IXMLDOMElement*		pElement = NULL;
	IXMLDOMNode*		pNodePlatform = NULL;

	long				lCount = 0;
	int					i;
	BSTR*				pbstrPlatformList = NULL;

	//
	// get list of platform nodes
	//
	hr = m_ppNodeArray[hNodeItem]->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
	CleanUpIfFailedAndMsg(hr);
	hr = pElement->getElementsByTagName(KEY_PLATFORM, &pPlatformList);
	CleanUpIfFailedAndMsg(hr);

	hr = pPlatformList->get_length(&lCount);
	CleanUpIfFailedAndMsg(hr);

	if (0 == lCount)
	{
		goto CleanUp;
	}


	pbstrPlatformList = (BSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lCount * sizeof(BSTR*));
	CleanUpFailedAllocSetHrMsg(pbstrPlatformList);

	//
	// loop through each suite, if any
	//
	pPlatformList->reset();
	for (i = 0; i < lCount; i++)
	{
		hr = pPlatformList->get_item(i, &pNodePlatform);
		CleanUpIfFailedAndMsg(hr);
		if (pNodePlatform)
		{
			hr = pNodePlatform->get_text(&(pbstrPlatformList[i]));
			CleanUpIfFailedAndMsg(hr);
			pNodePlatform->Release();
			pNodePlatform = NULL;
		}
	}

	hr = S_OK;


CleanUp:
	SafeReleaseNULL(pNodePlatform);
	SafeReleaseNULL(pPlatformList);
	SafeReleaseNULL(pElement);

	if (SUCCEEDED(hr))
	{
		*pnPlatformCount = lCount;
		*ppbPlatforms = pbstrPlatformList;
	}
	else
	{
		if (NULL != pbstrPlatformList)
		{
			*pnPlatformCount = 0;
			//
			// release all possibly allocated memory
			//
			for (i = 0; i < lCount; i++)
			{
				SafeSysFreeString(pbstrPlatformList[i]);
			}
			HeapFree(GetProcessHeap(), 0, pbstrPlatformList);
		}
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemPlatformStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the <platform> node from <identity> and
// convert the data inside <platform> into a string that can be used to
// uniquely identify a platform.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetPlatformStr(IXMLDOMNode* pNodePlatform,
					BSTR* pbstrPlatform)
{
	return UtilGetPlatformStr(pNodePlatform, pbstrPlatform, 0x0);
}

HRESULT CXmlCatalog::GetPlatformStrForPing(IXMLDOMNode* pNodePlatform,
					BSTR* pbstrPlatform)
{
	return UtilGetPlatformStr(pNodePlatform, pbstrPlatform, SKIP_SUITES | SKIP_SERVICEPACK_VER);
}


/////////////////////////////////////////////////////////////////////////////
//
// get data from a version node and convert them into a string with
// format: 
//			VersionStr   = <Version>[,<SvcPackVer>[,<timeStamp>]]
//			<Version>    = <Major>[.<Minor>[.<Build>]]
//			<SvcPackVer> = <Major>[.<minor>]
//
// Assumption:
//			pszVersion points to a buffer LARGE ENOUGH to store
//			any legal version number.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::getVersionStr(IXMLDOMNode* pNodeVersion, LPTSTR pszVersion)
{
	return UtilGetVersionStr(pNodeVersion, pszVersion, 0x0);
}

HRESULT CXmlCatalog::getVersionStrWithoutSvcPack(IXMLDOMNode* pNodeVersion, LPTSTR pszVersion)
{
	return UtilGetVersionStr(pNodeVersion, pszVersion, SKIP_SERVICEPACK_VER);
}



/////////////////////////////////////////////////////////////////////////////
// GetItemFirstLanguageStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve the first <language> node from <identity> 
// node 
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemFirstLanguageStr(HANDLE_NODE hNodeItem,
					BSTR* pbstrLanguage)
{
	LOG_Block("GetItemFirstLanguageStr");

	IXMLDOMNode* pNodeIdentity = NULL;
	IXMLDOMNode* pNodeLanguage = NULL;

	HRESULT hr = m_ppNodeArray[hNodeItem]->selectSingleNode(KEY_IDENTITY, &pNodeIdentity);
	CleanUpIfFailedAndMsg(hr);

	if (pNodeIdentity)
	{
		if (HANDLE_NODELIST_INVALID == FindFirstDOMNode(pNodeIdentity, KEY_LANGUAGE, &pNodeLanguage))
		{
			hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
			goto CleanUp;
		}
		else
		{
			hr = pNodeLanguage->get_text(pbstrLanguage);
			CleanUpIfFailedAndMsg(hr);
		}
	}

CleanUp:

	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pNodeIdentity);

	//
	// since language is not a required element in <identity>, so we should not
	// return error if not found
	//
	if (HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr)
	{
		*pbstrLanguage = NULL;
		hr = S_FALSE;
	}

	return hr;

}


/////////////////////////////////////////////////////////////////////////////
// GetItemAllLanguageStr()
//
// The input node pointer points to a node has <identity> as its child.
// This function will retrieve every <language> node from <identity> node and
// convert the data into an BSTR array to return.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemAllLanguageStr(HANDLE_NODE hNodeItem,
					BSTR** ppbstrLanguage, UINT* pnLangCount)
{
	LOG_Block("GetItemAllLanguageStr");

	HRESULT				hr;
	IXMLDOMNode*		pNodeIdentity = NULL;
	IXMLDOMNodeList*	pLanguageList = NULL;
	IXMLDOMElement*		pElement = NULL;
	IXMLDOMNode*		pNodeLanguage = NULL;

	long				lCount = 0;
	int					i;
	BSTR*				pbstrLanguageList = NULL;

	hr = m_ppNodeArray[hNodeItem]->selectSingleNode(KEY_IDENTITY, &pNodeIdentity);
	CleanUpIfFailedAndMsg(hr);

	//
	// get list of  nodes
	//
	hr = pNodeIdentity->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
	CleanUpIfFailedAndMsg(hr);
	hr = pElement->getElementsByTagName(KEY_LANGUAGE, &pLanguageList);
	CleanUpIfFailedAndMsg(hr);

	hr = pLanguageList->get_length(&lCount);
	CleanUpIfFailedAndMsg(hr);

	if (0 == lCount)
	{
		goto CleanUp;
	}


	pbstrLanguageList = (BSTR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lCount * sizeof(BSTR*));
	CleanUpFailedAllocSetHrMsg(pbstrLanguageList);

	//
	// loop through each suite, if any
	//
	pLanguageList->reset();
	for (i = 0; i < lCount; i++)
	{
		hr = pLanguageList->get_item(i, &pNodeLanguage);
		CleanUpIfFailedAndMsg(hr);
		if (pNodeLanguage)
		{
			hr = pNodeLanguage->get_text(&(pbstrLanguageList[i]));
			CleanUpIfFailedAndMsg(hr);
			pNodeLanguage->Release();
			pNodeLanguage = NULL;
		}
	}

	hr = S_OK;


CleanUp:
	SafeReleaseNULL(pNodeLanguage);
	SafeReleaseNULL(pLanguageList);
	SafeReleaseNULL(pElement);
	SafeReleaseNULL(pNodeIdentity);

	if (SUCCEEDED(hr))
	{
		*pnLangCount = lCount;
		*ppbstrLanguage = pbstrLanguageList;
	}
	else
	{

		if (NULL != pbstrLanguageList)
		{
			*pnLangCount = 0;
			//
			// release all possibly allocated memory
			//
			for (i = 0; i < lCount; i++)
			{
				SafeSysFreeString(pbstrLanguageList[i]);
			}
			HeapFree(GetProcessHeap(), 0, pbstrLanguageList);
		}
	}

	return hr;



}


/////////////////////////////////////////////////////////////////////////////
// GetItemFirstCodeBase()
//
// Find the first codebase (path) of the given item
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlCatalog::GetItemFirstCodeBase(HANDLE_NODE hNodeItem,
												  BSTR* pbstrCodeBase,
												  BSTR* pbstrName,
												  BSTR* pbstrCRC,
												  BOOL* pfPatchAvailable,
												  LONG* plSize)
{
	LOG_Block("GetItemFirstCodeBase()");

	HRESULT		hr = E_FAIL;

	QuitIfNull(pbstrCodeBase);
	QuitIfNull(pbstrName);
	QuitIfNull(pbstrCRC);
	QuitIfNull(pfPatchAvailable);
	QuitIfNull(plSize);

	IXMLDOMNode*	pNodeInstall = NULL;
	IXMLDOMNode*	pNodeCodeBaseSize = NULL;

	HANDLE_NODE		hNodeCodeBase = HANDLE_NODE_INVALID;
	HANDLE_NODELIST hNodeListCodeBase = HANDLE_NODELIST_INVALID;

	*pbstrCodeBase = NULL;
	*pbstrName = NULL;
	*pbstrCRC = NULL;
	*pfPatchAvailable = FALSE;
	*plSize = -1;
	BSTR bstrSize = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
	hNodeListCodeBase = FindFirstDOMNode(pNodeInstall, KEY_CODEBASE, &hNodeCodeBase);
	if (HANDLE_NODELIST_INVALID == hNodeListCodeBase) goto CleanUp;
	CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_HREF, pbstrCodeBase));
	CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_PATCHAVAILABLE, pfPatchAvailable));
	GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_CRC, pbstrCRC); // optional attribute, don't fail if its not there.
	GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_NAME, pbstrName);
	FindSingleDOMNode(m_ppNodeArray[hNodeCodeBase], KEY_SIZE, &pNodeCodeBaseSize);
	GetText(pNodeCodeBaseSize, &bstrSize);
	if (NULL != bstrSize)
	{
		*plSize = MyBSTR2L(bstrSize);
		SysFreeString(bstrSize);
	}

CleanUp:
	SafeReleaseNULL(pNodeInstall);
	SafeReleaseNULL(pNodeCodeBaseSize);
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCodeBase);
		SafeSysFreeString(*pbstrName);
		SafeSysFreeString(*pbstrCRC);
		*pfPatchAvailable = FALSE;
		*plSize = -1;
	}
	return hNodeListCodeBase;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemNextCodeBase()
//
// Find the next codebase (path) of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemNextCodeBase(HANDLE_NODELIST hNodeListCodeBase,
										 BSTR* pbstrCodeBase,
										 BSTR* pbstrName,
										 BSTR* pbstrCRC,
										 BOOL* pfPatchAvailable,
										 LONG* plSize)
{
    LOG_Block("GetItemNextCodeBase()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeCodeBaseSize = NULL;

	HANDLE_NODE		hNodeCodeBase = HANDLE_NODE_INVALID;

	if (NULL == pbstrCodeBase || NULL == pbstrName || NULL == pbstrCRC || NULL == pfPatchAvailable || NULL == plSize)
	{
		return E_INVALIDARG;
	}

	*pbstrCodeBase = NULL;
	*pbstrName = NULL;
	*pbstrCRC = NULL;
	*pfPatchAvailable = FALSE;
	*plSize = -1;
	BSTR bstrSize = NULL;
	
	if (SUCCEEDED(hr = FindNextDOMNode(hNodeListCodeBase, &hNodeCodeBase)))
	{
		CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_HREF, pbstrCodeBase));
		CleanUpIfFailedAndSetHrMsg(GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_PATCHAVAILABLE, pfPatchAvailable));
		GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_NAME, pbstrName);
		GetAttribute(m_ppNodeArray[hNodeCodeBase], KEY_CRC, pbstrCRC);
		FindSingleDOMNode(m_ppNodeArray[hNodeCodeBase], KEY_SIZE, &pNodeCodeBaseSize);
		GetText(pNodeCodeBaseSize, &bstrSize);
		if (NULL != bstrSize)
		{
			*plSize = MyBSTR2L(bstrSize);
		}
	}

CleanUp:
	SafeReleaseNULL(pNodeCodeBaseSize);
	SafeSysFreeString(bstrSize);
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCodeBase);
		SafeSysFreeString(*pbstrCRC);
		SafeSysFreeString(*pbstrName);
		*pfPatchAvailable = FALSE;
		*plSize = -1;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemInstallInfo()
//
// Retrieve the installation information of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemInstallInfo(HANDLE_NODE hNodeItem,
                                        BSTR* pbstrInstallerType,
										BOOL* pfExclusive,
                                        BOOL* pfReboot,
                                        LONG* plNumCommands)
{
    LOG_Block("GetItemInstallInfo()");

    HRESULT     hr = E_FAIL;

    QuitIfNull(pbstrInstallerType);
	QuitIfNull(pfExclusive);
    QuitIfNull(pfReboot);
    QuitIfNull(plNumCommands);
    *pbstrInstallerType = NULL;
    *plNumCommands = 0; // may not be any, so initialize to 0

    IXMLDOMNode*        pNodeInstall = NULL;
    IXMLDOMNodeList*    pNodeListCommands = NULL;

    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_INSTALLERTYPE, pbstrInstallerType));
	CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_EXCLUSIVE, pfExclusive));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_NEEDSREBOOT, pfReboot));
    pNodeListCommands = FindDOMNodeList(pNodeInstall, KEY_COMMAND);
    if (NULL != pNodeListCommands)
    {
        CleanUpIfFailedAndSetHrMsg(pNodeListCommands->get_length(plNumCommands));
    }

CleanUp:
    if (FAILED(hr))
    {
        SafeSysFreeString(*pbstrInstallerType);
    }
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeListCommands);
    return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// GetItemInstallCommand()
//
// Find the installation command and switches of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemInstallCommand(HANDLE_NODE hNodeItem,
                                           INT   iOrder,
                                           BSTR* pbstrCommandType,
                                           BSTR* pbstrCommand,
                                           BSTR* pbstrSwitches,
                                           BSTR* pbstrInfSection)
{
    LOG_Block("GetItemInstallCommand()");

    USES_IU_CONVERSION;

    HRESULT     hr = E_FAIL;

	QuitIfNull(pbstrCommandType);
	QuitIfNull(pbstrCommand);
	QuitIfNull(pbstrSwitches);
	QuitIfNull(pbstrInfSection);

	*pbstrCommandType = NULL;
	*pbstrCommand = NULL;
	*pbstrSwitches = NULL;
	*pbstrInfSection = NULL;

    IXMLDOMNode*    pNodeInstall = NULL;
    IXMLDOMNode*    pNodeCommand = NULL;
    IXMLDOMNode*    pNodeSwitches = NULL;
    BSTR bstrNameCommand = NULL;
	BSTR bstrNameCommandTemp = SysAllocString(L"command[@order = ");

    TCHAR szCommand[64];

    hr = StringCchPrintfEx(szCommand, ARRAYSIZE(szCommand), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%ls\"%d\"]"), bstrNameCommandTemp, iOrder);
    CleanUpIfFailedAndSetHrMsg(hr);

    bstrNameCommand = SysAllocString(T2OLE(szCommand));

    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLATION, &pNodeInstall));
    CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeInstall, bstrNameCommand, &pNodeCommand));
    CleanUpIfFailedAndSetHrMsg(GetText(pNodeCommand, pbstrCommand));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeCommand, KEY_COMMANDTYPE, pbstrCommandType));
    CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeCommand, KEY_INFINSTALL, pbstrInfSection));
    if (SUCCEEDED(FindSingleDOMNode(pNodeCommand, KEY_SWITCHES, &pNodeSwitches)))
	{
		CleanUpIfFailedAndSetHrMsg(GetText(pNodeSwitches, pbstrSwitches));
	}

CleanUp:
	if (FAILED(hr))
	{
		SafeSysFreeString(*pbstrCommandType);
		SafeSysFreeString(*pbstrCommand);
		SafeSysFreeString(*pbstrSwitches);
		SafeSysFreeString(*pbstrInfSection);
	}
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeCommand);
    SafeReleaseNULL(pNodeSwitches);
    SysFreeString(bstrNameCommand);
    SysFreeString(bstrNameCommandTemp);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CloseItem()
//
// Release the item node
/////////////////////////////////////////////////////////////////////////////
void CXmlCatalog::CloseItem(HANDLE_NODE hNodeItem)
{
	SafeCloseHandleNode(hNodeItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetTotalEstimatedSize()
//
// Get the Total Estimated Download Size of all Items based on Codebase Size
HRESULT CXmlCatalog::GetTotalEstimatedSize(LONG *plTotalSize)
{
    LOG_Block("GetTotalEstimatedSize()");

    HRESULT hr = E_FAIL;
    BSTR bstrCodebaseSize = NULL;
    IXMLDOMNodeList *pItemList = NULL;
    IXMLDOMNodeList *pCodebaseList = NULL;
    IXMLDOMNode *pNodeItem = NULL;
    IXMLDOMNode *pNodeInstall = NULL;
    IXMLDOMNode *pNodeCodebase = NULL;
    IXMLDOMNode *pNodeSize = NULL;
    LONG lItemCount = 0;
    LONG lCodebaseCount = 0;
    LONG lTotalSize = 0;

    QuitIfNull(plTotalSize);
    *plTotalSize = 0;

	IXMLDOMNode	*pParentNode = NULL;
	CleanUpIfFailedAndSetHrMsg(m_pDocCatalog->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode));
	CleanUpIfFailedAndSetHrMsg(pParentNode->selectNodes(KEY_ITEM_SEARCH, &pItemList));
    if (NULL == pItemList) goto CleanUp;

    CleanUpIfFailedAndSetHrMsg(pItemList->get_length(&lItemCount));
    if (0 == lItemCount) goto CleanUp; // no items

    // Loop through each Item
    CleanUpIfFailedAndSetHrMsg(pItemList->nextNode(&pNodeItem));
    while (NULL != pNodeItem)
    {
        // Get Installation Element
        CleanUpIfFailedAndSetHrMsg(pNodeItem->selectSingleNode(KEY_INSTALLATION, &pNodeInstall));
        if (NULL == pNodeInstall) goto CleanUp;

        CleanUpIfFailedAndSetHrMsg(pNodeInstall->selectNodes(KEY_CODEBASE, &pCodebaseList));
        if (NULL == pCodebaseList) goto CleanUp;

        CleanUpIfFailedAndSetHrMsg(pCodebaseList->get_length(&lCodebaseCount));
        if (0 == lCodebaseCount) goto CleanUp; // must be at least 1 cab

        // Loop through each Codebase Getting the Size for Each one
        CleanUpIfFailedAndSetHrMsg(pCodebaseList->nextNode(&pNodeCodebase));
        while (NULL != pNodeCodebase)
        {
            // Get the Size Element
            CleanUpIfFailedAndSetHrMsg(pNodeCodebase->selectSingleNode(KEY_SIZE, &pNodeSize));
            if (NULL != pNodeSize)
            {
                pNodeSize->get_text(&bstrCodebaseSize);
                if (NULL != bstrCodebaseSize)
                {
                    // Add this Codebase's size to the total download size
                    lTotalSize += (DWORD) MyBSTR2L(bstrCodebaseSize);
                    SafeSysFreeString(bstrCodebaseSize);
                }
            }
            SafeReleaseNULL(pNodeSize);
            SafeReleaseNULL(pNodeCodebase);
            CleanUpIfFailedAndSetHrMsg(pCodebaseList->nextNode(&pNodeCodebase));
        }
        SafeReleaseNULL(pCodebaseList);
        SafeReleaseNULL(pNodeInstall);
        SafeReleaseNULL(pNodeItem);
        CleanUpIfFailedAndSetHrMsg(pItemList->nextNode(&pNodeItem)); // get the next Item Node
    }

    // Update the Total Size after completing.. if we fail anywhere through here
    // we'll return 0.
    *plTotalSize = lTotalSize;

CleanUp:
	SafeReleaseNULL(pParentNode);
    SafeReleaseNULL(pItemList);
    SafeReleaseNULL(pCodebaseList);
    SafeReleaseNULL(pNodeItem);
    SafeReleaseNULL(pNodeInstall);
    SafeReleaseNULL(pNodeCodebase);
    SafeReleaseNULL(pNodeSize);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindItemByIdentity()
//
// Input:
// pNodeIdentity - a pointer to an Identity Node to match against an Items
//                 identity in the Catalog. We will search through each item
//                 till we find a match with the supplied identity                 
//                 
// Output:
// phNodeItem    - Handle of the found Item
//                 
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::FindItemByIdentity(IXMLDOMNode* pNodeIdentity, HANDLE_NODE* phNodeItem)
{
    LOG_Block("FindItemByIdentity()");

    HRESULT hr = E_FAIL;

    IXMLDOMNode*    pNodeIdentityDes = NULL;
    
    *phNodeItem = HANDLE_NODE_INVALID;
    HANDLE_NODE hNodeItem = HANDLE_NODE_INVALID;
    HANDLE_NODELIST hNodeList = HANDLE_NODELIST_INVALID;

    hNodeList = FindFirstDOMNode(m_pDocCatalog, KEY_ITEM_SEARCH, &hNodeItem);
    if (HANDLE_NODELIST_INVALID != hNodeList)
    {
        CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
        if (AreNodesEqual(pNodeIdentityDes, pNodeIdentity))
        {
            *phNodeItem = hNodeItem;
            goto CleanUp;
        }

        SafeReleaseNULL(pNodeIdentityDes);
        SafeReleaseNULL(m_ppNodeArray[hNodeItem]);

        while (SUCCEEDED(FindNextDOMNode(hNodeList, &hNodeItem)))
        {
            CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
            if (AreNodesEqual(pNodeIdentityDes, pNodeIdentity))
            {
                *phNodeItem = hNodeItem;
                goto CleanUp;
            }
            SafeReleaseNULL(pNodeIdentityDes);
            SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
        }
    }

CleanUp:
    CloseItemList(hNodeList);
    SafeReleaseNULL(pNodeIdentityDes);

    if (HANDLE_NODE_INVALID == *phNodeItem)
    {
        LOG_Error(_T("Can't find the matching Item Node in Catalog"));
        hr = E_FAIL;
    }
    return hr;
}


/*
/////////////////////////////////////////////////////////////////////////////
// IfSameIdentity()
//
// Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlCatalog::IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2)
{
    LOG_Block("IfSameIdentity()");

    BOOL fResult = FALSE;
    BSTR bstrNameGUID = SysAllocString(L"guid");
    BSTR bstrNameIDName = SysAllocString(L"name");
    BSTR bstrNameIDPublisherName = SysAllocString(L"publisherName");
    BSTR bstrNameType = SysAllocString(L"type");
    BSTR bstrNameVersion = SysAllocString(L"version");
    BSTR bstrNameLanguage = SysAllocString(L"language");

    //
    // compare <guid> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameGUID))
    {
        goto CleanUp;
    }

    //
    // compare <publisherName> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameIDPublisherName))
    {
        goto CleanUp;
    }

    //
    // compare "name" attribute, this is a required attribute
    //
    if (!IfHasSameAttribute(pNodeIdentity1, pNodeIdentity2, bstrNameIDName, FALSE))
    {
        goto CleanUp;
    }

    //
    // compare <type> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameType))
    {
        goto CleanUp;
    }

    //
    // compare <version> node, which really means "file version" here
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameVersion))
    {
        goto CleanUp;
    }

    //
    // compare <language> node
    //
    if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameLanguage))
    {
        goto CleanUp;
    }

    fResult = TRUE;

CleanUp:
    SysFreeString(bstrNameGUID);
    SysFreeString(bstrNameIDName);
    SysFreeString(bstrNameIDPublisherName);
    SysFreeString(bstrNameType);
    SysFreeString(bstrNameVersion);
    SysFreeString(bstrNameLanguage);
    if (!fResult)
    {
        LOG_XML(_T("Different <identity>\'s found."));
    }
    else
    {
        LOG_XML(_T("Same <identity>\'s found."));
    }
    return fResult;
}
*/

/////////////////////////////////////////////////////////////////////////////
// GetItemLanguage()
//
// Get the Language Entity from the Item Identity
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetItemLanguage(HANDLE_NODE hNodeItem, BSTR* pbstrLanguage)
{
    HRESULT hr = S_OK;
    if (HANDLE_NODE_INVALID == hNodeItem || NULL == pbstrLanguage)
    {
        return E_INVALIDARG;
    }

    IXMLDOMNode *pNodeIdentity = NULL;
    IXMLDOMNode *pNodeLanguage = NULL;
    
    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentity);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodeIdentity, KEY_LANGUAGE, &pNodeLanguage);
    if (FAILED(hr))
        goto CleanUp;

    hr = GetText(pNodeLanguage, pbstrLanguage);
    if (FAILED(hr))
        goto CleanUp;

CleanUp:
    SafeReleaseNULL(pNodeLanguage);
    SafeReleaseNULL(pNodeIdentity);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetCorpItemPlatformStr()
//
// Get the Simplified Platform String for an Item (uses the first available platform element)
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlCatalog::GetCorpItemPlatformStr(HANDLE_NODE hNodeItem, BSTR* pbstrPlatformStr)
{
    HRESULT hr = S_OK;
    if (HANDLE_NODE_INVALID == hNodeItem || NULL == pbstrPlatformStr)
    {
        return E_INVALIDARG;
    }

    IXMLDOMNode *pNodePlatform = NULL;
    IXMLDOMNode *pNodePlatformArchitecture = NULL;
    IXMLDOMNode *pNodePlatformVersion = NULL;
    BSTR bstrPlatformName = NULL;
    BSTR bstrArchitecture = NULL;
    int iMajor = 0;
    int iMinor = 0;


    hr = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatform);
    if (FAILED(hr))
        goto CleanUp;

    hr = GetAttribute(pNodePlatform, KEY_NAME, &bstrPlatformName);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodePlatform, KEY_PROCESSORARCHITECTURE, &pNodePlatformArchitecture);
    if (FAILED(hr))
        goto CleanUp;

    hr = FindSingleDOMNode(pNodePlatform, KEY_VERSION, &pNodePlatformVersion);
    if (FAILED(hr))
        goto CleanUp;

	if (NULL != bstrPlatformName && 0 != SysStringLen(bstrPlatformName))
    {
		if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
			bstrPlatformName, -1, L"VER_PLATFORM_WIN32_NT", -1))
		{
			// this is an NT platform
			hr = GetAttribute(pNodePlatformVersion, KEY_MAJOR, &iMajor);
			if (FAILED(hr))
				goto CleanUp;

			if (4 == iMajor)
			{
				// WinNT4
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_NT4);
			}
			else // 5 == iMajor
			{
				hr = GetAttribute(pNodePlatformVersion, KEY_MINOR, &iMinor);
				if (FAILED(hr))
					goto CleanUp;

				if (iMinor > 0)
				{
					hr = GetText(pNodePlatformArchitecture, &bstrArchitecture);
					if (FAILED(hr))
						goto CleanUp;
					// whistler
					if (CSTR_EQUAL == CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
						bstrArchitecture, -1, L"x86", -1))
					{
						// x86WinXP
						*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_X86WHI);
					}
					else
					{
						// ia64WinXP
						*pbstrPlatformStr = SysAllocString(CORP_PLATFROM_DIR_IA64WHI);
					}
				}
				else
				{
					// x86Win2k
					*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_NT5);
				}
			}
		}
		else // VER_PLATFORM_WIN32_WINDOWS
		{
			// this is a Win9x platform
			hr = GetAttribute(pNodePlatformVersion, KEY_MINOR, &iMinor);
			if (FAILED(hr))
				goto CleanUp;

			if (iMinor >= 90)
			{
				// x86WinME
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_WINME);
			}
			else if (iMinor > 0 && iMinor < 90)
			{
				// x86Win98
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_W98);
			}
			else
			{
				// x86Win95
				*pbstrPlatformStr = SysAllocString(CORP_PLATFORM_DIR_W95);
			}
		}
	}

CleanUp:
    SysFreeString(bstrPlatformName);
    SysFreeString(bstrArchitecture);
    SafeReleaseNULL(pNodePlatformVersion);
    SafeReleaseNULL(pNodePlatformArchitecture);
    SafeReleaseNULL(pNodePlatform);
    return hr;
}




/////////////////////////////////////////////////////////////////////////////
// CXmlItems

/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Items; this is for write only
/////////////////////////////////////////////////////////////////////////////
CXmlItems::CXmlItems()
 : m_pDocItems(NULL),
   m_pNodeItems(NULL)
{
    LOG_Block("CXmlItems()");

	Init();
}


/////////////////////////////////////////////////////////////////////////////
// Constructor
//
// Create IXMLDOMDocument* for Items; take TRUE for read, FALSE for write
/////////////////////////////////////////////////////////////////////////////
CXmlItems::CXmlItems(BOOL fRead)
 : m_pDocItems(NULL),
   m_pNodeItems(NULL)
{
    LOG_Block("CXmlItems(BOOL fRead)");

	//
	// for writing Items only
	//
	if (!fRead)
	{
		Init();
	}
}


/////////////////////////////////////////////////////////////////////////////
//
// Initialize XML DOC node pointers before writing
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::Init()
{
	LOG_Block("Init()");

 	HRESULT hr = CoCreateInstance(CLSID_DOMDocument,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IXMLDOMDocument,
								  (void **) &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		IXMLDOMNode*	pNodeXML = NULL;
		BSTR bstrNameSpaceSchema = NULL;

		//
		// create the <?xml version="1.0"?> node
		//
		pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
		if (NULL == pNodeXML) goto CleanUp;

		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

		//
		// process the iuident.txt to find the Items schema path
		//
		TCHAR szIUDir[MAX_PATH];
		TCHAR szIdentFile[MAX_PATH];
		LPTSTR pszItemsSchema = NULL;
		LPTSTR pszNameSpaceSchema = NULL;

		pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszItemsSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
		pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
		if (NULL == pszNameSpaceSchema)
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
			goto CleanUp;
		}
	
		GetIndustryUpdateDirectory(szIUDir);
		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		GetPrivateProfileString(IDENT_IUSCHEMA,
								IDENT_IUSCHEMA_ITEMS,
								_T(""),
								pszItemsSchema,
								INTERNET_MAX_URL_LENGTH,
								szIdentFile);

		if ('\0' == pszItemsSchema[0])
		{
			// no Items schema path specified in iuident.txt
			LOG_Error(_T("No schema path specified in iuident.txt for Items"));
			goto CleanUp;
		}
		
		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
		                       _T("x-schema:%s"), pszItemsSchema);
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

		//
		// create the <items> node with the path of the schema
		//
		m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
		if (NULL == m_pNodeItems) goto CleanUp;
		
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));

CleanUp:
		SafeReleaseNULL(pNodeXML);
		SysFreeString(bstrNameSpaceSchema);
		SafeHeapFree(pszItemsSchema);
		SafeHeapFree(pszNameSpaceSchema);
	}
}


/////////////////////////////////////////////////////////////////////////////
// Destructor
//
// Release IXMLDOMDocument* for Items
/////////////////////////////////////////////////////////////////////////////
CXmlItems::~CXmlItems()
{
	SafeReleaseNULL(m_pNodeItems);
	SafeReleaseNULL(m_pDocItems);
}


/////////////////////////////////////////////////////////////////////////////
// Clear()
//
// Reset IXMLDOMDocument* for Items
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::Clear()
{
	SafeReleaseNULL(m_pNodeItems);
	SafeReleaseNULL(m_pDocItems);
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocument()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::LoadXMLDocument(BSTR bstrXml)
{
	LOG_Block("LoadXMLDocument()");
	SafeReleaseNULL(m_pDocItems);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// LoadXMLDocumentFile()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::LoadXMLDocumentFile(BSTR bstrFilePath)
{
	LOG_Block("LoadXMLDocumentFile()");
	SafeReleaseNULL(m_pDocItems);
	HRESULT hr = LoadDocument(bstrFilePath, &m_pDocItems);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveXMLDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::SaveXMLDocument(BSTR bstrFilePath)
{
	LOG_Block("SaveXMLDocument()");
	HRESULT hr = SaveDocument(m_pDocItems, bstrFilePath);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddGlobalErrorCodeIfNoItems()
//
// Add the errorCode attribute for <items> if there's no <itemStatus> child node
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlItems::AddGlobalErrorCodeIfNoItems(DWORD dwErrorCode)
{
	LOG_Block("AddGlobalErrorCodeIfNoItems()");

	HRESULT			hr = S_OK;
	IXMLDOMNode*	pNodeItem = NULL;
	HANDLE_NODE		hNodeItemStatus = HANDLE_NODE_INVALID;

	FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, &hNodeItemStatus);
	if (HANDLE_NODE_INVALID == hNodeItemStatus)
	{
		//
		// set the "errorCode" attribute
		//
		FindFirstDOMNode(m_pDocItems, KEY_ITEMS, &pNodeItem);
		if (NULL != pNodeItem)
		{
			hr = SetAttribute(pNodeItem, KEY_ERRORCODE, dwErrorCode);
		}
	}
	
	SafeReleaseNULL(pNodeItem);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetFirstItem()
//
// Find the first item in Items xml doc
/////////////////////////////////////////////////////////////////////////////
HANDLE_NODELIST CXmlItems::GetFirstItem(HANDLE_NODE* phNodeItem)
{
	LOG_Block("GetFirstItem()");

	HANDLE_NODELIST hNodeListItem = FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, phNodeItem);
	
	return hNodeListItem;
}

	
/////////////////////////////////////////////////////////////////////////////
// GetNextItem()
//
// Find the next item in Items xml doc
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetNextItem(HANDLE_NODELIST hNodeListItem, HANDLE_NODE* phNodeItem)
{
    LOG_Block("GetNextItem()");

	return FindNextDOMNode(hNodeListItem, phNodeItem);
}

	
/////////////////////////////////////////////////////////////////////////////
// CloseItemList()
//
// Release the item nodelist
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::CloseItemList(HANDLE_NODELIST hNodeListItem)
{
	SafeFindCloseHandle(hNodeListItem);
}


/////////////////////////////////////////////////////////////////////////////
// GetItemDownloadPath()
//
// Retrieve the download path of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemDownloadPath(HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath)
{
    LOG_Block("GetItemDownloadPath()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadPath = NULL;

	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_DOWNLOADPATH, &pNodeDownloadPath));
	CleanUpIfFailedAndSetHrMsg(GetText(pNodeDownloadPath, pbstrDownloadPath));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemDownloadPath()
//
// Retrieve the download path of the given item in catalog
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemDownloadPath(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, BSTR* pbstrDownloadPath)
{
    LOG_Block("GetItemDownloadPath() for an item in catalog");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeItem = NULL;
	IXMLDOMNode*	pNodeDownloadPath = NULL;

	HANDLE_NODE	hNodeItemsItem = HANDLE_NODE_INVALID;

	if (NULL != (pNodeItem = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		hr = FindItem(pNodeItem, &hNodeItemsItem, TRUE);
	}
	else
	{
		LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	if (FAILED(hr) || HANDLE_NODE_INVALID == hNodeItemsItem)
	{
		LOG_Error(_T("Can't find item from Items xml"));
		goto CleanUp;
	}
	
	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItemsItem], KEY_DOWNLOADPATH, &pNodeDownloadPath));
	CleanUpIfFailedAndSetHrMsg(GetText(pNodeDownloadPath, pbstrDownloadPath));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CloseItem()
//
// Release the item node
/////////////////////////////////////////////////////////////////////////////
void CXmlItems::CloseItem(HANDLE_NODE hNodeItem)
{
	SafeCloseHandleNode(hNodeItem);
}


/////////////////////////////////////////////////////////////////////////////
// FindItem()
//
// Input:
// pNodeItem	- the <itemStatus> node of the install items xml; we need
//                to find the corresponding <itemStatus> node in the existing 
//                items xml with the identical <identity>, <platform> and 
//                <client> nodes.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in the existing items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::FindItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem, BOOL fIdentityOnly /*= FALSE*/)
{
	LOG_Block("FindItem()");

	HRESULT		hr1, hr2, hr = E_FAIL;

	IXMLDOMNode*	pNodeIdentitySrc = NULL;
	IXMLDOMNode*	pNodeIdentityDes = NULL;
	IXMLDOMNode*	pNodePlatformSrc = NULL;
	IXMLDOMNode*	pNodePlatformDes = NULL;
	IXMLDOMNode*	pNodeClientSrc = NULL;
	IXMLDOMNode*	pNodeClientDes = NULL;

	*phNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	hNodeList = FindFirstDOMNode(m_pDocItems, KEY_ITEM_ITEMSTATUS, &hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
		CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIdentitySrc));
		if (AreNodesEqual(pNodeIdentityDes, pNodeIdentitySrc))
		{
			if (fIdentityOnly)
			{
				//
				// we now found the match
				//
				*phNodeItem = hNodeItem;
				goto CleanUp;
			}
			else
			{
				hr1 = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatformDes);
				hr2 = FindSingleDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatformSrc);
				if ((FAILED(hr1) && FAILED(hr2)) ||
					(SUCCEEDED(hr1) && SUCCEEDED(hr2) && AreNodesEqual(pNodePlatformDes, pNodePlatformSrc)))
				{
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_CLIENT, &pNodeClientDes));
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClientSrc));
					if (AreNodesEqual(pNodeClientDes, pNodeClientSrc))
					{
						//
						// we now found the match
						//
						*phNodeItem = hNodeItem;
						goto CleanUp;
					}
				}
			}
		}
		SafeReleaseNULL(pNodeClientDes);
		SafeReleaseNULL(pNodeClientSrc);
		SafeReleaseNULL(pNodePlatformDes);
		SafeReleaseNULL(pNodePlatformSrc);
		SafeReleaseNULL(pNodeIdentityDes);
		SafeReleaseNULL(pNodeIdentitySrc);
		SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
		while (SUCCEEDED(FindNextDOMNode(hNodeList, &hNodeItem)))
		{
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_IDENTITY, &pNodeIdentityDes));
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIdentitySrc));
			if (AreNodesEqual(pNodeIdentityDes, pNodeIdentitySrc))
			{
				if (fIdentityOnly)
				{
					//
					// we now found the match
					//
					*phNodeItem = hNodeItem;
					goto CleanUp;
				}
				else
				{
					hr1 = FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_PLATFORM, &pNodePlatformDes);
					hr2 = FindSingleDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatformSrc);
					if ((FAILED(hr1) && FAILED(hr2)) ||
						(SUCCEEDED(hr1) && SUCCEEDED(hr2) && AreNodesEqual(pNodePlatformDes, pNodePlatformSrc)))
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_CLIENT, &pNodeClientDes));
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClientSrc));
						if (AreNodesEqual(pNodeClientDes, pNodeClientSrc))
						{
							//
							// we now found the match
							//
							*phNodeItem = hNodeItem;
							break;
						}
					}
				}
			}
			SafeReleaseNULL(pNodeClientDes);
			SafeReleaseNULL(pNodeClientSrc);
			SafeReleaseNULL(pNodePlatformDes);
			SafeReleaseNULL(pNodePlatformSrc);
			SafeReleaseNULL(pNodeIdentityDes);
			SafeReleaseNULL(pNodeIdentitySrc);
			SafeReleaseNULL(m_ppNodeArray[hNodeItem]);
		}
	}

CleanUp:
	CloseItemList(hNodeList);
	SafeReleaseNULL(pNodeClientDes);
	SafeReleaseNULL(pNodeClientSrc);
	SafeReleaseNULL(pNodePlatformDes);
	SafeReleaseNULL(pNodePlatformSrc);
	SafeReleaseNULL(pNodeIdentityDes);
	SafeReleaseNULL(pNodeIdentitySrc);
	if (HANDLE_NODE_INVALID == *phNodeItem)
	{
		LOG_Error(_T("Can't find the identical item node in existing Items xml"));
		hr = E_FAIL;
	}
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindItem()
//
// Input:
// pCatalog		- the pointer to the CXmlCatalog object
// hNodeItem	- the handle of the <item> node of the catalog xml; we need
//                to find the corresponding <itemStatus> node in the existing 
//                items xml with the identical <identity>, <platform> and 
//                <client> nodes.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::FindItem(CXmlCatalog* pCatalog,
							HANDLE_NODE hNodeItem,
							HANDLE_NODE* phNodeItem)
{
	LOG_Block("FindItem() by handle");

	IXMLDOMNode*	pNode = NULL;

	if (NULL != (pNode = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		return FindItem(pNode, phNodeItem, TRUE);
	}
	LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
	return E_FAIL;
}

	
/*
/////////////////////////////////////////////////////////////////////////////
// IfSameClientInfo()
//
// Return TRUE if the two <client> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSameClientInfo(IXMLDOMNode* pNodeClient1, IXMLDOMNode* pNodeClient2)
{
    LOG_Block("IfSameClientInfo()");

	BSTR bstrText1 = NULL, bstrText2 = NULL;
	BOOL fResult = FALSE;

	GetText(pNodeClient1, &bstrText1);
	GetText(pNodeClient2, &bstrText2);

	if (NULL != bstrText1 && NULL != bstrText2)
	{
		fResult = CompareBSTRsEqual(bstrText1, bstrText2);
	}

	SysFreeString(bstrText1);
	SysFreeString(bstrText2);
	if (!fResult)
	{
		LOG_XML(_T("Different <client>\'s found."));
	}
	else
	{
		LOG_XML(_T("Same <client>\'s found."));
	}
	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// IfSameIdentity()
//
// Return TRUE if the two <identity> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSameIdentity(IXMLDOMNode* pNodeIdentity1, IXMLDOMNode* pNodeIdentity2)
{
    LOG_Block("IfSameIdentity()");

	BOOL fResult = FALSE;
	BSTR bstrNameGUID = SysAllocString(L"guid");
	BSTR bstrNameIDName = SysAllocString(L"name");
	BSTR bstrNameIDPublisherName = SysAllocString(L"publisherName");
	BSTR bstrNameType = SysAllocString(L"type");
	BSTR bstrNameVersion = SysAllocString(L"version");
	BSTR bstrNameLanguage = SysAllocString(L"language");

	//
	// compare <guid> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameGUID))
	{
		goto CleanUp;
	}

	//
	// compare <publisherName> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameIDPublisherName))
	{
		goto CleanUp;
	}

	//
	// compare "name" attribute, this is a required attribute
	//
	if (!IfHasSameAttribute(pNodeIdentity1, pNodeIdentity2, bstrNameIDName, FALSE))
	{
		goto CleanUp;
	}

	//
	// compare <type> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameType))
	{
		goto CleanUp;
	}

	//
	// compare <version> node, which really means "file version" here
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameVersion))
	{
		goto CleanUp;
	}

	//
	// compare <language> node
	//
	if (!IfHasSameElement(pNodeIdentity1, pNodeIdentity2, bstrNameLanguage))
	{
		goto CleanUp;
	}

	fResult = TRUE;

CleanUp:
	SysFreeString(bstrNameGUID);
	SysFreeString(bstrNameIDName);
	SysFreeString(bstrNameIDPublisherName);
	SysFreeString(bstrNameType);
	SysFreeString(bstrNameVersion);
	SysFreeString(bstrNameLanguage);
	if (!fResult)
	{
		LOG_XML(_T("Different <identity>\'s found."));
	}
	else
	{
		LOG_XML(_T("Same <identity>\'s found."));
	}
	return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// IfSamePlatform()
//
// Return TRUE if the two <platform> nodes are identical. Return FALSE otherwise.
/////////////////////////////////////////////////////////////////////////////
BOOL CXmlItems::IfSamePlatform(IXMLDOMNode* pNodePlatform1, IXMLDOMNode* pNodePlatform2)
{
    LOG_Block("IfSamePlatform()");

	HRESULT		hr1 = S_OK, hr2 = S_OK;
	BSTR		bstrPlatform1 = NULL, bstrPlatform2 = NULL;
	BOOL		fResult = FALSE;

	hr1 = pNodePlatform1->get_xml(&bstrPlatform1);
	hr2 = pNodePlatform2->get_xml(&bstrPlatform2);

	if (FAILED(hr1) || FAILED(hr2) || !CompareBSTRsEqual(bstrPlatform1, bstrPlatform2))
		goto CleanUp;

	fResult = TRUE;

CleanUp:
	SysFreeString(bstrPlatform1);
	SysFreeString(bstrPlatform2);
	return fResult;
}
*/


/////////////////////////////////////////////////////////////////////////////
// MergeItemDownloaded()
//
// Insert items with download history into existing history (insert in front)
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::MergeItemDownloaded(CXmlItems *pHistoryDownload)
{
	LOG_Block("MergeItemDownloaded()");

	HRESULT		hr = S_OK;

	IXMLDOMNode*		pNodeItem = NULL;
	IXMLDOMNode*		pNodeItemNew = NULL;
	IXMLDOMNode*		pNodeItemRef = NULL;
	IXMLDOMNode*		pNodeXML = NULL;
	BSTR bstrNameSpaceSchema = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeListItem = HANDLE_NODELIST_INVALID;

	hNodeListItem = pHistoryDownload->GetFirstItem(&hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeListItem)
	{
		//
		// if this is the first time writing history
		// (e.g. the log file does not exist yet), do
		// initialization for m_pDocItems here...
		//
		if (NULL == m_pDocItems)
		{

 			hr = CoCreateInstance(CLSID_DOMDocument,
										  NULL,
										  CLSCTX_INPROC_SERVER,
										  IID_IXMLDOMDocument,
										  (void **) &m_pDocItems);
			if (FAILED(hr))
			{
				LOG_ErrorMsg(hr);
			}
			else
			{
				//
				// create the <?xml version="1.0"?> node
				//
				pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
				if (NULL == pNodeXML) goto CleanUp;

				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

				//
				// process the iuident.txt to find the Items schema path
				//
				TCHAR szIUDir[MAX_PATH];
				TCHAR szIdentFile[MAX_PATH];

				pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszItemsSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
				pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszNameSpaceSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
	
				GetIndustryUpdateDirectory(szIUDir);
        		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}

				GetPrivateProfileString(IDENT_IUSCHEMA,
										IDENT_IUSCHEMA_ITEMS,
										_T(""),
										pszItemsSchema,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				if ('\0' == pszItemsSchema[0])
				{
					// no Items schema path specified in iuident.txt
					LOG_Error(_T("No schema path specified in iuident.txt for Items"));
					goto CleanUp;
				}
				
        		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
        		                       _T("x-schema:%s"), pszItemsSchema);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}
				
				bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

				//
				// create the <items> node with the path of the schema
				//
				m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
				if (NULL == m_pNodeItems) goto CleanUp;
				
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
			}
		}
		else
		{
		    SafeReleaseNULL(m_pNodeItems);
			FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems);
		}

		if (NULL != m_pNodeItems)
		{
			if (NULL != (pNodeItem = pHistoryDownload->GetDOMNodebyHandle(hNodeItem)))
			{
				CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
				CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
//				SafeReleaseNULL(pNodeItem);
				SafeReleaseNULL(pNodeItemNew);
				SafeReleaseNULL(pNodeItemRef);
			}
			while (SUCCEEDED(pHistoryDownload->GetNextItem(hNodeListItem, &hNodeItem)))
			{
				if (NULL != (pNodeItem = pHistoryDownload->GetDOMNodebyHandle(hNodeItem)))
				{
					CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
					CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
//					SafeReleaseNULL(pNodeItem);
					SafeReleaseNULL(pNodeItemNew);
					SafeReleaseNULL(pNodeItemRef);
				}
			}
		}
	}

CleanUp:
	pHistoryDownload->CloseItemList(hNodeListItem);
//	SafeReleaseNULL(pNodeItem);
	SafeReleaseNULL(pNodeItemNew);
	SafeReleaseNULL(pNodeItemRef);
	SafeReleaseNULL(pNodeXML);
	SysFreeString(bstrNameSpaceSchema);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// UpdateItemInstalled()
//
// Update items with installation history in existing history
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::UpdateItemInstalled(CXmlItems *pHistoryInstall)
{
	LOG_Block("UpdateItemInstalled()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;

	IXMLDOMNode*		pNodeItem = NULL;
	IXMLDOMNode*		pNodeItemNew = NULL;
	IXMLDOMNode*		pNodeItemRef = NULL;
	IXMLDOMNode*		pNodeItemExist = NULL;
	IXMLDOMNode*		pNodeInstall = NULL;
	IXMLDOMNode*		pNodeInstallExist = NULL;
	IXMLDOMNode*		pNodeInstallNew = NULL;
	IXMLDOMNode*		pNodeInstallOut = NULL;
	IXMLDOMNode*		pNodeXML = NULL;
	BSTR bstrInstallStatusExist = NULL;
	BSTR bstrInstallStatusNew = NULL;
	BSTR bstrTimeStamp = NULL;
	BSTR bstrNameSpaceSchema = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	HANDLE_NODE	hNodeItem = HANDLE_NODE_INVALID;
	HANDLE_NODE	hNodeItemExist = HANDLE_NODE_INVALID;
	HANDLE_NODELIST	hNodeListItem = HANDLE_NODELIST_INVALID;

	hNodeListItem = pHistoryInstall->GetFirstItem(&hNodeItem);
	if (HANDLE_NODELIST_INVALID != hNodeListItem)
	{
		//
		// if this is the first time writing history
		// (e.g. the log file does not exist yet), do
		// initialization for m_pDocItems here...
		//
		if (NULL == m_pDocItems)
		{

 			hr = CoCreateInstance(CLSID_DOMDocument,
										  NULL,
										  CLSCTX_INPROC_SERVER,
										  IID_IXMLDOMDocument,
										  (void **) &m_pDocItems);
			if (FAILED(hr))
			{
				LOG_ErrorMsg(hr);
			}
			else
			{
				//
				// create the <?xml version="1.0"?> node
				//
				pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
				if (NULL == pNodeXML) goto CleanUp;

				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

				//
				// process the iuident.txt to find the Items schema path
				//
				TCHAR szIUDir[MAX_PATH];
				TCHAR szIdentFile[MAX_PATH];

				pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszItemsSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
				pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
				if (NULL == pszNameSpaceSchema)
				{
					hr = E_OUTOFMEMORY;
					LOG_ErrorMsg(hr);
					goto CleanUp;
				}
	
				GetIndustryUpdateDirectory(szIUDir);
        		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}

				GetPrivateProfileString(IDENT_IUSCHEMA,
										IDENT_IUSCHEMA_ITEMS,
										_T(""),
										pszItemsSchema,
										INTERNET_MAX_URL_LENGTH,
										szIdentFile);

				if ('\0' == pszItemsSchema[0])
				{
					// no Items schema path specified in iuident.txt
					LOG_Error(_T("No schema path specified in iuident.txt for Items"));
					goto CleanUp;
				}

        		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
        		                       _T("x-schema:%s"), pszItemsSchema);
        		if (FAILED(hr))
        		{
        			LOG_ErrorMsg(hr);
        			goto CleanUp;
        		}
				
				bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

				//
				// create the <items> node with the path of the schema
				//
				m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
				if (NULL == m_pNodeItems) goto CleanUp;
				
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
			}
		}
		else
		{
		    SafeReleaseNULL(m_pNodeItems);
			CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems));
		}

		if (NULL != (pNodeItem = pHistoryInstall->GetDOMNodebyHandle(hNodeItem)))
		{
			if (SUCCEEDED(FindItem(pNodeItem, &hNodeItemExist)))
			{
				//
				// successfully found the match
				//
				if (NULL != (pNodeItemExist = GetDOMNodebyHandle(hNodeItemExist)))
				{
					CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_INSTALLSTATUS, &pNodeInstall));			
					FindSingleDOMNode(pNodeItemExist, KEY_INSTALLSTATUS, &pNodeInstallExist);
					if (NULL != pNodeInstallExist)
					{
						//
						// found the item already with installStatus; now find out if we want to update
						// or append the installStatus
						//
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstallExist, KEY_VALUE, &bstrInstallStatusExist));
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_VALUE, &bstrInstallStatusNew));		
						if (CSTR_EQUAL == WUCompareStringI(OLE2T(bstrInstallStatusExist), _T("IN_PROGRESS")) &&
							CSTR_EQUAL != WUCompareStringI(OLE2T(bstrInstallStatusNew), _T("IN_PROGRESS")))
						{
							//
							// this entry is an exclusive item with "IN_PROGRESS" installStatus and we found its 
							// updated installStatus, we need to update its installStatus
							//
							LOG_Out(_T("Update the exclusive item's installStatus"));
							CleanUpIfFailedAndSetHrMsg(pNodeItemExist->removeChild(pNodeInstallExist, &pNodeInstallOut));
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
							CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
							CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
							SafeSysFreeString(bstrTimeStamp);
						}
						else
						{							
							//
							// in this case we append a copy of this item with the new installStatus, since
							// this comes from a separate install operation
							//
							LOG_Out(_T("This item was installed again, add an entry of this item into history \
										for the new installation status only."));
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
							CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
							CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
						}
						SafeSysFreeString(bstrInstallStatusExist);
						SafeSysFreeString(bstrInstallStatusNew);
					}
					else
					{
						//
						// found the item without installStatus, update the entry with the installStatus
						// and update the timeStamp with its installation timeStamp
						//
						CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
						CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
						CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
						SafeSysFreeString(bstrTimeStamp);
					}
				}
			}
			else
			{
				//
				// no match found, this item was not downloaded through IU,
				// append this item with the install status
				//
				LOG_Out(_T("Can't find the downloaded item in existing history. This item was not downloaded \
							through IU. Add the item into history for installation status only."));
				CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
				CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
				CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
			}
//			SafeReleaseNULL(pNodeItem);
//			SafeReleaseNULL(pNodeItemExist);
			SafeReleaseNULL(pNodeItemNew);
			SafeReleaseNULL(pNodeItemRef);
			SafeReleaseNULL(pNodeInstall);
			SafeReleaseNULL(pNodeInstallExist);
			SafeReleaseNULL(pNodeInstallNew);
			SafeReleaseNULL(pNodeInstallOut);
		}
		while (SUCCEEDED(pHistoryInstall->GetNextItem(hNodeListItem, &hNodeItem)))
		{
			if (NULL != (pNodeItem = pHistoryInstall->GetDOMNodebyHandle(hNodeItem)))
			{
				if (SUCCEEDED(FindItem(pNodeItem, &hNodeItemExist)))
				{
					//
					// successfully found the match
					//
					if (NULL != (pNodeItemExist = GetDOMNodebyHandle(hNodeItemExist)))
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_INSTALLSTATUS, &pNodeInstall));			
						FindSingleDOMNode(pNodeItemExist, KEY_INSTALLSTATUS, &pNodeInstallExist);
						if (NULL != pNodeInstallExist)
						{
							//
							// found the item already with installStatus; now find out if we want to update
							// or append the installStatus
							//
							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstallExist, KEY_VALUE, &bstrInstallStatusExist));
							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeInstall, KEY_VALUE, &bstrInstallStatusNew));
							if (CSTR_EQUAL == WUCompareStringI(OLE2T(bstrInstallStatusExist), _T("IN_PROGRESS")) &&
								CSTR_EQUAL != WUCompareStringI(OLE2T(bstrInstallStatusNew), _T("IN_PROGRESS")))
							{
								//
								// this entry is an exclusive item with "IN_PROGRESS" installStatus and we found its 
								// updated installStatus, we need to update its installStatus
								//
								LOG_Out(_T("Update the exclusive item's installStatus"));
								CleanUpIfFailedAndSetHrMsg(pNodeItemExist->removeChild(pNodeInstallExist, &pNodeInstallOut));
								CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
								CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

								CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
								CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
								SafeSysFreeString(bstrTimeStamp);
							}
							else
							{							
								//
								// in this case we append a copy of this item with the new installStatus, since
								// this comes from a separate install operation
								//
								LOG_Out(_T("This item was installed again, add an entry of this item into history \
											for the new installation status only."));
								CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
								CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
								CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
							}
							SafeSysFreeString(bstrInstallStatusExist);
							SafeSysFreeString(bstrInstallStatusNew);
						}
						else
						{
							//
							// found the item without installStatus, update the entry with the installStatus
							// and update the timeStamp with its installation timeStamp
							//
							CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeInstall, m_pDocItems, &pNodeInstallNew));
							CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeItemExist, pNodeInstallNew));

							CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
							CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeItemExist, KEY_TIMESTAMP, bstrTimeStamp));
							SafeSysFreeString(bstrTimeStamp);
						}
					}
				}
				else
				{
					//
					// no match found, this item was not downloaded through IU,
					// append this item with the install status
					//
					LOG_Out(_T("Can't find the downloaded item in existing history. This item was not downloaded \
								through IU. Add the item into history for installation status only."));
					CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeItem, m_pDocItems, &pNodeItemNew));
					CleanUpIfFailedAndSetHrMsg(m_pNodeItems->get_firstChild(&pNodeItemRef));
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, pNodeItemNew, pNodeItemRef));
				}
//				SafeReleaseNULL(pNodeItem);
//				SafeReleaseNULL(pNodeItemExist);
				SafeReleaseNULL(pNodeItemNew);
				SafeReleaseNULL(pNodeItemRef);
				SafeReleaseNULL(pNodeInstall);
				SafeReleaseNULL(pNodeInstallExist);
				SafeReleaseNULL(pNodeInstallNew);
				SafeReleaseNULL(pNodeInstallOut);
			}
		}
	}

CleanUp:
	pHistoryInstall->CloseItemList(hNodeListItem);
//	SafeReleaseNULL(pNodeItem);
//	SafeReleaseNULL(pNodeItemExist);
	SafeReleaseNULL(pNodeItemNew);
	SafeReleaseNULL(pNodeItemRef);
	SafeReleaseNULL(pNodeInstall);
	SafeReleaseNULL(pNodeInstallExist);
	SafeReleaseNULL(pNodeInstallNew);
	SafeReleaseNULL(pNodeInstallOut);
	SafeReleaseNULL(pNodeXML);
	SysFreeString(bstrInstallStatusExist);
	SysFreeString(bstrInstallStatusNew);
	SysFreeString(bstrTimeStamp);
	SysFreeString(bstrNameSpaceSchema);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}

	
/////////////////////////////////////////////////////////////////////////////
// UpdateItemInstallStatus()
//
// Update the install status of the given item
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::UpdateItemInstallStatus(HANDLE_NODE hNodeItem,
											 BSTR bstrValue,
											 INT iNeedsReboot /*= -1*/,
											 DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("UpdateItemInstallStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeInstallStatus = NULL;

	//
	// get the <installStatus> node
	//
	CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(m_ppNodeArray[hNodeItem], KEY_INSTALLSTATUS, &pNodeInstallStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrValue));

	//
	// set the "needsReboot" attribute
	//
	if (-1 != iNeedsReboot)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_NEEDSREBOOT, iNeedsReboot));
	}

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeInstallStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddItem()
//
// Input:
// pNodeItem	- the <item> node of the catalog xml; we need to read
//				  <identity> node, <description> node and <platform> nodes
//                from it and write to the items xml.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddItem(IXMLDOMNode* pNodeItem, HANDLE_NODE* phNodeItem)
{
	LOG_Block("AddItem()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeIndentity = NULL;
	IXMLDOMNode*	pNodeIndentityNew = NULL;
	IXMLDOMNode*	pNodeDescription = NULL;
	IXMLDOMNode*	pNodeDescriptionNew = NULL;
	IXMLDOMNode*	pNodePlatform = NULL;
	IXMLDOMNode*	pNodePlatformNew = NULL;

	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	*phNodeItem = CreateDOMNodeWithHandle(m_pDocItems, NODE_ELEMENT, KEY_ITEMSTATUS);
	if (HANDLE_NODE_INVALID == *phNodeItem) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_pNodeItems, m_ppNodeArray[*phNodeItem]));

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_IDENTITY, &pNodeIndentity);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeIndentity, m_pDocItems, &pNodeIndentityNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodeIndentityNew));
	}

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_DESCRIPTION, &pNodeDescription);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodeDescription, m_pDocItems, &pNodeDescriptionNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodeDescriptionNew));
	}

	hNodeList = FindFirstDOMNode(pNodeItem, KEY_PLATFORM, &pNodePlatform);
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		CleanUpIfFailedAndSetHrMsg(CopyNode(pNodePlatform, m_pDocItems, &pNodePlatformNew));
		CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodePlatformNew));
		SafeReleaseNULL(pNodePlatform);
		SafeReleaseNULL(pNodePlatformNew);
		while (SUCCEEDED(FindNextDOMNode(hNodeList, &pNodePlatform)))
		{
			CleanUpIfFailedAndSetHrMsg(CopyNode(pNodePlatform, m_pDocItems, &pNodePlatformNew));
			CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[*phNodeItem], pNodePlatformNew));
			SafeReleaseNULL(pNodePlatform);
			SafeReleaseNULL(pNodePlatformNew);
		}
	}

CleanUp:
	if (HANDLE_NODELIST_INVALID != hNodeList)
	{
		SafeFindCloseHandle(hNodeList);
	}
	SafeReleaseNULL(pNodeIndentity);
	SafeReleaseNULL(pNodeIndentityNew);
	SafeReleaseNULL(pNodeDescription);
	SafeReleaseNULL(pNodeDescriptionNew);
	SafeReleaseNULL(pNodePlatform);
	SafeReleaseNULL(pNodePlatformNew);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddItem()
//
// Input:
// pCatalog		- the pointer to the CXmlCatalog object
// hNodeItem	- the handle of the <item> node of the catalog xml; we need
//				  to read <identity> node, <description> node and <platform>
//                nodes from it and write to the items xml.
// Output:
// phNodeItem	- the handle we pass back to differentiate different
//				  <itemStatus> node in items xml
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddItem(CXmlCatalog* pCatalog, HANDLE_NODE hNodeItem, HANDLE_NODE* phNodeItem)
{
	LOG_Block("AddItem() by handle");

	IXMLDOMNode*	pNode = NULL;

	if (NULL != (pNode = pCatalog->GetDOMNodebyHandle(hNodeItem)))
	{
		return AddItem(pNode, phNodeItem);
	}
	LOG_Error(_T("Can't retrieve valid item node from catalog xml"));
	return E_FAIL;
}


/////////////////////////////////////////////////////////////////////////////
// AddTimeStamp()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddTimeStamp(HANDLE_NODE hNodeItem)
{
	LOG_Block("AddTimeStamp()");

	USES_IU_CONVERSION;

	HRESULT		hr = E_FAIL;

	TCHAR szTimestamp[32];
	SYSTEMTIME stTimestamp;
	BSTR bstrTimeStamp = NULL;
	GetLocalTime(&stTimestamp);

	hr = StringCchPrintfEx(szTimestamp, ARRAYSIZE(szTimestamp), NULL, NULL, MISTSAFE_STRING_FLAGS,
                           _T("%4d-%02d-%02dT%02d:%02d:%02d"), // "ISO 8601" format for "datatime" datatype in xml
                           stTimestamp.wYear,
                           stTimestamp.wMonth,
                           stTimestamp.wDay,
                           stTimestamp.wHour,
                           stTimestamp.wMinute,
                           stTimestamp.wSecond);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	bstrTimeStamp = SysAllocString(T2OLE(szTimestamp));

	//
	// set the "timestamp" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(m_ppNodeArray[hNodeItem], KEY_TIMESTAMP, bstrTimeStamp));

CleanUp:
	SysFreeString(bstrTimeStamp);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDetectResult()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDetectResult(HANDLE_NODE hNodeItem,
								   INT iInstalled    /*= -1*/,
								   INT iUpToDate     /*= -1*/,
								   INT iNewerVersion /*= -1*/,
								   INT iExcluded     /*= -1*/,
								   INT iForce        /*= -1*/,
								   INT iComputerSystem /* = -1 */)
{
	LOG_Block("AddDetectResult()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDetectResult = NULL;

	//
	// create the <detectResult> node
	//
	pNodeDetectResult = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DETECTRESULT);
	if (NULL == pNodeDetectResult) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDetectResult));

	//
	// set the "installed" attribute
	//
	if (-1 != iInstalled)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_INSTALLED, iInstalled));
	}

	//
	// set the "upToDate" attribute
	//
	if (-1 != iUpToDate)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_UPTODATE, iUpToDate));
	}

	//
	// set the "newerVersion" attribute
	//
	if (-1 != iNewerVersion)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_NEWERVERSION, iNewerVersion));
	}

	//
	// set the "excluded" attribute
	//
	if (-1 != iExcluded)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_EXCLUDED, iExcluded));
	}

	//
	// set the "force" attribute
	//
	if (-1 != iForce)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_FORCE, iForce));
	}

	//
	// set computerSystem attribute
	//
	if (-1 != iComputerSystem)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDetectResult, KEY_COMPUTERSYSTEM, iComputerSystem));
	}


CleanUp:
	SafeReleaseNULL(pNodeDetectResult);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDownloadStatus()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDownloadStatus(HANDLE_NODE hNodeItem, BSTR bstrValue, DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("AddDownloadStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadStatus = NULL;

	//
	// create the <downloadStatus> node
	//
	pNodeDownloadStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DOWNLOADSTATUS);
	if (NULL == pNodeDownloadStatus) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDownloadStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDownloadStatus, KEY_VALUE, bstrValue));

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeDownloadStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeDownloadStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddDownloadPath()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddDownloadPath(HANDLE_NODE hNodeItem, BSTR bstrDownloadPath)
{
	LOG_Block("AddDownloadPath()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeDownloadPath = NULL;
	IXMLDOMNode*	pNodeDownloadPathText = NULL;

	pNodeDownloadPath = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DOWNLOADPATH);
	if (NULL == pNodeDownloadPath) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeDownloadPath));

	pNodeDownloadPathText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
	if (NULL == pNodeDownloadPathText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeDownloadPathText, bstrDownloadPath));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeDownloadPath, pNodeDownloadPathText));

CleanUp:
	SafeReleaseNULL(pNodeDownloadPath);
	SafeReleaseNULL(pNodeDownloadPathText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddInstallStatus()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddInstallStatus(HANDLE_NODE hNodeItem,
									  BSTR bstrValue,
									  BOOL fNeedsReboot,
									  DWORD dwErrorCode /*= 0*/)
{
	LOG_Block("AddInstallStatus()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeInstallStatus = NULL;

	//
	// create the <installStatus> node
	//
	pNodeInstallStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_INSTALLSTATUS);
	if (NULL == pNodeInstallStatus) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeInstallStatus));

	//
	// set the "value" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrValue));

	//
	// set the "needsReboot" attribute
	//
	CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_NEEDSREBOOT, fNeedsReboot));

	//
	// set the "errorCode" attribute
	//
	if (0 != dwErrorCode)
	{
		CleanUpIfFailedAndSetHrMsg(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE, dwErrorCode));
	}

CleanUp:
	SafeReleaseNULL(pNodeInstallStatus);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AddClientInfo()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::AddClientInfo(HANDLE_NODE hNodeItem, BSTR bstrClient)
{
	LOG_Block("AddClientInfo()");

	HRESULT		hr = E_FAIL;

	IXMLDOMNode*	pNodeClient = NULL;
	IXMLDOMNode*	pNodeClientText = NULL;

	pNodeClient = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_CLIENT);
	if (NULL == pNodeClient) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(InsertNode(m_ppNodeArray[hNodeItem], pNodeClient));

	pNodeClientText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
	if (NULL == pNodeClientText) goto CleanUp;

	CleanUpIfFailedAndSetHrMsg(SetValue(pNodeClientText, bstrClient));
	CleanUpIfFailedAndSetHrMsg(InsertNode(pNodeClient, pNodeClientText));

CleanUp:
	SafeReleaseNULL(pNodeClient);
	SafeReleaseNULL(pNodeClientText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// MigrateV3History()
//
// Migrate V3 History: Consumer history only.
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::MigrateV3History(LPCTSTR pszHistoryFilePath)
{
	LOG_Block("MigrateV3History()");

	HRESULT		hr = S_OK;

	IXMLDOMNode*	pNodeXML = NULL;
	IXMLDOMNode*	pNodeItemStatus = NULL;
	IXMLDOMNode*	pNodeIdentity = NULL;
	IXMLDOMNode*	pNodeDescription = NULL;
	IXMLDOMNode*	pNodeDescriptionText = NULL;
	IXMLDOMNode*	pNodeTitle = NULL;
	IXMLDOMNode*	pNodeTitleText = NULL;
	IXMLDOMNode*	pNodeVersion = NULL;
	IXMLDOMNode*	pNodeVersionText = NULL;
	IXMLDOMNode*	pNodeInstallStatus = NULL;
	IXMLDOMNode*	pNodeClient = NULL;
	IXMLDOMNode*	pNodeClientText = NULL;
	BSTR bstrNameSpaceSchema = NULL, bstrStatus = NULL, bstrString = NULL;
	LPTSTR pszItemsSchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	CV3AppLog V3History(pszHistoryFilePath);
	char szLineType[32];
	char szTemp[32];
	char szDate[32];
	char szTime[32];
	char szPUID[32];		// puid - migrate to <identity "name">
	char szTitle[256];		// title - migrate to <description>-><descriptionText>-><title>
	char szVersion[40];		// version - migrate to <identity>-><version>
	char szTimeStamp[32];	// timestamp - migrate to <itemStatus "timestamp">
	char szResult[16];		// result - migrate to <installStatus "value">
	char szErrCode[16];		// errorcode - migrate to <installStatus "errorCode">

	USES_IU_CONVERSION;

	V3History.StartReading();
	while (V3History.ReadLine())
	{
	    SafeSysFreeString(bstrString);
		// get line type (first field)
		V3History.CopyNextField(szLineType, ARRAYSIZE(szLineType));
		if ((_stricmp(szLineType, LOG_V3CAT) == 0) || (_stricmp(szLineType, LOG_V3_2) == 0)) 
		{
			// get "puid" field
			V3History.CopyNextField(szPUID, ARRAYSIZE(szPUID));

			// get "operation" field: installed/uninstalled
			// we only migrate installed item
			V3History.CopyNextField(szTemp, ARRAYSIZE(szTemp));
			if (0 != _stricmp(szTemp, LOG_INSTALL))
				continue;

			//
			// now we start to create <itemStatus> node for this item
			//
			if (NULL == m_pDocItems)
			{
				//
				// we don't have IU history file yet
				//
 				hr = CoCreateInstance(CLSID_DOMDocument,
											  NULL,
											  CLSCTX_INPROC_SERVER,
											  IID_IXMLDOMDocument,
											  (void **) &m_pDocItems);
				if (FAILED(hr))
				{
					LOG_ErrorMsg(hr);
				}
				else
				{
					//
					// create the <?xml version="1.0"?> node
					//
					pNodeXML = CreateDOMNode(m_pDocItems, NODE_PROCESSING_INSTRUCTION, KEY_XML);
					if (NULL == pNodeXML) goto CleanUp;

					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, pNodeXML));

					//
					// process the iuident.txt to find the Items schema path
					//
					TCHAR szIUDir[MAX_PATH];
					TCHAR szIdentFile[MAX_PATH];

					pszItemsSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
					if (NULL == pszItemsSchema)
					{
						hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
					if (NULL == pszNameSpaceSchema)
					{
						hr = E_OUTOFMEMORY;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
		
					GetIndustryUpdateDirectory(szIUDir);
            		hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
            		if (FAILED(hr))
            		{
            			LOG_ErrorMsg(hr);
            			goto CleanUp;
            		}

					GetPrivateProfileString(IDENT_IUSCHEMA,
											IDENT_IUSCHEMA_ITEMS,
											_T(""),
											pszItemsSchema,
											INTERNET_MAX_URL_LENGTH,
											szIdentFile);

					if ('\0' == pszItemsSchema[0])
					{
						// no Items schema path specified in iuident.txt
						LOG_Error(_T("No schema path specified in iuident.txt for Items"));
						goto CleanUp;
					}

            		hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
            		                       _T("x-schema:%s"), pszItemsSchema);
            		if (FAILED(hr))
            		{
            			LOG_ErrorMsg(hr);
            			goto CleanUp;
            		}

					bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

					//
					// create the <items> node with the path of the schema
					//
					m_pNodeItems = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMS, bstrNameSpaceSchema);
					if (NULL == m_pNodeItems) goto CleanUp;
					
					CleanUpIfFailedAndSetHrMsg(InsertNode(m_pDocItems, m_pNodeItems));
				}
			}
			else
			{
			    SafeReleaseNULL(m_pNodeItems);
				FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &m_pNodeItems);
			}
			
			// create <itemStatus> node
			pNodeItemStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_ITEMSTATUS);
			if (NULL == pNodeItemStatus) continue;
			SkipIfFail(InsertNode(m_pNodeItems, pNodeItemStatus));
		
			// create <client> node
			pNodeClient = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_CLIENT);
			if (NULL == pNodeClient) continue;
			pNodeClientText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeClientText) continue;
			BSTR bstrV3Client = SysAllocString(C_V3_CLIENTINFO);
			SkipIfFail(SetValue(pNodeClientText, bstrV3Client));
			SkipIfFail(InsertNode(pNodeClient, pNodeClientText));
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeClient));
			SafeSysFreeString(bstrV3Client);

			// create <identity> node
			pNodeIdentity = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_IDENTITY);
			if (NULL == pNodeIdentity) continue;
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeIdentity));
			
			// set the "name" attribute for <identity>
			bstrString = SysAllocString(A2OLE(szPUID));
			SkipIfFail(SetAttribute(pNodeIdentity, KEY_NAME, bstrString));
			// set the "itemID" attribute for <identity>
			SkipIfFail(SetAttribute(pNodeIdentity, KEY_ITEMID, bstrString));
			SafeSysFreeString(bstrString);

			// get "title" field
			V3History.CopyNextField(szTitle, ARRAYSIZE(szTitle));
			
			// create <description> node
			pNodeDescription = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DESCRIPTION);
			if (NULL == pNodeDescription) continue;
			SkipIfFail(SetAttribute(pNodeDescription, KEY_HIDDEN, 0));
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeDescription));

			// create <descriptionText> node
			pNodeDescriptionText = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_DESCRIPTIONTEXT);
			if (NULL == pNodeDescriptionText) continue;
			SkipIfFail(InsertNode(pNodeDescription, pNodeDescriptionText));

			// create <title> node
			pNodeTitle = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_TITLE);
			if (NULL == pNodeTitle) continue;
			pNodeTitleText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeTitleText) continue;
			bstrString = SysAllocString(A2OLE(szTitle));
			SkipIfFail(SetValue(pNodeTitleText, bstrString));
			SkipIfFail(InsertNode(pNodeTitle, pNodeTitleText));
			SkipIfFail(InsertNode(pNodeDescriptionText, pNodeTitle));
			SafeSysFreeString(bstrString);

			// get "version" field
			V3History.CopyNextField(szVersion, ARRAYSIZE(szVersion));

			// create <version> node
			pNodeVersion = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_VERSION);
			if (NULL == pNodeVersion) continue;

			pNodeVersionText = CreateDOMNode(m_pDocItems, NODE_TEXT, NULL);
			if (NULL == pNodeVersionText) continue;
			bstrString = SysAllocString(A2OLE(szVersion));
			SkipIfFail(SetValue(pNodeVersionText, bstrString));
			SkipIfFail(InsertNode(pNodeVersion, pNodeVersionText));
			SkipIfFail(InsertNode(pNodeIdentity, pNodeVersion));
			SafeSysFreeString(bstrString);

			// get timestamp
			if ((_stricmp(szLineType, LOG_V3_2) == 0))
			{
				// read the timestamp and convert to "ISO 8601" format for "datatime" datatype in xml:
				// for example, 2001-05-01T18:30:00
				// so we only need to replace the space with 'T'
 
				// timestamp
				V3History.CopyNextField(szTimeStamp, ARRAYSIZE(szTimeStamp));
				char *p = strchr(szTimeStamp, ' ');
				if (NULL != p) // if (NULL == p): there's no space then leave it as is to pass into SetAttribute
				{
				    *p = 'T';
				}
			}
			else 
			{
				// V3 Beta had two fields for date and time, we need read both these fields:

				// date
				V3History.CopyNextField(szDate, ARRAYSIZE(szDate));

				// time
				V3History.CopyNextField(szTime, ARRAYSIZE(szTime));
				hr = StringCchPrintfExA(szTimeStamp, ARRAYSIZE(szTimeStamp), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                        "%sT%s", szDate, szTime);
				SkipIfFail(hr);
			}
			// set the "timestamp" attribute for <itemStatus>
			bstrString = SysAllocString(A2OLE(szTimeStamp));
			SkipIfFail(SetAttribute(pNodeItemStatus, KEY_TIMESTAMP, bstrString));
			SafeSysFreeString(bstrString);

			// skip the "record type" field
			V3History.CopyNextField(szTemp, ARRAYSIZE(szTemp));

			// get "result" field
			V3History.CopyNextField(szResult, ARRAYSIZE(szResult));

			// create <InstallStatus> node
			pNodeInstallStatus = CreateDOMNode(m_pDocItems, NODE_ELEMENT, KEY_INSTALLSTATUS);
			if (NULL == pNodeInstallStatus) continue;
			SkipIfFail(InsertNode(pNodeItemStatus, pNodeInstallStatus));

			// set the "value" attribute for <installStatus>
			if (_stricmp(szResult, LOG_SUCCESS) == 0)
			{
				bstrStatus = SysAllocString(L"COMPLETE");
			}
			else if (_stricmp(szTemp, LOG_STARTED) == 0)
			{
				bstrStatus = SysAllocString(L"IN_PROGRESS");
			}
			else
			{
				bstrStatus = SysAllocString(L"FAILED");
			}
			SkipIfFail(SetAttribute(pNodeInstallStatus, KEY_VALUE, bstrStatus));
			
			if (_stricmp(szResult, LOG_SUCCESS) != 0)
			{
				// get "error code" field
				V3History.CopyNextField(szErrCode, ARRAYSIZE(szErrCode));

				// set the "errorCode" attribute for <installStatus>
				SkipIfFail(SetAttribute(pNodeInstallStatus, KEY_ERRORCODE,  atoh(szErrCode)));
			}
		}

	}
	V3History.StopReading();

CleanUp:
	
	SafeReleaseNULL(pNodeXML);
	SafeReleaseNULL(pNodeItemStatus);
	SafeReleaseNULL(pNodeIdentity);
	SafeReleaseNULL(pNodeDescriptionText);
	SafeReleaseNULL(pNodeTitle);
	SafeReleaseNULL(pNodeTitleText);
	SafeReleaseNULL(pNodeVersion);
	SafeReleaseNULL(pNodeVersionText);
	SafeReleaseNULL(pNodeInstallStatus);
	SafeReleaseNULL(pNodeClient);
	SafeReleaseNULL(pNodeClientText);
	SysFreeString(bstrString);
	SysFreeString(bstrNameSpaceSchema);
	SysFreeString(bstrStatus);
	SafeHeapFree(pszItemsSchema);
	SafeHeapFree(pszNameSpaceSchema);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetItemsBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetItemsBSTR(BSTR *pbstrXmlItems)
{
	LOG_Block("GetItemsBSTR()");

	if (NULL == m_pDocItems)
	{
		*pbstrXmlItems = NULL;
		return S_OK;
	}

	//
	// convert XML DOC into BSTR 
	//
	HRESULT hr = m_pDocItems->get_xml(pbstrXmlItems);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetFilteredHistoryBSTR()
/////////////////////////////////////////////////////////////////////////////
HRESULT CXmlItems::GetFilteredHistoryBSTR(BSTR bstrBeginDateTime,
											BSTR bstrEndDateTime,
											BSTR bstrClient,
											BSTR *pbstrXmlHistory)
{
	LOG_Block("GetFilteredHistoryBSTR()");

	USES_IU_CONVERSION;

	HRESULT		hr = S_OK;

	IXMLDOMNode*	pNodeItems = NULL;
	IXMLDOMNode*	pNodeItem = NULL;
	IXMLDOMNode*	pNodeItemOut = NULL;
	IXMLDOMNode*	pNodeClient = NULL;
	BSTR bstrTimeStamp = NULL;
	BSTR bstrClientInfo = NULL;
	BOOL fOutOfRange = FALSE;

	HANDLE_NODELIST	hNodeList = HANDLE_NODELIST_INVALID;

	if (NULL == pbstrXmlHistory)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}	
	
	if (NULL != m_pDocItems)
	{
		if (SUCCEEDED(FindSingleDOMNode(m_pDocItems, KEY_ITEMS, &pNodeItems)))
		{
			hNodeList = FindFirstDOMNode(pNodeItems, KEY_ITEMSTATUS, &pNodeItem);
			if (HANDLE_NODELIST_INVALID != hNodeList)
			{
				CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
				if (NULL != bstrTimeStamp)
				{
					if ((NULL != bstrBeginDateTime) && (0 != SysStringLen(bstrBeginDateTime)) &&
						(CompareBSTRs(bstrTimeStamp, bstrBeginDateTime) < 0))
					{
						//
						// remove the item whose timestamp is out of range;
						// set the flag to ignore the timestamp comparison for the rest of nodes
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
						fOutOfRange = TRUE;
					}
					else if ((NULL != bstrEndDateTime) && (0 != SysStringLen(bstrEndDateTime)) &&
							 (CompareBSTRs(bstrTimeStamp, bstrEndDateTime) > 0))
					{
						//
						// remove the item whose timestamp is out of range
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
					}
					else
					{
						CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClient));
						CleanUpIfFailedAndSetHrMsg(GetText(pNodeClient, &bstrClientInfo));
						if ((NULL != bstrClient) && (0 != SysStringLen(bstrClient)) &&
							(WUCompareStringI(OLE2T(bstrClientInfo), OLE2T(bstrClient)) != CSTR_EQUAL))
						{
							//
							// remove the item whose clieninfo does not match what we need
							//
							CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
						}
					}
				}
				SafeReleaseNULL(pNodeItem);
				SafeReleaseNULL(pNodeItemOut);
				SafeReleaseNULL(pNodeClient);
				SafeSysFreeString(bstrTimeStamp);
				SafeSysFreeString(bstrClientInfo);
				while (SUCCEEDED(FindNextDOMNode(hNodeList, &pNodeItem)))
				{
					if (fOutOfRange)
					{
						//
						// remove the item whose timestamp is out of range
						//
						CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
					}
					else
					{
						CleanUpIfFailedAndSetHrMsg(GetAttribute(pNodeItem, KEY_TIMESTAMP, &bstrTimeStamp));
						if (NULL != bstrTimeStamp)
						{
							if ((NULL != bstrBeginDateTime) && (0 != SysStringLen(bstrBeginDateTime)) &&
								(CompareBSTRs(bstrTimeStamp, bstrBeginDateTime) < 0))
							{
								//
								// remove the item whose timestamp is out of range;
								// set the flag to ignore the timestamp comparison for the rest of nodes
								//
								CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
								fOutOfRange = TRUE;
							}
							else if ((NULL != bstrEndDateTime) && (0 != SysStringLen(bstrEndDateTime)) &&
									 (CompareBSTRs(bstrTimeStamp, bstrEndDateTime) > 0))
							{
								//
								// remove the item whose timestamp is out of range
								//
								CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
							}
							else
							{
								CleanUpIfFailedAndSetHrMsg(FindSingleDOMNode(pNodeItem, KEY_CLIENT, &pNodeClient));
								CleanUpIfFailedAndSetHrMsg(GetText(pNodeClient, &bstrClientInfo));
								if ((NULL != bstrClient) && (0 != SysStringLen(bstrClient)) &&
									(WUCompareStringI(OLE2T(bstrClientInfo), OLE2T(bstrClient)) != CSTR_EQUAL))
								{
									//
									// remove the item whose clieninfo does not match what we need
									//
									CleanUpIfFailedAndSetHrMsg(pNodeItems->removeChild(pNodeItem, &pNodeItemOut));
								}
							}
						}
					}
					SafeReleaseNULL(pNodeItem);
					SafeReleaseNULL(pNodeItemOut);
					SafeReleaseNULL(pNodeClient);
					SafeSysFreeString(bstrTimeStamp);
					SafeSysFreeString(bstrClientInfo);
				}
			}
		}
	}

CleanUp:
	CloseItemList(hNodeList);
	SafeReleaseNULL(pNodeItems);
	SafeReleaseNULL(pNodeItem);
	SafeReleaseNULL(pNodeItemOut);
	SafeReleaseNULL(pNodeClient);
	SysFreeString(bstrTimeStamp);
	SysFreeString(bstrClientInfo);
	if (SUCCEEDED(hr))
	{
		hr = GetItemsBSTR(pbstrXmlHistory);
	}
	return hr;
}






/////////////////////////////////////////////////////////////////////////////
// CXmlClientInfo


CXmlClientInfo::CXmlClientInfo()
: m_pDocClientInfo(NULL)
{

}

CXmlClientInfo::~CXmlClientInfo()
{
	SafeReleaseNULL(m_pDocClientInfo);
}

//
// load and parse and validate an XML document from string
//
HRESULT CXmlClientInfo::LoadXMLDocument(BSTR bstrXml, BOOL fOfflineMode)
{
    LOG_Block("CXmlClientInfo::LoadXMLDocument()");

    SafeReleaseNULL(m_pDocClientInfo);
	HRESULT hr = LoadXMLDoc(bstrXml, &m_pDocClientInfo, fOfflineMode);
	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	return hr;
}

//
// retrieve client name attribute
//
HRESULT CXmlClientInfo::GetClientName(BSTR* pbstrClientName)
{
	HRESULT hr= E_UNEXPECTED;

	IXMLDOMElement* pElement = NULL;
	BSTR bstrTagName = NULL;
	VARIANT vAttr;
	VariantInit(&vAttr);

	LOG_Block("GetClientName()");

	if (NULL == pbstrClientName)
	{
		return E_INVALIDARG;
	}

	if (NULL == m_pDocClientInfo)
	{
		return hr;
	}

	hr = m_pDocClientInfo->get_documentElement(&pElement);
	CleanUpIfFailedAndMsg(hr);
	if (NULL == pElement)
	{
		//
		// no root element
		//
		hr = E_INVALIDARG;		// clientInfo is bad! return this error back to caller
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	hr = pElement->get_tagName(&bstrTagName);
	CleanUpIfFailedAndMsg(hr);

	if (!CompareBSTRsEqual(bstrTagName, KEY_CLIENTINFO))
	{
		//
		// root is not clientInfo
		//
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	hr = pElement->getAttribute(KEY_CLIENTNAME, &vAttr);
	CleanUpIfFailedAndMsg(hr);

	if (VT_BSTR == vAttr.vt)
	{
		*pbstrClientName = SysAllocString(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
		CleanUpIfFailedAndMsg(hr);
	}

CleanUp:
	SafeReleaseNULL(pElement);
	if (bstrTagName)
	{
		SysFreeString(bstrTagName);
		bstrTagName = NULL;
	}
	VariantClear(&vAttr);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\manifest.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   manifest.cpp
//
//  Description:
//
//      Implementation for the GetManifest() function
//
//=======================================================================

#include "iuengine.h"
#include <iucommon.h>
#include <fileutil.h>
#include <shlwapi.h>
#include <wininet.h>
#include "schemamisc.h"
#include "WaitUtil.h"
#include "download.h"
#include <httprequest.h>
#include <httprequest_i.c>
#include <iuxml.h>

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; LOG_ErrorMsg(hr);	return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}




#define ERROR_INVALID_PID 100
#define E_INVALID_PID MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,ERROR_INVALID_PID)
#define errorInvalidLicense 1
const TCHAR g_szInvalidPID[]			= _T("The PID is invalid");



const TCHAR IDENT_IUSCHEMA[]			= _T("IUSchema");
const TCHAR IDENT_IUSCHEMA_SOAPQUERY[]	= _T("SOAPQuerySchema");
const TCHAR IDENT_IUSERVERCACHE[]		= _T("IUServerCache");
const TCHAR IDENT_IUSERVERCOUNT[]		= _T("ServerCount");
const TCHAR IDENT_IUSERVER[]			= _T("Server");

const CHAR	SZ_GET_MANIFEST[] = "Querying software update catalog from";
const CHAR	SZ_GET_MANIFEST_ERROR[] = "Querying software update catalog";

HRESULT ValidatePID(IXMLDOMDocument *pXmlDomDocument);
void PingInvalidPID(BSTR bstrClientName,HRESULT hRes,HANDLE *phQuit,DWORD dwNumHandles);


/////////////////////////////////////////////////////////////////////////////
// Function forward declarations
/////////////////////////////////////////////////////////////////////////////
HRESULT GetServerURL(IXMLDOMDocument *pXMLQuery, IXMLDOMDocument *pXMLClientInfo, LPTSTR *ppszURL);
HRESULT GetSOAPQuery(IXMLDOMDocument *pXMLClientInfo, IXMLDOMDocument *pXMLSystemSpec,
					 IXMLDOMDocument *pXMLQuery, IXMLDOMDocument **ppSOAPQuery);

/////////////////////////////////////////////////////////////////////////////
// GetManifest()
//
// Gets a catalog base on the specified information.
// Input:
// bstrXmlClientInfo - the credentials of the client in xml format
// bstrXmlSystemSpec - the detected system specifications in xml
// bstrXmlQuery - the user query infomation in xml
// Return:
// pbstrXmlCatalog - the xml catalog retrieved
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetManifest(BSTR	bstrXmlClientInfo,
						   BSTR	bstrXmlSystemSpec,
						   BSTR	bstrXmlQuery,
						   DWORD dwFlags,
						   BSTR *pbstrXmlCatalog)
{
	LOG_Block("GetManifest()");

    // clear any previous cancel event
    ResetEvent(m_evtNeedToQuit);

	USES_IU_CONVERSION;

	HRESULT	hr	= E_FAIL;
	CXmlClientInfo	xmlClientInfo;
	IXMLDOMDocument *pXMLSystemSpec		= NULL;
	IXMLDOMDocument	*pXMLQuery			= NULL;
	IXMLDOMDocument	*pSOAPQuery			= NULL;
	IXMLHttpRequest	*pIXMLHttpRequest	= NULL;
	IWinHttpRequest *pWinHttpRequest	= NULL;
	BSTR	bstrXmlSOAPQuery = NULL;
	BSTR	bstrPOST = NULL, bstrURL = NULL;
	BSTR	bstrClientName = NULL;
	LPTSTR	pszURL = NULL;
	LONG lCount = 0;
	MSG msg;
	DWORD dwRet;
	BOOL fDontAllowProxy = FALSE;
	SAUProxySettings pauProxySettings;
	ZeroMemory(&pauProxySettings, sizeof(SAUProxySettings));

	//
	// load the DOM Doc for Query, ClientInfo, SystemSpec respectively
	//
	LOG_XmlBSTR(bstrXmlQuery);
	hr = LoadXMLDoc(bstrXmlQuery, &pXMLQuery, FALSE);
	CleanUpIfFailedAndMsg(hr);

	LOG_XmlBSTR(bstrXmlClientInfo);
	hr = xmlClientInfo.LoadXMLDocument(bstrXmlClientInfo, FALSE);
	CleanUpIfFailedAndMsg(hr);

	CleanUpIfFailedAndSetHrMsg(xmlClientInfo.GetClientName(&bstrClientName));

	CleanUpIfFailedAndSetHrMsg(g_pUrlAgent->IsClientSpecifiedByPolicy(OLE2T(bstrClientName)));


	//
	// Set flag to NOT set proxy for WinHTTP
	//
	if (S_FALSE ==hr)
	{
		fDontAllowProxy = FALSE;
		hr = S_OK;
	}
	else // S_OK
	{
		fDontAllowProxy = TRUE;
	}

	//
	// we treat bstrXmlSystemSpec as optional
	//
	if (NULL != bstrXmlSystemSpec && SysStringLen(bstrXmlSystemSpec) > 0)
	{
		LOG_XmlBSTR(bstrXmlSystemSpec);
		hr = LoadXMLDoc(bstrXmlSystemSpec, &pXMLSystemSpec, FALSE);
		CleanUpIfFailedAndMsg(hr);
	}

	//
	// retrieve the ServerCache URL from the Query xml doc and validate it
	//
	hr = GetServerURL(pXMLQuery, xmlClientInfo.GetDocument(), &pszURL);
	CleanUpIfFailedAndMsg(hr);

	//
	// concatenate the above several xml client input into a single XML
	// with the SOAP syntax/format that the server recognizes
	//
	hr = GetSOAPQuery(xmlClientInfo.GetDocument(), pXMLSystemSpec, pXMLQuery, &pSOAPQuery);
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
        goto CleanUp;
	}
#if defined(DBG)
	else
	{
		BSTR	bstrSOAPQuery = NULL;
		pSOAPQuery->get_xml(&bstrSOAPQuery);
		LOG_XmlBSTR(bstrSOAPQuery);
		SafeSysFreeString(bstrSOAPQuery);
	}
#endif
	//
	// change again: add WINHTTP support for AU running as a service;
	//               use GetAllowedDownloadTransport(0) to determine -
	//               1)  0 == try winhttp first & if that fails, try wininet.
	//               2)  WUDF_ALLOWWINHTTPONLY == only try winhttp.  never fall back on wininet.
	//               3)  WUDF_ALLOWWININETONLY == only try wininet.  never use winhttp.
	//
	// in WINHTTP the compression is not supported yet at this time;
	// in WININET we removed the compression support at this point due to a bug in URLMON (< IE6.0).
	//
	// in both cases we use asynchronized sending in order to abort timely for a cancel event
	//

	BOOL fLoadWINHTTP = FALSE;
	DWORD dwTransportFlag = GetAllowedDownloadTransport(0);

	if ((0 == dwTransportFlag) || (WUDF_ALLOWWINHTTPONLY == dwTransportFlag))
	{
		hr = CoCreateInstance(CLSID_WinHttpRequest,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IWinHttpRequest,
							  (void **) &pWinHttpRequest);
		if (SUCCEEDED(hr))
		{
			BOOL fRetry = FALSE;
		    
			bstrURL = SysAllocString(T2OLE(pszURL));
			
			fLoadWINHTTP = TRUE;
			VARIANT	vProxyServer, vBypassList;
			hr = GetAUProxySettings(bstrURL, &pauProxySettings);
			CleanUpIfFailedAndMsg(hr);
			DWORD iProxy = pauProxySettings.iProxy;
			if (-1 == iProxy)
				pauProxySettings.iProxy = iProxy = 0;

			//
			// open request
			//
			VARIANT	vBool;
			vBool.vt = VT_BOOL;
			vBool.boolVal = VARIANT_TRUE;
			bstrPOST = SysAllocString(L"POST");
Retry:
			hr = pWinHttpRequest->Open(bstrPOST,	// HTTP method: "POST"
										bstrURL,	// requested URL
										vBool);		// asynchronous operation
			CleanUpIfFailedAndMsg(hr);

			//
			// For SSL URLs, set the WinHttpRequestOption_SslErrorIgnoreFlags
			// option to zero so that no server certificate errors are ignored.
			//
			// The default at the time this code was written was 0x3300, which
			// means ignore all server certificate errors.  Using this default
			// would significantly reduce security in various ways; for example
			// if the 0x0100 bit was set, WinHttp would trust certificates from
			// any root certificate authority, even it it was not in the list of
			// trusted CAs.
			//
			// Note that at the time this code was written, the WinHttp 
			// documentation made no mention of Certificate Revocation List
			// checking.  It is assumed that the default CRL behavior
			// implemented by WinHttp will provide adequate security and 
			// performance.
			//
			if ((_T('H') == pszURL[0] || _T('h') == pszURL[0]) &&    // Sorry, this is simpler than using a function.
				(_T('T') == pszURL[1] || _T('t') == pszURL[1]) &&
				(_T('T') == pszURL[2] || _T('t') == pszURL[2]) &&
				(_T('P') == pszURL[3] || _T('p') == pszURL[3]) &&
				(_T('S') == pszURL[4] || _T('s') == pszURL[4]) &&
				_T(':') == pszURL[5])
			{
				VARIANT vOption;
				VariantInit(&vOption);
				vOption.vt = VT_I4;
				vOption.lVal = 0;
				
				hr = pWinHttpRequest->put_Option(WinHttpRequestOption_SslErrorIgnoreFlags, vOption);

				VariantClear(&vOption);
				CleanUpIfFailedAndMsg(hr);
			}

			if (TRUE == fDontAllowProxy)
			{
				LOG_Internet(_T("Don't set the proxy due to policy"));
			}
			else
			{
				//
				// set proxy
				//
				VariantInit(&vProxyServer);
				VariantInit(&vBypassList);
				BOOL fSetProxy = TRUE;

				if (pauProxySettings.rgwszProxies != NULL)
				{
					vProxyServer.vt = VT_BSTR;
					vProxyServer.bstrVal = SysAllocString(pauProxySettings.rgwszProxies[iProxy]);
				}
				else if (pauProxySettings.rgwszProxies == NULL)
				{
					fSetProxy = FALSE;
				}

				if (pauProxySettings.wszBypass != NULL)
				{
					vBypassList.vt = VT_BSTR;
					vBypassList.bstrVal = SysAllocString(pauProxySettings.wszBypass);
				}

				if (fSetProxy)
				{
					hr = pWinHttpRequest->SetProxy(HTTPREQUEST_PROXYSETTING_PROXY, vProxyServer, vBypassList);
				}
				
				VariantClear(&vProxyServer);
				VariantClear(&vBypassList);
				CleanUpIfFailedAndMsg(hr);
			}


			//
			// send request
			//
			VARIANT	vQuery;
			vQuery.vt = VT_UNKNOWN;
			vQuery.punkVal = pSOAPQuery;

			hr = pWinHttpRequest->Send(vQuery);
    		if (FAILED(hr))
    		{
		        LOG_Internet(_T("WinHttpRequest: Send failed: 0x%08x"), hr);
    		    fRetry = TRUE;
    		    goto getNextProxyForRetry;
    		}

			//
			// check if quit or completion every 1/4 second
			//
			VARIANT vTimeOut;
			vTimeOut.vt = VT_I4;
			vTimeOut.lVal = 0;
			VARIANT_BOOL fSuccess = VARIANT_FALSE;
			hr = pWinHttpRequest->WaitForResponse(vTimeOut, &fSuccess);
			if (FAILED(hr))
			{
			    LOG_Internet(_T("WinHttpRequest: WaitForResponse failed: 0x%08x"), hr);
			    fRetry = TRUE;
			    goto getNextProxyForRetry;
			}

			// we wait up to 30 sec (120*250 ms)
			lCount = 0;
			while (!fSuccess && lCount <120)
			{
				lCount++;
				//
				// Wait for 250ms while pumping messages, but return if m_evtNeedToQuit signaled
				//
				dwRet = MyMsgWaitForMultipleObjects(1, &m_evtNeedToQuit, FALSE, 250, QS_ALLINPUT);
				if (WAIT_TIMEOUT != dwRet)
				{
					//
					// Either the event was signaled or a message being pumped says quit
					//
					pWinHttpRequest->Abort();
					hr = E_ABORT;
					goto CleanUp;
				}

				hr = pWinHttpRequest->WaitForResponse(vTimeOut, &fSuccess);
        		if (FAILED(hr))
        		{
			        LOG_Internet(_T("WinHttpRequest: WaitForResponse failed: 0x%08x"), hr);
        		    fRetry = TRUE;
        		    goto getNextProxyForRetry;
        		}
			}

			//
			// check the HTTP status code returned by a request
			//
			LONG lStatus = HTTP_STATUS_OK;// 200
			hr = pWinHttpRequest->get_Status(&lStatus);
        	if (FAILED(hr))
        	{
			    LOG_Internet(_T("WinHttpRequest: get_Status failed: 0x%08x"), hr);
        		fRetry = TRUE;
        		goto getNextProxyForRetry;
        	}

            fRetry = FALSE;
			if (!fSuccess)
			{
				// time out
				hr = E_FAIL;
				fRetry = TRUE;
			}
			else if (HTTP_STATUS_OK != lStatus)
			{
				// COMPLETED, but error in status
				hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, lStatus);
				LOG_ErrorMsg(hr);			
				fRetry = TRUE;
			}
			else
			{
				//
				// get response
				//
				hr = pWinHttpRequest->get_ResponseText(pbstrXmlCatalog);
				CleanUpIfFailedAndMsg(hr);

				//
				// verify the response is a well-formed XML document
				//
				IXMLDOMDocument	*pXMLDoc = NULL;
				hr = LoadXMLDoc(*pbstrXmlCatalog, &pXMLDoc);

				if(SUCCEEDED(hr))
				{
					hr=ValidatePID(pXMLDoc);

					if(FAILED(hr))
					{
						PingInvalidPID(bstrClientName,hr,&m_evtNeedToQuit,1);
						LogError(hr,"Validation of PID failed");
					}

					//The Banned PID case is not a failure for the GetManifest call.
					if(E_INVALID_PID == hr)
					{
						hr = S_OK;
					}

				}
				SafeReleaseNULL(pXMLDoc);
				CleanUpIfFailedAndMsg(hr);
			}

getNextProxyForRetry:
			if (fRetry && !fDontAllowProxy)
			{
				if (pauProxySettings.cProxies > 1 && pauProxySettings.rgwszProxies != NULL)
				{
					iProxy = ( iProxy + 1) % pauProxySettings.cProxies;
				}
				if (iProxy != pauProxySettings.iProxy)
				{
					LogError(hr, "Will retry.");
					pWinHttpRequest->Abort();
					goto Retry;
				}
				else
				{
					LogError(hr, "Already tried all proxies. Will not retry.");
				}
			}

		}
		else
		{
			if (WUDF_ALLOWWINHTTPONLY == dwTransportFlag)
			{
				CleanUpIfFailedAndMsg(hr);
			}
		}
	}

	if ((0 == dwTransportFlag && !fLoadWINHTTP) || (WUDF_ALLOWWININETONLY == dwTransportFlag))
	{
		//
		// 475506 W2K: IU - IU control's GetManifest method call fails on all subsequent
		// calls after the first. - On Win 2K Only
		//
		// We no longer take the FLAG_USE_COMPRESSION into account for WinInet since we
		// previously used URLMON and there are bugs that would require a rewrite of
		// xmlhttp.* to fix and we haven't been using compression on the live site to date.
		//
		LOG_Internet(_T("GetManifest using WININET.DLL"));

		//
		// create an XMLHttpRequest object
		//
		hr = CoCreateInstance(CLSID_XMLHTTPRequest,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IXMLHttpRequest,
							  (void **) &pIXMLHttpRequest);
		CleanUpIfFailedAndMsg(hr);

		//
		// open request
		//
		VARIANT	vEmpty, vBool;
		vEmpty.vt = VT_EMPTY;
		vBool.vt = VT_BOOL;
		vBool.boolVal= VARIANT_FALSE;
		bstrPOST = SysAllocString(L"POST");
		bstrURL = SysAllocString(T2OLE(pszURL));

		hr = pIXMLHttpRequest->open(bstrPOST,	// HTTP method: "POST"
									bstrURL,	// requested URL
									vBool,		// synchronous operation
									vEmpty,		// user for authentication (no authentication for V1.0)
									vEmpty);	// pswd for authentication
		CleanUpIfFailedAndMsg(hr);

		//
		// send request
		//
		VARIANT	vQuery;
		vQuery.vt = VT_UNKNOWN;
		vQuery.punkVal = pSOAPQuery;

		hr = pIXMLHttpRequest->send(vQuery);
		CleanUpIfFailedAndMsg(hr);

		//
		// check the HTTP status code returned by a request
		//
		LONG lResultStatus = HTTP_STATUS_OK;// 200
		hr = pIXMLHttpRequest->get_status(&lResultStatus);
		CleanUpIfFailedAndMsg(hr);

		if (HTTP_STATUS_OK != lResultStatus)
		{
			hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, lResultStatus);
			LOG_ErrorMsg(hr);			
		}
		else
		{
			//
			// get response
			//
			hr = pIXMLHttpRequest->get_responseText(pbstrXmlCatalog);
			CleanUpIfFailedAndMsg(hr);	

			//
			// verify the response is a well-formed XML document
			//
			IXMLDOMDocument	*pXMLDoc = NULL;
			hr = LoadXMLDoc(*pbstrXmlCatalog, &pXMLDoc);

			if(SUCCEEDED(hr))
			{
				hr=ValidatePID(pXMLDoc);

				if(FAILED(hr))
				{
					PingInvalidPID(bstrClientName,hr,&m_evtNeedToQuit,1);
					LogError(hr,"Validation of PID failed");
				}
				
				//The Banned pid case is not a failure for the GetManifest call
				if(E_INVALID_PID == hr)
				{
					hr = S_OK;
				}

			}
			SafeReleaseNULL(pXMLDoc);
			CleanUpIfFailedAndMsg(hr);
		}
	}

CleanUp:
	if (SUCCEEDED(hr))
	{
#if defined(UNICODE) || defined(_UNICODE)
		LogMessage("%s %ls", SZ_GET_MANIFEST, pszURL);
#else
		LogMessage("%s %s", SZ_GET_MANIFEST, pszURL);
#endif
	}
	else
	{
		if (NULL == pszURL)
		{
			LogError(hr, SZ_GET_MANIFEST_ERROR);
		}
		else
		{
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "%s %ls", SZ_GET_MANIFEST, pszURL);
#else
			LogError(hr, "%s %s", SZ_GET_MANIFEST, pszURL);
#endif
		}
	}

	if (NULL != pszURL)
		HeapFree(GetProcessHeap(), 0, pszURL);
	SafeReleaseNULL(pXMLSystemSpec);
	SafeReleaseNULL(pXMLQuery);
	SafeReleaseNULL(pSOAPQuery);
	SafeReleaseNULL(pIXMLHttpRequest);
	SafeReleaseNULL(pWinHttpRequest);
	SysFreeString(bstrPOST);
	SysFreeString(bstrURL);
	SysFreeString(bstrXmlSOAPQuery);
	SysFreeString(bstrClientName);
	FreeAUProxySettings(&pauProxySettings);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetServerURL()
//
// Retrieve the ServerCache URL from the Query xml doc and validate that
// URL against the ServerCache URLs in iuident.txt.
// Return:
// ppszURL - the ServerCache URL path pointer
/////////////////////////////////////////////////////////////////////////////
HRESULT GetServerURL(IXMLDOMDocument *pXMLQuery, IXMLDOMDocument *pXMLClientInfo, LPTSTR *ppszURL)
{
    LOG_Block("GetServerURL()");

	USES_IU_CONVERSION;

	HRESULT	hr	= E_FAIL;

    if ((NULL == pXMLQuery) || (NULL == pXMLClientInfo) || (NULL == ppszURL))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    IXMLDOMNode*	pQueryNode = NULL;
    IXMLDOMNode*	pQueryClient = NULL;
	BSTR bstrQuery = SysAllocString(L"query");
	BSTR bstrHref = SysAllocString(L"href");
	BSTR bstrClientInfo = SysAllocString(L"clientInfo");
	BSTR bstrClientName = SysAllocString(L"clientName");
	BSTR bstrURL = NULL, bstrClient = NULL;
	LPTSTR pszURL = NULL;
	INT iServerCnt;
	BOOL fInternalServer = FALSE;

	QuitIfFail(FindSingleDOMNode(pXMLClientInfo, bstrClientInfo, &pQueryClient));
	QuitIfFail(GetAttribute(pQueryClient, bstrClientName, &bstrClient));

	pszURL = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszURL);

	//
	// failure in "g_pUrlAgent = new CUrlAgent"
	//
	CleanUpFailedAllocSetHrMsg(g_pUrlAgent);
	QuitIfFail(g_pUrlAgent->GetQueryServer(OLE2T(bstrClient), pszURL, INTERNET_MAX_URL_LENGTH, &fInternalServer));

	if (fInternalServer)
	{
		//
		// we have policy override for this client, set the query url as WUServer in policy
		//
		*ppszURL = pszURL;
		hr = S_OK;
	}
	else
	{
		//
		// we don't have policy override for this client;
		//
		// find the ServerCache URL from <query> node
		//
		QuitIfFail(FindSingleDOMNode(pXMLQuery, bstrQuery, &pQueryNode));
		if (SUCCEEDED(GetAttribute(pQueryNode, bstrHref, &bstrURL))
			&& NULL != bstrURL && SysStringLen(bstrURL) >0)
		{
			//
			// this is the case that the query specified the serverl url, we need
			// to do the validation for the url here...
			//

			// pszURL is alloced to be INTERNET_MAX_URL_LENGTH above.
			hr = StringCchCopyEx(pszURL, INTERNET_MAX_URL_LENGTH, OLE2T(bstrURL), 
			                     NULL, NULL, MISTSAFE_STRING_FLAGS);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto CleanUp;
			}

			//
			// process the iuident.txt to find all valid ServerCache URLs
			//
			TCHAR szIUDir[MAX_PATH];
			TCHAR szIdentFile[MAX_PATH];

			GetIndustryUpdateDirectory(szIUDir);
			hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
			if (FAILED(hr))
			{
			    LOG_ErrorMsg(hr);
			    goto CleanUp;
			}

			iServerCnt = GetPrivateProfileInt(IDENT_IUSERVERCACHE,
											  IDENT_IUSERVERCOUNT,
											  -1,
											  szIdentFile);
			if (-1 == iServerCnt)
			{
				// no ServerCount number specified in iuident.txt
				LOG_Error(_T("No ServerCount number specified in iuident.txt"));
				hr = E_FAIL;
				goto CleanUp;
			}

			hr = INET_E_INVALID_URL;
			for (INT i=1; i<=iServerCnt; i++)
			{
				TCHAR szValidURL[INTERNET_MAX_URL_LENGTH];
				TCHAR szServer[32];

				hr = StringCchPrintfEx(szServer, ARRAYSIZE(szServer), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                       _T("%s%d"), IDENT_IUSERVER, i);
				if (FAILED(hr))
				{
				    LOG_ErrorMsg(hr);
				    goto CleanUp;
				}

				hr = INET_E_INVALID_URL;
				GetPrivateProfileString(IDENT_IUSERVERCACHE,
										szServer,
										_T(""),
										szValidURL,
										ARRAYSIZE(szValidURL),
										szIdentFile);

				if ('\0' == szValidURL[0])
				{
					// no ServerCache URL specified in iuident.txt for this server
					LOG_Error(_T("No ServerCache URL specified in iuident.txt for %s%d"), IDENT_IUSERVER, i);
					hr = E_FAIL;
					goto CleanUp;
				}
				
				if (0 == lstrcmpi(szValidURL, pszURL))
				{
					// it's a valid ServerCache URL
					*ppszURL = pszURL;
					hr = S_OK;
					break;
				}
			}
		}
		else
		{
			//
			// this is the case that the query didn't specify the serverl url, we just use the
			// server url that was found through g_pUrlAgent according to the clientName.
			//
			// now insert the URL into the <query> node
			//
			BSTR bstrTemp = T2BSTR(pszURL);
			QuitIfFail(SetAttribute(pQueryNode, bstrHref, bstrTemp));
			SafeSysFreeString(bstrTemp);

			*ppszURL = pszURL;
		}
	}

CleanUp:
    if (FAILED(hr))
	{
		HeapFree(GetProcessHeap(), 0, pszURL);
		*ppszURL = NULL;
		LOG_ErrorMsg(hr);
	}
    SafeReleaseNULL(pQueryNode);
    SafeReleaseNULL(pQueryClient);
	SysFreeString(bstrQuery);
	SysFreeString(bstrHref);
	SysFreeString(bstrURL);
	SysFreeString(bstrClientInfo);
	SysFreeString(bstrClientName);
	SysFreeString(bstrClient);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetSOAPQuery()
//
// Concatenate the several xml client input into a single XML
// with the SOAP syntax/format that the server recognizes
// Input:
// pXMLClientInfo - the credentials of the client in DOM Doc format
// pXMLSystemSpec - the detected system specifications in DOM Doc
// pXMLQuery - the user query infomation in DOM Doc
// Return:
// ppSOAPQuery - the concatenated query in DOM Doc with required SOAP syntax
//
// SOAPQuery xml doc example:
// <SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/">
//	<SOAP:Body>
//		<GetManifest>
//			<clientInfo>...</clientInfo>
//			<systemSpec>...</systemSpec>
//			<query href="//windowsupdate.microsoft.com/servecache.asp">...</query>
//		</GetManifest>
//	</SOAP:Body>
// </SOAP:Envelope>
//
/////////////////////////////////////////////////////////////////////////////
HRESULT GetSOAPQuery(IXMLDOMDocument *pXMLClientInfo,
					 IXMLDOMDocument *pXMLSystemSpec,
					 IXMLDOMDocument *pXMLQuery,
					 IXMLDOMDocument **ppSOAPQuery)
{
	LOG_Block("GetSOAPQuery()");

	USES_IU_CONVERSION;

	HRESULT	hr = E_FAIL;

	IXMLDOMDocument*	pDocSOAPQuery = NULL;
	IXMLDOMNode*	pNodeSOAPEnvelope = NULL;
	IXMLDOMNode*	pNodeSOAPBody = NULL;
	IXMLDOMNode*	pNodeGetManifest = NULL;
	IXMLDOMNode*	pNodeClientInfo = NULL;
	IXMLDOMNode*	pNodeClientInfoNew = NULL;
	IXMLDOMNode*	pNodeSystemInfo = NULL;
	IXMLDOMNode*	pNodeSystemInfoNew = NULL;
	IXMLDOMNode*	pNodeQuery = NULL;
	IXMLDOMNode*	pNodeQueryNew = NULL;
	BSTR bstrNameSOAPEnvelope = SysAllocString(L"SOAP:Envelope");
	BSTR bstrNameSOAPBody = SysAllocString(L"SOAP:Body");
	BSTR bstrNameGetManifest = SysAllocString(L"GetManifest");
	BSTR bstrClientInfo = SysAllocString(L"clientInfo");
	BSTR bstrSystemInfo = SysAllocString(L"systemInfo");
	BSTR bstrQuery = SysAllocString(L"query");
	BSTR bstrNameSpaceSchema = NULL;

	//
	// process the iuident.txt to find the SOAPQuery schema path
	//
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    LPTSTR pszSOAPQuerySchema = NULL;
	LPTSTR pszNameSpaceSchema = NULL;

	pszSOAPQuerySchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	if (NULL == pszSOAPQuerySchema)
	{
		hr = E_OUTOFMEMORY;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}
	pszNameSpaceSchema = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, INTERNET_MAX_URL_LENGTH * sizeof(TCHAR));
	if (NULL == pszNameSpaceSchema)
	{
		hr = E_OUTOFMEMORY;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	GetIndustryUpdateDirectory(szIUDir);
    hr = PathCchCombine(szIdentFile, ARRAYSIZE(szIdentFile), szIUDir, IDENTTXT);
    if (FAILED(hr))
    {
		LOG_ErrorMsg(hr);
		goto CleanUp;
    }

    GetPrivateProfileString(IDENT_IUSCHEMA,
							IDENT_IUSCHEMA_SOAPQUERY,
							_T(""),
							pszSOAPQuerySchema,
							INTERNET_MAX_URL_LENGTH,
							szIdentFile);

    if ('\0' == pszSOAPQuerySchema[0])
    {
        // no SOAPQuery schema path specified in iuident.txt
        LOG_Error(_T("No schema path specified in iuident.txt for SOAPQuery"));
        hr = E_FAIL;
		goto CleanUp;
    }

    // pszNameSpaceSchema is alloced to be INTERNET_MAX_URL_LENGTH above
	hr = StringCchPrintfEx(pszNameSpaceSchema, INTERNET_MAX_URL_LENGTH, NULL, NULL, MISTSAFE_STRING_FLAGS,
	                       _T("x-schema:%s"), pszSOAPQuerySchema);
	if (FAILED(hr))
	{
	    LOG_ErrorMsg(hr);
	    goto CleanUp;
	}

	bstrNameSpaceSchema = T2BSTR(pszNameSpaceSchema);

 	//
	// construct the SOAPQuery xml
	//
	QuitIfFail(CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, IID_IXMLDOMDocument, (void **)&pDocSOAPQuery));

	pNodeSOAPEnvelope = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameSOAPEnvelope, bstrNameSpaceSchema);
	if (NULL == pNodeSOAPEnvelope) goto CleanUp;
	QuitIfFail(InsertNode(pDocSOAPQuery, pNodeSOAPEnvelope));

	pNodeSOAPBody = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameSOAPBody, bstrNameSpaceSchema);
	if (NULL == pNodeSOAPBody) goto CleanUp;
	QuitIfFail(InsertNode(pNodeSOAPEnvelope, pNodeSOAPBody));

	pNodeGetManifest = CreateDOMNode(pDocSOAPQuery, NODE_ELEMENT, bstrNameGetManifest);
	if (NULL == pNodeGetManifest) goto CleanUp;
	QuitIfFail(InsertNode(pNodeSOAPBody, pNodeGetManifest));

	if (NULL != pXMLClientInfo)
	{
		QuitIfFail(FindSingleDOMNode(pXMLClientInfo, bstrClientInfo, &pNodeClientInfo));
		QuitIfFail(CopyNode(pNodeClientInfo, pDocSOAPQuery, &pNodeClientInfoNew));
		QuitIfFail(InsertNode(pNodeGetManifest, pNodeClientInfoNew));
	}
	if (NULL != pXMLSystemSpec)
	{
		QuitIfFail(FindSingleDOMNode(pXMLSystemSpec, bstrSystemInfo, &pNodeSystemInfo));
		QuitIfFail(CopyNode(pNodeSystemInfo, pDocSOAPQuery, &pNodeSystemInfoNew));
		QuitIfFail(InsertNode(pNodeGetManifest, pNodeSystemInfoNew));
	}
	QuitIfFail(FindSingleDOMNode(pXMLQuery, bstrQuery, &pNodeQuery));
	QuitIfFail(CopyNode(pNodeQuery, pDocSOAPQuery, &pNodeQueryNew));
	QuitIfFail(InsertNode(pNodeGetManifest, pNodeQueryNew));

CleanUp:
    if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
		SafeReleaseNULL(pDocSOAPQuery);
	}
	SafeReleaseNULL(pNodeSOAPEnvelope);
	SafeReleaseNULL(pNodeSOAPBody);
	SafeReleaseNULL(pNodeGetManifest);
	SafeReleaseNULL(pNodeClientInfo);
	SafeReleaseNULL(pNodeClientInfoNew);
	SafeReleaseNULL(pNodeSystemInfo);
	SafeReleaseNULL(pNodeSystemInfoNew);
	SafeReleaseNULL(pNodeQuery);
	SafeReleaseNULL(pNodeQueryNew);
	SysFreeString(bstrNameSOAPEnvelope);
	SysFreeString(bstrNameSOAPBody);
	SysFreeString(bstrNameGetManifest);
	SysFreeString(bstrClientInfo);
	SysFreeString(bstrSystemInfo);
	SysFreeString(bstrQuery);
	SafeHeapFree(pszSOAPQuerySchema);
	SafeHeapFree(pszNameSpaceSchema);
	SysFreeString(bstrNameSpaceSchema);
	*ppSOAPQuery = pDocSOAPQuery;
	return hr;
}





// Function name	: ValidatePID
// Description	    : This function is used to check the return xml from the 
// server in response to getmanifest calls. 
// If the catalogStatus attribute is  not present or is 0 then the pid validation succeeded
// If the catalogStatus attribute is 1 then an error is returned
 
// Return type		: HRESULT 
// Argument         : IXMLDOMDocument *pXmlDomDocument

HRESULT ValidatePID(IXMLDOMDocument *pXmlDomDocument)
{
	
	LOG_Block("ValidatePID()");
	HRESULT hr = S_OK;
	IXMLDOMElement *pRootElement = NULL;


	long lStatus = 0;


	if(!pXmlDomDocument)
	{
		return E_INVALIDARG;
	}


	BSTR bCatalogStatus = SysAllocString(L"catalogStatus");

	if(!bCatalogStatus)
	{
		return E_OUTOFMEMORY;
	}
	

	QuitIfFail( pXmlDomDocument->get_documentElement(&pRootElement) );

	//get the catalogStatus attribute
	QuitIfFail( GetAttribute( (IXMLDOMNode *)pRootElement, bCatalogStatus, &lStatus));

	if(errorInvalidLicense == lStatus)
		hr = E_INVALID_PID;

CleanUp:

	if(FAILED(hr))
		LOG_ErrorMsg(hr);

	//catalogStatus is an optional attribute. If it is not found we get the
	//hresult as S_FALSE. So reset it to S_OK

	if(S_FALSE == hr)
		hr = S_OK;

	SafeReleaseNULL(pRootElement);
	SysFreeString(bCatalogStatus);
	return hr;

}




// Function name	: PingInvalidPID
// Description	    : This function sends a ping message to the server
// to indicate failure of PID validation
// Return type		: void 
// Argument         : BSTR bstrClientName
// Argument         : HRESULT hRes
// Argument         : HANDLE *phQuit
// Argument         : DWORD dwNumHandles

void PingInvalidPID(BSTR bstrClientName, HRESULT hRes, HANDLE *phQuit, DWORD dwNumHandles)
{


		
	LOG_Block("PingInvalidPID()");
	
	USES_IU_CONVERSION;

	HRESULT hr = S_OK;
	URLLOGSTATUS status = URLLOGSTATUS_Declined;
	LPTSTR		ptszLivePingServerUrl = NULL;
	LPTSTR		ptszCorpPingServerUrl = NULL;

	if (NULL != (ptszLivePingServerUrl = (LPTSTR)HeapAlloc(
														GetProcessHeap(),
														HEAP_ZERO_MEMORY,
														INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED( g_pUrlAgent->GetLivePingServer(ptszLivePingServerUrl, INTERNET_MAX_URL_LENGTH) ) )
		{
			SafeHeapFree(ptszLivePingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszLivePingServerUrl"));
	}

	if (NULL != (ptszCorpPingServerUrl = (LPTSTR)HeapAlloc(
													GetProcessHeap(),
													HEAP_ZERO_MEMORY,
													INTERNET_MAX_URL_LENGTH * sizeof(TCHAR))))
	{
		if (FAILED(g_pUrlAgent->GetCorpPingServer(ptszCorpPingServerUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Out(_T("failed to get corp WU ping server URL"));
			SafeHeapFree(ptszCorpPingServerUrl);
		}
	}
	else
	{
		LOG_Out(_T("failed to allocate memory for ptszCorpPingServerUrl"));
	}


	LPTSTR lpClientName = NULL;

	if(bstrClientName)
	{
		lpClientName = OLE2T(bstrClientName);

	}

	CUrlLog pingSvr(lpClientName, ptszLivePingServerUrl, ptszCorpPingServerUrl); 

	SafeHeapFree(ptszLivePingServerUrl);
	SafeHeapFree(ptszCorpPingServerUrl);


	pingSvr.Ping(TRUE,						// on-line
				URLLOGDESTINATION_DEFAULT,	// going live or corp WU ping server
				phQuit,			// pt to cancel events
				dwNumHandles,							// number of events
				URLLOGACTIVITY_Download,	// activity
				status,						// status code
				hRes,							
				NULL,
				NULL,
				g_szInvalidPID
			);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\sysspec.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   sysspec.cpp
//
//  Description:
//
//      Implementation for the GetSystemSpec() function
//
//=======================================================================

#include "iuengine.h"
#include "iuxml.h"
#include <iucommon.h>

#include <comdef.h>
#include <osdet.h>
#include <setupapi.h>
#include <regstr.h>
#include <winspool.h>	// for DRIVER_INFO_6
#include "cdmp.h"		// for GetInstalledPrinterDriverInfo()
#include <shlwapi.h>
#include <safereg.h>
#include <safefile.h>
#include <safefunc.h>
#include <wusafefn.h>





//
// Specify a V1 structure passed to SetupDiBuildDriverInfoList
// so we will work on NT4/Win9x and don't need to
// fill in the extra V2 data on Win2K up
//
#define  USE_SP_DRVINFO_DATA_V1 1

//
// Constants
//

const TCHAR SZ_WIN32_NT[] = _T("VER_PLATFORM_WIN32_NT");
const TCHAR SZ_WIN32_WINDOWS[] = _T("VER_PLATFORM_WIN32_WINDOWS");
const CHAR	SZ_GET_SYSTEM_SPEC[] = "Determining machine configuration";

#if defined(_X86_) || defined(i386)
const TCHAR SZ_PROCESSOR[] = _T("x86");
#else // defined(_IA64_) || defined(IA64)
const TCHAR SZ_PROCESSOR[] = _T("ia64");
#endif

const TCHAR SZ_SUITE_SMALLBUSINESS[] = _T("VER_SUITE_SMALLBUSINESS");
const TCHAR SZ_SUITE_ENTERPRISE[] = _T("VER_SUITE_ENTERPRISE");
const TCHAR SZ_SUITE_BACKOFFICE[] = _T("VER_SUITE_BACKOFFICE");
const TCHAR SZ_SUITE_COMMUNICATIONS[] = _T("VER_SUITE_COMMUNICATIONS");
const TCHAR SZ_SUITE_TERMINAL[] = _T("VER_SUITE_TERMINAL");
const TCHAR SZ_SUITE_SMALLBUSINESS_RESTRICTED[] = _T("VER_SUITE_SMALLBUSINESS_RESTRICTED");
const TCHAR SZ_SUITE_EMBEDDEDNT[] = _T("VER_SUITE_EMBEDDEDNT");
const TCHAR SZ_SUITE_DATACENTER[] = _T("VER_SUITE_DATACENTER");
const TCHAR SZ_SUITE_SINGLEUSERTS[] = _T("VER_SUITE_SINGLEUSERTS");
const TCHAR SZ_SUITE_PERSONAL[] = _T("VER_SUITE_PERSONAL");
const TCHAR SZ_SUITE_BLADE[] = _T("VER_SUITE_BLADE");


const TCHAR SZ_NT_WORKSTATION[] = _T("VER_NT_WORKSTATION");
const TCHAR SZ_NT_DOMAIN_CONTROLLER[] = _T("VER_NT_DOMAIN_CONTROLLER");
const TCHAR SZ_NT_SERVER[] = _T("VER_NT_SERVER");

const TCHAR SZ_AMPERSAND[] = _T("&");


const TCHAR SZ_LICDLL[]=_T("licdll.dll");

LPCSTR  lpszIVLK_GetEncPID  = (LPCSTR)227;

typedef HRESULT (WINAPI *PFUNCGetEncryptedPID)(OUT BYTE  **ppbPid,OUT DWORD *pcbPid);


//
// DriverVer in schema uses ISO 8601 prefered format (yyyy-mm-dd)
//
const TCHAR SZ_UNKNOWN_DRIVERVER[] = _T("0000-00-00");
#define SIZEOF_DRIVERVER sizeof(SZ_UNKNOWN_DRIVERVER)
#define TCHARS_IN_DRIVERVER (ARRAYSIZE(SZ_UNKNOWN_DRIVERVER) - 1)


//forward declaration for the function which gets the PID
HRESULT GetSystemPID(BSTR &bstrPID);
HRESULT BinaryToString(BYTE *lpBinary,DWORD dwLength,LPWSTR lpString,DWORD *pdwLength);

//
// Helper functions
//

HRESULT GetMultiSzDevRegProp(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, DWORD dwProperty, LPTSTR* ppMultiSZ)
{
	LOG_Block("GetMultiSzDevRegProp");

	HRESULT hr = S_OK;
	ULONG ulSize = 0;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == pDevInfoData || NULL == ppMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppMultiSZ = NULL;

	//
	// Several different errors may be set depending on the size/existance of the property,
	// but these aren't errors for us, we only care about filling in the buffer if the
	// property exists
	//
	(void) SetupDiGetDeviceRegistryProperty(hDevInfoSet, pDevInfoData, dwProperty, NULL, NULL, 0, &ulSize);

	if (0 < ulSize)
	{
		//
		// Create a zero initialized buffer 4 bytes (two Unicode characters) longer than we think we need
		// to protect ourselves from incorrect results returned by SetupDiGetDeviceRegistryProperties on
		// some platforms. In addition, Win98 requires at least one character more than what it returned
		// in ulSize, so we just make it 8 bytes over and pass four of them as an extra-sized buffer.
		//
		CleanUpFailedAllocSetHrMsg(*ppMultiSZ = (TCHAR*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSize + 8));

		//
		// Get the actual hardware/compatible IDs (but don't tell SetupDiXxx about the extra four bytes of buffer)
		//
		if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, pDevInfoData, dwProperty, NULL, (LPBYTE) *ppMultiSZ, ulSize + 4, NULL))
		{
			DWORD dwError = GetLastError();
			LOG_Driver(_T("Informational: SetupDiGetDeviceRegistryProperty failed: 0x%08x"), dwError);
			if (ERROR_NO_SUCH_DEVINST == dwError || ERROR_INVALID_REG_PROPERTY == dwError || ERROR_INSUFFICIENT_BUFFER == dwError)
			{
				//
				// Return valid errors
				//
				SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(dwError));
			}
			//
			// Some devices don't have the registry info we are looking for, so exit with default S_OK
			//
			goto CleanUp;
		}
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppMultiSZ);
	}

	return hr;
}

HRESULT AddIDToXml(LPCTSTR pszMultiSZ, CXmlSystemSpec& xmlSpec, DWORD dwProperty,
						  DWORD& dwRank, HANDLE_NODE& hDevices, LPCTSTR pszMatchingID, LPCTSTR pszDriverVer)
{
	LOG_Block("AddIDToXml");
	HRESULT hr = S_OK;
	BSTR bstrMultiSZ = NULL;
	BSTR bstrDriverVer = NULL;

	if (NULL == pszMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	//
	// Open a <device> element if necessary (don't reopen for compatible IDs)
	//
	if (HANDLE_NODE_INVALID == hDevices)
	{
		CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, -1, NULL, NULL, NULL, &hDevices));
	}

	for (NULL ; *pszMultiSZ; pszMultiSZ += (lstrlen(pszMultiSZ) + 1))
	{
		if (   NULL != pszMatchingID
			&& NULL != pszDriverVer
			&& 0 == lstrcmpi(pszMultiSZ, pszMatchingID)	)
		{
			LOG_Driver(_T("ID: %s Match: %s, rank: %d, DriverVer: %s"), pszMultiSZ, pszMatchingID, dwRank, pszDriverVer);
			CleanUpFailedAllocSetHrMsg(bstrMultiSZ = T2BSTR(pszMultiSZ));
			CleanUpFailedAllocSetHrMsg(bstrDriverVer = T2BSTR(pszDriverVer));
			CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, (SPDRP_COMPATIBLEIDS == dwProperty), dwRank++, bstrMultiSZ, bstrDriverVer));
			SafeSysFreeString(bstrMultiSZ);
			SafeSysFreeString(bstrDriverVer);
			//
			// We found the ID with the driver installed - don't pass any of lower rank up
			//
			hr = S_FALSE;
			break;
		}
		else
		{
			LOG_Driver(_T("ID: %s, rank: %d"), pszMultiSZ, dwRank);
			CleanUpFailedAllocSetHrMsg(bstrMultiSZ = T2BSTR(pszMultiSZ));
			CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hDevices, (SPDRP_COMPATIBLEIDS == dwProperty), dwRank++, bstrMultiSZ, NULL));
			SafeSysFreeString(bstrMultiSZ);
		}
	}

CleanUp:

	SysFreeString(bstrMultiSZ);
	SysFreeString(bstrDriverVer);
	return hr;
}

HRESULT DoesHwidMatchPrinter(
					DRIVER_INFO_6* paDriverInfo6,			// array of DRIVER_INFO_6 structs for installed printer drivers
					DWORD dwDriverInfoCount,				// count of structs in paDriverInfo6 array
					LPCTSTR pszMultiSZ,						// Hardware or Compatible MultiSZ to compare with installed printer drivers
					BOOL* pfHwidMatchesInstalledPrinter)	// [OUT] set TRUE if we match an installed printer driver
{
	LOG_Block("DoesHwidMatchPrinter");

	HRESULT hr = S_OK;

	if (NULL == pfHwidMatchesInstalledPrinter || NULL == pszMultiSZ)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pfHwidMatchesInstalledPrinter = FALSE;

	if (NULL == paDriverInfo6 || 0 == dwDriverInfoCount)
	{
		LOG_Driver(_T("WARNING: We're missing printer information (maybe no installed printer drivers), so we won't prune"));
		goto CleanUp;
	}

	for (NULL; *pszMultiSZ; pszMultiSZ += (lstrlen(pszMultiSZ) + 1))
	{
		for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
		{
			if (NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
			{
				continue;
			}
			//
			// Use case-insensitive compares (paDriverInfo6 is different case from bstrHwidTxtTemp)
			//
			if (0 == lstrcmpi(pszMultiSZ, (paDriverInfo6 + dwCount)->pszHardwareID))
			{
				LOG_Driver(_T("HWID (%s) matches an installed printer driver"), pszMultiSZ);
				*pfHwidMatchesInstalledPrinter = TRUE;
				goto CleanUp;
			}
		}
	}

CleanUp:

	return hr;
}

HRESULT AddPrunedDevRegProps(HDEVINFO hDevInfoSet,
									PSP_DEVINFO_DATA pDevInfoData,
									CXmlSystemSpec& xmlSpec,
									LPTSTR pszMatchingID,
									LPTSTR pszDriverVer,
									DRIVER_INFO_6* paDriverInfo6,	// OK if this is NULL (no installed printer drivers)
									DWORD dwDriverInfoCount,
									BOOL fIsSysSpecCall)			// Called by GetSystemSpec and GetPackage, with slightly different behavior
{
	LOG_Block("AddPrunedDevRegProps");
	HRESULT hr = S_OK;
	LPTSTR pszMultiHwid = NULL;
	LPTSTR pszMultiCompid = NULL;
	DWORD dwRank = 0;
	HANDLE_NODE hDevices = HANDLE_NODE_INVALID;
	BOOL fHwidMatchesInstalledPrinter = FALSE;

	//
	// Get the Hardware and Compatible Multi-SZ strings so we can prune printer devices before commiting to XML.
	//
	// Note that GetMultiSzDevRegProp may return S_OK and a NULL *ppMultiSZ if the SRDP doesn't exist.
	//
	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_HARDWAREID, &pszMultiHwid));

	CleanUpIfFailedAndSetHr(GetMultiSzDevRegProp(hDevInfoSet, pDevInfoData, SPDRP_COMPATIBLEIDS, &pszMultiCompid));

	if (fIsSysSpecCall)
	{
		//
		// We prune this device if a HWID or CompID matches a HWID of an installed printer since we
		// must avoid offering a driver that may conflict with one if the installed printer drivers.
		// Other code will write <device isPrinter="1" /> elements to the system spec XML to be used in
		// offering printer drivers. NOTE, if there is no printer driver currently installed for the given
		// HWID we will just offer the driver based on the PnP match.
		//
		if (NULL != pszMultiHwid)
		{
			CleanUpIfFailedAndSetHr(DoesHwidMatchPrinter(paDriverInfo6, dwDriverInfoCount, pszMultiHwid, &fHwidMatchesInstalledPrinter));
			if(fHwidMatchesInstalledPrinter)
			{
				goto CleanUp;
			}
		}

		if (NULL != pszMultiCompid)
		{
			CleanUpIfFailedAndSetHr(DoesHwidMatchPrinter(paDriverInfo6, dwDriverInfoCount, pszMultiCompid, &fHwidMatchesInstalledPrinter));
			if(fHwidMatchesInstalledPrinter)
			{
				goto CleanUp;
			}
		}
	}

	//
	// Add the Hardware and Compatible IDs to XML
	//
	if (NULL != pszMultiHwid)
	{
		CleanUpIfFailedAndSetHr(AddIDToXml(pszMultiHwid, xmlSpec, SPDRP_HARDWAREID, dwRank, hDevices, pszMatchingID, pszDriverVer));
	}
	//
	// Skip compatible IDs if we don't have any or already found a match (hr == S_FALSE)
	//
	if (NULL != pszMultiCompid && hr == S_OK)
	{
		CleanUpIfFailedAndSetHr(AddIDToXml(pszMultiCompid, xmlSpec, SPDRP_COMPATIBLEIDS, dwRank, hDevices, pszMatchingID, pszDriverVer));
	}

CleanUp:

	SafeHeapFree(pszMultiHwid);
	SafeHeapFree(pszMultiCompid);

	if (HANDLE_NODE_INVALID != hDevices)
	{
		xmlSpec.SafeCloseHandleNode(hDevices);
	}

	return hr;
}

static HRESULT DriverVerToIso8601(LPTSTR * ppszDriverVer)
{
	LOG_Block("DriverVerToIso8601");

	HRESULT hr = S_OK;
	TCHAR pszDVTemp[TCHARS_IN_DRIVERVER + 1];
	LPTSTR pszMonth = pszDVTemp;
	LPTSTR pszDay = NULL;
	LPTSTR pszYear = NULL;

	//
	//                     buffer:      pszDVTemp                     *ppszDriverVer
	// DriverVer: "[m]m-[d]d-yyyy" or "[m]m/[d]d/yyyy" --> ISO 8601: "yyyy-mm-dd"
	//                     index:         01   234567                 0123456789
	//                                  0 12 3 456789 ,,, etc, 
	//
	if (NULL == ppszDriverVer || NULL == *ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

    int nInLength = lstrlen(*ppszDriverVer);
    if (nInLength < TCHARS_IN_DRIVERVER - 2 || nInLength > TCHARS_IN_DRIVERVER)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		(*ppszDriverVer)[0] = _T('\0');
		return E_INVALIDARG;
	}

	// Make sure *ppszDriverVer is large enough for ISO 8601
	//
	// **** It is VERY IMPORTANT that NO FAILURE CASE with an error of E_INVALIDARG go from before this ****
	// ****  size check to the CleanUp section below.                                                   ****
	//
	if (ARRAYSIZE(pszDVTemp) > nInLength)
	{
	    // if the size of this alloc is changed from SIZEOF_DRIVERVER, the StringCbCopy call below will need to be
	    //  changd appropriately as well.
		LPTSTR pszTemp = (LPTSTR) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (LPVOID) *ppszDriverVer, SIZEOF_DRIVERVER);
		if (NULL == pszTemp)
		{
			CleanUpIfFailedAndSetHrMsg(E_OUTOFMEMORY);
		}
		*ppszDriverVer = pszTemp;
	}
	
	LOG_Driver(_T("In: \"%s\""), *ppszDriverVer);

	if ((_T('-') == (*ppszDriverVer)[4] || _T('/') == (*ppszDriverVer)[4]) &&
		(_T('-') == (*ppszDriverVer)[7] || _T('/') == (*ppszDriverVer)[7]))
	{
		//
		// It's probably already a valid ISO date, so do nothing
		//
		SetHrMsgAndGotoCleanUp(S_FALSE);
	}
	//
	// Unfortunately, DriverDate under HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Class (Win2K)
	// in the registry doesn't *always* pad the mm and dd fields with _T('0') for single digit months and days,
	// so we have to do this the hard way. But watch out - there's more. Win98SE (and maybe more)
	// pad with spaces, so we also have to change spaces to _T('0').
	//
	
	//
	// Copy to pszDVTemp
	//
	hr = StringCchCopyEx(pszDVTemp, ARRAYSIZE(pszDVTemp), *ppszDriverVer,
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	//
	// Find end of month, start of day
	//
	int i;
	for (i = 0; i < 3; i++)
	{
		if (_T('-') == pszMonth[i] || _T('/') == pszMonth[i])
		{
			pszMonth[i] = 0;
			pszDay = &pszMonth[i+1];
			break;
		}
		else if (_T(' ') == pszMonth[i])
		{
			pszMonth[i] = _T('0');
		}
		else if (!(_T('0') <= pszMonth[i] && _T('9') >= pszMonth[i]))
		{
			//
			// non-decimal characters other than _T('/') and "-"
			//
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}
	if (NULL == pszDay || 0 == pszMonth[0])
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
	//
	// Find end of day, start of year
	//
	for (i = 0; i < 3; i++)
	{
		if (_T('-') == pszDay[i] || _T('/') == pszDay[i])
		{
			pszDay[i] = 0;
			pszYear = &pszDay[i+1];
			break;
		}
		else if (' ' == pszDay[i])
		{
			pszDay[i] = _T('0');
		}
		else if (!(_T('0') <= pszDay[i] && _T('9') >= pszDay[i]))
		{
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}
	if (NULL == pszYear || 0 == pszDay[0])
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
	//
	// Verify year is four decimal digits
	//
	for (i = 0; i < 4 ; i++)
	{
		if (!(_T('0') <= pszYear[i] && _T('9') >= pszYear[i]) || _T('\0') == pszYear[i])
		{
			SetHrMsgAndGotoCleanUp(E_INVALIDARG);
		}
	}

	//
	// Copy back "yyyy" to start of string
	//
	hr = StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, pszYear, 
	                    NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	//
	// Copy month and pad if necessary
	//
	if (2 == lstrlen(pszMonth))
	{
		(*ppszDriverVer)[5] = pszMonth[0];
		(*ppszDriverVer)[6] = pszMonth[1];
	}
	else
	{
		(*ppszDriverVer)[5] = _T('0');
		(*ppszDriverVer)[6] = pszMonth[0];
	}
	//
	// Copy day and pad if necessary
	//
	//
	if (2 == lstrlen(pszDay))
	{
		(*ppszDriverVer)[8] = pszDay[0];
		(*ppszDriverVer)[9] = pszDay[1];
	}
	else
	{
		(*ppszDriverVer)[8] = _T('0');
		(*ppszDriverVer)[9] = pszDay[0];
	}
	// Add back the field separators: _T('-')
	//
	(*ppszDriverVer)[4] = _T('-');
	(*ppszDriverVer)[7] = _T('-');
	//
	// NULL terminate string
	//
	(*ppszDriverVer)[10] = _T('\0');

CleanUp:

	//
	// If we got garbage in, copy default date to *ppszDriverVer and return S_FALSE
	//
	if (E_INVALIDARG == hr)
	{
	    // This is safe to do because we know that this function calls HeapReAlloc
		// on this buffer if it is too small above.
	    (void) StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, SZ_UNKNOWN_DRIVERVER, 
	                   NULL, NULL, MISTSAFE_STRING_FLAGS);
		hr = S_FALSE;
	}

	LOG_Driver(_T("Out: \"%s\""), *ppszDriverVer);

	return hr;
}



static HRESULT GetFirstStringField(HINF hInf, LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue, DWORD dwcValueTCHARs)
{
	LOG_Block("GetFirstStringField");

	INFCONTEXT ctx;
	HRESULT hr = S_OK;

	if (INVALID_HANDLE_VALUE == hInf	||
		NULL == szSection				||
		NULL == szKey					||
		NULL == szValue					||
		0 == dwcValueTCHARs				)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*szValue = _T('\0');
	
	if (0 == SetupFindFirstLine(hInf, szSection, szKey, &ctx))
	{
		LOG_Error(_T("SetupFindFirstLine"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (0 == SetupGetStringField(&ctx, 1, szValue, dwcValueTCHARs, NULL))
	{
		LOG_Error(_T("SetupGetStringField"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

CleanUp:

	if (FAILED(hr))
	{
		*szValue = _T('\0');
	}

	return hr;
}


HRESULT GetPropertyFromSetupDi(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, ULONG ulProperty, LPTSTR* ppszProperty)
{
	LOG_Block("GetPropertyFromSetupDi");

	HRESULT hr = S_OK;
	ULONG ulSize = 0;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == ppszProperty)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszProperty = NULL;

	if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, &devInfoData, ulProperty, NULL, NULL, 0, &ulSize))
	{
		if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
		{
			LOG_Error(_T("SetupDiGetDeviceRegistryProperty"));
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}

	if (0 == ulSize)
	{
		LOG_Error(_T("SetupDiGetDeviceRegistryProperty returned zero size"));
		SetHrAndGotoCleanUp(E_FAIL);
	}
    // Win98 has a bug when requesting SPDRP_HARDWAREID
    // NTBUG9#182680 We make this big enough to always have a Unicode double-null at the end
    // so that we don't fault if the reg value isn't correctly terminated. Don't tell SetupDiXxxx
	// about all eight extra bytes.
	ulSize += 8;
	// NTBUG9#182680 zero the buffer so we don't get random garbage - REG_MULTI_SZ isn't always double-null terminated
	CleanUpFailedAllocSetHrMsg(*ppszProperty = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ulSize));

	if (!SetupDiGetDeviceRegistryProperty(hDevInfoSet, &devInfoData, ulProperty, NULL, (LPBYTE)*ppszProperty, ulSize - 4 , NULL))
	{
		LOG_Error(_T("SetupDiGetDeviceRegistryProperty"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

CleanUp:

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszProperty);
	}

	return hr;
}

HRESULT GetPropertyFromSetupDiReg(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPCTSTR szProperty, LPTSTR *ppszData)
{
	LOG_Block("GetPropertyFromSetupDiReg");

	int cchValueSize = 0;
	HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || NULL == szProperty || NULL == ppszData)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszData = NULL;
	//
	// Open a software, or driver, registry key for the device. This key is located in the Class branch.
	//
	if (INVALID_HANDLE_VALUE == (hKey = SetupDiOpenDevRegKey(hDevInfoSet, &devInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ)))
	{
		LOG_Error(_T("SetupDiOpenDevRegKey"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	hr = SafeRegQueryStringValueCch(hKey, szProperty, NULL, 0, &cchValueSize);
	if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
	{
		CleanUpIfFailedAndSetHrMsg(hr);
	}

	//
	// Sanity check size of data in registry
	//
	if (MAX_INF_STRING_LEN < cchValueSize)
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}

	//
	// Add extra character of zero'ed memory for safety
	//
	CleanUpFailedAllocSetHrMsg(*ppszData = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

	CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKey, szProperty, *ppszData, cchValueSize, &cchValueSize));

CleanUp:

	if (INVALID_HANDLE_VALUE != hKey)
	{
		RegCloseKey(hKey);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszData);
	}

	return hr;
}

static HRESULT DriverVerFromInf(HINF hInf, LPTSTR pszMfg, LPTSTR pszDescription, LPTSTR* ppszDriverVer)
{
	LOG_Block("DriverVerFromInf");

	HRESULT hr;
	TCHAR szDeviceSec[MAX_PATH + 1];
	TCHAR szValue[MAX_PATH + 1];
	TCHAR szInstallSec[MAX_PATH + 1];

	if (INVALID_HANDLE_VALUE == hInf	||
		NULL == pszMfg					||
		NULL == pszDescription			||
		NULL == ppszDriverVer	)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	ZeroMemory(szDeviceSec , sizeof(szDeviceSec));
	ZeroMemory(szValue , sizeof(szValue));
	ZeroMemory(szInstallSec , sizeof(szInstallSec));
	*ppszDriverVer = NULL;
	//
	// Lie about buffer size so we are always NULL terminated
	//
	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, _T("Manufacturer"), pszMfg, szDeviceSec, ARRAYSIZE(szDeviceSec) - 1));	// Driver section

	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, szDeviceSec, pszDescription, szInstallSec, ARRAYSIZE(szInstallSec) - 1));	// Install section

	CleanUpIfFailedAndSetHr(GetFirstStringField(hInf, szInstallSec, _T("DriverVer"), szValue, ARRAYSIZE(szValue) - 1));		// DriverVer

CleanUp:

	if (FAILED(hr))
	{
		//
		// if we didn't get it from the "Manufacturer" section, try the "Version" section
		//
		hr = GetFirstStringField(hInf, _T("Version"), _T("DriverVer"), szValue, MAX_PATH);
	}

	if (SUCCEEDED(hr))
	{
		if (NULL != ppszDriverVer)
		{
		    DWORD cch = (lstrlen(szValue) + 1);
			if (NULL == (*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cch * sizeof(TCHAR))))
			{
				LOG_ErrorMsg(E_OUTOFMEMORY);
				hr = E_OUTOFMEMORY;
			}
			else
			{
				// Convert to ISO 8601 format
			    hr = StringCchCopyEx(*ppszDriverVer, cch, szValue, NULL, NULL, MISTSAFE_STRING_FLAGS);
			    if (FAILED(hr))
			    {
			        LOG_ErrorMsg(hr);
			    }
			    else
			    {
				    hr = DriverVerToIso8601(ppszDriverVer);
			    }
				if (FAILED(hr))
				{
					SafeHeapFree(*ppszDriverVer);
				}
			}
		}
	}

	return hr;
}

inline bool IsDriver(LPCTSTR szFile)
{
#if defined(DBG)
	if (NULL == szFile)
	{
		return false;
	}
#endif

	LPCTSTR szExt = PathFindExtension(szFile);
	if (NULL == szExt)
	{
		return false;
	}

	static const TCHAR* aszExt[] = {
		_T(".sys"),
		_T(".dll"),
		_T(".drv"),
		_T(".vxd"),
	};
	for(int i = 0; i < ARRAYSIZE(aszExt); i ++)
	{
		if(0 == lstrcmpi(aszExt[i], szExt))
			return true;
	}
	return false;
}

static UINT CALLBACK FileQueueScanCallback(
	IN PVOID pContext,			// setup api context
	IN UINT ulNotification,		// notification message
	IN UINT_PTR ulParam1,				// extra notification message information 1
	IN UINT_PTR /*Param2*/	)		// extra notification message information 2
{
	LOG_Block("FileQueueScanCallback");

	HRESULT hr;

	if (NULL == pContext || 0 == ulParam1)
	{
		LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
		return ERROR_INVALID_PARAMETER;
	}

	if (SPFILENOTIFY_QUEUESCAN == ulNotification)
	{
		PFILETIME pftDateLatest = (PFILETIME)pContext;
		LPCTSTR szFile = (LPCTSTR)ulParam1; 
		// Is this a binary
		if (IsDriver(szFile)) 
		{
			HANDLE hFile = INVALID_HANDLE_VALUE;
			if (SUCCEEDED(hr = SafeCreateFile(&hFile, 0, szFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)))
			{
				FILETIME ft;
				if (GetFileTime(hFile, NULL, NULL, &ft))
				{
#if defined(DBG)
					SYSTEMTIME st;
 					if (FileTimeToSystemTime(&ft, &st))
					{
						LOG_Out(_T("%s : %04d-%02d-%02d"), szFile, (int)st.wYear, (int)st.wMonth, (int)st.wDay);
					}
#endif
					if (CompareFileTime(pftDateLatest, &ft) < 0)
						*pftDateLatest = ft;

				}
				else
				{
					LOG_Error(_T("GetFileTime %s"), szFile);
					LOG_ErrorMsg(GetLastError());
				}
				CloseHandle(hFile);
			}
			else
			{
				LOG_Error(_T("SafeCreateFile %s:"), szFile);
				LOG_ErrorMsg(hr);
			}
		}
		else
		{
			LOG_Out(_T("%s: not a driver"), szFile);
		}
	}

	return NO_ERROR;
}

static HRESULT LatestDriverFileTime(HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPTSTR pszMfg,
									LPTSTR pszDescription, LPTSTR pszProvider, LPCTSTR pszInfFile, LPTSTR* ppszDriverVer)
{
	LOG_Block("LatestDriverFileTime");

	HRESULT hr = S_OK;
	FILETIME ftDate = {0,0};
	HSPFILEQ hspfileq = INVALID_HANDLE_VALUE;
	SP_DEVINSTALL_PARAMS	DeviceInstallParams;

	if (INVALID_HANDLE_VALUE == hDevInfoSet ||
		NULL == pszMfg						||
		NULL == pszDescription				||
		NULL == pszProvider					||
		NULL == pszInfFile					||
		NULL == ppszDriverVer	)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	ZeroMemory(&DeviceInstallParams, sizeof(SP_DEVINSTALL_PARAMS));
	DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

	*ppszDriverVer = NULL;

	if (!SetupDiGetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		LOG_Error(_T("SetupDiGetDeviceInstallParams"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	hr = StringCchCopyEx(DeviceInstallParams.DriverPath, ARRAYSIZE(DeviceInstallParams.DriverPath),
	                     pszInfFile,
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndSetHrMsg(hr);
	
	DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;

	if (!SetupDiSetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		LOG_Error(_T("SetupDiSetDeviceInstallParams"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//Now build a class driver list from this INF.
	if (!SetupDiBuildDriverInfoList(hDevInfoSet, &devInfoData, SPDIT_CLASSDRIVER))
	{
		LOG_Error(_T("SetupDiBuildDriverInfoList"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//Prepare driver info struct
	SP_DRVINFO_DATA	DriverInfoData;
	ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
	DriverInfoData.cbSize = sizeof(DriverInfoData);
	DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
	DriverInfoData.Reserved	= 0;

	hr = StringCchCopyEx(DriverInfoData.MfgName, ARRAYSIZE(DriverInfoData.MfgName), pszMfg, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	hr = StringCchCopyEx(DriverInfoData.Description, ARRAYSIZE(DriverInfoData.Description), pszDescription, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	hr = StringCchCopyEx(DriverInfoData.ProviderName, ARRAYSIZE(DriverInfoData.ProviderName), pszProvider, 
	                     NULL, NULL, MISTSAFE_STRING_FLAGS);
    CleanUpIfFailedAndSetHrMsg(hr);

	if (!SetupDiSetSelectedDriver(hDevInfoSet, &devInfoData, (SP_DRVINFO_DATA*)&DriverInfoData))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (INVALID_HANDLE_VALUE == (hspfileq = SetupOpenFileQueue()))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Set custom queue to device install params
	if (!SetupDiGetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	DeviceInstallParams.FileQueue	 = hspfileq;
	DeviceInstallParams.Flags		|= DI_NOVCP;

	if (!SetupDiSetDeviceInstallParams(hDevInfoSet, &devInfoData, &DeviceInstallParams))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (!SetupDiInstallDriverFiles(hDevInfoSet, &devInfoData))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	// Parse the queue
	DWORD dwScanResult;
	if (!SetupScanFileQueue(hspfileq, SPQ_SCAN_USE_CALLBACK, NULL, (PSP_FILE_CALLBACK)FileQueueScanCallback, &ftDate, &dwScanResult))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	SYSTEMTIME st;
 	if (!FileTimeToSystemTime(&ftDate, &st))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (1990 > st.wYear)
	{
		//
		// Didn't enumerate any files, or files had bogus dates. Return an error so
		// we will fallback on default "0000-00-00"
		//
		hr = E_NOTIMPL;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

#if defined(DBG)
	LOG_Out(_T("%s - %s %04d-%02d-%02d"), pszMfg, pszDescription, (int)st.wYear, (int)st.wMonth, (int)st.wDay);
#endif

	CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, SIZEOF_DRIVERVER));

	// ISO 8601 prefered format (yyyy-mm-dd)
	hr = StringCbPrintfEx(*ppszDriverVer, SIZEOF_DRIVERVER, NULL, NULL, MISTSAFE_STRING_FLAGS, 
	                      _T("%04d-%02d-%02d"), (int)st.wYear, (int)st.wMonth, (int)st.wDay);
	CleanUpIfFailedAndSetHrMsg(hr);

CleanUp:

	if (INVALID_HANDLE_VALUE != hspfileq)
	{
		SetupCloseFileQueue(hspfileq);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}

//
// Called if we don't get driver date from registry
//
static HRESULT GetDriverDateFromInf(HKEY hDevRegKey, HDEVINFO hDevInfoSet, SP_DEVINFO_DATA devInfoData, LPTSTR* ppszDriverVer)
{
	LOG_Block("GetDriverDateFromInf");
	HRESULT hr;
	UINT nRet;
	HINF hInf = INVALID_HANDLE_VALUE;
	LPTSTR pszMfg = NULL;
	LPTSTR pszDescription = NULL;
	LPTSTR pszProvider = NULL;
	TCHAR szInfName[MAX_PATH + 2];
	int cchValueSize;

	if (INVALID_HANDLE_VALUE == hDevInfoSet || (HKEY)INVALID_HANDLE_VALUE == hDevRegKey || NULL == ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*ppszDriverVer = NULL;

	//
	// Get INF File name from registry, but lie about size to make sure we are NULL terminated
	//
	ZeroMemory(szInfName, sizeof(szInfName));
	CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_INFPATH, szInfName, ARRAYSIZE(szInfName)-1, &cchValueSize));

	//
	// Verify the file name ends with ".inf"
	//
	if (CSTR_EQUAL != WUCompareStringI(&szInfName[lstrlen(szInfName) - 4], _T(".inf")))
	{
		CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
	}
	//
	// Look for szInfName in %windir%\inf\ or %windir%\inf\other\
	//
	TCHAR szInfFile[MAX_PATH + 1];
	nRet = GetWindowsDirectory(szInfFile, ARRAYSIZE(szInfFile));
	if (0 == nRet || ARRAYSIZE(szInfFile) < nRet)
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), _T("inf"));
	CleanUpIfFailedAndSetHrMsg(hr);	
	
	hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), szInfName);
	CleanUpIfFailedAndSetHrMsg(hr);	
	
	if (INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL)))
	{
		nRet = GetWindowsDirectory(szInfFile, ARRAYSIZE(szInfFile));
		if (0 == nRet || ARRAYSIZE(szInfFile) < nRet)
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), _T("inf\\other"));
		CleanUpIfFailedAndSetHrMsg(hr);	

		hr = PathCchAppend(szInfFile, ARRAYSIZE(szInfFile), szInfName);
		CleanUpIfFailedAndSetHrMsg(hr);	

		if (INVALID_HANDLE_VALUE == (hInf = SetupOpenInfFile(szInfFile, NULL, INF_STYLE_WIN4, NULL)))
		{
			LOG_Driver(_T("SetupOpenInfFile %s"), szInfFile);
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}
	
	// first try to get it from inf
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDi(hDevInfoSet, devInfoData, SPDRP_MFG, &pszMfg));
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDi(hDevInfoSet, devInfoData, SPDRP_DEVICEDESC, &pszDescription));

	if (SUCCEEDED(hr = DriverVerFromInf(hInf, pszMfg, pszDescription, ppszDriverVer)))
	{
		goto CleanUp;
	}
	//
	// Try enumerating the files as last resort
	//
	CleanUpIfFailedAndSetHr(GetPropertyFromSetupDiReg(hDevInfoSet, devInfoData, REGSTR_VAL_PROVIDER_NAME, &pszProvider));

	hr = LatestDriverFileTime(hDevInfoSet, devInfoData, pszMfg, pszDescription, pszProvider, szInfFile, ppszDriverVer);

CleanUp:

	if (INVALID_HANDLE_VALUE != hInf)
	{
		SetupCloseInfFile(hInf);
	}

	SafeHeapFree(pszMfg);
	SafeHeapFree(pszDescription);
	SafeHeapFree(pszProvider);

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Add Classes helper functionality for GetSystemSpec() and CDM functions
/////////////////////////////////////////////////////////////////////////////
HRESULT AddComputerSystemClass(CXmlSystemSpec& xmlSpec)
{
	USES_IU_CONVERSION;
	LOG_Block("AddComputerSystemClass");

	HRESULT hr;
	BSTR bstrDrive = NULL;
	BSTR bstrPID = NULL;


	PIU_DRIVEINFO pDriveInfo = NULL;
	DWORD dwNumDrives;

	IU_PLATFORM_INFO iuPlatformInfo;

	ZeroMemory( &iuPlatformInfo, sizeof(iuPlatformInfo));
	CleanUpIfFailedAndSetHr( DetectClientIUPlatform(&iuPlatformInfo) );


	if( 4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion )
	{
		BOOL bPid = TRUE;
		
		if(5 == iuPlatformInfo.osVersionInfoEx.dwMajorVersion)
		{
			if( 1 > iuPlatformInfo.osVersionInfoEx.dwMinorVersion)
				bPid = FALSE;
			else if(1 == iuPlatformInfo.osVersionInfoEx.dwMinorVersion)
			{
				if(1 > iuPlatformInfo.osVersionInfoEx.wServicePackMajor)
					bPid = FALSE;
			}
		}

		if(bPid)
			GetSystemPID(bstrPID);

		//Note: Return value  is not checked because
		//Any failure to get the PID is not considered as a failure on the GetSystemSpec method
		//If the pid attribute is missing on the supported platforms  it is still considered as 
		//an invalid pid case and no items will be returned in the catalog from the server
		//if there is any error bstrPID will  be null and it will not be added to 
		//the systemspec xml
	}


	//CleanUpIfFailedAndSetHr(GetOemBstrs(bstrManufacturer, bstrModel, bstrOEMSupportURL));
	// NTRAID#NTBUG9-277070-2001/01/12-waltw IUpdate methods should return
	// HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) when Windows Update is disabled
	// Just pass -1 to AddComputerSystem()

	CleanUpIfFailedAndSetHr(xmlSpec.AddComputerSystem(iuPlatformInfo.bstrOEMManufacturer, iuPlatformInfo.bstrOEMModel,
				iuPlatformInfo.bstrOEMSupportURL, IsAdministrator(), IsWindowsUpdateDisabled(), IsAutoUpdateEnabled(), bstrPID));

	CleanUpIfFailedAndSetHr(GetLocalFixedDriveInfo(&dwNumDrives, &pDriveInfo));

	for (DWORD i = 0; i < dwNumDrives; i++)
	{
		CleanUpFailedAllocSetHrMsg(bstrDrive = SysAllocString(T2OLE((&pDriveInfo[i])->szDriveStr)));

		CleanUpIfFailedAndSetHr(xmlSpec.AddDriveSpace(bstrDrive, (&pDriveInfo[i])->iKBytes));
		
		SafeSysFreeString(bstrDrive);
	}

CleanUp:

	SafeHeapFree(pDriveInfo);
	SysFreeString(bstrDrive);
	SysFreeString(bstrPID);
	return hr;
}

HRESULT AddRegKeyClass(CXmlSystemSpec& xmlSpec)
{
	LOG_Block("AddRegKeysClass");

	HRESULT hr = S_OK;
	LONG lRet;
	HKEY hkSoftware;
	TCHAR szSoftware[MAX_PATH];
	DWORD dwcSoftware;
	DWORD dwIndex = 0;
	FILETIME ftLastWriteTime;
	BSTR bstrSoftware = NULL;
	BOOL fRegKeyOpened = FALSE;

	if (ERROR_SUCCESS != (lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SOFTWARE"), 0, KEY_READ, &hkSoftware)))
	{
		Win32MsgSetHrGotoCleanup(lRet);
	}
	else
	{
		fRegKeyOpened = TRUE;
	}

	do
	{
		dwcSoftware = MAX_PATH;
		if (ERROR_SUCCESS != (lRet = (RegEnumKeyEx(hkSoftware, dwIndex++, szSoftware, &dwcSoftware, NULL, NULL, NULL, &ftLastWriteTime))))
		{
			if (ERROR_NO_MORE_ITEMS == lRet)
			{
				break;
			}
			else
			{
				LOG_ErrorMsg(lRet);
				hr = HRESULT_FROM_WIN32(lRet);
				break;
			}
		}
		CleanUpFailedAllocSetHrMsg(bstrSoftware = T2BSTR(szSoftware));
		CleanUpIfFailedAndSetHr(xmlSpec.AddReg(bstrSoftware));
		SafeSysFreeString(bstrSoftware);

	} while (ERROR_SUCCESS == lRet);

CleanUp:

	SysFreeString(bstrSoftware);

	if (TRUE == fRegKeyOpened)
	{
		RegCloseKey(hkSoftware);
	}
	return hr;
}

HRESULT AddPlatformClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo)
{
	USES_IU_CONVERSION;
	LOG_Block("AddPlatformClass");

	HRESULT hr;
	BSTR bstrTemp = NULL;

	// NOTE: we never expect to be called on Win32s
	const TCHAR* pszPlatformName = (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId)
															? SZ_WIN32_NT : SZ_WIN32_WINDOWS;

	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(pszPlatformName));
	CleanUpIfFailedAndSetHr(xmlSpec.AddPlatform(bstrTemp));
	SafeSysFreeString(bstrTemp);

	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_PROCESSOR));
	CleanUpIfFailedAndSetHr(xmlSpec.AddProcessor(bstrTemp));
	SafeSysFreeString(bstrTemp);


	hr = xmlSpec.AddVersion(	iuPlatformInfo.osVersionInfoEx.dwMajorVersion,
								iuPlatformInfo.osVersionInfoEx.dwMinorVersion,
								iuPlatformInfo.osVersionInfoEx.dwBuildNumber,
								(sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
									? iuPlatformInfo.osVersionInfoEx.wServicePackMajor : 0,
								(sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
									? iuPlatformInfo.osVersionInfoEx.wServicePackMinor : 0
							);
	CleanUpIfFailedAndSetHr(hr);

	//
	// If we can, add Suite and Product Type
	//
	if (sizeof(OSVERSIONINFOEX) == iuPlatformInfo.osVersionInfoEx.dwOSVersionInfoSize)
	{
		//
		// Add all suites
		//
		if (VER_SUITE_SMALLBUSINESS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SMALLBUSINESS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_ENTERPRISE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_ENTERPRISE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_BACKOFFICE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_BACKOFFICE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_COMMUNICATIONS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_COMMUNICATIONS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_TERMINAL & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_TERMINAL));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_SMALLBUSINESS_RESTRICTED & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SMALLBUSINESS_RESTRICTED));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_EMBEDDEDNT & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_EMBEDDEDNT));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_DATACENTER & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_DATACENTER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_SINGLEUSERTS & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_SINGLEUSERTS));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_PERSONAL & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_PERSONAL));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		if (VER_SUITE_BLADE & iuPlatformInfo.osVersionInfoEx.wSuiteMask)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_SUITE_BLADE));
			CleanUpIfFailedAndSetHr(xmlSpec.AddSuite(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}

		//
		// Add Product Type
		//
		if (VER_NT_WORKSTATION == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_WORKSTATION));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		else if (VER_NT_DOMAIN_CONTROLLER == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_DOMAIN_CONTROLLER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		else if (VER_NT_SERVER == iuPlatformInfo.osVersionInfoEx.wProductType)
		{
			CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(SZ_NT_SERVER));
			CleanUpIfFailedAndSetHr(xmlSpec.AddProductType(bstrTemp));
			SafeSysFreeString(bstrTemp);
		}
		// else skip - there's a new one defined we don't know about
	}

CleanUp:

	SysFreeString(bstrTemp);
	return hr;
}

HRESULT AddLocaleClass(CXmlSystemSpec& xmlSpec, BOOL fIsUser)
{
	LOG_Block("AddLocaleClass");

	HRESULT hr;
	BSTR bstrTemp = NULL;
	HANDLE_NODE hLocale = HANDLE_NODE_INVALID;
	TCHAR szLang[256] = _T("");	// Usually ISO format five characters + NULL (en-US) but note exceptions
								// such as "el_IBM"

	CleanUpFailedAllocSetHrMsg(bstrTemp = SysAllocString(fIsUser ? L"USER" : L"OS"));
	CleanUpIfFailedAndSetHr(xmlSpec.AddLocale(bstrTemp, &hLocale));
	SafeSysFreeString(bstrTemp);

	LookupLocaleString((LPTSTR) szLang, ARRAYSIZE(szLang), fIsUser ? TRUE : FALSE);
	CleanUpFailedAllocSetHrMsg(bstrTemp = T2BSTR(szLang));
	CleanUpIfFailedAndSetHr(xmlSpec.AddLanguage(hLocale, bstrTemp));
	SafeSysFreeString(bstrTemp);
	xmlSpec.SafeCloseHandleNode(hLocale);

CleanUp:

	if (HANDLE_NODE_INVALID != hLocale)
	{
		xmlSpec.SafeCloseHandleNode(hLocale);
	}

	SysFreeString(bstrTemp);
	return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
//
// NOTE: Caller must clean up heap allocations made for *ppszMatchingID and *ppszDriverVer
//
////////////////////////////////////////////////////////////////////////////////////////
HRESULT GetMatchingDeviceID(HDEVINFO hDevInfoSet, PSP_DEVINFO_DATA pDevInfoData, LPTSTR* ppszMatchingID, LPTSTR* ppszDriverVer)
{
	LOG_Block("GetMatchingDeviceID");

	HKEY hDevRegKey = (HKEY) INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	if (NULL == ppszMatchingID || NULL == ppszDriverVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	OSVERSIONINFOEX verInfoEx;

	ZeroMemory(&verInfoEx, sizeof(verInfoEx));
	*ppszMatchingID = NULL;
	*ppszDriverVer = NULL;

	//
	// Get the MatchingDeviceID and DriverDate (succeedes only if driver is already installed)
	//
	if (INVALID_HANDLE_VALUE == (hDevRegKey = SetupDiOpenDevRegKey(hDevInfoSet, pDevInfoData, DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_READ)))
	{
		LOG_Driver(_T("Optional SetupDiOpenDevRegKey returned INVALID_HANDLE_VALUE"));
	}
	else
	{
		int cchValueSize = 0;
		hr = SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_MATCHINGDEVID, NULL, 0, &cchValueSize);
		if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
		{
			LOG_Driver(_T("Driver doesn't have a matching ID"));
			//
			// This is not an error
			//
			hr = S_OK;
		}
		else
		{
			//
			// Sanity check size of data in registry
			//
			if (MAX_INF_STRING_LEN < cchValueSize)
			{
				CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
			}
			//
			// MatchingDeviceID
			//
			// Add extra character of zero'ed memory for safety
			//
			CleanUpFailedAllocSetHrMsg(*ppszMatchingID = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_MATCHINGDEVID, *ppszMatchingID, cchValueSize, &cchValueSize));
			//
			// We got the matching ID, now do our best to get DriverVer (prefer from registry)
			//
			hr = SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERDATE, NULL, 0, &cchValueSize);
			if (REG_E_MORE_DATA != hr || 0 == cchValueSize)
			{
				LOG_Error(_T("No DRIVERDATE registry key, search the INF"));
				//
				// Search the INF and driver files for a date
				//
				if (FAILED(hr = GetDriverDateFromInf(hDevRegKey, hDevInfoSet, *pDevInfoData, ppszDriverVer)))
				{
					//
					// Use a default driver date
					//
					CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, SIZEOF_DRIVERVER));
                    hr = StringCbCopyEx(*ppszDriverVer, SIZEOF_DRIVERVER, SZ_UNKNOWN_DRIVERVER, 
                                        NULL, NULL, MISTSAFE_STRING_FLAGS);
                    CleanUpIfFailedAndSetHrMsg(hr);
				}
			}
			else
			{
				//
				// Sanity check size of data in registry
				//
				if (MAX_INF_STRING_LEN < cchValueSize)
				{
					CleanUpIfFailedAndSetHrMsg(E_INVALIDARG);
				}
				//
				// Get the driver date from the registry
				//
				// Add extra character of zero'ed memory for safety
				//
				CleanUpFailedAllocSetHrMsg(*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (cchValueSize + 1) * sizeof(TCHAR)));

				CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERDATE, *ppszDriverVer, cchValueSize, &cchValueSize));
				//
				// Convert to ISO 8601 format
				//
				CleanUpIfFailedAndSetHr(DriverVerToIso8601(ppszDriverVer));

#if defined(_UNICODE) || defined(UNICODE)
				//
				// 645161 Driver Ver Version to be returned to driver query.asp for WUPM 1.2 Release Timeframe
				//
				// Optionally add DriverVer version to date. NOTE: We don't attempt this unless we were able to get
				// the DriverVer date via REGSTR_VAL_DRIVERDATE. Also, this is done only for WinXP SP1 up.
				//
				verInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
				if (GetVersionEx((LPOSVERSIONINFO) &verInfoEx))
				{
					if (VER_PLATFORM_WIN32_NT == verInfoEx.dwPlatformId
						&&	(
									5 < verInfoEx.dwMajorVersion	// Longhorn
								||	(5 == verInfoEx.dwMajorVersion && 1 < verInfoEx.dwMinorVersion)	// .NET Server
								||	(5 == verInfoEx.dwMajorVersion && 1 == verInfoEx.dwMinorVersion
										&& 0 < verInfoEx.wServicePackMajor)	// WinXP with SP1 or greater
							)
						)
					{
						//
						// Attempt to get the version, but fail isn't an error
						//
						cchValueSize = 0;
						HRESULT hrVer = SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERVERSION, NULL, 0, &cchValueSize);
						if (REG_E_MORE_DATA != hrVer || 0 == cchValueSize)
						{
							LOG_Out(_T("No DRIVERVERSION registry key (optional)"));
						}
						else
						{
							TCHAR szTempVersion[MAX_INF_STRING_LEN];
							//
							// Sanity check size of data in registry
							//
							if (MAX_INF_STRING_LEN > cchValueSize)
							{
								if (S_OK == SafeRegQueryStringValueCch(hDevRegKey, REGSTR_VAL_DRIVERVERSION, (LPTSTR) szTempVersion, cchValueSize, &cchValueSize))
								{
									LPTSTR pszOldDriverVer = *ppszDriverVer;
									int nDate = lstrlen(*ppszDriverVer);
									//
									// Original DriverVer date + DriverVer Version + "|" + NULL
									//
									int nDriverDateAndVer = (nDate + cchValueSize + 2) * sizeof(TCHAR);
									*ppszDriverVer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nDriverDateAndVer);
									if (NULL == *ppszDriverVer)
									{
										//
										// Log the error, but return the DriverVer date without version appended
										//
										LOG_ErrorMsg(ERROR_NOT_ENOUGH_MEMORY);
										*ppszDriverVer = pszOldDriverVer;
									}
									else
									{
										if (SUCCEEDED(hrVer = StringCchPrintf(*ppszDriverVer, nDriverDateAndVer, _T("%s|%s"), pszOldDriverVer, (LPTSTR) szTempVersion)))
										{
											SafeHeapFree(pszOldDriverVer);
										}
										else
										{
											//
											// Restore original DriverVer date and free new alloc
											//
											LOG_ErrorMsg(hrVer);
											SafeHeapFree(*ppszDriverVer);
											*ppszDriverVer = pszOldDriverVer;
										}
									}
								}
							}
						}
					}
				}
#endif
			}
		}
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevRegKey)
	{
		RegCloseKey(hDevRegKey);
	}

	if (FAILED(hr))
	{
		SafeHeapFree(*ppszMatchingID);
		SafeHeapFree(*ppszDriverVer);
	}

	return hr;
}			


HRESULT AddDevicesClass(CXmlSystemSpec& xmlSpec, IU_PLATFORM_INFO iuPlatformInfo, BOOL fIsSysSpecCall)
{
	USES_IU_CONVERSION;
	LOG_Block("AddDevicesClass");

	HRESULT hr = E_NOTIMPL;
	LONG lRet;
	BSTR bstrProvider = NULL;
	BSTR bstrMfgName = NULL;
	BSTR bstrName = NULL;
	BSTR bstrHardwareID = NULL;
	BSTR bstrDriverVer = NULL;
	DWORD dwDeviceIndex = 0;
	HDEVINFO hDevInfoSet = INVALID_HANDLE_VALUE;
	HANDLE_NODE hPrinterDevNode = HANDLE_NODE_INVALID;
	SP_DEVINFO_DATA devInfoData;
	LPTSTR	pszMatchingID = NULL;
	LPTSTR	pszDriverVer= NULL;
	DRIVER_INFO_6* paDriverInfo6 = NULL;
	DWORD dwDriverInfoCount = 0;

	//
	// We only enumerate drivers on Win2K up or Win98 up
	//
	if (  ( (VER_PLATFORM_WIN32_NT == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion)
		  )
		  ||
		  ( (VER_PLATFORM_WIN32_WINDOWS == iuPlatformInfo.osVersionInfoEx.dwPlatformId) &&
			(	(4 < iuPlatformInfo.osVersionInfoEx.dwMajorVersion)	||
				(	(4 == iuPlatformInfo.osVersionInfoEx.dwMajorVersion) &&
					(0 < iuPlatformInfo.osVersionInfoEx.dwMinorVersion)	)	)
		  )
		)
	{
		//
		// Get array of DRIVER_INFO_6 holding info on installed printer drivers. Only allocates and returns
		// memory for appropriate platforms that have printer drivers already installed.
		//
		CleanUpIfFailedAndSetHr(GetInstalledPrinterDriverInfo((OSVERSIONINFO*) &iuPlatformInfo.osVersionInfoEx, &paDriverInfo6, &dwDriverInfoCount));

		if (INVALID_HANDLE_VALUE == (hDevInfoSet = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_PRESENT | DIGCF_ALLCLASSES)))
		{
			LOG_Error(_T("SetupDiGetClassDevs failed: 0x%08x"), GetLastError());
			return HRESULT_FROM_WIN32(GetLastError());
		}
		
		ZeroMemory(&devInfoData, sizeof(SP_DEVINFO_DATA));
		devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
		while (SetupDiEnumDeviceInfo(hDevInfoSet, dwDeviceIndex++, &devInfoData))
		{
			//
			// 656449 Controls Stops if it incounters a malformed Driver Date
			//
			// Just skip instances where getting the DriverVer returns an error
			//
			if SUCCEEDED(GetMatchingDeviceID(hDevInfoSet, &devInfoData, &pszMatchingID, &pszDriverVer))
			{
				//
				// Write the Hardware & Compatible IDs to XML
				//
				CleanUpIfFailedAndSetHr(AddPrunedDevRegProps(hDevInfoSet, &devInfoData, xmlSpec, pszMatchingID, \
													pszDriverVer, paDriverInfo6, dwDriverInfoCount, fIsSysSpecCall));
			}

			SafeHeapFree(pszMatchingID);
			SafeHeapFree(pszDriverVer);
		}
		if (ERROR_NO_MORE_ITEMS != GetLastError())
		{
				Win32MsgSetHrGotoCleanup(GetLastError());
		}
		//
		// Get the Printer "Hardware IDs" for Win2K up (already checked dwMajorVersion) & WinME
		//
		if (NULL != paDriverInfo6 && 0 != dwDriverInfoCount)
		{
			//
			// Add the driver elements for each printer driver. 
			//
			for (DWORD dwCount = 0; dwCount < dwDriverInfoCount; dwCount++)
			{
				if (   NULL == (paDriverInfo6 + dwCount)->pszHardwareID)
				{
					LOG_Driver(_T("Skiping driver with incomplete ID info"));
					continue;
				}

				//
				// Open a <device> element to write the printer info
				//
				CleanUpFailedAllocSetHrMsg(bstrProvider = T2BSTR((paDriverInfo6 + dwCount)->pszProvider));
				CleanUpFailedAllocSetHrMsg(bstrMfgName = T2BSTR((paDriverInfo6 + dwCount)->pszMfgName));
				CleanUpFailedAllocSetHrMsg(bstrName = T2BSTR((paDriverInfo6 + dwCount)->pName));
				CleanUpIfFailedAndSetHr(xmlSpec.AddDevice(NULL, 1, bstrProvider, bstrMfgName, bstrName, &hPrinterDevNode));
				//
				// Convert ftDriverDate to ISO 8601 prefered format (yyyy-mm-dd)
				//
				SYSTEMTIME systemTime;
				if (0 == FileTimeToSystemTime(&((paDriverInfo6 + dwCount)->ftDriverDate), &systemTime))
				{
					LOG_Error(_T("FileTimeToSystemTime failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				TCHAR szDriverVer[11];
				hr = StringCchPrintfEx(szDriverVer, ARRAYSIZE(szDriverVer), NULL, NULL, MISTSAFE_STRING_FLAGS,
				                       _T("%04d-%02d-%02d"), systemTime.wYear, systemTime.wMonth, systemTime.wDay);
				if (FAILED(hr))
				{
					LOG_Error(_T("wsprintf failed:"));
					LOG_ErrorMsg(GetLastError());
					SetHrAndGotoCleanUp(HRESULT_FROM_WIN32(GetLastError()));
				}

				// Always rank 0 and never fIsCompatible
				CleanUpFailedAllocSetHrMsg(bstrHardwareID = T2BSTR((paDriverInfo6 + dwCount)->pszHardwareID));
				CleanUpFailedAllocSetHrMsg(bstrDriverVer = T2BSTR(szDriverVer));
				CleanUpIfFailedAndSetHr(xmlSpec.AddHWID(hPrinterDevNode, FALSE, 0, bstrHardwareID, bstrDriverVer));
				xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
				//
				// 514009 Apparent memory leak in getting info - Getsystemspec increases memory
				// consumption as follows - approximately 32 Kb when successfully called with all
				// class types (also approximately 8 Kb on failed call to get iexplorer server context)
				//
				// T2BSTR macro calls SysAllocString()
				//
				SafeSysFreeString(bstrProvider);
				SafeSysFreeString(bstrMfgName);
				SafeSysFreeString(bstrName);
				SafeSysFreeString(bstrHardwareID);
				SafeSysFreeString(bstrDriverVer);
			}
		}
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hDevInfoSet)
	{
		if (0 == SetupDiDestroyDeviceInfoList(hDevInfoSet))
		{
			LOG_Driver(_T("Warning: SetupDiDestroyDeviceInfoList failed: 0x%08x"), GetLastError());
		}
	}

	if (HANDLE_NODE_INVALID != hPrinterDevNode)
	{
		xmlSpec.SafeCloseHandleNode(hPrinterDevNode);
	}

	SafeHeapFree(pszMatchingID);
	SafeHeapFree(pszDriverVer);
	SafeHeapFree(paDriverInfo6);

	SysFreeString(bstrProvider);
	SysFreeString(bstrMfgName);
	SysFreeString(bstrName);
	SysFreeString(bstrHardwareID);
	SysFreeString(bstrDriverVer);

	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetSystemSpec()
//
// Gets the basic system specs.
// Input:
// bstrXmlClasses - a list of requested classes in xml format, NULL BSTR if all.
//				    For example:
//						<?xml version=\"1.0\"?>
//						<classes xmlns=\"file://\\kingbird\winupddev\Slm\src\Specs\v4\systeminfoclassschema.xml\">
//							<computerSystem/>
//							<regKeys/>
//							<platform/>
//							<locale/>
//							<devices/>
//						</classes>
//					Where all of the classes are optional.
//
// Return:
// pbstrXmlDetectionResult - the detection result in xml format.
/////////////////////////////////////////////////////////////////////////////
HRESULT WINAPI CEngUpdate::GetSystemSpec(BSTR bstrXmlClasses, DWORD dwFlags, BSTR *pbstrXmlDetectionResult)
{
	USES_IU_CONVERSION;
	LOG_Block("GetSystemSpec");

	//
	// By default we return all <classes/>
	//
	DWORD dwClasses = (COMPUTERSYSTEM | REGKEYS	| PLATFORM | LOCALE | DEVICES);
	HRESULT hr = S_OK;
	IU_PLATFORM_INFO iuPlatformInfo;
	CXmlSystemSpec xmlSpec;

	if (NULL == pbstrXmlDetectionResult)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	*pbstrXmlDetectionResult = NULL;

	//
	// We have to init iuPlatformInfo (redundant) because we may goto CleanUp before calling DetectClientIUPlatform
	//
	ZeroMemory(&iuPlatformInfo, sizeof(iuPlatformInfo));

    // Set Global Offline Flag - checked by XML Classes to disable Validation (schemas are on the net)
    if (dwFlags & FLAG_OFFLINE_MODE)
    {
        m_fOfflineMode = TRUE;
    }
    else
    {
        m_fOfflineMode = FALSE;
    }

	//
	// 494519 A call to GetSystemSpec with bstrXmlClasses that is less then 10 character suceeds, weather it is valid or invalid XML.
	//
	// If client passes us anything it must be well formed [and possibly valid] XML
	//
	// But, allow BSTRs of length 0 to be treated the same as a NULL BSTR
	//     (497059 A call to GetSystemSpec with bstrXmlClasses equal
	//     to empty string fails.)
	//
	if (NULL != bstrXmlClasses && SysStringLen(bstrXmlClasses) > 0)
	{
		CXmlSystemClass xmlClass;
		if (FAILED(hr = xmlClass.LoadXMLDocument(bstrXmlClasses, m_fOfflineMode)))
		{
			//
			// They probably passed us invalid XML
			//
			goto CleanUp;
		}

		dwClasses = xmlClass.GetClasses();
	}

	

	//
	// Add the ComputerSystem node
	//

	if (dwClasses & COMPUTERSYSTEM)
	{
		CleanUpIfFailedAndSetHr(AddComputerSystemClass(xmlSpec));
	}

	//
	// Enumerate and add the Software RegKey elements
	//
	if (dwClasses & REGKEYS)
	{
		CleanUpIfFailedAndSetHr(AddRegKeyClass(xmlSpec));
	}

	//
	// We need iuPlatformInfo for both <platform> and <devices>  elements
	//
	
	if (dwClasses & (PLATFORM | DEVICES))
	{
		CleanUpIfFailedAndSetHr(DetectClientIUPlatform(&iuPlatformInfo));
	}

	//
	// Add Platform
	//
	if (dwClasses & PLATFORM)
	{
		CleanUpIfFailedAndSetHr(AddPlatformClass(xmlSpec, iuPlatformInfo));
	}

	//
	// Add Locale information
	//
	if (dwClasses & LOCALE)
	{
		//
		// OS locale
		//
		CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, FALSE));
		//
		// USER locale
		//
		CleanUpIfFailedAndSetHr(AddLocaleClass(xmlSpec, TRUE));
	}

	//
	// Add devices
	//
	if (dwClasses & DEVICES)
	{
		CleanUpIfFailedAndSetHr(AddDevicesClass(xmlSpec, iuPlatformInfo, TRUE));
	}

	

CleanUp:

	//
	// Only return S_OK for success (S_FALSE sometimes drops through from above)
	//
	if (S_FALSE == hr)
	{
		hr = S_OK;
	}

	if (SUCCEEDED(hr))
	{
		//
		// Return the spec as a BSTR
		//
		hr = xmlSpec.GetSystemSpecBSTR(pbstrXmlDetectionResult);
	}

	if (SUCCEEDED(hr))
	{
		LogMessage(SZ_GET_SYSTEM_SPEC);
	}
	else
	{
		LogError(hr, SZ_GET_SYSTEM_SPEC);
		//
		// If the DOM allocates but returns error, we will leak, but
		// this is safer than calling SysFreeString()
		//
		*pbstrXmlDetectionResult = NULL;
	}

	SysFreeString(iuPlatformInfo.bstrOEMManufacturer);
	SysFreeString(iuPlatformInfo.bstrOEMModel);
	SysFreeString(iuPlatformInfo.bstrOEMSupportURL);

	return hr;
}



// Function name	: GetSystemPID
// Description	    : This method basically obtaing the encrypted version of the System PID
// This method also converts the binary blob in to string format
// Return type		: HRESULT 
// Argument         : BSTR &bstrPID  --containg the hex encoded string
// author			:a-vikuma



HRESULT GetSystemPID(BSTR &bstrPID)
{

	LOG_Block("GetSystemPID");

	HRESULT hr = S_OK;
	HMODULE hLicDll = NULL;
	PFUNCGetEncryptedPID pPIDEncrProc = NULL;
	
	BYTE *pByte = NULL;
	DWORD dwLen = 0;
	
	LPWSTR 	lpszData = NULL;
	

	if(bstrPID)
	{
		bstrPID = NULL;
	}


	//load the pid encryption library
	hLicDll = LoadLibraryFromSystemDir(SZ_LICDLL);

	if (!hLicDll)
    { 
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanUp;
    }

	//get the pointer to GetEncryptedPID method 
	pPIDEncrProc = (PFUNCGetEncryptedPID)GetProcAddress(hLicDll, lpszIVLK_GetEncPID);

	if (!pPIDEncrProc)
    { 
		hr = HRESULT_FROM_WIN32(GetLastError());
        goto CleanUp;
    }

	CleanUpIfFailedAndSetHrMsg(pPIDEncrProc(&pByte, &dwLen));
	
	
	DWORD dwSize = 0;
	

	//convert the binary stream to string format
	//initially get the length for the string buffer
	CleanUpIfFailedAndSetHrMsg(BinaryToString(pByte, dwLen, lpszData, &dwSize));

	//allocate memory
	CleanUpFailedAllocSetHrMsg( lpszData = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize*sizeof(WCHAR)));

	//get the binary blob in string format
	CleanUpIfFailedAndSetHrMsg(BinaryToString(pByte, dwLen, lpszData, &dwSize));

	//convert the LPWSTR to a BSTR
	CleanUpFailedAllocSetHrMsg(bstrPID = SysAllocString(lpszData));

	
CleanUp:

	if(hLicDll)
		FreeLibrary(hLicDll);

	SafeHeapFree(lpszData);

	//LocalFree can take nulls. So not checked if pByte is null
	LocalFree(pByte);

	if(FAILED(hr))
	{
	
		SysFreeString(bstrPID);
		bstrPID = NULL;
	
	}
	return hr;

}


// Function name	: HexEncode
// Description	    : This is a helper function to convert a binary stream in to string format
// Return type		: DWORD 
// Argument         : IN BYTE const *pbIn
// Argument         : DWORD cbIn
// Argument         : WCHAR *pchOut
// Argument         : DWORD *pcchOut

DWORD HexEncode(IN BYTE const *pbIn, DWORD cbIn, WCHAR *pchOut, DWORD *pcchOut)
{
    WCHAR *pszsep;
    WCHAR *psznl;
    DWORD nCount;
    DWORD cbremain;
    DWORD cchOut = 0;

	//each byte needs two characters for encoding
    DWORD cch = 2;
    WCHAR *pch = pchOut;
    DWORD dwErr = ERROR_INSUFFICIENT_BUFFER;
	
    DWORD dwRem = *pcchOut;


	HRESULT hr = S_OK;
   
    for (nCount = 0; nCount < cbIn; nCount ++)
    {
		if (NULL != pchOut)
		{
			if (cchOut + cch + 1 > *pcchOut)
			{
				goto ErrorReturn;
			}
			hr = StringCchPrintfW(pch, dwRem, L"%02x", pbIn[nCount]);
			if(FAILED(hr))
			{
				dwErr = HRESULT_CODE(hr);
				goto ErrorReturn;
			}
			pch += cch;
			dwRem -= cch;
		}
		cchOut += cch;
    }
  
	if (NULL != pchOut)
	{

		*pch = L'\0';

	}

    *pcchOut = cchOut+1;
    dwErr = ERROR_SUCCESS;

ErrorReturn:
    return(dwErr);
}



// Function name	: BinaryToString
// Description	    : This function converts a binary stream in to a string format
// Return type		: HRESULT 
// Argument         : BYTE *lpBinary --The binary stream
// Argument         : DWORD dwLength --The length of the stream
// Argument         : LPWSTR lpString --Pointer to the string which contains the converted encoded data on return
// If this parameter is NULL the DWORD pointed ny pdwLength parameter contains to the size of the buffer needed to hold
// the encoded data
// Argument         : DWORD *pdwLength --pointer to the zise of the string buffer in no of characters


HRESULT BinaryToString(BYTE *lpBinary, DWORD dwLength, LPWSTR lpString, DWORD *pdwLength)
{

	HRESULT hr = S_OK;

	if(!lpBinary || !pdwLength)
		return E_INVALIDARG;

	DWORD dwStatus = HexEncode(lpBinary, dwLength, lpString, pdwLength);

	if(ERROR_SUCCESS != dwStatus)
	{
		hr = HRESULT_FROM_WIN32(dwStatus);

	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\v3applog.h ===
//=======================================================================
//
//  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    v3applog.h
//
//  Purpose: Reading WindowsUpdate V3 history logging 
//
//  History: 22-Feb-99   YAsmi    Created
//			 02-May-01   JHou	  Modified
//
//=======================================================================

#ifndef _APPLOG_H_
#define _APPLOG_H_

#define LOG_FIELD_SEPARATOR    "|"


class CV3AppLog
{
public:
	CV3AppLog(LPCTSTR pszLogFileName = NULL);    
	~CV3AppLog();

	void SetLogFile(LPCTSTR pszLogFileName);

	//
	// reading
	//
	void StartReading();
	BOOL ReadLine();
	BOOL CopyNextField(LPSTR pszBuf, int cBufSize);
	void StopReading();

private:
	void CheckBuf(DWORD dwSize);

	LPTSTR m_pszLogFN;

	LPSTR m_pFileBuf;
	LPSTR m_pFieldBuf;
	LPSTR m_pLine;

	DWORD m_dwFileSize;
	DWORD m_dwBufLen;
	DWORD m_dwFileOfs;
};

#endif // _APPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\v3applog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-1999 Microsoft Corporation.  All Rights Reserved.
//
//  File:    v3applog.cpp
//
//  Purpose: Reading WindowsUpdate V3 history logging 
//
//  History: 22-Feb-99   YAsmi    Created
//			 02-May-01   JHou	  Modified
//
//=======================================================================

#include "iuengine.h"
#include <iucommon.h>
#include "v3applog.h"


//
// CV3AppLog class
//


//--------------------------------------------------------------------------------
// CV3AppLog::CV3AppLog
//
// if the pszLogFileName=NULL, then the caller must set the log file name by
// calling SetLogFile before using
//--------------------------------------------------------------------------------
CV3AppLog::CV3AppLog(LPCTSTR pszLogFileName) :
	m_pFileBuf(NULL),
	m_pFieldBuf(NULL),
	m_pLine(NULL),
	m_dwFileSize(0),
	m_dwBufLen(0),
	m_dwFileOfs(0)
{
	m_pszLogFN = NULL;
	SetLogFile(pszLogFileName);
}


//--------------------------------------------------------------------------------
// CV3AppLog::~CV3AppLog
//
// free resources
//--------------------------------------------------------------------------------
CV3AppLog::~CV3AppLog()
{
	SafeHeapFree(m_pszLogFN);
	SafeHeapFree(m_pFileBuf);
	SafeHeapFree(m_pFieldBuf);
}


//--------------------------------------------------------------------------------
// CV3AppLog::CheckBuf
//
// allocates the internal buffer to be atleast dwSize big.  Does not do anything
// if the the buffer is already big enough
//--------------------------------------------------------------------------------
void CV3AppLog::CheckBuf(DWORD dwSize)
{
	if (m_dwBufLen >= dwSize)
		return;

	SafeHeapFree(m_pFieldBuf);

	m_dwBufLen = dwSize + 16;   
    m_pFieldBuf = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwBufLen);
}


//--------------------------------------------------------------------------------
// CV3AppLog::SetLogFile
//
// sets the log file name.  Use this function if you did not specify the file name
// in the ctor
//--------------------------------------------------------------------------------
void CV3AppLog::SetLogFile(LPCTSTR pszLogFileName)
{
	SafeHeapFree(m_pszLogFN);
	
	if (pszLogFileName != NULL)
	{
		m_pszLogFN = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, MAX_PATH * sizeof (TCHAR));
		if (NULL != m_pszLogFN)
		{
		    HRESULT hr;

		    hr = StringCchCopyEx(m_pszLogFN, MAX_PATH, pszLogFileName, NULL, NULL, MISTSAFE_STRING_FLAGS);
		    if (FAILED(hr))
		    {
		        SafeHeapFree(m_pszLogFN);
		        m_pszLogFN = NULL;
		    }
		}
	}
}


//--------------------------------------------------------------------------------
// CV3AppLog::StartReading
//
// Reads the entire log in memory so we can read lines.  Following is an example:
//
//		CV3AppLog V3His("C:\\wuhistv3.log");
//		V3His.StartReading();
//		while (V3His.ReadLine())
//			// do something;
//		V3His.StopReading();
//--------------------------------------------------------------------------------
void CV3AppLog::StartReading()
{
	if (NULL != m_pszLogFN)
	{
		m_dwFileSize = 0;
		m_dwFileOfs = 0;
		SafeHeapFree(m_pFileBuf);

		HANDLE hFile = CreateFile(m_pszLogFN, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			return;

		m_dwFileSize = GetFileSize(hFile, NULL);
		if (m_dwFileSize >0)
		{
			m_pFileBuf = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, m_dwFileSize+1);
			if (NULL == m_pFileBuf)
			{
				m_dwFileSize = 0;
			}
			else
			{
				DWORD dwBytes;
				if (!ReadFile(hFile, m_pFileBuf, m_dwFileSize, &dwBytes, NULL) || dwBytes != m_dwFileSize)
				{
					SafeHeapFree(m_pFileBuf);
					m_dwFileSize = 0;
				}
			}
		}

		CloseHandle(hFile);
	}
}


//--------------------------------------------------------------------------------
// CV3AppLog::ReadLine
//
// reads a line from the memory buffer where the entire file was loaded
// moves the internal pointer to the next line. 
//--------------------------------------------------------------------------------
BOOL CV3AppLog::ReadLine()
{
	DWORD dwOrgOfs; 
	
	if (m_dwFileSize == 0 || m_dwFileOfs >= m_dwFileSize || (NULL == m_pFileBuf))
		return FALSE;

	// setup the start of field parsing
	m_pLine = &m_pFileBuf[m_dwFileOfs];

	dwOrgOfs = m_dwFileOfs;
	while (m_dwFileOfs < m_dwFileSize && m_pFileBuf[m_dwFileOfs] != '\r')
		m_dwFileOfs++;

	if ((m_dwFileOfs - dwOrgOfs) > 2048)
	{
		// self imposed limit of 2048 chars in a line
		// we consider a file with a longer line of text an invalid log file
		m_dwFileOfs	= m_dwFileSize;
		m_pLine = NULL;
		return FALSE;
	}

	// this is where we have the \r (13), we replace it with a 0 to create
	// end of string here
	m_pFileBuf[m_dwFileOfs] = '\0';

	// point the ofset to next line
	m_dwFileOfs += 2;

	// allocate enough memory to parse out fields when CopyNextField is called
	CheckBuf(m_dwFileOfs - dwOrgOfs - 2);
	if (NULL == m_pFieldBuf)
	{
		return FALSE;
	}
	return TRUE;
}


//--------------------------------------------------------------------------------
// CV3AppLog::CopyNextField
//
// parses out the current line separated by the LOG_FIELD_SEPARATOR
// and copies the string to pszBuf upto cBufSize long field and moves internal 
// pointer to next field.  When the end of line is reached, returns a blank string
// 
// RETURNS: TRUE if more fields are left, FALSE otherwise
//
// NOTES: Once you get a field you cannot get it again.  
//--------------------------------------------------------------------------------
BOOL CV3AppLog::CopyNextField(LPSTR pszBuf, int cBufSize)
{
	BOOL bMoreFields = FALSE;

	if (m_pLine == NULL || *m_pLine == '\0')
	{
		//there are no more fields 
		m_pFieldBuf[0] = '\0';
		m_pLine = NULL;
	}
	else
	{
		LPCSTR p = strstr(m_pLine, LOG_FIELD_SEPARATOR);
		if (p != NULL)
		{
		    DWORD cch;  

            // this will fail if the size of the field is > 4GB.  But it should be
            //  very unlikely that this will ever happen...
		    cch = (DWORD)(DWORD_PTR)(p - m_pLine);
		    if (cch >= m_dwBufLen)
		        cch = m_dwBufLen - 1;
		    
			// copy the field to buffer but there are still more fields

            // this is safe because we made sure above that the max amount of data
            //  copied will be ARRAYSIZE(buffer) - 1 giving us room for the NULL at the end
			CopyMemory(m_pFieldBuf, m_pLine, cch * sizeof(m_pFieldBuf[0]));
			m_pFieldBuf[cch] = '\0';
			m_pLine = const_cast<LPSTR>(p + strlen(LOG_FIELD_SEPARATOR));
			bMoreFields = TRUE;
		}
		else
		{
			// this is the last field, there are no more fields

			// don't care if this fails- it will always truncate the string which is
			//  exactly what we want
			(void)StringCchCopyExA(m_pFieldBuf, m_dwBufLen, m_pLine, NULL, NULL, MISTSAFE_STRING_FLAGS);
			m_pLine = NULL;
		}
	}

	// don't care if this fails- it will always truncate the string which is exactly what 
	//  we want
    (void)StringCchCopyExA(pszBuf, cBufSize, m_pFieldBuf, NULL, NULL, MISTSAFE_STRING_FLAGS);

	return bMoreFields;
}


//--------------------------------------------------------------------------------
// CV3AppLog::StopReading
//
// free up memory from allocated in StartReading
//--------------------------------------------------------------------------------
void CV3AppLog::StopReading()
{
	SafeHeapFree(m_pFileBuf);
	m_dwFileSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\main.asm ===
PAGE 58,132
;******************************************************************************
TITLE main.asm - WindowsUpdate BIOS Scanning VxD
;******************************************************************************
;
;   Title:	main.asm - WindowsUpdate BIOS Scanning VxD
;
;  Author:     Yan Leshinsky (YanL)
;  Created     10/04/98
;
;  MODIFICATION HISTORY
;
;
;  DESCRIPTION:
;
;******************************************************************************


	.386p

;******************************************************************************
;			      I N C L U D E S
;******************************************************************************

	.XLIST
	INCLUDE vmm.inc
	.LIST


;******************************************************************************
;		 V I R T U A L	 D E V I C E   D E C L A R A T I O N
;******************************************************************************

Declare_Virtual_Device WUBIOS, 1, 0, WUBIOS_Control, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER


VXD_LOCKED_CODE_SEG

;******************************************************************************
;
;   WUBIOS_Control
;
;   DESCRIPTION:
;	Control procedure for device driver.
;
;   ENTRY:
;	EAX = Control call ID
;
;   EXIT:
;	If carry clear then
;	    Successful
;	else
;	    Control call failed
;
;   USES:
;	EAX, EBX, ECX, EDX, ESI, EDI, Flags
;
;==============================================================================

BeginProc WUBIOS_Control

	Control_Dispatch W32_DEVICEIOCONTROL, WUBIOS_IOCtrl, sCall, <esi>
IFDEF DEBUG
	Control_Dispatch DEBUG_QUERY, WUBIOS_Debug, sCall
ENDIF
	clc
	ret

EndProc WUBIOS_Control

VXD_LOCKED_CODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\debug.c ===
/*** debug.c - Debug functions
 *
 *  This module contains all the debug functions.
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 *	10/06/98		YanL		Modified to be used in WUBIOS.VXD
*/

#include "wubiosp.h"

//Miscellaneous Constants
#ifdef TRACING
#define MAX_TRIG_PTS            10
#define MAX_TRIGPT_LEN          31
#define TF_TRIG_MODE            0x00000001
#endif

//Local function prototypes
#ifdef TRACING
VOID CM_LOCAL TraceIndent(VOID);
BOOL CM_LOCAL IsTrigPt(char *pszProcName);
PCHAR CM_LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr);
VOID CM_INTERNAL DebugSetTraceLevel(VOID);
VOID CM_INTERNAL DebugToggleTrigMode(VOID);
VOID CM_INTERNAL DebugClearTrigPts(VOID);
VOID CM_INTERNAL DebugAddTrigPt(VOID);
VOID CM_INTERNAL DebugZapTrigPt(VOID);
PCHAR CM_LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper);
#endif

//Local Data
#ifdef TRACING
#pragma CM_DEBUG_DATA
int giTraceLevel = 3, giIndent = 0;
char aszTrigPtBuff[MAX_TRIG_PTS][MAX_TRIGPT_LEN + 1] = {0};
DWORD dwfTrace = 0, dwcTriggers = 0;
#endif

#ifdef DEBUGGER
#pragma CM_DEBUG_DATA
CMDDC DebugCmds[] =
{
  #ifdef TRACING
    {'t', DebugSetTraceLevel,  "set Trace level     ", "Set Trace Level"},
    {'g', DebugToggleTrigMode, "toGgle trigger mode ", "Toggle Trace Trigger mode"},
    {'x', DebugClearTrigPts,   "clear trigger points", "Clear all trace trigger points"},
    {'y', DebugAddTrigPt,      "add trigger point   ", "Add a trace trigger point"},
    {'z', DebugZapTrigPt,      "Zap trigger point   ", "Delete a trace trigger point"},
  #endif
    {'q', NULL,                "Quit                ", "Quit the debugger"},
    {'\0'}
};
#endif  //ifdef DEBUGGER

#ifdef TRACING
#pragma CM_DEBUG_DATA
#pragma CM_DEBUG_CODE
/***LP  TraceIndent - Indent trace output
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_LOCAL TraceIndent(VOID)
{
    int i;

    CMDD(WARNNAME ":");
    for (i = 0; i < giIndent; i++)
    {
        CMDD("..");
    }
}       //TraceIndent

/***LP  IsTraceOn - Determine if tracing is on for the given procedure
 *
 *  ENTRY
 *      n - trace level
 *      pszProcName -> procedure name
 *      fEnter - TRUE if EnterProc trace
 *
 *  EXIT-SUCCESS
 *      returns TRUE
 *  EXIT-FAILURE
 *      returns FALSE
 */

BOOL CM_LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter)
{
    BOOL rc = FALSE;

    if ((dwfTrace & TF_TRIG_MODE) && IsTrigPt(pszProcName))
    {
        if (fEnter)
            dwcTriggers++;
        else
            dwcTriggers--;
        rc = TRUE;
    }
    else if ((n <= giTraceLevel) &&
             (!(dwfTrace & TF_TRIG_MODE) || (dwcTriggers > 0)))
    {
        rc = TRUE;
    }

    if (rc == TRUE)
        TraceIndent();

    return rc;
}       //IsTraceOn

/***LP  IsTrigPt - Find the procedure name in the TrigPt buffer
 *
 *  ENTRY
 *      pszProcName -> procedure name
 *
 *  EXIT-SUCCESS
 *      returns TRUE - matched whole or partial name in the TrigPt buffer
 *  EXIT-FAILURE
 *      returns FALSE - no match
 */

BOOL CM_LOCAL IsTrigPt(char *pszProcName)
{
    BOOL rc = FALSE;
    BYTE i;

    for (i = 0; (rc == FALSE) && (i < MAX_TRIG_PTS); ++i)
    {
        if (InStr(pszProcName, &aszTrigPtBuff[i][0]) != NULL)
            rc = TRUE;
    }

    return rc;
}       //IsTrigPt

/***LP  InStr - Match a sub-string in a given string
 *
 *  ENTRY
 *      pszStr -> string
 *      pszSubStr -> sub-string
 *
 *  EXIT-SUCCESS
 *      returns pointer to the string where the substring is found
 *  EXIT-FAILURE
 *      returns NULL
 */

PCHAR CM_LOCAL InStr(PCHAR pszStr, PCHAR pszSubStr)
{
    PCHAR psz = NULL;
    BYTE bcStrLen = (BYTE)_lstrlen(pszStr);
    BYTE bcSubStrLen = (BYTE)_lstrlen(pszSubStr);

    _asm
    {
        cld
        mov edi,pszStr

    Next:
        mov esi,pszSubStr
        movzx ecx,BYTE PTR bcStrLen
        lodsb
        repne scasb
        jnz NotFound

        movzx ecx,BYTE PTR bcSubStrLen
        repe cmpsb
        jne Next

        movzx ecx,BYTE PTR bcSubStrLen
        sub edi,ecx
        mov psz,edi

    NotFound:
    }

    return psz;
}       //InStr
#endif  //ifdef TRACING

#ifdef DEBUGGER
#pragma CM_DEBUG_DATA
#pragma CM_DEBUG_CODE
/***EP  WUBIOS_Debug - Debugger entry point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_SYSCTRL WUBIOS_Debug(VOID)
{
    CMDMenu(WARNNAME, DebugCmds);
}       //WUBIOS_Debug

#ifdef TRACING
/***LP  DebugSetTraceLevel - Set Trace Level
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugSetTraceLevel(VOID)
{
    CMDD("\n");
    giTraceLevel = (int)CMDReadNumber("Trace Level", 1, FALSE);
    CMDD("\n\n");
}       //DebugSetTraceLevel

/***LP  DebugToggleTrigMode - Toggle Trace Trigger mode
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugToggleTrigMode(VOID)
{
    dwfTrace ^= TF_TRIG_MODE;
    if (!(dwfTrace & TF_TRIG_MODE))
        dwcTriggers = 0;
    CMDD("\nTrace Trigger Mode is %s\n\n",
         (dwfTrace & TF_TRIG_MODE)? "On": "Off");
}       //DebugToggleTrigMode

/***LP  DebugClearTrigPts - Clear all trace trigger points
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugClearTrigPts(VOID)
{
    BYTE i;

    for (i = 0; i < MAX_TRIG_PTS; ++i)
        aszTrigPtBuff[i][0] = '\0';

    CMDD("\n");
}       //DebugClearTrigPts

/***LP  DebugAddTrigPt - Add a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugAddTrigPt(VOID)
{
    char szTrigPt[MAX_TRIGPT_LEN + 1];
    BYTE i;

    CMDD("\n");
    GetString("Trigger Point", szTrigPt, sizeof(szTrigPt), TRUE);
    CMDD("\n");
    for (i = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] == '\0')
        {
            _lstrcpyn(aszTrigPtBuff[i], szTrigPt, MAX_TRIGPT_LEN + 1);
            break;
        }
    }

    if (i == MAX_TRIG_PTS)
        CMDD("No free trigger point.\n");

    CMDD("\n");
}       //DebugAddTrigPt

/***LP  DebugZapTrigPt - Delete a trace trigger point
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL DebugZapTrigPt(VOID)
{
    BYTE i, bcTrigPts;

    CMDD("\n");
    for (i = 0, bcTrigPts = 0; i < MAX_TRIG_PTS; ++i)
    {
        if (aszTrigPtBuff[i][0] != '\0')
        {
            CMDD("%2d: %s\n", i, &aszTrigPtBuff[i][0]);
            bcTrigPts++;
        }
    }

    if (bcTrigPts > 0)
    {
        CMDD("\n");
        i = (BYTE)CMDReadNumber("Trigger Point", 1, FALSE);
        CMDD("\n");

        if ((i < MAX_TRIG_PTS) && (aszTrigPtBuff[i][0] != '\0'))
            aszTrigPtBuff[i][0] = '\0';
        else
            CMDD("Invalid Trace Trigger Point.\n");
    }
    else
        CMDD("No Trace Trigger Point set.\n");

    CMDD("\n");
}       //DebugZapTrigPt

/***LP  GetString - Read a string from the debug terminal
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> buffer to hold the string
 *      bcLen - buffer length
 *      fUpper - TRUE if convert to upper case
 *
 *  EXIT
 *      always returns pszBuff
 */

PCHAR CM_LOCAL GetString(PCHAR pszPrompt, PCHAR pszBuff, BYTE bcLen, BOOL fUpper)
{
    BYTE i, ch;

    CMDD("%s: ", pszPrompt);
    for (i = 0; i < bcLen - 1; ++i)
    {
        ch = CMDInChar();

        if ((ch == '\r') || (ch == '\n'))
            break;
        else if (ch == '\b')
        {
            if (i > 0)
                i -= 2;
        }
        else if (fUpper && (ch >= 'a') && (ch <= 'z'))
            pszBuff[i] = (BYTE)(ch - 'a' + 'A');
        else if ((ch < ' ') || (ch > '~'))
        {
            ch = '\a';          //change it to a BELL character
            i--;                //don't store it
        }
        else
            pszBuff[i] = ch;

        CMDD("%c", ch);
    }
    pszBuff[i] = '\0';

    return pszBuff;
}       //GetString
#endif  //ifdef TRACING
#endif  //ifdef DEBUGGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\acpi.c ===
/*** acpi.c - ACPI VXD to provide table access IOCTLs
 *
 *  Author:     Michael Tsang (MikeTs)
 *  Created     10/08/97
 *
 *  MODIFICATION HISTORY
 *	10/06/98		YanL		Modified to be used in WUBIOS.VXD
 */

#include "wubiosp.h"

/*** Function prototypes
 */

PRSDT CM_LOCAL FindRSDT(DWORD* pdwRSDTAddr);
BYTE CM_LOCAL CheckSum(PBYTE pb, DWORD dwLen);
#ifdef TRACING
PSZ CM_LOCAL SigStr(DWORD dwSig);
#endif

#pragma CM_PAGEABLE_DATA
#pragma CM_PAGEABLE_CODE


/***LP  FindRSDT - Find the RSDT
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the RSDT pointer
 *  EXIT-FAILURE
 *      returns NULL
 */

PRSDT CM_LOCAL FindRSDT(DWORD* pdwRSDTAddr)
{
    TRACENAME("FINDRSDT")
    PRSDT pRSDT = NULL;
    PBYTE pbROM;

    ENTER(2, ("FindRSDT()\n"));

    if ((pbROM = (PBYTE)_MapPhysToLinear(RSDP_SEARCH_RANGE_BEGIN,
                                         RSDP_SEARCH_RANGE_LENGTH, 0)) !=
        (PBYTE)0xffffffff)
    {
        PBYTE pbROMEnd;
        DWORD dwRSDTAddr = 0;

        pbROMEnd = pbROM + RSDP_SEARCH_RANGE_LENGTH - RSDP_SEARCH_INTERVAL;
        while (pbROM != NULL)
        {
            if ((((PRSDP)pbROM)->Signature == RSDP_SIGNATURE) &&
                (CheckSum(pbROM, sizeof(RSDP)) == 0))
            {
                dwRSDTAddr = ((PRSDP)pbROM)->RsdtAddress;
                if (((pbROM = (PBYTE)_MapPhysToLinear(dwRSDTAddr,
                                                      sizeof(DESCRIPTION_HEADER),
                                                      0)) ==
                     (PBYTE)0xffffffff) ||
                    (((PDESCRIPTION_HEADER)pbROM)->Signature != RSDT_SIGNATURE))
                {
                    pbROM = NULL;
                }
                break;
            }
            else
            {
                pbROM += RSDP_SEARCH_INTERVAL;
                if (pbROM > pbROMEnd)
                {
                    pbROM = NULL;
                }
            }
        }

        if (pbROM != NULL)
        {
            DWORD dwLen = ((PDESCRIPTION_HEADER)pbROM)->Length;

            pRSDT = (PRSDT)_MapPhysToLinear(dwRSDTAddr, dwLen, 0);
            if ((pRSDT == (PRSDT)0xffffffff) ||
                (CheckSum((PBYTE)pRSDT, dwLen) != 0))
            {
                pRSDT = NULL;
            }
			*pdwRSDTAddr = dwRSDTAddr;
        }
    }

    EXIT(2, ("FindRSDT=%x\n", pRSDT));
    return pRSDT;
}       //FindRSDT

/***LP  AcpiFindTable - Find an ACPI Table
 *
 *  ENTRY
 *      dwSig - signature of the table
 *      pdwLen -> to hold length of table (can be NULL)
 *
 *  EXIT-SUCCESS
 *      returns physical address of table
 *  EXIT-FAILURE
 *      returns 0
 */

DWORD CM_INTERNAL AcpiFindTable(DWORD dwSig, PDWORD pdwLen)
{
    TRACENAME("AcpiFindTable")
    DWORD dwPhyAddr = 0;
    static PRSDT pRSDT = (PRSDT)0xffffffff;
    static DWORD dwRSDTAddr;

    ENTER(2, ("AcpiFindTable(Sig=%s,pdwLen=%x)\n", SigStr(dwSig), pdwLen));

    if (pRSDT == (PRSDT)0xffffffff)
    {
        pRSDT = FindRSDT(&dwRSDTAddr);
    }

    if (pRSDT != NULL)
    {
        PDESCRIPTION_HEADER pdh = NULL;

        if (dwSig == RSDT_SIGNATURE)
		{
			*pdwLen = ((PDESCRIPTION_HEADER)pRSDT)->Length;
			dwPhyAddr = dwRSDTAddr;
		}
        else if (dwSig == DSDT_SIGNATURE)
        {
            DWORD dwLen;
            PFADT pFADT;

            if (((dwPhyAddr = AcpiFindTable(FADT_SIGNATURE, &dwLen)) != 0) &&
                ((pFADT = (PFADT)_MapPhysToLinear(dwPhyAddr, dwLen, 0)) !=
                 (PFADT)0xffffffff))
            {
                dwPhyAddr = pFADT->dsdt;
                if ((pdh = (PDESCRIPTION_HEADER)_MapPhysToLinear(
                                                    dwPhyAddr,
                                                    sizeof(DESCRIPTION_HEADER),
                                                    0)) ==
                    (PDESCRIPTION_HEADER)0xffffffff)
                {
                    dwPhyAddr = 0;
                }
            }
            else
            {
                dwPhyAddr = 0;
            }
        }
        else
        {
            int i, iNumTables = NumTableEntriesFromRSDTPointer(pRSDT);

            for (i = 0; i < iNumTables; ++i)
            {
                dwPhyAddr = pRSDT->Tables[i];
                if (((pdh = (PDESCRIPTION_HEADER)_MapPhysToLinear(
                                                    dwPhyAddr,
                                                    sizeof(DESCRIPTION_HEADER),
                                                    0)) 
					!= (PDESCRIPTION_HEADER)0xffffffff))
				{
					if (pdh->Signature == dwSig && (CheckSum((PBYTE)pdh, pdh->Length) == 0) )
					{
						break;
					}
                }
            }

            if (i >= iNumTables)
            {
                dwPhyAddr = 0;
            }
        }

        if ((dwPhyAddr != 0) && (pdwLen != NULL))
        {
            *pdwLen = pdh->Length;
        }
    }

    EXIT(2, ("AcpiFindTable=%x (Len=%x)\n", dwPhyAddr, pdwLen? *pdwLen: 0));
    return dwPhyAddr;
}       //AcpiFindTable

/***LP  AcpiCopyROM - Copy ROM memory to buffer
 *
 *  ENTRY
 *      dwPhyAddr - physical address of ROM location
 *      pbBuff -> buffer
 *      dwLen - buffer length
 *
 *  EXIT
 *      None
 */

VOID CM_INTERNAL AcpiCopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen)
{
    TRACENAME("AcpiCopyROM")
    PBYTE pbROM;

    ENTER(2, ("AcpiCopyROM(PhyAddr=%x,pbBuff=%x,Len=%x)\n",
              dwPhyAddr, pbBuff, dwLen));

    if ((pbROM = (PBYTE)_MapPhysToLinear(dwPhyAddr, dwLen, 0)) !=
        (PBYTE)0xffffffff)
    {
        memcpy(pbBuff, pbROM, dwLen);
    }

    EXIT(2, ("AcpiCopyROM!\n"));
}       //AcpiCopyROM

#ifdef TRACING
/***LP  SigStr - return string of DWORD signature
 *
 *  ENTRY
 *      dwSig - signature
 *
 *  EXIT
 *      returns signature string
 */

PSZ CM_LOCAL SigStr(DWORD dwSig)
{
    static char szSig[sizeof(DWORD) + 1] = {0};

    memcpy(szSig, &dwSig, sizeof(DWORD));

    return (PSZ)szSig;
}       //SigStr
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\control.c ===
/*** control.c - System Control Message Support
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "wubiosp.h"

#pragma CM_PAGEABLE_DATA
#pragma CM_PAGEABLE_CODE

/***EP  WUBIOS_IOCtrl - Win32 Device IO Control entry point
 *
 *  ENTRY
 *      pioc -> DIOC structure
 *
 *  EXIT-SUCCESS
 *      returns ERROR_SUCCESS
 *  EXIT-FAILURE
 *      returns ERROR_*
 */

CM_VXD_RESULT CM_SYSCTRL WUBIOS_IOCtrl(PDIOCPARAMETERS pdioc)
{
    TRACENAME("WUBIOS_IOCtrl")
    CM_VXD_RESULT rc = ERROR_SUCCESS;

    ENTER(1, ("WUBIOS_IOCtrl(hVM=%lx,hDev=%lx,Code=%lx)\n",
              pdioc->VMHandle, pdioc->hDevice, pdioc->dwIoControlCode));

    switch (pdioc->dwIoControlCode)
    {
        case WUBIOCTL_GET_VERSION:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetVersion"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PVMMDDB pddb = (PVMMDDB)pdioc->Internal2;

                *((PDWORD)pdioc->lpvOutBuffer) =
                    (pddb->DDB_Dev_Major_Version << 8) |
                    pddb->DDB_Dev_Minor_Version;

                if (pdioc->lpcbBytesReturned != NULL)
                    *((PDWORD)pdioc->lpcbBytesReturned) = sizeof(DWORD);
            }
            break;
        case WUBIOCTL_GET_ACPI_TABINFO:
            if ((pdioc->lpvOutBuffer == NULL) ||
                (pdioc->cbOutBuffer != sizeof(ACPITABINFO)))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTabInfo"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                PACPITABINFO pTabInfo = (PACPITABINFO)pdioc->lpvOutBuffer;

                if ((pTabInfo->dwPhyAddr = AcpiFindTable(pTabInfo->dwTabSig, NULL)) != 0)
                {
                    AcpiCopyROM(pTabInfo->dwPhyAddr, (PBYTE)&pTabInfo->dh, sizeof(pTabInfo->dh));
                }
                else
                {
                    DBG_ERR(("WUBIOS_IOCtrl: failed to get table info"));
                    rc = ERROR_GEN_FAILURE;
                }
            }
            break;

        case WUBIOCTL_GET_ACPI_TABLE:
            if ((pdioc->lpvInBuffer == NULL) || (pdioc->lpvOutBuffer == NULL) || (pdioc->cbOutBuffer == 0))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTable"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                AcpiCopyROM((DWORD)pdioc->lpvInBuffer, (PBYTE)pdioc->lpvOutBuffer, pdioc->cbOutBuffer);
            }
            break;
		case WUBIOCTL_GET_SMB_STRUCTSIZE:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on WUBIOCTL_GET_SMB_TABSIZE"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
				*((PDWORD)(pdioc->lpvOutBuffer)) = SmbStructSize();
            }
			break;

		case WUBIOCTL_GET_SMB_STRUCT:
            if ((pdioc->lpvInBuffer == NULL) || (pdioc->lpvOutBuffer == NULL) || (pdioc->cbOutBuffer == 0))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on GetTable"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                rc = SmbCopyStruct((DWORD)pdioc->lpvInBuffer, (PBYTE)pdioc->lpvOutBuffer, pdioc->cbOutBuffer);
            }
			break;
		case WUBIOCTL_GET_PNP_OEMID:
            if ((pdioc->cbOutBuffer < sizeof(DWORD)) || (pdioc->lpvOutBuffer == NULL))
            {
                DBG_ERR(("WUBIOS_IOCtrl: invalid parameter on WUBIOCTL_GET_PNP_OEMID"));
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
				*((PDWORD)(pdioc->lpvOutBuffer)) = PnpOEMID();
            }
			break;
		default:
			;
    }

    EXIT(1, ("WUBIOS_IOCtrl=%x\n", rc));
    return rc;
}       //WUBIOS_IOCtrl

/***LP  CheckSum - Calculate checksum of a buffer
 *
 *  ENTRY
 *      pb -> buffer
 *      dwLen - length of buffer
 *
 *  EXIT
 *      returns checksum
 */

BYTE CM_INTERNAL CheckSum(PBYTE pb, DWORD dwLen)
{
    TRACENAME("CHECKSUM")
    BYTE bChkSum = 0;

    ENTER(3, ("CheckSum(pb=%x,Len=%x)\n", pb, dwLen));

    while (dwLen > 0)
    {
        bChkSum = (BYTE)(bChkSum + *pb);
        pb++;
        dwLen--;
    }

    EXIT(3, ("CheckSum=%x\n", bChkSum));
    return bChkSum;
}       //CheckSum
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\smbios.c ===
/*** smbios.c - System Management BIOS support
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#include "wubiosp.h"

/*** Function prototypes
 */
PPNPBIOSINIT CM_LOCAL GetPNPBIOSINIT(void);
PSMBIOSENTRY CM_LOCAL GetSMBIOSENTRY(void);
PBYTE CM_LOCAL NextTable(PBYTE pMem);

#pragma CM_PAGEABLE_DATA

 /*** Globals
 */
static PSMBIOSENTRY g_pSMBIOS = (PSMBIOSENTRY)0xffffffff;


#pragma CM_PAGEABLE_CODE

 /*** SmbStructSize - Init SMBIOS and return max table size
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      TRUE
 *  EXIT-FAILURE
 *      FALSE
 *
 *
 */
DWORD CM_INTERNAL SmbStructSize(void)
{
    TRACENAME("SmbStructSize")

	DWORD dwMaxTableSize = 0;

	ENTER(2, ("SmbStructSize()\n"));

	if ((PSMBIOSENTRY)0xffffffff == g_pSMBIOS)
	{
		// Find Struct
		g_pSMBIOS = GetSMBIOSENTRY();
	}
	if (g_pSMBIOS)
	{
		dwMaxTableSize = (DWORD)(g_pSMBIOS->wMaxStructSize);
	}

	EXIT(2, ("SmbStructSize()=%x\n", dwMaxTableSize));
	
	return dwMaxTableSize;
}

 /*** SmbCopyStruct - Do BIOS init
 *
 *  ENTRY
 *      dwType - Structure type (from SMBIOS spec)
 *      pbBuff -> buffer
 *      dwLen - buffer length
 *
 *  EXIT
 *      None
 *
 */
CM_VXD_RESULT CM_INTERNAL SmbCopyStruct(DWORD dwType, PBYTE pbBuff, DWORD dwLen)
{
    TRACENAME("SmbCopyStruct")
    
	CM_VXD_RESULT rc = ERROR_GEN_FAILURE;
	
	ENTER(2, ("SmbCopyStruct()\n"));
	
	if ((PSMBIOSENTRY)0xffffffff == g_pSMBIOS)
	{
		// Find Struct
		g_pSMBIOS = GetSMBIOSENTRY();
	}
	// Check if we are inited
	if ( 0 != g_pSMBIOS && (DWORD)(g_pSMBIOS->wMaxStructSize) <= dwLen) 
	{

		// Map table
		PBYTE pTable = _MapPhysToLinear(g_pSMBIOS->dwStructTableAddress, g_pSMBIOS->wStructTableLength, 0);
		if ((PBYTE)0xffffffff != pTable)
		{
			WORD wTblCounter = g_pSMBIOS->wNumberOfStructs;
			while (wTblCounter --)
			{
				PBYTE pNextTable = NextTable(pTable);
				if ((BYTE)dwType == ((PSMBIOSHEADER)pTable)->bType)
				{
					// Do copy
				    memcpy(pbBuff, pTable, pNextTable - pTable);
					rc = ERROR_SUCCESS;
					//break;
				}
				pTable = pNextTable;
			}
		}
	}
    
	EXIT(2, ("SmbCopyStruct()=%x\n", rc));
	return rc;
}

 /*** PnpOEMID - Find PNPBIOSINIT and extract OEM id From it
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      DWORD id
 *  EXIT-FAILURE
 *      0
 *
 *
 */
DWORD CM_INTERNAL PnpOEMID(void)
{
    TRACENAME("PnpOEMID")

    static PPNPBIOSINIT pPnPBIOS = (PPNPBIOSINIT)0xffffffff;

	DWORD dwID = 0;
	ENTER(2, ("PnpOEMID()\n"));

    if ((PPNPBIOSINIT)0xffffffff == pPnPBIOS)
    {
        pPnPBIOS = GetPNPBIOSINIT();
    }
	if (pPnPBIOS)
	{
		dwID = pPnPBIOS->dwOEMID;
	}
    
	EXIT(2, ("PnpOEMID() dwID = %08X\n", dwID));
	
	return dwID;
}


 /*** GetInitTable - Find PNPBIOSINIT structure
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the PNPBIOSINIT pointer
 *  EXIT-FAILURE
 *      returns NULL
 *
 *
 */
PPNPBIOSINIT CM_LOCAL GetPNPBIOSINIT(void)
{
    TRACENAME("GetPNPBIOSINIT")
	
	PPNPBIOSINIT pInitTableRet = NULL;
	PBYTE pMem;

    ENTER(2, ("GetPNPBIOSINIT()\n"));

	// Map start address
	pMem = _MapPhysToLinear(SMBIOS_SEARCH_RANGE_BEGIN, SMBIOS_SEARCH_RANGE_LENGTH, 0);

    if (pMem != (PBYTE)0xffffffff)
	{
		// Loop counter;
		int  nCounter = SMBIOS_SEARCH_RANGE_LENGTH / SMBIOS_SEARCH_INTERVAL;

		CM_FOREVER 
		{
			PPNPBIOSINIT pInitTable = (PPNPBIOSINIT)pMem;
			if ((PNP_SIGNATURE == pInitTable->dwSignature) && (0 == CheckSum(pMem, pInitTable->bLength)))
			{
				// Check length
				if (pInitTable->bLength<sizeof(PNPBIOSINIT)) 
				{
					DBG_ERR(("PnP BIOS Structure size %2X is less than %2X", 
						pInitTable->bLength, sizeof(PNPBIOSINIT)));
					break;
				}
				// Check version
				if (pInitTable->bRevision<0x10)
				{
					DBG_ERR(("PnP BIOS Revision %2X is less than 1.0", 
						pInitTable->bRevision));
					break;
				}
				pInitTableRet = pInitTable;
				break;
			}
			pMem += SMBIOS_SEARCH_INTERVAL;

			if ((--nCounter)==0)
			{
				DBG_ERR(("Could not find BIOS Init structure"));
				break;
			}
		}
	}
    EXIT(2, ("GetPNPBIOSINIT() pInitTable = %08X\n", pInitTableRet));
	return pInitTableRet;
}

 /*** GetInitTable - Find SMBIOSENTRY structure
 *
 *  ENTRY
 *      None
 *
 *  EXIT-SUCCESS
 *      returns the SMBIOSENTRY pointer
 *  EXIT-FAILURE
 *      returns NULL
 *
 *
 */
PSMBIOSENTRY CM_LOCAL GetSMBIOSENTRY(void)
{
    TRACENAME("GetSMBIOSENTRY")
	
	PSMBIOSENTRY pEntryTableRet = NULL;
	PBYTE pMem;

    ENTER(2, ("GetSMBIOSENTRY()\n"));

	// Map start address
	pMem = _MapPhysToLinear(SMBIOS_SEARCH_RANGE_BEGIN, SMBIOS_SEARCH_RANGE_LENGTH, 0);
	

    if (pMem != (PBYTE)0xffffffff)
	{
		// Loop counter;
		int nCounter = SMBIOS_SEARCH_RANGE_LENGTH / SMBIOS_SEARCH_INTERVAL;

		CM_FOREVER 
		{
			PSMBIOSENTRY pEntryTable = (PSMBIOSENTRY)pMem;
			if ((SM_SIGNATURE == pEntryTable->dwSignature) && (0 == CheckSum(pMem, pEntryTable->bLength)))
			{
				// Check length
				if (pEntryTable->bLength<sizeof(SMBIOSENTRY)) 
				{
					DBG_ERR(("SMBIOS Structure size %2X is less than %2X", 
						pEntryTable->bLength, sizeof(SMBIOSENTRY)));
					break;
				}
				pEntryTableRet = pEntryTable;
				break;
			}
			pMem += SMBIOS_SEARCH_INTERVAL;

			if ((--nCounter)==0)
			{
				DBG_ERR(("Could not find BIOS Init structure"));
				break;
			}
		}
	}
    EXIT(2, ("GetSMBIOSENTRY()\n"));
	return pEntryTableRet;
}

PBYTE CM_LOCAL NextTable(PBYTE pMem)
{
	pMem += ((PSMBIOSHEADER)pMem)->bLength;
	while ( *(PWORD)pMem)
		pMem ++;
	return pMem + 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\wubiosp.h ===
/*** wubiosp.h - WindowsUpdate BIOS Scanning VxD Private Definitions
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/04/98
 *
 *  MODIFICATION HISTORY
 */

#ifndef _WUBIOSP_H
#define _WUBIOSP_H

/*XLATOFF*/
#define CM_PERFORMANCE_INFO
#include <basedef.h>
#include <vmm.h>
#define USECMDWRAPPERS
#include <vxdwraps.h>
#include <configmg.h>
#include <vwin32.h>
#include <winerror.h>
#include "wubios.h"
/*XLATON*/

/*** Build Options
 */

#ifdef DEBUG
  #define TRACING
  #define DEBUGGER
#endif  //DEBUG

/*** Constants
 */

#define WARNNAME                "WUBIOS"

/*XLATOFF*/
#pragma intrinsic(memcpy)

/*** Global Data
 */

#ifdef TRACING
extern int giIndent;
#endif

/*** Macros
 */

#define DEREF(x)        ((x) = (x))

#ifdef TRACING
  BOOL CM_LOCAL IsTraceOn(BYTE n, char *pszProcName, BOOL fEnter);
  #define TRACENAME(s)  char *pszTraceName = s;
  #define ENTER(n,p)    {                                               \
                            if (IsTraceOn(n, pszTraceName, TRUE))       \
                                CMDD p;                                 \
                            ++giIndent;                                 \
                        }
  #define EXIT(n,p)     {                                               \
                            --giIndent;                                 \
                            if (IsTraceOn(n, pszTraceName, FALSE))      \
                                CMDD p;                                 \
                        }
#else
  #define TRACENAME(s)
  #define ENTER(n,p)
  #define EXIT(n,p)
#endif  //TRACING

#ifdef DEBUGGER
VOID CM_SYSCTRL WUBIOS_Debug(VOID);
#endif

#ifdef DEBUG
  #define DBG_PRINTF(str)   _Debug_Printf_Service##str
  #define DBG_WARN(str)  {                              \
        _Debug_Printf_Service(WARNNAME ":WARNS:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
  }
  #define DBG_ERR(str)  {                               \
        _Debug_Printf_Service(WARNNAME ":ERROR:");      \
        _Debug_Printf_Service##str;                     \
        _Debug_Printf_Service("\n");                    \
        _asm int 3                                      \
  }
  #define ASSERT(x)     if (!(x))                                           \
                            DBG_ERR(("Assertion failed: file %s, line %d",  \
                                     __FILE__, __LINE__))
#else
  #define DBG_PRINTF(str)
  #define DBG_WARN(str)
  #define DBG_ERR(str)
  #define ASSERT(x)
#endif  //DEBUG
/*XLATON*/


/*** Functions prototipes
 */
CM_VXD_RESULT CM_SYSCTRL WUBIOS_IOCtrl(PDIOCPARAMETERS pdioc);
BYTE CM_INTERNAL CheckSum(PBYTE pb, DWORD dwLen);

/*** ACPI
 */
DWORD CM_INTERNAL AcpiFindTable(DWORD dwSig, PDWORD pdwLen);
VOID CM_INTERNAL AcpiCopyROM(DWORD dwPhyAddr, PBYTE pbBuff, DWORD dwLen);


/*** SMBIOS 
 */
DWORD CM_INTERNAL SmbStructSize(void);
CM_VXD_RESULT CM_INTERNAL SmbCopyStruct(DWORD dwType, PBYTE pbBuff, DWORD dwLen);
DWORD CM_INTERNAL PnpOEMID(void);
#endif  //ifndef _ACPITABP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\basedef.h ===
/***    BASEDEF.H
 *
 *      Basic constants and types for the VMM and VxDs
 *      Copyright (c) 1988,1989 Microsoft Corporation
 *
 *      NOBASEDEFS turns off the base definations
 */

#ifndef NOBASEDEFS
#define NOBASEDEFS

/*
 *  No warnings generated on non-standard usuage such as double
 *  slash for comments
 */
#pragma warning (disable:4206)
#pragma warning (disable:4214)
#pragma warning (disable:4201)
#pragma warning (disable:4505)
#pragma warning (disable:4514)
#pragma warning (disable:4001)

#ifndef FALSE
#define FALSE   0
#endif
#ifndef TRUE
#define TRUE	1
#endif
#ifndef NULL
#define NULL    '\0'                    // Null pointer
#endif

#define CDECL   _cdecl
#define PASCAL  _pascal
#define VOID    void
#define CONST   const
#define VOLATILE volatile

typedef int INT;                        // i
typedef unsigned int UINT;              // u
typedef int BOOL;                       // f

typedef unsigned char BYTE;             // b
typedef unsigned short WORD;            // w
typedef unsigned long DWORD;            // dw

#ifndef _H2INC

typedef struct qword_s {                /* qword */
   DWORD qword_lo;
   DWORD qword_hi;
} QWORD;				// qw

#endif

#ifndef	_NTDEF_

typedef char CHAR;                      // ch
typedef unsigned char UCHAR;            // uch
typedef short SHORT;                    // s
typedef unsigned short USHORT;          // us
typedef long LONG;                      // l
typedef unsigned long ULONG;            // ul

typedef UCHAR *PSZ;                     // psz
typedef VOID *PVOID;                    // p
typedef PVOID *PPVOID;                  // pp

/*XLATOFF*/

#if (_MSC_VER >= 900)

#if (!defined(MIDL_PASS) || defined(__midl))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
struct _LARGE_INTEGER {
#else // MIDL_PASS
union _LARGE_INTEGER {
    struct _LARGE_INTERGER1 {
        ULONG LowPart;
        LONG HighPart;
    };
    struct _LARGE_INTERGER2 {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER LARGE_INTEGER;
#else
typedef union _LARGE_INTEGER LARGE_INTEGER;
#endif

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
struct _ULARGE_INTEGER {
#else // MIDL_PASS
union _ULARGE_INTEGER {
    struct _LARGE_INTERGER3 {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct _LARGE_INTERGER4 {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
};

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER ULARGE_INTEGER;
#else
typedef union _ULARGE_INTEGER ULARGE_INTEGER;
#endif

typedef ULARGE_INTEGER *PULARGE_INTEGER;

#else	// of MSC_VER > 900

#ifndef _H2INC

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

typedef struct _ULARGE_INTEGER {
	ULONG LowPart;
	ULONG HighPart;
} ULARGE_INTEGER;

#endif 

#endif 

/*XLATON*/

#else

typedef PVOID *PPVOID;                  // pp

#endif 

typedef INT *PINT;                      // pi
typedef UINT *PUINT;                    // pu
typedef BYTE *PBYTE;                    // pb
typedef WORD *PWORD;                    // pw
typedef DWORD *PDWORD;                  // pdw
typedef CHAR *PCHAR;                    // pch
typedef SHORT *PSHORT;                  // ps
typedef LONG *PLONG;                    // pl
typedef UCHAR *PUCHAR;                  // puch
typedef USHORT *PUSHORT;                // pus
typedef ULONG *PULONG;                  // pul
typedef BOOL *PBOOL;                    // pf

typedef UCHAR SZ[];                     // sz
typedef UCHAR SZZ[];                    // szz
typedef UCHAR *PSZZ;                    // pszz

typedef USHORT SEL;                     // sel
typedef SEL *PSEL;                      // psel

typedef ULONG PPHYS;                    // pphys

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

typedef PVOID HANDLE;                   // h
typedef HANDLE *PHANDLE;                // ph

typedef ULONG HTIMEOUT;			// timeout handle
typedef ULONG CMS;			// count of milliseconds

#ifndef NOMINMAX

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

#ifndef min
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))

#endif // NOBASEDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\poppack.h ===
/*++

Copyright (c) 1990,95  Microsoft Corporation

Module Name:

    poppack.h

Abstract:

    This file turns packing of structures off.  (That is, it enables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.

    poppack.h is the complement to pshpack?.h.  An inclusion of poppack.h
    MUST ALWAYS be preceded by an inclusion of one of pshpack?.h, in one-to-one
    correspondence.

    For Microsoft compatible compilers, this file uses the pop option
    to the pack pragma so that it can restore the previous saved by the
    pshpack?.h include file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(pop)
#else
#pragma pack()
#endif
#else
#pragma pack()
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\configmg.h ===
/*****************************************************************************
 *
 *	(C) Copyright MICROSOFT Corp., 1993
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *	Date:		02-Feb-1993
 *
 *	Authors:	PYS & RAL
 *
 *------------------------------------------------------------------------------
 *
 *	Change log:
 *
 *	   DATE     REV DESCRIPTION
 *	----------- --- -----------------------------------------------------------
 *	02-Feb-1993 PYS Original
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#ifdef	WIN40COMPAT

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#define	ASD_SUPPORT		1
#define	ASSERT_STRING_SUPPORT	1

#else

#define	CONFIGMG_VERSION	0x040A

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x000A

#define	ASD_SUPPORT		0
#define	ASSERT_STRING_SUPPORT	0

#endif

#define	CONFIGMG_W32IOCTL_RANGE	0x80000000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

#ifdef	GOLDEN
#ifndef	DEBUG
#define	CM_GOLDEN_RETAIL
#endif
#endif

/*XLATOFF*/
#include <pshpack1.h>
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"None", \
	"Mem ", \
	"IO  ", \
	"DMA ", \
	"IRQ ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32
#define	fMD_Pref		4		// Memory range is Prefetch
#define	fMD_CombinedWrite	8		// Memory range is write combineable (no effect, for WDM only)
#define	fMD_Cacheable		0x10		// Memory range is cacheable (no effect, for WDM only)

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0x0003		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share_Bit		0			// IRQ can be shared
#define	fIRQD_Share		1			// IRQ can be shared
#define	fIRQD_Level_Bit		1			// IRQ is level (PCI)
#define	fIRQD_Level		2			// IRQ is level (PCI)
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_HARDWIRED		0x0000E000
#define	LCPRI_IMPOSSIBLE	0x0000F000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#define CM_FIRST_BOOT_START     0x00000001
#define CM_FIRST_BOOT           0x00000002
#define CM_FIRST_BOOT_FINISH    0x00000004
#define CM_QUEUE_REBOOT_START   0x00000008
#define CM_QUEUE_REBOOT_FINISH  0x00000010
#define CM_INSTALL_MEDIA_READY  0x00000020

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Find_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Global_State, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Broadcast_Device_Change_Message, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Reinsert_All, VxD_CODE)
//
// 4.0 OPK2 Services
//
CONFIGMG_Service	(_CONFIGMG_Change_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reprocess_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Assert_Structure, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Discard_Boot_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Dependent_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Refilter_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Merge_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Substract_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_PowerState, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_PowerCapabilities, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Set_Log_Conf_Priority, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Support_Share_Irq, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent_Structure, VxD_CODE)
//
// 4.1 Services
//
CONFIGMG_Service	(_CONFIGMG_Register_DevNode_For_Idle_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CM_To_ISAPNP, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Handler, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Detect_Resource_Conflict, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_List_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Conflict_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Remove_DevNode_Property, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Interface, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_System_Device_Power_State_Mapping, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Arbitrator_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Waking_Up_From_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_DevNode_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Interface_Alias, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"_CONFIGMG_Get_Version", \
	"_CONFIGMG_Initialize", \
	"_CONFIGMG_Locate_DevNode", \
	"_CONFIGMG_Get_Parent", \
	"_CONFIGMG_Get_Child", \
	"_CONFIGMG_Get_Sibling", \
	"_CONFIGMG_Get_Device_ID_Size", \
	"_CONFIGMG_Get_Device_ID", \
	"_CONFIGMG_Get_Depth", \
	"_CONFIGMG_Get_Private_DWord", \
	"_CONFIGMG_Set_Private_DWord", \
	"_CONFIGMG_Create_DevNode", \
	"_CONFIGMG_Query_Remove_SubTree", \
	"_CONFIGMG_Remove_SubTree", \
	"_CONFIGMG_Register_Device_Driver", \
	"_CONFIGMG_Register_Enumerator", \
	"_CONFIGMG_Register_Arbitrator", \
	"_CONFIGMG_Deregister_Arbitrator", \
	"_CONFIGMG_Query_Arbitrator_Free_Size", \
	"_CONFIGMG_Query_Arbitrator_Free_Data", \
	"_CONFIGMG_Sort_NodeList", \
	"_CONFIGMG_Yield", \
	"_CONFIGMG_Lock", \
	"_CONFIGMG_Unlock", \
	"_CONFIGMG_Add_Empty_Log_Conf", \
	"_CONFIGMG_Free_Log_Conf", \
	"_CONFIGMG_Get_First_Log_Conf", \
	"_CONFIGMG_Get_Next_Log_Conf", \
	"_CONFIGMG_Add_Res_Des", \
	"_CONFIGMG_Modify_Res_Des", \
	"_CONFIGMG_Free_Res_Des", \
	"_CONFIGMG_Get_Next_Res_Des", \
	"_CONFIGMG_Get_Performance_Info", \
	"_CONFIGMG_Get_Res_Des_Data_Size", \
	"_CONFIGMG_Get_Res_Des_Data", \
	"_CONFIGMG_Process_Events_Now", \
	"_CONFIGMG_Create_Range_List", \
	"_CONFIGMG_Add_Range", \
	"_CONFIGMG_Delete_Range", \
	"_CONFIGMG_Test_Range_Available", \
	"_CONFIGMG_Dup_Range_List", \
	"_CONFIGMG_Free_Range_List", \
	"_CONFIGMG_Invert_Range_List", \
	"_CONFIGMG_Intersect_Range_List", \
	"_CONFIGMG_First_Range", \
	"_CONFIGMG_Next_Range", \
	"_CONFIGMG_Dump_Range_List", \
	"_CONFIGMG_Load_DLVxDs", \
	"_CONFIGMG_Get_DDBs", \
	"_CONFIGMG_Get_CRC_CheckSum", \
	"_CONFIGMG_Register_DevLoader", \
	"_CONFIGMG_Reenumerate_DevNode", \
	"_CONFIGMG_Setup_DevNode", \
	"_CONFIGMG_Reset_Children_Marks", \
	"_CONFIGMG_Get_DevNode_Status", \
	"_CONFIGMG_Remove_Unmarked_Children", \
	"_CONFIGMG_ISAPNP_To_CM", \
	"_CONFIGMG_CallBack_Device_Driver", \
	"_CONFIGMG_CallBack_Enumerator", \
	"_CONFIGMG_Get_Alloc_Log_Conf", \
	"_CONFIGMG_Get_DevNode_Key_Size", \
	"_CONFIGMG_Get_DevNode_Key", \
	"_CONFIGMG_Read_Registry_Value", \
	"_CONFIGMG_Write_Registry_Value", \
	"_CONFIGMG_Disable_DevNode", \
	"_CONFIGMG_Enable_DevNode", \
	"_CONFIGMG_Move_DevNode", \
	"_CONFIGMG_Set_Bus_Info", \
	"_CONFIGMG_Get_Bus_Info", \
	"_CONFIGMG_Set_HW_Prof", \
	"_CONFIGMG_Recompute_HW_Prof", \
	"_CONFIGMG_Query_Change_HW_Prof", \
	"_CONFIGMG_Get_Device_Driver_Private_DWord", \
	"_CONFIGMG_Set_Device_Driver_Private_DWord", \
	"_CONFIGMG_Get_HW_Prof_Flags", \
	"_CONFIGMG_Set_HW_Prof_Flags", \
	"_CONFIGMG_Read_Registry_Log_Confs", \
	"_CONFIGMG_Run_Detection", \
	"_CONFIGMG_Call_At_Appy_Time", \
	"_CONFIGMG_Fail_Change_HW_Prof", \
	"_CONFIGMG_Set_Private_Problem", \
	"_CONFIGMG_Debug_DevNode", \
	"_CONFIGMG_Get_Hardware_Profile_Info", \
	"_CONFIGMG_Register_Enumerator_Function", \
	"_CONFIGMG_Call_Enumerator_Function", \
	"_CONFIGMG_Add_ID", \
	"_CONFIGMG_Find_Range", \
	"_CONFIGMG_Get_Global_State", \
	"_CONFIGMG_Broadcast_Device_Change_Message", \
	"_CONFIGMG_Call_DevNode_Handler", \
	"_CONFIGMG_Remove_Reinsert_All", \
	"_CONFIGMG_Change_DevNode_Status", \
	"_CONFIGMG_Reprocess_DevNode", \
	"_CONFIGMG_Assert_Structure", \
	"_CONFIGMG_Discard_Boot_Log_Conf", \
	"_CONFIGMG_Set_Dependent_DevNode", \
	"_CONFIGMG_Get_Dependent_DevNode", \
	"_CONFIGMG_Refilter_DevNode", \
	"_CONFIGMG_Merge_Range_List", \
	"_CONFIGMG_Substract_Range_List", \
	"_CONFIGMG_Set_DevNode_PowerState", \
	"_CONFIGMG_Get_DevNode_PowerState", \
	"_CONFIGMG_Set_DevNode_PowerCapabilities", \
	"_CONFIGMG_Get_DevNode_PowerCapabilities", \
	"_CONFIGMG_Read_Range_List", \
	"_CONFIGMG_Write_Range_List", \
	"_CONFIGMG_Get_Set_Log_Conf_Priority", \
	"_CONFIGMG_Support_Share_Irq", \
	"_CONFIGMG_Get_Parent_Structure", \
	"_CONFIGMG_Register_For_Idle_Detection", \
	"_CONFIGMG_CM_To_ISAPNP", \
	"_CONFIGMG_Get_DevNode_Handler", \
	"_CONFIGMG_Detect_Resource_Conflict", \
	"_CONFIGMG_Get_Device_Interface_List", \
	"_CONFIGMG_Get_Device_Interface_List_Size", \
	"_CONFIGMG_Get_Conflict_Info", \
	"_CONFIGMG_Add_Remove_DevNode_Property", \
	"_CONFIGMG_CallBack_At_Appy_Time", \
	"_CONFIGMG_Register_Device_Interface", \
	"_CONFIGMG_System_Device_Power_State_Mapping", \
	"_CONFIGMG_Get_Arbitrator_Info", \
	"_CONFIGMG_Waking_Up_From_DevNode", \
	"_CONFIGMG_Set_DevNode_Problem", \
	"_CONFIGMG_Get_Device_Interface_Alias", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	PRIORITY	CMFAR	*PPRIORITY;	// Pointer to a priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

#ifdef	_NTDDK_
typedef	DEVICE_POWER_STATE	PSMAPPING[PowerSystemMaximum];
#else
typedef	VOID			PSMAPPING;
#endif

typedef	PSMAPPING	CMFAR	*PPSMAPPING;

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

/****************************************************************************
 *
 * Arbitration list structures (they must be key in sync with CONFIGMG's
 * local.h own structure).
 *
 ***************************************************************************/
typedef	struct nodelist_s	NODELIST;
typedef	NODELIST		CMFAR *PNODELIST;
typedef	PNODELIST		CMFAR *PPNODELIST;

struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	DEVNODE			nl_ItsDevNode;		// The dev node it represent
	LOG_CONF	 	nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct nodelist_s	*nlh_Head;		// First node element
	struct nodelist_s	*nlh_Tail;		// Last node element
};

typedef	struct nodelistheader_s	NODELISTHEADER;
typedef	NODELISTHEADER		CMFAR *PNODELISTHEADER;

/*XLATOFF*/
struct	arbitfree_s {
	PFARVOID		af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};
/*XLATON*/
/* ASM
arbitfree_s 	STRUC
	af_PointerToInfo	dd	?
	af_SizeOfInfo		dd	?
arbitfree_s 	ENDS
*/
typedef	struct	arbitfree_s	ARBITFREE;
typedef	ARBITFREE		CMFAR *PARBITFREE;

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, PNODELISTHEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPES
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020
#define	BusType_BIOS		0x00000040
#define	BusType_ACPI		0x00000080
#define	BusType_IDE		0x00000100
#define	BusType_MF		0x00000200

/****************************************************************************
 *
 *				CONFIGURATION MANAGER STRUCTURE TYPES
 *
 ***************************************************************************/
#define	CMAS_UNKNOWN		0x00000000
#define	CMAS_DEVNODE		0x00000001
#define	CMAS_LOG_CONF		0x00000002
#define	CMAS_RES_DES		0x00000003
#define	CMAS_RANGELIST_HEADER	0x00000004
#define	CMAS_RANGELIST		0x00000005
#define	CMAS_NODELIST_HEADER	0x00000006
#define	CMAS_NODELIST		0x00000007
#define	CMAS_INTERNAL_RES_DES	0x00000008
#define	CMAS_ARBITRATOR		0x00000009

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS			0x00000000
#define	CR_DEFAULT			0x00000001
#define	CR_OUT_OF_MEMORY		0x00000002
#define	CR_INVALID_POINTER		0x00000003
#define	CR_INVALID_FLAG			0x00000004
#define	CR_INVALID_DEVNODE		0x00000005
#define	CR_INVALID_RES_DES		0x00000006
#define	CR_INVALID_LOG_CONF		0x00000007
#define	CR_INVALID_ARBITRATOR		0x00000008
#define	CR_INVALID_NODELIST		0x00000009
#define	CR_DEVNODE_HAS_REQS		0x0000000A
#define	CR_INVALID_RESOURCEID		0x0000000B
#define	CR_DLVXD_NOT_FOUND		0x0000000C
#define	CR_NO_SUCH_DEVNODE		0x0000000D
#define	CR_NO_MORE_LOG_CONF		0x0000000E
#define	CR_NO_MORE_RES_DES		0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE		0x00000010
#define	CR_INVALID_RANGE_LIST		0x00000011
#define	CR_INVALID_RANGE		0x00000012
#define	CR_FAILURE			0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV		0x00000014
#define	CR_CREATE_BLOCKED		0x00000015
#define	CR_NOT_A_GOOD_TIME		0x00000016
#define	CR_REMOVE_VETOED		0x00000017
#define	CR_APM_VETOED			0x00000018
#define	CR_INVALID_LOAD_TYPE		0x00000019
#define	CR_BUFFER_SMALL			0x0000001A
#define	CR_NO_ARBITRATOR		0x0000001B
#define	CR_NO_REGISTRY_HANDLE		0x0000001C
#define	CR_REGISTRY_ERROR		0x0000001D
#define	CR_INVALID_DEVICE_ID		0x0000001E
#define	CR_INVALID_DATA			0x0000001F
#define	CR_INVALID_API			0x00000020
#define	CR_DEVLOADER_NOT_READY		0x00000021
#define	CR_NEED_RESTART			0x00000022
#define	CR_NO_MORE_HW_PROFILES		0x00000023
#define	CR_DEVICE_NOT_THERE		0x00000024
#define	CR_NO_SUCH_VALUE		0x00000025
#define	CR_WRONG_TYPE			0x00000026
#define	CR_INVALID_PRIORITY		0x00000027
#define	CR_NOT_DISABLEABLE		0x00000028
#define	CR_FREE_RESOURCES		0x00000029
#define	CR_QUERY_VETOED			0x0000002A
#define	CR_CANT_SHARE_IRQ		0x0000002B
//
// 4.0 OPK2 results
//
#define	CR_NO_DEPENDENT			0x0000002C
//
// 4.1 OPK2 results
//
#define	CR_SAME_RESOURCES		0x0000002D
#define	CR_ALREADY_SUCH_DEPENDENT	0x0000002E
#define	NUM_CR_RESULTS			0x0000002F

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_A_GOOD_TIME", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_NO_MORE_HW_PROFILES", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_FREE_RESOURCES", \
	"CR_QUERY_VETOED", \
	"CR_CANT_SHARE_IRQ", \
	"CR_NO_DEPENDENT", \
	"CR_SAME_RESOURCES", \
	"CR_ALREADY_SUCH_DEPENDENT", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_ASD_FAILED			0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	CM_PROB_FAILED_INSTALL			0x0000001C
#define	CM_PROB_HARDWARE_DISABLED		0x0000001D
#define	CM_PROB_CANT_SHARE_IRQ			0x0000001E

//
// 4.0 OPK2 Problems
//
#define	CM_PROB_DEPENDENT_PROBLEM		0x0000001F

//
// 4.1 Problems
//
#define CM_PROB_INSTALL_MEDIA_NOT_READY		0x00000020
#define CM_PROB_HARDWARE_MALFUNCTION		0x00000021
#define NUM_CM_PROB				0x00000022

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"ASD check failed", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
	"Failed install", \
	"Hardware Disabled", \
	"Can't share IRQ", \
	"Dependent failed", \
	"Install media not ready", \
	"Hardware malfunction", \
};

/*XLATON*/

//
// Flags to be passed in the various APIs
//

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_BITS			0x00000000

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_LOCK_UNLOCK_NORMAL			0x00000000
#define	CM_LOCK_UNLOCK_JUST_DEVNODES_CHANGED	0x00000001
#define	CM_LOCK_UNLOCK_BITS			0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_ADD_PARENT_INSTANCE	0x00000002
#define	CM_CREATE_DEVNODE_BITS			0x00000003

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_SYNCHRONOUS	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_ASYNCHRONOUS	0x00000004
#define	CM_REGISTER_DEVICE_DRIVER_ACPI_APM	0x00000008
#define	CM_REGISTER_DEVICE_DRIVER_LOAD_DRIVER	0x00000010
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x0000001F

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_ACPI_APM		0x00000002
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000003

#define	CM_REGISTER_ARBITRATOR_GLOBAL		0x00000001
#define	CM_REGISTER_ARBITRATOR_LOCAL		0x00000000
#define	CM_REGISTER_ARBITRATOR_MYSELF		0x00000002
#define	CM_REGISTER_ARBITRATOR_NOT_MYSELF	0x00000000
#define	CM_REGISTER_ARBITRATOR_CONFLICT_FREE	0x00000004
#define	CM_REGISTER_ARBITRATOR_CAN_CONFLICT	0x00000000
#define	CM_REGISTER_ARBITRATOR_PARTIAL		0x00000008
#define	CM_REGISTER_ARBITRATOR_COMPLETE		0x00000000
#define	CM_REGISTER_ARBITRATOR_PARTIAL_RES_DES	0x00000010
#define	CM_REGISTER_ARBITRATOR_PARTIAL_DEVNODE	0x00000000
#define	CM_REGISTER_ARBITRATOR_BITS		0x0000001F

#define	CM_QUERY_REMOVE_UI_OK			0x00000000
#define	CM_QUERY_REMOVE_UI_NOT_OK		0x00000001
#define	CM_QUERY_REMOVE_BITS			0x00000001

#define	CM_REMOVE_UI_OK				0x00000000
#define	CM_REMOVE_UI_NOT_OK			0x00000001
#define	CM_REMOVE_BITS				0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_WRITE_LOG_CONFS		0x00000002
#define	CM_SETUP_PROP_CHANGE			0x00000003
#define	CM_SETUP_BITS				0x00000003

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_ADD_RES_DES_UNCONFIGURABLE	0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_BUS_INFO_DONT_RETURN_MF_INFO	0x00000000
#define	CM_GET_BUS_INFO_RETURN_MF_INFO		0x00000001
#define	CM_GET_BUS_INFO_FLAGS			0x00000001

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_DUMP_RANGE_NORMAL			0x00000000
#define	CM_DUMP_RANGE_JUST_LIST			0x00000001
#define	CM_DUMP_RANGE_BITS			0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_HARDWARE			0x00000002	// Don't ask the driver, and won't be restarteable
#define	CM_DISABLE_BITS				0x00000003	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define CM_DETECT_TOPBUSONLY			0x00000008	// detect only top level bus
#define CM_DETECT_VERIFYONLY			0x00000010	// verify, dont detect
#define CM_DETECT_EXCLENUMDEVS			0x00000020	// exclude enum devs
#define CM_DETECT_DOUI				0x00000040	// detect all HW
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

#define	CM_BROADCAST_SEND			0x00000000
#define	CM_BROADCAST_QUERY			0x00000001
#define	CM_BROADCAST_BITS			0x00000001

#define	CM_CALL_HANDLER_ENUMERATOR		0x00000000
#define	CM_CALL_HANDLER_DEVICE_DRIVER		0x00000001
#define	CM_CALL_HANDLER_BITS			0x00000001

#define	CM_GLOBAL_STATE_CAN_DO_UI		0x00000001
#define	CM_GLOBAL_STATE_ON_BIG_STACK		0x00000002
#define	CM_GLOBAL_STATE_SERVICES_AVAILABLE	0x00000004
#define	CM_GLOBAL_STATE_SHUTING_DOWN		0x00000008
#define	CM_GLOBAL_STATE_DETECTION_PENDING	0x00000010
#define	CM_GLOBAL_STATE_ON_BATTERY		0x00000020
#define	CM_GLOBAL_STATE_SUSPEND_PHASE		0x00000040
#define	CM_GLOBAL_STATE_SUSPEND_LOCKED_PHASE	0x00000080
#define	CM_GLOBAL_STATE_REBALANCE		0x00000100
#define	CM_GLOBAL_STATE_LOGGING_ON		0x00000200

#define	CM_REMOVE_REINSERT_ALL_REMOVE		0x00000000
#define	CM_REMOVE_REINSERT_ALL_REINSERT		0x00000001
#define	CM_REMOVE_REINSERT_ALL_BITS		0x00000001

#define	CM_CHANGE_DEVNODE_STATUS_REMOVE_FLAGS	0x00000000
#define	CM_CHANGE_DEVNODE_STATUS_ADD_FLAGS	0x00000001
#define	CM_CHANGE_DEVNODE_STATUS_BITS		0x00000001

#define	CM_REPROCESS_DEVNODE_ASYNCHRONOUS	0x00000000
#define	CM_REPROCESS_DEVNODE_SYNCHRONOUS	0x00000001
#define	CM_REPROCESS_DEVNODE_BITS		0x00000001

//
// SET_DEVNODE_POWERSTATE_PERSISTANT is ignored in 4.1. You need to call
// Set_DevNode_Property(CM_PROPERTY_ARM_WAKEUP).
//
//#define CM_SET_DEVNODE_POWERSTATE_PERSISTANT    0x00000001
#define CM_SET_DEVNODE_POWERSTATE_BITS          0x00000001

#define CM_POWERSTATE_D0                        0x00000001
#define CM_POWERSTATE_D1			0x00000002
#define CM_POWERSTATE_D2                        0x00000004
#define CM_POWERSTATE_D3                        0x00000008
#define CM_POWERSTATE_BITS                      0x0000000f

#define	CM_CAPABILITIES_NORMAL			0x00000000
#define	CM_CAPABILITIES_FOR_WAKEUP		0x00000001
#define	CM_CAPABILITIES_OVERRIDE		0x00000002	// Should be used by ACPI only
#define	CM_CAPABILITIES_MERGE			0x00000000
#define	CM_GET_CAPABILITIES_BITS		0x00000001
#define	CM_SET_CAPABILITIES_BITS		0x00000003

#define	CM_CM_TO_ISAPNP_NORMAL			0x00000000
#define	CM_CM_TO_ISAPNP_FAIL_NUL_TAGS		0x00000001
#define	CM_CM_TO_ISAPNP_BITS			0x00000001

#define	CM_SET_DEPENDENT_DEVNODE_ADD		0x00000000
#define	CM_SET_DEPENDENT_DEVNODE_REMOVE		0x00000001
#define	CM_SET_DEPENDENT_DEVNODE_BITS		0x00000001

#define	CM_GET_DEVNODE_HANDLER_CONFIG		0x00000000
#define	CM_GET_DEVNODE_HANDLER_ENUM		0x00000001
#define	CM_GET_DEVNODE_HANDLER_BITS		0x00000001

#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT		0x00000000  // only currently 'live' devices
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES	0x00000001  // all registered devices, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS		0x00000001

#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_ADD		0x00000000
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_REMOVE		0x00000001
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_NEEDS_LOCKING	0x00000002
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_ARM_WAKEUP	0x00000004
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_LIGHT_SLEEP	0x00000008
#define	CM_ADD_REMOVE_DEVNODE_PROPERTY_BITS		0x0000000F

#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_GET	0x00000000
#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_SET	0x00000001
#define	CM_SYSTEM_DEVICE_POWER_STATE_MAPPING_BITS	0x00000001

#define	CM_WAKING_UP_FROM_DEVNODE_ASYNCHRONOUS		0x00000000
#define	CM_WAKING_UP_FROM_DEVNODE_SYNCHRONOUS		0x00000001
#define	CM_WAKING_UP_FROM_DEVNODE_BITS			0x00000001

#define	CM_GET_LOG_CONF_PRIORITY			0x00000000
#define	CM_SET_LOG_CONF_PRIORITY			0x00000001
#define	CM_GET_SET_LOG_CONF_PRIORITY_BITS		0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.
#define	CONFIG_PROP_CHANGE	0x00000010	// The property page is exiting.
#define	CONFIG_PRIVATE		0x00000011	// Someone called Call_Handler.
#define	CONFIG_PRESHUTDOWN	0x00000012	// We are shutting down
#define	CONFIG_BEGIN_PNP_MODE	0x00000013	// We will start configuring PNP devs.
#define	CONFIG_LOCK		0x00000014	// Gets call during suspend
#define	CONFIG_UNLOCK		0x00000015	// Gets call during resume
#define CONFIG_IRP		0x00000016	// IRP from WDM driver
#define	CONFIG_WAKEUP		0x00000017	// Please arm/disarm the wake up.
#define	CONFIG_WAKEUP_CALLBACK	0x00000018	// You are waking up

#define	NUM_CONFIG_COMMANDS	0x00000019	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
	"CONFIG_PROP_CHANGE", \
	"CONFIG_PRIVATE", \
	"CONFIG_PRESHUTDOWN", \
	"CONFIG_BEGIN_PNP_MODE", \
	"CONFIG_LOCK", \
	"CONFIG_UNLOCK", \
	"CONFIG_IRP", \
	"CONFIG_WAKEUP", \
	"CONFIG_WAKEUP_CALLBACK", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001
#define	CONFIG_START_SHUTDOWN_START			0x00000002

#define NUM_START_COMMANDS				0x00000003

/*XLATOFF*/

#define DEBUG_START_NAMES \
char	CMFAR *lpszStartName[NUM_START_COMMANDS] = \
{ \
    	"DYNAMIC_START", \
	"FIRST_START", \
	"SHUTDOWN_START", \
};

/*XLATON*/

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

#define NUM_STOP_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_STOP_NAMES \
char	CMFAR *lpszStopName[NUM_STOP_COMMANDS] = \
{ \
    	"DYNAMIC_STOP", \
	"HAS_PROBLEM", \
};

/*XLATON*/

//
// For both CONFIG_REMOVE, CONFIG_PREREMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_SHUTDOWN_OFF				0x00000000
#define	CONFIG_SHUTDOWN_REBOOT				0x00000001

#define NUM_REMOVE_COMMANDS				0x00000003

/*XLATOFF*/

#define DEBUG_REMOVE_NAMES \
char	CMFAR *lpszRemoveName[NUM_REMOVE_COMMANDS] = \
{ \
    	"DYNAMIC", \
	"SHUTDOWN", \
	"REBOOT", \
};

/*XLATON*/

#define	CONFIG_ENUMERATE_DYNAMIC			0x00000000
#define	CONFIG_ENUMERATE_FIRST_TIME			0x00000001

#define NUM_ENUMERATE_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_ENUMERATE_NAMES \
char	CMFAR *lpszEnumerateName[NUM_ENUMERATE_COMMANDS] = \
{ \
    	"DYNAMIC", \
	"FIRST_TIME", \
};

/*XLATON*/

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define NUM_TEST_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_TEST_NAMES \
char	CMFAR *lpszTestName[NUM_TEST_COMMANDS] = \
{ \
    	"CAN_STOP", \
	"CAN_REMOVE", \
};

/*XLATON*/

//
// APM changed drastically in 4.1. We do not send the old APM message at all.
// Enumerators/Device Driver
//
//
// APM messages have a flag part (the high part) as well as message number
// part (the low part).
//
#define	CONFIG_APM_FLAGS_MASK				0xFFFFF000

//
// APM flags
//
#define	CONFIG_APM_UI_IS_ALLOWED			0x80000000
#define	CONFIG_APM_SUSPEND_PHASE			0x40000000
#define	CONFIG_APM_SUSPEND_LOCKED_PHASE			0x20000000
#define	CONFIG_APM_ARM_WAKEUP				0x10000000
#define	CONFIG_APM_RESUME_CRITICAL			0x08000000

#define	CONFIG_APM_QUERY_D1				0x00000000
#define	CONFIG_APM_QUERY_D2				0x00000001
#define	CONFIG_APM_QUERY_D3				0x00000002
#define	CONFIG_APM_FAILED_D1				0x00000003
#define	CONFIG_APM_FAILED_D2				0x00000004
#define	CONFIG_APM_FAILED_D3				0x00000005
#define	CONFIG_APM_SET_D0				0x00000006
#define	CONFIG_APM_SET_D1				0x00000007
#define	CONFIG_APM_SET_D2				0x00000008
#define	CONFIG_APM_SET_D3				0x00000009

//
// Normally you shouldn't listen to the resume ones unless you care about
// behing turned on right away on resume.
//
#define	CONFIG_APM_RESUME_D0				0x0000000A
#define	CONFIG_APM_RESUME_D1				0x0000000B
#define	CONFIG_APM_RESUME_D2				0x0000000C
#define	CONFIG_APM_RESUME_D3				0x0000000D

//
// Only NTKern should listen to the following ones.
//
#define	CONFIG_APM_QUERY_S1				0x0000000E
#define	CONFIG_APM_QUERY_S2				0x0000000F
#define	CONFIG_APM_QUERY_S3				0x00000010
#define	CONFIG_APM_QUERY_S4				0x00000011
#define	CONFIG_APM_QUERY_S5				0x00000012
#define	CONFIG_APM_SET_S0				0x00000013
#define	CONFIG_APM_SET_S1				0x00000014
#define	CONFIG_APM_SET_S2				0x00000015
#define	CONFIG_APM_SET_S3				0x00000016
#define	CONFIG_APM_SET_S4				0x00000017
#define	CONFIG_APM_SET_S5				0x00000018

#define NUM_APM_COMMANDS				0x00000019

/*XLATOFF*/

#define DEBUG_APM_NAMES \
char	CMFAR *lpszAPMName[NUM_APM_COMMANDS] = \
{ \
    	"QUERY_D1", \
	"QUERY_D2", \
	"QUERY_D3", \
	"FAILED_D1", \
	"FAILED_D2", \
	"FAILED_D3", \
	"SET_D0", \
	"SET_D1", \
	"SET_D2", \
	"SET_D3", \
	"RESUME_D0", \
	"RESUME_D1", \
	"RESUME_D2", \
	"RESUME_D3", \
	"QUERY_S1", \
	"QUERY_S2", \
	"QUERY_S3", \
	"QUERY_S4", \
	"QUERY_S5", \
	"SET_S0", \
	"SET_S1", \
	"SET_S2", \
	"SET_S3", \
	"SET_S4", \
	"SET_S5", \
};

/*XLATON*/

#define	CONFIG_WAKEUP_ARM				0x00000000
#define	CONFIG_WAKEUP_DISABLE				0x00000001

#define NUM_WAKEUP_COMMANDS				0x00000002

/*XLATOFF*/

#define DEBUG_WAKEUP_NAMES \
char	CMFAR *lpszWakeupName[NUM_WAKEUP_COMMANDS] = \
{ \
    	"ARM", \
	"DISABLE", \
};

/*XLATON*/

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makes no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	4.0 OPK2 Messages
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_QUERY_ARBITRATE - Ask if arbitrator arbitrates this node
 *
 *	DESC:	Local partial arbitrator is passed a one devnode nodelist,
 *		and returns whether it arbitrates for that devnode.
 *
 *	EXIT:	CR_SUCCESS if arbitrator wants to arbitrate this node.
 *		CR_FAILURE if the arbitrator does not arbitrate this node.
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_ADD_RESERVE - Tell the arbitrator it should reserve this alloc
 *
 *	DESC:	In 4.0, arbitrators were learning reserve resources
 *		(resources that would be given only during a second pass)
 *		when called with ARB_RETEST/FORCE_ALLOC. However, we can
 *		ARB_RETEST_ALLOC during rebalance, so with 4.0 OPK2 we send a
 *		specific message telling the arbitrator that the resources
 *		in the test_alloc are for a FORCED or BOOT LOG_CONF and thus
 *		should be marked to be given only in a second pass during
 *		an ARB_TEST_ALLOC. This is for optimization only: to avoid
 *		rebalance.
 *
 *	EXIT:	CR_SUCCESS if the arbitrator understand this message and did
 *		something about it.
 *		CR_FAILURE if nothing was done.
 *
 *	CR_DEFAULT is CR_FAILURE.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_WRITE_RESERVE - Tell the arbitrator it should save the reserve
 *		list in the registry
 *
 *	DESC:	If an arbitrator returns CR_SUCCESS to ARB_SET_RESERVE, it
 *		will be called later on to save the reserve list.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	CR_DEFAULT is CR_SUCCESS.
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 * -------------------------------------------------------------------------
 *
 *	ARB_BEGIN_PNP_MODE - Tell the arbitrator that PNP mode is about to be
 *      started.
 *
 *	DESC:	If an arbitrator returns CR_SUCCESS, it understood the message and
 *		performed some action accordingly.
 *
 *	EXIT:	CR_SUCCESS if the arbitrator understand this message and did
 *		something about it.
 *		CR_FAILURE if nothing was done.
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC.
#define	ARB_QUERY_ARBITRATE	0x00000007	// Check if wants to arbitrate.
#define	ARB_ADD_RESERVE		0x00000008	// Mark alloc as reserved.
#define	ARB_WRITE_RESERVE	0x00000009	// Save reserve in registry.
#define	ARB_BEGIN_PNP_MODE  	0x0000000A  	// Tell the arb the start of PNP mode.
#define	ARB_APPLY_ALLOC  	0x0000000B  	// Called after the stop of the rebalance.
#define	NUM_ARB_COMMANDS	0x0000000C	// Number of arb commands.

/*XLATOFF*/
#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
	"ARB_QUERY_ARBITRATE",\
	"ARB_ADD_RESERVE",\
	"ARB_WRITE_RESERVE",\
	"ARB_BEGIN_PNP_MODE",\
	"ARB_APPLY_ALLOC",\
};
/*XLATON*/

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	can be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config start
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed
//
// 4.0 OPK2 Flags
//
#define	DN_NOT_FIRST_TIMEE	0x00080000	// S: Has received a config enumerate
#define	DN_STOP_FREE_RES	0x00100000	// S: When child is stopped, free resources
#define	DN_REBAL_CANDIDATE	0x00200000	// S: Don't skip during rebalance
#define	DN_BAD_PARTIAL		0x00400000	// S: This devnode's log_confs do not have same resources
#define	DN_NT_ENUMERATOR	0x00800000	// S: This devnode's is an NT enumerator
#define	DN_NT_DRIVER		0x01000000	// S: This devnode's is an NT driver
//
// 4.1 Flags
//
#define	DN_NEEDS_LOCKING	0x02000000	// S: Devnode need lock resume processing
#define	DN_ARM_WAKEUP		0x04000000	// S: Devnode can be the wakeup device
#define	DN_APM_ENUMERATOR	0x08000000	// S: APM aware enumerator
#define	DN_APM_DRIVER		0x10000000	// S: APM aware driver
#define	DN_SILENT_INSTALL	0x20000000	// S: Silent install
#define	DN_NO_SHOW_IN_DM	0x40000000	// S: No show in device manager
#define	DN_BOOT_LOG_PROB	0x80000000	// S: Had a problem during preassignment of boot log conf

#define	DN_CHANGEABLE_FLAGS	0x79BB62E0

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000020	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
	"fe", \
	"sf", \
	"rc", \
	"bp", \
	"ze", \
	"zd", \
	"nl", \
	"wk", \
	"ae", \
	"ad", \
	"si", \
	"ns", \
	"bl", \
};

typedef ULONG			VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctWalk;
CMTIME		ctGarbageCollection;
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctAppyTime;
CMTIME		ctSyncAppyTime;
CMTIME		ctAsyncAppyTime;
CMTIME		ctAsyncWorker;
CMTIME		ctWaitForAppy;
CMTIME		ctWaitForWorker;
CMTIME		ctWaitForWorkers;
CMTIME		ctReceiveMessage;
CMTIME		ctRegistryOpen;
CMTIME		ctRegistryCreate;
CMTIME		ctRegistryClose;
CMTIME		ctRegistryRead;
CMTIME		ctRegistryWrite;
CMTIME		ctRegistryEnumKey;
CMTIME		ctRegistryEnumValue;
CMTIME		ctRegistryFlush;
CMTIME		ctRegistryDelete;
CMTIME		ctRegistryOther;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctHeap;
CMTIME		ctAssertRange;
CMTIME		ctASD;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	REALMODE_LOG_CONF	0x00000005	// Specifies the Realmode Log Conf.
#define	NEW_ALLOC_LOG_CONF	0x00000006	// Specifies the Old Alloc Log Conf.
#define	NUM_LOG_CONF		0x00000007	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
	"REALMODE_LOG_CONF",\
	"NEW_ALLOC_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
	WORD			IRQA_Level;
	WORD			IRQA_Unused;
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifndef	debug
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
CM_LOCKABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_LOCKABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_LOCKABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_LOCKABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
CM_LOCKABLE_CODE_SEG	TEXTEQU	<VxD_LOCKABLE_CODE_SEG>
CM_LOCKABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKABLE_CODE_ENDS>
CM_LOCKABLE_DATA_SEG	TEXTEQU	<VxD_LOCKABLE_CODE_SEG>
CM_LOCKABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKABLE_CODE_ENDS>
ENDIF

IFDEF CM_GOLDEN_RETAIL
CM_DEBUG_CODE_SEG	TEXTEQU	<.err>
CM_DEBUG_CODE_ENDS	TEXTEQU	<.err>
ELSE
IFDEF DEBUG
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
ELSE
CM_DEBUG_CODE_SEG	TEXTEQU	<VxD_DEBUG_ONLY_CODE_SEG>
CM_DEBUG_CODE_ENDS	TEXTEQU	<VxD_DEBUG_ONLY_CODE_ENDS>
ENDIF
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name (OEM format)
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUGBUG(d, id, msg)	message("BUGBUG: "##d##", "##id##": "##msg)

#define	CM_DEREF(var)		{var=var;}

#ifndef	DEBUG

#define	CM_WARN1(strings)
#define	CM_WARN2(strings)
#define	CM_ERROR(strings)

#else

#ifndef	MAXDEBUG

#define	CM_WARN1(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_WARN2(strings)
#define	CM_ERROR(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " ERROR: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}

#else

#define	CM_WARN1(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_WARN2(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " WARNS: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n");}
#define	CM_ERROR(strings) {\
	LCODE__Debug_Printf_Service(WARNNAME " ERROR: "); \
	LCODE__Debug_Printf_Service##strings; \
	LCODE__Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define CM_LOCKABLE_CODE	VxD_LOCKED_CODE_SEG
#define CM_LOCKABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#undef	CURSEG
#define	CURSEG()		LCODE

#define	CM_HEAPFLAGS		(HEAPZEROINIT)

#else

#define CM_LOCKABLE_CODE	VxD_LOCKABLE_CODE_SEG
#define CM_LOCKABLE_DATA	VxD_LOCKABLE_DATA_SEG
#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#undef	CURSEG
#define	CURSEG()		CCODE

#define	CM_HEAPFLAGS		(HEAPSWAP|HEAPZEROINIT)

#endif

#ifndef	CM_GOLDEN_RETAIL

#define	CM_DEBUGGER_USE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_DEBUGGER_USE_DATA	VxD_LOCKED_DATA_SEG

#else

#define	CM_DEBUGGER_USE_CODE	CM_LOCKABLE_CODE
#define	CM_DEBUGGER_USE_DATA	CM_LOCKABLE_DATA

#endif

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL
#define	CM_INLINE		_inline

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL {\
_asm	popfd	\
}

#ifndef NEC_98
#define	CM_PIC_MASTER	0x21
#define	CM_PIC_SLAVE	0xA1
#else
#define	CM_PIC_MASTER	0x02
#define	CM_PIC_SLAVE	0x0A
#endif

#define	CM_MASK_PIC(wPICMask) { \
_asm	in	al, CM_PIC_SLAVE \
_asm	mov	ah, al \
_asm	in	al, CM_PIC_MASTER \
_asm	mov	word ptr [wPICMask], ax \
_asm	or	al, 0xff \
_asm	out	CM_PIC_SLAVE, al \
_asm	out	CM_PIC_MASTER, al \
}

#define	CM_LOCK_PIC(dwEFlags, wPICMask) { \
{_asm	pushfd \
_asm	pop	[dwEFlags] \
_asm	cli	\
}; CM_MASK_PIC(wPICMask); \
}

#define	CM_UNMASK_PIC(wPICMask) { \
_asm	mov	ax, word ptr [wPICMask] \
_asm	out	CM_PIC_MASTER, al \
_asm	mov	al, ah \
_asm	out	CM_PIC_SLAVE, al \
}

#define	CM_UNLOCK_PIC(dwEFlags, wPICMask) { \
CM_UNMASK_PIC(wPICMask); \
{ _asm	push	[dwEFlags] \
_asm	popfd }\
}

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

#ifdef	IS_32

#include <vwin32.h>

struct	_WIN32CMIOCTLPACKET {
	DWORD	dwStack;
	DWORD	dwServiceNumber;
};

typedef	struct	_WIN32CMIOCTLPACKET	WIN32CMIOCTLPACKET;
typedef	WIN32CMIOCTLPACKET		*PWIN32CMIOCTLPACKET;

#ifdef	CM_USE_OPEN_SERVICE

CONFIGRET WINAPI
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket);

CONFIGRET WINAPI
CMWorker(DWORD dwStack, DWORD dwServiceNumber);

BOOL WINAPI
CM_Open(VOID);

VOID WINAPI
CM_Close(VOID);

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _cdecl \
CM_##Function##Parameters \
{ \
	DWORD	dwStack; \
	_asm	{mov	dwStack, ebp}; \
	dwStack+=8; \
	return(CMWorker(dwStack, CONFIGMG_W32IOCTL_RANGE+(GetVxDServiceOrdinal(_CONFIGMG_##Function) & 0xFFFF))); \
}

#define	CM_IS_FILE_PROVIDING_SERVICES \
HANDLE	hCONFIGMG=INVALID_HANDLE_VALUE; \
BOOL WINAPI \
CM_Open(VOID) \
{ \
	hCONFIGMG=CreateFile(	"\\\\.\\CONFIGMG", \
				GENERIC_READ|GENERIC_WRITE, \
				FILE_SHARE_READ|FILE_SHARE_WRITE, \
				NULL, OPEN_EXISTING, 0, NULL); \
	if (hCONFIGMG==INVALID_HANDLE_VALUE) \
		return(FALSE); \
	return(CM_Get_Version()>=0x400); \
} \
VOID WINAPI \
CM_Close(VOID) \
{ \
	CloseHandle(hCONFIGMG); \
 \
	hCONFIGMG==INVALID_HANDLE_VALUE; \
} \
CONFIGRET WINAPI \
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket) \
{ \
	CONFIGRET	crReturnValue=CR_FAILURE; \
	DWORD		dwReturnSize=0; \
	if (!DeviceIoControl(	hCONFIGMG, \
				pPacket->dwServiceNumber, \
				&(pPacket->dwStack), \
				sizeof(pPacket->dwStack), \
				&crReturnValue, \
				sizeof(crReturnValue), \
				&dwReturnSize, \
				NULL)) \
		return(CR_FAILURE); \
	if (dwReturnSize!=sizeof(crReturnValue)) \
		return(CR_FAILURE); \
	return(crReturnValue); \
} \
CONFIGRET WINAPI \
CMWorker(DWORD dwStack, DWORD dwServiceNumber) \
{ \
	WIN32CMIOCTLPACKET	Packet; \
	Packet.dwStack=dwStack; \
	Packet.dwServiceNumber=dwServiceNumber; \
	return(WIN32CMIoctlHandler(&Packet)); \
}

#else	// ifdef CM_USE_OPEN_SERVICE

CONFIGRET static WINAPI
WIN32CMIOCTLHandler(PWIN32CMIOCTLPACKET pPacket)
{
	HANDLE		hCONFIGMG;
	CONFIGRET	crReturnValue=CR_FAILURE;
	DWORD		dwReturnSize=0;

	hCONFIGMG=CreateFile(	"\\\\.\\CONFIGMG",
				GENERIC_READ|GENERIC_WRITE,
				FILE_SHARE_READ|FILE_SHARE_WRITE,
				NULL, OPEN_EXISTING, 0, NULL);

	if (hCONFIGMG==INVALID_HANDLE_VALUE)
		return(CR_FAILURE);

	if (!DeviceIoControl(	hCONFIGMG,
				pPacket->dwServiceNumber,
				&(pPacket->dwStack),
				sizeof(pPacket->dwStack),
				&crReturnValue,
				sizeof(crReturnValue),
				&dwReturnSize,
				NULL))
		crReturnValue=CR_FAILURE;

	CloseHandle(hCONFIGMG);

	if (dwReturnSize!=sizeof(crReturnValue))
		crReturnValue=CR_FAILURE;

	return(crReturnValue);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _cdecl \
CM_##Function##Parameters \
{ \
	WIN32CMIOCTLPACKET	Packet; \
	DWORD			dwStack; \
	_asm	{mov	dwStack, ebp}; \
	dwStack+=8; \
	Packet.dwStack=dwStack; \
	Packet.dwServiceNumber=CONFIGMG_W32IOCTL_RANGE+(GetVxDServiceOrdinal(_CONFIGMG_##Function) & 0xFFFF); \
	return(WIN32CMIOCTLHandler(&Packet)); \
}

#endif	// ifdef CM_USE_OPEN_SERVICE

#else	// IS_32

#ifdef	CM_USE_OPEN_SERVICE

extern	DWORD	CMEntryPoint;

BOOL
CM_Open(void);

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if (CMEntryPoint==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#define	CM_IS_FILE_PROVIDING_SERVICES \
DWORD	CMEntryPoint=0; \
BOOL \
CM_Open(void) \
{ \
	_asm	{push	bx}; \
	_asm	{push	es}; \
	_asm	{push	di}; \
	_asm	{xor	di, di}; \
	_asm	{mov	ax, 0x1684}; \
	_asm	{mov	bx, 0x33}; \
	_asm	{mov	es, di}; \
	_asm	{int	0x2f}; \
	_asm	{mov	word ptr [CMEntryPoint+2], es}; \
	_asm	{mov	word ptr [CMEntryPoint], di}; \
	_asm	{pop	di}; \
	_asm	{pop	es}; \
	_asm	{pop	bx}; \
	if (!CMEntryPoint) \
		return(FALSE); \
	return(CM_Get_Version()>=0x400); \
}

#else	// ifdef CM_USE_OPEN_SERVICE

DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#endif	// ifdef CM_USE_OPEN_SERVICE

#endif	// IS_32

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#define	CM_Get_Version	CONFIGMG_Get_Version

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (PNODELISTHEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (DEVNODE dnDevnode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))
MAKE_CM_HEADER(Find_Range, (PFARULONG pulStart, ULONG ulStart, ULONG ulLength, ULONG ulAlignment, ULONG ulEnd, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Global_State, (PFARULONG pulState, ULONG ulFlags))
MAKE_CM_HEADER(Broadcast_Device_Change_Message, (ULONG ulwParam, PFARVOID plParam, ULONG ulFlags))
MAKE_CM_HEADER(Call_DevNode_Handler, (DEVNODE dnDevNode, ULONG ulPrivate, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Reinsert_All, (ULONG ulFlags))
//
// 4.0 OPK2 Services
//
MAKE_CM_HEADER(Change_DevNode_Status, (DEVNODE dnDevNode, ULONG ulStatus, ULONG ulFlags))
MAKE_CM_HEADER(Reprocess_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Assert_Structure, (PFARULONG pulPointerType, DWORD dwData, ULONG ulFlags))
MAKE_CM_HEADER(Discard_Boot_Log_Conf, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Dependent_DevNode, (DEVNODE dnDependOnDevNode, DEVNODE dnDependingDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Dependent_DevNode, (PDEVNODE dnDependOnDevNode, DEVNODE dnDependingDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Refilter_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_PowerState, (DEVNODE dnDevNode, ULONG ulPowerState, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_PowerState, (DEVNODE dnDevNode, PFARULONG pulPowerState, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_PowerCapabilities, (DEVNODE dnDevNode, ULONG ulPowerCapabilities, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_PowerCapabilities, (DEVNODE dnDevNode, PFARULONG pulPowerCapabilities, ULONG ulFlags))
MAKE_CM_HEADER(Substract_Range_List, (RANGE_LIST rlhFrom, RANGE_LIST rlhWith, RANGE_LIST rlhDifference, ULONG ulFlags))
MAKE_CM_HEADER(Merge_Range_List, (RANGE_LIST rlh1, RANGE_LIST rlh2, RANGE_LIST rlhTotal, ULONG ulFlags))
MAKE_CM_HEADER(Read_Range_List, (PFARCHAR pszKeyName, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Write_Range_List, (PFARCHAR pszKeyName, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Get_Set_Log_Conf_Priority, (PPRIORITY pPriority, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Support_Share_Irq, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent_Structure, (PFARULONG pulParentStructure, RES_DES CurrentResDesOrLogConf, ULONG ulFlags))
//
// 4.1 Services
//
MAKE_CM_HEADER(Register_DevNode_For_Idle_Detection, (DEVNODE dnDevNode, ULONG ulConservationTime, ULONG ulPerformanceTime, PFARULONG pulCounterVariable, ULONG ulState, ULONG ulFlags))
MAKE_CM_HEADER(CM_To_ISAPNP, (LOG_CONF lcLogConf, PFARVOID pCurrentResources, PFARVOID pNewResources, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Handler, (DEVNODE dnDevNode, PFARULONG pAddress, ULONG ulFlags))
MAKE_CM_HEADER(Detect_Resource_Conflict, (DEVNODE dnDevNode, RESOURCEID ResourceID, PFARVOID pResourceData, ULONG ulResourceLen, PFARCHAR pfConflictDetected, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_List, (PFARVOID pInterfaceGuid, PFARCHAR pDeviceID, PFARCHAR pBuffer, ULONG ulBufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_List_Size, (PFARULONG pulLen, PFARVOID pInterfaceGuid, PFARCHAR pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Conflict_Info, (DEVNODE dnDevNode, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Add_Remove_DevNode_Property, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Interface, (DEVNODE dnDevNode, PFARVOID pInterfaceGuid, PFARCHAR pReference, PFARCHAR pInterfaceDevice, PFARULONG pulLen, ULONG ulFlags))
MAKE_CM_HEADER(System_Device_Power_State_Mapping, (DEVNODE dnDevNode, PPSMAPPING pPSMapping, ULONG ulFlags))
MAKE_CM_HEADER(Get_Arbitrator_Info, (PFARULONG pInfo, PDEVNODE pdnDevNode, DEVNODE dnDevNode, RESOURCEID ResourceID, PFARVOID pResourceData, ULONG ulResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Waking_Up_From_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_DevNode_Problem, (DEVNODE dnDevNode, ULONG ulProblem, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Interface_Alias, (PFARCHAR pDeviceInterface, PFARVOID pAliasInterfaceGuid, PFARCHAR pAliasDeviceInterface, PFARULONG pulLen, ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

/*XLATOFF*/
#include <poppack.h>
/*XLATON*/

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:	1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:	RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 *   17-Dec-1993     Adds East Asia VxDs identifiers
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.	Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE	    0	    // False
#define VMM_TRUE    (~FALSE)	// The opposite of False!

#define DEBLEVELRETAIL	0
#define DEBLEVELNORMAL	1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#define WIN403SERVICES		/*OPK-3 Services*/
#endif

#ifndef WIN40COMPAT
#define WIN41SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef	NEWSTRUCTS	; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *	    EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID	    0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID	    0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID	    0x0000A
#define VSD_DEVICE_ID	    0x0000B
#define VMD_DEVICE_ID	    0x0000C
#define VKD_DEVICE_ID	    0x0000D
#define VCD_DEVICE_ID	    0x0000E
#define VPD_DEVICE_ID	    0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID	    0x0001B
#define VDD2_DEVICE_ID	    0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID	    0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID	    0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID	    0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID	0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID 	0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID	0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID	0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID	0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS	*/
/* #define VNB_DEVICE_ID	   0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID	   0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID	*/

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID	    0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID	   0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F	/* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID	    0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID	    0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */
#define DDS_DEVICE_ID	    0x0004A /* Device driver services */
#define NTKERN_DEVICE_ID    0x0004B /* NT kernel device id */
#define VDOSKEYD_DEVICE_ID  0x0004B /* DOSKEY device id */
#define ACPI_DEVICE_ID      0x0004C /* Advanced Configuration and Power Interfacec */
#define UDF_DEVICE_ID       0x0004D /* UDF FSD device id */
#define SMCLIB_DEVICE_ID    0x0004E /* Smart Card port driver */

/*
 *   East Asia DOS support VxD ID
 */

#define ETEN_Device_ID	    0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID	    0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.	Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER	    0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER	0x000000000 /*	but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER		0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER	    0x014000000
#define VWIN32_INIT_ORDER   0x014100000
#define VXDLDR_INIT_ORDER   0x016000000
#define NTKERN_INIT_ORDER   0x016200000 /* Must be after VxDLdr and before configmg */

#define CONFIGMG_INIT_ORDER 0x016400000	/* Must now be before enumerators */
#define ENUMERATOR_INIT_ORDER	0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER	    ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define ACPI_INIT_ORDER     ENUMERATOR_INIT_ORDER+2 /* To simplify reenumeration */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER	    0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER	    0x028000000
#define VSD_INIT_ORDER	    0x02C000000

#define VCD_INIT_ORDER	    0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER	    0x034000000
#define VKD_INIT_ORDER	    0x038000000
#define VPD_INIT_ORDER	    0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER	0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER	0x080000000
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order	    0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER	    0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;	    /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;		/* Client's EDI */
    ULONG Pushad_ESI;		/* Client's ESI */
    ULONG Pushad_EBP;		/* Client's EBP */
    ULONG Pushad_ESP;		/* ESP before pushad */
    ULONG Pushad_EBX;		/* Client's EBX */
    ULONG Pushad_EDX;		/* Client's EDX */
    ULONG Pushad_ECX;		/* Client's ECX */
    ULONG Pushad_EAX;		/* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)	// turn off redefinition warning

typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;

#pragma warning (default:4209)	// turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)	__##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define Declare_SCService(service, args, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG	    code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG	    data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG	code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG	data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DB1CODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DB2DATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG	code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG	code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG	code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG	code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG	code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG	code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG	code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG	code_seg("LOCKABLE", "LOCKABLECODE")
#define VxD_LOCKABLE_DATA_SEG	data_seg("LOCKABLE_DATA", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS

;*  32 bit pageable code
_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM		;; End for each segment

    ENDM

MakeCodeSeg <L0CKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***	DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_L0CKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_L0CKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***	DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***	CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***	MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***	MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS

;*  32 bit locked data
_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS

;*  32 bit pageable data
_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS

;*  32 Bit initialization data
_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS

;*  Created by C8
_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS

;*  32 Bit static code for DL-VxDs
_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS

;*  32 Bit static data for DL-VxDs
_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS

;*	dummy segment for IsDebugOnlyLoaded
_DB0START   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB0START   ENDS

;*	32 bit debug only code; loaded only if debugger is present
_DB1CODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB1CODE    ENDS

;*	32 bit debug only data; loaded only if debugger is present
_DB2DATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB2DATA    ENDS

if DEBLEVEL
;*  Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*  32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*  End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DB0START, _DB1CODE, _DB2DATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;	. . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table	VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1		; Only in module where table is
;   INCLUDE	VxD.INC 	; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err	;StdCallBytes required
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM


;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


;***	Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.	If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName	- the name of the VxD; it is assumed
;		  that a corresponding Device_ID is
;		  also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;	accepts a service name as its only parameter.
;	This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM


;***	End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName	- the same name passed to
;		  Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***	Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name	- the service name
;	cParms	    - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***	Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service	- the name of the service
;	CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)	service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp	VxDJmp

#define SERVICE 	__cdecl
#define ASYNC_SERVICE	__cdecl
#define WIN32_SERVICE	void __stdcall

#ifndef FASTCALL
#define FASTCALL	__fastcall
#endif
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status; 	/* VM status flags */
    ULONG CB_High_Linear;	/* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56	/* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT	0x00	/* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE	(1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT	0x01	/* VM runs in background */
#define VMSTAT_BACKGROUND	(1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING 	(1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT	0x03	/* VM not scheduled */
#define VMSTAT_SUSPENDED	(1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE	(1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC		(1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP		(1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32 	(1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC 	(1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09	/* High pri background */
#define VMSTAT_HIGH_PRI_BACK	(1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED		(1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT	0x0B	/* Woke up after blocked */
#define VMSTAT_AWAKENING	(1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT	0x0C	/* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT	VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86	(1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D	/* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED	(1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E	/* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT	(1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT 	0x0F	/* VM has released time slice */
#define VMSTAT_IDLE		(1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING		(1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11	/* VM suspended by */
#define VMSTAT_TS_SUSPENDED	(1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT	0x12	/* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI	(1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;		/* Thread status flags */
    ULONG   TCB_Reserved1;	/* Used internally by VMM */
    ULONG   TCB_Reserved2;	/* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;	/* Client registers of thread */
    ULONG   TCB_VMHandle;	/* VM that thread is part of */
    USHORT  TCB_ThreadId;	/* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;	    /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;	    /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;	/* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;		/* reusable; for dword align */
    UCHAR   TCB_pad2;		/* reusable; for dword align */
    UCHAR   TCB_extErrLocus;	    /* extended error Locus */
    USHORT  TCB_extErr; 	/* extended error Code */
    UCHAR   TCB_extErrAction;	    /*	    "   "   Action */
    UCHAR   TCB_extErrClass;	    /*	    "   "   Class */
    ULONG   TCB_extErrPtr;	/*	"   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD	    0x42434854	  // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT	    0x03   // Thread not scheduled
#define THFLAG_SUSPENDED		   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE		   (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION		   (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED		   (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD		   (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_ASYNC_THREAD_BIT	    0x1F   // thread is asynchronous
#define THFLAG_ASYNC_THREAD	       	   (1L << THFLAG_ASYNC_THREAD_BIT)
#define THFLAG_CHARSET_BITS	0x10   // Default character set
#define THFLAG_CHARSET_MASK	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI	       (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM	       (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE		   (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED 	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES 	   (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13	 // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE		 (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;		// faulting EIP
    WORD  VMFI_CS;		// faulting CS
    WORD  VMFI_Ints;		// interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *		V M M	S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#define VMM_StdCall_Service Declare_SCService
#define VMM_FastCall_Service Declare_SCService
#pragma warning (disable:4003)	    // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)	// MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

//
// Flags affecting the returned block
//

#define HEAPZEROINIT        0x00000001
#define HEAPZEROREINIT      0x00000002
#define HEAPNOCOPY          0x00000004

//
// Alignment flags
//

#define HEAPALIGN_SHIFT     16
#define HEAPALIGN_MASK      0x000F0000

#define HEAPALIGN_4         0x00000000                // dword aligned
#define HEAPALIGN_8         0x00000000                // quadword aligned
#define HEAPALIGN_16        0x00000000                // paragraph aligned
#define HEAPALIGN_32        0x00010000                // etc.
#define HEAPALIGN_64        0x00020000
#define HEAPALIGN_128       0x00030000
#define HEAPALIGN_256       0x00040000
#define HEAPALIGN_512       0x00050000
#define HEAPALIGN_1K        0x00060000
#define HEAPALIGN_2K        0x00070000
#define HEAPALIGN_4K        0x00080000
#define HEAPALIGN_8K        0x00090000
#define HEAPALIGN_16K       0x000A0000
#define HEAPALIGN_32K       0x000B0000
#define HEAPALIGN_64K       0x000C0000
#define HEAPALIGN_128K      0x000D0000

//
// Flags indicating which system heap to use.  There are four bits reserved
// to identify the heap to use.  Four are currently defined by the system.
//

#define HEAPTYPESHIFT       8
#define HEAPTYPEMASK        0x00000700

#define HEAPLOCKEDHIGH      0x00000000
#define HEAPLOCKEDIFDP      0x00000100
#define HEAPSWAP            0x00000200
#define HEAPINIT            0x00000400  // will be automatically freed after
                                        // init complete

//
// other flags
//

#define HEAPCLEAN           0x00000800
#define HEAPCONTIG          0x00001000  // memory must be physically contiguous
#define HEAPFORGET          0x00002000  // this memory will never be freed

//
// Combinations of flags understood by HeapAllocateEx
//

#define HEAPLOCKEDLOW       0x00000300
#define HEAPSYSVM           0x00000500
#define HEAPPREEMPT         0x00000600  // code in this heap is preemptable

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT		0x00000001
#define PAGEUSEALIGN		0x00000002
#define PAGECONTIG		0x00000004
#define PAGEFIXED		0x00000008
#define PAGEDEBUGNULFAULT	0x00000010
#define PAGEZEROREINIT		0x00000020
#define PAGENOCOPY		0x00000040
#define PAGELOCKED		0x00000080
#define PAGELOCKEDIFDP		0x00000100
#define PAGESETV86PAGEABLE	0x00000200
#define PAGECLEARV86PAGEABLE	0x00000400
#define PAGESETV86INTSLOCKED	0x00000800
#define PAGECLEARV86INTSLOCKED	0x00001000
#define PAGEMARKPAGEOUT 	0x00002000
#define PAGEPDPSETBASE		0x00004000
#define PAGEPDPCLEARBASE	0x00008000
#define PAGEDISCARD		0x00010000
#define PAGEPDPQUERYDIRTY	0x00020000
#define PAGEMAPFREEPHYSREG	0x00040000
#define PAGEPHYSONLY		0x04000000
//efine PAGEDONTUSE		0x08000000  // ;Internal
#define PAGENOMOVE		0x10000000
#define PAGEMAPGLOBAL		0x40000000
#define PAGEMARKDIRTY		0x80000000

/****************************************************
 *
 *	Flags for _PhysIntoV86,
 *	_MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP	0x00000001

/****************************************************
 *
 *	Flags for MapPhysToLinear
 *
 *
 ***************************************************/

#define	MPL_NonCached			0x00000000
#define	MPL_HardwareCoherentCached	0x00000001
#define	MPL_FrameBufferCached		0x00000002
#define	MPL_Cached			0x00000004

// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
*   Flag equates for _Allocate_GDT_Selector
*/
#define ALLOCFROMEND    0x40000000


/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL	0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE	0x00000002
#define MMGRHMADISABLE	0x00000004
#define MMGRHMAQUERY	0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT	    0
#define LF_ASYNC	(1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP	(1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR	    (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP 	(LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area)
VMM_Service (_Free_Temp_V86_Data_Area)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign	    0x00000001
#define GVDADWordAlign	    0x00000002
#define GVDAParaAlign	    0x00000004
#define GVDAPageAlign	    0x00000008
#define GVDAInstance	    0x00000100
#define GVDAZeroInit	    0x00000200
#define GVDAReclaim	0x00000400
#define GVDAInquire	0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE	    260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT	0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT	0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT	0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT	0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT	0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)
#define GMIF_80586_BIT  0x15
#define GMIF_80586  (1 << GMIF_80586_BIT)
#define GMIF_4MEGPG_BIT 0x16                // cpu supports 4 meg pages
#define GMIF_4MEGPG (1 << GMIF_4MEGPG_BIT)
#define GMIF_RDTSC_BIT 0x17
#define GMIF_RDTSC ( 1 << GMIF_RDTSC_BIT )

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *	    D E B U G G I N G	E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)	// Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)	// for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz	@@Test_DBCS_Lead_Byte - 100D1h	 ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT	 0x0001 // physical memory that must be swapped out
				// and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY	    0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS	 0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001	/* Privledged instruction */
#define GSDVME_INVALINST    0x00010002	/* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003	/* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004	/* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005	/* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006	/* User requested NUKE of VM */
#define GSDVME_DEVNUKE	    0x00010007	/* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008	/* Device specific problem:
			 *   invalid hardware fiddling
			 *   by VM (invalid I/O)
			 */
#define GSDVME_NUKENOMSG    0x00010009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */
#define GSDVME_OKNUKEMASK   0x80000000	/* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001	/* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002	/* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003	/* XMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004	/* EMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005	/* Hi DOS V86 mem   - DOSMGR
			 *	     V86MMGR
			 */
#define GSDVME_INSMEMVID    0x00020006	/* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007	/* Base VM mem	   - VMM
			 *   CB, Inst Buffer
			 */
#define GSDVME_INSMEMDEV    0x00020008	/* Couldn't alloc base VM
			 * memory for device.
			 */
#define GSDVME_CRTNOMSG     0x00020009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001	/* Page directory entry not-present */
#define IPF_V86PG   0x00000002	/* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004	/* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008	/* page has invalid not present type */
#define IPF_PGERR   0x00000010	/* pageswap device failure */
#define IPF_REFLT   0x00000020	/* re-entrant page fault */
#define IPF_VMM     0x00000040	/* Page fault caused by a VxD */
#define IPF_PM	    0x00000080	/* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100	/* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT	0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)	// Debugging only
VMM_Service (Disable_Touch_1st_Meg)	// Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz	 @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT	    0
#define DFS_LOG 	    (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT 	1
#define DFS_PROFILE	    (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT	2
#define DFS_TEST_CLD		(1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT	    3
#define DFS_NEVER_REENTER	(1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT	    4
#define DFS_TEST_REENTER	(1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT	    5
#define DFS_NOT_SWAPPING	(1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT	6
#define DFS_TEST_BLOCK		(1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES   0xFFFFFF80

#define DFS_EXIT_NOBLOCK	(DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC  (DFS_RARE_SERVICES+1)
#define DFS_WIMP_DEBUG      (DFS_RARE_SERVICES+2)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define MUTEX_MUST_COMPLETE	1L
#define MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND	    1L
#define THREAD_TERM_STATUS_NUKE_PEND	    2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE	0	/* no data instanced in range */
#define INSTINFO_SOME	1	/* some data instanced in range */
#define INSTINFO_ALL	2	/* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ	    // define only if not there already

#define REG_SZ	    0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT	0x80000000
#define HKEY_CURRENT_USER	0x80000001
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_USERS		0x80000003
#define HKEY_PERFORMANCE_DATA	0x80000004
#define HKEY_CURRENT_CONFIG	0x80000005
#define HKEY_DYN_DATA		0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE	0	/* no pages in the specified range exist */
#define PHYSINFO_SOME	1	/* some pages in the specified range exist */
#define PHYSINFO_ALL	2	/* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM	0
#define REGTYPE_CLASS	1
#define REGTYPE_VXD	2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN		    0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD	    0x00000000
#define ASSERT_RANGE_NULL_OK	    0x00000001
#define ASSERT_RANGE_IS_ASCIIZ	    0x00000002
#define ASSERT_RANGE_IS_NOT_ASCIIZ  0x00000000
#define ASSERT_RANGE_NO_DEBUG	    0x80000000
#define ASSERT_RANGE_BITS	    0x80000003

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN		0x00000001
#define BOOT_DOSCLEAN		0x00000002
#define BOOT_NETCLEAN		0x00000004
#define BOOT_INTERACTIVE	0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

#ifdef WIN403SERVICES

//
// 4.03 Services
//

/*MACROS*/
VMM_Service (_PageOutPages)
/*ENDMACROS*/

// Flag definitions for _PageOutPages

#define PAGEOUT_PRIVATE 0x00000001
#define PAGEOUT_SHARED	0x00000002
#define PAGEOUT_SYSTEM	0x00000004
#define PAGEOUT_REGION	0x00000008
#define PAGEOUT_ALL	(PAGEOUT_PRIVATE | PAGEOUT_SHARED | PAGEOUT_SYSTEM)

/*MACROS*/
VMM_Service (_Call_On_My_Not_Flat_Stack)
VMM_Service (_LinRegionLock)
VMM_Service (_LinRegionUnLock)
VMM_Service (_AttemptingSomethingDangerous)
VMM_Service (_Vsprintf)
VMM_Service (_Vsprintfw)
VMM_Service (Load_FS_Service)
VMM_Service (Assert_FS_Service)
VMM_StdCall_Service (ObsoleteRtlUnwind, 4)		
VMM_StdCall_Service (ObsoleteRtlRaiseException, 1)
VMM_StdCall_Service (ObsoleteRtlRaiseStatus, 1)		

VMM_StdCall_Service (ObsoleteKeGetCurrentIrql, 0)
VMM_FastCall_Service (ObsoleteKfRaiseIrql, 1)
VMM_FastCall_Service (ObsoleteKfLowerIrql, 1)

VMM_Service (_Begin_Preemptable_Code)
VMM_Service (_End_Preemptable_Code)
VMM_FastCall_Service (Set_Preemptable_Count, 1)

VMM_StdCall_Service (ObsoleteKeInitializeDpc, 3)
VMM_StdCall_Service (ObsoleteKeInsertQueueDpc, 3)
VMM_StdCall_Service (ObsoleteKeRemoveQueueDpc, 1)

VMM_StdCall_Service (HeapAllocateEx, 4)
VMM_StdCall_Service (HeapReAllocateEx, 5)
VMM_StdCall_Service (HeapGetSizeEx, 2)
VMM_StdCall_Service (HeapFreeEx, 2)
VMM_Service (_Get_CPUID_Flags)
VMM_StdCall_Service (KeCheckDivideByZeroTrap, 1)

/*ENDMACROS*/

#endif /* WIN403SERVICES */

#ifdef	WIN41SERVICES

/*MACROS*/
VMM_Service (_RegisterGARTHandler)
VMM_Service (_GARTReserve)
VMM_Service (_GARTCommit)
VMM_Service (_GARTUnCommit)
VMM_Service (_GARTFree)
VMM_Service (_GARTMemAttributes)
VMM_StdCall_Service (KfRaiseIrqlToDpcLevel, 0)
VMM_Service (VMMCreateThreadEx)
VMM_Service (_FlushCaches)
/*ENDMACROS*/

/*
 * Flags for the VMM GART services.
 * WARNING: THESE FLAGS SHOULD HAVE SAME VALUE AS THE VMM FLAGS DEFINED IN PCI.H
 * IF YOU CHANGE THE VALUE AT EITHER PLACE, YOU NEED TO UPDATE THE OTHER.
 */
#define	PG_UNCACHED		0x00000001		// Uncached memory
#define	PG_WRITECOMBINED	0x00000002		// Write combined memory

/*
 * Flags for the FlushCaches service.
 */
#define FLUSHCACHES_NORMAL              0x00000000
#define FLUSHCACHES_GET_CACHE_LINE_PTR  0x00000001
#define FLUSHCACHES_GET_CACHE_SIZE_PTR  0x00000002
#define FLUSHCACHES_TAKE_OVER           0x00000003
#define FLUSHCACHES_FORCE_PAGES_OUT     0x00000004
#define FLUSHCACHES_LOCK_LOCKABLE       0x00000005
#define FLUSHCACHES_UNLOCK_LOCKABLE     0x00000006

/*MACROS*/
VMM_Service (Set_Thread_Win32_Pri_NoYield)
VMM_Service (_FlushMappedCacheBlock)
VMM_Service (_ReleaseMappedCacheBlock)
VMM_Service (Run_Preemptable_Events)
VMM_Service (_MMPreSystemExit)
VMM_Service (_MMPageFileShutDown)
VMM_Service (_Set_Global_Time_Out_Ex)

VMM_Service (Query_Thread_Priority)

/*ENDMACROS*/

#endif /* WIN41SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning

#ifndef try
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#ifndef exception_code
#define exception_code			__exception_code
#endif
#endif

#ifndef EXCEPTION_EXECUTE_HANDLER
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_SEARCH	0
#define EXCEPTION_CONTINUE_EXECUTION	-1
#endif
/*XLATON*/

#define COMNFS_FLAT	0xFFFFFFFF

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM		0x00000001
#define RS_RESTORE		0x00000002
#define RS_DOSARENA		0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;			// low (< 1meg) address of item
    ULONG   RS_Bytes;			// size of item in bytes
    ULONG   RS_CallBack;		// callback, if any (zero if none)
    ULONG   RS_RefData; 		// reference data for callback, if any
    ULONG   RS_HookTable;		// real-mode hook table (zero if none)
    ULONG   RS_Flags;			// 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;	/* # pages in linear address space */
    ULONG DIPhys_Count; 	/* Count of phys pages */
    ULONG DIFree_Count; 	/* Count of free phys pages */
    ULONG DIUnlock_Count;	/* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;	/* Base of pageable address space */
    ULONG DILin_Total_Free;	/* Total Count of free linear pages */

    /*
     *	The following 5 fields are all running totals, kept from the time
     *	the system was started
     */
    ULONG DIPage_Faults;	/* total page faults */
    ULONG DIPage_Ins;		/* calls to pagers to page in a page */
    ULONG DIPage_Outs;		/* calls to pagers to page out a page*/
    ULONG DIPage_Discards;	/* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;	/* instance page faults */

    ULONG DIPagingFileMax;	/* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;	/* # of pages of paging file currently in use */

    ULONG DICommit_Count;	/* Total committed memory, in pages */

    ULONG DIReserved[2];	/* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;	    /* INIT <0> RESERVED */
    ULONG InstLinkB;	    /* INIT <0> RESERVED */
    ULONG InstLinAddr;	    /* Linear address of start of block */
    ULONG InstSize;	    /* Size of block in bytes */
    ULONG InstType;	    /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD	0x100	/* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD	0x200	/* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD	0x400	/* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;	    /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;	    /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400	/* anywhere in private arena */
#define PR_SHARED   0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM   0x80080000	/* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG     0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC   0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008	/* pages are permanently locked */
#define PC_LOCKED   0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR     0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000	/* make pages initially present */
#define PC_STATIC   0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000	/* make pages initially dirty */
#define PC_CACHEDIS 0x00100000  /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT  0x00080000  /* Allocate write through cache pages - new for WDM */
#define PC_PAGEFLUSH 0x00008000 /* Touch device mapped pages on alloc - new for WDM */

#ifdef WRITE_WATCH
#define PC_WRITE_WATCH 0x00200000 /* to request write_watch in this region */
#endif // WRITE_WATCH

/* PageCommitContig additional flags */
#define PCC_ZEROINIT	0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000	/* don't map to any linear address */


/*MTRR type flags */
#define MTRR_UC 0
#define MTRR_WC 1
#define	MTRR_WT 4
#define	MTRR_WP 5
#define	MTRR_WB 6

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS	       0x01
#define PAGE_READONLY	       0x02
#define PAGE_READWRITE	       0x04
#define MEM_COMMIT	     0x1000
#define MEM_RESERVE	     0x2000
#define MEM_FREE	    0x10000
#define MEM_PRIVATE	    0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *	clean - page has not been written to since its last page out
 *	dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *	virgin - page has never been written to since it was committed
 *	tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *	For 32-bit EXE code or read-only data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = 0
 *	  pd_cleanout = 0
 *	  pd_dirtyout = 0
 *	  pd_virginfree = 0
 *    pd_taintedfree = 0
 *    pd_dirty = 0
 *	  pd_type = PD_PAGERONLY
 *
 *	For 32-bit EXE writeable data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 *
 *	For zero-initialized swappable data:
 *
 *	  pd_virginin = routine to zero-fill a page
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *	The following four fields are entry points in the pager which
     *	we call to page in or page out a page.	The following parameters
     *	are passed to the pager during these calls:
     *
     *	ppagerdata - pointer to the pager-specific dword of data
     *		 stored with the virtual page.	The pager is
     *		 free to modify the contents of this dword
     *		 DURING the page in or out, but not afterwards.
     *
     *	ppage - pointer to page going in or out (a ring 0 alias
     *	    to the physical page).  The pager should use this
     *	    address to access the contents of the page.
     *
     *	faultpage - faulting linear page number for page-ins, -1 for
     *		page-outs.  This address should not be accessed
     *		by the pager.  It is provided for information
     *		only.  Note that a single page can be mapped at
     *		more than one linear address because of the
     *		MapIntoV86 and LinMapIntoV86 services.
     *
     *	The pager should return non-0 if the page was successfully
     *	paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *	The pd_*free routines are used to inform the pager when the last
     *	reference to a virtual page controlled by the pager is
     *	decommitted.  A common use of this notification is to
     *	free space in a backing file, or write the page contents
     *	into the backing file.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions, but no return value is recognized.  The "ppage"
     *	and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *	The pd_dirty routine is used to inform the pager when the
     *	memory manager detects that a page has been written to.  The memory
     *	manager does not detect the write at the instant it occurs, so
     *	the pager should not depend upon prompt notification.  A common
     *	use of this notification might be to invalidate cached data.
     *	If the page was dirtied in more than one memory context,
     *	the pager's pd_dirty routine will be called once for each
     *	context.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions except that the "ppage" parameter isn't valid and
     *	no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *	The pd_type field gives the sytem information about the
     *	overcommit characteristics of pages controlled by this pager.
     *	The following are allowable values for the field:
     *
     *	PD_SWAPPER - under some conditions, pages of this type
     *	    may be paged out into the swap file
     *	PD_PAGERONLY - pages controlled by this pager will never
     *	    be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *	    functions perform nested excecution or block using the
     *	    BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *	    specified if the pager does any sort of file i/o to anything
     *	    other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER  0	/* pages need direct accounting in swap file */
#define PD_PAGERONLY	1   /* pages will never be swapped */
#define PD_NESTEXEC 2	/* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

/* XLATOFF */    
#ifndef PAGE
#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#endif
/* XLATON */

#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR	    ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR	    ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR	    ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR	((ULONG) 0x003fffff)
#define MINDOSLADDR	((ULONG) 0x00000000)

#define MAXSYSTEMPAGE	    (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE	    (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE	    (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE	    (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE	    (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE	    (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE	(MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE	(MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE	(1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED	(1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM	(1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS		(1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE	(1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED	(1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM	(1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS		(1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC	(max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC	(max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF
*/

#define ASD_MAX_REF_DATA    256	    // If bigger than this, a checksum is used

struct	_vmmguid {
unsigned long Data1;
unsigned short Data2;
unsigned short Data3;
unsigned char Data4[8];
};

typedef struct _vmmguid VMMGUID;
typedef VMMGUID     *VMMREFIID;

typedef DWORD		ASD_RESULT;

#define ASD_ERROR_NONE	    0x00000000
#define ASD_CHECK_FAIL	    0x00000001	// The flag is set that this failed before
#define ASD_CHECK_SUCCESS   0x00000002	// The flag is set that this succeeded before
#define ASD_CHECK_UNKNOWN   0x00000003	// No flag is set
#define ASD_ERROR_BAD_TIME  0x00000004	// Under cli
#define ASD_REGISTRY_ERROR  0x00000005	// Unknown registry error
#define ASD_CLEAN_BOOT	    0x00000006	// Clean booting fails everything
#define ASD_OUT_OF_MEMORY   0x00000007	// Ran out of memory (extremely rare)
#define ASD_FILE_ERROR	    0x00000008	// Int 21 to flush the info file failed
#define ASD_ALREADY_SET     0x00000009	// ASD_CHECK* done twice on same vgOperation/pRefData
#define ASD_MISSING_CHECK   0x0000000A	// ASD_DONE* on something not set
#define ASD_BAD_PARAMETER   0x0000000B	// Invalid operation, refiid or ref pointer

#define ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	0x00000000
#define ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	0x00000001
#define ASD_OP_CHECK				0x00000002
#define ASD_OP_DONE_AND_SET_SUCCESS		0x00000003
#define ASD_OP_SET_FAIL 			0x00000004
#define ASD_OP_SET_SUCCESS			0x00000005
#define ASD_OP_SET_UNKNOWN			0x00000006
#define ASD_OP_DONE				0x00000007

#define ASD_FLAG_STRING     0x00000001

#ifndef Not_VxD

/******************************************************************************
 *
 *	     EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.	Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000	/* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT	0x0001	    /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.	Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE	    0x0002	/* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT	0x0003	    /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004	/* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT	0x0005	    /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.	SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006	/* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM	0x0007

/*
 *  Second phase of Create_VM.	EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT 	0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE	    0x000A	/* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.	VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B	/* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.	EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM	0x000C	    /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00	/* VM was crashed */
#define VNE_CRASHED	(1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT	    0x01	/* VM was destroyed while active */
#define VNE_NUKED	(1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02	/* Some device failed Create_VM */
#define VNE_CREATEFAIL	    (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03	/* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL	    (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04	/* Some device failed VM_Init */
#define VNE_INITFAIL	    (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT	    0x05
#define VNE_CLOSED	(1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND	0x000D	    /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME	0x000E	    /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.	Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012	/* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY	    0x0013	/* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY	0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP	    0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT	0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP	0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY	0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *	  CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT	0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD	0x001D

/*
 *  Second phase of creating a thread.	EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT	0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * BUGBUG: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN	DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2	    0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2	    0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2	0x0029
#define VM_SUSPEND2	0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2	0x002C
#define DEVICE_REBOOT_NOTIFY2	0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER	0x0030

#define KERNEL32_INITIALIZED	0x0031

#define KERNEL32_SHUTDOWN	0x0032

#define CREATE_PROCESS		0x0033
#define DESTROY_PROCESS 	0x0034

#ifndef WIN40COMPAT
#define SYS_DYNAMIC_DEVICE_REINIT 0x0035
#endif
#define SYS_POWER_DOWN		0x0036

#define MAX_SYSTEM_CONTROL	0x0036

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL 0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

		    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
		    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT	    0x10000000
		    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
		    /* INIT_COMPLETE is broadcast */
		    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
		    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
		    /* All initialization completed */
		    /* System running normally */
		    /* System shutdown initiated */
		    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
		    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
		    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT	    0xE0000000
		    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
		    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
		    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
		    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
		    /* Return to real mode */
		    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
		    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT	    0xFFFFF000
		    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU	    0xFFFFFF00
		    /* REBOOT_PROCESSOR is broadcast */
		    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC		; Used outside this module (default)
;   LOCAL		; Local to this module
;   HIGH_FREQ		; DWORD align procedure
;   SERVICE		; Routine is called via VxDCall
;   ASYNC_SERVICE	    ; Same as "SERVICE" plus routine can
;		    ;	be called under interrupt.
;   HOOK_PROC		; Proc is a handler installed with
;		    ;	with a call to Hook_xxx_Fault
;		    ;	or Hook_Device_Service.  The
;		    ;	following parameter must be
;		    ;	the label of a DWORD location
;		    ;	which will hold the ptr to next
;		    ;	hook proc. e.g.
;
;		   ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG		; Disable Queue_Out call logging
;   NO_PROFILE		; Disable DynaLink profile counts
;   NO_TEST_CLD 	; Disable direction flag check
;
;   TEST_BLOCK		; Trap if in NOBLOCK state
;		    ;  (default if in pageable code seg)
;   TEST_REENTER	    ; Trap if Get_VMM_Reenter_Count != 0
;		    ;  (default for non-async services)
;   NEVER_REENTER	    ; Trap if VMM has been reentered
;   NOT_SWAPPING	    ; Trap if this thread is swapping
;
;   NO_PROLOG		; Disable all prolog tests
;
;   ESP 	    ; Use ESP instead of EBP for stack
;		    ;  frame base
;   PCALL		; pascal calling convention
;   SCALL		; stdcall calling convention
;   FASTCALL		; stdcall, but first 2 parameters are passed in ECX & EDX
;   CCALL		; "C" calling convention
;   ICALL		; default calling convention
;   W32SVC		; Win32 service
;
;   segment type	    ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type	    ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1	;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed	equ 2	    ;; ArgVars were used
??_pf_Entered	equ 4	    ;; EnterProc performed
??_pf_Left  equ 8	;; LeaveProc performed
??_pf_Returned	equ    16		;; Return performed

??_pushed	=	0		;; For WIN31COMPAT
??_align    =	0	;; For WIN31COMPAT
??_ends     equ <>	;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0	    ;; local frame base
    ??_aframe = 0	    ;; argument frame base
    ??_taframe = 0	    ;; true argument frame base
    ??_initaframe = 0	    ;; initial aframe value
    ??_numargs = 0	    ;; number of argvars
    ??_numlocals = 0	    ;; number of localvars
    ??_numlocalsymbols = 0	;; number of local symbols
    ??_procflags = 0	    ;; misc. Enter/LeaveProc flags
    ??_esp = 0		;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0	    ;; number of bytes pushed
    ??_align = 0	    ;; set if proc should be dword aligned
    ??_hook = 0 	;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG	    ;; logging on by default
    ??_profile = DFS_PROFILE	;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD	;; test that direction is clear
ELSE
    ??_log = 0		;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE	;; service profiling on by default
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
    ??_test_cld = 0	    ;; test that direction is clear
ENDIF
    ??_might_block = 0	    ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0	;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0	;; use a prolog by default
    ??_public = 1	    ;; everything's public by default
    ??_cleanoff = 0	    ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0		;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0      ;; only services can be profiled
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif	; ife ??_service

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE 	    ;; if real-mode code segment
	??_prolog_disabled = 1	;; don't do anything stupid
    else		;; else protected mode code segment
	ife ?_PCODE	;; if swappable code
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif	; ife ?_RCODE
    endif	; ife ?_16ICODE
    endif   ; Not_VxD

    if ??_esp
    ;; just return address on stack
    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else
    ;; ret addr and EBP on stack
    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align	; This also aligns the proc
	endif		;   since Profile_Data is a dd

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif   ; Not_VxD

    Name proc near	;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;	     Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall    ;; if no munging
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;	     DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service

    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif

    ;; Phase 7:  Post-label code
    ;;	     <none>
endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call	;; no test, just log
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter	;; no log, just reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif		;if ??_dfs
	endif		; if ??_dfs EQ DFS_TEST_REENTER
	endif		; if ??_dfs EQ DFS_LOG
    endif ; DEBUG
    endif ; Not_VxD
ENDM

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***	ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;	 to indicate that the argument will not be used
;	 by the procedure.
;

ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm

;***	?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***	LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;	 to suppress the usual padding and aligning of variables
;	 PACK is typically used when declaring a bunch of
;	 byte or word variables.  Make sure that the total
;	 size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal

;***	EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***	LeaveProc - removes stack frame on exit
;
;   NOTE:   If there are localvar and ESP kind of stack frame
;	LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;	flag is given.	PRESERVE_FLAGS generates bigger, slower
;	code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;	 the internal stack depth for the local frame.	This is
;	 to allow jumping around the LeaveProc/Return to code
;	 after the LeaveProc/Return to use args/local variables,
;	 but code that uses the stack frame executed after the
;	 LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***	Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***	EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp		;; Masm will provide error msg for us
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***	cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall

;***	pCall - pascal call
;
;   Arguments pushed in pascal order, callee cleans stack
;

pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***	sCall - standard call
;
;   Arguments pushed in "C" order, callee cleans stack,
;   @argc appended to name
;

sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***	fCall - fastcall call
;
;   Arguments pushed in "C" order (except first two parms,
;   which are passed in ECX and EDX), callee cleans stack, and
;   @argc appended to name.
;
;   The only useful value for flags is PRESERVE_FLAGS,
;   which can also be achieved by simply declaring the function
;   as non-standard, like so:
;
;	DeclareNonstandardCcallService <functionname>
;

fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall

;***	iCall - internal routine call
;
;   Set to whatever type we want to use as a default.

iCall	equ <sCall>

;***	PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;	the word FAST if we should prefer speed over size
;
;	The default flag is SMALL, unless the current procedure
;	is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1		;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0 	;; number of dwords on stack (global)
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0		;; establish default
ELSE
    ??_popargs = ??_align EQ 0	;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1		;; size, not speed
    elseifidni <flags>, <FAST>
	??_popargs = 0		;; speed, not size
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0		;; speed, not size
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm

;***	ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;   If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;   This will generate bigger, slower code, so use it only when
;   necessary.

ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref

;***	CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm

;***	SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro	reglist 	;; push those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm

;***	RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist	;; pop those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.	Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *	   S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST	0x00000010
#define HIGH_PRI_DEVICE_BOOST	0x00001000
#define CRITICAL_SECTION_BOOST	0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S	 F O R	 C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT	    0
#define PEF_WAIT_FOR_STI	(1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT	    1
#define PEF_WAIT_NOT_CRIT	(1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT	    2
#define PEF_DONT_UNBOOST	(1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT	    3
#define PEF_ALWAYS_SCHED	(1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT	4
#define PEF_TIME_OUT		(1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT	(1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT	6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT	7
#define PEF_WAIT_IN_PM		(1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT	    8
#define PEF_THREAD_EVENT	(1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT	    10
#define PEF_RING0_EVENT 	(1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	11
#define PEF_WAIT_CRIT	    (1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM    (1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST    (1 << PEF_PROCESS_LAST_BIT)

#define PEF_WAIT_PREEMPTABLE_BIT    14
#define PEF_WAIT_PREEMPTABLE (1 << PEF_WAIT_PREEMPTABLE_BIT)

#define PEF_WAIT_FOR_PASSIVE_BIT	    15
#define	PEF_WAIT_FOR_PASSIVE     (1 << PEF_WAIT_FOR_PASSIVE_BIT)

//
// The next two are equivalent of SHELL_Call_At_Appy_Time and ExQueueWorkItem,
// they are mostly to be used by _Set_Global_Time_Out_Ex. No other flag can be
// set with them. Note that the dispatching of the callback of these two new
// PEF (with both Call_Restricted_Event and _Set_Global_Time_Out_Ex) follow
// the original convention but EDX (the ref data) is CDECL pushed/pop on the
// stack, so that the callback function can be a standard
// VOID CDECL FOO(ULONG BAR);
//
	
#define PEF_WAIT_FOR_APPY_BIT	    16
#define	PEF_WAIT_FOR_APPY     (1 << PEF_WAIT_FOR_APPY_BIT)

#define PEF_WAIT_FOR_WORKER_BIT	    17
#define	PEF_WAIT_FOR_WORKER     (1 << PEF_WAIT_FOR_WORKER_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT	     PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK	 PEF_WAIT_NOT_NESTED_EXEC

//
// If you may want to call CONFIGMG synchronously at some point.
//
#define	PEF_WAIT_FOR_CONFIGMG_CALLABLE	PEF_WAIT_FOR_WORKER

//
// If you will want to call CONFIGMG synchronously (slower callback, but no
// context switch in CONFIGMG).
//
#define	PEF_WAIT_FOR_CONFIGMG_QUICK	PEF_WAIT_FOR_APPY

/******************************************************************************
 *	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *			     E N T E R _ M U T E X
 *	       A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT	0
#define BLOCK_SVC_INTS		(1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT	1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT	    2
#define BLOCK_ENABLE_INTS	(1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT		3
#define BLOCK_POLL	    (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT		4
#define BLOCK_THREAD_IDLE		(1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT	5
#define BLOCK_FORCE_SVC_INTS	    (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;		/* Client's EDI */
    ULONG Client_ESI;		/* Client's ESI */
    ULONG Client_EBP;		/* Client's EBP */
    ULONG Client_res0;		/* ESP at pushall */
    ULONG Client_EBX;		/* Client's EBX */
    ULONG Client_EDX;		/* Client's EDX */
    ULONG Client_ECX;		/* Client's ECX */
    ULONG Client_EAX;		/* Client's EAX */
    ULONG Client_Error; 	/* Dword error code */
    ULONG Client_EIP;		/* EIP */
    USHORT Client_CS;		/* CS */
    USHORT Client_res1; 	/*   (padding) */
    ULONG Client_EFlags;	/* EFLAGS */
    ULONG Client_ESP;		/* ESP */
    USHORT Client_SS;		/* SS */
    USHORT Client_res2; 	/*   (padding) */
    USHORT Client_ES;		/* ES */
    USHORT Client_res3; 	/*   (padding) */
    USHORT Client_DS;		/* DS */
    USHORT Client_res4; 	/*   (padding) */
    USHORT Client_FS;		/* FS */
    USHORT Client_res5; 	/*   (padding) */
    USHORT Client_GS;		/* GS */
    USHORT Client_res6; 	/*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;		/* Client's DI */
    USHORT Client_res13;	/*   (padding) */
    USHORT Client_SI;		/* Client's SI */
    USHORT Client_res14;	/*   (padding) */
    USHORT Client_BP;		/* Client's BP */
    USHORT Client_res15;	/*   (padding) */
    ULONG Client_res16; 	/* ESP at pushall */
    USHORT Client_BX;		/* Client's BX */
    USHORT Client_res17;	/*   (padding) */
    USHORT Client_DX;		/* Client's DX */
    USHORT Client_res18;	/*   (padding) */
    USHORT Client_CX;		/* Client's CX */
    USHORT Client_res19;	/*   (padding) */
    USHORT Client_AX;		/* Client's AX */
    USHORT Client_res20;	/*   (padding) */
    ULONG Client_res21; 	/* Dword error code */
    USHORT Client_IP;		/* Client's IP */
    USHORT Client_res22;	/*   (padding) */
    ULONG Client_res23; 	/* CS */
    USHORT Client_Flags;	/* Client's flags (low) */
    USHORT Client_res24;	/*   (padding) */
    USHORT Client_SP;		/* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];	/* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;		/* Client's BL */
    UCHAR Client_BH;		/* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;		/* Client's DL */
    UCHAR Client_DH;		/* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;		/* Client's CL */
    UCHAR Client_CH;		/* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;		/* Client's AL */
    UCHAR Client_AH;		/* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc	  CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0	/* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT	0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;   Declare services as conforming to the C calling convention
;   for parameter-passing, but *not* conforming to the C calling
;   convention for register usage.
;
;   Services which do not use the C calling convention for
;   parameter-passing need not be declared as nonstandard.
;
;   arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm

;
; The following VMM services are nonstandard:
;	_BlockOnID and _LocalizeSprintf modify no registers except flags.
;	_SetLastV86Page modifies no registers except EAX and flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints	; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

WDMCall MACRO P, Param, flags
    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    mov	eax,WDM@@&P
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

WDMJmp	MACRO P, Param
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to WDMJmp>
    endif
    mov	eax, WDM@@&P+WDM_DL_Jmp_Mask
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ENDM

WDM_DL_Jmp_Mask	EQU	80000000h
WDM_DL_Jmp_Bit	EQU	31

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;VxD_LOCKED_CODE_SEG	defines start of always present code segment
;VxD_LOCKED_CODE_ENDS	defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG	defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DB1CODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DB1CODE    ENDS
	ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM


;   Protected mode initialization data

VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DB2DATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DB2DATA    ENDS
	ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A	    /* 3.10 */
#else  // WIN31COMPAT

#ifdef WIN40COMPAT
#define DDK_VERSION 0x400	    /* 4.00 */
#else  // WIN40COMPAT

#define DDK_VERSION 0x40A	    /*Memphis is 4.1 */

#endif // WIN40COMPAT

#endif // WIN31COMPAT

#endif // DDK_VERSION

struct VxD_Desc_Block {
    ULONG DDB_Next;	    /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;	/* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;		/* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];		/* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;	/* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;	/* Offset of control procedure */
    ULONG DDB_V86_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;	    /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;	    /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;	/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;	/* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;	/* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;	/* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block	    *PVMMDDB;
typedef PVMMDDB 	    *PPVMMDDB;

#ifndef Not_VxD

/* XLATOFF */

typedef (_cdecl * VXD_C_SERVICE)();
typedef VXD_C_SERVICE VXD_SERVICE_TABLE[];

#define	Declare_Virtual_Device(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data) \
struct VxD_Desc_Block name##_DDB={ \
0, \
0, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
0, \
0, \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

#define	Declare_Virtual_Device_With_Table(quote_name, name, ctrl_proc, device_num, init_order, V86_proc, PM_proc, ref_data, table_ptr) \
struct VxD_Desc_Block name##_DDB={ \
0, \
DDK_VERSION, \
device_num, \
DDK_VERSION >> 8, \
DDK_VERSION & 0XFF, \
0, \
quote_name, \
init_order, \
(ULONG)ctrl_proc, \
(ULONG)V86_proc, \
(ULONG)PM_proc, \
0, \
0, \
ref_data, \
(ULONG)table_ptr, \
(ULONG)(sizeof(table_ptr)/sizeof(VXD_C_SERVICE)), \
0, \
0, \
sizeof(struct VxD_Desc_Block), \
'Rsv1', \
'Rsv2', \
'Rsv3' \
};

/* XLATON */

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE	    (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE	    (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT	    14
#define DDB_HAS_WIN32_SVCS	(1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT	15
#define DDB_DYNAMIC_VXD 	(1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED	    (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc 	    ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT	0x014

#define OUTPUT_BIT  2
#define OUTPUT	    (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT	4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT	5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO	    (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT	7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT	8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT	0x10		/* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw	Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a return.  If non-debugging version then the
;	   specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   CallJmp -- Call procedure then jump to label.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a jmp.  If non-debugging version then the desired return
;          address will be pushed on the stack and the specified label will
;          be jumped to.
;
;   PARAMETERS:
;   Function_Name = Procedure to be called
;   Return_Label  = Address to return to
;
;   EXIT:
;
;------------------------------------------------------------------------------
EndDoc

CallJmp MACRO Function_Name, Return_Label
IFDEF DEBUG
    call    Function_Name
    jmp     Return_Label
ELSE
    push    Return_Label
    jmp     Function_Name
ENDIF
    ENDM


BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm
*/

/*XLATOFF*/
#define Load_FS VMMCall(Load_FS_Service)
/*XLATON*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0	/* loaded */
#define DUPLICATE_DEVICE_ID	(1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1	/* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F	    (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT	    2	/* in the INT 2F device list */
#define LOADING_FROM_INT2F	(1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK	    0	/* load protected mode portion */
#define ABORT_DEVICE_LOAD   1	/* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2	/* fatal-error: abort load of Win386 */
#define DEVICE_NOT_NEEDED   3	/* don't load protected mode portion */
				/* b/c the driver's presence is not needed */



#define NO_FAIL_MESSAGE_BIT 15	/* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0	/* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING	1   /* search for next string */
#define LDRSRV_RESERVED 	2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3	/* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT	4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5	/* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6	/* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO	    7	/* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey	0x100
#define LDRSRV_RegCreateKey	0x101
#define LDRSRV_RegCloseKey	0x102
#define LDRSRV_RegDeleteKey	0x103
#define LDRSRV_RegSetValue	0x104
#define LDRSRV_RegQueryValue	    0x105
#define LDRSRV_RegEnumKey	0x106
#define LDRSRV_RegDeleteValue	    0x107
#define LDRSRV_RegEnumValue	0x108
#define LDRSRV_RegQueryValueEx	    0x109
#define LDRSRV_RegSetValueEx	    0x10A
#define LDRSRV_RegFlushKey	0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT	1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED	2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE	    3	/* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*	    Also Init type objects should be added to the second part of the
*	    list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ	-1

#define LCODE_OBJ	0x01
#define LDATA_OBJ	0x02
#define PCODE_OBJ	0x03
#define PDATA_OBJ	0x04
#define SCODE_OBJ	0x05
#define SDATA_OBJ	0x06
#define CODE16_OBJ	0x07
#define LMSG_OBJ	0x08
#define PMSG_OBJ	0x09

#define DBOC_OBJ    0x0B
#define DBOD_OBJ    0x0C

#define PLCODE_OBJ	0x0D
#define PPCODE_OBJ	0x0F

#define ICODE_OBJ	0x11
#define IDATA_OBJ	0x12
#define ICODE16_OBJ	0x13
#define IMSG_OBJ	0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *	Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT	    0	/* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT	    1	/* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT	    2	/* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT	    3	/* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT	    4	/* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT	    31	/* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *		PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE	    0x1000	/* page size */

/******************************************************************************
 *
 *		PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES	    (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER	    (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC	    (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM	    0
#define PG_SYS	    1
#define PG_RESERVED1	2
#define PG_PRIVATE  3
#define PG_RESERVED2	4
#define PG_RELOCK   5	    /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES	    0x080	/* present in memory */
#define D_NOTPRES   0	    /* not present in memory */

#define D_DPL0	    0	    /* Ring 0 */
#define D_DPL1	    0x020	/* Ring 1 */
#define D_DPL2	    0x040	/* Ring 2 */
#define D_DPL3	    0x060	/* Ring 3 */

#define D_SEG	    0x010	/* Segment descriptor */
#define D_CTRL	    0	    /* Control descriptor */

#define D_GRAN_BYTE 0x000	/* Segment length is byte granular */
#define D_GRAN_PAGE 0x080	/* Segment length is page granular */
#define D_DEF16     0x000	/* Default operation size is 16 bits */
#define D_DEF32     0x040	/* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE	    0x08	/* code */
#define D_DATA	    0	    /* data */

#define D_X	0	/* if code, exec only */
#define D_RX	    0x02	/* if code, readable */
#define D_C	0x04	    /* if code, conforming */

#define D_R	0	/* if data, read only */
#define D_W	0x02	    /* if data, writable */
#define D_ED	    0x04	/* if data, expand down */

#define D_ACCESSED  1	    /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE	(D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK	0xFFF8	    /* selector index */
#define SEL_LOW_MASK	0xF8	    /* mask for low byte of sel indx */
#define TABLE_MASK  0x04	/* table bit */
#define RPL_MASK    0x03	/* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()	{__asm cli}

#define SAVE_FLAGS(flags) {\
    {__asm pushfd}; \
    {__asm pop flags}}

#define RESTORE_FLAGS(flags) {\
    {__asm push flags}; \
    {__asm popfd}}

#define IO_Delay() {\
    {__asm _emit 0xeb __asm _emit 0x00}; \
    }

#define Touch_Register(Register) {_asm xor Register, Register}

typedef DWORD	HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)	// turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;	// count of milliseconds

#pragma warning (default:4209)	// turn on redefine warning (with basedef.h)

typedef DWORD	VMM_SEMAPHORE;

typedef struct _HEAP_ALLOCATE_INFO {
    DWORD   StructSize;
    PVOID   CallerAddress;
    ULONG   Tag;
} HEAP_ALLOCATE_INFO, *PHEAP_ALLOCATE_INFO;

PVOID
_stdcall
HeapAllocateEx(
    ULONG cBytes,
    PVOID Reserved,
    PHEAP_ALLOCATE_INFO AllocateInfo,
    ULONG Flags
    );

VOID
_stdcall
HeapFreeEx(
    PVOID MemBlk,
    PVOID Reserved
    );

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\pshpack1.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    pshpack1.h

Abstract:

    This file turns 1 byte packing of structures on.  (That is, it disables
    automatic alignment of structure fields.)  An include file is needed
    because various compilers do this in different ways.  For Microsoft
    compatible compilers, this files uses the push option to the pack pragma
    so that the poppack.h include file can restore the previous packing
    reliably.

    The file poppack.h is the complement to this file.

--*/

#if ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
#if ( _MSC_VER >= 800 ) || defined(_PUSHPOP_SUPPORTED)
#pragma warning(disable:4103)
#if !(defined( MIDL_PASS )) || defined( __midl )
#pragma pack(push)
#endif
#pragma pack(1)
#else
#pragma pack(1)
#endif
#endif // ! (defined(lint) || defined(_lint) || defined(RC_INVOKED) || defined(IS_16))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)
VWIN32_StdCall_Service	(VWIN32_ConvertNtTimeout, 1)
VWIN32_Service	(_VWIN32_SetWin32EventBoostPriority)
VWIN32_Service	(_VWIN32_GetRing3Flat32Selectors)
VWIN32_Service	(_VWIN32_GetCurThreadCondition)
VWIN32_Service  (VWIN32_Init_FP)
VWIN32_StdCall_Service  (R0SetWaitableTimer, 5)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning

PVOID VXDINLINE
VWIN32OpenVxDHandle(ULONG Handle,ULONG dwType)
{
    PVOID ul;
    
    _asm push [dwType]
    _asm push [Handle]
    VxDCall(_VWIN32_OpenVxDHandle)
    _asm add esp, 8
    _asm mov [ul], eax
	    
    return(ul);
}

WORD VXDINLINE
VWIN32_Get_Version(VOID)
{
	WORD	w;
	VxDCall(VWIN32_Get_Version);
	_asm mov [w], ax
	return(w);
}

/*XLATON*/

#endif // Not_VxD

//
// For _VWIN32_GetCurThreadCondition
//
#define	THREAD_CONDITION_DOS_BOX		0x00000000l
#define	THREAD_CONDITION_V86_NEST		0x00000001l
#define	THREAD_CONDITION_WDM			0x00000002l
#define	THREAD_CONDITION_INDETERMINATE		0x00000003l
#define	THREAD_CONDITION_LOCKED_STACK		0x00000004l
#define	THREAD_CONDITION_PURE_WIN16		0x00000005l
#define	THREAD_CONDITION_THUNKED_WIN16		0x00000006l
#define	THREAD_CONDITION_THUNKED_WIN32		0x00000007l
#define	THREAD_CONDITION_PURE_WIN32		0x00000008l
#define	THREAD_CONDITION_APPY_TIME		0x00000009l
#define	THREAD_CONDITION_RING0_APPY_TIME	0x0000000Al
#define	THREAD_CONDITION_EXIT			0x0000000Bl
#define	THREAD_CONDITION_INVALID_FLAGS		0xFFFFFFFFl

#define	THREAD_CONDITION_NORMAL_FLAGS		0x00000000l

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\vmmreg.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 *   Date:	03-June-1993
 *
 *   Author:	Nagara
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already
#define REG_SZ		0x0001
#endif
#ifndef REG_BINARY	// define only if not there already
#define REG_BINARY	0x0003
#endif
#ifndef REG_DWORD	// define only if not there already
#define	REG_DWORD	0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#endif

#ifndef ERROR_REGISTRY_IO_FAILED
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif 


#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\vmm.inc ===
ifndef _VMM_
_VMM_	EQU	1
FALSE	EQU	0
VMM_TRUE	EQU	(NOT FALSE)
DEBLEVELRETAIL	EQU	0
DEBLEVELNORMAL	EQU	1
DEBLEVELMAX	EQU	2
ifndef DEBLEVEL
ifdef DEBUG
DEBLEVEL	EQU	DEBLEVELNORMAL
else
DEBLEVEL	EQU	DEBLEVELRETAIL
endif
endif
ifndef WIN31COMPAT
WIN40SERVICES	EQU	1
WIN403SERVICES	EQU	1
endif
ifndef WIN40COMPAT
WIN41SERVICES	EQU	1
endif
ifdef MASM6
ifndef NO_MASM6_OPTIONS



    option oldmacros
ifndef	NEWSTRUCTS
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif




IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF

UNDEFINED_DEVICE_ID	EQU	00000H
VMM_DEVICE_ID	EQU	00001H
DEBUG_DEVICE_ID	EQU	00002H
VPICD_DEVICE_ID	EQU	00003H
VDMAD_DEVICE_ID	EQU	00004H
VTD_DEVICE_ID	EQU	00005H
V86MMGR_DEVICE_ID	EQU	00006H
PAGESWAP_DEVICE_ID	EQU	00007H
PARITY_DEVICE_ID	EQU	00008H
REBOOT_DEVICE_ID	EQU	00009H
VDD_DEVICE_ID	EQU	0000AH
VSD_DEVICE_ID	EQU	0000BH
VMD_DEVICE_ID	EQU	0000CH
VKD_DEVICE_ID	EQU	0000DH
VCD_DEVICE_ID	EQU	0000EH
VPD_DEVICE_ID	EQU	0000FH
BLOCKDEV_DEVICE_ID	EQU	00010H
VMCPD_DEVICE_ID	EQU	00011H
EBIOS_DEVICE_ID	EQU	00012H
BIOSXLAT_DEVICE_ID	EQU	00013H
VNETBIOS_DEVICE_ID	EQU	00014H
DOSMGR_DEVICE_ID	EQU	00015H
WINLOAD_DEVICE_ID	EQU	00016H
SHELL_DEVICE_ID	EQU	00017H
VMPOLL_DEVICE_ID	EQU	00018H
VPROD_DEVICE_ID	EQU	00019H
DOSNET_DEVICE_ID	EQU	0001AH
VFD_DEVICE_ID	EQU	0001BH
VDD2_DEVICE_ID	EQU	0001CH
WINDEBUG_DEVICE_ID	EQU	0001DH
TSRLOAD_DEVICE_ID	EQU	0001EH
BIOSHOOK_DEVICE_ID	EQU	0001FH
INT13_DEVICE_ID	EQU	00020H
PAGEFILE_DEVICE_ID	EQU	00021H
SCSI_DEVICE_ID	EQU	00022H
MCA_POS_DEVICE_ID	EQU	00023H
SCSIFD_DEVICE_ID	EQU	00024H
VPEND_DEVICE_ID	EQU	00025H
APM_DEVICE_ID	EQU	00026H
VPOWERD_DEVICE_ID	EQU	APM_DEVICE_ID
VXDLDR_DEVICE_ID	EQU	00027H
NDIS_DEVICE_ID	EQU	00028H
BIOS_EXT_DEVICE_ID	EQU	00029H
VWIN32_DEVICE_ID	EQU	0002AH
VCOMM_DEVICE_ID	EQU	0002BH
SPOOLER_DEVICE_ID	EQU	0002CH
WIN32S_DEVICE_ID	EQU	0002DH
DEBUGCMD_DEVICE_ID	EQU	0002EH
CONFIGMG_DEVICE_ID	EQU	00033H
DWCFGMG_DEVICE_ID	EQU	00034H
SCSIPORT_DEVICE_ID	EQU	00035H
VFBACKUP_DEVICE_ID	EQU	00036H
ENABLE_DEVICE_ID	EQU	00037H
VCOND_DEVICE_ID	EQU	00038H
ISAPNP_DEVICE_ID	EQU	0003CH
BIOS_DEVICE_ID	EQU	0003DH
IFSMgr_Device_ID	EQU	00040H
VCDFSD_DEVICE_ID	EQU	00041H
MRCI2_DEVICE_ID	EQU	00042H
PCI_DEVICE_ID	EQU	00043H
PELOADER_DEVICE_ID	EQU	00044H
EISA_DEVICE_ID	EQU	00045H
DRAGCLI_DEVICE_ID	EQU	00046H
DRAGSRV_DEVICE_ID	EQU	00047H
PERF_DEVICE_ID	EQU	00048H
AWREDIR_DEVICE_ID	EQU	00049H
DDS_DEVICE_ID	EQU	0004AH
NTKERN_DEVICE_ID	EQU	0004BH
VDOSKEYD_DEVICE_ID	EQU	0004BH
ACPI_DEVICE_ID	EQU	0004CH
UDF_DEVICE_ID	EQU	0004DH
SMCLIB_DEVICE_ID	EQU	0004EH
ETEN_Device_ID	EQU	00060H
CHBIOS_Device_ID	EQU	00061H
VMSGD_Device_ID	EQU	00062H
VPPID_Device_ID	EQU	00063H
VIME_Device_ID	EQU	00064H
VHBIOSD_Device_ID	EQU	00065H
BASEID_FOR_NAMEBASEDVXD	EQU	0f000H
BASEID_FOR_NAMEBASEDVXD_MASK	EQU	0fffH
VMM_INIT_ORDER	EQU	000000000H
DEBUG_INIT_ORDER	EQU	000000000H
DEBUGCMD_INIT_ORDER	EQU	000000000H
PERF_INIT_ORDER	EQU	000900000H
APM_INIT_ORDER	EQU	001000000H
VPOWERD_INIT_ORDER	EQU	APM_INIT_ORDER
BIOSHOOK_INIT_ORDER	EQU	006000000H
VPROD_INIT_ORDER	EQU	008000000H
VPICD_INIT_ORDER	EQU	00C000000H
VTD_INIT_ORDER	EQU	014000000H
VWIN32_INIT_ORDER	EQU	014100000H
VXDLDR_INIT_ORDER	EQU	016000000H
NTKERN_INIT_ORDER	EQU	016200000H
CONFIGMG_INIT_ORDER	EQU	016400000H
ENUMERATOR_INIT_ORDER	EQU	016800000H
ISAPNP_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
EISA_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
PCI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER
BIOS_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+1
ACPI_INIT_ORDER	EQU	ENUMERATOR_INIT_ORDER+2
VCDFSD_INIT_ORDER	EQU	016F00000H
IOS_INIT_ORDER	EQU	017000000H
PAGEFILE_INIT_ORDER	EQU	018000000H
PAGESWAP_INIT_ORDER	EQU	01C000000H
PARITY_INIT_ORDER	EQU	020000000H
REBOOT_INIT_ORDER	EQU	024000000H
EBIOS_INIT_ORDER	EQU	026000000H
VDD_INIT_ORDER	EQU	028000000H
VSD_INIT_ORDER	EQU	02C000000H
VCD_INIT_ORDER	EQU	030000000H
COMMDRVR_INIT_ORDER	EQU	(VCD_INIT_ORDER-1)
PRTCL_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-2)
MODEM_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-3)
PORT_INIT_ORDER	EQU	(COMMDRVR_INIT_ORDER-4)
VMD_INIT_ORDER	EQU	034000000H
VKD_INIT_ORDER	EQU	038000000H
VPD_INIT_ORDER	EQU	03C000000H
BLOCKDEV_INIT_ORDER	EQU	040000000H
MCA_POS_INIT_ORDER	EQU	041000000H
SCSIFD_INIT_ORDER	EQU	041400000H
SCSIMASTER_INIT_ORDER	EQU	041800000H
INT13_INIT_ORDER	EQU	042000000H
VMCPD_INIT_ORDER	EQU	048000000H
BIOSXLAT_INIT_ORDER	EQU	050000000H
VNETBIOS_INIT_ORDER	EQU	054000000H
DOSMGR_INIT_ORDER	EQU	058000000H
DOSNET_INIT_ORDER	EQU	05C000000H
WINLOAD_INIT_ORDER	EQU	060000000H
VMPOLL_INIT_ORDER	EQU	064000000H
UNDEFINED_INIT_ORDER	EQU	080000000H
VCOND_INIT_ORDER	EQU	UNDEFINED_INIT_ORDER
WINDEBUG_INIT_ORDER	EQU	081000000H
VDMAD_INIT_ORDER	EQU	090000000H
V86MMGR_INIT_ORDER	EQU	0A0000000H
IFSMgr_Init_Order	EQU	10000H+V86MMGR_Init_Order
FSD_Init_Order	EQU	00100H+IFSMgr_Init_Order
VFD_INIT_ORDER	EQU	50000H+IFSMgr_Init_Order
UNDEF_TOUCH_MEM_INIT_ORDER	EQU	0A8000000H
SHELL_INIT_ORDER	EQU	0B0000000H






IO_Delay    macro
jmp $+2
ENDM

VXD_FAILURE	EQU	0
VXD_SUCCESS	EQU	1

Pushad_Struc	STRUC
Pushad_EDI	DD	?
Pushad_ESI	DD	?
Pushad_EBP	DD	?
Pushad_ESP	DD	?
Pushad_EBX	DD	?
Pushad_EDX	DD	?
Pushad_ECX	DD	?
Pushad_EAX	DD	?
Pushad_Struc	ENDS
ifndef Not_VxD
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS





IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF


_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS


_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM

    ENDM

MakeCodeSeg <L0CKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM











DefLockableCodeBegin MACRO name, private
VxD_L0CKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_L0CKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM









DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
ifdef BLD_COFF
	DD	?
endif
VxD_LOCKABLE_END_CODE_ENDS
    ENDM





CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM






MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM






MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM



_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS


_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS


_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS


_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS


_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS


_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS


_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS


_DB0START   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB0START   ENDS


_DB1CODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB1CODE    ENDS


_DB2DATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DB2DATA    ENDS

if DEBLEVEL

_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS


_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS


_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif


_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS


_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DB0START, _DB1CODE, _DB2DATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc





































EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE



IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM




End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


















Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM










End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM











Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM












Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM







Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc

















EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h


cb_s	STRUC
CB_VM_Status	DD	?
CB_High_Linear	DD	?
CB_Client_Pointer	DD	?
CB_VMID	DD	?
CB_Signature	DD	?
cb_s	ENDS
VMCB_ID	EQU	62634D56H
VMSTAT_EXCLUSIVE_BIT	EQU	00H
VMSTAT_EXCLUSIVE	EQU	(1 SHL VMSTAT_EXCLUSIVE_BIT)
VMSTAT_BACKGROUND_BIT	EQU	01H
VMSTAT_BACKGROUND	EQU	(1 SHL VMSTAT_BACKGROUND_BIT)
VMSTAT_CREATING_BIT	EQU	02H
VMSTAT_CREATING	EQU	(1 SHL VMSTAT_CREATING_BIT)
VMSTAT_SUSPENDED_BIT	EQU	03H
VMSTAT_SUSPENDED	EQU	(1 SHL VMSTAT_SUSPENDED_BIT)
VMSTAT_NOT_EXECUTEABLE_BIT	EQU	04H
VMSTAT_NOT_EXECUTEABLE	EQU	(1 SHL VMSTAT_NOT_EXECUTEABLE_BIT)
VMSTAT_PM_EXEC_BIT	EQU	05H
VMSTAT_PM_EXEC	EQU	(1 SHL VMSTAT_PM_EXEC_BIT)
VMSTAT_PM_APP_BIT	EQU	06H
VMSTAT_PM_APP	EQU	(1 SHL VMSTAT_PM_APP_BIT)
VMSTAT_PM_USE32_BIT	EQU	07H
VMSTAT_PM_USE32	EQU	(1 SHL VMSTAT_PM_USE32_BIT)
VMSTAT_VXD_EXEC_BIT	EQU	08H
VMSTAT_VXD_EXEC	EQU	(1 SHL VMSTAT_VXD_EXEC_BIT)
VMSTAT_HIGH_PRI_BACK_BIT	EQU	09H
VMSTAT_HIGH_PRI_BACK	EQU	(1 SHL VMSTAT_HIGH_PRI_BACK_BIT)
VMSTAT_BLOCKED_BIT	EQU	0AH
VMSTAT_BLOCKED	EQU	(1 SHL VMSTAT_BLOCKED_BIT)
VMSTAT_AWAKENING_BIT	EQU	0BH
VMSTAT_AWAKENING	EQU	(1 SHL VMSTAT_AWAKENING_BIT)
VMSTAT_PAGEABLEV86BIT	EQU	0CH
VMSTAT_PAGEABLEV86_BIT	EQU	VMSTAT_PAGEABLEV86BIT
VMSTAT_PAGEABLEV86	EQU	(1 SHL VMSTAT_PAGEABLEV86BIT)
VMSTAT_V86INTSLOCKEDBIT	EQU	0DH
VMSTAT_V86INTSLOCKED_BIT	EQU	VMSTAT_V86INTSLOCKEDBIT
VMSTAT_V86INTSLOCKED	EQU	(1 SHL VMSTAT_V86INTSLOCKEDBIT)
VMSTAT_IDLE_TIMEOUT_BIT	EQU	0EH
VMSTAT_IDLE_TIMEOUT	EQU	(1 SHL VMSTAT_IDLE_TIMEOUT_BIT)
VMSTAT_IDLE_BIT	EQU	0FH
VMSTAT_IDLE	EQU	(1 SHL VMSTAT_IDLE_BIT)
VMSTAT_CLOSING_BIT	EQU	10H
VMSTAT_CLOSING	EQU	(1 SHL VMSTAT_CLOSING_BIT)
VMSTAT_TS_SUSPENDED_BIT	EQU	11H
VMSTAT_TS_SUSPENDED	EQU	(1 SHL VMSTAT_TS_SUSPENDED_BIT)
VMSTAT_TS_MAXPRI_BIT	EQU	12H
VMSTAT_TS_MAXPRI	EQU	(1 SHL VMSTAT_TS_MAXPRI_BIT)
VMSTAT_USE32_MASK	EQU	(VMSTAT_PM_USE32 OR VMSTAT_VXD_EXEC)

tcb_s	STRUC
TCB_Flags	DD	?
TCB_Reserved1	DD	?
TCB_Reserved2	DD	?
TCB_Signature	DD	?
TCB_ClientPtr	DD	?
TCB_VMHandle	DD	?
TCB_ThreadId	DW	?
TCB_PMLockOrigSS	DW	?
TCB_PMLockOrigESP	DD	?
TCB_PMLockOrigEIP	DD	?
TCB_PMLockStackCount	DD	?
TCB_PMLockOrigCS	DW	?
TCB_PMPSPSelector	DW	?
TCB_ThreadType	DD	?
TCB_pad1	DW	?
TCB_pad2	DB	?
TCB_extErrLocus	DB	?
TCB_extErr	DW	?
TCB_extErrAction	DB	?
TCB_extErrClass	DB	?
TCB_extErrPtr	DD	?
tcb_s	ENDS
SCHED_OBJ_ID_THREAD	EQU	42434854H
THFLAG_SUSPENDED_BIT	EQU	03H
THFLAG_SUSPENDED	EQU	(1 SHL THFLAG_SUSPENDED_BIT)
THFLAG_NOT_EXECUTEABLE_BIT	EQU	04H
THFLAG_NOT_EXECUTEABLE	EQU	(1 SHL THFLAG_NOT_EXECUTEABLE_BIT)
THFLAG_THREAD_CREATION_BIT	EQU	08H
THFLAG_THREAD_CREATION	EQU	(1 SHL THFLAG_THREAD_CREATION_BIT)
THFLAG_THREAD_BLOCKED_BIT	EQU	0AH
THFLAG_THREAD_BLOCKED	EQU	(1 SHL THFLAG_THREAD_BLOCKED_BIT)
THFLAG_RING0_THREAD_BIT	EQU	1CH
THFLAG_RING0_THREAD	EQU	(1 SHL THFLAG_RING0_THREAD_BIT)
THFLAG_ASYNC_THREAD_BIT	EQU	1FH
THFLAG_ASYNC_THREAD	EQU	(1 SHL THFLAG_ASYNC_THREAD_BIT)
THFLAG_CHARSET_BITS	EQU	10H
THFLAG_CHARSET_MASK	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_ANSI	EQU	(0 SHL THFLAG_CHARSET_BITS)
THFLAG_OEM	EQU	(1 SHL THFLAG_CHARSET_BITS)
THFLAG_UNICODE	EQU	(2 SHL THFLAG_CHARSET_BITS)
THFLAG_RESERVED	EQU	(3 SHL THFLAG_CHARSET_BITS)
THFLAG_EXTENDED_HANDLES_BIT	EQU	12H
THFLAG_EXTENDED_HANDLES	EQU	(1 SHL THFLAG_EXTENDED_HANDLES_BIT)
THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT	EQU	13H
THFLAG_OPEN_AS_IMMOVABLE_FILE	EQU	(1 SHL THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

pmcb_s	STRUC
PMCB_Flags	DD	?
PMCB_Parent	DD	?
pmcb_s	ENDS

VMFaultInfo	STRUC
VMFI_EIP	DD	?
VMFI_CS	DW	?
VMFI_Ints	DW	?
VMFaultInfo	ENDS
Begin_Service_Table VMM, VMM
VMM_Service  Get_VMM_Version, LOCAL
VMM_Service  Get_Cur_VM_Handle
VMM_Service  Test_Cur_VM_Handle
VMM_Service  Get_Sys_VM_Handle
VMM_Service  Test_Sys_VM_Handle
VMM_Service  Validate_VM_Handle
VMM_Service  Get_VMM_Reenter_Count
VMM_Service  Begin_Reentrant_Execution
VMM_Service  End_Reentrant_Execution
VMM_Service  Install_V86_Break_Point
VMM_Service  Remove_V86_Break_Point
VMM_Service  Allocate_V86_Call_Back
VMM_Service  Allocate_PM_Call_Back
VMM_Service  Call_When_VM_Returns
VMM_Service  Schedule_Global_Event
VMM_Service  Schedule_VM_Event
VMM_Service  Call_Global_Event
VMM_Service  Call_VM_Event
VMM_Service  Cancel_Global_Event
VMM_Service  Cancel_VM_Event
VMM_Service  Call_Priority_VM_Event
VMM_Service  Cancel_Priority_VM_Event
VMM_Service  Get_NMI_Handler_Addr
VMM_Service  Set_NMI_Handler_Addr
VMM_Service  Hook_NMI_Event
VMM_Service  Call_When_VM_Ints_Enabled
VMM_Service  Enable_VM_Ints
VMM_Service  Disable_VM_Ints
VMM_Service  Map_Flat
VMM_Service  Map_Lin_To_VM_Addr
VMM_Service  Adjust_Exec_Priority
VMM_Service  Begin_Critical_Section
VMM_Service  End_Critical_Section
VMM_Service  End_Crit_And_Suspend
VMM_Service  Claim_Critical_Section
VMM_Service  Release_Critical_Section
VMM_Service  Call_When_Not_Critical
VMM_Service  Create_Semaphore
VMM_Service  Destroy_Semaphore
VMM_Service  Wait_Semaphore
VMM_Service  Signal_Semaphore
VMM_Service  Get_Crit_Section_Status
VMM_Service  Call_When_Task_Switched
VMM_Service  Suspend_VM
VMM_Service  Resume_VM
VMM_Service  No_Fail_Resume_VM
VMM_Service  Nuke_VM
VMM_Service  Crash_Cur_VM
VMM_Service  Get_Execution_Focus
VMM_Service  Set_Execution_Focus
VMM_Service  Get_Time_Slice_Priority
VMM_Service  Set_Time_Slice_Priority
VMM_Service  Get_Time_Slice_Granularity
VMM_Service  Set_Time_Slice_Granularity
VMM_Service  Get_Time_Slice_Info
VMM_Service  Adjust_Execution_Time
VMM_Service  Release_Time_Slice
VMM_Service  Wake_Up_VM
VMM_Service  Call_When_Idle
VMM_Service  Get_Next_VM_Handle
VMM_Service  Set_Global_Time_Out
VMM_Service  Set_VM_Time_Out
VMM_Service  Cancel_Time_Out
VMM_Service  Get_System_Time
VMM_Service  Get_VM_Exec_Time
VMM_Service  Hook_V86_Int_Chain
VMM_Service  Get_V86_Int_Vector
VMM_Service  Set_V86_Int_Vector
VMM_Service  Get_PM_Int_Vector
VMM_Service  Set_PM_Int_Vector
VMM_Service  Simulate_Int
VMM_Service  Simulate_Iret
VMM_Service  Simulate_Far_Call
VMM_Service  Simulate_Far_Jmp
VMM_Service  Simulate_Far_Ret
VMM_Service  Simulate_Far_Ret_N
VMM_Service  Build_Int_Stack_Frame
VMM_Service  Simulate_Push
VMM_Service  Simulate_Pop
VMM_Service  _HeapAllocate
VMM_Service  _HeapReAllocate
VMM_Service  _HeapFree
VMM_Service  _HeapGetSize
HEAPZEROINIT	EQU	00000001H
HEAPZEROREINIT	EQU	00000002H
HEAPNOCOPY	EQU	00000004H
HEAPALIGN_SHIFT	EQU	16
HEAPALIGN_MASK	EQU	000F0000H
HEAPALIGN_4	EQU	00000000H
HEAPALIGN_8	EQU	00000000H
HEAPALIGN_16	EQU	00000000H
HEAPALIGN_32	EQU	00010000H
HEAPALIGN_64	EQU	00020000H
HEAPALIGN_128	EQU	00030000H
HEAPALIGN_256	EQU	00040000H
HEAPALIGN_512	EQU	00050000H
HEAPALIGN_1K	EQU	00060000H
HEAPALIGN_2K	EQU	00070000H
HEAPALIGN_4K	EQU	00080000H
HEAPALIGN_8K	EQU	00090000H
HEAPALIGN_16K	EQU	000A0000H
HEAPALIGN_32K	EQU	000B0000H
HEAPALIGN_64K	EQU	000C0000H
HEAPALIGN_128K	EQU	000D0000H
HEAPTYPESHIFT	EQU	8
HEAPTYPEMASK	EQU	00000700H
HEAPLOCKEDHIGH	EQU	00000000H
HEAPLOCKEDIFDP	EQU	00000100H
HEAPSWAP	EQU	00000200H
HEAPINIT	EQU	00000400H
HEAPCLEAN	EQU	00000800H
HEAPCONTIG	EQU	00001000H
HEAPFORGET	EQU	00002000H
HEAPLOCKEDLOW	EQU	00000300H
HEAPSYSVM	EQU	00000500H
HEAPPREEMPT	EQU	00000600H
VMM_Service  _PageAllocate
VMM_Service  _PageReAllocate
VMM_Service  _PageFree
VMM_Service  _PageLock
VMM_Service  _PageUnLock
VMM_Service  _PageGetSizeAddr
VMM_Service  _PageGetAllocInfo
VMM_Service  _GetFreePageCount
VMM_Service  _GetSysPageCount
VMM_Service  _GetVMPgCount
VMM_Service  _MapIntoV86
VMM_Service  _PhysIntoV86
VMM_Service  _TestGlobalV86Mem
VMM_Service  _ModifyPageBits
VMM_Service  _CopyPageTable
VMM_Service  _LinMapIntoV86
VMM_Service  _LinPageLock
VMM_Service  _LinPageUnLock
VMM_Service  _SetResetV86Pageable
VMM_Service  _GetV86PageableArray
VMM_Service  _PageCheckLinRange
VMM_Service  _PageOutDirtyPages
VMM_Service  _PageDiscardPages
PAGEZEROINIT	EQU	00000001H
PAGEUSEALIGN	EQU	00000002H
PAGECONTIG	EQU	00000004H
PAGEFIXED	EQU	00000008H
PAGEDEBUGNULFAULT	EQU	00000010H
PAGEZEROREINIT	EQU	00000020H
PAGENOCOPY	EQU	00000040H
PAGELOCKED	EQU	00000080H
PAGELOCKEDIFDP	EQU	00000100H
PAGESETV86PAGEABLE	EQU	00000200H
PAGECLEARV86PAGEABLE	EQU	00000400H
PAGESETV86INTSLOCKED	EQU	00000800H
PAGECLEARV86INTSLOCKED	EQU	00001000H
PAGEMARKPAGEOUT	EQU	00002000H
PAGEPDPSETBASE	EQU	00004000H
PAGEPDPCLEARBASE	EQU	00008000H
PAGEDISCARD	EQU	00010000H
PAGEPDPQUERYDIRTY	EQU	00020000H
PAGEMAPFREEPHYSREG	EQU	00040000H
PAGEPHYSONLY	EQU	04000000H
PAGENOMOVE	EQU	10000000H
PAGEMAPGLOBAL	EQU	40000000H
PAGEMARKDIRTY	EQU	80000000H
MAPV86_IGNOREWRAP	EQU	00000001H
MPL_NonCached	EQU	00000000H
MPL_HardwareCoherentCached	EQU	00000001H
MPL_FrameBufferCached	EQU	00000002H
MPL_Cached	EQU	00000004H
VMM_Service  _GetNulPageHandle
VMM_Service  _GetFirstV86Page
VMM_Service  _MapPhysToLinear
VMM_Service  _GetAppFlatDSAlias
VMM_Service  _SelectorMapFlat
VMM_Service  _GetDemandPageInfo
VMM_Service  _GetSetPageOutCount
GSPOC_F_GET	EQU	00000001H
VMM_Service  Hook_V86_Page
VMM_Service  _Assign_Device_V86_Pages
VMM_Service  _DeAssign_Device_V86_Pages
VMM_Service  _Get_Device_V86_Pages_Array
VMM_Service  MMGR_SetNULPageAddr
VMM_Service  _Allocate_GDT_Selector
VMM_Service  _Free_GDT_Selector
VMM_Service  _Allocate_LDT_Selector
VMM_Service  _Free_LDT_Selector
VMM_Service  _BuildDescriptorDWORDs
VMM_Service  _GetDescriptor
VMM_Service  _SetDescriptor
ALLOCFROMEND	EQU	40000000H
BDDEXPLICITDPL	EQU	00000001H
ALDTSPECSEL	EQU	00000001H
VMM_Service  _MMGR_Toggle_HMA
MMGRHMAPHYSICAL	EQU	00000001H
MMGRHMAENABLE	EQU	00000002H
MMGRHMADISABLE	EQU	00000004H
MMGRHMAQUERY	EQU	00000008H
VMM_Service  Get_Fault_Hook_Addrs
VMM_Service  Hook_V86_Fault
VMM_Service  Hook_PM_Fault
VMM_Service  Hook_VMM_Fault
VMM_Service  Begin_Nest_V86_Exec
VMM_Service  Begin_Nest_Exec
VMM_Service  Exec_Int
VMM_Service  Resume_Exec
VMM_Service  End_Nest_Exec
VMM_Service  Allocate_PM_App_CB_Area, VMM_ICODE
VMM_Service  Get_Cur_PM_App_CB
VMM_Service  Set_V86_Exec_Mode
VMM_Service  Set_PM_Exec_Mode
VMM_Service  Begin_Use_Locked_PM_Stack
VMM_Service  End_Use_Locked_PM_Stack
VMM_Service  Save_Client_State
VMM_Service  Restore_Client_State
VMM_Service  Exec_VxD_Int
VMM_Service  Hook_Device_Service
VMM_Service  Hook_Device_V86_API
VMM_Service  Hook_Device_PM_API
VMM_Service  System_Control
VMM_Service  Simulate_IO
VMM_Service  Install_Mult_IO_Handlers
VMM_Service  Install_IO_Handler
VMM_Service  Enable_Global_Trapping
VMM_Service  Enable_Local_Trapping
VMM_Service  Disable_Global_Trapping
VMM_Service  Disable_Local_Trapping
VMM_Service  List_Create
VMM_Service  List_Destroy
VMM_Service  List_Allocate
VMM_Service  List_Attach
VMM_Service  List_Attach_Tail
VMM_Service  List_Insert
VMM_Service  List_Remove
VMM_Service  List_Deallocate
VMM_Service  List_Get_First
VMM_Service  List_Get_Next
VMM_Service  List_Remove_First
LF_ASYNC_BIT	EQU	0
LF_ASYNC	EQU	(1 SHL LF_ASYNC_BIT)
LF_USE_HEAP_BIT	EQU	1
LF_USE_HEAP	EQU	(1 SHL LF_USE_HEAP_BIT)
LF_ALLOC_ERROR_BIT	EQU	2
LF_ALLOC_ERROR	EQU	(1 SHL LF_ALLOC_ERROR_BIT)
LF_SWAP	EQU	(LF_USE_HEAP+(1 SHL 3))
VMM_Service  _AddInstanceItem
VMM_Service  _Allocate_Device_CB_Area
VMM_Service  _Allocate_Global_V86_Data_Area, VMM_ICODE
VMM_Service  _Allocate_Temp_V86_Data_Area
VMM_Service  _Free_Temp_V86_Data_Area
GVDAWordAlign	EQU	00000001H
GVDADWordAlign	EQU	00000002H
GVDAParaAlign	EQU	00000004H
GVDAPageAlign	EQU	00000008H
GVDAInstance	EQU	00000100H
GVDAZeroInit	EQU	00000200H
GVDAReclaim	EQU	00000400H
GVDAInquire	EQU	00000800H
GVDAHighSysCritOK	EQU	00001000H
GVDAOptInstance	EQU	00002000H
GVDAForceLow	EQU	00004000H
TVDANeedTilInitComplete	EQU	00000001H
VMM_Service  Get_Profile_Decimal_Int, VMM_ICODE
VMM_Service  Convert_Decimal_String, VMM_ICODE
VMM_Service  Get_Profile_Fixed_Point, VMM_ICODE
VMM_Service  Convert_Fixed_Point_String, VMM_ICODE
VMM_Service  Get_Profile_Hex_Int, VMM_ICODE
VMM_Service  Convert_Hex_String, VMM_ICODE
VMM_Service  Get_Profile_Boolean, VMM_ICODE
VMM_Service  Convert_Boolean_String, VMM_ICODE
VMM_Service  Get_Profile_String, VMM_ICODE
VMM_Service  Get_Next_Profile_String, VMM_ICODE
VMM_Service  Get_Environment_String, VMM_ICODE
VMM_Service  Get_Exec_Path, VMM_ICODE
VMM_Service  Get_Config_Directory, VMM_ICODE
VMM_Service  OpenFile, VMM_ICODE
VMM_OPENFILE_BUF_SIZE	EQU	260
VMM_Service  Get_PSP_Segment, VMM_ICODE
VMM_Service  GetDOSVectors, VMM_ICODE
VMM_Service  Get_Machine_Info
GMIF_80486_BIT	EQU	10H
GMIF_80486	EQU	(1 SHL GMIF_80486_BIT)
GMIF_PCXT_BIT	EQU	11H
GMIF_PCXT	EQU	(1 SHL GMIF_PCXT_BIT)
GMIF_MCA_BIT	EQU	12H
GMIF_MCA	EQU	(1 SHL GMIF_MCA_BIT)
GMIF_EISA_BIT	EQU	13H
GMIF_EISA	EQU	(1 SHL GMIF_EISA_BIT)
GMIF_CPUID_BIT	EQU	14H
GMIF_CPUID	EQU	(1 SHL GMIF_CPUID_BIT)
GMIF_80586_BIT	EQU	15H
GMIF_80586	EQU	(1 SHL GMIF_80586_BIT)
GMIF_4MEGPG_BIT	EQU	16H
GMIF_4MEGPG	EQU	(1 SHL GMIF_4MEGPG_BIT)
GMIF_RDTSC_BIT	EQU	17H
GMIF_RDTSC	EQU	(1 SHL GMIF_RDTSC_BIT)
VMM_Service  GetSet_HMA_Info
VMM_Service  Set_System_Exit_Code
VMM_Service  Fatal_Error_Handler
VMM_Service  Fatal_Memory_Error
VMM_Service  Update_System_Clock
VMM_Service  Test_Debug_Installed
VMM_Service  Out_Debug_String
VMM_Service  Out_Debug_Chr
VMM_Service  In_Debug_Chr
VMM_Service  Debug_Convert_Hex_Binary
VMM_Service  Debug_Convert_Hex_Decimal
VMM_Service  Debug_Test_Valid_Handle
VMM_Service  Validate_Client_Ptr
VMM_Service  Test_Reenter
VMM_Service  Queue_Debug_String
VMM_Service  Log_Proc_Call
VMM_Service  Debug_Test_Cur_VM
VMM_Service  Get_PM_Int_Type
VMM_Service  Set_PM_Int_Type
VMM_Service  Get_Last_Updated_System_Time
VMM_Service  Get_Last_Updated_VM_Exec_Time
VMM_Service  Test_DBCS_Lead_Byte
.errnz	@@Test_DBCS_Lead_Byte - 100D1h

VMM_Service  _AddFreePhysPage, VMM_ICODE
VMM_Service  _PageResetHandlePAddr
VMM_Service  _SetLastV86Page, VMM_ICODE
VMM_Service  _GetLastV86Page
VMM_Service  _MapFreePhysReg
VMM_Service  _UnmapFreePhysReg
VMM_Service  _XchgFreePhysReg
VMM_Service  _SetFreePhysRegCalBk, VMM_ICODE
VMM_Service  Get_Next_Arena, VMM_ICODE
VMM_Service  Get_Name_Of_Ugly_TSR, VMM_ICODE
VMM_Service  Get_Debug_Options, VMM_ICODE
AFPP_SWAPOUT	EQU	0001H
PCP_CHANGEPAGER	EQU	1H
PCP_CHANGEPAGERDATA	EQU	2H
PCP_VIRGINONLY	EQU	4H
GNA_HIDOSLINKED	EQU	0002H
GNA_ISHIGHDOS	EQU	0004H
VMM_Service  Set_Physical_HMA_Alias, VMM_ICODE
VMM_Service  _GetGlblRng0V86IntBase, VMM_ICODE
VMM_Service  _Add_Global_V86_Data_Area, VMM_ICODE
VMM_Service  GetSetDetailedVMError
GSDVME_PRIVINST	EQU	00010001H
GSDVME_INVALINST	EQU	00010002H
GSDVME_INVALPGFLT	EQU	00010003H
GSDVME_INVALGPFLT	EQU	00010004H
GSDVME_INVALFLT	EQU	00010005H
GSDVME_USERNUKE	EQU	00010006H
GSDVME_DEVNUKE	EQU	00010007H
GSDVME_DEVNUKEHDWR	EQU	00010008H
GSDVME_NUKENOMSG	EQU	00010009H
GSDVME_OKNUKEMASK	EQU	80000000H
GSDVME_INSMEMV86	EQU	00020001H
GSDVME_INSV86SPACE	EQU	00020002H
GSDVME_INSMEMXMS	EQU	00020003H
GSDVME_INSMEMEMS	EQU	00020004H
GSDVME_INSMEMV86HI	EQU	00020005H
GSDVME_INSMEMVID	EQU	00020006H
GSDVME_INSMEMVM	EQU	00020007H
GSDVME_INSMEMDEV	EQU	00020008H
GSDVME_CRTNOMSG	EQU	00020009H
VMM_Service  Is_Debug_Chr
VMM_Service  Clear_Mono_Screen
VMM_Service  Out_Mono_Chr
VMM_Service  Out_Mono_String
VMM_Service  Set_Mono_Cur_Pos
VMM_Service  Get_Mono_Cur_Pos
VMM_Service  Get_Mono_Chr
VMM_Service  Locate_Byte_In_ROM, VMM_ICODE
VMM_Service  Hook_Invalid_Page_Fault
VMM_Service  Unhook_Invalid_Page_Fault
IPF_PGDIR	EQU	00000001H
IPF_V86PG	EQU	00000002H
IPF_V86PGH	EQU	00000004H
IPF_INVTYP	EQU	00000008H
IPF_PGERR	EQU	00000010H
IPF_REFLT	EQU	00000020H
IPF_VMM	EQU	00000040H
IPF_PM	EQU	00000080H
IPF_V86	EQU	00000100H
VMM_Service  Set_Delete_On_Exit_File
VMM_Service  Close_VM
CVF_CONTINUE_EXEC_BIT	EQU	0
CVF_CONTINUE_EXEC	EQU	(1 SHL CVF_CONTINUE_EXEC_BIT)
VMM_Service  Enable_Touch_1st_Meg
VMM_Service  Disable_Touch_1st_Meg
VMM_Service  Install_Exception_Handler
VMM_Service  Remove_Exception_Handler
VMM_Service  Get_Crit_Status_No_Block

.errnz	 @@Get_Crit_Status_No_Block - 100F1h

ifdef WIN40SERVICES
VMM_Service  _GetLastUpdatedThreadExecTime
VMM_Service  _Trace_Out_Service
VMM_Service  _Debug_Out_Service
VMM_Service  _Debug_Flags_Service
endif
DFS_LOG_BIT	EQU	0
DFS_LOG	EQU	(1 SHL DFS_LOG_BIT)
DFS_PROFILE_BIT	EQU	1
DFS_PROFILE	EQU	(1 SHL DFS_PROFILE_BIT)
DFS_TEST_CLD_BIT	EQU	2
DFS_TEST_CLD	EQU	(1 SHL DFS_TEST_CLD_BIT)
DFS_NEVER_REENTER_BIT	EQU	3
DFS_NEVER_REENTER	EQU	(1 SHL DFS_NEVER_REENTER_BIT)
DFS_TEST_REENTER_BIT	EQU	4
DFS_TEST_REENTER	EQU	(1 SHL DFS_TEST_REENTER_BIT)
DFS_NOT_SWAPPING_BIT	EQU	5
DFS_NOT_SWAPPING	EQU	(1 SHL DFS_NOT_SWAPPING_BIT)
DFS_TEST_BLOCK_BIT	EQU	6
DFS_TEST_BLOCK	EQU	(1 SHL DFS_TEST_BLOCK_BIT)
DFS_RARE_SERVICES	EQU	0FFFFFF80H
DFS_EXIT_NOBLOCK	EQU	(DFS_RARE_SERVICES+0)
DFS_ENTER_NOBLOCK	EQU	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)
DFS_TEST_NEST_EXEC	EQU	(DFS_RARE_SERVICES+1)
DFS_WIMP_DEBUG	EQU	(DFS_RARE_SERVICES+2)
ifdef WIN40SERVICES
VMM_Service  VMMAddImportModuleName
VMM_Service  VMM_Add_DDB
VMM_Service  VMM_Remove_DDB
VMM_Service  Test_VM_Ints_Enabled
VMM_Service  _BlockOnID
VMM_Service  Schedule_Thread_Event
VMM_Service  Cancel_Thread_Event
VMM_Service  Set_Thread_Time_Out
VMM_Service  Set_Async_Time_Out
VMM_Service  _AllocateThreadDataSlot
VMM_Service  _FreeThreadDataSlot
MUTEX_MUST_COMPLETE	EQU	1
MUTEX_NO_CLEANUP_THREAD_STATE	EQU	2
VMM_Service  _CreateMutex
VMM_Service  _DestroyMutex
VMM_Service  _GetMutexOwner
VMM_Service  Call_When_Thread_Switched
VMM_Service  VMMCreateThread
VMM_Service  _GetThreadExecTime
VMM_Service  VMMTerminateThread
VMM_Service  Get_Cur_Thread_Handle
VMM_Service  Test_Cur_Thread_Handle
VMM_Service  Get_Sys_Thread_Handle
VMM_Service  Test_Sys_Thread_Handle
VMM_Service  Validate_Thread_Handle
VMM_Service  Get_Initial_Thread_Handle
VMM_Service  Test_Initial_Thread_Handle
VMM_Service  Debug_Test_Valid_Thread_Handle
VMM_Service  Debug_Test_Cur_Thread
VMM_Service  VMM_GetSystemInitState
VMM_Service  Cancel_Call_When_Thread_Switched
VMM_Service  Get_Next_Thread_Handle
VMM_Service  Adjust_Thread_Exec_Priority
VMM_Service  _Deallocate_Device_CB_Area
VMM_Service  Remove_IO_Handler
VMM_Service  Remove_Mult_IO_Handlers
VMM_Service  Unhook_V86_Int_Chain
VMM_Service  Unhook_V86_Fault
VMM_Service  Unhook_PM_Fault
VMM_Service  Unhook_VMM_Fault
VMM_Service  Unhook_Device_Service
VMM_Service  _PageReserve
VMM_Service  _PageCommit
VMM_Service  _PageDecommit
VMM_Service  _PagerRegister
VMM_Service  _PagerQuery
VMM_Service  _PagerDeregister
VMM_Service  _ContextCreate
VMM_Service  _ContextDestroy
VMM_Service  _PageAttach
VMM_Service  _PageFlush
VMM_Service  _SignalID
VMM_Service  _PageCommitPhys
VMM_Service  _Register_Win32_Services
VMM_Service  Cancel_Call_When_Not_Critical
VMM_Service  Cancel_Call_When_Idle
VMM_Service  Cancel_Call_When_Task_Switched
VMM_Service  _Debug_Printf_Service
VMM_Service  _EnterMutex
VMM_Service  _LeaveMutex
VMM_Service  Simulate_VM_IO
VMM_Service  Signal_Semaphore_No_Switch
VMM_Service  _ContextSwitch
VMM_Service  _PageModifyPermissions
VMM_Service  _PageQuery
VMM_Service  _EnterMustComplete
VMM_Service  _LeaveMustComplete
VMM_Service  _ResumeExecMustComplete
THREAD_TERM_STATUS_CRASH_PEND	EQU	1
THREAD_TERM_STATUS_NUKE_PEND	EQU	2
THREAD_TERM_STATUS_SUSPEND_PEND	EQU	4
VMM_Service  _GetThreadTerminationStatus
VMM_Service  _GetInstanceInfo
INSTINFO_NONE	EQU	0
INSTINFO_SOME	EQU	1
INSTINFO_ALL	EQU	2
VMM_Service  _ExecIntMustComplete
VMM_Service  _ExecVxDIntMustComplete
VMM_Service  Begin_V86_Serialization
VMM_Service  Unhook_V86_Page
VMM_Service  VMM_GetVxDLocationList
VMM_Service  VMM_GetDDBList
VMM_Service  Unhook_NMI_Event
VMM_Service  Get_Instanced_V86_Int_Vector
VMM_Service  Get_Set_Real_DOS_PSP
GSRDP_Set	EQU	0001H
VMM_Service  Call_Priority_Thread_Event
VMM_Service  Get_System_Time_Address
VMM_Service  Get_Crit_Status_Thread
VMM_Service  Get_DDB
VMM_Service  Directed_Sys_Control
VMM_Service  _RegOpenKey
VMM_Service  _RegCloseKey
VMM_Service  _RegCreateKey
VMM_Service  _RegDeleteKey
VMM_Service  _RegEnumKey
VMM_Service  _RegQueryValue
VMM_Service  _RegSetValue
VMM_Service  _RegDeleteValue
VMM_Service  _RegEnumValue
VMM_Service  _RegQueryValueEx
VMM_Service  _RegSetValueEx
ifndef REG_SZ
REG_SZ	EQU	0001H
REG_BINARY	EQU	0003H
endif
ifndef HKEY_LOCAL_MACHINE
HKEY_CLASSES_ROOT	EQU	80000000H
HKEY_CURRENT_USER	EQU	80000001H
HKEY_LOCAL_MACHINE	EQU	80000002H
HKEY_USERS	EQU	80000003H
HKEY_PERFORMANCE_DATA	EQU	80000004H
HKEY_CURRENT_CONFIG	EQU	80000005H
HKEY_DYN_DATA	EQU	80000006H
endif
VMM_Service  _CallRing3
VMM_Service  Exec_PM_Int
VMM_Service  _RegFlushKey
VMM_Service  _PageCommitContig
VMM_Service  _GetCurrentContext
VMM_Service  _LocalizeSprintf
VMM_Service  _LocalizeStackSprintf
VMM_Service  Call_Restricted_Event
VMM_Service  Cancel_Restricted_Event
VMM_Service  Register_PEF_Provider, VMM_ICODE
VMM_Service  _GetPhysPageInfo
VMM_Service  _RegQueryInfoKey
VMM_Service  MemArb_Reserve_Pages
PHYSINFO_NONE	EQU	0
PHYSINFO_SOME	EQU	1
PHYSINFO_ALL	EQU	2
VMM_Service  Time_Slice_Sys_VM_Idle
VMM_Service  Time_Slice_Sleep
VMM_Service  Boost_With_Decay
VMM_Service  Set_Inversion_Pri
VMM_Service  Reset_Inversion_Pri
VMM_Service  Release_Inversion_Pri
VMM_Service  Get_Thread_Win32_Pri
VMM_Service  Set_Thread_Win32_Pri
VMM_Service  Set_Thread_Static_Boost
VMM_Service  Set_VM_Static_Boost
VMM_Service  Release_Inversion_Pri_ID
VMM_Service  Attach_Thread_To_Group
VMM_Service  Detach_Thread_From_Group
VMM_Service  Set_Group_Static_Boost
VMM_Service  _GetRegistryPath, VMM_ICODE
VMM_Service  _GetRegistryKey
REGTYPE_ENUM	EQU	0
REGTYPE_CLASS	EQU	1
REGTYPE_VXD	EQU	2
REGKEY_OPEN	EQU	0
REGKEY_CREATE_IFNOTEXIST	EQU	1
ASSERT_RANGE_NULL_BAD	EQU	00000000H
ASSERT_RANGE_NULL_OK	EQU	00000001H
ASSERT_RANGE_IS_ASCIIZ	EQU	00000002H
ASSERT_RANGE_IS_NOT_ASCIIZ	EQU	00000000H
ASSERT_RANGE_NO_DEBUG	EQU	80000000H
ASSERT_RANGE_BITS	EQU	80000003H
VMM_Service  Cleanup_Thread_State
VMM_Service  _RegRemapPreDefKey
VMM_Service  End_V86_Serialization
VMM_Service  _Assert_Range
VMM_Service  _Sprintf
VMM_Service  _PageChangePager
VMM_Service  _RegCreateDynKey
VMM_Service  _RegQueryMultipleValues
VMM_Service  Boost_Thread_With_VM
BOOT_CLEAN	EQU	00000001H
BOOT_DOSCLEAN	EQU	00000002H
BOOT_NETCLEAN	EQU	00000004H
BOOT_INTERACTIVE	EQU	00000008H
VMM_Service  Get_Boot_Flags
VMM_Service  Set_Boot_Flags
VMM_Service  _lstrcpyn
VMM_Service  _lstrlen
VMM_Service  _lmemcpy
VMM_Service  _GetVxDName
VMM_Service  Force_Mutexes_Free
VMM_Service  Restore_Forced_Mutexes
VMM_Service  _AddReclaimableItem
VMM_Service  _SetReclaimableItem
VMM_Service  _EnumReclaimableItem
VMM_Service  Time_Slice_Wake_Sys_VM
VMM_Service  VMM_Replace_Global_Environment
VMM_Service  Begin_Non_Serial_Nest_V86_Exec
VMM_Service  Get_Nest_Exec_Status
VMM_Service  Open_Boot_Log
VMM_Service  Write_Boot_Log
VMM_Service  Close_Boot_Log
VMM_Service  EnableDisable_Boot_Log
VMM_Service  _Call_On_My_Stack
VMM_Service  Get_Inst_V86_Int_Vec_Base
VMM_Service  _lstrcmpi
VMM_Service  _strupr
VMM_Service  Log_Fault_Call_Out
VMM_Service  _AtEventTime
endif
ifdef WIN403SERVICES
VMM_Service  _PageOutPages
PAGEOUT_PRIVATE	EQU	00000001H
PAGEOUT_SHARED	EQU	00000002H
PAGEOUT_SYSTEM	EQU	00000004H
PAGEOUT_REGION	EQU	00000008H
PAGEOUT_ALL	EQU	(PAGEOUT_PRIVATE OR PAGEOUT_SHARED OR PAGEOUT_SYSTEM)
VMM_Service  _Call_On_My_Not_Flat_Stack
VMM_Service  _LinRegionLock
VMM_Service  _LinRegionUnLock
VMM_Service  _AttemptingSomethingDangerous
VMM_Service  _Vsprintf
VMM_Service  _Vsprintfw
VMM_Service  Load_FS_Service
VMM_Service  Assert_FS_Service
VMM_StdCall_Service  ObsoleteRtlUnwind, 4
VMM_StdCall_Service  ObsoleteRtlRaiseException, 1
VMM_StdCall_Service  ObsoleteRtlRaiseStatus, 1
VMM_StdCall_Service  ObsoleteKeGetCurrentIrql, 0
VMM_FastCall_Service  ObsoleteKfRaiseIrql, 1
VMM_FastCall_Service  ObsoleteKfLowerIrql, 1
VMM_Service  _Begin_Preemptable_Code
VMM_Service  _End_Preemptable_Code
VMM_FastCall_Service  Set_Preemptable_Count, 1
VMM_StdCall_Service  ObsoleteKeInitializeDpc, 3
VMM_StdCall_Service  ObsoleteKeInsertQueueDpc, 3
VMM_StdCall_Service  ObsoleteKeRemoveQueueDpc, 1
VMM_StdCall_Service  HeapAllocateEx, 4
VMM_StdCall_Service  HeapReAllocateEx, 5
VMM_StdCall_Service  HeapGetSizeEx, 2
VMM_StdCall_Service  HeapFreeEx, 2
VMM_Service  _Get_CPUID_Flags
VMM_StdCall_Service  KeCheckDivideByZeroTrap, 1
endif
ifdef	WIN41SERVICES
VMM_Service  _RegisterGARTHandler
VMM_Service  _GARTReserve
VMM_Service  _GARTCommit
VMM_Service  _GARTUnCommit
VMM_Service  _GARTFree
VMM_Service  _GARTMemAttributes
VMM_StdCall_Service  KfRaiseIrqlToDpcLevel, 0
VMM_Service  VMMCreateThreadEx
VMM_Service  _FlushCaches
PG_UNCACHED	EQU	00000001H
PG_WRITECOMBINED	EQU	00000002H
FLUSHCACHES_NORMAL	EQU	00000000H
FLUSHCACHES_GET_CACHE_LINE_PTR	EQU	00000001H
FLUSHCACHES_GET_CACHE_SIZE_PTR	EQU	00000002H
FLUSHCACHES_TAKE_OVER	EQU	00000003H
FLUSHCACHES_FORCE_PAGES_OUT	EQU	00000004H
FLUSHCACHES_LOCK_LOCKABLE	EQU	00000005H
FLUSHCACHES_UNLOCK_LOCKABLE	EQU	00000006H
VMM_Service  Set_Thread_Win32_Pri_NoYield
VMM_Service  _FlushMappedCacheBlock
VMM_Service  _ReleaseMappedCacheBlock
VMM_Service  Run_Preemptable_Events
VMM_Service  _MMPreSystemExit
VMM_Service  _MMPageFileShutDown
VMM_Service  _Set_Global_Time_Out_Ex
VMM_Service  Query_Thread_Priority
endif
End_Service_Table VMM, VMM
COMNFS_FLAT	EQU	0FFFFFFFFH
RS_RECLAIM	EQU	00000001H
RS_RESTORE	EQU	00000002H
RS_DOSARENA	EQU	00000004H

ReclaimStruc	STRUC
RS_Linear	DD	?
RS_Bytes	DD	?
RS_CallBack	DD	?
RS_RefData	DD	?
RS_HookTable	DD	?
RS_Flags	DD	?
ReclaimStruc	ENDS

frmtx	STRUC
frmtx_pfrmtxNext	DD	?
frmtx_hmutex	DD	?
frmtx_cEnterCount	DD	?
frmtx_pthcbOwner	DD	?
frmtx_htimeout	DD	?
frmtx	ENDS

vmmfrinfo	STRUC
vmmfrinfo_frmtxDOS	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxV86	DB	SIZE frmtx DUP (?)
vmmfrinfo_frmtxOther	DB	SIZE frmtx DUP (?)
vmmfrinfo	ENDS

DemandInfoStruc	STRUC
DILin_Total_Count	DD	?
DIPhys_Count	DD	?
DIFree_Count	DD	?
DIUnlock_Count	DD	?
DILinear_Base_Addr	DD	?
DILin_Total_Free	DD	?
DIPage_Faults	DD	?
DIPage_Ins	DD	?
DIPage_Outs	DD	?
DIPage_Discards	DD	?
DIInstance_Faults	DD	?
DIPagingFileMax	DD	?
DIPagingFileInUse	DD	?
DICommit_Count	DD	?
DIReserved	DD	2 DUP (?)
DemandInfoStruc	ENDS

InstDataStruc	STRUC
InstLinkF	DD	0
InstLinkB	DD	0
InstLinAddr	DD	?
InstSize	DD	?
InstType	DD	?
InstDataStruc	ENDS
INDOS_FIELD	EQU	100H
ALWAYS_FIELD	EQU	200H
OPTIONAL_FIELD	EQU	400H

IPF_Data	STRUC
IPF_LinAddr	DD	?
IPF_MapPageNum	DD	?
IPF_PTEEntry	DD	?
IPF_FaultingVM	DD	?
IPF_Flags	DD	?
IPF_Data	ENDS

Exception_Handler_Struc	STRUC
EH_Reserved	DD	?
EH_Start_EIP	DD	?
EH_End_EIP	DD	?
EH_Handler	DD	?
Exception_Handler_Struc	ENDS
PR_PRIVATE	EQU	80000400H
PR_SHARED	EQU	80060000H
PR_SYSTEM	EQU	80080000H
PR_FIXED	EQU	00000008H
PR_4MEG	EQU	00000001H
PR_STATIC	EQU	00000010H
PD_ZEROINIT	EQU	00000001H
PD_NOINIT	EQU	00000002H
PD_FIXEDZERO	EQU	00000003H
PD_FIXED	EQU	00000004H
PC_FIXED	EQU	00000008H
PC_LOCKED	EQU	00000080H
PC_LOCKEDIFDP	EQU	00000100H
PC_WRITEABLE	EQU	00020000H
PC_USER	EQU	00040000H
PC_INCR	EQU	40000000H
PC_PRESENT	EQU	80000000H
PC_STATIC	EQU	20000000H
PC_DIRTY	EQU	08000000H
PC_CACHEDIS	EQU	00100000H
PC_CACHEWT	EQU	00080000H
PC_PAGEFLUSH	EQU	00008000H
ifdef WRITE_WATCH
PC_WRITE_WATCH	EQU	00200000H
endif
PCC_ZEROINIT	EQU	00000001H
PCC_NOLIN	EQU	10000000H
MTRR_UC	EQU	0
MTRR_WC	EQU	1
MTRR_WT	EQU	4
MTRR_WP	EQU	5
MTRR_WB	EQU	6
ifndef _WINNT_

_MEMORY_BASIC_INFORMATION	STRUC
mbi_BaseAddress	DD	?
mbi_AllocationBase	DD	?
mbi_AllocationProtect	DD	?
mbi_RegionSize	DD	?
mbi_State	DD	?
mbi_Protect	DD	?
mbi_Type	DD	?
_MEMORY_BASIC_INFORMATION	ENDS
PAGE_NOACCESS	EQU	01H
PAGE_READONLY	EQU	02H
PAGE_READWRITE	EQU	04H
MEM_COMMIT	EQU	1000H
MEM_RESERVE	EQU	2000H
MEM_FREE	EQU	10000H
MEM_PRIVATE	EQU	20000H
endif

pd_s	STRUC
pd_virginin	DD	?
pd_taintedin	DD	?
pd_cleanout	DD	?
pd_dirtyout	DD	?
pd_virginfree	DD	?
pd_taintedfree	DD	?
pd_dirty	DD	?
pd_type	DD	?
pd_s	ENDS
PD_SWAPPER	EQU	0
PD_PAGERONLY	EQU	1
PD_NESTEXEC	EQU	2
endif
PAGESHIFT	EQU	12
PAGESIZE	EQU	(1 SHL PAGESHIFT)
PAGEMASK	EQU	(PAGESIZE-1)
MAXSYSTEMLADDR	EQU	(0ffbfffffH)
MINSYSTEMLADDR	EQU	(0c0000000H)
MAXSHAREDLADDR	EQU	(0bfffffffH)
MINSHAREDLADDR	EQU	(80000000H)
MAXPRIVATELADDR	EQU	(7fffffffH)
MINPRIVATELADDR	EQU	(00400000H)
MAXDOSLADDR	EQU	(003fffffH)
MINDOSLADDR	EQU	(00000000H)
MAXSYSTEMPAGE	EQU	(MAXSYSTEMLADDR SHR PAGESHIFT)
MINSYSTEMPAGE	EQU	(MINSYSTEMLADDR SHR PAGESHIFT)
MAXSHAREDPAGE	EQU	(MAXSHAREDLADDR SHR PAGESHIFT)
MINSHAREDPAGE	EQU	(MINSHAREDLADDR SHR PAGESHIFT)
MAXPRIVATEPAGE	EQU	(MAXPRIVATELADDR SHR PAGESHIFT)
MINPRIVATEPAGE	EQU	(MINPRIVATELADDR SHR PAGESHIFT)
MAXDOSPAGE	EQU	(MAXDOSLADDR SHR PAGESHIFT)
MINDOSPAGE	EQU	(MINDOSLADDR SHR PAGESHIFT)
CBPRIVATE	EQU	(1+MAXPRIVATELADDR-MINPRIVATELADDR)
CBSHARED	EQU	(1+MAXSHAREDLADDR-MINSHAREDLADDR)
CBSYSTEM	EQU	(1+MAXSYSTEMLADDR-MINSYSTEMLADDR)
CBDOS	EQU	(1+MAXDOSLADDR-MINDOSLADDR)
CPGPRIVATE	EQU	(1+MAXPRIVATEPAGE-MINPRIVATEPAGE)
CPGSHARED	EQU	(1+MAXSHAREDPAGE-MINSHAREDPAGE)
CPGSYSTEM	EQU	(1+MAXSYSTEMPAGE-MINSYSTEMPAGE)
CPGDOS	EQU	(1+MAXDOSPAGE-MINDOSPAGE)
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF

ASD_MAX_REF_DATA	EQU	256

_vmmguid	STRUC
Data1	DD	?
Data2	DW	?
Data3	DW	?
Data4	DB	8 DUP (?)
_vmmguid	ENDS
ASD_ERROR_NONE	EQU	00000000H
ASD_CHECK_FAIL	EQU	00000001H
ASD_CHECK_SUCCESS	EQU	00000002H
ASD_CHECK_UNKNOWN	EQU	00000003H
ASD_ERROR_BAD_TIME	EQU	00000004H
ASD_REGISTRY_ERROR	EQU	00000005H
ASD_CLEAN_BOOT	EQU	00000006H
ASD_OUT_OF_MEMORY	EQU	00000007H
ASD_FILE_ERROR	EQU	00000008H
ASD_ALREADY_SET	EQU	00000009H
ASD_MISSING_CHECK	EQU	0000000AH
ASD_BAD_PARAMETER	EQU	0000000BH
ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	EQU	00000000H
ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	EQU	00000001H
ASD_OP_CHECK	EQU	00000002H
ASD_OP_DONE_AND_SET_SUCCESS	EQU	00000003H
ASD_OP_SET_FAIL	EQU	00000004H
ASD_OP_SET_SUCCESS	EQU	00000005H
ASD_OP_SET_UNKNOWN	EQU	00000006H
ASD_OP_DONE	EQU	00000007H
ASD_FLAG_STRING	EQU	00000001H
ifndef Not_VxD
SYS_CRITICAL_INIT	EQU	0000H
DEVICE_INIT	EQU	0001H
INIT_COMPLETE	EQU	0002H
SYS_VM_INIT	EQU	0003H
SYS_VM_TERMINATE	EQU	0004H
SYSTEM_EXIT	EQU	0005H
SYS_CRITICAL_EXIT	EQU	0006H
CREATE_VM	EQU	0007H
VM_CRITICAL_INIT	EQU	0008H
VM_INIT	EQU	0009H
VM_TERMINATE	EQU	000AH
VM_NOT_EXECUTEABLE	EQU	000BH
DESTROY_VM	EQU	000CH
VNE_CRASHED_BIT	EQU	00H
VNE_CRASHED	EQU	(1 SHL VNE_CRASHED_BIT)
VNE_NUKED_BIT	EQU	01H
VNE_NUKED	EQU	(1 SHL VNE_NUKED_BIT)
VNE_CREATEFAIL_BIT	EQU	02H
VNE_CREATEFAIL	EQU	(1 SHL VNE_CREATEFAIL_BIT)
VNE_CRINITFAIL_BIT	EQU	03H
VNE_CRINITFAIL	EQU	(1 SHL VNE_CRINITFAIL_BIT)
VNE_INITFAIL_BIT	EQU	04H
VNE_INITFAIL	EQU	(1 SHL VNE_INITFAIL_BIT)
VNE_CLOSED_BIT	EQU	05H
VNE_CLOSED	EQU	(1 SHL VNE_CLOSED_BIT)
VM_SUSPEND	EQU	000DH
VM_RESUME	EQU	000EH
SET_DEVICE_FOCUS	EQU	000FH
BEGIN_MESSAGE_MODE	EQU	0010H
END_MESSAGE_MODE	EQU	0011H
REBOOT_PROCESSOR	EQU	0012H
QUERY_DESTROY	EQU	0013H
DEBUG_QUERY	EQU	0014H
BEGIN_PM_APP	EQU	0015H
BPA_32_BIT	EQU	01H
BPA_32_BIT_FLAG	EQU	1
END_PM_APP	EQU	0016H
DEVICE_REBOOT_NOTIFY	EQU	0017H
CRIT_REBOOT_NOTIFY	EQU	0018H
CLOSE_VM_NOTIFY	EQU	0019H
CVNF_CRIT_CLOSE_BIT	EQU	0
CVNF_CRIT_CLOSE	EQU	(1 SHL CVNF_CRIT_CLOSE_BIT)
POWER_EVENT	EQU	001AH
SYS_DYNAMIC_DEVICE_INIT	EQU	001BH
SYS_DYNAMIC_DEVICE_EXIT	EQU	001CH
CREATE_THREAD	EQU	001DH
THREAD_INIT	EQU	001EH
TERMINATE_THREAD	EQU	001FH
THREAD_Not_Executeable	EQU	0020H
DESTROY_THREAD	EQU	0021H
PNP_NEW_DEVNODE	EQU	0022H
W32_DEVICEIOCONTROL	EQU	0023H
DIOC_GETVERSION	EQU	0H
DIOC_OPEN	EQU	DIOC_GETVERSION
DIOC_CLOSEHANDLE	EQU	-1
SYS_VM_TERMINATE2	EQU	0024H
SYSTEM_EXIT2	EQU	0025H
SYS_CRITICAL_EXIT2	EQU	0026H
VM_TERMINATE2	EQU	0027H
VM_NOT_EXECUTEABLE2	EQU	0028H
DESTROY_VM2	EQU	0029H
VM_SUSPEND2	EQU	002AH
END_MESSAGE_MODE2	EQU	002BH
END_PM_APP2	EQU	002CH
DEVICE_REBOOT_NOTIFY2	EQU	002DH
CRIT_REBOOT_NOTIFY2	EQU	002EH
CLOSE_VM_NOTIFY2	EQU	002FH
GET_CONTENTION_HANDLER	EQU	0030H
KERNEL32_INITIALIZED	EQU	0031H
KERNEL32_SHUTDOWN	EQU	0032H
CREATE_PROCESS	EQU	0033H
DESTROY_PROCESS	EQU	0034H
ifndef WIN40COMPAT
SYS_DYNAMIC_DEVICE_REINIT	EQU	0035H
endif
SYS_POWER_DOWN	EQU	0036H
MAX_SYSTEM_CONTROL	EQU	0036H
BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	70000000H
END_RESERVED_PRIVATE_SYSTEM_CONTROL	EQU	7FFFFFFFH
endif
SYSSTATE_PRESYSCRITINIT	EQU	00000000H
SYSSTATE_PREDEVICEINIT	EQU	10000000H
SYSSTATE_PREINITCOMPLETE	EQU	20000000H
SYSSTATE_VXDINITCOMPLETED	EQU	40000000H
SYSSTATE_KERNEL32INITED	EQU	50000000H
SYSSTATE_KERNEL32TERMINATED	EQU	0A0000000H
SYSSTATE_PRESYSVMTERMINATE	EQU	0B0000000H
SYSSTATE_PRESYSTEMEXIT	EQU	0E0000000H
SYSSTATE_PRESYSTEMEXIT2	EQU	0E4000000H
SYSSTATE_PRESYSCRITEXIT	EQU	0F0000000H
SYSSTATE_PRESYSCRITEXIT2	EQU	0F4000000H
SYSSTATE_POSTSYSCRITEXIT2	EQU	0FFF00000H
SYSSTATE_PREDEVICEREBOOT	EQU	0FFFF0000H
SYSSTATE_PRECRITREBOOT	EQU	0FFFFF000H
SYSSTATE_PREREBOOTCPU	EQU	0FFFFFF00H
BeginDoc












































































EndDoc












??_pf_Check equ 1
??_pf_ArgsUsed	equ 2
??_pf_Entered	equ 4
??_pf_Left  equ 8
??_pf_Returned	equ    16

??_pushed	=	0
??_align    =	0
??_ends     equ <>

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0
    ??_aframe = 0
    ??_taframe = 0
    ??_initaframe = 0
    ??_numargs = 0
    ??_numlocals = 0
    ??_numlocalsymbols = 0
    ??_procflags = 0
    ??_esp = 0
    ??_pushed = 0
    ??_align = 0
    ??_hook = 0
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG
    ??_profile = DFS_PROFILE
    ??_test_cld = DFS_TEST_CLD
ELSE
    ??_log = 0
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
ELSE
    ??_profile = 0
ENDIF
    ??_test_cld = 0
ENDIF
    ??_might_block = 0
    ??_test_reenter = 0
    ??_never_reenter = 0
    ??_not_swapping = 0
    ??_prolog_disabled = 0
    ??_public = 1
    ??_cleanoff = 0
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE

    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>


    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm


    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE
	??_prolog_disabled = 1
    else
	ife ?_PCODE
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif
    endif
    endif

    if ??_esp

    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else

    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall


    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif



    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align
	endif

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif

    Name proc near



    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif



    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif



endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif
	endif
	endif
    endif
    endif
ENDM






?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif
















ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm






?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm



















LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal



EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm















LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm







Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm




EndProc macro Name, Flag
    Name endp
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm







cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall






pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall







sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall














fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall





iCall	equ <sCall>














IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0
ELSE
    ??_popargs = ??_align EQ 0
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1
    elseifidni <flags>, <FAST>
	??_popargs = 0
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm
















ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm



?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg



?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg



?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall



?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm



?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref






CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm



SaveReg macro	reglist
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm







RestoreReg macro     reglist
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm

ifdef DEBUG
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm


endif
ifndef Not_VxD
RESERVED_LOW_BOOST	EQU	00000001H
CUR_RUN_VM_BOOST	EQU	00000004H
LOW_PRI_DEVICE_BOOST	EQU	00000010H
HIGH_PRI_DEVICE_BOOST	EQU	00001000H
CRITICAL_SECTION_BOOST	EQU	00100000H
TIME_CRITICAL_BOOST	EQU	00400000H
RESERVED_HIGH_BOOST	EQU	40000000H
PEF_WAIT_FOR_STI_BIT	EQU	0
PEF_WAIT_FOR_STI	EQU	(1 SHL PEF_WAIT_FOR_STI_BIT)
PEF_WAIT_NOT_CRIT_BIT	EQU	1
PEF_WAIT_NOT_CRIT	EQU	(1 SHL PEF_WAIT_NOT_CRIT_BIT)
PEF_DONT_UNBOOST_BIT	EQU	2
PEF_DONT_UNBOOST	EQU	(1 SHL PEF_DONT_UNBOOST_BIT)
PEF_ALWAYS_SCHED_BIT	EQU	3
PEF_ALWAYS_SCHED	EQU	(1 SHL PEF_ALWAYS_SCHED_BIT)
PEF_TIME_OUT_BIT	EQU	4
PEF_TIME_OUT	EQU	(1 SHL PEF_TIME_OUT_BIT)
PEF_WAIT_NOT_HW_INT_BIT	EQU	5
PEF_WAIT_NOT_HW_INT	EQU	(1 SHL PEF_WAIT_NOT_HW_INT_BIT)
PEF_WAIT_NOT_NESTED_EXEC_BIT	EQU	6
PEF_WAIT_NOT_NESTED_EXEC	EQU	(1 SHL PEF_WAIT_NOT_NESTED_EXEC_BIT)
PEF_WAIT_IN_PM_BIT	EQU	7
PEF_WAIT_IN_PM	EQU	(1 SHL PEF_WAIT_IN_PM_BIT)
PEF_THREAD_EVENT_BIT	EQU	8
PEF_THREAD_EVENT	EQU	(1 SHL PEF_THREAD_EVENT_BIT)
PEF_WAIT_FOR_THREAD_STI_BIT	EQU	9
PEF_WAIT_FOR_THREAD_STI	EQU	(1 SHL PEF_WAIT_FOR_THREAD_STI_BIT)
PEF_RING0_EVENT_BIT	EQU	10
PEF_RING0_EVENT	EQU	(1 SHL PEF_RING0_EVENT_BIT)
PEF_WAIT_CRIT_BIT	EQU	11
PEF_WAIT_CRIT	EQU	(1 SHL PEF_WAIT_CRIT_BIT)
PEF_WAIT_CRIT_VM_BIT	EQU	12
PEF_WAIT_CRIT_VM	EQU	(1 SHL PEF_WAIT_CRIT_VM_BIT)
PEF_PROCESS_LAST_BIT	EQU	13
PEF_PROCESS_LAST	EQU	(1 SHL PEF_PROCESS_LAST_BIT)
PEF_WAIT_PREEMPTABLE_BIT	EQU	14
PEF_WAIT_PREEMPTABLE	EQU	(1 SHL PEF_WAIT_PREEMPTABLE_BIT)
PEF_WAIT_FOR_PASSIVE_BIT	EQU	15
PEF_WAIT_FOR_PASSIVE	EQU	(1 SHL PEF_WAIT_FOR_PASSIVE_BIT)
PEF_WAIT_FOR_APPY_BIT	EQU	16
PEF_WAIT_FOR_APPY	EQU	(1 SHL PEF_WAIT_FOR_APPY_BIT)
PEF_WAIT_FOR_WORKER_BIT	EQU	17
PEF_WAIT_FOR_WORKER	EQU	(1 SHL PEF_WAIT_FOR_WORKER_BIT)
PEF_WAIT_NOT_TIME_CRIT_BIT	EQU	PEF_WAIT_NOT_HW_INT_BIT
PEF_WAIT_NOT_TIME_CRIT	EQU	PEF_WAIT_NOT_HW_INT
PEF_WAIT_NOT_PM_LOCKED_STACK_BIT	EQU	PEF_WAIT_NOT_NESTED_EXEC_BIT
PEF_WAIT_NOT_PM_LOCKED_STACK	EQU	PEF_WAIT_NOT_NESTED_EXEC
PEF_WAIT_FOR_CONFIGMG_CALLABLE	EQU	PEF_WAIT_FOR_WORKER
PEF_WAIT_FOR_CONFIGMG_QUICK	EQU	PEF_WAIT_FOR_APPY
BLOCK_SVC_INTS_BIT	EQU	0
BLOCK_SVC_INTS	EQU	(1 SHL BLOCK_SVC_INTS_BIT)
BLOCK_SVC_IF_INTS_LOCKED_BIT	EQU	1
BLOCK_SVC_IF_INTS_LOCKED	EQU	(1 SHL BLOCK_SVC_IF_INTS_LOCKED_BIT)
BLOCK_ENABLE_INTS_BIT	EQU	2
BLOCK_ENABLE_INTS	EQU	(1 SHL BLOCK_ENABLE_INTS_BIT)
BLOCK_POLL_BIT	EQU	3
BLOCK_POLL	EQU	(1 SHL BLOCK_POLL_BIT)
BLOCK_THREAD_IDLE_BIT	EQU	4
BLOCK_THREAD_IDLE	EQU	(1 SHL BLOCK_THREAD_IDLE_BIT)
BLOCK_FORCE_SVC_INTS_BIT	EQU	5
BLOCK_FORCE_SVC_INTS	EQU	(1 SHL BLOCK_FORCE_SVC_INTS_BIT)

Client_Reg_Struc	STRUC
Client_EDI	DD	?
Client_ESI	DD	?
Client_EBP	DD	?
Client_res0	DD	?
Client_EBX	DD	?
Client_EDX	DD	?
Client_ECX	DD	?
Client_EAX	DD	?
Client_Error	DD	?
Client_EIP	DD	?
Client_CS	DW	?
Client_res1	DW	?
Client_EFlags	DD	?
Client_ESP	DD	?
Client_SS	DW	?
Client_res2	DW	?
Client_ES	DW	?
Client_res3	DW	?
Client_DS	DW	?
Client_res4	DW	?
Client_FS	DW	?
Client_res5	DW	?
Client_GS	DW	?
Client_res6	DW	?
Client_Alt_EIP	DD	?
Client_Alt_CS	DW	?
Client_res7	DW	?
Client_Alt_EFlags	DD	?
Client_Alt_ESP	DD	?
Client_Alt_SS	DW	?
Client_res8	DW	?
Client_Alt_ES	DW	?
Client_res9	DW	?
Client_Alt_DS	DW	?
Client_res10	DW	?
Client_Alt_FS	DW	?
Client_res11	DW	?
Client_Alt_GS	DW	?
Client_res12	DW	?
Client_Reg_Struc	ENDS

Client_Word_Reg_Struc	STRUC
Client_DI	DW	?
Client_res13	DW	?
Client_SI	DW	?
Client_res14	DW	?
Client_BP	DW	?
Client_res15	DW	?
Client_res16	DD	?
Client_BX	DW	?
Client_res17	DW	?
Client_DX	DW	?
Client_res18	DW	?
Client_CX	DW	?
Client_res19	DW	?
Client_AX	DW	?
Client_res20	DW	?
Client_res21	DD	?
Client_IP	DW	?
Client_res22	DW	?
Client_res23	DD	?
Client_Flags	DW	?
Client_res24	DW	?
Client_SP	DW	?
Client_res25	DW	?
Client_res26	DD	5 DUP (?)
Client_Alt_IP	DW	?
Client_res27	DW	?
Client_res28	DD	?
Client_Alt_Flags	DW	?
Client_res29	DW	?
Client_Alt_SP	DW	?
Client_Word_Reg_Struc	ENDS

Client_Byte_Reg_Struc	STRUC
Client_res30	DD	4 DUP (?)
Client_BL	DB	?
Client_BH	DB	?
Client_res31	DW	?
Client_DL	DB	?
Client_DH	DB	?
Client_res32	DW	?
Client_CL	DB	?
Client_CH	DB	?
Client_res33	DW	?
Client_AL	DB	?
Client_AH	DB	?
Client_Byte_Reg_Struc	ENDS
?UnionSize = 0
if size Client_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Reg_Struc
endif
CRS	equ	<(byte ptr 0)>

if size Client_Word_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Word_Reg_Struc
endif
CWRS	equ	<(byte ptr 0)>

if size Client_Byte_Reg_Struc gt ?UnionSize
	?UnionSize = size Client_Byte_Reg_Struc
endif
CBRS	equ	<(byte ptr 0)>


tagCLIENT_STRUC	STRUC
	DB	?UnionSize dup(?)
tagCLIENT_STRUC	ENDS

IF 0
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX

endif
DYNA_LINK_INT	EQU	20H












DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm






DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc













EndDoc


BeginDoc








EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

WDMCall MACRO P, Param, flags
    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    mov	eax,WDM@@&P
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

WDMJmp	MACRO P, Param
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to WDMJmp>
    endif
    mov	eax, WDM@@&P+WDM_DL_Jmp_Mask
    int WDM_DynaLink_Int
    nop
    nop
    nop
    ENDM

WDM_DL_Jmp_Mask	EQU	80000000h
WDM_DL_Jmp_Bit	EQU	31

BeginDoc




























EndDoc




VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM




VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM




VxD_DEBUG_ONLY_CODE_SEG MACRO
_DB1CODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DB1CODE    ENDS
	ENDM




VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS




VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM




VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM




VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM




VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM




VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM



VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DB2DATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DB2DATA    ENDS
	ENDM




VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM



VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM

endif
ifndef DDK_VERSION
ifdef WIN31COMPAT
DDK_VERSION	EQU	30AH
else
ifdef WIN40COMPAT
DDK_VERSION	EQU	400H
else
DDK_VERSION	EQU	40AH
endif
endif
endif

VxD_Desc_Block	STRUC
DDB_Next	DD	?
DDB_SDK_Version	DW	DDK_VERSION
DDB_Req_Device_Number	DW	UNDEFINED_DEVICE_ID
DDB_Dev_Major_Version	DB	0
DDB_Dev_Minor_Version	DB	0
DDB_Flags	DW	0
DDB_Name	DB	"        "
DDB_Init_Order	DD	UNDEFINED_INIT_ORDER
DDB_Control_Proc	DD	?
DDB_V86_API_Proc	DD	0
DDB_PM_API_Proc	DD	0
DDB_V86_API_CSIP	DD	0
DDB_PM_API_CSIP	DD	0
DDB_Reference_Data	DD	?
DDB_Service_Table_Ptr	DD	0
DDB_Service_Table_Size	DD	0
DDB_Win32_Service_Table	DD	0
DDB_Prev	DD	'Prev'
DDB_Size	DD	SIZE(VxD_Desc_Block)
DDB_Reserved1	DD	'Rsv1'
DDB_Reserved2	DD	'Rsv2'
DDB_Reserved3	DD	'Rsv3'
VxD_Desc_Block	ENDS
ifndef Not_VxD
DDB_SYS_CRIT_INIT_DONE_BIT	EQU	0
DDB_SYS_CRIT_INIT_DONE	EQU	(1 SHL DDB_SYS_CRIT_INIT_DONE_BIT)
DDB_DEVICE_INIT_DONE_BIT	EQU	1
DDB_DEVICE_INIT_DONE	EQU	(1 SHL DDB_DEVICE_INIT_DONE_BIT)
DDB_HAS_WIN32_SVCS_BIT	EQU	14
DDB_HAS_WIN32_SVCS	EQU	(1 SHL DDB_HAS_WIN32_SVCS_BIT)
DDB_DYNAMIC_VXD_BIT	EQU	15
DDB_DYNAMIC_VXD	EQU	(1 SHL DDB_DYNAMIC_VXD_BIT)
DDB_DEVICE_DYNALINKED_BIT	EQU	13
DDB_DEVICE_DYNALINKED	EQU	(1 SHL DDB_DEVICE_DYNALINKED_BIT)
BeginDoc







EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM





























Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc




















EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF

    ENDM

BYTE_INPUT	EQU	000H
BYTE_OUTPUT	EQU	004H
WORD_INPUT	EQU	008H
WORD_OUTPUT	EQU	00CH
DWORD_INPUT	EQU	010H
DWORD_OUTPUT	EQU	014H
OUTPUT_BIT	EQU	2
OUTPUT	EQU	(1 SHL OUTPUT_BIT)
WORD_IO_BIT	EQU	3
WORD_IO	EQU	(1 SHL WORD_IO_BIT)
DWORD_IO_BIT	EQU	4
DWORD_IO	EQU	(1 SHL DWORD_IO_BIT)
STRING_IO_BIT	EQU	5
STRING_IO	EQU	(1 SHL STRING_IO_BIT)
REP_IO_BIT	EQU	6
REP_IO	EQU	(1 SHL REP_IO_BIT)
ADDR_32_IO_BIT	EQU	7
ADDR_32_IO	EQU	(1 SHL ADDR_32_IO_BIT)
REVERSE_IO_BIT	EQU	8
REVERSE_IO	EQU	(1 SHL REVERSE_IO_BIT)
IO_SEG_MASK	EQU	0FFFF0000H
IO_SEG_SHIFT	EQU	10H
BeginDoc






EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc







EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM

BeginDoc








EndDoc


VxD_IOT_Hdr	STRUC
VxD_IO_Ports	DW	?
VxD_IOT_Hdr	ENDS

VxD_IO_Struc	STRUC
VxD_IO_Port	DW	?
VxD_IO_Proc	DD	?
VxD_IO_Struc	ENDS
.ERRNZ SIZE VxD_IOT_Hdr - 2
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE
    dw	Table_Name&_Entries
ENDIF

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM













Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc














EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc















EndDoc

CallJmp MACRO Function_Name, Return_Label
IFDEF DEBUG
    call    Function_Name
    jmp     Return_Label
ELSE
    push    Return_Label
    jmp     Function_Name
ENDIF
    ENDM


BeginDoc






EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF



PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16











Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM



VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm

endif
DUPLICATE_DEVICE_ID_BIT	EQU	0
DUPLICATE_DEVICE_ID	EQU	(1 SHL DUPLICATE_DEVICE_ID_BIT)
DUPLICATE_FROM_INT2F_BIT	EQU	1
DUPLICATE_FROM_INT2F	EQU	(1 SHL DUPLICATE_FROM_INT2F_BIT)
LOADING_FROM_INT2F_BIT	EQU	2
LOADING_FROM_INT2F	EQU	(1 SHL LOADING_FROM_INT2F_BIT)
DEVICE_LOAD_OK	EQU	0
ABORT_DEVICE_LOAD	EQU	1
ABORT_WIN386_LOAD	EQU	2
DEVICE_NOT_NEEDED	EQU	3
NO_FAIL_MESSAGE_BIT	EQU	15
NO_FAIL_MESSAGE	EQU	(1 SHL NO_FAIL_MESSAGE_BIT)
LDRSRV_GET_PROFILE_STRING	EQU	0
LDRSRV_GET_NEXT_PROFILE_STRING	EQU	1
LDRSRV_RESERVED	EQU	2
LDRSRV_GET_PROFILE_BOOLEAN	EQU	3
LDRSRV_GET_PROFILE_DECIMAL_INT	EQU	4
LDRSRV_GET_PROFILE_HEX_INT	EQU	5
LDRSRV_COPY_EXTENDED_MEMORY	EQU	6
LDRSRV_GET_MEMORY_INFO	EQU	7
LDRSRV_RegOpenKey	EQU	100H
LDRSRV_RegCreateKey	EQU	101H
LDRSRV_RegCloseKey	EQU	102H
LDRSRV_RegDeleteKey	EQU	103H
LDRSRV_RegSetValue	EQU	104H
LDRSRV_RegQueryValue	EQU	105H
LDRSRV_RegEnumKey	EQU	106H
LDRSRV_RegDeleteValue	EQU	107H
LDRSRV_RegEnumValue	EQU	108H
LDRSRV_RegQueryValueEx	EQU	109H
LDRSRV_RegSetValueEx	EQU	10AH
LDRSRV_RegFlushKey	EQU	10BH
LDRSRV_COPY_INIT	EQU	1
LDRSRV_COPY_LOCKED	EQU	2
LDRSRV_COPY_PAGEABLE	EQU	3
RCODE_OBJ	EQU	-1
LCODE_OBJ	EQU	01H
LDATA_OBJ	EQU	02H
PCODE_OBJ	EQU	03H
PDATA_OBJ	EQU	04H
SCODE_OBJ	EQU	05H
SDATA_OBJ	EQU	06H
CODE16_OBJ	EQU	07H
LMSG_OBJ	EQU	08H
PMSG_OBJ	EQU	09H
DBOC_OBJ	EQU	0BH
DBOD_OBJ	EQU	0CH
PLCODE_OBJ	EQU	0DH
PPCODE_OBJ	EQU	0FH
ICODE_OBJ	EQU	11H
IDATA_OBJ	EQU	12H
ICODE16_OBJ	EQU	13H
IMSG_OBJ	EQU	14H

ObjectLocation	STRUC
OL_LinearAddr	DD	?
OL_Size	DD	?
OL_ObjType	DB	?
ObjectLocation	ENDS
MAXOBJECTS	EQU	25

Device_Location_List	STRUC
DLL_DDB	DD	?
DLL_NumObjects	DB	?
DLL_ObjLocation	DB	SIZE ObjectLocation * 1 DUP (?)
Device_Location_List	ENDS
PE_BIT	EQU	0
PE_MASK	EQU	(1 SHL PE_BIT)
MP_BIT	EQU	1
MP_MASK	EQU	(1 SHL MP_BIT)
EM_BIT	EQU	2
EM_MASK	EQU	(1 SHL EM_BIT)
TS_BIT	EQU	3
TS_MASK	EQU	(1 SHL TS_BIT)
ET_BIT	EQU	4
ET_MASK	EQU	(1 SHL ET_BIT)
PG_BIT	EQU	31
PG_MASK	EQU	(1 SHL PG_BIT)
CF_BIT	EQU	0
CF_MASK	EQU	(1 SHL CF_BIT)
PF_BIT	EQU	2
PF_MASK	EQU	(1 SHL PF_BIT)
AF_BIT	EQU	4
AF_MASK	EQU	(1 SHL AF_BIT)
ZF_BIT	EQU	6
ZF_MASK	EQU	(1 SHL ZF_BIT)
SF_BIT	EQU	7
SF_MASK	EQU	(1 SHL SF_BIT)
TF_BIT	EQU	8
TF_MASK	EQU	(1 SHL TF_BIT)
IF_BIT	EQU	9
IF_MASK	EQU	(1 SHL IF_BIT)
DF_BIT	EQU	10
DF_MASK	EQU	(1 SHL DF_BIT)
OF_BIT	EQU	11
OF_MASK	EQU	(1 SHL OF_BIT)
IOPL_MASK	EQU	3000H
IOPL_BIT0	EQU	12
IOPL_BIT1	EQU	13
NT_BIT	EQU	14
NT_MASK	EQU	(1 SHL NT_BIT)
RF_BIT	EQU	16
RF_MASK	EQU	(1 SHL RF_BIT)
VM_BIT	EQU	17
VM_MASK	EQU	(1 SHL VM_BIT)
AC_BIT	EQU	18
AC_MASK	EQU	(1 SHL AC_BIT)
VIF_BIT	EQU	19
VIF_MASK	EQU	(1 SHL VIF_BIT)
VIP_BIT	EQU	20
VIP_MASK	EQU	(1 SHL VIP_BIT)






IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF

P_SIZE	EQU	1000H
P_PRESBIT	EQU	0
P_PRES	EQU	(1 SHL P_PRESBIT)
P_WRITEBIT	EQU	1
P_WRITE	EQU	(1 SHL P_WRITEBIT)
P_USERBIT	EQU	2
P_USER	EQU	(1 SHL P_USERBIT)
P_ACCBIT	EQU	5
P_ACC	EQU	(1 SHL P_ACCBIT)
P_DIRTYBIT	EQU	6
P_DIRTY	EQU	(1 SHL P_DIRTYBIT)
P_AVAIL	EQU	(P_PRES+P_WRITE+P_USER)
PG_VM	EQU	0
PG_SYS	EQU	1
PG_RESERVED1	EQU	2
PG_PRIVATE	EQU	3
PG_RESERVED2	EQU	4
PG_RELOCK	EQU	5
PG_INSTANCE	EQU	6
PG_HOOKED	EQU	7
PG_IGNORE	EQU	0FFFFFFFFH
D_PRES	EQU	080H
D_NOTPRES	EQU	0
D_DPL0	EQU	0
D_DPL1	EQU	020H
D_DPL2	EQU	040H
D_DPL3	EQU	060H
D_SEG	EQU	010H
D_CTRL	EQU	0
D_GRAN_BYTE	EQU	000H
D_GRAN_PAGE	EQU	080H
D_DEF16	EQU	000H
D_DEF32	EQU	040H
D_CODE	EQU	08H
D_DATA	EQU	0
D_X	EQU	0
D_RX	EQU	02H
D_C	EQU	04H
D_R	EQU	0
D_W	EQU	02H
D_ED	EQU	04H
D_ACCESSED	EQU	1
RW_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_W)
R_DATA_TYPE	EQU	(D_PRES+D_SEG+D_DATA+D_R)
CODE_TYPE	EQU	(D_PRES+D_SEG+D_CODE+D_RX)
D_PAGE32	EQU	(D_GRAN_PAGE+D_DEF32)
SELECTOR_MASK	EQU	0FFF8H
SEL_LOW_MASK	EQU	0F8H
TABLE_MASK	EQU	04H
RPL_MASK	EQU	03H
RPL_CLR	EQU	(NOT RPL_MASK)
IVT_ROM_DATA_SIZE	EQU	500H
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\detect\findoem.cpp ===
/*** findoem.cpp - OEM detection interface
 *
 *  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Author:     Yan Leshinsky (YanL)
 *  Created     10/08/98
 *
 *  MODIFICATION HISTORY
 *	10/07/2000	waltw	Ripped out auto_hkey, auto_hfile, auto_hlib, _com_ptr_t (_COM_SMARTPTR_TYPEDEF),
 *						bstr_t, variant_t, & exceptions. Converted to generic text mappings
 *						(Unicode or ANSI compile)
 *	11/02/2000	waltw	Stub out VxD functions for Unicode builds and ia64 ANSI builds.
 */

#define		_WIN32_DCOM		// so we can attempt to call CoInitializeSecurity
#include <comdef.h>
#include <tchar.h>
#include <windows.h>
#include <objbase.h>
#include <ole2.h>
#include<MISTSAFE.h>

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif

#include <logging.h>
#include <iucommon.h>

#include <wuiutest.h>
#include <wbemcli.h>
#include <wubios.h>
#include <osdet.h>
#include <wusafefn.h>

//
// Do we really want a VxD?
//
#if defined(IA64) || defined(_IA64_) || defined(UNICODE) || defined(_UNICODE)
// It's gone...
#define NUKE_VXD 1
#else
// We still have friends on Win9x platforms
#define NUKE_VXD 0
#endif

// hardcodes - not defined in any header
const CLSID CLSID_WbemLocator = {0x4590f811,0x1d3a,0x11d0,{0x89,0x1f,0x00,0xaa,0x00,0x4b,0x2e,0x24}};

#if NUKE_VXD == 0
const TCHAR WUBIOS_VXD_NAME[] = {_T("\\\\.\\WUBIOS.VXD")};
#endif



#define BYTEOF(d,i)	(((BYTE *)&(d))[i])

// used in UseVxD()
HINSTANCE g_hinst;

/*** Local function prototypes
 */

static void UseOeminfoIni(POEMINFO pOemInfo);
static void UseAcpiReg(POEMINFO pOemInfo);
static void UseWBEM(POEMINFO pOemInfo);
static void UseVxD(POEMINFO pOemInfo);
static bool ReadFromReg(POEMINFO pOemInfo);
static void SaveToReg(POEMINFO pOemInfo);

/*** Registry access
 */
static const TCHAR REGSTR_KEY_OEMINFO[]		= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\OemInfo");
static const TCHAR REGSTR_VAL_MASK[]		= _T("Mask");
static const TCHAR REGSTR_VAL_ACPIOEM[]		= _T("AcpiOem");
static const TCHAR REGSTR_VAL_ACPIPRODUCT[]	= _T("AcpiProduct");
static const TCHAR REGSTR_VAL_SMBOEM[]		= _T("SmbOem");
static const TCHAR REGSTR_VAL_SMBPRODUCT[]	= _T("SmbProduct");
static const TCHAR REGSTR_VAL_PNPOEMID[]	= _T("PnpOemId");
static const TCHAR REGSTR_VAL_INIOEM[]		= _T("IniOem");
static const TCHAR REGSTR_VAL_WBEMOEM[]		= _T("WbemOem");
static const TCHAR REGSTR_VAL_WBEMPRODUCT[]	= _T("WbemProduct");
static const TCHAR REGSTR_VAL_OEMINFO_VER[]	= _T("OemInfoVersion");	// used to determine if we need to nuke old values
static const TCHAR REGSTR_VAL_SUPPORTURL[]	= _T("OemSupportURL");

//
// forward declarations
//
HRESULT GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave = false);
BSTR StringID(DWORD dwID);



//
//	Increment REG_CURRENT_OEM_VER whenever you need to force override of
//	old values written to the OemInfo key. Doesn't need to change for each
//	new control version.
//
//	History: No version - original controls
//			 Version 1	- WUV3 when OEM functions first fixed Aug. 2000
//			 Version 2	- IU control
#define REG_CURRENT_OEM_VER	2

// Based on V3 MakeAndModel
//  Note that for OEMINFO_PNP_PRESENT or
//  OEMINFO_INI_PRESENT the model BSTR is an empty string.
HRESULT GetOemBstrs(BSTR& bstrManufacturer, BSTR& bstrModel, BSTR& bstrSupportURL)
{
	USES_IU_CONVERSION;

	LOG_Block("GetOemBstrs");

	if(NULL != bstrManufacturer || NULL != bstrModel || NULL != bstrSupportURL)
	{
		// BSTRs must be NULL on entry
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	// Collect all the data possible, but always prefer in the following order
	//				Win98	WinME	NT4		Win2k/WinXP
	//	-----------------------------------------
	//	WBEM/WMI	1		1		1		1
	//	SMBIOS/DMI	3		3					// wubios.vxd
	//	ACPI		2		2				2	// UseAcpiReg or wubios.vxd
	//	PNP			4		4					// wubios.vxd		
	//	OEMInfo.ini	5		5		2
	
	//
	// Move OEMINFO to heap per Prefast warning 831: GetOemBstrs uses 5792 bytes
	// of stack, consider moving some data to heap.  
	//
	POEMINFO pOemInfo = NULL;
	HRESULT hr;

	pOemInfo = (POEMINFO) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(OEMINFO));
	if (NULL == pOemInfo)
	{
		LOG_ErrorMsg(E_OUTOFMEMORY);
		return E_OUTOFMEMORY;
	}
	//
	// Fill in the pOemInfo struct.
	//
	if (SUCCEEDED(hr = GetOemInfo(pOemInfo)))
	{
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szWbemOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szWbemProduct));
		}
		// NTRAID#NTBUG9-248906-2000/12/13-waltw IU: Improve OEM detection and reporting.
		//	prefer SMBIOS over ACPI, and always try to report OEM support URL.
		else if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szSmbOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szSmbProduct));
		}
		else if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szAcpiOem));
			bstrModel			= SysAllocString(T2OLE(pOemInfo->szAcpiProduct));
		}
		else if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			bstrManufacturer	= StringID(pOemInfo->dwPnpOemId);
			bstrModel			= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}
		else if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			bstrManufacturer	= SysAllocString(T2OLE(pOemInfo->szIniOem));
			bstrModel			= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}

		//
		// Always return the OEMSupportURL if available
		//
		if (0 < lstrlen(pOemInfo->szIniOemSupportUrl))
		{
			bstrSupportURL		= SysAllocString(T2OLE(pOemInfo->szIniOemSupportUrl));
		}
		else
		{
			bstrSupportURL		= SysAllocString(T2OLE(_T("")));	// empty BSTR
		}

		//
		// Manufacturer and Model are optional (if !pOemInfo->dwMask)
		//
		if (	(pOemInfo->dwMask && (NULL == bstrManufacturer || NULL == bstrModel)) ||
				NULL == bstrSupportURL	)
		{
			SafeSysFreeString(bstrManufacturer);
			SafeSysFreeString(bstrModel);
			SafeSysFreeString(bstrSupportURL);

			LOG_ErrorMsg(E_OUTOFMEMORY);
			hr = E_OUTOFMEMORY;
		}
	}

	SafeHeapFree(pOemInfo);
	return hr;
}

/*** GetOemInfo - Gather all available machine OEM and model information
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      
 */
HRESULT GetOemInfo(POEMINFO pOemInfo, bool fAlwaysDetectAndDontSave /*= false*/)
{
	LOG_Block("GetOemInfo");
	HRESULT hr;

	if (!pOemInfo)
	{
		LOG_Error(_T("E_INVALIDARG"));
		SetHrAndGotoCleanUp(E_INVALIDARG);
	}
	// Worst case:
	ZeroMemory(pOemInfo, sizeof(OEMINFO)); 
	// Do detection if necessary or requested
	if (fAlwaysDetectAndDontSave || ! ReadFromReg(pOemInfo))
	{
		//
		// Always attempt to get strings from oeminfo.ini, if present
		//
		UseOeminfoIni(pOemInfo);

		OSVERSIONINFO	osvi;
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if (GetVersionEx(&osvi))
		{
			if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId)
			{
				UseWBEM(pOemInfo);
				UseVxD(pOemInfo);
			}
			else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
			{
				if (4 < osvi.dwMajorVersion)
				{
					// Win2k and higher
					UseWBEM(pOemInfo);
					UseAcpiReg(pOemInfo);
				}
				else
				{
					UseWBEM(pOemInfo);
				}
			}
			// Save info to the registry
			if (!fAlwaysDetectAndDontSave)
			{
				SaveToReg(pOemInfo);
			}
		}
		else
		{
			LOG_Driver(_T("GetVersionEx:"));
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
	}

	//
	// Manufacturer and Model are now optional (RAID#337879	IU: can't get latest IU controls
	// to work with IU site) so it is OK to return with no information
	//

	return S_OK;

CleanUp:
	//
	// Only used for returning errors
	//
	return hr;
}


/***LP  StringID - convert numeric ID to string ID
 *
 *  ENTRY
 *      dwID - numeric PnP ID
 *
 *  EXIT
 *      returns string ID
 */

BSTR StringID(DWORD dwID)
{
	LOG_Block("StringID");

	USES_IU_CONVERSION;
	TCHAR szID[8];
    WORD wVenID;
    int i;

	wVenID = (WORD)(((dwID & 0x00ff) << 8) | ((dwID & 0xff00) >> 8));
	wVenID <<= 1;

	for (i = 0; i < 3; ++i)
	{
		szID[i] = (TCHAR)(((wVenID & 0xf800) >> 11) + 0x40);
		wVenID <<= 5;
	}
	wVenID = HIWORD(dwID);
	wVenID = (WORD)(((wVenID & 0x00ff) << 8) | ((wVenID & 0xff00) >> 8));
	for (i = 6; i > 2; --i)
	{
		szID[i] = (TCHAR)(wVenID & 0x000F);
		if(szID[i] > 9)
		{
			szID[i] += 0x37; // 'A' - 0xA	for digits A to F
		}
		else
		{
			szID[i] += 0x30; // '0'			for digits 0 to 9
		}
		wVenID >>= 4;
	}

    return SysAllocString(T2OLE(szID));
} //StringID


/*** UseOeminfoIni - get OemInfo from OEMINFO.INI
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseOeminfoIni(POEMINFO pOemInfo)
{
	LOG_Block("UseOeminfoIni");
	static const TCHAR szFile[]			= _T("OEMINFO.INI");
	static const TCHAR szSection[]		= _T("General");
	static const TCHAR szKey[]			= _T("Manufacturer");
	static const TCHAR szSupportURL[]	= _T("SupportURL");

	HRESULT hr=S_OK;
	

	TCHAR szPath[MAX_PATH + 1];
	// OEMINFO.INI is in system directory
	if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)) > 0)
	{
		hr=PathCchAppend(szPath,ARRAYSIZE(szPath),szFile);

		if(FAILED(hr))
		{
			LOG_ErrorMsg(HRESULT_CODE(hr));
			return;
		}

		GetPrivateProfileString(szSection, szKey, _T(""), 
			pOemInfo->szIniOem, ARRAYSIZE(pOemInfo->szIniOem), szPath);
		if (lstrlen(pOemInfo->szIniOem))
		{
			pOemInfo->dwMask |= OEMINFO_INI_PRESENT;
			LOG_Driver(_T("Set OEMINFO_INI_PRESENT bit"));
		}
		//
		// We'll use szIniOemSupportUrl any time we can get it, but don't need to set flag
		//
		GetPrivateProfileString(szSection, szSupportURL, _T(""), 
			pOemInfo->szIniOemSupportUrl, ARRAYSIZE(pOemInfo->szIniOemSupportUrl), szPath);
   }
}

/*** UseAcpiReg - get OemInfo from the registry
 *
 *  Structure of the registry will be:
 *	HKEY_LOCAL_MACHINE\Hardware\ACPI\<TableSig>\<OEMID>\<TableID>\<TableRev>
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseAcpiReg(POEMINFO pOemInfo)
{
	LOG_Block("UseAcpiReg");

	static const TCHAR szRSDT[] = _T("Hardware\\ACPI\\DSDT");
	HKEY hKeyTable;
	LONG lRet;
	if (NO_ERROR ==(lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRSDT, 0, MAXIMUM_ALLOWED, &hKeyTable)))
	{
		if (NO_ERROR == (lRet = RegEnumKey(hKeyTable, 0, pOemInfo->szAcpiOem, sizeof(pOemInfo->szAcpiOem)/sizeof(TCHAR))))
		{
			HKEY hKeyOEM;
			if (NO_ERROR == (lRet = RegOpenKeyEx(hKeyTable, pOemInfo->szAcpiOem, 0, MAXIMUM_ALLOWED, &hKeyOEM)))
			{
				if (NO_ERROR == (lRet = RegEnumKey(hKeyOEM, 0, pOemInfo->szAcpiProduct, sizeof(pOemInfo->szAcpiProduct)/sizeof(TCHAR))))
				{
					pOemInfo->dwMask |= OEMINFO_ACPI_PRESENT;
					LOG_Driver(_T("Set OEMINFO_ACPI_PRESENT bit"));
				}
				else
				{
					LOG_Error(_T("RegEnumKey:"));
					LOG_ErrorMsg(lRet);
				}
				RegCloseKey(hKeyOEM);
			}
			else
			{
				LOG_Error(_T("RegOpenKeyEx:"));
				LOG_ErrorMsg(lRet);
			}
		}
		else
		{
			LOG_Error(_T("RegEnumKey:"));
			LOG_ErrorMsg(lRet);
		}
		RegCloseKey(hKeyTable);
	}
	else
	{
		LOG_Error(_T("RegOpenKeyEx:"));
		LOG_ErrorMsg(lRet);
	}
}

/*** UseWBEM - Get info through WBEM access
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */

void UseWBEM(POEMINFO pOemInfo)
{
	LOG_Block("UseWBEM");

	USES_IU_CONVERSION;

	IWbemLocator* pWbemLocator = NULL;
	IWbemServices* pWbemServices = NULL;
	IEnumWbemClassObject* pEnum = NULL;
	IWbemClassObject* pObject = NULL;
	BSTR bstrNetworkResource = NULL;
	BSTR bstrComputerSystem = NULL;
	VARIANT var;
	VariantInit(&var);
	HRESULT hr;

	if (NULL == pOemInfo)
		return;

	// Create Locator
	if (FAILED(hr =  CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, __uuidof(IWbemLocator), (LPVOID*) &pWbemLocator)))
	{
		LOG_Error(_T("CoCreateInstance returned 0x%08x in UseWBEM"), hr);
		goto CleanUp;
	}
	
	// Get services
	if (bstrNetworkResource = SysAllocString(L"\\\\.\\root\\cimv2"))
	{
		if (FAILED(pWbemLocator->ConnectServer(bstrNetworkResource, NULL, NULL, 0L, 0L, NULL, NULL, &pWbemServices)))
		{
			LOG_Error(_T("pWbemLocator->ConnectServer returned 0x%08x in UseWBEM"), hr);
			goto CleanUp;
		}
		if (FAILED(hr = CoSetProxyBlanket(pWbemServices, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
					   RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))
		{
			LOG_Error(_T("CoSetProxyBlanket returned 0x%08x in UseWBEM"), hr);
			goto CleanUp;
		}

		// Create enumerator
		if (bstrComputerSystem = SysAllocString(L"Win32_ComputerSystem"))
		{
			if (FAILED(hr = pWbemServices->CreateInstanceEnum(bstrComputerSystem, 0, NULL, &pEnum)))
			{
				goto CleanUp;
			}
			if (FAILED(CoSetProxyBlanket(pEnum, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
						   RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE)))
			{
				goto CleanUp;
			}

			// Get our object now
			ULONG uReturned = 1;
			hr = pEnum->Next(
					6000,           // timeout in six seconds
					1,              // return just one storage device
					&pObject,		// pointer to storage device
					&uReturned);	// number obtained: one or zero
			//
			// 569939 Need to verify IEnumWbemClassObject::Next uReturned value
			//
			if (FAILED(hr) || 0 == uReturned || NULL == pObject)
			{
				goto CleanUp;
			}


			if (FAILED(hr = pObject->Get(L"Manufacturer", 0L, &var, NULL, NULL)))
			{
				goto CleanUp;
			}

			if (VT_BSTR == var.vt)
			{
				lstrcpyn(pOemInfo->szWbemOem, OLE2T(var.bstrVal), ARRAYSIZE(pOemInfo->szWbemOem));
			}

			//
			// 569968  Call VariantClear before line 549 to prevent leak of BSTR
			//
			VariantClear(&var);

			if (FAILED(hr = pObject->Get(L"Model", 0L, &var, NULL, NULL)))
			{
				goto CleanUp;
			}

			if (VT_BSTR == var.vt) 
			{
				lstrcpyn(pOemInfo->szWbemProduct, OLE2T(var.bstrVal), ARRAYSIZE(pOemInfo->szWbemProduct));
			}

			if (0 != lstrlen(pOemInfo->szWbemOem) || 0 != lstrlen(pOemInfo->szWbemProduct))
			{
				pOemInfo->dwMask |= OEMINFO_WBEM_PRESENT;
				LOG_Driver(_T("Set OEMINFO_WBEM_PRESENT"));
			}
		}
		else
		{
			LOG_Error(_T("SysAllocString failed in UseWBEM"));
		}
	}

CleanUp:
		SafeReleaseNULL(pWbemLocator);

		SafeReleaseNULL(pWbemServices);

		SafeReleaseNULL(pEnum);

		SafeReleaseNULL(pObject);

		SysFreeString(bstrNetworkResource);

		SysFreeString(bstrComputerSystem);

		if (VT_EMPTY != var.vt)
			VariantClear(&var);
	return;
}

/*** Calls to wubios.vxd
 */
class CWubiosVxD
{
public:
	bool Init(HMODULE hModuleGlobal);
	PBYTE GetAcpiTable(DWORD dwTabSig);
	PBYTE GetSmbTable(DWORD dwTableType);
	DWORD GetPnpOemId();

	CWubiosVxD();
	~CWubiosVxD();

private:
	HANDLE m_hVxD;
	TCHAR m_szVxdPath[MAX_PATH + 1];
};

CWubiosVxD::CWubiosVxD()
{
	LOG_Block("CWubiosVxD::CWubiosVxD");

	m_hVxD = INVALID_HANDLE_VALUE;
	m_szVxdPath[0] = _T('\0');
}

CWubiosVxD::~CWubiosVxD()
{
	LOG_Block("CWubiosVxD::~CWubiosVxD");

	if	(INVALID_HANDLE_VALUE != m_hVxD)
	{
		CloseHandle(m_hVxD);
	}

	if (0 != lstrlen(m_szVxdPath))
	{
		DeleteFile(m_szVxdPath);
	}
}


/***LP  CWubiosVxD::Init - Loads VxD
 *
 *  ENTRY
 *      none
 *
 *  EXIT
 *      path
 */
bool CWubiosVxD::Init(HMODULE hModuleGlobal)
{
	LOG_Block("CWubiosVxD::Init");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return false;
#else
	bool fRet = false;
	HMODULE hModule = NULL;
	HRSRC hrscVxd = 0;
	HGLOBAL hRes = 0;
	PBYTE pImage = NULL;
	DWORD dwResSize = 0;
	DWORD dwWritten = 0;
	DWORD dwVersion = ~WUBIOS_VERSION;
	HANDLE hfile = INVALID_HANDLE_VALUE;
	TCHAR szMyFileName[MAX_PATH + 1];

	HRESULT hr=S_OK;
	// Init
	if (0 == GetSystemDirectory(m_szVxdPath, ARRAYSIZE(m_szVxdPath)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	
	hr=PathCchAppend(m_szVxdPath,ARRAYSIZE(m_szVxdPath),_T("\\wubios.vxd"));
	if(FAILED(hr))
	{
		LOG_ErrorMsg(HRESULT_CODE(hr));
		goto CleanUp;
	}


	if (0 == GetModuleFileName(hModuleGlobal, szMyFileName, ARRAYSIZE(szMyFileName)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	hModule = LoadLibraryEx(szMyFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
	if (INVALID_HANDLE_VALUE == hModule)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	// Get Vxd from resource and save it
	hrscVxd = FindResource(hModule, _T("WUBIOS"), RT_VXD);			
	if (0 == hrscVxd)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (0 == (hRes = LoadResource(hModule, hrscVxd)))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	pImage = (PBYTE) LockResource(hRes);
	if (NULL == pImage)
	{
		LOG_Error(_T("LockResource failed"));
		goto CleanUp;
	}

	dwResSize = SizeofResource(hModule, hrscVxd);
	if (0 == dwResSize)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	hfile = CreateFile(m_szVxdPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == hfile)
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	else
	{
		LOG_Driver(_T("Success: CreateFile \"%s\""), m_szVxdPath);
	}

	if (0 == WriteFile(hfile, pImage, dwResSize, &dwWritten, NULL))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

	if (0 == CloseHandle(hfile))
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}
	hfile = INVALID_HANDLE_VALUE;

	if (dwWritten != dwResSize)
	{
		LOG_Error(_T("WriteFile wrote %d bytes to \"%s\", should be %d"), dwWritten, m_szVxdPath, dwResSize);
		goto CleanUp;
	}

	// Load Vxd
	if (INVALID_HANDLE_VALUE != (m_hVxD = CreateFile(WUBIOS_VXD_NAME, 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL)))
	{
		// Check version
		if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_VERSION, NULL, 0, &dwVersion, sizeof(dwVersion), NULL, NULL))
		{
			if (dwVersion == WUBIOS_VERSION)
			{
				fRet = true;
			}
			else
			{
				LOG_Error(_T("Wrong VxD Version"));
				CloseHandle(m_hVxD);
				m_hVxD = INVALID_HANDLE_VALUE;
				goto CleanUp;
			}
		}
		else
		{
			LOG_ErrorMsg(GetLastError());
			goto CleanUp;
		}
	}
	else
	{
		LOG_ErrorMsg(GetLastError());
		goto CleanUp;
	}

CleanUp:

	if (INVALID_HANDLE_VALUE != hfile)
		CloseHandle(hfile);

	if (hModule)
		FreeLibrary(hModule);

	return fRet;
#endif	// NUKE_VXD
}

/***LP CWubiosVxD::GetAcpiTable - Get table
 *
 *  ENTRY
 *      m_hVxD - VxD handle
 *      dwTabSig - table signature
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */
PBYTE CWubiosVxD::GetAcpiTable(DWORD dwTabSig)
{
	LOG_Block("CWubiosVxD::GetAcpiTable");

	PBYTE pb = NULL;

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
#else

	ACPITABINFO TabInfo;
	TabInfo.dwTabSig = dwTabSig;

	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("INVALID_HANDLE_VALUE == m_hVxD"));
		return NULL;
	}

	if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_ACPI_TABINFO, NULL, 0, &TabInfo, sizeof(TabInfo), NULL, NULL))
	{
		if (pb = (PBYTE) HeapAlloc(GetProcessHeap(), 0, TabInfo.dh.Length))
		{
			if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_ACPI_TABLE,
				(PVOID)TabInfo.dwPhyAddr, 0, pb,TabInfo.dh.Length, NULL, NULL))
			{
				SafeHeapFree(pb);
				LOG_Error(_T("Second DeviceIoControl:"));
				LOG_ErrorMsg(GetLastError());
				return NULL;
			}
		}
		else
		{
			LOG_ErrorMsg(E_OUTOFMEMORY);
		}
	}
	else
	{
		LOG_Error(_T("First DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}
#endif	// NUKE_VXD

	return pb;
}//GetAcpiTable

/***LP  CWubiosVxD::GetSmbTable - Get table
 *
 *  ENTRY
 *		dwTableType - table type
 *
 *  EXIT-SUCCESS
 *      returns pointer to table
 *  EXIT-FAILURE
 *      returns NULL
 */
PBYTE CWubiosVxD::GetSmbTable(DWORD dwTableType)
{
	LOG_Block("CWubiosVxD::GetSmbTable");

	PBYTE pb = NULL;

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
#else
	
	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("m_hVxD invalid"));
		return NULL;
	}

	DWORD dwMaxSize = 0;
	if (DeviceIoControl(m_hVxD, WUBIOCTL_GET_SMB_STRUCTSIZE, NULL, 0, &dwMaxSize, sizeof(dwMaxSize), NULL, NULL) && dwMaxSize)
	{
		if (pb = (PBYTE) HeapAlloc(GetProcessHeap(), 0, dwMaxSize))
		{
			if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_SMB_STRUCT,
				(PVOID)dwTableType, 0, pb, dwMaxSize, NULL, NULL))
			{
				SafeHeapFree(pb);
				LOG_Error(_T("Second DeviceIoControl:"));
				LOG_ErrorMsg(GetLastError());
				return NULL;
			}
		}
		else
		{
			LOG_Error(_T("HeapAlloc failed"));
		}
	}
	else
	{
		LOG_Error(_T("First DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}
#endif	// NUKE_VXD

	return pb;
}// GetSmbTable


/***LP  CWubiosVxD::GetPnpOemId - Do it
 *
 *  ENTRY
 *      none
 *
 *  EXIT
 *      path
 */
DWORD CWubiosVxD::GetPnpOemId()
{
	LOG_Block("CWubiosVxD::GetPnpOemId");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return 0;
#else

	// PnP last
	DWORD dwOemId = 0;
	if (INVALID_HANDLE_VALUE == m_hVxD)
	{
		LOG_Error(_T("m_hVxD invalid"));
		return 0;
	}

	if (0 == DeviceIoControl(m_hVxD, WUBIOCTL_GET_PNP_OEMID, NULL, 0, 
		&dwOemId, sizeof(dwOemId), NULL, NULL))
	{
		// make sure it didn't mess with the size on error
		dwOemId = 0;
		LOG_Error(_T("DeviceIoControl:"));
		LOG_ErrorMsg(GetLastError());
	}

	return dwOemId;
#endif	// NUKE_VXD
}

/*** UseVxD - Get bios info from it
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      POEMINFO pOemInfo
 *		All fields that aren't available will be filled with 0
 *      returns NULL
 */
void UseVxD(POEMINFO pOemInfo)
{

	HRESULT hr=S_OK;

	LOG_Block("CWubiosVxD::UseVxD");

#if NUKE_VXD == 1
	LOG_Error(_T("Not supported"));
	return;
#else

	USES_IU_CONVERSION;

	CWubiosVxD vxd;
	if(false == vxd.Init(g_hinst))
		return;

	// ISSUE-2000/10/10-waltw I don't have a machine to test vxd.GetAcpiTable on...
	// ACPI first
	PDESCRIPTION_HEADER pHeader = (PDESCRIPTION_HEADER)vxd.GetAcpiTable(DSDT_SIGNATURE);
	if (NULL != pHeader)
	{
		memcpy(pOemInfo->szAcpiOem, pHeader->OEMID, sizeof(pHeader->OEMID));
		memcpy(pOemInfo->szAcpiProduct, pHeader->OEMTableID, sizeof(pHeader->OEMTableID));
		HeapFree(GetProcessHeap(), 0, pHeader);
		pOemInfo->dwMask |= OEMINFO_ACPI_PRESENT;
		LOG_Driver(_T("Set OEMINFO_ACPI_PRESENT bit"));
	}
	
	// SMBIOS second
	PSMBIOSSYSINFO pTable = (PSMBIOSSYSINFO)vxd.GetSmbTable(SMBIOS_SYSTEM_INFO_TABLE);
	if (NULL != pTable)
	{
		// Search counter
		int cnStrs = max(pTable->bManufacturer, pTable->bProductName);
		char* sz = (char*)pTable + pTable->bLength;
		for (int i = 1; i <= cnStrs && sz; i ++)
		{
			if (pTable->bManufacturer == i)
			{
				
				hr=StringCchCopyEx(pOemInfo->szSmbOem,ARRAYSIZE(pOemInfo->szSmbOem),A2T(sz),NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{	
					LOG_ErrorMsg(HRESULT_CODE(hr));
					return;
				}

			}
			else if (pTable->bProductName == i)
			{
				
				hr=StringCchCopyEx(pOemInfo->szSmbProduct,ARRAYSIZE(pOemInfo->szSmbProduct),A2T(sz),NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{
					LOG_ErrorMsg(HRESULT_CODE(hr));
					return;
				}

			}
			sz += strlen(sz) + 1;
		}
		pOemInfo->dwMask |= OEMINFO_SMB_PRESENT;
		SafeHeapFree(pTable);
		LOG_Driver(_T("Set OEMINFO_SMB_PRESENT bit"));
	}

	// ISSUE-2000/10/10-waltw I don't have a machine to test vxd.GetPnpOemId on...
	// PnP last
	pOemInfo->dwPnpOemId = vxd.GetPnpOemId();
	if (pOemInfo->dwPnpOemId != 0)
	{
		pOemInfo->dwMask |= OEMINFO_PNP_PRESENT;
		LOG_Driver(_T("Set OEMINFO_PNP_PRESENT bit"));
	}		
#endif	// NUKE_VXD
}


/*** ReadFromReg - read OEMINFO from registry
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      true if info is present
 *		false otherwise
 */
bool ReadFromReg(POEMINFO pOemInfo)
{
	LOG_Block("ReadFromReg");

	DWORD dwVersion = 0;
	bool  fReturn = false;
	bool  fRegKeyOpened = false;
	LONG lReg;
	//read registry first
	HKEY hKeyOemInfo;
	HRESULT hr;
	int cchValueSize;

	if (NULL == pOemInfo)
	{
		return false;
	}

	if	(NO_ERROR == (lReg = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, KEY_READ, &hKeyOemInfo)))
	{
		fRegKeyOpened = true;
		DWORD dwCount = sizeof(pOemInfo->dwMask);
		if (ERROR_SUCCESS != RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_MASK, 0, 0, (LPBYTE)&(pOemInfo->dwMask), &dwCount))
		{
			goto CleanUp;
		}
		//
		// ***** WU Bug# 11921 *****
		//
		
		//
		//	No bits set requires detection
		//
		if(!pOemInfo->dwMask)
		{
			LOG_Error(_T("No pOemInfo->dwMask bits set in ReadFromReg"));
			goto CleanUp;
		}

		//
		//	If an older version of the detection wrote the OemInfo return false to force detection.
		//	This value is written starting with 1 around August 2000 for the Classic control.
		//
		dwCount = sizeof(dwVersion);
		if (NO_ERROR == (lReg = RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_OEMINFO_VER, 0, 0, (LPBYTE)&dwVersion, &dwCount)))
		{
			if(REG_CURRENT_OEM_VER > dwVersion)
			{
				LOG_Error(_T("REG_CURRENT_OEM_VER > %lu in Registry"), dwVersion);
				goto CleanUp;
			}
		}
		else
		{
			Win32MsgSetHrGotoCleanup(lReg);
		}

		//
		// ***** end WU Bug *****
		//

		if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szAcpiOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_ACPIOEM, pOemInfo->szAcpiOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szAcpiProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_ACPIPRODUCT, pOemInfo->szAcpiProduct, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szSmbOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SMBOEM, pOemInfo->szSmbOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szSmbProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SMBPRODUCT, pOemInfo->szSmbProduct, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			dwCount = sizeof(pOemInfo->dwPnpOemId);	
			if (NO_ERROR != (lReg = RegQueryValueEx(hKeyOemInfo, REGSTR_VAL_PNPOEMID, 0, 0, (LPBYTE)&(pOemInfo->dwPnpOemId), &dwCount)))
				goto CleanUp;
		}
		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szIniOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_INIOEM, pOemInfo->szIniOem, cchValueSize, &cchValueSize));
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			cchValueSize = ARRAYSIZE(pOemInfo->szWbemOem);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_WBEMOEM, pOemInfo->szWbemOem, cchValueSize, &cchValueSize));

			cchValueSize = ARRAYSIZE(pOemInfo->szWbemProduct);	
			CleanUpIfFailedAndSetHrMsg(SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_WBEMPRODUCT, pOemInfo->szWbemProduct, cchValueSize, &cchValueSize));
		}
		//
		// Always try to get the OEM Support URL, but don't bail if we don't have it.
		//
		cchValueSize = ARRAYSIZE(pOemInfo->szIniOemSupportUrl);	
		(void) SafeRegQueryStringValueCch(hKeyOemInfo, REGSTR_VAL_SUPPORTURL, pOemInfo->szIniOemSupportUrl, cchValueSize, &cchValueSize);
		//
		// We got everything we had a dwMask bit set for - drop through to CleanUp
		//
		fReturn = true;
	}
	else
	{
		LOG_ErrorMsg(lReg);
		goto CleanUp;
	}

CleanUp:

	if (true == fRegKeyOpened)
	{
		RegCloseKey(hKeyOemInfo);
	}

	return fReturn;
}

/*** SaveToReg - Save OEMINFO
 *
 *  ENTRY
 *      POEMINFO pOemInfo
 *
 *  EXIT
 *      none
 */
void SaveToReg(POEMINFO pOemInfo)
{
	LOG_Block("SaveToReg");

	DWORD dwDisp;
	DWORD dwVersion = REG_CURRENT_OEM_VER;
	LONG lReg;
	HKEY hKey;
	//
	// Nuke the existing key (it has no subkeys)
	//

	if (NO_ERROR != (lReg = RegDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO)))
	{
		//
		// Log error but don't bail - it may not have existed before
		//
		LOG_Driver(_T("Optional RegDeleteKey:"));
		LOG_ErrorMsg(lReg);
	}

	if	(NO_ERROR == (lReg = RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_KEY_OEMINFO, 0, NULL, 
		REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hKey, &dwDisp)))
	{
		//
		// Ignore errors from RegSetValueEx - we check for errors in ReadFromReg
		//
		RegSetValueEx(hKey, REGSTR_VAL_MASK, 0, REG_DWORD, (LPBYTE)&(pOemInfo->dwMask), sizeof(pOemInfo->dwMask));

		//
		//	Write the current version so future controls can check version of detection that wrote this key.
		//	WU RAID # 11921
		//
		RegSetValueEx(hKey, REGSTR_VAL_OEMINFO_VER, 0, REG_DWORD, (LPBYTE)&dwVersion, sizeof(dwVersion));

		if (pOemInfo->dwMask & OEMINFO_ACPI_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_ACPIOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szAcpiOem), (lstrlen(pOemInfo->szAcpiOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_ACPIPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szAcpiProduct), (lstrlen(pOemInfo->szAcpiProduct) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_SMB_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_SMBOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szSmbOem), (lstrlen(pOemInfo->szSmbOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_SMBPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szSmbProduct), (lstrlen(pOemInfo->szSmbProduct) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_PNP_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_PNPOEMID, 0, REG_DWORD, (LPBYTE)&(pOemInfo->dwPnpOemId), sizeof(pOemInfo->dwPnpOemId));
		}
		if (pOemInfo->dwMask & OEMINFO_INI_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_INIOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szIniOem), (lstrlen(pOemInfo->szIniOem) + 1) * sizeof(TCHAR));
		}
		if (pOemInfo->dwMask & OEMINFO_WBEM_PRESENT)
		{
			RegSetValueEx(hKey, REGSTR_VAL_WBEMOEM, 0, REG_SZ, (LPBYTE)&(pOemInfo->szWbemOem), (lstrlen(pOemInfo->szWbemOem) + 1) * sizeof(TCHAR));
			RegSetValueEx(hKey, REGSTR_VAL_WBEMPRODUCT, 0, REG_SZ, (LPBYTE)&(pOemInfo->szWbemProduct), (lstrlen(pOemInfo->szWbemProduct) + 1) * sizeof(TCHAR));
		}
		//
		// Always save REGSTR_VAL_SUPPORTURL if we have it
		//
		int nUrlLen = lstrlen(pOemInfo->szIniOemSupportUrl);
		if (0 < nUrlLen)
		{
			RegSetValueEx(hKey, REGSTR_VAL_SUPPORTURL, 0, REG_SZ, (LPBYTE)&(pOemInfo->szIniOemSupportUrl), (nUrlLen + 1) * sizeof(TCHAR));
		}

		RegCloseKey(hKey);
	}
	else
	{
		LOG_Error(_T("RegCreateKeyEx returned 0x%08x in SaveToReg"), lReg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\iuengine\wubios\inc\vxdwraps.h ===
/****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title: VXDWRAPS.H - Include file for using VXDWRAPS.LIB
 *
 *   Version:   1.00
 *
 *   Date:  18-September-1993
 *
 *   Author:    PYS
 *
 *--------------------------------------------------------------------------
 *
 *   Change log:
 *
 ***************************************************************************/

#ifndef _VXDWRAPS_H
#define _VXDWRAPS_H

#ifndef NOBASEDEFS

typedef (*PFN)();                       // pfn
typedef PFN *PPFN;                      // ppfn

#endif  // NOBASEDEFS

#ifdef  _VMM_

#define VMM_MAP_PHYS_TO_LINEAR_INVALID  0xFFFFFFFF

typedef VOID                (_cdecl *VMM_TIMEOUT_HANDLER)();
typedef VOID                (_cdecl *VMM_EVENT_HANDLER)();
typedef VOID                (_cdecl *VMM_HOOK_HANDLER)(VOID);
typedef ULONG               (_cdecl *VMMSWP)(ULONG frame, ULONG npages);
typedef VOID                (_cdecl *VMMCOMS)(DWORD dwParam);
typedef DWORD               (_cdecl *VMMCOMNFS)();

typedef struct Exception_Handler_Struc  *PVMMEXCEPTION;
//typedef   QWORD               DESCDWORDS;
typedef	DWORD			VMMEVENT;
typedef DWORD               VMMLIST;
typedef PVOID               VMMLISTNODE;
typedef DWORD               SIGNATURE;
typedef SIGNATURE           *PSIGNATURE;    // Pointer to a signature.
typedef struct _vmmmtx {int unused;}    *PVMMMUTEX;
typedef struct cb_s                     *PVMMCB;

#endif  // _VMM_

#define CAT_HELPER(x, y)    x##y
#define CAT(x, y)       CAT_HELPER(x, y)

#ifndef CURSEG
#define CURSEG()        LCODE
#endif

/****************************************************************************
 *
 * There are two types of VxD 'C' wrappers. The ones that are VXDINLINE and
 * the one that have little stubs.
 *
 ***************************************************************************/

/****************************************************************************
 *
 * The following are VxD wrappers done with VXDINLINE. They must return void
 * (to avoid a problem with C++), must take VOID (so that no parameter are
 * used as temporary stack) and all registers are preserved. The two
 * *_Debug_String also fall in that category since they need esp and ebp
 * not to be in a nested stack frame.
 *
 ***************************************************************************/

#ifdef  _VMM_

VOID VXDINLINE
Load_FS_Service(VOID)
{
    VMMCall(Load_FS_Service)
}

VOID VXDINLINE
End_Critical_Section(VOID)
{
    VMMCall(End_Critical_Section)
}

VOID VXDINLINE
Fatal_Memory_Handler(VOID)
{
    VMMJmp(Fatal_Memory_Error);
}

VOID VXDINLINE
Begin_Nest_Exec(VOID)
{
    VMMCall(Begin_Nest_Exec)
}

VOID VXDINLINE
End_Nest_Exec(VOID)
{
    VMMCall(End_Nest_Exec)
}

VOID VXDINLINE
Resume_Exec(VOID)
{
    VMMCall(Resume_Exec)
}

VOID VXDINLINE
Enable_Touch_1st_Meg(VOID)
{
    VMMCall(Enable_Touch_1st_Meg)
}

VOID VXDINLINE
Disable_Touch_1st_Meg(VOID)
{
    VMMCall(Disable_Touch_1st_Meg)
}

VOID VXDINLINE
Out_Debug_String(PCHAR psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

VOID VXDINLINE
Queue_Debug_String(PCHAR psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#endif  // _VMM_

#define MAKE_HEADER(RetType, DecType, Function, Parameters) \
extern  RetType DecType CAT(LCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(ICODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(PCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(SCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(DCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(CCODE_, CAT(Function, Parameters)); \
extern  RetType DecType CAT(KCODE_, CAT(Function, Parameters));

#define PREPEND(Name)       CURSEG()##_##Name

#ifdef  _VMM_

WORD VXDINLINE
Get_VMM_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(PVOID,_cdecl, _MapPhysToLinear, (ULONG PhysAddr, ULONG nBytes, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_HeapAllocate, (ULONG Bytes, ULONG Flags))
MAKE_HEADER(PVOID,_stdcall,_HeapAllocateEx, (ULONG cBytes, PVOID Res, PVOID Res1, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_HeapFree, (PVOID Address, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,_HeapFreeEx, (PVOID Address, ULONG Flags))
MAKE_HEADER(PVOID,_cdecl,_HeapReAllocate, (PVOID pOld, ULONG Bytes, ULONG Flags))
MAKE_HEADER(ULONG,_cdecl,_HeapGetSize, (PVOID p, ULONG Flags))
MAKE_HEADER(VOID,_stdcall,Fatal_Error_Handler, (PCHAR pszMessage, DWORD dwExitFlag))
MAKE_HEADER(VOID,_stdcall,Begin_Critical_Section, (ULONG Flags))
MAKE_HEADER(HEVENT,_stdcall,Schedule_Global_Event, (VMM_EVENT_HANDLER pfnEvent, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Global_Event, (HEVENT hEvent));
MAKE_HEADER(HVM,_cdecl,Get_Sys_VM_Handle, (VOID))
MAKE_HEADER(DWORD,_stdcall,Get_Profile_Hex_Int, (PCHAR pszSection, PCHAR pszKeyName, DWORD dwDefault))
MAKE_HEADER(BOOL,_stdcall,Get_Profile_Boolean, (PCHAR pszSection, PCHAR pszKeyName, BOOL fDefault))
MAKE_HEADER(VMM_SEMAPHORE,_stdcall,Create_Semaphore, (LONG lTokenCount))
MAKE_HEADER(VOID,_stdcall,Destroy_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Signal_Semaphore, (VMM_SEMAPHORE vsSemaphore))
MAKE_HEADER(VOID,_stdcall,Wait_Semaphore, (VMM_SEMAPHORE vsSemaphore, DWORD dwFlags))
MAKE_HEADER(HVM,_cdecl,Get_Execution_Focus, (VOID))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_VM_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(HTIMEOUT,_stdcall,Set_Global_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(VOID,_stdcall,Cancel_Time_Out, (HTIMEOUT htimeout))
MAKE_HEADER(VOID,_stdcall,Update_System_Clock, (ULONG msElapsed))
MAKE_HEADER(BOOL,_stdcall,Install_Exception_Handler, (PVMMEXCEPTION pveException))
MAKE_HEADER(PCHAR,_stdcall,Get_Exec_Path, (PULONG pulPathLength))
MAKE_HEADER(DWORD,_cdecl,Get_Last_Updated_System_Time, (VOID))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Allocate, (VMMLIST List))
MAKE_HEADER(VOID,_stdcall,List_Attach, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Attach_Tail, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLIST,_stdcall,List_Create, (ULONG Flags, ULONG NodeSize))
MAKE_HEADER(VOID,_stdcall,List_Deallocate, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Destroy, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_First, (VMMLIST List))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Get_Next, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VOID,_stdcall,List_Insert, (VMMLIST List, VMMLISTNODE NewNode, VMMLISTNODE Node))
MAKE_HEADER(BOOL,_stdcall,List_Remove, (VMMLIST List, VMMLISTNODE Node))
MAKE_HEADER(VMMLISTNODE,_stdcall,List_Remove_First, (VMMLIST List))
MAKE_HEADER(PVOID,_cdecl,_PageAllocate, (DWORD nPages, DWORD pType, HVM hvm, DWORD AlignMask, DWORD minPhys, DWORD maxPhys, PVOID *PhysAddr, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_PageFree, (PVOID hMem, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_AddFreePhysPage, (ULONG PhysPgNum, ULONG nPages, ULONG flags, VMMSWP pfnSwapOutNotify))
MAKE_HEADER(HVM,_cdecl,Get_Cur_VM_Handle, (VOID))
MAKE_HEADER(BOOL,_cdecl,_LinPageLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_LinPageUnLock, (DWORD HLinPgNum, DWORD nPages, DWORD flags))
MAKE_HEADER(DWORD,_cdecl,_Allocate_Device_CB_Area, (DWORD nBytes, DWORD flags))
MAKE_HEADER(HVM,_stdcall,Get_Next_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Test_Cur_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Test_Sys_VM_Handle, (HVM hvm))
MAKE_HEADER(BOOL,_stdcall,Hook_V86_Int_Chain, (VMM_HOOK_HANDLER pfHook, DWORD dwInterrupt))
MAKE_HEADER(BOOL,_stdcall,Unhook_V86_Int_Chain, (VMM_HOOK_HANDLER pfHook, DWORD dwInterrupt))
MAKE_HEADER(PCHAR,_cdecl,Get_Config_Directory,(VOID))
MAKE_HEADER(DWORD,_cdecl,_Allocate_Temp_V86_Data_Area,(DWORD nBytes, DWORD Flags))
MAKE_HEADER(BOOL,_cdecl,_Free_Temp_V86_Data_Area,(VOID))
MAKE_HEADER(PVOID,_cdecl,_GetNulPageHandle,(VOID))
MAKE_HEADER(VOID,_stdcall,Get_Machine_Info,(PULONG prEAX, PULONG prEBX, PULONG prECX, PULONG prEDX))
MAKE_HEADER(ULONG,_cdecl,_PageModifyPermissions,(ULONG page, ULONG npages, ULONG permand, ULONG permor))
//MAKE_HEADER(WORD,_cdecl,_Allocate_GDT_Selector, (DESCDWORDS DescDWORDS, ULONG flags))
//MAKE_HEADER(DESCDWORDS,_cdecl,_BuildDescriptorDWORDs, (DWORD DESCBase, DWORD DESCLimit, DWORD DESCType, DWORD DESCSize, ULONG flags))
//MAKE_HEADER(BOOL,_cdecl,_Free_GDT_Selector, (WORD Selector, ULONG flags))
MAKE_HEADER(DWORD,_cdecl,_CallRing3, (DWORD ulCS, DWORD ulEIP, DWORD cbArgs, PDWORD lpvArgs))

#ifdef  WIN40SERVICES

MAKE_HEADER(ULONG,_cdecl,VMM_GetSystemInitState, (VOID))
MAKE_HEADER(VOID,_stdcall,_Trace_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Out_Service, (PCHAR psz))
MAKE_HEADER(VOID,_stdcall,_Debug_Flags_Service, (ULONG flags))
MAKE_HEADER(VOID,_cdecl,_Debug_Printf_Service, (PCHAR pszfmt, ...))
MAKE_HEADER(HTIMEOUT,_stdcall, Set_Async_Time_Out, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData))
MAKE_HEADER(PVMMDDB,_stdcall,Get_DDB, (WORD DeviceID, PCHAR Name))
MAKE_HEADER(DWORD,_stdcall,Directed_Sys_Control, (PVMMDDB pDDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI))
MAKE_HEADER(BOOL,_cdecl,_Assert_Range, (PVOID p, ULONG ulSize, SIGNATURE sSignature, LONG lSignatureOffset, ULONG ulFlags))
MAKE_HEADER(ULONG,_cdecl,_Sprintf, (PCHAR pszBuf, PCHAR pszFmt, ...))
MAKE_HEADER(PVMMMUTEX,_cdecl,_CreateMutex, (LONG Boost, ULONG Flags))
MAKE_HEADER(BOOL,_cdecl,_DestroyMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_EnterMutex, (PVMMMUTEX hmtx, ULONG Flags))
MAKE_HEADER(PTCB,_cdecl,_GetMutexOwner, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_LeaveMutex, (PVMMMUTEX hmtx))
MAKE_HEADER(VOID,_cdecl,_SignalID, (DWORD id))
MAKE_HEADER(VOID,_cdecl,_BlockOnID, (DWORD id, ULONG Flags))
MAKE_HEADER(PCHAR,_cdecl,_lstrcpyn,(PCHAR pszDest,const char *pszSrc,DWORD cb))
MAKE_HEADER(ULONG,_cdecl,_lstrlen,(const char *psz))
MAKE_HEADER(ULONG,_cdecl,_lmemcpy,(PVOID pDst, const void *pSrc, DWORD cb))
MAKE_HEADER(DWORD,_cdecl,Get_Boot_Flags, (VOID))
MAKE_HEADER(PTCB,_cdecl,Get_Cur_Thread_Handle, (VOID))
MAKE_HEADER(PVOID,_cdecl,_GetVxDName, (PVOID pLinAddr, PCHAR pBuffer))
MAKE_HEADER(VOID,_cdecl,_Call_On_My_Stack, (VMMCOMS Callback, DWORD LParam, PVOID StackPtr, DWORD StackSize))
MAKE_HEADER(PVOID,_cdecl,_PageReserve,(ULONG page, ULONG npages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageCommit,(ULONG page, ULONG npages, ULONG hpd, ULONG pagerdata, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageDecommit,(ULONG page, ULONG npages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PageCommitPhys,(ULONG page, ULONG npages, ULONG physpg, ULONG flags))
MAKE_HEADER(DWORD,_cdecl,Open_Boot_Log,(VOID))          // Warning 0 means success
MAKE_HEADER(VOID,_cdecl,Close_Boot_Log,(VOID))
MAKE_HEADER(VOID,_stdcall,Write_Boot_Log,(DWORD dwLength, PCHAR pString))
MAKE_HEADER(BOOL,_cdecl,_CopyPageTable,(ULONG PageNumber, ULONG nPages, PULONG ppte, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_PhysIntoV86,(ULONG PhysPage, HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_LinMapIntoV86,(ULONG HLinPgNum, HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG flags))
MAKE_HEADER(ULONG,_cdecl,_ModifyPageBits,(HVM VM, ULONG VMLinPgNum, ULONG nPages, ULONG AndMask, ULONG OrMask, ULONG pType, ULONG flags))
MAKE_HEADER(PVOID,_cdecl,_PageReAllocate,(PVOID pMem, ULONG nPages, ULONG flags))
MAKE_HEADER(BOOL,_stdcall,VMM_Add_DDB, (PVMMDDB pDDB))
MAKE_HEADER(BOOL,_stdcall,VMM_Remove_DDB, (PVMMDDB pDDB))
MAKE_HEADER(ULONG,_cdecl,_AtEventTime,(VOID))
MAKE_HEADER(VMMEVENT,_stdcall,Call_Restricted_Event,(ULONG ulBoost, HVM hvm, ULONG ulFlags, ULONG ulRefData, VMM_EVENT_HANDLER Handler, CMS cms))
MAKE_HEADER(VOID,_stdcall,Cancel_Restricted_Event,(VMMEVENT Event))
MAKE_HEADER(DWORD,_cdecl,_AllocateThreadDataSlot, (VOID))
MAKE_HEADER(VOID,_cdecl,_FreeThreadDataSlot, (DWORD))
MAKE_HEADER(PTCB,_stdcall,Get_Next_Thread_Handle, (PTCB))

//
// 4.1 Service
//
MAKE_HEADER(DWORD,_cdecl,_Call_On_My_Not_Flat_Stack, (DWORD dwCallback, DWORD dwNewCS, DWORD dwNewESP, DWORD dwNewSS, DWORD dwNewDS, DWORD dwNewES, DWORD dwStackSizeInWords, PVOID pFlatStackOffset, DWORD dwReturnOfFail, DWORD dwFlags))
MAKE_HEADER(BOOL,_cdecl,_LinRegionLock, (DWORD dwBeginLock, DWORD dwEndLock, DWORD flags))
MAKE_HEADER(BOOL,_cdecl,_LinRegionUnLock, (DWORD dwBeginLock, DWORD dwEndLock, DWORD flags))
MAKE_HEADER(ASD_RESULT,_cdecl,_AttemptingSomethingDangerous,(DWORD dwFunction, VMMREFIID vrOperation, PVOID pRefData, DWORD dwSizeRefData, DWORD dwFlags))
MAKE_HEADER(ULONG,_cdecl,_Vsprintf,(PCHAR pchBuffer, PCHAR pszFormat, PVOID paParameters))
MAKE_HEADER(BOOL, _cdecl, _RegisterGARTHandler,(PVOID pGARTHandler))
MAKE_HEADER(PVOID, _cdecl, _GARTReserve,(PVOID pDevObj, ULONG ulNumPages, ULONG ulAlignMask, PULONG pulGARTDev, ULONG ulFlags))
MAKE_HEADER(BOOL, _cdecl, _GARTCommit,(PVOID pGARTLin, ULONG ulPageOffset, ULONG ulNumPages, PULONG pulGARTDev, ULONG ulFlags))
MAKE_HEADER(VOID, _cdecl, _GARTUnCommit,(PVOID pGARTLin, ULONG ulPageOffset, ULONG ulNumPages))
MAKE_HEADER(VOID, _cdecl, _GARTFree,(PVOID pGARTLin))
MAKE_HEADER(VOID, _cdecl, _GARTMemAttributes,(PVOID pGARTLin, PULONG pulFlags))
MAKE_HEADER(DWORD,_cdecl,_FlushCaches,(DWORD dwService))
MAKE_HEADER(HTIMEOUT,_cdecl,_Set_Global_Time_Out_Ex, (VMM_TIMEOUT_HANDLER pfnTimeout, CMS cms, ULONG ulRefData, ULONG ulScheduleFlags))

#endif  // WIN40SERVICES

#endif  // _VMM_

#ifdef	_PCI_H

WORD VXDINLINE
PCI_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_PCI_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_cdecl,_PCI_Read_Config,(BYTE bBus, BYTE bDevFunc, BYTE bOffset))
MAKE_HEADER(VOID,_cdecl,_PCI_Write_Config,(BYTE bBus, BYTE bDevFunc, BYTE bOffset, DWORD dwValue))
MAKE_HEADER(BOOL,_cdecl,_PCI_Lock_Unlock,(DWORD dnDevNode, ULONG ulFlags))

#endif	// _PCI_H

#ifdef	_MTRR_H_

WORD VXDINLINE
MTRRGetVersion(VOID)
{
    WORD w;
    Touch_Register(eax)
    VxDCall(_MTRR_Get_Version);
    _asm mov [w], ax;
    return (w);
}

MAKE_HEADER(ULONG,_stdcall,MTRRSetPhysicalCacheTypeRange,(PVOID PhysicalAddress, ULONG NumberOfBytes, MEMORY_CACHING_TYPE CacheType))

#endif	// _MTRR_H_

#ifdef	_NTKERN_H

WORD VXDINLINE
NTKERN_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_NTKERN_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(NTSTATUS,_stdcall,_NtKernCreateFile,(PHANDLE FileHandle,ACCESS_MASK DesiredAccess,\
	POBJECT_ATTRIBUTES ObjectAttributes,PIO_STATUS_BLOCK IoStatusBlock,PLARGE_INTEGER AllocationSize, \
	ULONG FileAttributes,ULONG ShareAccess,ULONG CreateDisposition,ULONG CreateOptions,PVOID EaBuffer,ULONG EaLength))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernClose,(HANDLE FileHandle))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernDeviceIoControl,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,\
	PVOID ApcContext,PIO_STATUS_BLOCK IoStatusBlock,ULONG IoControlCode,PVOID InputBuffer,ULONG InputBufferLength,\
	PVOID OutputBuffer,ULONG OutputBufferLength))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernReadFile,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,PVOID ApcContext,\
	PIO_STATUS_BLOCK IoStatusBlock,PVOID Buffer,ULONG Length,PLARGE_INTEGER ByteOffset,PULONG Key))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernWriteFile,(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,PVOID ApcContext,\
	PIO_STATUS_BLOCK IoStatusBlock,PVOID Buffer,ULONG Length,PLARGE_INTEGER ByteOffset,PULONG Key))
MAKE_HEADER(ULONG,_cdecl,_NtKernGetWorkerThread,(ULONG ThreadType))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernLoadDriver,(PUNICODE_STRING DriverServiceName))
MAKE_HEADER(VOID,_stdcall,_NtKernQueueWorkItem,(PWORK_QUEUE_ITEM workitem,WORK_QUEUE_TYPE worktype))
MAKE_HEADER(DWORD,_cdecl,_NtKernPhysicalDeviceObjectToDevNode,(PDEVICE_OBJECT PhysicalDeviceObject))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernSetPhysicalCacheTypeRange,(ULONG BaseAddressHigh, ULONG BaseAddressLow, ULONG NumberOfBytex, ULONG CacheType))
MAKE_HEADER(PDRIVER_OBJECT,_cdecl,_NtKernWin9XLoadDriver,(PCHAR FileName,PCHAR RegisteryPath))
MAKE_HEADER(NTSTATUS,_stdcall,_NtKernCancelIoFile,(HANDLE FileHandle,PIO_STATUS_BLOCK IoStatusBlock))



#endif	// _NTKERN_H

#ifdef  _SHELL_H

typedef DWORD       SHELL_HINSTANCE;
typedef PVOID       SHELL_FARPROC;

WORD VXDINLINE
SHELL_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(SHELL_Get_Version);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(DWORD,_stdcall,SHELL_SYSMODAL_Message, (HVM hvm, DWORD dwMBFlags, PCHAR pszMessage, PCHAR pszCaption))

#ifndef WIN31COMPAT

MAKE_HEADER(APPY_HANDLE,_cdecl,_SHELL_CallAtAppyTime, (APPY_CALLBACK pfnAppyCallBack, DWORD dwRefData, DWORD flAppy, ...))
MAKE_HEADER(BOOL,_cdecl,_SHELL_CancelAppyTimeEvent, (APPY_HANDLE appy_handle))
MAKE_HEADER(BOOL,_cdecl,_SHELL_QueryAppyTimeAvailable, (VOID))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalAllocEx, (DWORD fl, DWORD cb, PVOID lpvBuf))
MAKE_HEADER(DWORD,_cdecl,_SHELL_LocalFree, (DWORD hdata))
MAKE_HEADER(DWORD,_cdecl,_SHELL_CallDll, (PCHAR lpszDll, PCHAR lpszProcName, DWORD cbArgs, PVOID lpvArgs))
MAKE_HEADER(DWORD,_cdecl,_SHELL_BroadcastSystemMessage, (DWORD dwFlags, PDWORD lpdwRecipients, DWORD uMsg, DWORD wparam, DWORD lparam))
MAKE_HEADER(SYSBHOOK_HANDLE,_cdecl,_SHELL_HookSystemBroadcast, (SYSBHOOK_CALLBACK pfnSysBHookCallBack, DWORD dwRefData, DWORD dwCallOrder))
MAKE_HEADER(VOID,_cdecl,_SHELL_UnhookSystemBroadcast, (SYSBHOOK_HANDLE SysBHookHandle))
MAKE_HEADER(SHELL_HINSTANCE,_cdecl,_SHELL_LoadLibrary, (PCHAR pszDll))
MAKE_HEADER(VOID,_cdecl,_SHELL_FreeLibrary, (SHELL_HINSTANCE hinstance))
MAKE_HEADER(SHELL_FARPROC,_cdecl,_SHELL_GetProcAddress, (SHELL_HINSTANCE hinstance, PCHAR pszProcName))

#ifdef WIN41SERVICES
MAKE_HEADER(PSHELL_SUUAE_INFO,_cdecl,_SHELL_Update_User_Activity_Ex, (ULONG ulFlags))
#endif

#endif  // WIN31COMPAT

#endif  // _SHELL_H

#ifdef  _PCCARD_H

MAKE_HEADER(DWORD,_cdecl,_PCCARD_Access_CIS_Memory, (DWORD dnDevNode, PUCHAR pBuffer, DWORD dwOffset, DWORD dwLength, DWORD fFlags))

#endif

#ifdef  _VTD_H
#ifndef WIN31COMPAT

MAKE_HEADER(DWORD,_stdcall,VTD_GetTimeZoneBias, (VOID))
MAKE_HEADER(ULONGLONG,_cdecl,VTD_Get_Real_Time, (VOID))
MAKE_HEADER(VOID,_cdecl,_VTD_Delay_Ex,(ULONG us, ULONG ulFlags))

#endif  // WIN31COMPAT
#endif  // _VTD_H

#ifdef  _VMMREG_H

#ifndef WIN31COMPAT

MAKE_HEADER(VMMREGRET,cdecl,_RegOpenKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegCloseKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateKey, (VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteKey, (VMMHKEY hkey, PCHAR lpszSubKey))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumKey, (VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValue, (VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValue, (VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegDeleteValue, (VMMHKEY hkey, PCHAR lpszValue))
MAKE_HEADER(VMMREGRET,cdecl,_RegEnumValue, (VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryValueEx, (VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PVOID lpbData, PDWORD lpcbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegSetValueEx, (VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PVOID lpbData, DWORD cbData))
MAKE_HEADER(VMMREGRET,cdecl,_RegFlushKey, (VMMHKEY hkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryInfoKey, (VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, \
			PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime))
MAKE_HEADER(VMMREGRET,cdecl,_RegRemapPreDefKey, (VMMHKEY hkey,VMMHKEY hkRootKey))
MAKE_HEADER(ULONG,cdecl,_GetRegistryPath, (PVMMDDB ThisDDB, PVOID pUserBuff, ULONG ulUserBuffSize))
MAKE_HEADER(VMMREGRET,cdecl,_GetRegistryKey, (DWORD dwType, PCHAR lpszDevName, DWORD dwFlags, PVMMHKEY lpHkey))
MAKE_HEADER(VMMREGRET,cdecl,_RegCreateDynKey, (PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult))
MAKE_HEADER(VMMREGRET,cdecl,_RegQueryMultipleValues, (VMMHKEY hKey,PVOID val_list,DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize))

#endif  // WIN31COMPAT

#endif  // _VWWREG_H

#ifdef  _VPICD_H

MAKE_HEADER(HIRQ,_stdcall,VPICD_Virtualize_IRQ, (PVID pvid))
MAKE_HEADER(VOID,_stdcall,VPICD_Phys_EOI, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Physically_Mask, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Physically_Unmask, (HIRQ hirq))
MAKE_HEADER(VOID,_stdcall,VPICD_Force_Default_Behavior, (HIRQ hirq))
MAKE_HEADER(VOID,_cdecl,_VPICD_Clear_IR_Bits, (DWORD dwIRQMask))
MAKE_HEADER(WORD,_cdecl,_VPICD_Get_Level_Mask, (VOID))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Level_Mask, (WORD wIRQMask))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Irql_Mask, (DWORD dwNewLevel))
MAKE_HEADER(VOID,_cdecl,_VPICD_Set_Channel_Irql, (DWORD dwChannel, DWORD dwNewLevel))
MAKE_HEADER(ULONG,_cdecl,_VPICD_Register_Trigger_Handler, (VPICDTRIGGERHANDLER vthHandler, ULONG ulMBZ))

#endif  // _VPICD_H

#ifdef  _VXDLDR_H

typedef struct DeviceInfo   *PDEVICEINFO;
typedef PDEVICEINFO     *PPDEVICEINFO;

WORD VXDINLINE
VXDLDR_GetVersion(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(VXDLDR_GetVersion);
    _asm mov [w], ax
    return(w);
}

MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_LoadDevice, (PPVMMDDB ppDDB, PPDEVICEINFO ppDeviceHandle, PCHAR Filename, BOOL InitDevice))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadDevice, (USHORT DevID, PCHAR szName))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitSucceeded, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_DevInitFailed, (PDEVICEINFO DeviceHandle))
MAKE_HEADER(PDEVICEINFO,_cdecl,VXDLDR_GetDeviceList, (VOID))
MAKE_HEADER(VXDLDRRET,_stdcall,VXDLDR_UnloadMe, (USHORT DevID, PCHAR szName))
MAKE_HEADER(LRESULT,_cdecl,_PELDR_LoadModule, (PHPEMODULE phl, PSTR pFileName, PHLIST phetl));
MAKE_HEADER(HPEMODULE,_cdecl,_PELDR_GetModuleHandle, (PSTR pFileName));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_GetModuleUsage, (HPEMODULE hl));
MAKE_HEADER(PFN,_cdecl,_PELDR_GetEntryPoint, (HPEMODULE hl));
MAKE_HEADER(PFN,_cdecl,_PELDR_GetProcAddress, (HPEMODULE hl, PVOID pFuncName, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_LoadModuleEx, (PHPEMODULE phl, PSTR pFileName, PHLIST phetl, DWORD dwFlags));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_InitCompleted, (HPEMODULE hl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_AddExportTable, (PHPEEXPORTTABLE pht, PSTR pszModuleName, \
	ULONG cExportedFunctions, ULONG cExportedNames, ULONG ulOrdinalBase, PVOID *pExportNameList, \
	PUSHORT pExportOrdinals, PFN *ppExportAddrs, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_RemoveExportTable, (HPEEXPORTTABLE ht, PHLIST phetl));
MAKE_HEADER(LRESULT,_cdecl,_PELDR_FreeModule, (HPEMODULE hl, PHLIST phetl));
#endif  // _VXDLDR_H

#ifdef _VCOMM_H

WORD VXDINLINE
VCOMM_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(VCOMM_Get_Version);
    _asm mov [w], ax
    return(w);
}

// VCOMM headers
#ifndef HPORT
    #define HPORT   DWORD
#endif

MAKE_HEADER(BOOL, _cdecl, _VCOMM_Register_Port_Driver, (PFN InitFn))
MAKE_HEADER(ULONG, _cdecl, _VCOMM_Acquire_Port, (HANDLE PHandle, ULONG PortNum, ULONG OwnerVM, ULONG flags, char *PortName))
MAKE_HEADER(void, _cdecl, _VCOMM_Release_Port,(ULONG PortHandle, ULONG OwnerVM))
MAKE_HEADER(HPORT, _cdecl, _VCOMM_OpenComm, (char *PortName, ULONG VMId))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommState, (HPORT hPort, _DCB *pDcb, DWORD ActionMask))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommState, (HPORT hPort, _DCB *pDcb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetupComm, (HPORT hPort,BYTE *RxBase, ULONG RxLength, BYTE *TxBase, ULONG TxLength, _QSB *pqsb))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_TransmitCommChar, (HPORT hPort, char ch))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_CloseComm, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommQueueStatus, (HPORT hPort, _COMSTAT *pComStat))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ClearCommError, (HPORT hPort, _COMSTAT *pComstat, ULONG *perror))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetModemStatus, (HPORT hPort, ULONG *pModemStatus))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommProperties, (HPORT hPort, _COMMPROP *pCommprop))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EscapeCommFunction, (HPORT hPort, long lFunc, long IData, long OData))
// MAKE_HEADER(BOOL, _cdecl, _VCOMM_DeviceIOControl, (HPORT hPort, long IOCTL, long IData, long cbIData, long OData, long cbOData, long *cbBytesReturned))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_PurgeComm, (HPORT hPort, long QueueType))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetCommEventMask, (HPORT hPort, long EvtMask, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetCommEventMask, (HPORT hPort, long EvtMaskToClear, long *dwEvents))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_WriteComm, (HPORT hPort, char *lpBuf, ULONG ToWrite,ULONG *Written))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_ReadComm, (HPORT hPort, char *lpBuf, long ToRead, long *Read))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_EnableCommNotification, (HPORT hPort, PVOID Fn, long ReferenceData))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_GetLastError, (HPORT hPort))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Steal_Port, (ULONG PortHandle, ULONG VMHandle))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetReadCallBack, (HPORT hPort, ULONG RecvTrigger, PVOID FnReadEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_SetWriteCallBack, (HPORT hPort,ULONG SendTrigger, PVOID FnWriteEvent, ULONG RefData))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Add_Port, (DWORD refData, PFN PortEntry, char *PortName))

#ifndef WIN31COMPAT
MAKE_HEADER(BOOL, _cdecl, _VCOMM_GetSetCommTimeouts, (HPORT hPort, LPCOMMTIMEOUTS lpct, DWORD dwAction))
MAKE_HEADER(IORequest * , _cdecl, _VCOMM_SetWriteRequest, (HPORT hPort, IORequest *ioreq, ULONG *lpNumWritten))
MAKE_HEADER(IORequest *, _cdecl, _VCOMM_SetReadRequest, (HPORT hPort,IORequest *ioreq, ULONG *lpNumRead))
MAKE_HEADER(BOOL, _cdecl, _VCOMM_Dequeue_Request,(DWORD listElement, PDWORD  lpcbTransfer))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Enumerate_DevNodes, (void))
MAKE_HEADER(PFN, _cdecl, _VCOMM_Get_Contention_Handler, (char *PortName))
MAKE_HEADER(DWORD, _cdecl, _VCOMM_Map_Name_To_Resource, (char *PortName))
#endif

#endif          // _VCOMM_H

#ifdef      _IRS_H
MAKE_HEADER(void, _cdecl, IOS_Requestor_Service, (ULONG p))
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

WORD VXDINLINE
VPOWERD_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(_VPOWERD_Get_Version);
    _asm mov [w], ax
	return(w);
}

MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_APM_BIOS_Version, (VOID))
MAKE_HEADER(DWORD, _cdecl, _VPOWERD_Get_Power_Management_Level, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Power_Management_Level, (DWORD Power_Management_Level))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_Device_Power_State, (POWER_DEVICE_ID Power_Device_ID, POWER_STATE Power_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Restore_Power_On_Defaults, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_Status, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATUS pPower_Status))
#ifndef _NTDDK_
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Get_Power_State, (POWER_DEVICE_ID Power_Device_ID, LPPOWER_STATE pPower_State))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (POWER_STATE Power_State, DWORD Request_Type))
#else
MAKE_HEADER(VOID, _cdecl, _VPOWERD_Transfer_Control, (PVTC_INFO pvtc))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Set_System_Power_State, (VXD_POWER_STATE Power_State, DWORD Request_Type))
#endif
MAKE_HEADER(VOID, _cdecl, _VPOWERD_OEM_APM_Function, (VOID))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Register_Power_Handler, (POWER_HANDLER Power_Handler, DWORD Priority))
MAKE_HEADER(POWERRET, _cdecl, _VPOWERD_Deregister_Power_Handler, (POWER_HANDLER Power_Handler));

#endif      // _INC_VPOWERD

#ifdef  _ACPIVXD_H
#ifndef	_ACPIVXD_SERVICES_PROVIDER

WORD VXDINLINE
ACPI_Get_Version(VOID)
{
    WORD    w;
    Touch_Register(eax)
    VxDCall(ACPI_GetVersion);
    _asm mov [w], ax
	return(w);
}

MAKE_HEADER(BOOL, _cdecl, _ACPI_SetTimingMode, (DEVNODE IDEChannelDevnode, PTIMINGMODE TimingMode, ULONG Drive0IDEBlockLength, PVOID Drive0IDEBlock, ULONG Drive1IDEBlockLength, PVOID Drive1IDEBlock))
#ifdef _NTDDK_
MAKE_HEADER(BOOL, _cdecl, _ACPI_SetSystemPowerState, (SYSTEM_POWER_STATE PowerState))
#endif
MAKE_HEADER(BOOL, _cdecl, _ACPI_RegisterOpRegionCookedHandler, (OPREGIONHANDLER pCallBack, ULONG Type, ULONG Context))
#ifdef _NTDDK_
MAKE_HEADER(BOOL, _cdecl, _ACPI_Set_RTC, (PTIME_FIELDS TimeFields))
#endif
MAKE_HEADER(BOOL, _cdecl, _ACPI_GetTimingMode, (DEVNODE Channel, PTIMINGMODE TimingMode))
MAKE_HEADER(BOOL, _cdecl, _ACPI_GetTaskFile, (DEVNODE Drive, PVOID ATACommandBuffer, PULONG ReturnedBufferSize))
#ifdef	_AMLI_H
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_WalkNameSpace, (PNSOBJ pnsObj, ULONG ulDirection))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_GetObject, (PNSOBJ pnsObj, ULONG ulPackedID))
MAKE_HEADER(DEVNODE, _cdecl, _ACPI_NameSpaceToDevNode, (PNSOBJ pnsObj))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_DevNodeToNameSpace, (DEVNODE dnDevNode))
MAKE_HEADER(BOOL, _cdecl, _ACPI_RunControlMethod, (PNSOBJ pnsObj, ULONG ulParamCount, POBJDATA pParams, DWORD dwExpectedType, PDWORD pdwBufferSize, PVOID pBuffer))
#endif
#ifdef	_AMLI_H
MAKE_HEADER(BOOL, _cdecl, _ACPI_EvalPackageElement, (PNSOBJ pns, int iPktIndex, POBJDATA pResult))
MAKE_HEADER(BOOL, _cdecl, _ACPI_EvalPkgDataElement, (POBJDATA pdataPkg, int iPkgIndex, POBJDATA pdataResult))
MAKE_HEADER(VOID, _cdecl, _ACPI_FreeDataBuffs, (POBJDATA pdata, int icData))
MAKE_HEADER(PNSOBJ, _cdecl, _ACPI_GetNameSpaceObject, (PSZ pszObjPath, PNSOBJ pnsScope, PPNSOBJ ppns, ULONG dwfFlags))
#endif

#endif	// _ACPIVXD_SERVICES_PROVIDER
#endif  // _ACPIVXD_H

#ifdef _VDMAD_H_
MAKE_HEADER(ULONG, _stdcall, VDMAD_Get_Phys_Count, (HDMA hdma, HVM hvm))
MAKE_HEADER(VOID, _stdcall, VDMAD_Phys_Mask_Channel, (HDMA hdma))
MAKE_HEADER(VOID, _stdcall, VDMAD_Phys_Unmask_Channel, (HDMA hdma, HVM hvm))
MAKE_HEADER(VOID, _stdcall, VDMAD_Set_Phys_State( HDMA hdma, HVM hVM, ULONG ulMode, ULONG ulExtMode ))
MAKE_HEADER(VOID, _stdcall, VDMAD_Set_Region_Info, (HDMA hdma, ULONG ulBufferId, BOOLEAN fLocked, ULONG ulLinear, ULONG cbSize, ULONG ulPhysical))
MAKE_HEADER(VOID, _stdcall, VDMAD_Unvirtualize_Channel, (HDMA hdma))
MAKE_HEADER(HDMA, _stdcall, VDMAD_Virtualize_Channel, (ULONG ulChannel, PVOID pHandler))
#endif // _VDMAD_H_

#ifdef _VWIN32_H_
#ifdef NOBASEDEFS
MAKE_HEADER(ULONG, _cdecl, VWIN32_AllocExternalHandle, (PR0OBJTYPETABLE, PVOID, PHANDLE, ULONG))
MAKE_HEADER(VOID, _cdecl, VWIN32_UseExternalHandle, (HANDLE))
MAKE_HEADER(VOID, _cdecl, VWIN32_UnuseExternalHandle, (HANDLE))
MAKE_HEADER(DWORD, _stdcall, VWIN32_ConvertNtTimeout, (PLARGE_INTEGER))
MAKE_HEADER(VOID, _cdecl, VWIN32_SetWin32EventBoostPriority, (PVOID, PULONG))
MAKE_HEADER(ULONG, _cdecl, VWIN32_GetCurThreadCondition, (ULONG))

#define VWIN32_AllocExternalHandle  PREPEND(VWIN32_AllocExternalHandle)
#define VWIN32_UseExternalHandle    PREPEND(VWIN32_UseExternalHandle)
#define VWIN32_UnuseExternalHandle  PREPEND(VWIN32_UnuseExternalHandle)
#define VWIN32_ConvertNtTimeout  PREPEND(VWIN32_ConvertNtTimeout)
#define VWIN32_SetWin32EventBoostPriority PREPEND(VWIN32_SetWin32EventBoostPriority)
#define VWIN32_GetCurThreadCondition	PREPEND(VWIN32_GetCurThreadCondition)

#endif // NOBASEDEFS
#endif  // _VWIN32_H_

#define _MapPhysToLinear        PREPEND(_MapPhysToLinear)
#define _HeapAllocate           PREPEND(_HeapAllocate)
#define _HeapFree           PREPEND(_HeapFree)
#define _HeapReAllocate         PREPEND(_HeapReAllocate)
#define _HeapGetSize            PREPEND(_HeapGetSize)
#define _Trace_Out_Service      PREPEND(_Trace_Out_Service)
#define _Debug_Out_Service      PREPEND(_Debug_Out_Service)
#define _Debug_Flags_Service        PREPEND(_Debug_Flags_Service)
#define _Debug_Printf_Service       PREPEND(_Debug_Printf_Service)
#define Fatal_Error_Handler     PREPEND(Fatal_Error_Handler)
#define Begin_Critical_Section      PREPEND(Begin_Critical_Section)
#define Schedule_Global_Event       PREPEND(Schedule_Global_Event)
#define Cancel_Global_Event     PREPEND(Cancel_Global_Event)
#define Get_Sys_VM_Handle       PREPEND(Get_Sys_VM_Handle)
#define Get_Profile_Hex_Int     PREPEND(Get_Profile_Hex_Int)
#define Get_Profile_Boolean     PREPEND(Get_Profile_Boolean)
#define Create_Semaphore        PREPEND(Create_Semaphore)
#define Destroy_Semaphore       PREPEND(Destroy_Semaphore)
#define Signal_Semaphore        PREPEND(Signal_Semaphore)
#define Wait_Semaphore          PREPEND(Wait_Semaphore)
#define Get_Execution_Focus     PREPEND(Get_Execution_Focus)
#define Set_VM_Time_Out         PREPEND(Set_VM_Time_Out)
#define Set_Global_Time_Out     PREPEND(Set_Global_Time_Out)
#define Cancel_Time_Out         PREPEND(Cancel_Time_Out)
#define Update_System_Clock     PREPEND(Update_System_Clock)
#define Set_Async_Time_Out      PREPEND(Set_Async_Time_Out)
#define Get_Last_Updated_System_Time    PREPEND(Get_Last_Updated_System_Time)
#define List_Allocate           PREPEND(List_Allocate)
#define List_Attach         PREPEND(List_Attach)
#define List_Attach_Tail        PREPEND(List_Attach_Tail)
#define List_Create         PREPEND(List_Create)
#define List_Deallocate         PREPEND(List_Deallocate)
#define List_Destroy            PREPEND(List_Destroy)
#define List_Get_First          PREPEND(List_Get_First)
#define List_Get_Next           PREPEND(List_Get_Next)
#define List_Insert         PREPEND(List_Insert)
#define List_Remove         PREPEND(List_Remove)
#define List_Remove_First       PREPEND(List_Remove_First)
#define Get_DDB             PREPEND(Get_DDB)
#define Directed_Sys_Control        PREPEND(Directed_Sys_Control)
#define Install_Exeption_Handler    PREPEND(Install_Exeption_Handler)
#define _Assert_Range           PREPEND(_Assert_Range)
#define _Sprintf            PREPEND(_Sprintf)
#define _PageAllocate           PREPEND(_PageAllocate)
#define _PageFree           PREPEND(_PageFree)
#define _PageReserve        PREPEND(_PageReserve)
#define _PageCommit         PREPEND(_PageCommit)
#define _PageDecommit       PREPEND(_PageDecommit)
#define _AddFreePhysPage        PREPEND(_AddFreePhysPage)
#define Get_Cur_VM_Handle       PREPEND(Get_Cur_VM_Handle)
#define _CreateMutex            PREPEND(_CreateMutex)
#define _DestroyMutex           PREPEND(_DestroyMutex)
#define _EnterMutex         PREPEND(_EnterMutex)
#define _GetMutexOwner          PREPEND(_GetMutexOwner)
#define _LeaveMutex         PREPEND(_LeaveMutex)
#define _SignalID           PREPEND(_SignalID)
#define _BlockOnID          PREPEND(_BlockOnID)
#define _lstrcpyn           PREPEND(_lstrcpyn)
#define _lstrlen            PREPEND(_lstrlen)
#define _lmemcpy            PREPEND(_lmemcpy)
#define VMM_GetSystemInitState      PREPEND(VMM_GetSystemInitState)
#define Get_Boot_Flags          PREPEND(Get_Boot_Flags)
#define Get_Cur_Thread_Handle       PREPEND(Get_Cur_Thread_Handle)
#define _GetVxDName             PREPEND(_GetVxDName)
#define _Call_On_My_Stack       PREPEND(_Call_On_My_Stack)
#define _LinPageLock            PREPEND(_LinPageLock)
#define _LinPageUnLock          PREPEND(_LinPageUnLock)
#define _Allocate_Device_CB_Area        PREPEND(_Allocate_Device_CB_Area)
#define Hook_V86_Int_Chain      PREPEND(Hook_V86_Int_Chain)
#define Unhook_V86_Int_Chain    PREPEND(Unhook_V86_Int_Chain)
#define Get_Next_VM_Handle              PREPEND(Get_Next_VM_Handle)
#define Test_Cur_VM_Handle       PREPEND(Test_Cur_VM_Handle)
#define Test_Sys_VM_Handle       PREPEND(Test_Sys_VM_Handle)
#define _PageCommitPhys         PREPEND(_PageCommitPhys)
#define Open_Boot_Log           PREPEND(Open_Boot_Log)
#define Close_Boot_Log          PREPEND(Close_Boot_Log)
#define Write_Boot_Log          PREPEND(Write_Boot_Log)
#define _CopyPageTable          PREPEND(_CopyPageTable)
#define _PhysIntoV86            PREPEND(_PhysIntoV86)
#define _LinMapIntoV86          PREPEND(_LinMapIntoV86)
#define _ModifyPageBits         PREPEND(_ModifyPageBits)
#define _PageReAllocate         PREPEND(_PageReAllocate)
#define VMM_Add_DDB		PREPEND(VMM_Add_DDB)
#define VMM_Remove_DDB		PREPEND(VMM_Remove_DDB)
#define _AtEventTime            PREPEND(_AtEventTime)
#define	Call_Restricted_Event	PREPEND(Call_Restricted_Event)
#define	Cancel_Restricted_Event	PREPEND(Cancel_Restricted_Event)
#define	_Free_Temp_V86_Data_Area	PREPEND(_Free_Temp_V86_Data_Area)
#define	_Allocate_Temp_V86_Data_Area	PREPEND(_Allocate_Temp_V86_Data_Area)
#define	_GetNulPageHandle	PREPEND(_GetNulPageHandle)
#define	_RegisterGARTHandler	PREPEND(_RegisterGARTHandler)
#define	_GARTReserve		PREPEND(_GARTReserve)
#define	_GARTCommit		PREPEND(_GARTCommit)
#define	_GARTUnCommit		PREPEND(_GARTUnCommit)
#define	_GARTFree		PREPEND(_GARTFree)
#define	_GARTMemAttributes	PREPEND(_GARTMemAttributes)
#define	_FlushCaches		PREPEND(_FlushCaches)
#define	_Set_Global_Time_Out_Ex	PREPEND(_Set_Global_Time_Out_Ex)
#define	_AllocateThreadDataSlot	PREPEND(_AllocateThreadDataSlot)
#define	_FreeThreadDataSlot	PREPEND(_FreeThreadDataSlot)
#define	Get_Next_Thread_Handle	PREPEND(Get_Next_Thread_Handle)
#define	Get_Machine_Info	PREPEND(Get_Machine_Info)
#define	_PageModifyPermissions	PREPEND(_PageModifyPermissions)
#define	_CallRing3		PREPEND(_CallRing3)
#define	_NtKernCreateFile	PREPEND(_NtKernCreateFile)
#define	_NtKernClose	PREPEND(_NtKernClose)
#define	_NtKernReadFile	PREPEND(_NtKernReadFile)
#define	_NtKernWriteFile	PREPEND(_NtKernWriteFile)
#define	_NtKernDeviceIoControl	PREPEND(_NtKernDeviceIoControl)
#define	_NtKernGetWorkerThread	PREPEND(_NtKernGetWorkerThread)
#define	_NtKernLoadDriver	PREPEND(_NtKernLoadDriver)
#define	_NtKernQueueWorkItem	PREPEND(_NtKernQueueWorkItem)
#define	_NtKernPhysicalDeviceObjectToDevNode	PREPEND(_NtKernPhysicalDeviceObjectToDevNode)
#define	_NtKernSetPhysicalCacheTypeRange PREPEND(_NtKernSetPhysicalCacheTypeRange)
#define	_NtKernWin9XLoadDriver		PREPEND(_NtKernWin9XLoadDriver)
#define _SHELL_CallAtAppyTime       PREPEND(_SHELL_CallAtAppyTime)
#define _SHELL_CancelAppyTimeEvent  PREPEND(_SHELL_CancelAppyTimeEvent)
#define _SHELL_QueryAppyTimeAvailable   PREPEND(_SHELL_QueryAppyTimeAvailable)
#define _SHELL_LocalAllocEx     PREPEND(_SHELL_LocalAllocEx)
#define _SHELL_LocalFree        PREPEND(_SHELL_LocalFree)
#define _SHELL_CallDll          PREPEND(_SHELL_CallDll)
#define _SHELL_BroadcastSystemMessage   PREPEND(_SHELL_BroadcastSystemMessage)
#define _SHELL_HookSystemBroadcast  PREPEND(_SHELL_HookSystemBroadcast)
#define _SHELL_UnhookSystemBroadcast    PREPEND(_SHELL_UnhookSystemBroadcast)
#define _SHELL_LoadLibrary      PREPEND(_SHELL_LoadLibrary)
#define _SHELL_FreeLibrary      PREPEND(_SHELL_FreeLibrary)
#define _SHELL_GetProcAddress       PREPEND(_SHELL_GetProcAddress)
#define SHELL_SYSMODAL_Message      PREPEND(SHELL_SYSMODAL_Message)
#define	_SHELL_Update_User_Activity_Ex	PREPEND(_SHELL_Update_User_Activity_Ex)
#define _RegOpenKey         PREPEND(_RegOpenKey)
#define _RegCloseKey            PREPEND(_RegCloseKey)
#define _RegCreateKey           PREPEND(_RegCreateKey)
#define _RegCreateDynKey        PREPEND(_RegCreateDynKey)
#define _RegQueryMultipleValues PREPEND(_RegQueryMultipleValues)
#define _RegDeleteKey           PREPEND(_RegDeleteKey)
#define _RegEnumKey         PREPEND(_RegEnumKey)
#define _RegQueryValue          PREPEND(_RegQueryValue)
#define _RegSetValue            PREPEND(_RegSetValue)
#define _RegDeleteValue         PREPEND(_RegDeleteValue)
#define _RegEnumValue           PREPEND(_RegEnumValue)
#define _RegQueryValueEx        PREPEND(_RegQueryValueEx)
#define _RegSetValueEx          PREPEND(_RegSetValueEx)
#define _RegFlushKey            PREPEND(_RegFlushKey)
#define _RegQueryInfoKey        PREPEND(_RegQueryInfoKey)
#define _RegRemapPreDefKey      PREPEND(_RegRemapPreDefKey)
#define _GetRegistryPath        PREPEND(_GetRegistryPath)
#define _GetRegistryKey         PREPEND(_GetRegistryKey)
#define Get_Config_Directory            PREPEND(Get_Config_Directory)
#define _Call_On_My_Not_Flat_Stack      PREPEND(_Call_On_My_Not_Flat_Stack)
#define _LinRegionLock          PREPEND(_LinRegionLock)
#define _LinRegionUnLock                PREPEND(_LinRegionUnLock)
#define _AttemptingSomethingDangerous   PREPEND(_AttemptingSomethingDangerous)
#define	_Vsprintf			PREPEND(_Vsprintf)

#ifndef	PCI_WITH_PCIMP

#define	_PCI_Read_Config			PREPEND(_PCI_Read_Config)
#define	_PCI_Write_Config			PREPEND(_PCI_Write_Config)
#define	_PCI_Lock_Unlock			PREPEND(_PCI_Lock_Unlock)

#endif	// PCI_WITH_PCIMP

#ifdef  _VTD_H
#ifndef	_VTD_SERVICES_PROVIDER

#define VTD_GetTimeZoneBias         PREPEND(VTD_GetTimeZoneBias)
#define VTD_Get_Real_Time	    PREPEND(VTD_Get_Real_Time)
#define	VTD_Delay_Ex			PREPEND(VTD_Delay_Ex)

#endif
#endif

#ifndef	_PCCARD_SERVICES_PROVIDER

#define	_PCCARD_Access_CIS_Memory	PREPEND(_PCCARD_Access_CIS_Memory)

#endif

#define	MTRRSetPhysicalCacheTypeRange	PREPEND(MTRRSetPhysicalCacheTypeRange)

#define VPICD_Virtualize_IRQ            PREPEND(VPICD_Virtualize_IRQ)
#define VPICD_Phys_EOI                  PREPEND(VPICD_Phys_EOI)
#define VPICD_Physically_Mask           PREPEND(VPICD_Physically_Mask)
#define VPICD_Physically_Unmask         PREPEND(VPICD_Physically_Unmask)
#define VPICD_Force_Default_Behavior    PREPEND(VPICD_Force_Default_Behavior)
#define _VPICD_Clear_IR_Bits            PREPEND(_VPICD_Clear_IR_Bits)
#define _VPICD_Get_Level_Mask   PREPEND(_VPICD_Get_Level_Mask)
#define _VPICD_Set_Level_Mask   PREPEND(_VPICD_Set_Level_Mask)
#define _VPICD_Set_Irql_Mask            PREPEND(_VPICD_Set_Irql_Mask)
#define _VPICD_Set_Channel_Irql         PREPEND(_VPICD_Set_Channel_Irql)
#define	_VPICD_Register_Trigger_Handler PREPEND(_VPICD_Register_Trigger_Handler)

#define	_ACPI_SetTimingMode			PREPEND(_ACPI_SetTimingMode)
#define	_ACPI_SetSystemPowerState		PREPEND(_ACPI_SetSystemPowerState)
#define	_ACPI_RegisterOpRegionCookedHandler	PREPEND(_ACPI_RegisterOpRegionCookedHandler)
#define	_ACPI_Set_RTC				PREPEND(_ACPI_Set_RTC)
#define	_ACPI_GetTimingMode			PREPEND(_ACPI_GetTimingMode)
#define	_ACPI_GetTaskFile			PREPEND(_ACPI_GetTaskFile)
#define	_ACPI_WalkNameSpace			PREPEND(_ACPI_WalkNameSpace)
#define	_ACPI_GetObject				PREPEND(_ACPI_GetObject)
#define	_ACPI_NameSpaceToDevNode		PREPEND(_ACPI_NameSpaceToDevNode)
#define	_ACPI_DevNodeToNameSpace		PREPEND(_ACPI_DevNodeToNameSpace)
#define	_ACPI_RunControlMethod			PREPEND(_ACPI_RunControlMethod)
#define	_ACPI_EvalPackageElement		PREPEND(_ACPI_EvalPackageElement)
#define	_ACPI_EvalPkgDataElement		PREPEND(_ACPI_EvalPkgDataElement)
#define	_ACPI_FreeDataBuffs			PREPEND(_ACPI_FreeDataBuffs)
#define	_ACPI_GetNameSpaceObject		PREPEND(_ACPI_GetNameSpaceObject)

#define VXDLDR_LoadDevice       PREPEND(VXDLDR_LoadDevice)
#define VXDLDR_UnloadDevice     PREPEND(VXDLDR_UnloadDevice)
#define VXDLDR_DevInitSucceeded     PREPEND(VXDLDR_DevInitSucceeded)
#define VXDLDR_DevInitFailed        PREPEND(VXDLDR_DevInitFailed)
#define VXDLDR_GetDeviceList        PREPEND(VXDLDR_GetDeviceList)
#define _PELDR_LoadModule               PREPEND(_PELDR_LoadModule)
#define _PELDR_GetModuleHandle  PREPEND(_PELDR_GetModuleHandle)
#define _PELDR_GetModuleUsage   PREPEND(_PELDR_GetModuleUsage)
#define _PELDR_GetEntryPoint    PREPEND(_PELDR_GetEntryPoint)
#define _PELDR_GetProcAddress   PREPEND(_PELDR_GetProcAddress)
#define _PELDR_AddExportTable   PREPEND(_PELDR_AddExportTable)
#define _PELDR_RemoveExportTable        PREPEND(_PELDR_RemoveExportTable)
#define _PELDR_FreeModule       PREPEND(_PELDR_FreeModule)
#define _PELDR_InitCompleted    PREPEND(_PELDR_InitCompleted)
#define _PELDR_LoadModuleEx     PREPEND(_PELDR_LoadModuleEx)

#define Get_Exec_Path           PREPEND(Get_Exec_Path)
#define CM_Initialize           PREPEND(_CONFIGMG_Initialize)
#define CM_Locate_DevNode       PREPEND(_CONFIGMG_Locate_DevNode)
#define CM_Get_Parent           PREPEND(_CONFIGMG_Get_Parent)
#define CM_Get_Child            PREPEND(_CONFIGMG_Get_Child)
#define CM_Get_Sibling          PREPEND(_CONFIGMG_Get_Sibling)
#define CM_Get_Device_ID_Size       PREPEND(_CONFIGMG_Get_Device_ID_Size)
#define CM_Get_Device_ID        PREPEND(_CONFIGMG_Get_Device_ID)
#define CM_Get_Depth            PREPEND(_CONFIGMG_Get_Depth)
#define CM_Get_Private_DWord        PREPEND(_CONFIGMG_Get_Private_DWord)
#define CM_Set_Private_DWord        PREPEND(_CONFIGMG_Set_Private_DWord)
#define CM_Create_DevNode       PREPEND(_CONFIGMG_Create_DevNode)
#define CM_Query_Remove_SubTree     PREPEND(_CONFIGMG_Query_Remove_SubTree)
#define CM_Remove_SubTree       PREPEND(_CONFIGMG_Remove_SubTree)
#define CM_Register_Device_Driver   PREPEND(_CONFIGMG_Register_Device_Driver)
#define CM_Register_Enumerator      PREPEND(_CONFIGMG_Register_Enumerator)
#define CM_Register_Arbitrator      PREPEND(_CONFIGMG_Register_Arbitrator)
#define CM_Deregister_Arbitrator    PREPEND(_CONFIGMG_Deregister_Arbitrator)
#define CM_Query_Arbitrator_Free_Size   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Size)
#define CM_Query_Arbitrator_Free_Data   PREPEND(_CONFIGMG_Query_Arbitrator_Free_Data)
#define CM_Sort_NodeList        PREPEND(_CONFIGMG_Sort_NodeList)
#define CM_Yield            PREPEND(_CONFIGMG_Yield)
#define CM_Lock             PREPEND(_CONFIGMG_Lock)
#define CM_Unlock           PREPEND(_CONFIGMG_Unlock)
#define CM_Add_Empty_Log_Conf       PREPEND(_CONFIGMG_Add_Empty_Log_Conf)
#define CM_Free_Log_Conf        PREPEND(_CONFIGMG_Free_Log_Conf)
#define CM_Get_First_Log_Conf       PREPEND(_CONFIGMG_Get_First_Log_Conf)
#define CM_Get_Next_Log_Conf        PREPEND(_CONFIGMG_Get_Next_Log_Conf)
#define CM_Add_Res_Des          PREPEND(_CONFIGMG_Add_Res_Des)
#define CM_Modify_Res_Des       PREPEND(_CONFIGMG_Modify_Res_Des)
#define CM_Free_Res_Des         PREPEND(_CONFIGMG_Free_Res_Des)
#define CM_Get_Next_Res_Des     PREPEND(_CONFIGMG_Get_Next_Res_Des)
#define CM_Get_Res_Des_Header_Size  PREPEND(_CONFIGMG_Get_Res_Des_Header_Size)
#define CM_Get_Res_Des_Data_Size    PREPEND(_CONFIGMG_Get_Res_Des_Data_Size)
#define CM_Get_Res_Des_Data     PREPEND(_CONFIGMG_Get_Res_Des_Data)
#define CM_Process_Events_Now       PREPEND(_CONFIGMG_Process_Events_Now)
#define CM_Create_Range_List        PREPEND(_CONFIGMG_Create_Range_List)
#define CM_Add_Range            PREPEND(_CONFIGMG_Add_Range)
#define CM_Delete_Range         PREPEND(_CONFIGMG_Delete_Range)
#define CM_Test_Range_Available     PREPEND(_CONFIGMG_Test_Range_Available)
#define CM_Dup_Range_List       PREPEND(_CONFIGMG_Dup_Range_List)
#define CM_Free_Range_List      PREPEND(_CONFIGMG_Free_Range_List)
#define CM_Invert_Range_List        PREPEND(_CONFIGMG_Invert_Range_List)
#define CM_Intersect_Range_List     PREPEND(_CONFIGMG_Intersect_Range_List)
#define CM_First_Range          PREPEND(_CONFIGMG_First_Range)
#define CM_Next_Range           PREPEND(_CONFIGMG_Next_Range)
#define CM_Dump_Range_List      PREPEND(_CONFIGMG_Dump_Range_List)
#define CM_Load_DLVxDs          PREPEND(_CONFIGMG_Load_DLVxDs)
#define CM_Get_DDBs         PREPEND(_CONFIGMG_Get_DDBs)
#define CM_Get_CRC_CheckSum     PREPEND(_CONFIGMG_Get_CRC_CheckSum)
#define CM_Register_DevLoader       PREPEND(_CONFIGMG_Register_DevLoader)
#define CM_Reenumerate_DevNode      PREPEND(_CONFIGMG_Reenumerate_DevNode)
#define CM_Setup_DevNode        PREPEND(_CONFIGMG_Setup_DevNode)
#define CM_Reset_Children_Marks     PREPEND(_CONFIGMG_Reset_Children_Marks)
#define CM_Get_DevNode_Status       PREPEND(_CONFIGMG_Get_DevNode_Status)
#define CM_Remove_Unmarked_Children PREPEND(_CONFIGMG_Remove_Unmarked_Children)
#define CM_ISAPNP_To_CM         PREPEND(_CONFIGMG_ISAPNP_To_CM)
#define CM_CallBack_Device_Driver   PREPEND(_CONFIGMG_CallBack_Device_Driver)
#define CM_CallBack_Enumerator      PREPEND(_CONFIGMG_CallBack_Enumerator)
#define CM_Get_Alloc_Log_Conf       PREPEND(_CONFIGMG_Get_Alloc_Log_Conf)
#define CM_Get_DevNode_Key_Size     PREPEND(_CONFIGMG_Get_DevNode_Key_Size)
#define CM_Get_DevNode_Key      PREPEND(_CONFIGMG_Get_DevNode_Key)
#define CM_Read_Registry_Value      PREPEND(_CONFIGMG_Read_Registry_Value)
#define CM_Write_Registry_Value     PREPEND(_CONFIGMG_Write_Registry_Value)
#define CM_Disable_DevNode      PREPEND(_CONFIGMG_Disable_DevNode)
#define CM_Enable_DevNode       PREPEND(_CONFIGMG_Enable_DevNode)
#define CM_Move_DevNode         PREPEND(_CONFIGMG_Move_DevNode)
#define CM_Set_Bus_Info         PREPEND(_CONFIGMG_Set_Bus_Info)
#define CM_Get_Bus_Info         PREPEND(_CONFIGMG_Get_Bus_Info)
#define CM_Set_HW_Prof          PREPEND(_CONFIGMG_Set_HW_Prof)
#define CM_Recompute_HW_Prof        PREPEND(_CONFIGMG_Recompute_HW_Prof)
#define CM_Get_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Get_Device_Driver_Private_DWord)
#define CM_Set_Device_Driver_Private_DWord  PREPEND(_CONFIGMG_Set_Device_Driver_Private_DWord)
#define CM_Query_Change_HW_Prof     PREPEND(_CONFIGMG_Query_Change_HW_Prof)
#define CM_Get_HW_Prof_Flags        PREPEND(_CONFIGMG_Get_HW_Prof_Flags)
#define CM_Set_HW_Prof_Flags        PREPEND(_CONFIGMG_Set_HW_Prof_Flags)
#define CM_Read_Registry_Log_Confs  PREPEND(_CONFIGMG_Read_Registry_Log_Confs)
#define CM_Run_Detection        PREPEND(_CONFIGMG_Run_Detection)
#define CM_Call_At_Appy_Time        PREPEND(_CONFIGMG_Call_At_Appy_Time)
#define CM_Fail_Change_HW_Prof      PREPEND(_CONFIGMG_Fail_Change_HW_Prof)
#define CM_Set_Private_Problem      PREPEND(_CONFIGMG_Set_Private_Problem)
#define CM_Debug_DevNode        PREPEND(_CONFIGMG_Debug_DevNode)
#define CM_Get_Hardware_Profile_Info    PREPEND(_CONFIGMG_Get_Hardware_Profile_Info)
#define CM_Register_Enumerator_Function PREPEND(_CONFIGMG_Register_Enumerator_Function)
#define CM_Call_Enumerator_Function     PREPEND(_CONFIGMG_Call_Enumerator_Function)
#define CM_Add_ID                       PREPEND(_CONFIGMG_Add_ID)
#define CM_Find_Range                   PREPEND(_CONFIGMG_Find_Range)
#define CM_Get_Global_State             PREPEND(_CONFIGMG_Get_Global_State)
#define CM_Broadcast_Device_Change_Message      PREPEND(_CONFIGMG_Broadcast_Device_Change_Message)
#define CM_Call_DevNode_Handler         PREPEND(_CONFIGMG_Call_DevNode_Handler)
#define CM_Remove_Reinsert_All                  PREPEND(_CONFIGMG_Remove_Reinsert_All)
//
// OPK2 Services
//
#define CM_Change_DevNode_Status        PREPEND(_CONFIGMG_Change_DevNode_Status)
#define CM_Reprocess_DevNode            PREPEND(_CONFIGMG_Reprocess_DevNode)
#define CM_Assert_Structure             PREPEND(_CONFIGMG_Assert_Structure)
#define CM_Discard_Boot_Log_Conf        PREPEND(_CONFIGMG_Discard_Boot_Log_Conf)
#define CM_Set_Dependent_DevNode        PREPEND(_CONFIGMG_Set_Dependent_DevNode)
#define CM_Get_Dependent_DevNode        PREPEND(_CONFIGMG_Get_Dependent_DevNode)
#define CM_Refilter_DevNode             PREPEND(_CONFIGMG_Refilter_DevNode)
#define CM_Merge_Range_List             PREPEND(_CONFIGMG_Merge_Range_List);
#define CM_Substract_Range_List         PREPEND(_CONFIGMG_Substract_Range_List);
#define	CM_Set_DevNode_PowerState	PREPEND(_CONFIGMG_Set_DevNode_PowerState)
#define	CM_Get_DevNode_PowerState	PREPEND(_CONFIGMG_Get_DevNode_PowerState)
#define	CM_Set_DevNode_PowerCapabilities	PREPEND(_CONFIGMG_Set_DevNode_PowerCapabilities)
#define	CM_Get_DevNode_PowerCapabilities	PREPEND(_CONFIGMG_Get_DevNode_PowerCapabilities)
#define	CM_Read_Range_List		PREPEND(_CONFIGMG_Read_Range_List)
#define	CM_Write_Range_List		PREPEND(_CONFIGMG_Write_Range_List)
#define	CM_Get_Set_Log_Conf_Priority	PREPEND(_CONFIGMG_Get_Set_Log_Conf_Priority)
#define	CM_Support_Share_Irq		PREPEND(_CONFIGMG_Support_Share_Irq)
#define	CM_Get_Parent_Structure		PREPEND(_CONFIGMG_Get_Parent_Structure)
//
// 4.1 Services
//
#define	CM_Register_DevNode_For_Idle_Detection	PREPEND(_CONFIGMG_Register_DevNode_For_Idle_Detection)
#define	CM_CM_To_ISAPNP				PREPEND(_CONFIGMG_CM_To_ISAPNP)
#define	CM_Get_DevNode_Handler			PREPEND(_CONFIGMG_Get_DevNode_Handler)
#define	CM_Detect_Resource_Conflict		PREPEND(_CONFIGMG_Detect_Resource_Conflict)
#define	CM_Get_Interface_Device_List		PREPEND(_CONFIGMG_Get_Interface_Device_List)
#define	CM_Get_Interface_Device_List_Size	PREPEND(_CONFIGMG_Get_Interface_Device_List_Size)
#define	CM_Get_Conflict_Info			PREPEND(_CONFIGMG_Get_Conflict_Info)
#define	CM_Add_Remove_DevNode_Property		PREPEND(_CONFIGMG_Add_Remove_DevNode_Property)
#define	CM_CallBack_At_Appy_Time		PREPEND(_CONFIGMG_CallBack_At_Appy_Time)
#define	CM_Register_Interface_Device		PREPEND(_CONFIGMG_Register_Interface_Device)
#define	CM_System_Device_Power_State_Mapping	PREPEND(_CONFIGMG_System_Device_Power_State_Mapping)
#define	CM_Get_Arbitrator_Info			PREPEND(_CONFIGMG_Get_Arbitrator_Info)
#define	CM_Waking_Up_From_DevNode		PREPEND(_CONFIGMG_Waking_Up_From_DevNode)
#define	CM_Set_DevNode_Problem			PREPEND(_CONFIGMG_Set_DevNode_Problem)

#ifdef _VCOMM_H
#define VCOMM_Register_Port_Driver      PREPEND(_VCOMM_Register_Port_Driver)
#define VCOMM_Acquire_Port              PREPEND(_VCOMM_Acquire_Port)
#define VCOMM_Release_Port              PREPEND(_VCOMM_Release_Port)
#define VCOMM_OpenComm                  PREPEND(_VCOMM_OpenComm)
#define VCOMM_SetCommState              PREPEND(_VCOMM_SetCommState)
#define VCOMM_GetCommState              PREPEND(_VCOMM_GetCommState)
#define VCOMM_SetupComm                 PREPEND(_VCOMM_SetupComm)
#define VCOMM_TransmitCommChar          PREPEND(_VCOMM_TransmitCommChar)
#define VCOMM_CloseComm                 PREPEND(_VCOMM_CloseComm)
#define VCOMM_GetCommQueueStatus        PREPEND(_VCOMM_GetCommQueueStatus)
#define VCOMM_ClearCommError            PREPEND(_VCOMM_ClearCommError)
#define VCOMM_GetModemStatus            PREPEND(_VCOMM_GetModemStatus)
#define VCOMM_GetCommProperties         PREPEND(_VCOMM_GetCommProperties)
#define VCOMM_EscapeCommFunction        PREPEND(_VCOMM_EscapeCommFunction)
// #define VCOMM_DeviceIOControl           PREPEND(_VCOMM_DeviceIOControl)
#define VCOMM_PurgeComm                 PREPEND(_VCOMM_PurgeComm)
#define VCOMM_SetCommEventMask          PREPEND(_VCOMM_SetCommEventMask)
#define VCOMM_GetCommEventMask          PREPEND(_VCOMM_GetCommEventMask)
#define VCOMM_WriteComm                 PREPEND(_VCOMM_WriteComm)
#define VCOMM_ReadComm                  PREPEND(_VCOMM_ReadComm)
#define VCOMM_EnableCommNotification    PREPEND(_VCOMM_EnableCommNotification)
#define VCOMM_GetLastError              PREPEND(_VCOMM_GetLastError)
#define VCOMM_Steal_Port                PREPEND(_VCOMM_Steal_Port)
#define VCOMM_SetReadCallBack           PREPEND(_VCOMM_SetReadCallBack)
#define VCOMM_SetWriteCallBack          PREPEND(_VCOMM_SetWriteCallBack)
#define VCOMM_Add_Port                  PREPEND(_VCOMM_Add_Port)

#ifndef WIN31COMPAT
#define VCOMM_GetSetCommTimeouts        PREPEND(_VCOMM_GetSetCommTimeouts)
#define VCOMM_SetWriteRequest           PREPEND(_VCOMM_SetWriteRequest)
#define VCOMM_SetReadRequest            PREPEND(_VCOMM_SetReadRequest)
#define VCOMM_Dequeue_Request           PREPEND(_VCOMM_Dequeue_Request)
#define VCOMM_Enumerate_DevNodes        PREPEND(_VCOMM_Enumerate_DevNodes)
#define VCOMM_Get_Contention_Handler    PREPEND(_VCOMM_Get_Contention_Handler)
#define VCOMM_Map_Name_To_Resource  PREPEND(_VCOMM_Map_Name_To_Resource)
#endif
#endif // _VCOMM_H

#ifdef      _IRS_H
#define IOS_Requestor_Service       PREPEND(IOS_Requestor_Service)
#endif      // _IRS_H

#ifdef      _INC_VPOWERD

#define _VPOWERD_Get_APM_BIOS_Version       PREPEND(_VPOWERD_Get_APM_BIOS_Version)
#define _VPOWERD_Get_Power_Management_Level PREPEND(_VPOWERD_Get_Power_Management_Level)
#define _VPOWERD_Set_Power_Management_Level PREPEND(_VPOWERD_Set_Power_Management_Level)
#define _VPOWERD_Set_Device_Power_State     PREPEND(_VPOWERD_Set_Device_Power_State)
#define _VPOWERD_Set_System_Power_State     PREPEND(_VPOWERD_Set_System_Power_State)
#define _VPOWERD_Restore_Power_On_Defaults  PREPEND(_VPOWERD_Restore_Power_On_Defaults)
#define _VPOWERD_Get_Power_Status       PREPEND(_VPOWERD_Get_Power_Status)
#define	_VPOWERD_Transfer_Control	PREPEND(_VPOWERD_Transfer_Control)
#define _VPOWERD_Get_Power_State        PREPEND(_VPOWERD_Get_Power_State)
#define _VPOWERD_OEM_APM_Function       PREPEND(_VPOWERD_OEM_APM_Function)
#define _VPOWERD_Register_Power_Handler     PREPEND(_VPOWERD_Register_Power_Handler)
#define _VPOWERD_Deregister_Power_Handler   PREPEND(_VPOWERD_Deregister_Power_Handler)

#endif      // _INC_VPOWERD

#ifdef _VDMAD_H_
#define VDMAD_Get_Phys_Count    PREPEND(VDMAD_Get_Phys_Count)
#define VDMAD_Phys_Mask_Channel PREPEND(VDMAD_Phys_Mask_Channel)
#define VDMAD_Phys_Unmask_Channel PREPEND(VDMAD_Phys_Unmask_Channel)
#define VDMAD_Set_Phys_State PREPEND(VDMAD_Set_Phys_State)
#define VDMAD_Set_Region_Info PREPEND(VDMAD_Set_Region_Info)
#define VDMAD_Unvirtualize_Channel PREPEND(VDMAD_Unvirtualize_Channel)
#define VDMAD_Virtualize_Channel PREPEND(VDMAD_Virtualize_Channel)
#endif // _VDMAD_H_

#ifdef  USECMDWRAPPERS

struct _CMDDEBUGCOMMAND {
	CHAR    cLetter;
	VOID    (_cdecl *pFunction)(VOID);
	PCHAR   pszShortName;
	PCHAR   pszExplanation;
};

typedef struct _CMDDEBUGCOMMAND CMDDC;
typedef CMDDC                   *PCMDDC;

#define CMDD            _Debug_Printf_Service
#define CMD_LOCAL       _fastcall

/****************************************************************************
 *
 *      CMDInChar - Get a character from the debug terminal
 *
 *      ENTRY:  None.
 *
 *      EXIT:   ASCII character.
 *
 ***************************************************************************/
CHAR CMD_LOCAL
CMDInChar(VOID);

/****************************************************************************
 *
 *      CMDMenu - Display standard menu
 *
 *      ENTRY:  pszVxDName is the name of the VxD which wants this debugger.
 *
 *              pdcDebugCommands are the various debug commands.
 *
 *      EXIT:   None.
 *
 ***************************************************************************/
VOID CMD_LOCAL
CMDMenu(PCHAR pszVxDName, PCMDDC pdcDebugCommands);

/****************************************************************************
 *
 *      CMDReadNumber - Returns an hex number read from the debug terminal
 *
 *      ENTRY:  pszQuestion is the prompt (can be NULL).
 *
 *              bNumDigits is the number of hex digits of maximum input (1-8).
 *
 *              fAppendCrLf is TRUE if a carriage return is wanted after the
 *              input.
 *
 *      EXIT:   A DWORD being the inputted value.
 *
 ***************************************************************************/
DWORD CMD_LOCAL
CMDReadNumber(PCHAR pszQuestion, BYTE bNumDigits, BOOL fAppendCrLf);

/***LP  CMDGetString - Read a string from the debug terminal
 *
 *  ENTRY
 *      pszPrompt -> prompt string
 *      pszBuff -> buffer to hold the string
 *      dwcbLen - buffer length
 *      fUpper - TRUE if convert to upper case
 *
 *  EXIT
 *      returns the number of characters read including the terminating newline.
 */
DWORD CMD_LOCAL
CMDGetString(PCHAR pszPrompt, PCHAR pszBuff, DWORD dwcbLen, BOOL fUpper);

#endif  // USECMDWRAPPERS

#endif  // _VXDWRAPS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\detect\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=detect
# TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;$(WINDOWS_COM)\inc;

SOURCES= \
	..\osdet.cpp	\
	..\findoem.cpp	\
	..\osdetutl.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\dlcache.h ===
/********************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dlcache.h

Revision History:
    DerekM  created  11/26/01

********************************************************************/

#ifndef DLCACHE_H
#define DLCACHE_H

#if defined(UNICODE)

#include <tchar.h>
#include <dllite.h>

const DWORD c_dwProxyCacheTimeLimit = 60 * 60 * 1000; // 1h

struct SWUDLProxyCacheObj
{
    LPWSTR  wszSrv;
    LPWSTR  wszProxy;
    LPWSTR  wszBypass;
    DWORD   dwAccessType;
    DWORD   cbProxy;
    DWORD   cbBypass;
    DWORD   dwLastCacheTime;
    DWORD   iLastKnownGood;

    SWUDLProxyCacheObj *pNext;
};

class CWUDLProxyCache
{
private:
    SWUDLProxyCacheObj   *m_rgpObj;

    SWUDLProxyCacheObj *internalFind(LPCWSTR wszSrv);

public:
    CWUDLProxyCache();
    ~CWUDLProxyCache();

    BOOL    Set(LPCWSTR wszSrv, LPCWSTR wszProxy, LPCWSTR wszBypass, 
                DWORD dwAccessType);
    BOOL    Find(LPCWSTR wszSrv, LPWSTR *pwszProxy, LPWSTR *pwszBypass, 
                DWORD *pdwAccessType);
    BOOL    SetLastGoodProxy(LPCWSTR wszSrv, DWORD iProxy);
    BOOL    GetLastGoodProxy(LPCWSTR wszSrv, SAUProxySettings *paups);
    BOOL    Empty(void);
};

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\detect\osdet.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdet.cpp
//
//  Description:
//
//      Ported to lib from V3 SLM DLL sources
//
//=======================================================================

#include <windows.h>
#include <wuiutest.h>
#include <tchar.h>
#include <osdet.h>
#include <logging.h>
#include <iucommon.h>
#include "wusafefn.h"
#include<MISTSAFE.h>

// Forwared Declarations
static LANGID CorrectGetSystemDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95);
static LANGID CorrectGetUserDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95);
static WORD CorrectGetACP(void);
static WORD CorrectGetOEMCP(void);
static LANGID MapLangID(LANGID langid);
static bool FIsNECMachine();
static int aton(LPCTSTR ptr);
static int atoh(LPCTSTR ptr);


//
// Constants and defines
//
const LANGID LANGID_ENGLISH         = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);            // 0x0409
const LANGID LANGID_GREEK           = MAKELANGID(LANG_GREEK, SUBLANG_DEFAULT);              // 0x0408
const LANGID LANGID_JAPANESE        = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);           // 0x0411

const LANGID LANGID_ARABIC          = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA); // 0x0401
const LANGID LANGID_HEBREW          = MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT);             // 0x040D
const LANGID LANGID_THAI            = MAKELANGID(LANG_THAI, SUBLANG_DEFAULT);               // 0x041E


const TCHAR Win98_REGPATH_MACHLCID[]    = _T("Control Panel\\Desktop\\ResourceLocale");
const TCHAR REGPATH_CODEPAGE[]          = _T("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage");
const TCHAR REGKEY_OEMCP[]              = _T("OEMCP");
const TCHAR REGKEY_ACP[]                = _T("ACP");
const TCHAR REGKEY_LOCALE[]             = _T("Locale");
const TCHAR REGKEY_IE[]                 = _T("Software\\Microsoft\\Internet Explorer");
const TCHAR REGKEY_VERSION[]            = _T("Version");
const TCHAR REGKEY_CP_INTERNATIONAL[]   = _T(".DEFAULT\\Control Panel\\International");
const TCHAR REGKEY_CP_RESOURCELOCAL[]   = _T("Control Panel\\Desktop\\ResourceLocale");


const TCHAR KERNEL32_DLL[]              = _T("kernel32.dll");

const WORD CODEPAGE_ARABIC          = 1256;
const WORD CODEPAGE_HEBREW          = 1255;
const WORD CODEPAGE_THAI            = 874;
const WORD CODEPAGE_GREEK_MS        = 737;
const WORD CODEPAGE_GREEK_IBM       = 869;

// ISO code for Greek OS's on Windows 98 ONLY.
const TCHAR ISOCODE_GREEK_MS[]      = _T("el_MS");
const TCHAR ISOCODE_GREEK_IBM[]     = _T("el_IBM");
   

// Registry keys to determine NEC machines
const TCHAR NT5_REGPATH_MACHTYPE[]      = _T("HARDWARE\\DESCRIPTION\\System");
const TCHAR NT5_REGKEY_MACHTYPE[]       = _T("Identifier");
const TCHAR REGVAL_MACHTYPE_AT[]        = _T("AT/AT COMPATIBLE");
const TCHAR REGVAL_MACHTYPE_NEC[]       = _T("NEC PC-98");
const TCHAR REGVAL_GREEK_IBM[]          = _T("869");

// Platform strings
const TCHAR SZ_PLAT_WIN95[]     = _T("w95");
const TCHAR SZ_PLAT_WIN98[]     = _T("w98");
const TCHAR SZ_PLAT_WINME[]     = _T("mil");
const TCHAR SZ_PLAT_NT4[]       = _T("NT4");
const TCHAR SZ_PLAT_W2K[]       = _T("W2k");
const TCHAR SZ_PLAT_WHISTLER[]  = _T("Whi");
const TCHAR SZ_PLAT_UNKNOWN[]   = _T("unk");


#define LOOKUP_OEMID(keybdid)     HIBYTE(LOWORD((keybdid)))
#define PC98_KEYBOARD_ID          0x0D

//
// Globals
//

//
// We derive this from WINVER >= 0x0500 section of winnls.h
//
typedef LANGID (WINAPI * PFN_GetUserDefaultUILanguage) (void);
typedef LANGID (WINAPI * PFN_GetSystemDefaultUILanguage) (void);

typedef struct
{
    LANGID  langidUser;
    TCHAR * pszISOCode;

} USER_LANGID;

typedef struct
{
    LANGID  langidMachine;
    TCHAR * pszDefaultISOCode;
    int     cElems;
    const USER_LANGID * grLangidUser;

} MACH_LANGID;


// We give a Japanese NEC machine its own ISO code.
#define LANGID_JAPANESE     0x0411
#define ISOCODE_NEC         _T("nec")
#define ISOCODE_EN          _T("en")
#define grsize(langid) (sizeof(gr##langid) / sizeof(USER_LANGID))

// These are all the user langids associated with a particular machine.

// NTRAID#NTBUG9-220063-2000/12/13-waltw 220063 IU: Specify mappings between GetSystemDefaultUILanguage LANGID and ISO/639/1988
//  From Industry Update XML Schema.doc
//      3.1 Language Codes
//      The languages are defined by ISO 639. They are represented by lowercase 2 letter symbols such as "en" for English, "fr" for French etc.
//
//      3.2 Country Codes
//      The country codes are defined in ISO 3166-1, using the Alpha-2 representation (two letter symbols).
//
//      3.3 Representation in Industry Update
//      Industry Update uses the RFC 1766 standard to manage the representation of language+locale symbols. 
//      3.3.1   Simple Case - Language Alone
//      When no regional flavor is considered for a language, or when it pertains to the "standard" version of the language, such as Portuguese as spoken in Portugal, it uses a straight ISO 639 symbol:
//      en, fr, de
//
//      3.3.2   Regional Variants
//      Managed by the RFCThe lowercase version of the Alpha-2 ISO 3166-1 country (or region) code is hyphenated to the language code, e.g. en-us, en-ca, fr-be, fr-ca, zh-hk, zh-tw


const USER_LANGID gr0404[] = {{0x0804,_T("zh-CN")},{0x1004,_T("zh-CN")}};
const USER_LANGID gr0407[] = {{0x0c07,_T("de-AT")},{0x0807,_T("de-CH")}};
const USER_LANGID gr0409[] = {{0x1c09,_T("en-ZA")},{0x0809,_T("en-GB")},{0x0c09,_T("en-AU")},{0x1009,_T("en-CA")},
                        {0x1409,_T("en-NZ")},{0x1809,_T("en-IE")}};
const USER_LANGID gr040c[] = {{0x080c,_T("fr-BE")},{0x0c0c,_T("fr-CA")},{0x100c,_T("fr-CH")}};
const USER_LANGID gr0410[] = {{0x0810,_T("it-CH")}};
const USER_LANGID gr0413[] = {{0x0813,_T("nl-BE")}};
const USER_LANGID gr0416[] = {{0x0816,_T("pt")}};
const USER_LANGID gr080a[] = {{0x040a,_T("es")},{0x080a,_T("es-MX")},{0x200a,_T("es-VE")},{0x240a,_T("es-CO")},
                        {0x280a,_T("es-PE")},{0x2c0a,_T("es-AR")},{0x300a,_T("es-EC")},{0x340a,_T("es-CL")}};
const USER_LANGID gr0c0a[] = {{0x040a,_T("es")},{0x080a,_T("es-MX")},{0x200a,_T("es-VE")},{0x240a,_T("es-CO")},
                        {0x280a,_T("es-PE")},{0x2c0a,_T("es-AR")},{0x300a,_T("es-EC")},{0x340a,_T("es-CL")}};

// These are all the machine langids.  If there isn't an associated array of user langids, then
// the user langid is irrelevant, and the default ISO language code should be used. If there is
// an associated array of user langids, then it should be searched first and the specific langid used.
// If no match is found in the user langids, then the default langid is used.
const MACH_LANGID grLangids[] = {
    { 0x0401, _T("ar"),     0,              NULL },
    { 0x0403, _T("ca"),     0,              NULL },
    { 0x0404, _T("zh-TW"),  grsize(0404),   gr0404 },
    { 0x0405, _T("cs"),     0,              NULL },
    { 0x0406, _T("da"),     0,              NULL },
    { 0x0407, _T("de"),     grsize(0407),   gr0407 },
    { 0x0408, _T("el"),     0,              NULL },
    { 0x0409, _T("en"),     grsize(0409),   gr0409 },
    { 0x040b, _T("fi"),     0,              NULL },
    { 0x040c, _T("fr"),     grsize(040c),   gr040c },
    { 0x040d, _T("iw"),     0,              NULL },
    { 0x040e, _T("hu"),     0,              NULL },
    { 0x0410, _T("it"),     grsize(0410),   gr0410 },
    { 0x0411, _T("ja"),     0,              NULL },
    { 0x0412, _T("ko"),     0,              NULL },
    { 0x0413, _T("nl"),     grsize(0413),   gr0413 },
    { 0x0414, _T("no"),     0,              NULL },
    { 0x0415, _T("pl"),     0,              NULL },
    { 0x0416, _T("pt-BR"),  grsize(0416),   gr0416 },               
    { 0x0419, _T("ru"),     0,              NULL },
    { 0x041b, _T("sk"),     0,              NULL },
    { 0x041d, _T("sv"),     0,              NULL },
    { 0x041e, _T("th"),     0,              NULL },
    { 0x041f, _T("tr"),     0,              NULL },
    { 0x0424, _T("sl"),     0,              NULL },
    { 0x042d, _T("eu"),     0,              NULL },
    { 0x0804, _T("zh-CN"),  0,              NULL },
    { 0x080a, _T("es"),     grsize(080a),   gr080a },
    { 0x0816, _T("pt"),     0,              NULL },
    { 0x0c0a, _T("es"),     grsize(0c0a),   gr0c0a }
};

#define cLangids (sizeof(grLangids) / sizeof(MACH_LANGID))

static LANGID MapLangID(LANGID langid)
{
    switch (PRIMARYLANGID(langid))
    {
        case LANG_ARABIC:
            langid = MAKELANGID(LANG_ARABIC, SUBLANG_ARABIC_SAUDI_ARABIA);
            break;

        case LANG_CHINESE:
            if (SUBLANGID(langid) != SUBLANG_CHINESE_TRADITIONAL)
                langid = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
            break;

        case LANG_DUTCH:
            langid = MAKELANGID(LANG_DUTCH, SUBLANG_DUTCH);
            break;

        case LANG_GERMAN:
            langid = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
            break;

        case LANG_ENGLISH:
            if (SUBLANGID(langid) != SUBLANG_ENGLISH_UK)
                langid = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
            break;

        case LANG_FRENCH:
            langid = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
            break;

        case LANG_ITALIAN:
            langid = MAKELANGID(LANG_ITALIAN, SUBLANG_ITALIAN);
            break;

        case LANG_KOREAN:
            langid = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
            break;

        case LANG_NORWEGIAN:
            langid = MAKELANGID(LANG_NORWEGIAN, SUBLANG_NORWEGIAN_BOKMAL);
            break;

        case LANG_PORTUGUESE:
            // We support both SUBLANG_PORTUGUESE and SUBLANG_PORTUGUESE_BRAZILIAN
            break;

        case LANG_SPANISH:
            langid = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
            break;

        case LANG_SWEDISH:
            langid = MAKELANGID(LANG_SWEDISH, SUBLANG_SWEDISH);
            break;
    };
    return langid;
}



// return user language ID
LANGID WINAPI GetUserLangID()
{
    LOG_Block("GetUserLangID");

#ifdef __WUIUTEST
    // language spoofing
    HKEY hKey;
    DWORD dwLangID = 0;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(dwLangID);
        error = RegQueryValueEx(hKey, REGVAL_USER_LANGID, 0, 0, (LPBYTE)&dwLangID, &dwSize);
        RegCloseKey(hKey);
        if (ERROR_SUCCESS == error)
        {
            return (WORD) dwLangID;
        }
    }
#endif

    WORD wCodePage = 0;
    BOOL bIsNT4 = FALSE;
    BOOL bIsW95 = FALSE;
    
    // 
    // get base language id
    //
    LANGID langidCurrent = CorrectGetUserDefaultLangID(bIsNT4, bIsW95);  // Passed by reference

    //
 //     // special handling for languages
 //     //
 //     switch (langidCurrent) 
 //     {
 //         case LANGID_ENGLISH:
 // 
 //             // enabled langauges
 //             wCodePage = CorrectGetACP();
 //             if (CODEPAGE_ARABIC != wCodePage && 
 //                 CODEPAGE_HEBREW != wCodePage && 
 //                 CODEPAGE_THAI != wCodePage)
 //             {
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_GREEK:
 // 
 //             // Greek IBM?
 //             wCodePage = CorrectGetOEMCP();
 //             if (wCodePage != CODEPAGE_GREEK_IBM)
 //             {
 //                 // if its not Greek IBM we assume its MS. The language code for Greek MS does not include
 //                 // the code page
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_JAPANESE:
 // 
 //             if (FIsNECMachine())
 //             {
 //                 wCodePage = 1;  
 //             }
 // 
 //             break;
 //         
 //         default:
 // 
    // map language to the ones we support
    //
    langidCurrent = MapLangID(langidCurrent);   
 //             break;
 //     }

    //
    // Special treatment of NT4 and W95 languages.  
    // On NT4, Enabled Arabic, Thai, and Hebrew systems report as fully localized but we want to map them to Enabled
    // On W95, Enabled Thai is reported as Thai but we want to map to Enabled Thai
    //
    if (bIsNT4)
    {
        // NT4
        switch (langidCurrent) 
        {
            case LANGID_ARABIC:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_HEBREW:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_THAI:
                langidCurrent = LANGID_ENGLISH;
                break;
        }
    }
    else if (bIsW95)
    {
        // W95 - only tweek Thai
        if (langidCurrent == LANGID_THAI)
        {
//          wCodePage = CODEPAGE_THAI;
            langidCurrent = LANGID_ENGLISH;
        }
    }

    LOG_Driver(_T("Returning 0x%04x"), langidCurrent);
    return langidCurrent;
}

// return system language ID
LANGID WINAPI GetSystemLangID()
{
    LOG_Block("GetSystemLangID");

#ifdef __WUIUTEST
    // language spoofing
    HKEY hKey;
    DWORD dwLangID = 0;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(dwLangID);
        error = RegQueryValueEx(hKey, REGVAL_OS_LANGID, 0, 0, (LPBYTE)&dwLangID, &dwSize);
        RegCloseKey(hKey);
        if (ERROR_SUCCESS == error)
        {
            return (WORD) dwLangID;
        }
    }
#endif

    WORD wCodePage = 0;
    BOOL bIsNT4 = FALSE;
    BOOL bIsW95 = FALSE;
    
    // 
    // get base language id
    //
    LANGID langidCurrent = CorrectGetSystemDefaultLangID(bIsNT4, bIsW95);  // Passed by reference

    //
 //     // special handling for languages
 //     //
 //     switch (langidCurrent) 
 //     {
 //         case LANGID_ENGLISH:
 // 
 //             // enabled langauges
 //             wCodePage = CorrectGetACP();
 //             if (CODEPAGE_ARABIC != wCodePage && 
 //                 CODEPAGE_HEBREW != wCodePage && 
 //                 CODEPAGE_THAI != wCodePage)
 //             {
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_GREEK:
 // 
 //             // Greek IBM?
 //             wCodePage = CorrectGetOEMCP();
 //             if (wCodePage != CODEPAGE_GREEK_IBM)
 //             {
 //                 // if its not Greek IBM we assume its MS. The language code for Greek MS does not include
 //                 // the code page
 //                 wCodePage = 0;
 //             }
 //             break;
 //         
 //         case LANGID_JAPANESE:
 // 
 //             if (FIsNECMachine())
 //             {
 //                 wCodePage = 1;  
 //             }
 // 
 //             break;
 //         
 //         default:
 // 
    // map language to the ones we support
    //
    langidCurrent = MapLangID(langidCurrent);   
 //             break;
 //     }

    //
    // Special treatment of NT4 and W95 languages.  
    // On NT4, Enabled Arabic, Thai, and Hebrew systems report as fully localized but we want to map them to Enabled
    // On W95, Enabled Thai is reported as Thai but we want to map to Enabled Thai
    //
    if (bIsNT4)
    {
        // NT4
        switch (langidCurrent) 
        {
            case LANGID_ARABIC:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_HEBREW:
                langidCurrent = LANGID_ENGLISH;
                break;

            case LANGID_THAI:
                langidCurrent = LANGID_ENGLISH;
                break;
        }
    }
    else if (bIsW95)
    {
        // W95
        if (langidCurrent == LANGID_THAI)
        {
//          wCodePage = CODEPAGE_THAI;
            langidCurrent = LANGID_ENGLISH;
        }
    }

    LOG_Driver(_T("Returning 0x%04x"), langidCurrent);
    return langidCurrent;
}


HRESULT WINAPI DetectClientIUPlatform(PIU_PLATFORM_INFO pIuPlatformInfo)
{
    LOG_Block("DetectClientIUPlatform");
    HRESULT hr = S_OK;

    if (!pIuPlatformInfo)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    ZeroMemory(pIuPlatformInfo, sizeof(IU_PLATFORM_INFO));

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( !GetVersionEx(&osverinfo) )
    {
        LOG_ErrorMsg(GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef __WUIUTEST
    // platform spoofing
    HKEY hKey;
    int error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_WUIUTEST, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS == error)
    {
        DWORD dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey, REGVAL_MAJORVER, 0, 0, (LPBYTE)&osverinfo.dwMajorVersion, &dwSize);
        RegQueryValueEx(hKey, REGVAL_MINORVER, 0, 0, (LPBYTE)&osverinfo.dwMinorVersion, &dwSize);
        RegQueryValueEx(hKey, REGVAL_BLDNUMBER, 0, 0, (LPBYTE)&osverinfo.dwBuildNumber, &dwSize);
        RegQueryValueEx(hKey, REGVAL_PLATFORMID, 0, 0, (LPBYTE)&osverinfo.dwPlatformId, &dwSize);
        int cchValueSize;
        (void) SafeRegQueryStringValueCch(hKey, REGVAL_SZCSDVER, osverinfo.szCSDVersion, ARRAYSIZE(osverinfo.szCSDVersion), &cchValueSize);

        RegCloseKey(hKey);
    }
#endif

    if ( VER_PLATFORM_WIN32_WINDOWS == osverinfo.dwPlatformId 
        || ( VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId && 5 > osverinfo.dwMajorVersion ) )
    {
        //
        // We're on a Win9x platform or NT < 5.0 (Win2K) - just copy OSVERSIONINFO
        //
        memcpy(&pIuPlatformInfo->osVersionInfoEx, &osverinfo, sizeof(OSVERSIONINFO));
        //
        // For Win9x platforms, remove redundant Major/Minor info from high word of build
        //
        if (VER_PLATFORM_WIN32_WINDOWS == osverinfo.dwPlatformId)
        {
            pIuPlatformInfo->osVersionInfoEx.dwBuildNumber = (0x0000FFFF & pIuPlatformInfo->osVersionInfoEx.dwBuildNumber);
        }
    }
    else
    {
        //
        //  We're on Win2K or greater, get and copy OSVERSIONINFOEX
        //
        OSVERSIONINFOEX osverinfoex;
        osverinfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        if ( !GetVersionEx((OSVERSIONINFO*)&osverinfoex) )
        {
            LOG_ErrorMsg(GetLastError());
            return HRESULT_FROM_WIN32(GetLastError());
        }
        memcpy(&pIuPlatformInfo->osVersionInfoEx, &osverinfoex, sizeof(OSVERSIONINFOEX));
    }
    //
    // Fill in the OEM BSTRs
    //
    if (FAILED(hr = GetOemBstrs(pIuPlatformInfo->bstrOEMManufacturer, pIuPlatformInfo->bstrOEMModel, pIuPlatformInfo->bstrOEMSupportURL)))
    {
        goto FreeBSTRsAndReturnError;
    }

    //
    // Fill in pIuPlatformInfo->fIsAdministrator
    //
    pIuPlatformInfo->fIsAdministrator = IsAdministrator();

    return S_OK;

FreeBSTRsAndReturnError:

    SafeSysFreeString(pIuPlatformInfo->bstrOEMManufacturer);
    SafeSysFreeString(pIuPlatformInfo->bstrOEMModel);
    SafeSysFreeString(pIuPlatformInfo->bstrOEMSupportURL);

    return hr;
}



static int atoh(LPCTSTR ptr)
{
    int     i = 0;

    //skip 0x if present
    if ( ptr[0] == '0' && (ptr[1] == 'x' || ptr[1] == 'X') )
        ptr += 2;

    for(;;) // until break
    {
        TCHAR ch = *ptr;

        if ('0' <= ch && ch <= '9')
            ch -= '0';
        else if ('a' <= ch && ch <= 'f')
            ch -= ('a' - 10);
        else if ('A' <= ch && ch <= 'F')
            ch -= ('A' - 10);
        else
            break;
        i = 16 * i + (int)ch;
        ptr++;
    }
    return i;
}


static int aton(LPCTSTR ptr)
{
    int i = 0;
    while ('0' <= *ptr && *ptr <= '9')
    {
        i = 10 * i + (int)(*ptr - '0');
        ptr ++;
    }
    return i;
}


static LANGID CorrectGetSystemDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95)
{
    LOG_Block("CorrectGetSystemDefaultLangID");
    LANGID langidMachine = LANGID_ENGLISH; // default is english 

    bIsNT4 = FALSE;
    bIsW95 = FALSE;
    
    TCHAR szMachineLCID[MAX_PATH];

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            //
            if (5 == osverinfo.dwMajorVersion)
            {
                // langidMachine = GetSystemDefaultLangID(); 
                typedef LANGID (WINAPI *PFN_GetSystemDefaultUILanguage)(void);

                //
                //kernel32.dll will  always be loaded in process
                //
                HMODULE hLibModule = GetModuleHandle(KERNEL32_DLL);
                if (hLibModule)
                {
                    PFN_GetSystemDefaultUILanguage fpnGetSystemDefaultUILanguage = 
                        (PFN_GetSystemDefaultUILanguage)GetProcAddress(hLibModule, "GetSystemDefaultUILanguage");
                    if (NULL != fpnGetSystemDefaultUILanguage)
                    { 
                        langidMachine = fpnGetSystemDefaultUILanguage();

                        if (0 == langidMachine)
                        {
                            LOG_Driver(_T("GetSystemDefaultUILanguage() returned 0, setting langidMachine back to LANGID_ENGLISH"));
                            langidMachine = LANGID_ENGLISH;
                        }
                    }
                
                }
            }
            else
            {
                // Get the OS lang from the registry to correct NT4 bug in
                // GetSystemDefaultLangID -- it returns the UI lang and 
                // the UI bits get installed (incorrect) as opposed to the actual OS
                // lang bits.
                HKEY hKey;
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, REGKEY_CP_INTERNATIONAL, 0, KEY_QUERY_VALUE, &hKey))
                {
                    int cchValueSize = ARRAYSIZE(szMachineLCID);
                    if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_LOCALE, szMachineLCID, cchValueSize, &cchValueSize)))
                    {
                        langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                    }
                    else
                    {
                        LOG_Driver(_T("Failed to get langid from \"Locale\" registry value - defaults to LANGID_ENGLISH"));
                    }
                    RegCloseKey(hKey);  
                }
                else
                {
                    LOG_Driver(_T("Failed to open \"HKCU\\.DEFAULT\\Control Panel\\International\" - defaults to LANGID_ENGLISH"));
                }
            }

            if (osverinfo.dwMajorVersion == 4) // NT 4
            {
                bIsNT4 = TRUE;
            }

        }
        else
        {
            //
            // hack around a problem introduced in Win95 and still existing
            // in Win98 whereby the System Langid is the same as the User Langid.
            // We must look in the registry to get the real value.
            //
            HKEY hKey;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_CP_RESOURCELOCAL, 0, KEY_QUERY_VALUE, &hKey))
            {
                int cchValueSize = ARRAYSIZE(szMachineLCID);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, NULL, szMachineLCID, cchValueSize, &cchValueSize))) 
                {
                    langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                }
                else
                {
                    LOG_Driver(_T("Failed to get (Default) from \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
                }
                RegCloseKey(hKey);
            }
            else
            {
                LOG_Driver(_T("Failed to open \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
            }


            if ((osverinfo.dwMajorVersion == 4) && (osverinfo.dwMinorVersion <= 0)) // Windows 95
            {
                bIsW95 = TRUE;
            }

        }
    }

    return langidMachine;
}

static LANGID CorrectGetUserDefaultLangID(BOOL& bIsNT4, BOOL& bIsW95)
{
    LOG_Block("CorrectGetUserDefaultLangID");
    LANGID langidMachine = LANGID_ENGLISH; // default is english 

    bIsNT4 = FALSE;
    bIsW95 = FALSE;
    TCHAR szMachineLCID[MAX_PATH];
    
    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            //
            // We shouldn't be using this function from NT, so just default to LANGID_ENGLISH
            // and log a message. This function will hopefully go away when we port to downlevel OS's
            //
            LOG_ErrorMsg(E_INVALIDARG);
        }
        else
        {
            //
            // hack around a problem introduced in Win95 and still existing
            // in Win98 whereby the System Langid is the same as the User Langid.
            // We must look in the registry to get the real value.
            //
            HKEY hKey;
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_CP_INTERNATIONAL, 0, KEY_QUERY_VALUE, &hKey))
            {
                int cchValueSize = ARRAYSIZE(szMachineLCID);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, NULL, szMachineLCID, cchValueSize, &cchValueSize)))
                {
                    langidMachine = LANGIDFROMLCID(atoh(szMachineLCID));
                }
                else
                {
                    LOG_Driver(_T("Failed to get (Default) from \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
                }
                RegCloseKey(hKey);
            }
            else
            {
                LOG_Driver(_T("Failed to open \"HKCU\\Control Panel\\Desktop\\ResourceLocale\" - defaults to LANGID_ENGLISH"));
            }


            if ((osverinfo.dwMajorVersion == 4) && (osverinfo.dwMinorVersion <= 0)) // Windows 95
            {
                bIsW95 = TRUE;
            }

        }
    }

    return langidMachine;
}


static WORD CorrectGetACP(void)
{
    LOG_Block("CorrectGetACP");
    WORD wCodePage = 0;
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szCodePage[MAX_PATH];
        int cchValueSize = ARRAYSIZE(szCodePage);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_ACP, szCodePage, cchValueSize, &cchValueSize)))
        {
            wCodePage = (WORD)aton(szCodePage);
        }
        else
        {
            LOG_Driver(_T("Failed SafeRegQueryStringValueCch in CorrectGetACP - defaulting to code page 0"));
        }
        RegCloseKey(hKey);
    }
    else
    {
        LOG_Driver(_T("Failed RegOpenKeyEx in CorrectGetACP - defaulting to code page 0"));
    }
    return wCodePage;
}


static WORD CorrectGetOEMCP(void)
{
    LOG_Block("CorrectGetOEMCP");
    WORD wCodePage = 0;
    HKEY hKey;
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_CODEPAGE, 0, KEY_QUERY_VALUE, &hKey))
    {
        TCHAR szCodePage[MAX_PATH];
        int cchValueSize = ARRAYSIZE(szCodePage);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, REGKEY_OEMCP, szCodePage, cchValueSize, &cchValueSize)))
        {
            wCodePage = (WORD)aton(szCodePage);
        }
        else
        {
            LOG_Driver(_T("Failed SafeRegQueryStringValueCch in CorrectGetOEMCP - defaulting to code page 0"));
        }
        RegCloseKey(hKey);
    }
    else
    {
        LOG_Driver(_T("Failed RegOpenKeyEx in CorrectGetOEMCP - defaulting to code page 0"));
    }
    return wCodePage;
}


static bool FIsNECMachine()
{
    LOG_Block("FIsNECMachine");
    bool fNEC = false;
    OSVERSIONINFO osverinfo;
    LONG lErr;

    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (GetVersionEx(&osverinfo))
    {
        if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            HKEY hKey;
            TCHAR tszMachineType[50];
            int cchValueSize;

            if (ERROR_SUCCESS == (lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 NT5_REGPATH_MACHTYPE,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey)))
            {
                cchValueSize = ARRAYSIZE(tszMachineType);
                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, 
                                        NT5_REGKEY_MACHTYPE, 
                                        tszMachineType,
                                        cchValueSize,
                                        &cchValueSize)))
                {
                    if (lstrcmp(tszMachineType, REGVAL_MACHTYPE_NEC) == 0)
                    {
                        fNEC = true;
                    }
                }
                else
                {
                    LOG_ErrorMsg(lErr);
                    LOG_Driver(_T("Failed SafeRegQueryStringValueCch in FIsNECMachine - defaulting to fNEC = false"));
                }

                RegCloseKey(hKey);
            }
            else
            {
                LOG_ErrorMsg(lErr);
                LOG_Driver(_T("Failed RegOpenKeyEx in FIsNECMachine - defaulting to fNEC = false"));
            }
        }
        else // enOSWin98
        {
            // All NEC machines have NEC keyboards for Win98.  NEC
            // machine detection is based on this.
            if (LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID)
            {
                fNEC = true;
            }
            else
            {
                LOG_Driver(_T("LOOKUP_OEMID(GetKeyboardType(1)) == PC98_KEYBOARD_ID was FALSE: defaulting to fNEC = false"));
            }
        }
    }
    
    return fNEC;
}

//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR GetIdentPlatformString(LPTSTR pszPlatformBuff, DWORD dwcBuffLen)
{
    
    HRESULT hr=S_OK;
    LOG_Block("GetIdentPlatformString");

    if (NULL == pszPlatformBuff || 1 > dwcBuffLen)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return pszPlatformBuff;
    }

    LPTSTR szOSNamePtr = (LPTSTR) SZ_PLAT_UNKNOWN;
    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osverinfo))
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS )
        {
            // ADD CHECK FOR NEPTUNE HERE!!!!!
            if ( osverinfo.dwMinorVersion >= 90) // Millenium
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WINME;
            }
            else if (osverinfo.dwMinorVersion > 0 && osverinfo.dwMinorVersion < 90) // Windows 98
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WIN98;
            }
            else  // Windows 95
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_WIN95;
            }
        }
        else // osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT 
        {
            if ( osverinfo.dwMajorVersion == 4 ) // NT 4
            {
                szOSNamePtr = (LPTSTR) SZ_PLAT_NT4;
            }
            else if (osverinfo.dwMajorVersion == 5) // NT 5 
            {
                if (0 == osverinfo.dwMinorVersion)
                {
                    szOSNamePtr = (LPTSTR) SZ_PLAT_W2K;
                }
                else if (1 <= osverinfo.dwMinorVersion)
                {
                    szOSNamePtr = (LPTSTR) SZ_PLAT_WHISTLER;
                }
            }
        }
    }

    if(lstrlen(szOSNamePtr) + 1 > (int) dwcBuffLen)
    {
        pszPlatformBuff[0] = 0;
    }
    else
    {
        

        //The length is validated  above. So this function cannot possibly fail
        hr=StringCchCopyEx(pszPlatformBuff,dwcBuffLen,szOSNamePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);
        if(FAILED(hr))
            pszPlatformBuff[0] = 0;
    }
    return pszPlatformBuff;
}

//
// GetIdentLocaleString and related functions ported from Drizzle Utils
//

/////////////////////////////////////////////////////////////////////////////
// DistinguishGreekOSs
//   Append additional code to distinguish the Greek OS version.
//
// Parameters:
//   pszISOCodeOut-
//       Greek-specific ISO code is appended to this parameter.
/////////////////////////////////////////////////////////////////////////////

void DistinguishGreekOSs(const TCHAR*& pszISOCodeOut /* out */)
{
    LOG_Block("DistinguishGreekOSs");
    //
    // Default ISO code to Greek OS (MS).
    //

    pszISOCodeOut = ISOCODE_GREEK_MS;

    
    //
    // Determine from the registry which version of Greek OS. There are
    // two versions of the Greek OS.
    //

    HKEY hKey;
    DWORD type;
    TCHAR tszOSType[50];
    int cchValueSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGPATH_CODEPAGE,
                     0,
                     KEY_QUERY_VALUE,
                     &hKey) == ERROR_SUCCESS)
    {
        cchValueSize = ARRAYSIZE(tszOSType);
        if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, 
                            REGKEY_OEMCP, 
                            tszOSType,
                            cchValueSize,
                            &cchValueSize)))
        {
            if (0 == lstrcmp(tszOSType, REGVAL_GREEK_IBM))
            {
                // Greek2
                pszISOCodeOut = ISOCODE_GREEK_IBM;
            }
        }

        RegCloseKey(hKey);
    }

}

/////////////////////////////////////////////////////////////////////////////
// HandleExceptionCases
//   Take care of a few exception cases (i.e. Greek OS).
//
// Parameters:
//   langidMachine-
//       Contains a language id for the current OS.
//
//   pszISOCode-
//       Points to a valid language id string for the current OS.
/////////////////////////////////////////////////////////////////////////////

inline void HandleExceptionCases(const LANGID& langidMachine,   /* in  */
                                 const TCHAR*& pszISOCode       /* out */)
{
    LOG_Block("HandleExceptionCases");

    // NEC machines are treated as having their own langid.
    // See if we have a Japanese machine, then check if it
    // is NEC.
    

    if (LANGID_JAPANESE == langidMachine)
    {

        if (FIsNECMachine())
        {
            pszISOCode = ISOCODE_NEC;
        }

        return;
    }
    

    
    // Windows 98 has two versions of Greek OS distinguished
    // only by a key in the registry.
        
    if(LANGID_GREEK == langidMachine)
    {
        OSVERSIONINFO osverinfo;
        osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (! GetVersionEx(&osverinfo))
        {
            return;
        }
        if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
        {
            if (osverinfo.dwMinorVersion > 0) 
            {
                DistinguishGreekOSs(pszISOCode);
            }
            return;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// langidCorrectGetSystemDefaultLangID
//   Make this return what GetSystemDefaultLangID should have returned
//   under Win98.
//
// Parameters:
//
// Comments :
/////////////////////////////////////////////////////////////////////////////

LANGID langidCorrectGetSystemDefaultLangID(void)
{
    LOG_Block("langidCorrectGetSystemDefaultLangID");

    LANGID langidMachine = LANGID_ENGLISH; // default is english 
    OSVERSIONINFO osverinfo;


    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            langidMachine = GetSystemDefaultLangID(); 
        }
        else
        {
            //  hack around a problem introduced in Win95 and still existing
            //  in Win98 whereby the System Langid is the same as the User Langid.
            //  We must look in the registry to get the real value.
            
            HKEY hKey;

            // determine if we should log transmissions
            if ( RegOpenKeyEx(  HKEY_CURRENT_USER,
                                 Win98_REGPATH_MACHLCID,
                                 0,
                                 KEY_QUERY_VALUE,
                                 &hKey) == ERROR_SUCCESS )
            {
                TCHAR tszMachineLCID[MAX_PATH];
                int cchValueSize = ARRAYSIZE(tszMachineLCID);

                if (SUCCEEDED(SafeRegQueryStringValueCch(hKey, NULL, tszMachineLCID, cchValueSize, &cchValueSize))
					|| SUCCEEDED(StringCchCopyEx(tszMachineLCID,ARRAYSIZE(tszMachineLCID),_T("00000409"),NULL,NULL,MISTSAFE_STRING_FLAGS)))
				{
					// Now convert to hexadecimal.
					langidMachine = LANGIDFROMLCID(atoh(tszMachineLCID));
				}

                RegCloseKey(hKey);
            }
        }
    }

    return langidMachine;
}

//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR GetIdentLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen)
{
    LOG_Block("GetIdentLocaleString");
    HRESULT hr=S_OK;

    if (NULL == pszISOCode || 1 > dwcBuffLen)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return pszISOCode;
    }
    // if we don't find any matching machine langids, we go to the english page.
    LPTSTR pszISOCodePtr = ISOCODE_EN;

    // First get the system and user LCID.
    LANGID langidMachine = langidCorrectGetSystemDefaultLangID();

    // First, locate the machine langid in the table.
    for ( int iMachine = 0; iMachine < cLangids; iMachine++ )
    {
        if ( grLangids[iMachine].langidMachine == langidMachine )
        {
            // set the default langid in case we don't find a matching user langid.
            pszISOCodePtr = grLangids[iMachine].pszDefaultISOCode;

            // Found the machine langid, now lookup the user langid
            if ( grLangids[iMachine].cElems != 0 )
            {
                LANGID langidUser = GetUserDefaultLangID();

                // We check for specific user langids
                for ( int iUser = 0; iUser < grLangids[iMachine].cElems; iUser++ )
                {
                    if ( grLangids[iMachine].grLangidUser[iUser].langidUser == langidUser )
                    {
                        pszISOCodePtr = grLangids[iMachine].grLangidUser[iUser].pszISOCode;
                        break;
                    }
                }
            }
            break;
        }
    }

    // Take care of a few exceptions.
//  HandleExceptionCases(langidMachine, pszISOCodePtr);

    if(lstrlen(pszISOCodePtr) + 1 > (int) dwcBuffLen)
    {
        pszISOCode[0] = 0;
    }
    else
    {

        
        hr=StringCchCopyEx(pszISOCode,dwcBuffLen,pszISOCodePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);

        //cannot possibly fail since  length is already validated
        if(FAILED(hr))
        {
            pszISOCode[0] = 0;
        }
    }

    return pszISOCode;
}


BOOL LookupLocaleStringFromLCID(LCID lcid, LPTSTR pszISOCode, DWORD cchISOCode)
{
    LOG_Block("LookupLocaleStringFromLCID");

    TCHAR   szCountry[MAX_PATH];
    BOOL    fRet = FALSE;

    if (GetLocaleInfo(lcid, LOCALE_SISO639LANGNAME,
                      pszISOCode, cchISOCode) == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }

    szCountry[0] = _T('-');
    
    if (GetLocaleInfo(lcid, LOCALE_SISO3166CTRYNAME,
                      szCountry + 1, ARRAYSIZE(szCountry) - 1) == FALSE)
    {
        LOG_ErrorMsg(GetLastError());
        goto done;
    }
    else
    {
        HRESULT hr;
        
        hr = StringCchCatEx(pszISOCode, cchISOCode, szCountry,
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            LOG_ErrorMsg(hr);
            pszISOCode[0] = _T('\0');
            goto done;
        }
    }

    fRet = TRUE;

done:
    return fRet;
}


//
// NOTES:   If you pass in a NULL pointer you'll get it right back.
//          dwcBuffLen is in characters, not bytes.
//
LPTSTR LookupLocaleString(LPTSTR pszISOCode, DWORD dwcBuffLen, BOOL fIsUser)
{
    LOG_Block("LookupLocaleString");

    TCHAR szCtryName[MAX_PATH];
    LANGID langid = 0;
    LCID lcid = 0;
    PFN_GetUserDefaultUILanguage pfnGetUserDefaultUILanguage = NULL;
    PFN_GetSystemDefaultUILanguage pfnGetSystemDefaultUILanguage = NULL;
    HMODULE hModule = NULL;
    HRESULT hr=S_OK;

    if (NULL == pszISOCode)
    {
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        return NULL;
    }
    //
    // If we hit an error, return a "Error" string
    //
    const TCHAR szError[] = _T("Error");

    if (lstrlen(szError) < (int) dwcBuffLen)
    {
        
        hr=StringCchCopyEx(pszISOCode,dwcBuffLen,szError,NULL,NULL,MISTSAFE_STRING_FLAGS);

        //This should not ideally happen
        if(FAILED(hr))
        {
            LOG_ErrorMsg(HRESULT_CODE(hr));
            pszISOCode[0] = 0;
            goto CleanUp;
        }

    }
    else
    {
        pszISOCode[0] = 0;
    }

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ( GetVersionEx(&osverinfo) )
    {
        if ( osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT && 5 <= osverinfo.dwMajorVersion)
        {
            //
            // Windows 2000 and greater (Windows XP)
            //
            //kernel32.dll will  always be loaded in process
            //

            hModule = GetModuleHandle(KERNEL32_DLL);
            if (NULL == hModule)
            {
                LOG_ErrorMsg(GetLastError());
                goto CleanUp;
            }

            if (TRUE == fIsUser)
            {
                //
                // We want the MUI language rather than the LOCALE_USER_DEFAULT and we are >= Win2k
                //
                pfnGetUserDefaultUILanguage = (PFN_GetUserDefaultUILanguage) GetProcAddress(hModule, "GetUserDefaultUILanguage");
                if (NULL == pfnGetUserDefaultUILanguage)
                {
                    LOG_ErrorMsg(GetLastError());
                    goto CleanUp;
                }

                langid = pfnGetUserDefaultUILanguage();
                if (0 == langid)
                {
                    LOG_ErrorMsg(E_FAIL);
                    goto CleanUp;
                }

                lcid = MAKELCID(langid, SORT_DEFAULT);
            }
            else
            {
                pfnGetSystemDefaultUILanguage = (PFN_GetSystemDefaultUILanguage) GetProcAddress(hModule, "GetSystemDefaultUILanguage");
                if (NULL == pfnGetSystemDefaultUILanguage)
                {
                    LOG_ErrorMsg(GetLastError());
                    goto CleanUp;
                }

                langid = pfnGetSystemDefaultUILanguage();
                if (0 == langid)
                {
                    LOG_ErrorMsg(E_FAIL);
                    goto CleanUp;
                }

                lcid = MAKELCID(langid, SORT_DEFAULT);
            }

            if (FALSE == fIsUser && FIsNECMachine())
            {
                //
                // 523660 Website is not distinguishing the JA_NEC and JA machine types
                //
                // For context="OS", special case NEC machines and just return "nec" for <language/>
                //
                lstrcpyn(pszISOCode, _T("nec"), (int) dwcBuffLen);
            }
            else
            {
                // don't check for error return because the previous code didn't
                LookupLocaleStringFromLCID(lcid, pszISOCode, dwcBuffLen);
            }

        }
        else
        {
            //
            // Use methods ported from V3 to get local strings
            //

            // if we don't find any matching machine langids, we go to the english page.
            LPTSTR pszISOCodePtr = ISOCODE_EN;

            // First get the system or user LCID.
            LANGID langidMachine = fIsUser ? GetUserLangID() : GetSystemLangID();
            
            // First, locate the machine langid in the table.
            for ( int iMachine = 0; iMachine < cLangids; iMachine++ )
            {
                if ( grLangids[iMachine].langidMachine == langidMachine )
                {
                    // set the default langid in case we don't find a matching user langid.
                    pszISOCodePtr = grLangids[iMachine].pszDefaultISOCode;

                    // Found the machine langid, now lookup the user langid
                    if ( grLangids[iMachine].cElems != 0 )
                    {
                        LANGID langidUser = fIsUser ? GetUserDefaultLangID() : GetSystemDefaultLangID();

                        // We check for specific user langids
                        for ( int iUser = 0; iUser < grLangids[iMachine].cElems; iUser++ )
                        {
                            if ( grLangids[iMachine].grLangidUser[iUser].langidUser == langidUser )
                            {
                                pszISOCodePtr = grLangids[iMachine].grLangidUser[iUser].pszISOCode;
                                break;
                            }
                        }
                    }
                    break;
                }
            }

            // Take care of a few exceptions.
            // HandleExceptionCases(langidMachine, pszISOCodePtr);

            if(lstrlen(pszISOCodePtr) < (int) dwcBuffLen)
            {
                
                hr=StringCchCopyEx(pszISOCode,dwcBuffLen,pszISOCodePtr,NULL,NULL,MISTSAFE_STRING_FLAGS);
                if(FAILED(hr))
                {
                    LOG_ErrorMsg(HRESULT_CODE(hr));
                    pszISOCode[0] = 0;
                    goto CleanUp;

                }
            }
        }
    }
    else
    {
        LOG_ErrorMsg(GetLastError());
    }

CleanUp:
    return pszISOCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\dlcache.cpp ===
/********************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    pcache.cpp

Revision History:
    DerekM  created  11/26/01

********************************************************************/

#if defined(UNICODE)

#include <windows.h>
#include "dlcache.h"
#include <strsafe.h>
#include <mistsafe.h>

// **************************************************************************
inline 
DWORD RolloverSubtract(DWORD dwA, DWORD dwB)
{
    return (dwA >= dwB) ? (dwA - dwB) : (dwA + ((DWORD)-1 - dwB));
}

// **************************************************************************
CWUDLProxyCache::CWUDLProxyCache()
{
    m_rgpObj  = NULL;
}

// **************************************************************************
CWUDLProxyCache::~CWUDLProxyCache()
{
    this->Empty();
}

// **************************************************************************
SWUDLProxyCacheObj *CWUDLProxyCache::internalFind(LPCWSTR wszSrv)
{
    SWUDLProxyCacheObj   *pObj = m_rgpObj;
    SWUDLProxyCacheObj   **ppNextPtr = &m_rgpObj;
    
    // see if it exists
    while(pObj != NULL)
    {
        if (pObj->wszSrv != NULL && _wcsicmp(pObj->wszSrv, wszSrv) == 0)
        {
            // detach it from the list
            *ppNextPtr  = pObj->pNext;
            pObj->pNext = NULL; 
            break;
        }

        ppNextPtr = &pObj->pNext;
        pObj      = pObj->pNext;
    }

    return pObj;    
}

// **************************************************************************
BOOL CWUDLProxyCache::Set(LPCWSTR wszSrv, LPCWSTR wszProxy, LPCWSTR wszBypass, 
                          DWORD dwAccessType)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    DWORD               cbProxy = 0, cbBypass = 0, cbSrv, cbNeed;
    BOOL                fRet = FALSE;

    if (wszSrv == NULL || *wszSrv == L'\0')
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    cbSrv  = (wcslen(wszSrv) + 1) * sizeof(WCHAR);
    cbNeed = cbSrv + sizeof(SWUDLProxyCacheObj);

    if (wszProxy != NULL)
    {
        cbProxy = (wcslen(wszProxy) + 1) * sizeof(WCHAR);
        cbNeed  += cbProxy;
        
        if (wszBypass != NULL)
        {
            cbBypass = (wcslen(wszBypass) + 1) * sizeof(WCHAR);
            cbNeed   += cbBypass;
        }
    }    


    // Now, in theory, we should look for an existing object in the list for this
    //  server, but a couple things make it unnecessary:
    //  1. we only use this class in one place
    //  2. we will always attempt a find first
    //  3. we will only get to this function if find returns NULL
    //  4. if one exists, but it's outdated, find will delete it and return NULL
    // 
    // Given the above, there should never be an existing object when Set is
    //  called.

    pObj = (SWUDLProxyCacheObj *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                                           cbNeed);
    if (pObj == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // set up pointers into the blob for the strings & copy the data down
    pObj->wszSrv = (LPWSTR)((LPBYTE)pObj + sizeof(SWUDLProxyCacheObj));
    hr = StringCbCopyExW(pObj->wszSrv, cbSrv, wszSrv, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
    {
        SetLastError(HRESULT_CODE(hr));
        goto done;
    }

    if (wszProxy != NULL)
    {
        pObj->wszProxy  = (LPWSTR)((LPBYTE)pObj->wszSrv + cbSrv);
        hr = StringCbCopyExW(pObj->wszProxy, cbProxy, wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
        
        if (wszBypass != NULL)
        {
            pObj->wszBypass = (LPWSTR)((LPBYTE)pObj->wszProxy + cbProxy);
            hr = StringCbCopyExW(pObj->wszBypass, cbBypass, wszBypass, 
                                 NULL, NULL, MISTSAFE_STRING_FLAGS);
            if (FAILED(hr))
            {
                SetLastError(HRESULT_CODE(hr));
                goto done;
            }
        }
    }

    
    pObj->dwLastCacheTime = GetTickCount();
    pObj->dwAccessType    = dwAccessType;
    pObj->cbBypass        = cbBypass;
    pObj->cbProxy         = cbProxy;
    pObj->iLastKnownGood  = (DWORD)-1;
    
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;
    pObj        = NULL;

    fRet = TRUE;

done:
    if (pObj != NULL)
        HeapFree(GetProcessHeap(), 0, pObj);
    
    return fRet;
}

// **************************************************************************
BOOL CWUDLProxyCache::Find(LPCWSTR wszSrv, LPWSTR *pwszProxy, LPWSTR *pwszBypass, 
                           DWORD *pdwAccessType)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    LPWSTR              wszProxy = NULL;
    LPWSTR              wszBypass = NULL;
    DWORD               dwNow;
    BOOL                fRet = FALSE, fFreeObjMemory = FALSE;
    
    if (wszSrv == NULL || pwszProxy == NULL || pwszBypass == NULL || 
        pdwAccessType == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pdwAccessType  = 0;
    *pwszBypass     = NULL;
    *pwszProxy      = NULL;

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
        goto done;

    // has the object expired?
    dwNow = GetTickCount();
    if (RolloverSubtract(dwNow, pObj->dwLastCacheTime) > c_dwProxyCacheTimeLimit)
    {
        fFreeObjMemory = TRUE;
        goto done;
    }

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;


    // need to use GloablAlloc here cuz that's what WinHttp uses and we need 
    //  to match it
    if (pObj->cbBypass > 0 && pObj->wszBypass != NULL)
    {
        wszBypass = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbBypass);
        if (wszBypass == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }

        hr = StringCbCopyExW(wszBypass, pObj->cbBypass, pObj->wszBypass, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    if (pObj->cbProxy > 0 && pObj->wszProxy != NULL)
    {
        wszProxy = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbProxy);
        if (wszProxy == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszProxy, pObj->cbProxy, pObj->wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    *pdwAccessType  = pObj->dwAccessType;
    *pwszBypass     = wszBypass;
    *pwszProxy      = wszProxy;

    wszBypass       = NULL;
    wszProxy        = NULL;
    pObj            = NULL;

    fRet = TRUE;
    
done:
    if (fFreeObjMemory && pObj != NULL)
        HeapFree(GetProcessHeap(), 0, pObj);
    if (wszProxy != NULL)
        GlobalFree(wszProxy);
    if (wszBypass != NULL)
        GlobalFree(wszBypass);
    
    return fRet;    
}

// **************************************************************************
BOOL CWUDLProxyCache::SetLastGoodProxy(LPCWSTR wszSrv, DWORD iProxy)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    BOOL                fRet = FALSE;

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
        goto done;

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;

    pObj->iLastKnownGood = iProxy;

    fRet = TRUE;

done:
    return fRet;
}

// **************************************************************************
BOOL CWUDLProxyCache::GetLastGoodProxy(LPCWSTR wszSrv, SAUProxySettings *paups)
{
    SWUDLProxyCacheObj  *pObj = NULL;
    HRESULT             hr = NOERROR;
    LPWSTR              wszBypass = NULL, wszProxy = NULL;
    BOOL                fRet = FALSE;

    if (wszSrv == NULL || paups == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    // does it exist?
    pObj = this->internalFind(wszSrv);
    if (pObj == NULL)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        goto done;
    }

    // reset object to front of list
    pObj->pNext = m_rgpObj;
    m_rgpObj    = pObj;

    // need to use GloablAlloc here cuz that's what WinHttp uses and we need 
    //  to match it
    if (pObj->cbBypass > 0 && pObj->wszBypass != NULL)
    {
        wszBypass = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbBypass);
        if (wszBypass == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszBypass, pObj->cbBypass, pObj->wszBypass, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    if (pObj->cbProxy > 0 && pObj->wszProxy != NULL)
    {
        wszProxy = (LPWSTR)GlobalAlloc(GMEM_FIXED, pObj->cbProxy);
        if (wszProxy == NULL)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            goto done;
        }
        
        hr = StringCbCopyExW(wszProxy, pObj->cbProxy, pObj->wszProxy, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
        {
            SetLastError(HRESULT_CODE(hr));
            goto done;
        }
    }

    ZeroMemory(paups, sizeof(SAUProxySettings));

    paups->dwAccessType = pObj->dwAccessType;
    paups->wszBypass    = wszBypass;
    paups->wszProxyOrig = wszProxy;
    paups->iProxy       = pObj->iLastKnownGood;

    wszBypass       = NULL;
    wszProxy        = NULL;

    fRet = TRUE;
    
done:
    if (wszProxy != NULL)
        GlobalFree(wszProxy);
    if (wszBypass != NULL)
        GlobalFree(wszBypass);
    
    return fRet;    


    
}

// **************************************************************************
BOOL CWUDLProxyCache::Empty(void)
{
    SWUDLProxyCacheObj  *pObj = m_rgpObj;

    while (pObj != NULL)
    {
        m_rgpObj = pObj->pNext;
        HeapFree(GetProcessHeap(), 0, pObj);
        pObj = m_rgpObj;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\detect\osdetutl.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   osdetutl.cpp
//
//  Description:
//
//      Additional OS detection utility routines for:
//			* Returning free drive space
//			* Returning "Administrator" flag
//
//=======================================================================

#include <windows.h>
#include <oleauto.h>
#include <wuiutest.h>
#include <tchar.h>
#include <osdet.h>
#include <logging.h>
#include <iucommon.h>
#include <stdio.h>	// for _i64tot

// #define __IUENGINE_USES_ATL_
#if defined(__IUENGINE_USES_ATL_)
#include <atlbase.h>
#define USES_IU_CONVERSION USES_CONVERSION
#else
#include <MemUtil.h>
#endif

typedef BOOL (WINAPI * PFN_GetDiskFreeSpaceEx) (LPTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

const TCHAR REGPATH_AU[]			= _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU");
const TCHAR REGKEY_AU_OPTIONS[]		= _T("NoAutoUpdate");
const TCHAR REGPATH_EXPLORER[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
const TCHAR REGKEY_WINUPD_DISABLED[] = _T("NoWindowsUpdate");
const TCHAR REGPATH_POLICY_USERACCESS_DISABLED[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\WindowsUpdate");
const TCHAR REGKEY_WU_USERACCESS_DISABLED[] = _T("DisableWindowsUpdateAccess");


HRESULT GetLocalFixedDriveInfo(DWORD* pdwNumDrives, PPIU_DRIVEINFO ppDriveInfo)
{
	USES_IU_CONVERSION;
	LOG_Block("GetLocalFixedDriveInfo");

	DWORD dwNumCharacters = 0;
	LPTSTR pszDriveStrBuffer = NULL;
	HRESULT hr = E_FAIL;
	LPTSTR pszRootPathName;

	if (NULL == pdwNumDrives || ppDriveInfo == NULL)
	{
		LOG_Error(_T("E_INVALIDARG"));
		return E_INVALIDARG;
	}

	*ppDriveInfo = NULL;
	*pdwNumDrives = 0;

	//
	// kernel32.dll is loaded into all processes, so we don't need to LoadLibrary, but need to look for W or A versions
	//
	PFN_GetDiskFreeSpaceEx pfnGetDiskFreeSpaceEx;
#if defined(UNICODE) || defined (_UNICODE)
	pfnGetDiskFreeSpaceEx = (PFN_GetDiskFreeSpaceEx) GetProcAddress( GetModuleHandle(L"kernel32.dll"), "GetDiskFreeSpaceExW");
#else
	pfnGetDiskFreeSpaceEx = (PFN_GetDiskFreeSpaceEx) GetProcAddress( GetModuleHandle("kernel32.dll"), "GetDiskFreeSpaceExA");
#endif
	if (NULL == pfnGetDiskFreeSpaceEx)
	{
		//
		// This could fail on Win95 Gold, but we don't support that anyway
		//
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//
	// Handle corner case of race issue when new drives are hot-plugged between the first
	// and second calls to GetLogicalDriveStrings and the buffer requirements increase
	//
	for (;;)
	{
		if (0 == (dwNumCharacters = GetLogicalDriveStrings(0, NULL)))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		//
		// Add space for terminating NULL
		//
		dwNumCharacters += 1;

		CleanUpFailedAllocSetHrMsg(pszDriveStrBuffer = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNumCharacters * sizeof(TCHAR)));

		DWORD dwRet = GetLogicalDriveStrings(dwNumCharacters, pszDriveStrBuffer);
		if (0 == dwRet)
		{
			//
			// Unknown error - we gotta bail
			//
			Win32MsgSetHrGotoCleanup(GetLastError());
		}
		else if (dwRet > dwNumCharacters)
		{
			//
			// Someone plugged in a new drive, get the new buffer space requirements and try again
			//
			SafeHeapFree(pszDriveStrBuffer);
			continue;
		}
		//
		// GetLogicalDriveStrings succeeded, break and continue
		//
		break;
	}

	//
	// Count the number of fixed drives while building the return array of IU_DRIVEINFO
	//
	for (pszRootPathName = pszDriveStrBuffer; NULL != *pszRootPathName; pszRootPathName += lstrlen(pszRootPathName) + 1)
	{
		//
		// Only return sizes for fixed drives
		//
		if (DRIVE_FIXED == GetDriveType(pszRootPathName))
		{
			//
			// Make sure pszRootPathName is of the form "<drive letter>:\" by checking for ':' in second position
			//
			if (_T(':') != pszRootPathName[1])
			{
				LOG_Error(_T("Root paths must be of form \"<drive letter>:\\\""));
				SetHrAndGotoCleanUp(E_FAIL);
			}

			ULARGE_INTEGER i64FreeBytesAvailable;
			ULARGE_INTEGER i64TotalBytes;
			ULARGE_INTEGER i64TotalFreeBytes;
			BOOL fResult;

			//
			// Get the free space
			//
			fResult = pfnGetDiskFreeSpaceEx(pszRootPathName,
											&i64FreeBytesAvailable,
											&i64TotalBytes,
											&i64TotalFreeBytes);

			// Process GetDiskFreeSpaceEx results.
			if (!fResult)
			{
				LOG_Driver(_T("GetDiskFreeSpaceEx(%s, ...) returned an error. We will not report space for this drive"), \
					pszRootPathName);
				LOG_ErrorMsg(GetLastError());
			}
			else
			{
				//
				// We return KiloBytes
				//
				i64FreeBytesAvailable.QuadPart /= 1024;
				
				if (NULL == *ppDriveInfo)
				{
					//
					// Allocate one IU_DRIVEINFO struct
					//
					CleanUpFailedAllocSetHrMsg(*ppDriveInfo = (PIU_DRIVEINFO) HeapAlloc(GetProcessHeap(), 0, sizeof(IU_DRIVEINFO)));
				}
				else
				{
					//
					// Realloc buffer so we can append
					//
					PIU_DRIVEINFO pDriveInfoTemp;
					if (NULL == (pDriveInfoTemp = (PIU_DRIVEINFO) HeapReAlloc(GetProcessHeap(), 0, *ppDriveInfo, ((*pdwNumDrives)+1) * sizeof(IU_DRIVEINFO))))
					{
						LOG_Error(_T("E_OUTOFMEMORY"));
						SetHrAndGotoCleanUp(E_OUTOFMEMORY);
						// Note: *ppDriveInfo still points to previously allocated memory
					}
					*ppDriveInfo = pDriveInfoTemp; // in case it was moved
				}
				//
				// First copy the drive letter
				//
				lstrcpyn(((&(*ppDriveInfo)[*pdwNumDrives]))->szDriveStr, pszRootPathName, 4);
				//
				// Next copy the bytes, but truncate to MAXLONG 
				//
				((&(*ppDriveInfo)[*pdwNumDrives]))->iKBytes = (i64FreeBytesAvailable.QuadPart > 0x000000007FFFFFFF) ? MAXLONG : (INT) i64FreeBytesAvailable.QuadPart;
				//
				// increment drive count
				//
				(*pdwNumDrives)++;
				}
		}
	}

	hr = S_OK;

CleanUp:

	SafeHeapFree(pszDriveStrBuffer);

	if (FAILED(hr))
	{
		SafeHeapFree(*ppDriveInfo);
		*pdwNumDrives = 0;
	}

	return hr;
}

//
// Code adapted from MSDN SearchTokenGroupsForSID since CheckTokenMembership is Win2K only
//
BOOL IsAdministrator(void)
{
	LOG_Block("IsAdministrator");
	return (GetLogonGroupInfo() & IU_SECURITY_MASK_ADMINS);
}

DWORD GetLogonGroupInfo(void)
{
	DWORD dwRet = 0x0;
	LOG_Block("GetLogonGroupInfo");
	DWORD dwSize = 0;
	DWORD i = 0;
	HANDLE hToken = INVALID_HANDLE_VALUE;
	PTOKEN_GROUPS pGroupInfo = NULL;
	PSID pAdminSID = NULL, pPowerUsrSID = NULL;
	SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
	HRESULT hr;	// so we can use CleanUpXxxxx macros

	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (GetVersionEx(&osvi))
	{
		if (VER_PLATFORM_WIN32_NT != osvi.dwPlatformId)
		{
			LOG_Driver(_T("Platform isn't VER_PLATFORM_WIN32_NT - returning TRUE by default"));
			dwRet = IU_SECURITY_MASK_ADMINS | IU_SECURITY_MAST_POWERUSERS;
			LOG_Out(_T("Non NT system, return TRUE for all groups"));
			goto CleanUp;
		}
	}
	else
	{
		LOG_Error(_T("GetVersionEx:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	//
	// Open a handle to the access token for the calling process.
	//
	if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
	{
		LOG_Error(_T("OpenProcessToken:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Call GetTokenInformation to get the buffer size.

	if (!GetTokenInformation(hToken, TokenGroups, NULL, dwSize, &dwSize))
	{
		DWORD dwResult = GetLastError();
		if( dwResult != ERROR_INSUFFICIENT_BUFFER )
		{
			LOG_Error(_T("GetTokenInformation:"));
			Win32MsgSetHrGotoCleanup(dwResult);
		}
	}

	// Allocate the buffer.

	if (NULL == (pGroupInfo = (PTOKEN_GROUPS) HeapAlloc(GetProcessHeap(), 0, dwSize)))
	{
		LOG_Error(_T("HeapAlloc"));
		goto CleanUp;
	}

	// Call GetTokenInformation again to get the group information.

	if (! GetTokenInformation(hToken, TokenGroups, pGroupInfo, 
							dwSize, &dwSize ) )
	{
		LOG_Error(_T("GetTokenInformation:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Create a SID for the BUILTIN\Administrators group.

	if (! AllocateAndInitializeSid( &SIDAuth, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_ADMINS,
					 0, 0, 0, 0, 0, 0,
					 &pAdminSID) )
	{
		LOG_Error(_T("AllocateAndInitializeSid:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	if (! AllocateAndInitializeSid( &SIDAuth, 2,
					 SECURITY_BUILTIN_DOMAIN_RID,
					 DOMAIN_ALIAS_RID_POWER_USERS,
					 0, 0, 0, 0, 0, 0,
					 &pPowerUsrSID) )
	{
		LOG_Error(_T("AllocateAndInitializeSid:"));
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	// Loop through the group SIDs looking for the administrator SID.
	
	for(i = 0; i < pGroupInfo->GroupCount; i++)
	{
		if (EqualSid(pAdminSID, pGroupInfo->Groups[i].Sid) && 
			(pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
		{
			dwRet |= IU_SECURITY_MASK_ADMINS;
		}
		if (EqualSid(pPowerUsrSID, pGroupInfo->Groups[i].Sid) && 
			(pGroupInfo->Groups[i].Attributes & SE_GROUP_ENABLED))
		{
			dwRet |= IU_SECURITY_MAST_POWERUSERS;
		}
	}

CleanUp:

	if (pAdminSID)
	{
		FreeSid(pAdminSID);
	}
	if (pPowerUsrSID)
	{
		FreeSid(pPowerUsrSID);
	}

	SafeHeapFree(pGroupInfo);

	if (INVALID_HANDLE_VALUE != hToken)
	{
		CloseHandle(hToken);
	}

	LOG_Out(_T("Return 0x%08x"), dwRet);

	return dwRet;
}

// ----------------------------------------------------------------------------------
//
// Returns:
//		1	If the NoWindowsUpdate value exists and is != 0 under
//			HKEY_CURRENT_USER for NT or HKEY_LOCAL_MACHINE for Win9x.
//		0	If the NoWindowsUpdate value exists and is zero.
//	   -1	If the NoWindowsUpdate value doesn't exist. 
//
// ----------------------------------------------------------------------------------
int IsWindowsUpdateDisabled(void)
{
	LOG_Block("IsWindowsUpdateDisabled");

	int nRet = -1;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;
	HKEY hkeyRoot;
	OSVERSIONINFO	versionInformation;

	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);

	if (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hkeyRoot = HKEY_CURRENT_USER;
	}
	else
	{
		hkeyRoot = HKEY_LOCAL_MACHINE;
	}

	if ( RegOpenKeyEx(	hkeyRoot,
						REGPATH_EXPLORER,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WINUPD_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled == 0) )
			{
				nRet = 0;
			}
			else
			{
				nRet = 1;
			}
		}

		RegCloseKey(hKey);
	}

	LOG_Out(_T("Return: %d"), nRet);
	return nRet;
}

// ----------------------------------------------------------------------------------
//
// Returns:
//		1	If the DisableWindowsUpdateAccess value exists and is != 0 under
//			HKEY_CURRENT_USER for NT or HKEY_LOCAL_MACHINE for Win9x.
//		0	If the DisableWindowsUpdateAccess value exists and is zero.
//	   -1	If the DisableWindowsUpdateAccess value doesn't exist. 
//
// ----------------------------------------------------------------------------------
int IsWindowsUpdateUserAccessDisabled(void)
{
	LOG_Block("IsWindowsUpdateUserAccessDisabled");

	int nRet = -1;
	HKEY hKey;
	DWORD dwDisabled;
	DWORD dwSize = sizeof(dwDisabled);
	DWORD dwType;
	HKEY hkeyRoot;
	OSVERSIONINFO	versionInformation;

	versionInformation.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&versionInformation);

	if (versionInformation.dwPlatformId == VER_PLATFORM_WIN32_NT)
	{
		hkeyRoot = HKEY_CURRENT_USER;
	}
	else
	{
		hkeyRoot = HKEY_LOCAL_MACHINE;
	}

	if ( RegOpenKeyEx(	hkeyRoot,
						REGPATH_POLICY_USERACCESS_DISABLED,
						NULL,
						KEY_QUERY_VALUE,
						&hKey) == ERROR_SUCCESS )
	{
		if ( RegQueryValueEx(hKey,
							REGKEY_WU_USERACCESS_DISABLED,
							NULL,
							&dwType,
							(LPBYTE)&dwDisabled,
							&dwSize) == ERROR_SUCCESS )
		{
			if ( (dwType == REG_DWORD) && (dwDisabled == 0) )
			{
				nRet = 0;
			}
			else
			{
				nRet = 1;
			}
		}

		RegCloseKey(hKey);
	}

	LOG_Out(_T("Return: %d"), nRet);

	if (1 == nRet)
	{
		LogMessage("Access to Windows Update has been disabled by administrative policy");
	}

	return nRet;
}

//
// Returns 1 for enabled, 0 for disabled, and -1 for unknown/default (registry doesn't exist)
//
int IsAutoUpdateEnabled(void)
{
	LOG_Block("IsAutoUpdateEnabled");

	HKEY	hSubKey;
	DWORD	dwType;
	ULONG	nLen;
	DWORD	dwAUOptions;
	int		nRet = -1;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGPATH_AU, 0, KEY_READ, &hSubKey))	
	{
		nLen = sizeof(dwAUOptions);
		if (ERROR_SUCCESS == RegQueryValueEx(hSubKey, REGKEY_AU_OPTIONS, NULL, &dwType, (LPBYTE)&dwAUOptions, &nLen))
		{
			//
			// 1 is disabled, 2 & 3 are enabled
			//
			nRet = (1 == dwAUOptions ? 0 : 1);
		}	
		RegCloseKey(hSubKey);	
	}
	else
	{
		LOG_Error(_T("RegOpenKeyEx failed - returning -1"));
	}

	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\dlutil.h ===
/******************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name:
    dlutil.h

Abstract:
    header for download library

******************************************************************************/

#ifndef DLUTIL_H
#define DLUTIL_H

#include <strsafe.h>
#include <wusafefn.h>
#include <mistsafe.h>

///////////////////////////////////////////////////////////////////////////////
// const defines & typedefs

#define UNLEN 256

// need to define this here cuz winhttp.h doesn't define it and we get dupe 
//  definitions if we try to include wininet.h just to get it.
#ifndef INTERNET_MAX_URL_LENGTH
#define INTERNET_MAX_URL_LENGTH  2200
#endif

const DWORD c_cbDownloadBuffer      = 32 * 1024; // 32k
const DWORD c_cbDownloadBufferLite  = 4 * 1024;  // 4k

const DWORD c_dwRetryTimeLimitInmsWinHttp  = 2 * 60 * 1000; // 120s (2m)
const DWORD c_dwRetryTimeLimitInmsWiuInet  = 10 * 1000;       // 10s
const DWORD c_cMaxRetries           = 3;

const WCHAR c_wszUserAgent[]        = L"Industry Update Control";
const char  c_szUserAgent[]         = "Industry Update Control";

const DWORD c_cchMaxURLSize         = INTERNET_MAX_URL_LENGTH;

#ifdef UNICODE
#define c_tszUserAgent c_wszUserAgent
#else
#define c_tszUserAgent c_szUserAgent
#endif

typedef BOOL (__stdcall *pfn_ReadDataFromSite)(HINTERNET, LPVOID, DWORD, LPDWORD);


///////////////////////////////////////////////////////////////////////////////
// macro defines

#define sizeofSTRW(wsz) (sizeof(wsz) / sizeof(WCHAR))
#define sizeofSTRA(sz)  (sizeof(sz))
#define sizeofSTRT(sz)  (sizeof(sz) / sizeof(TCHAR))


///////////////////////////////////////////////////////////////////////////////
// necessary classes

class CAutoCritSec
{
private:
#if defined(DEBUG) || defined(DBG)
    DWORD               m_dwOwningThread;
    DWORD               m_cLocks;
#endif

    CRITICAL_SECTION    m_cs;
    BOOL                m_fInit;

public:
    CAutoCritSec(void)
    {
        m_fInit = WUInitializeCriticalSectionAndSpinCount(&m_cs, 0x8000FA0);
#if defined(DEBUG) || defined(DBG)
        m_cLocks         = 0;
        m_dwOwningThread = 0;
#endif
    }

    ~CAutoCritSec(void)
    {
#if defined(DEBUG) || defined(DBG)
        if (m_cLocks > 0 || m_dwOwningThread != 0)
        {
            // can't do logging here cuz this could be run during DllMain
        }
#endif
        if (m_fInit)
            DeleteCriticalSection(&m_cs);
    }

    BOOL Lock(void)
    {
        LOG_Block("CAutoCritSec::Lock()");
        
        if (m_fInit)
        {
            EnterCriticalSection(&m_cs);
#if defined(DEBUG) || defined(DBG)
            m_cLocks++;
            m_dwOwningThread = GetCurrentThreadId();
#endif
        }
        else
        {
            LOG_Internet(_T("CAutoCritSec not initialized during Lock."));
        }

        return m_fInit;
    }

    BOOL Unlock(void)
    {
        LOG_Block("CAutoCritSec::Unlock()");

        if (m_fInit)
        {
#if defined(DEBUG) || defined(DBG)
            if (m_cLocks == 0)
                LOG_Internet(_T("CAutoCritSec: trying to unlock when lock count is 0"));
            else
                m_cLocks--;

            if (m_dwOwningThread != GetCurrentThreadId())
            {
                LOG_Internet(_T("CAutoCritSec: lock not owned by current thread: Owning thread: %d. Current thread: %d"), 
                             m_dwOwningThread, GetCurrentThreadId());
            }
            
            if (m_cLocks == 0)
                m_dwOwningThread = 0;
#endif        
            LeaveCriticalSection(&m_cs);
        }
        else
        {
            LOG_Internet(_T("CAutoCritSec not initialized during Unlock."));
        }

        return m_fInit;
    }
};


///////////////////////////////////////////////////////////////////////////////
// prototypes

BOOL IsServerFileDifferentW(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                           LPCWSTR wszLocalFile);
BOOL IsServerFileDifferentA(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                           LPCSTR szLocalFile);
#ifdef UNICODE
#define IsServerFileDifferent  IsServerFileDifferentW
#else
#define IsServerFileDifferent  IsServerFileDifferentA
#endif // !UNICODE


HRESULT PerformDownloadToFile(pfn_ReadDataFromSite pfnRead,
                              HINTERNET hRequest, 
                              HANDLE hFile, DWORD cbFile,
                              DWORD cbBuffer,
                              HANDLE *rghEvents, DWORD cEvents,
                              PFNDownloadCallback fpnCallback, LPVOID pCallbackData,
                              DWORD *pcbDownloaded);


HRESULT StartWinInetDownload(HMODULE hmodWinInet,
                             LPCTSTR pszServerUrl, 
                             LPCTSTR pszLocalPath,
                             DWORD *pdwDownloadedBytes,
                             HANDLE *hQuitEvents,
                             UINT nQuitEventCount,
                             PFNDownloadCallback fpnCallback,
                             LPVOID pCallbackData,
                             DWORD dwFlags,
                             DWORD cbDownloadBuffer);

HRESULT IsFileHtml(LPCTSTR pszFileName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\install\install.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   install.cpp
//
//  Description:
//
//      Functions called to install Active Setup/Windows Installer/and Custom Installer
//      type components.
//
//=======================================================================

#include <windows.h>
#include <iucommon.h>
#include <tchar.h>
#include <shlwapi.h>
#include <install.h>
#include <advpub.h>
#include <memutil.h>
#include <fileutil.h>
#include <WaitUtil.h>
#include <strsafe.h>
#include <wusafefn.h>

typedef struct 
{
    char  szInfname[MAX_PATH];
    char  szSection[MAX_PATH];
    char  szDir[MAX_PATH];
    char  szCab[MAX_PATH];
    DWORD dwFlags;
    DWORD dwType;
} INF_ARGUMENTS;

DWORD WINAPI LaunchInfCommand(void *p);

HRESULT InstallSoftwareItem(LPTSTR pszInstallSourcePath, BOOL fRebootRequired, LONG lNumberOfCommands,
                      PINSTALLCOMMANDINFO pCommandInfoArray, DWORD *pdwStatus)
{
    LOG_Block("InstallASItem");

    HRESULT hr = S_OK;
    TCHAR szCommand[MAX_PATH+1]; // sourcepath + commandname from INSTALLCOMMANDINFO array
    TCHAR szCommandTemp[MAX_PATH+1]; // temporary buffer used to wrap the command line in quotes for CreateProcess
    TCHAR szDecompressFile[MAX_PATH];
    WIN32_FIND_DATA fd;
    HANDLE hProc;
    HANDLE hFind;
    BOOL fMore;
    LONG lCnt;
    DWORD dwRet;
    DWORD dwThreadId;

    USES_IU_CONVERSION;

    if ((NULL == pszInstallSourcePath) || (NULL == pCommandInfoArray) || (0 == lNumberOfCommands) || (NULL == pdwStatus))
    {
        hr = E_INVALIDARG;
        hr = LOG_ErrorMsg(hr);
        return hr;
    }

    *pdwStatus = ITEM_STATUS_FAILED; // default to failed in case no commands match known installers

    // Need to enumerate all .CAB files in the Install Source Path and Decompress them
    // before executing commands.
    hr = PathCchCombine(szCommand, ARRAYSIZE(szCommand), pszInstallSourcePath, _T("*.cab"));
    if (FAILED(hr)) {
        LOG_ErrorMsg(hr);
        return hr;
    }
    hFind = FindFirstFile(szCommand, &fd);
    fMore = (INVALID_HANDLE_VALUE != hFind);
    while (fMore)
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        {
            hr = PathCchCombine(szDecompressFile, ARRAYSIZE(szDecompressFile), pszInstallSourcePath, fd.cFileName);
            if (FAILED(hr)) 
            {
                LOG_ErrorMsg(hr);
            } else {
                if (!IUExtractFiles(szDecompressFile, pszInstallSourcePath))
                {
                    LOG_Software(_T("Failed to Decompress file %s"), szDecompressFile);
                    // ISSUE: do we abort this item?, or try the install anyway?
                }
            }
        }
        fMore = FindNextFile(hFind, &fd);
    }

    if (INVALID_HANDLE_VALUE != hFind)
    {
        FindClose(hFind);
    }

    for (lCnt = 0; lCnt < lNumberOfCommands; lCnt++)
    {
        // the szCommand variable is used to launch a process (msi or exe installer), but because of 
        // oddities in the CreateProcess API's handling of the commandline parameter we need to wrap
        // the command line in quotes.
        hr = SafePathCombine(szCommandTemp, ARRAYSIZE(szCommandTemp), pszInstallSourcePath, pCommandInfoArray[lCnt].szCommandLine, SPC_FILE_MUST_EXIST);
        if (SUCCEEDED(hr))
            hr = StringCchPrintf(szCommand, ARRAYSIZE(szCommand), _T("\"%s\""), szCommandTemp);
        if (FAILED(hr))
        {
            LOG_ErrorMsg(hr);
            return hr;
        }

        switch (pCommandInfoArray[lCnt].iCommandType)
        {
        case COMMANDTYPE_INF:
        case COMMANDTYPE_ADVANCEDINF:
            {
                // Call INF Installer Passing Commandline and Parameters (if any)
                INF_ARGUMENTS infArgs;
                infArgs.dwType = pCommandInfoArray[lCnt].iCommandType;

                hr = StringCchCopyA(infArgs.szInfname, ARRAYSIZE(infArgs.szInfname), 
                            T2A(pCommandInfoArray[lCnt].szCommandLine));
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szSection, ARRAYSIZE(infArgs.szSection), ""); // use default
                     
                }
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szDir, ARRAYSIZE(infArgs.szDir), T2A(pszInstallSourcePath));
                }
                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopyA(infArgs.szCab, ARRAYSIZE(infArgs.szCab), "");
                }
                if (FAILED(hr)) {
                    LOG_ErrorMsg(hr);
                    break;
                }

                infArgs.dwFlags = StrToInt(pCommandInfoArray[lCnt].szCommandParameters);
                
                LOG_Software(_T("Launching Inf - inf: %hs, section: %hs"), infArgs.szInfname, lstrlenA(infArgs.szSection) ? infArgs.szSection : "Default");

                hr = E_FAIL; // default INF result to E_FAIL.. if GetExitCodeThread fails so did the install

                hProc = CreateThread(NULL, 0, LaunchInfCommand, &infArgs, 0, &dwThreadId);
                if (NULL != hProc)
                {
                    WaitAndPumpMessages(1, &hProc, QS_ALLINPUT);
                    if (GetExitCodeThread(hProc, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Error(_T("Inf Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Thread Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(hProc);
                break;
            }
        case COMMANDTYPE_EXE:
            {
                // Call EXE Installer Passing Commandline and Parameters (if any)
                STARTUPINFO startInfo;
                PROCESS_INFORMATION processInfo;
                ZeroMemory(&startInfo, sizeof(startInfo));
                startInfo.cb = sizeof(startInfo);
                startInfo.dwFlags |= STARTF_USESHOWWINDOW;
                startInfo.wShowWindow = SW_SHOWNORMAL;

                if (NULL != pCommandInfoArray[lCnt].szCommandParameters)
                {
                    hr = StringCchCat(szCommand, ARRAYSIZE(szCommand), _T(" "));
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                    hr = StringCchCat(szCommand, ARRAYSIZE(szCommand), pCommandInfoArray[lCnt].szCommandParameters);
                    if (FAILED(hr))
                    {
                        LOG_ErrorMsg(hr);
                        break;
                    }
                }

                if (CreateProcess(NULL, szCommand, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pszInstallSourcePath, &startInfo, &processInfo))
                {
                    CloseHandle(processInfo.hThread);
                    hr = S_OK; // Default EXE result to S_OK, if GetExitCodeProcess fails result was unknown assume success
                    WaitAndPumpMessages(1, &processInfo.hProcess, QS_ALLINPUT);
                    if (GetExitCodeProcess(processInfo.hProcess, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Software(_T("EXE Install Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Process Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(processInfo.hProcess);
                break;
            }
        case COMMANDTYPE_MSI:
            {
                // Call MSI Installer Passing MSI Package and Parameters (if any)
                STARTUPINFO startInfo;
                PROCESS_INFORMATION processInfo;
                ZeroMemory(&startInfo, sizeof(startInfo));
                startInfo.cb = sizeof(startInfo);
                startInfo.dwFlags |= STARTF_USESHOWWINDOW;
                startInfo.wShowWindow = SW_SHOWNORMAL;

                // The MSI Installer is run a little differently than a normal EXE package. The command line in
                // CommandInfo Array will actually be the MSI package name. We are going to form a new set of
                // parameters to include the MSI package name and command line will be MSIEXEC.

                TCHAR szCommandLine[MAX_PATH];
                hr = StringCchPrintf( szCommandLine, ARRAYSIZE(szCommandLine), 
                         _T("msiexec.exe /i %s %s"), 
                         pCommandInfoArray[lCnt].szCommandLine, 
                         pCommandInfoArray[lCnt].szCommandParameters );
                if (FAILED(hr)) 
                {
                    LOG_ErrorMsg(hr);
                    break;
                }
                
                if (CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, pszInstallSourcePath, &startInfo, &processInfo))
                {
                    CloseHandle(processInfo.hThread);
                    hr = E_FAIL; // Default MSI install result to Error
                    WaitAndPumpMessages(1, &processInfo.hProcess, QS_ALLINPUT);
                    if (GetExitCodeProcess(processInfo.hProcess, &dwRet))
                    {
                        hr = HRESULT_FROM_WIN32(dwRet);
                        if (SUCCEEDED(hr) || hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                        {
                            *pdwStatus = ITEM_STATUS_SUCCESS;
                            if (hr == HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED))
                            {
                                hr = S_OK;
                                *pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
                            }
                        }
                        else
                        {
                            LOG_Software(_T("MSI Install Failed - return code %x"), hr);
                        }
                    }
                    else
                    {
                        LOG_Software(_T("Failed to get Install Process Exit Code"));
                    }
                }
                else
                {
                    hr = GetLastError();
                    LOG_ErrorMsg(hr);
                }
                CloseHandle(processInfo.hProcess);
                break;
            }
        case COMMANDTYPE_CUSTOM:
            LOG_Software(_T("Custom Install Command Type Not Implemented Yet"));
            break;
        default:
            LOG_Software(_T("Unknown Command Type, No Install Action"));
            break;
        }
    }

    return hr;
}


DWORD WINAPI LaunchInfCommand(void *p)
{
    HRESULT hr = S_OK;

    INF_ARGUMENTS *pinfArgs = (INF_ARGUMENTS *)p;

    if(pinfArgs->dwType == COMMANDTYPE_ADVANCEDINF)
    {
        CABINFO cabinfo;
        cabinfo.pszCab = pinfArgs->szCab;
        cabinfo.pszInf = pinfArgs->szInfname;
        cabinfo.pszSection = pinfArgs->szSection;

        // cabinfo.szSrcPath is a char[MAXPATH] in the CABINFO struct
        StringCchCopyA(cabinfo.szSrcPath, ARRAYSIZE(cabinfo.szSrcPath), pinfArgs->szDir);
        cabinfo.dwFlags = pinfArgs->dwFlags;

        hr = ExecuteCab(NULL, &cabinfo, 0);
    }
    else
    {
        hr = RunSetupCommand(NULL, pinfArgs->szInfname,
                   lstrlenA(pinfArgs->szSection) ? pinfArgs->szSection : NULL,
                   pinfArgs->szDir, NULL, NULL, pinfArgs->dwFlags, NULL );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\dlhttp.cpp ===
#include <windows.h>
#include <winhttp.h>
#include <shlwapi.h>
#include <logging.h>
#include "iucommon.h"
#include "download.h"
#include "dllite.h"
#include "dlutil.h"
#include "malloc.h"

#include "trust.h"
#include "fileutil.h"
#include "dlcache.h"
#include "wusafefn.h"

///////////////////////////////////////////////////////////////////////////////
// typedefs


// winhttp
extern "C"
{
typedef BOOL      (WINAPI *pfn_WinHttpCrackUrl)(LPCWSTR, DWORD, DWORD, LPURL_COMPONENTS);
typedef HINTERNET (WINAPI *pfn_WinHttpOpen)(LPCWSTR, DWORD, LPCWSTR, LPCWSTR, DWORD);
typedef HINTERNET (WINAPI *pfn_WinHttpConnect)(HINTERNET, LPCWSTR, INTERNET_PORT, DWORD);
typedef HINTERNET (WINAPI *pfn_WinHttpOpenRequest)(HINTERNET, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR FAR *, DWORD);
typedef BOOL      (WINAPI *pfn_WinHttpSendRequest)(HINTERNET, LPCWSTR, DWORD, LPVOID, DWORD, DWORD, DWORD_PTR);
typedef BOOL      (WINAPI *pfn_WinHttpReceiveResponse)(HINTERNET, LPVOID);
typedef BOOL      (WINAPI *pfn_WinHttpQueryHeaders)(HINTERNET, DWORD, LPCWSTR, LPVOID, LPDWORD, LPDWORD);
typedef BOOL      (WINAPI *pfn_WinHttpReadData)(HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (WINAPI *pfn_WinHttpCloseHandle)(HINTERNET);
typedef BOOL      (WINAPI *pfn_WinHttpGetIEProxyConfigForCurrentUser)(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG *);
typedef BOOL      (WINAPI *pfn_WinHttpGetProxyForUrl)(HINTERNET, LPCWSTR, WINHTTP_AUTOPROXY_OPTIONS *, WINHTTP_PROXY_INFO *);
typedef BOOL      (WINAPI *pfn_WinHttpSetOption)(HINTERNET, DWORD, LPVOID, DWORD);
}

struct SWinHTTPFunctions
{
    pfn_WinHttpGetIEProxyConfigForCurrentUser   pfnWinHttpGetIEProxyConfigForCurrentUser;
    pfn_WinHttpGetProxyForUrl   pfnWinHttpGetProxyForUrl;
    pfn_WinHttpCrackUrl         pfnWinHttpCrackUrl;
    pfn_WinHttpOpen             pfnWinHttpOpen;
    pfn_WinHttpConnect          pfnWinHttpConnect;
    pfn_WinHttpOpenRequest      pfnWinHttpOpenRequest;
    pfn_WinHttpSendRequest      pfnWinHttpSendRequest;
    pfn_WinHttpReceiveResponse  pfnWinHttpReceiveResponse;
    pfn_WinHttpQueryHeaders     pfnWinHttpQueryHeaders;
    pfn_WinHttpReadData         pfnWinHttpReadData;
    pfn_WinHttpCloseHandle      pfnWinHttpCloseHandle;
    pfn_WinHttpSetOption        pfnWinHttpSetOption;
    HMODULE                     hmod;
};

typedef struct tagSAUProxyInfo
{
    WINHTTP_PROXY_INFO  ProxyInfo;
    LPWSTR              wszProxyOrig;
    LPWSTR              *rgwszProxies;
    DWORD               cProxies;
    DWORD               iProxy;
} SAUProxyInfo;

typedef enum tagETransportUsed
{
    etuNone = 0,
    etuWinHttp,
    etuWinInet,
} ETransportUsed;

#define SafeWinHTTPCloseHandle(sfns, x) if (NULL != x) { (*sfns.pfnWinHttpCloseHandle)(x); x = NULL; }
#define StringOrConstW(wsz, wszConst) (((wsz) != NULL) ? (wsz) : (wszConst))


///////////////////////////////////////////////////////////////////////////////
// globals

#if defined(UNICODE)

CWUDLProxyCache g_wudlProxyCache;
CAutoCritSec    g_csCache;

#endif

HMODULE         g_hmodWinHttp = NULL;
HMODULE         g_hmodWinInet = NULL;

///////////////////////////////////////////////////////////////////////////////
// utility functions

// **************************************************************************
static
LPTSTR MakeFullLocalFilePath(LPCTSTR szUrl, 
                             LPCTSTR szFileName, 
                             LPCTSTR szPath)
{
    LOG_Block("MakeFullLocalFilePath()");

    HRESULT hr = NOERROR;
    LPTSTR  pszRet, pszFileNameToUse = NULL, pszQuery = NULL;
    LPTSTR  pszFullPath = NULL;
    DWORD   cchFile;
    TCHAR   chTemp = _T('\0');

    // if we got a local filename passed to us, use it.
    if (szFileName != NULL)
    {
        pszFileNameToUse = (LPTSTR)szFileName;
    } 

    // otherwise, parse the filename out of the URL & use it instead
    else
    {
        // first get a pointer to the querystring, if any
        pszQuery = _tcschr(szUrl, _T('?'));

        // next, find the last slash before the start of the querystring
        pszFileNameToUse = StrRChr(szUrl, pszQuery, _T('/'));

        // if we don't have a filename at this point, we can't continue
        //  cuz there's nowhere to download the file to.
        if (pszFileNameToUse == NULL)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto done;
        }
        
        pszFileNameToUse++;

        // temporarily NULL out the first character of the querystring, if
        //  we have a querystring.  This makes the end of the filename the
        //  end of the string.
        if (pszQuery != NULL)
        {
            chTemp = *pszQuery;
            *pszQuery  = _T('\0');
        }
    }

    // add 2 for a possible backslash & the null terminator
    cchFile = 2 + _tcslen(szPath) + _tcslen(pszFileNameToUse);

    pszFullPath = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, cchFile * sizeof(TCHAR));
    if (pszFullPath == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        if (pszQuery != NULL)
            *pszQuery = chTemp;
        goto done;
    }

    // construct the path
    hr = SafePathCombine(pszFullPath, cchFile, szPath, pszFileNameToUse, 0);

    // if we nuked the first character of the querystring, restore it.
    if (pszQuery != NULL)
        *pszQuery = chTemp;

    if (FAILED(hr))
    {
		SetLastError(HRESULT_CODE(hr));
		SafeHeapFree(pszFullPath);
		goto done;
    }

done:
    return pszFullPath;
}

// **************************************************************************
static
ETransportUsed LoadTransportDll(SWinHTTPFunctions *psfns, HMODULE *phmod, 
                                  DWORD dwFlags)
{
    LOG_Block("LoadTransportDll()");

    ETransportUsed  etu = etuNone;
    HMODULE hmod = NULL;
    HRESULT hr = NOERROR;
    BOOL    fAllowWininet;
    BOOL    fAllowWinhttp;
    BOOL    fPersistTrans = ((dwFlags & WUDF_PERSISTTRANSPORTDLL) != 0);

    if (psfns == NULL || phmod == NULL || 
        (dwFlags & WUDF_TRANSPORTMASK) == WUDF_TRANSPORTMASK)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    dwFlags = GetAllowedDownloadTransport(dwFlags);
    fAllowWininet = ((dwFlags & WUDF_ALLOWWINHTTPONLY) == 0);
    fAllowWinhttp = ((dwFlags & WUDF_ALLOWWININETONLY) == 0);

    ZeroMemory(psfns, sizeof(SWinHTTPFunctions));
    *phmod = NULL;

    // first try to load the winhttp dll
    if (fAllowWinhttp)
    {
        if (g_hmodWinHttp == NULL)
        {
            hmod = LoadLibraryFromSystemDir(c_szWinHttpDll);
            
            if (hmod != NULL && fPersistTrans && 
                InterlockedCompareExchangePointer((LPVOID *)&g_hmodWinHttp,
                                                  hmod, NULL) != NULL)
            {
                FreeLibrary(hmod);
                hmod = g_hmodWinHttp;
            }
        }
        else
        {
            hmod = g_hmodWinHttp;
        }
    }
    if (hmod != NULL)
    {
        psfns->hmod                      = hmod;
        psfns->pfnWinHttpGetProxyForUrl  = (pfn_WinHttpGetProxyForUrl)GetProcAddress(hmod, "WinHttpGetProxyForUrl");
        psfns->pfnWinHttpCrackUrl        = (pfn_WinHttpCrackUrl)GetProcAddress(hmod, "WinHttpCrackUrl");
        psfns->pfnWinHttpOpen            = (pfn_WinHttpOpen)GetProcAddress(hmod, "WinHttpOpen");
        psfns->pfnWinHttpConnect         = (pfn_WinHttpConnect)GetProcAddress(hmod, "WinHttpConnect");
        psfns->pfnWinHttpOpenRequest     = (pfn_WinHttpOpenRequest)GetProcAddress(hmod, "WinHttpOpenRequest");
        psfns->pfnWinHttpSendRequest     = (pfn_WinHttpSendRequest)GetProcAddress(hmod, "WinHttpSendRequest");
        psfns->pfnWinHttpReceiveResponse = (pfn_WinHttpReceiveResponse)GetProcAddress(hmod, "WinHttpReceiveResponse");
        psfns->pfnWinHttpQueryHeaders    = (pfn_WinHttpQueryHeaders)GetProcAddress(hmod, "WinHttpQueryHeaders");
        psfns->pfnWinHttpReadData        = (pfn_WinHttpReadData)GetProcAddress(hmod, "WinHttpReadData");
        psfns->pfnWinHttpCloseHandle     = (pfn_WinHttpCloseHandle)GetProcAddress(hmod, "WinHttpCloseHandle");
        psfns->pfnWinHttpSetOption       = (pfn_WinHttpSetOption)GetProcAddress(hmod, "WinHttpSetOption");
        psfns->pfnWinHttpGetIEProxyConfigForCurrentUser = (pfn_WinHttpGetIEProxyConfigForCurrentUser)GetProcAddress(hmod, "WinHttpGetIEProxyConfigForCurrentUser");
        if (psfns->pfnWinHttpCrackUrl == NULL || 
            psfns->pfnWinHttpOpen == NULL ||
            psfns->pfnWinHttpConnect == NULL || 
            psfns->pfnWinHttpOpenRequest == NULL ||
            psfns->pfnWinHttpSendRequest == NULL || 
            psfns->pfnWinHttpReceiveResponse == NULL ||
            psfns->pfnWinHttpQueryHeaders == NULL || 
            psfns->pfnWinHttpReadData == NULL ||
            psfns->pfnWinHttpCloseHandle == NULL || 
            psfns->pfnWinHttpGetProxyForUrl == NULL ||
            psfns->pfnWinHttpGetIEProxyConfigForCurrentUser == NULL || 
            psfns->pfnWinHttpSetOption == NULL)
        {
            // do this logging here cuz we'll try wininet afterward & we want
            //  to make sure to log this error as well
            LOG_ErrorMsg(ERROR_PROC_NOT_FOUND);
            SetLastError(ERROR_PROC_NOT_FOUND);
            
            ZeroMemory(psfns, sizeof(SWinHTTPFunctions));
            FreeLibrary(hmod);
            hmod = NULL;
        }
        else
        {
            LOG_Internet(_T("Successfully loaded WinHttp.dll"));
            
            etu     = etuWinHttp;
            *phmod  = hmod;
        }
    }

    // if hmod is NULL at this point, then try to fall back to wininet.  If
    //  that fails, we can only bail...
    if (fAllowWininet && hmod == NULL)
    {
        if (g_hmodWinInet == NULL)
        {
            hmod = LoadLibraryFromSystemDir(c_szWinInetDll);
            if (hmod == NULL)
                goto done;

            if (fPersistTrans &&
                InterlockedCompareExchangePointer((LPVOID *)&g_hmodWinInet, 
                                                  hmod, NULL) != NULL)
            {
                FreeLibrary(hmod);
                hmod = g_hmodWinInet;
            }
        }

        LOG_Internet(_T("Successfully loaded WinInet.dll (no functions yet)"));

        etu    = etuWinInet;
        *phmod = hmod;
    }

done:    
    return etu;
}

// **************************************************************************
static
BOOL UnloadTransportDll(SWinHTTPFunctions *psfns, HMODULE hmod)
{
    LOG_Block("UnloadTransportDll()");

    if (hmod != NULL && hmod != g_hmodWinHttp && hmod != g_hmodWinInet)
        FreeLibrary(hmod);

    if (psfns != NULL)
        ZeroMemory(psfns, sizeof(SWinHTTPFunctions));

    return TRUE;
}

// we only care about winhttp on unicode platforms!
#if defined(UNICODE)

// **************************************************************************
static
BOOL ProxyListToArray(LPWSTR wszProxy, LPWSTR **prgwszProxies, DWORD *pcProxies)
{
    LPWSTR  pwszProxy = wszProxy;
    LPWSTR  *rgwszProxies = NULL;
    DWORD   cProxies = 0, iProxy;
    BOOL    fRet = FALSE;

    if (prgwszProxies == NULL || pcProxies == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *prgwszProxies = NULL;
    *pcProxies     = 0;

    if (wszProxy == NULL || *wszProxy == L'\0')
        goto done;
    
    // walk the string & count how many proxies we have
    for(;;)
    {
        for(;
            *pwszProxy != L';' && *pwszProxy != L'\0';
            pwszProxy++);

        cProxies++;

        if (*pwszProxy == L'\0')
            break;
        else
            pwszProxy++;
    }

    // alloc an array to hold 'em
    rgwszProxies = (LPWSTR *)GlobalAlloc(GPTR, sizeof(LPWSTR) * cProxies);
    if (rgwszProxies == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    // fill the array
    pwszProxy = wszProxy;
    for(iProxy = 0; iProxy < cProxies; iProxy++)
    {
        rgwszProxies[iProxy] = pwszProxy;

        for(;
            *pwszProxy != L';' && *pwszProxy != L'\0';
            pwszProxy++);


        if (*pwszProxy == L'\0')
        {
            break;
        }
        else
        {
            *pwszProxy = L'\0';
            pwszProxy++;
        }
    }
        
    *prgwszProxies = rgwszProxies;
    *pcProxies     = cProxies;

    rgwszProxies   = NULL;

    fRet = TRUE;

done:
    if (rgwszProxies != NULL)
        GlobalFree(rgwszProxies);

    return fRet;    
}

// **************************************************************************
static
DWORD GetInitialProxyIndex(DWORD cProxies)
{
    SYSTEMTIME  st;
    DWORD       iProxy;

    GetSystemTime(&st);

    // this would be incredibly weird, but it's easy to deal with so do so
    if (st.wMilliseconds >= 1000)
        st.wMilliseconds = st.wMilliseconds % 1000;

    // so we don't have to use the crt random number generator, just fake it
    return (st.wMilliseconds * cProxies) / 1000;
}

// **************************************************************************
static
BOOL GetWinHTTPProxyInfo(SWinHTTPFunctions &sfns, BOOL fCacheResults,
                         HINTERNET hInternet, LPCWSTR wszURL, LPCWSTR wszSrv,
                         SAUProxyInfo *pAUProxyInfo)
{
    LOG_Block("GetWinHTTPProxyInfo()");

    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyCfg;
    WINHTTP_AUTOPROXY_OPTIONS               AutoProxyOpt;
    DWORD                                   dwErr = ERROR_SUCCESS;
    BOOL                                    fUseAutoProxy = FALSE;
    BOOL                                    fGotProxy = FALSE;
    BOOL                                    fRet = FALSE;
    
    ZeroMemory(&IEProxyCfg, sizeof(IEProxyCfg));
    ZeroMemory(&AutoProxyOpt, sizeof(AutoProxyOpt));

    // only need to acquire the CS if we're caching results
    if (fCacheResults)
        g_csCache.Lock();
    
    if (pAUProxyInfo == NULL || hInternet == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }
    
    ZeroMemory(pAUProxyInfo, sizeof(SAUProxyInfo));

    // if we're not caching results, skip directly to the proxy fetch
    if (fCacheResults && 
        g_wudlProxyCache.Find(wszSrv, &pAUProxyInfo->ProxyInfo.lpszProxy,
                              &pAUProxyInfo->ProxyInfo.lpszProxyBypass,
                              &pAUProxyInfo->ProxyInfo.dwAccessType))
    {
        LOG_Internet(_T("WinHttp: Cached proxy settings Proxy: %ls | Bypass: %ls | AccessType: %d"),
                     StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                     StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                     pAUProxyInfo->ProxyInfo.dwAccessType);

        pAUProxyInfo->wszProxyOrig = pAUProxyInfo->ProxyInfo.lpszProxy;

        // we'll deal with this function failing later on when we cycle thru
        //  the proxies.  We'll basically only use the first and never cycle
        if (ProxyListToArray(pAUProxyInfo->wszProxyOrig,
                             &pAUProxyInfo->rgwszProxies,
                             &pAUProxyInfo->cProxies))
        {
            DWORD iProxy;
            
            iProxy = GetInitialProxyIndex(pAUProxyInfo->cProxies);
            pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
            pAUProxyInfo->iProxy              = iProxy;
            
        }
        
        goto done;
    }
        
    // first try to get the current user's IE configuration
    fRet = (*sfns.pfnWinHttpGetIEProxyConfigForCurrentUser)(&IEProxyCfg);
    if (fRet)
    {
        LOG_Internet(_T("WinHttp: Read IE user proxy settings"));
        
        if (IEProxyCfg.fAutoDetect)
        {
            AutoProxyOpt.dwFlags           = WINHTTP_AUTOPROXY_AUTO_DETECT;
            AutoProxyOpt.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                             WINHTTP_AUTO_DETECT_TYPE_DNS_A;
            fUseAutoProxy = TRUE;
        }

        if (IEProxyCfg.lpszAutoConfigUrl != NULL)
        {
            AutoProxyOpt.dwFlags           |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOpt.lpszAutoConfigUrl = IEProxyCfg.lpszAutoConfigUrl;
            fUseAutoProxy = TRUE;
        }

        AutoProxyOpt.fAutoLogonIfChallenged = TRUE;
        
    }

    // couldn't get current user's config options, so just try autoproxy
    else 
    {
        AutoProxyOpt.dwFlags           = WINHTTP_AUTOPROXY_AUTO_DETECT;
        AutoProxyOpt.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                         WINHTTP_AUTO_DETECT_TYPE_DNS_A;
        AutoProxyOpt.fAutoLogonIfChallenged = TRUE;

        fUseAutoProxy = TRUE;
    }

    if (fUseAutoProxy)
    {
        LOG_Internet(_T("WinHttp: Doing autoproxy detection"));

        fGotProxy = (*sfns.pfnWinHttpGetProxyForUrl)(hInternet, wszURL, 
                                                     &AutoProxyOpt, 
                                                     &pAUProxyInfo->ProxyInfo);
    }

    // if we didn't try to autoconfigure the proxy or we did & it failed, then
    //  check and see if we had one defined by the user
    if ((fUseAutoProxy == FALSE || fGotProxy == FALSE) && 
        IEProxyCfg.lpszProxy != NULL)
    {
        // the empty string and L':' are not valid server names, so skip them
        //  if they are what is set for the proxy
        if (!(IEProxyCfg.lpszProxy[0] == L'\0' ||
              (IEProxyCfg.lpszProxy[0] == L':' && 
               IEProxyCfg.lpszProxy[1] == L'\0')))
        {
            pAUProxyInfo->ProxyInfo.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
            pAUProxyInfo->ProxyInfo.lpszProxy    = IEProxyCfg.lpszProxy;
            IEProxyCfg.lpszProxy                 = NULL;
        }
        
        // the empty string and L':' are not valid server names, so skip them
        //  if they are what is set for the proxy bypass
        if (IEProxyCfg.lpszProxyBypass != NULL && 
            !(IEProxyCfg.lpszProxyBypass[0] == L'\0' ||
              (IEProxyCfg.lpszProxyBypass[0] == L':' && 
               IEProxyCfg.lpszProxyBypass[1] == L'\0')))
        {
            pAUProxyInfo->ProxyInfo.lpszProxyBypass = IEProxyCfg.lpszProxyBypass;
            IEProxyCfg.lpszProxyBypass              = NULL;
        }
    }

    LOG_Internet(_T("WinHttp: Proxy settings Proxy: %ls | Bypass: %ls | AccessType: %d"),
                 StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                 StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                 pAUProxyInfo->ProxyInfo.dwAccessType);

    // don't really care if this fails.  It'll just mean a perf hit the next
    //  time we go fetch the proxy info
    if (fCacheResults &&
        g_wudlProxyCache.Set(wszSrv, pAUProxyInfo->ProxyInfo.lpszProxy,
                             pAUProxyInfo->ProxyInfo.lpszProxyBypass,
                             pAUProxyInfo->ProxyInfo.dwAccessType) == FALSE)
    {
        LOG_Internet(_T("WinHttp: Attempt to cache proxy info failed: %d"), 
                     GetLastError());
    }

    pAUProxyInfo->wszProxyOrig = pAUProxyInfo->ProxyInfo.lpszProxy;

    // we'll deal with this function failing later on when we cycle thru the
    //  proxies.  We'll basically only use the first and never cycle
    // Note that this function call has to be AFTER the cache call since we 
    //  modify the proxy list by embedding null terminators in it in place of
    //  the separating semicolons.
    if (ProxyListToArray(pAUProxyInfo->wszProxyOrig, &pAUProxyInfo->rgwszProxies,
                         &pAUProxyInfo->cProxies))
    {
        DWORD iProxy;
        
        iProxy = GetInitialProxyIndex(pAUProxyInfo->cProxies);
        pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
        pAUProxyInfo->iProxy              = iProxy;
        
    }

    fRet = TRUE;

done:
    // only need to release the CS if we're caching results
    if (fCacheResults)
        g_csCache.Unlock();
    
    dwErr = GetLastError();
    
    if (IEProxyCfg.lpszAutoConfigUrl != NULL)
        GlobalFree(IEProxyCfg.lpszAutoConfigUrl);
    if (IEProxyCfg.lpszProxy != NULL)
        GlobalFree(IEProxyCfg.lpszProxy);
    if (IEProxyCfg.lpszProxyBypass != NULL)
        GlobalFree(IEProxyCfg.lpszProxyBypass);

    SetLastError(dwErr);

    return fRet;
}

// **************************************************************************
static
HRESULT MakeRequest(SWinHTTPFunctions   &sfns,
                    HINTERNET hConnect, 
                    HINTERNET hRequest,
                    LPCWSTR wszSrv,
                    LPCWSTR wszVerb, 
                    LPCWSTR wszObject, 
                    SAUProxyInfo *pAUProxyInfo, 
                    HANDLE *rghEvents, 
                    DWORD cEvents, 
                    HINTERNET *phRequest)
{
    LOG_Block("MakeRequest()");

    HINTERNET   hOpenRequest = hRequest;
    LPCWSTR     wszAcceptTypes[] = {L"*/*", NULL};
    HRESULT     hr = S_OK;
    DWORD       iProxy = 0, dwErr;
    BOOL        fProxy, fContinue = TRUE;

    fProxy = (pAUProxyInfo != NULL && pAUProxyInfo->ProxyInfo.lpszProxy != NULL);

    LOG_Internet(_T("WinHttp: Making %ls request for %ls"), wszVerb, wszObject);

    // if we were passed in a request handle, then use it.  Otherwise, gotta 
    //  open one
    if (hOpenRequest == NULL)
    {
        hOpenRequest = (*sfns.pfnWinHttpOpenRequest)(hConnect, wszVerb, wszObject, 
                                                     NULL, NULL, wszAcceptTypes, 0);
        if (hOpenRequest == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }

    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }
    
    // if we have a list of proxies & the first one is bad, winhttp won't try
    //  any others.  So we have to do it ourselves.  That is the purpose of this 
    //  loop.
    if (fProxy && 
        pAUProxyInfo->cProxies > 1 && pAUProxyInfo->rgwszProxies != NULL)
        iProxy = (pAUProxyInfo->iProxy + 1) % pAUProxyInfo->cProxies;
    for(;;)
    {
        
       if (fProxy)
       {
            LOG_Internet(_T("WinHttp: Using proxy: Proxy: %ls | Bypass %ls | AccessType: %d"),
                         StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxy, L"(none)"),
                         StringOrConstW(pAUProxyInfo->ProxyInfo.lpszProxyBypass, L"(none)"),
                         pAUProxyInfo->ProxyInfo.dwAccessType);

            if ((*sfns.pfnWinHttpSetOption)(hOpenRequest, WINHTTP_OPTION_PROXY, 
                                            &pAUProxyInfo->ProxyInfo, 
                                            sizeof(WINHTTP_PROXY_INFO)) == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }
        }
        
        if ((*sfns.pfnWinHttpSendRequest)(hOpenRequest, NULL, 0, NULL, 0, 0, 0) == FALSE)
        {
//            dwErr = GetLastError();
//            LOG_Internet(_T("WinHttp: WinHttpSendRequest failed: %d.  Request object at: 0x%x"), 
//                         dwErr, hOpenRequest);
//            SetLastError(dwErr);

            goto loopDone;
        }
        
        if ((*sfns.pfnWinHttpReceiveResponse)(hOpenRequest, 0) == FALSE)
        {
//            dwErr = GetLastError();
//            LOG_Internet(_T("WinHttp: WinHttpReceiveResponse failed: %d.  Request object at: 0x%x"), 
//                         dwErr, hOpenRequest);
//            SetLastError(dwErr);

            goto loopDone;
        }

        hr = S_OK;
        SetLastError(ERROR_SUCCESS);

loopDone:
        fContinue = FALSE;
        dwErr = GetLastError();
        if (dwErr != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(dwErr);
        else
            hr = S_OK;

        // if we succeeded, then we're done here...
        if (SUCCEEDED(hr))
        {
            if (fProxy)
            {
                if (g_csCache.Lock() == FALSE)
                {
                    hr = E_FAIL;
                    goto done;
                }
                
                g_wudlProxyCache.SetLastGoodProxy(wszSrv, pAUProxyInfo->iProxy);
   
                // Unlock returns FALSE as well, but we should never get here cuz 
                //  we should not have been able to take the lock above.
                g_csCache.Unlock();
            }
            
            break;
        }
        
        LOG_ErrorMsg(hr);

        // we only care about retrying if we have a proxy server & get a 
        //  'cannot connect' error.
        if (fProxy && 
            (dwErr == ERROR_WINHTTP_CANNOT_CONNECT ||
             dwErr == ERROR_WINHTTP_CONNECTION_ERROR ||
             dwErr == ERROR_WINHTTP_NAME_NOT_RESOLVED ||
             dwErr == ERROR_WINHTTP_TIMEOUT))
        {
            LOG_Internet(_T("WinHttp: Connection failure: %d"), dwErr);
            if (pAUProxyInfo->cProxies > 1 && pAUProxyInfo->rgwszProxies != NULL && 
                iProxy != pAUProxyInfo->iProxy)
            {
                pAUProxyInfo->ProxyInfo.lpszProxy = pAUProxyInfo->rgwszProxies[iProxy];
                iProxy = (iProxy + 1) % pAUProxyInfo->cProxies;
                fContinue = TRUE;
            }
            else
            {
                LOG_Internet(_T("WinHttp: No proxies left.  Failing download."));
            }
        }

        if (fContinue == FALSE)
            goto done;
    }

    
    if (FAILED(hr))
        goto done;


    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }

    *phRequest   = hOpenRequest;
    hOpenRequest = NULL;
    
done:
    // don't want to free the handle if we didn't open it.
    if (hRequest != hOpenRequest)
        SafeWinHTTPCloseHandle(sfns, hOpenRequest);
    return hr;
}

// **************************************************************************
static
HRESULT CheckFileHeader(SWinHTTPFunctions   &sfns,
                        HINTERNET hOpenRequest, 
                        HANDLE *rghEvents, 
                        DWORD cEvents, 
                        LPCWSTR wszFile,
                        DWORD *pcbFile,
                        FILETIME *pft)
{
    LOG_Block("CheckFileHeader()");

    SYSTEMTIME  st;
    FILETIME    ft;
    HRESULT     hr = S_OK;
    DWORD       dwLength, dwStatus, dwFileSize, dwErr;

    dwLength = sizeof(st);
    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_LAST_MODIFIED | WINHTTP_QUERY_FLAG_SYSTEMTIME, 
                                       NULL, (LPVOID)&st, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(dwFileSize);
    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_CONTENT_LENGTH | WINHTTP_QUERY_FLAG_NUMBER, 
                                       NULL, (LPVOID)&dwFileSize, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }
    
    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto done;
    }

    if (pcbFile != NULL)
        *pcbFile = dwFileSize;
    if (pft != NULL)
        CopyMemory(pft, &ft, sizeof(FILETIME));

    hr = IsServerFileDifferentW(ft, dwFileSize, wszFile) ? S_OK : S_FALSE;

done:
    return hr;
}

// **************************************************************************
static
HRESULT GetContentTypeHeader(SWinHTTPFunctions &sfns,
                             HINTERNET hOpenRequest,
                             LPWSTR *pwszContentType)
{
    LOG_Block("GetContentTypeHeader()");

    HRESULT hr = S_OK;
    LPWSTR  wszContentType = NULL;
    DWORD   dwLength, dwErr;
    BOOL    fRet;

    *pwszContentType = NULL;

    dwLength = 0;
    fRet = (*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                          WINHTTP_QUERY_CONTENT_TYPE, 
                                          NULL, (LPVOID)NULL, &dwLength, 
                                          NULL);
    if (fRet == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (dwLength == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_WINHTTP_HEADER_NOT_FOUND);
        goto done;
    }

    wszContentType = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
                                       dwLength);
    if (wszContentType == NULL)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto done;
    }

    if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                       WINHTTP_QUERY_CONTENT_TYPE, 
                                       NULL, (LPVOID)wszContentType, &dwLength, 
                                       NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    *pwszContentType = wszContentType;
    wszContentType   = NULL;

done:
    SafeHeapFree(wszContentType);

    return hr;
}


// **************************************************************************
static
HRESULT StartWinHttpDownload(SWinHTTPFunctions &sfns,
                             LPCWSTR wszUrl, 
                             LPCWSTR wszLocalFile,
                             DWORD   *pcbDownloaded,
                             HANDLE  *rghQuitEvents,
                             UINT    cQuitEvents,
                             PFNDownloadCallback pfnCallback,
                             LPVOID  pvCallbackData,
                             DWORD   dwFlags,
                             DWORD   cbDownloadBuffer)
{
    LOG_Block("StartWinHttpDownload()");

    URL_COMPONENTS  UrlComponents;
    SAUProxyInfo    AUProxyInfo;

    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect = NULL;
    HINTERNET   hOpenRequest = NULL;
    DWORD       dwStatus, dwAccessType;

    LPWSTR      wszServerName = NULL;
    LPWSTR      wszObject = NULL;
    LPWSTR      wszContentType = NULL;
    WCHAR       wszUserName[UNLEN + 1];
    WCHAR       wszPasswd[UNLEN + 1];
    WCHAR       wszScheme[32];

    // NULL (equivalent to "GET") MUST be the last verb in the list
    LPCWSTR     rgwszVerbs[] = { L"HEAD", NULL };
    DWORD       iVerb;

    HRESULT     hr = S_OK, hrToReturn = S_OK;
    BOOL        fRet = TRUE;

    FILETIME    ft;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cbRemoteFile;

    DWORD       dwLength;
    DWORD       dwTickStart = 0, dwTickEnd = 0;

    int         iRetryCounter = -1;         // non-negative during download mode

    BOOL        fAllowProxy = ((dwFlags & WUDF_DONTALLOWPROXY) == 0);
    BOOL        fCheckStatusOnly = ((dwFlags & WUDF_CHECKREQSTATUSONLY) != 0);
    BOOL        fAppendCacheBreaker = ((dwFlags & WUDF_APPENDCACHEBREAKER) != 0);
    BOOL        fSkipDownloadRetry = ((dwFlags & WUDF_DODOWNLOADRETRY) == 0);
    BOOL        fDoCabValidation = ((dwFlags & WUDF_SKIPCABVALIDATION) == 0);
    BOOL        fCacheProxyInfo = ((dwFlags & WUDF_SKIPAUTOPROXYCACHE) == 0);

    ZeroMemory(&AUProxyInfo, sizeof(AUProxyInfo));

    if ((wszUrl == NULL) || 
        (wszLocalFile == NULL && fCheckStatusOnly == FALSE))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if (pcbDownloaded != NULL)
        *pcbDownloaded = 0;

    wszServerName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    wszObject     = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    if (wszServerName == NULL || wszObject == NULL)
    {
        LOG_ErrorMsg(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    wszServerName[0] = L'\0';
    wszObject[0]     = L'\0';
    wszUserName[0]   = L'\0';
    wszPasswd[0]     = L'\0';

    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    // Break down the URL into its various components for the InternetAPI calls.
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = wszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = wszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = wszUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(wszUserName);
    UrlComponents.lpszPassword     = wszPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(wszPasswd);
    UrlComponents.lpszScheme       = wszScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(wszScheme);

    LOG_Internet(_T("WinHttp: Downloading URL %ls to FILE %ls"), wszUrl, wszLocalFile);

    if ((*sfns.pfnWinHttpCrackUrl)(wszUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (wszUrl[0] == L'\0' || wszScheme[0] == L'\0' || wszServerName[0] == L'\0' ||
        _wcsicmp(wszScheme, L"http") != 0)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (fAppendCacheBreaker)
    {
        SYSTEMTIME  stCB;
        WCHAR       wszCacheBreaker[12];
        
        GetSystemTime(&stCB);
        hr = StringCchPrintfExW(wszCacheBreaker, ARRAYSIZE(wszCacheBreaker),
                                NULL, NULL, MISTSAFE_STRING_FLAGS,
                                L"?%02d%02d%02d%02d%02d", 
                                stCB.wYear % 100,
                                stCB.wMonth,
                                stCB.wDay,
                                stCB.wHour,
                                stCB.wMinute);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCatExW(wszObject, c_cchMaxURLSize, wszCacheBreaker, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
    }

    if (fAllowProxy)
        dwAccessType = WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
    else
        dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
    
    dwTickStart = GetTickCount();
    
START_INTERNET:
    // start to deal with Internet    
    iRetryCounter++; 
    
    // If the connection has already been established re-use it.
    hInternet = (*sfns.pfnWinHttpOpen)(c_wszUserAgent, dwAccessType, NULL, NULL, 0);
    if (hInternet == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (fAllowProxy != NULL)
    {
        GetWinHTTPProxyInfo(sfns, fCacheProxyInfo, hInternet, wszUrl, 
                            wszServerName, &AUProxyInfo);
    }

    hConnect = (*sfns.pfnWinHttpConnect)(hInternet, wszServerName, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    // if we're only doing a status check, then may as well just make a GET 
    //  request
    iVerb = (DWORD)((fCheckStatusOnly) ? ARRAYSIZE(rgwszVerbs) - 1 : 0);
    for(; iVerb < ARRAYSIZE(rgwszVerbs); iVerb++)
    {
        SafeWinHTTPCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, NULL, wszServerName, rgwszVerbs[iVerb], 
                         wszObject, ((fAllowProxy) ? &AUProxyInfo : NULL),
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;
        
        dwLength = sizeof(dwStatus);
        if ((*sfns.pfnWinHttpQueryHeaders)(hOpenRequest, 
                                           WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, 
                                           NULL, (LPVOID)&dwStatus, &dwLength, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: Request result: %d"), dwStatus);

        if (dwStatus == HTTP_STATUS_OK || dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
            break;
        }
        else
        {
            // since a server result is not a proper win32 error code, we can't 
            //  really do a HRESULT_FROM_WIN32 here.  Otherwise, we'd return
            //  a bogus code.  However, we do want to pass an error HRESULT back
            //  that contains this code.
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, dwStatus);
            LOG_Error(_T("WinHttp: got failed status code from server %d\n"), dwStatus);

            // if it's the last verb in the list, then bail...
            if (rgwszVerbs[iVerb] == NULL)
                goto CleanUp;
        }
    }

    // if we made it here & we're only trying to check status, then we're done
    if (fCheckStatusOnly)
    {
        LOG_Internet(_T("WinHttp: Only checking status.  Exiting before header check and download."));
        hr = S_OK;
        goto CleanUp;
    }

    // CheckFileHeader will return S_OK if we need to download the file, S_FALSE
    //  if we don't, and some other HRESULT if a failure occurred
    hr = CheckFileHeader(sfns, hOpenRequest, rghQuitEvents, cQuitEvents, 
                         wszLocalFile, &cbRemoteFile, &ft);
    if (FAILED(hr))
        goto CleanUp;

    // unless we have a flag that explicitly allows it, do not retry downloads 
    //  here.  The reasoning is that we could be in the middle of a large 
    //  download and have it fail...
    if (fSkipDownloadRetry)
        iRetryCounter = c_cMaxRetries;

    if (hr == S_OK)
    {
        DWORD cbDownloaded;
        BOOL  fCheckForHTML = fDoCabValidation;

        LOG_Internet(_T("WinHttp: Server file was newer.  Downloading file"));
        
        // if we didn't open with a GET request above, then we gotta open a new
        //  request.  Otherwise, can reuse the request object...
        if (rgwszVerbs[iVerb] != NULL)
            SafeWinHTTPCloseHandle(sfns, hOpenRequest);

        // now we know we need to download this file
        hr = MakeRequest(sfns, hConnect, hOpenRequest, wszServerName, NULL, 
                         wszObject, ((fAllowProxy) ? &AUProxyInfo : NULL), 
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = GetContentTypeHeader(sfns, hOpenRequest, &wszContentType);
            if (SUCCEEDED(hr) && wszContentType != NULL)
            {
                fCheckForHTML = FALSE;
                if (_wcsicmp(wszContentType, L"text/html") == 0)
                {
                    LOG_Internet(_T("WinHttp: Content-Type header is text/html.  Bailing."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto CleanUp;
                }
                else
                {
                    LOG_Internet(_T("WinHttp: Content-Type header is %ls.  Continuing."), wszContentType);
                }
            }

            hr = NOERROR;
        }

        // open the file we're gonna spew into
        hFile = CreateFileW(wszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                            FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: downloading to FILE %ls"), wszLocalFile);

        // bring down the bits
        hr = PerformDownloadToFile(sfns.pfnWinHttpReadData, hOpenRequest, 
                                   hFile, cbRemoteFile,
                                   cbDownloadBuffer, 
                                   rghQuitEvents, cQuitEvents, 
                                   pfnCallback, pvCallbackData, &cbDownloaded);
        if (FAILED(hr))
        {
            LOG_Internet(_T("WinHttp: Download failed: hr: 0x%08x"), hr);
            SafeCloseInvalidHandle(hFile);
            DeleteFileW(wszLocalFile);
            goto CleanUp;
        }

        LOG_Internet(_T("WinHttp: Download succeeded"));

        // set the file time to match the server file time since we just 
        //  downloaded it. If we don't do this the file time will be set 
        //  to the current system time.
        SetFileTime(hFile, &ft, NULL, NULL);
        SafeCloseInvalidHandle(hFile);

        if (pcbDownloaded != NULL)
            *pcbDownloaded = cbRemoteFile;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = IsFileHtml(wszLocalFile);
            if (SUCCEEDED(hr))
            {
                if (hr == S_FALSE)
                {
                    LOG_Internet(_T("WinHttp: Download is not a html file"));
                    hr = S_OK;
                }
                else
                {
                    LOG_Internet(_T("WinHttp: Download is a html file.  Failing download."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    DeleteFileW(wszLocalFile);
                    goto CleanUp;
                }
            }
            else
            {
                LOG_Internet(_T("WinHttp: Unable to determine if download is a html file or not.  Failing download."));
            }
        }
        else if (fDoCabValidation == FALSE)
        {
            LOG_Internet(_T("WinHttp: Skipping cab validation."));
        }
    }
    else
    {
        hr = S_OK;
        
        LOG_Internet(_T("WinHttp: Server file is not newer.  Skipping download."));
        
        // The server ain't newer & the file is already on machine, so
        //  send progress callback indicating file downloadeded ok
        if (pfnCallback != NULL)
        {
            // fpnCallback(pCallbackData, DOWNLOAD_STATUS_FILECOMPLETE, dwFileSize, dwFileSize, NULL, NULL);
            pfnCallback(pvCallbackData, DOWNLOAD_STATUS_OK, cbRemoteFile, cbRemoteFile, NULL, NULL);
        }
    }

CleanUp:
    SafeWinHTTPCloseHandle(sfns, hOpenRequest);
    SafeWinHTTPCloseHandle(sfns, hConnect);
    SafeWinHTTPCloseHandle(sfns, hInternet);

    SafeHeapFree(wszContentType);

    // free up the proxy strings- they were allocated by WinHttp
    if (AUProxyInfo.ProxyInfo.lpszProxyBypass != NULL)
        GlobalFree(AUProxyInfo.ProxyInfo.lpszProxyBypass);
    if (AUProxyInfo.wszProxyOrig != NULL)
        GlobalFree(AUProxyInfo.wszProxyOrig);
    if (AUProxyInfo.rgwszProxies != NULL)
        GlobalFree(AUProxyInfo.rgwszProxies);
    ZeroMemory(&AUProxyInfo, sizeof(AUProxyInfo));
    
    // if we failed, see if it's ok to continue (quit events) and whether
    //  we've tried enuf times yet.
    if (FAILED(hr) &&
        HandleEvents(rghQuitEvents, cQuitEvents) &&
        iRetryCounter >= 0 && iRetryCounter < c_cMaxRetries)
    {
        DWORD dwElapsedTime;

        dwTickEnd = GetTickCount();
        if (dwTickEnd > dwTickStart)   
            dwElapsedTime = dwTickEnd - dwTickStart;
        else
            dwElapsedTime = (0xFFFFFFFF - dwTickStart) + dwTickEnd;
        
        // We haven't hit our retry limit, so log & error and go again
        if (dwElapsedTime < c_dwRetryTimeLimitInmsWinHttp)
        {
            LogError(hr, "Library download error. Will retry.");

            // in the case where we're gonna retry, keep track of the very first
            //  error we encoutered cuz the ops guys say that this is the most
            //  useful error to know about.
            if (iRetryCounter == 0)
            {
                LOG_Internet(_T("First download error saved: 0x%08x."), hr);
                hrToReturn = hr;
            }
            else
            {
                LOG_Internet(_T("Subsequent download error: 0x%08x."), hr);
            }
            hr = S_OK;
            goto START_INTERNET;
        }

        // We've completely timed out, so bail
        else
        {
            LogError(hr, "Library download error and timed out (%d ms). Will not retry.", dwElapsedTime);
        }
    }
    
    // make a callback indicating a download error
    if (FAILED(hr) && pfnCallback != NULL)
        pfnCallback(pvCallbackData, DOWNLOAD_STATUS_ERROR, cbRemoteFile, 0, NULL, NULL);

    // if we haven't saved off an error, just use the current error.  We can't
    //  have set hrToReturn previously if we didn't fail and want to attempt 
    //  a retry.
    // However, if we've got a success from this pass, be sure to return that 
    //  and not a fail code.
    if (FAILED(hr) && SUCCEEDED(hrToReturn))
        hrToReturn = hr;
    else if (SUCCEEDED(hr) && FAILED(hrToReturn))
        hrToReturn = hr;

    SafeHeapFree(wszServerName);
    SafeHeapFree(wszObject);
    
    return hrToReturn;
}

#endif // defined(UNICODE)

///////////////////////////////////////////////////////////////////////////////
// exported functions

#if defined(UNICODE)

// **************************************************************************
HRESULT  GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups)
{
    LOG_Block("GetAUProxySettings()");

    URL_COMPONENTS      UrlComponents;
    LPWSTR              wszServerName = NULL;
    LPWSTR              wszObject = NULL;
    WCHAR               wszUserName[UNLEN + 1];
    WCHAR               wszPasswd[UNLEN + 1];
    WCHAR               wszScheme[32];

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    BOOL                fRet, fLocked = FALSE;

    if (wszUrl == NULL || paups == NULL)
    {
        hr = E_INVALIDARG;
        goto done;
    }

    ZeroMemory(paups, sizeof(SAUProxySettings));

    etu = LoadTransportDll(&sfns, &hmod, WUDF_ALLOWWINHTTPONLY);
    if (etu == etuNone)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }
    else if (etu != etuWinHttp)
    {
        hr = E_FAIL;
        LOG_Internet(_T("GetAUProxySettings called when in WinInet mode."));
        goto done;
    }

    wszServerName = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    wszObject     = (LPWSTR)HeapAlloc(GetProcessHeap(), 0, c_cchMaxURLSize * sizeof(WCHAR));
    if (wszServerName == NULL || wszObject == NULL)
    {
        LOG_ErrorMsg(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
        goto done;
    }

    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = wszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = wszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = wszUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(wszUserName);
    UrlComponents.lpszPassword     = wszPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(wszPasswd);
    UrlComponents.lpszScheme       = wszScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(wszScheme);
    
    if ((*sfns.pfnWinHttpCrackUrl)(wszUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (wszUrl[0] == L'\0' || wszScheme[0] == L'\0' || wszServerName[0] == L'\0' ||
        (_wcsicmp(wszScheme, L"http") != 0 && _wcsicmp(wszScheme, L"https") != 0))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto done;
    }
   
    if (g_csCache.Lock() == FALSE)
    {
        hr = E_FAIL;
        goto done;
    }
    fLocked = TRUE;

    // get the proxy list 
    if (g_wudlProxyCache.GetLastGoodProxy(wszServerName, paups) == FALSE)
    {
        
        // proxy was not in list
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
        {
            SAUProxyInfo    aupi;
            HINTERNET       hInternet = NULL;

            LOG_Internet(_T("GetLastGoodProxy did not find a proxy object.  Doing autodetect."));
            
            hInternet = (*sfns.pfnWinHttpOpen)(c_wszUserAgent, 
                                               WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, 
                                               NULL, NULL, 0);
            if (hInternet == NULL)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }

            fRet = GetWinHTTPProxyInfo(sfns, TRUE, hInternet, wszUrl, 
                                       wszServerName, &aupi);
            (*sfns.pfnWinHttpCloseHandle)(hInternet);
            if (fRet == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }

            paups->wszProxyOrig = aupi.wszProxyOrig;
            paups->wszBypass    = aupi.ProxyInfo.lpszProxyBypass;
            paups->dwAccessType = aupi.ProxyInfo.dwAccessType;
            paups->cProxies     = aupi.cProxies;
            paups->rgwszProxies = aupi.rgwszProxies;
            paups->iProxy       = (DWORD)-1;

            SetLastError(ERROR_SUCCESS);
            
        }
        else
        {
            LOG_Internet(_T("GetLastGoodProxy failed..."));
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }
    else
    {
        if (paups->wszProxyOrig != NULL)
        {
            // break it up into an array
            if (ProxyListToArray(paups->wszProxyOrig, &paups->rgwszProxies,
                                &paups->cProxies) == FALSE)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                LOG_ErrorMsg(hr);
                goto done;
            }
        }
        else
        {
            paups->iProxy       = (DWORD)-1;
        }
    }
       
done:
    // Unlock returns FALSE as well, but we should never get here cuz we should
    //  not have been able to take the lock above.
    if (fLocked)
        g_csCache.Unlock();
    if (wszServerName != NULL)
        HeapFree(GetProcessHeap(), 0, wszServerName);
    if (wszObject != NULL)
        HeapFree(GetProcessHeap(), 0, wszObject);
        
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    
    return hr;
}

// **************************************************************************
HRESULT FreeAUProxySettings(SAUProxySettings *paups)
{
    LOG_Block("FreeAUProxySettings()");

    if (paups == NULL)
        goto done;
    
    if (paups->rgwszProxies != NULL)
        GlobalFree(paups->rgwszProxies);
    if (paups->wszBypass != NULL)
        GlobalFree(paups->wszBypass);
    if (paups->wszProxyOrig != NULL)
        GlobalFree(paups->wszProxyOrig);

done:
    return S_OK;
}

// **************************************************************************
HRESULT CleanupDownloadLib(void)
{
    LOG_Block("CleanupDownloadLib()");

    HRESULT hr = S_OK;

    if (g_hmodWinHttp != NULL)
    {
        FreeLibrary(g_hmodWinHttp);
        g_hmodWinHttp = NULL;        
    }

    if (g_hmodWinInet != NULL)
    {
        FreeLibrary(g_hmodWinInet);
        g_hmodWinInet = NULL;        
    }

    if (g_csCache.Lock() == FALSE)
        return E_FAIL;

    __try { g_wudlProxyCache.Empty(); }
    __except(EXCEPTION_EXECUTE_HANDLER) { hr = E_FAIL; }

    // this returns FALSE as well, but we should never get here cuz we should
    //  not have been able to take the lock above.
    g_csCache.Unlock();

    return hr;
}

// **************************************************************************
HRESULT DownloadFile(
            LPCWSTR wszServerUrl,            // full http url
            LPCWSTR wszLocalPath,            // local directory to download file to
            LPCWSTR wszLocalFileName,        // optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
            PDWORD  pdwDownloadedBytes,      // bytes downloaded for this file
            HANDLE  *hQuitEvents,            // optional events causing this function to abort
            UINT    nQuitEventCount,         // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback, // optional call back function
            VOID*   pCallbackData,           // parameter for call back function to use
            DWORD   dwFlags
)
{
    LOG_Block("DownloadFile()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    LPWSTR              wszLocalFile = NULL;
    DWORD               dwFlagsToUse;

    // for full download, disable cache breaker.
    dwFlagsToUse = dwFlags & ~WUDF_APPENDCACHEBREAKER;
    
    ZeroMemory(&sfns, sizeof(sfns));

    if (wszServerUrl == NULL || wszLocalPath == NULL)
    {
        LOG_ErrorMsg(ERROR_INVALID_PARAMETER);
        hr = E_INVALIDARG;
        goto done;
    }

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    if (etu == etuNone)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    else if (etu != etuWinHttp && etu != etuWinInet)
    {
        hr = E_FAIL;
        LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
        goto done;
    }

    // Since StartDownload just takes a full path to the file to download, build
    //  it here...  
    // Note that we don't need to do this if we're just in status 
    //  checking mode)
    if ((dwFlags & WUDF_CHECKREQSTATUSONLY) == 0)
    {
        wszLocalFile = MakeFullLocalFilePath(wszServerUrl, wszLocalFileName, 
                                             wszLocalPath);
        if (wszLocalFile == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }
    }

    if (etu == etuWinHttp)
    {
        hr = StartWinHttpDownload(sfns, wszServerUrl, wszLocalFile, 
                                  pdwDownloadedBytes, hQuitEvents, nQuitEventCount,
                                  fpnCallback, pCallbackData, dwFlagsToUse,
                                  c_cbDownloadBuffer);
    }

    else
    {
        hr = StartWinInetDownload(hmod, wszServerUrl, wszLocalFile, 
                                  pdwDownloadedBytes, hQuitEvents, nQuitEventCount, 
                                  fpnCallback, pCallbackData, dwFlagsToUse,
                                  c_cbDownloadBuffer);
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    SafeHeapFree(wszLocalFile);
    return hr;
}

// **************************************************************************
HRESULT DownloadFileLite(LPCWSTR wszDownloadUrl, 
                         LPCWSTR wszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags)
{
    LOG_Block("DownloadFileLite()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsToUse;


    // for lite download, force cache breaker & download retry
    dwFlagsToUse = dwFlags | WUDF_APPENDCACHEBREAKER | WUDF_DODOWNLOADRETRY;

    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);

    switch (etu)
    {
        case etuNone:
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;

        case etuWinHttp:
            hr = StartWinHttpDownload(sfns, wszDownloadUrl, wszLocalFile, 
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;

        case etuWinInet:
            hr = StartWinInetDownload(hmod, wszDownloadUrl, wszLocalFile,  
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;
            
        default:
            LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    return hr;
}

#else // !defined(UNICODE)

// **************************************************************************
HRESULT  GetAUProxySettings(LPCWSTR wszUrl, SAUProxySettings *paups)
{
    return E_NOTIMPL;
}

// **************************************************************************
HRESULT FreeAUProxySettings(SAUProxySettings *paups)
{
    return E_NOTIMPL;
}

// **************************************************************************
HRESULT CleanupDownloadLib(void)
{
    if (g_hmodWinInet != NULL)
    {
        FreeLibrary(g_hmodWinInet);
        g_hmodWinInet = NULL;        
    }
    
    return NOERROR;
}

// **************************************************************************
HRESULT DownloadFile(
            LPCSTR  pszServerUrl,            // full http url
            LPCSTR  pszLocalPath,            // local directory to download file to
            LPCSTR  pszLocalFileName,        // optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
            PDWORD  pdwDownloadedBytes,      // bytes downloaded for this file
            HANDLE  *hQuitEvents,            // optional events causing this function to abort
            UINT    nQuitEventCount,         // number of quit events, must be 0 if array is NULL
            PFNDownloadCallback fpnCallback, // optional call back function
            VOID*   pCallbackData,            // parameter for call back function to use
            DWORD   dwFlags
)
{
    LOG_Block("DownloadFile()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    LPSTR               pszLocalFile = NULL;
    DWORD               dwFlagsToUse;

    // for ansi, force wininet & disable any request to force winhttp 
    // for full download, disable cache breaker.
    dwFlagsToUse = dwFlags | WUDF_ALLOWWININETONLY;
    dwFlagsToUse &= ~(WUDF_ALLOWWINHTTPONLY | WUDF_APPENDCACHEBREAKER);

    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    if (etu == etuNone)
    {
        LOG_ErrorMsg(GetLastError());
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto done;
    }

    else if (etu != etuWinInet)
    {
        hr = E_FAIL;
        LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
        goto done;
    }

    // Since StartDownload just takes a full path to the file to download, build
    //  it here...  
    // Note that we don't need to do this if we're just in status 
    //  checking mode)
    if ((dwFlags & WUDF_CHECKREQSTATUSONLY) == 0)
    {
        pszLocalFile = MakeFullLocalFilePath(pszServerUrl, pszLocalFileName, 
                                             pszLocalPath);
        if (pszLocalFile == NULL)
        {
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
        }
    }

    hr = StartWinInetDownload(hmod, pszServerUrl, pszLocalFile, 
                              pdwDownloadedBytes, hQuitEvents, nQuitEventCount, 
                              fpnCallback, pCallbackData, dwFlagsToUse,
                              c_cbDownloadBuffer);

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    SafeHeapFree(pszLocalFile);
    
    return hr;
}

// **************************************************************************
HRESULT DownloadFileLite(LPCSTR pszDownloadUrl, 
                         LPCSTR pszLocalFile,  
                         HANDLE hQuitEvent,
                         DWORD dwFlags)

{
    LOG_Block("DownloadFileLite()");

    SWinHTTPFunctions   sfns;
    ETransportUsed      etu;
    HMODULE             hmod = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwFlagsToUse;

    // for ansi, force wininet & disable any request to force winhttp 
    // for lite download, force cache breaker & download retry
    dwFlagsToUse = dwFlags | WUDF_APPENDCACHEBREAKER | WUDF_ALLOWWININETONLY |
                   WUDF_DODOWNLOADRETRY;
    dwFlagsToUse &= ~WUDF_ALLOWWINHTTPONLY;
    
    ZeroMemory(&sfns, sizeof(sfns));

    etu = LoadTransportDll(&sfns, &hmod, dwFlagsToUse);
    switch (etu)
    {
        case etuNone:
            LOG_ErrorMsg(GetLastError());
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;

        case etuWinInet:
            hr = StartWinInetDownload(hmod, pszDownloadUrl, pszLocalFile,  
                                      NULL, 
                                      ((hQuitEvent != NULL) ? &hQuitEvent : NULL),
                                      ((hQuitEvent != NULL) ? 1 : 0),
                                      NULL, NULL, dwFlagsToUse,
                                      c_cbDownloadBuffer);
            break;
            
        default:
        case etuWinHttp:
            LogError(hr, "Unexpected answer from LoadTransportDll(): %d", etu);
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto done;
    }

done:
    if (hmod != NULL)
        UnloadTransportDll(&sfns, hmod);
    return hr;
}

#endif // defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\install\drvinst.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   drvinst.cpp
//
//  Description:
//
//      Functions called to install drivers and printer drivers
//
//=======================================================================

#include <windows.h>
#include <wuiutest.h>
#include <tchar.h>
#include <winspool.h>
#include <setupapi.h>
#include <shlwapi.h>
#include <fileutil.h>

#include <install.h>
#include <logging.h>
#include <memutil.h>
#include <stringutil.h>
#include <iucommon.h>
#include <wusafefn.h>
#include <mistsafe.h>

#if defined(_X86_) || defined(i386)
const TCHAR SZ_PROCESSOR[] = _T("Intel");
#else // defined(_IA64_) || defined(IA64)
const TCHAR SZ_PROCESSOR[] = _T("IA64");
#endif

const TCHAR SZ_PRINTER[] = _T("Printer");


///////////////////////////////////////////////////////////////////////////
//
// InstallPrinterDriver 
//
///////////////////////////////////////////////////////////////////////////
HRESULT InstallPrinterDriver(
	IN LPCTSTR szDriverName,
	IN LPCTSTR pszLocalDir,		//Local directory where installation files are.
	IN LPCTSTR szArchitecture,
	OUT	DWORD* pdwStatus
	)
{
	LOG_Block("InstallPrinterDriver");

	USES_IU_CONVERSION;

	HRESULT hr = S_OK;
	DWORD dwError = ERROR_INVALID_FUNCTION;
	TCHAR szFileName[MAX_PATH + 1];
	HANDLE hFindFile = INVALID_HANDLE_VALUE;
	OSVERSIONINFO	osvi;
	WIN32_FIND_DATA ffd;
	HMODULE hLibModule = NULL;
	LPWSTR pszwCmd = NULL;
	HINF hInfFile = INVALID_HANDLE_VALUE;

	if (NULL == szDriverName || NULL == pszLocalDir || NULL == pdwStatus)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	LOG_Driver(_T("Called with szDriverName = %s, pszLocalDir = %s, szArchitecture = %s"),
		szDriverName, pszLocalDir, (NULL == szArchitecture) ? _T("NULL") : szArchitecture);
	//
	// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
	//
	hr = DecompressFolderCabs(pszLocalDir);
	if (S_OK != hr)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	
	//
	// Find the first *.inf file in pszLocalDir
	//
	CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), pszLocalDir, \
														NULL, NULL, MISTSAFE_STRING_FLAGS));
	CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFileName, ARRAYSIZE(szFileName), _T("*.inf")));

	if (INVALID_HANDLE_VALUE == (hFindFile = FindFirstFile(szFileName, &ffd)))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	//
	// 574593  During site printer install, we pass path to first INF - this may not be correct for MFD's or multi-platform CABs
	//
	// Find the first printer INF by calling SetupOpenInfFile() with class "Printer"
	//
	for (;;)
	{
		//
		// Construct .inf path using FindXxxFile name
		//
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szFileName, ARRAYSIZE(szFileName), pszLocalDir, \
															NULL, NULL, MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(PathCchAppend(szFileName, ARRAYSIZE(szFileName), ffd.cFileName));

		if (INVALID_HANDLE_VALUE == (hInfFile = SetupOpenInfFile(szFileName, SZ_PRINTER, INF_STYLE_WIN4, NULL)))
		{
			if (ERROR_CLASS_MISMATCH != GetLastError())
			{
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			//
			// If this isn't a Printer INF (ERROR_CLASS_MISMATCH) try the next file
			//
			if (0 == FindNextFile(hFindFile, &ffd))
			{
				//
				// We ran out of *.inf files or hit other FindNextFile error before finding class match
				//
				Win32MsgSetHrGotoCleanup(GetLastError());
			}
			continue;
		}
		else
		{
			//
			// We found the printer INF in the cab. NOTE: WHQL assumption that only one "Printer" class
			// INF will exist in any particular cab.
			//
			SetupCloseInfFile(hInfFile);
			hInfFile = INVALID_HANDLE_VALUE;
			//
			// Go use szFileName
			//
			break;
		}
	}
	//
	// We've broken out of for (;;) loop without jumping to CleanUp, so we have a
	// "Printer" class INF path in szFileName
	//
	
	// Only works on NT 5 up and Millennium
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId && 4 == osvi.dwMajorVersion && 90 == osvi.dwMinorVersion)
	{
#if !(defined(_UNICODE) || defined(UNICODE))
		//
		// Millennium (ANSI only)
		//
		typedef DWORD (WINAPI *PFN_InstallPrinterDriver)(LPCSTR lpszDriverName, LPCSTR lpszINF);

		if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("msprint2.dll"))))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		PFN_InstallPrinterDriver pfnIPD;
		
		if (NULL == (pfnIPD= (PFN_InstallPrinterDriver) GetProcAddress(hLibModule, "InstallPrinterDriver")))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		if (NO_ERROR != (dwError = pfnIPD(szDriverName, szFileName)))
		{
			LOG_Driver("pfnIPD(%s, %s) returns %d", szDriverName, szFileName, dwError);
			Win32MsgSetHrGotoCleanup(dwError);
		}
#endif
	}
	else if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && 5 <= osvi.dwMajorVersion)
	{
		//
		// Windows 2000 and Whistler:  PrintUIEntryW is the only supported method of installing printer drivers.
		// Don't try and use PnPInterface() defined in printui.dll (and don't ask *me* why PrintUIEntryW isn't
		// typedef'ed there...)
		//
		// Type "rundll32.exe printui.dll,PrintUIEntry /?" from a cmd prompt for help on the command parameters.
		//
		// Private typedef since this isn't exposed in any internal or external SDK headers
		//
		typedef DWORD (*PFN_PrintUIEntryW)(
			IN HWND        hwnd,
			IN HINSTANCE   hInstance,
			IN LPCWSTR     pszCmdLine,
			IN UINT        nCmdShow
			);
		///////////////////////////////////

		if (NULL == szArchitecture)
		{
			szArchitecture = (LPCTSTR) &SZ_PROCESSOR;
		}

		//
		// 491157 Trying to update an English  language printer driver installed on a German build through the German WU website fails.
		//
		// Don't pass optional /u, /h, and /v parameters (localized). They aren't required since we always provide
		// drivers for the client architecture and OS.
		//
		// 574593  Per attached discussion we need to pass an undocumented upper-case 'U' flag.
		//
		const WCHAR szwCmdLineFormat[] = L"/ia /m \"%s\" /f \"%s\" /q /U";
		const size_t nCmdLineFormatLength = wcslen(szwCmdLineFormat);
#define MAX_PLATFORMVERSION 20 // NOTE:: Max Version Length Needs to be Updated if the OS Strings in the Below Command Line Change

		// NOTE: this doesn't bother to remove the length of the %s characters from nCmdLineFormatLength

		DWORD dwLength=(nCmdLineFormatLength + lstrlen(szDriverName) + lstrlen(szArchitecture) + MAX_PLATFORMVERSION + lstrlen(szFileName) + 1);
		pszwCmd = (LPWSTR) HeapAlloc(
					GetProcessHeap(),
					0,
					dwLength * sizeof(WCHAR));
		CleanUpFailedAllocSetHrMsg(pszwCmd);

		// OK to cast away const-ness on string params so T2OLE works, since it doesn't modify them anyway
					
		hr=StringCchPrintfExW(pszwCmd,dwLength,NULL,NULL,MISTSAFE_STRING_FLAGS,(LPCWSTR) szwCmdLineFormat,
			T2OLE(const_cast<TCHAR*>(szDriverName)),
			T2OLE(const_cast<TCHAR*>(szFileName)) );
		
		CleanUpIfFailedAndSetHr(hr);

		// Load printui.dll
		if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("printui.dll"))))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		PFN_PrintUIEntryW pfnPrintUIEntryW;
		if (NULL == (pfnPrintUIEntryW = (PFN_PrintUIEntryW) GetProcAddress(hLibModule, "PrintUIEntryW")))
		{
			Win32MsgSetHrGotoCleanup(GetLastError());
		}

		if (NO_ERROR != (dwError = pfnPrintUIEntryW(GetActiveWindow(), 0, pszwCmd, SW_HIDE)))
		{
			LOG_Driver(_T("pfnPrintUIEntryW(%s) returns %d"), OLE2T(pszwCmd), dwError);
			Win32MsgSetHrGotoCleanup(dwError);
		}
	}
	else
	{
		SetHrMsgAndGotoCleanUp(E_NOTIMPL);
	}

	*pdwStatus = ITEM_STATUS_SUCCESS;

CleanUp:

	SafeHeapFree(pszwCmd);
		
	if (INVALID_HANDLE_VALUE != hFindFile)
	{
		FindClose(hFindFile);
	}

	if (INVALID_HANDLE_VALUE != hInfFile)
	{
		SetupCloseInfFile(hInfFile);
	}

	if (NULL != hLibModule)
	{
		FreeLibrary(hLibModule);
	}

	if (FAILED(hr))
	{
        if (NULL != pdwStatus)
        {
    		*pdwStatus = ITEM_STATUS_FAILED;
        }
	}

	return hr; 
}

///////////////////////////////////////////////////////////////////////////
//
// InstallDriver and helper functions
//
///////////////////////////////////////////////////////////////////////////


DWORD OpenReinstallKey(HKEY* phKeyReinstall)
{
	return RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reinstall"),
		0, KEY_ALL_ACCESS, phKeyReinstall);
}


//-----------------------------------------------------------------------------------
// LaunchProcess
//   Launches pszCmd and optionally waits till the process terminates
//-----------------------------------------------------------------------------------
static HRESULT LaunchProcess(LPTSTR pszCmd, LPCTSTR pszDir, UINT uShow, BOOL bWait)
{
	LOG_Block("LaunchProcess");

	HRESULT hr = S_OK;

	STARTUPINFO startInfo;
	PROCESS_INFORMATION processInfo;
	
	ZeroMemory(&startInfo, sizeof(startInfo));
	startInfo.cb = sizeof(startInfo);
	startInfo.dwFlags |= STARTF_USESHOWWINDOW;
	startInfo.wShowWindow = (USHORT)uShow;
	
	BOOL bRet = CreateProcess(NULL, pszCmd, NULL, NULL, FALSE,
		NORMAL_PRIORITY_CLASS, NULL, pszDir, &startInfo, &processInfo);
	if (!bRet)
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
	
	CloseHandle(processInfo.hThread);

	if (bWait)
	{
		BOOL bDone = FALSE;
		
		while (!bDone)
		{
			DWORD dwObject = MsgWaitForMultipleObjects(1, &processInfo.hProcess, FALSE,INFINITE, QS_ALLINPUT);
			if (dwObject == WAIT_OBJECT_0 || dwObject == WAIT_FAILED)
			{
				bDone = TRUE;
			}
			else
			{
				MSG msg;
				while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE))
				{
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}
		}  // while

	} // bWait

	CloseHandle(processInfo.hProcess);

CleanUp:

  return hr;
}

//	"@rundll sysdm.cpl,UpdateDriver_Start"
//	"@rundll sysdm.cpl,UpdateDriver_RunDLL .\,,1,Win98 signed test pkg for System Devices"
//	"@rundll sysdm.cpl,UpdateDriver_Finish 0"
//	"@rundll sysdm.cpl,UpdateDriver_RunDLL .\,,1,Win98 signed test pkg for System Devices"
//Note: Windows 98 uses rundll.exe to call device manager. This is because sysdm.cpl which
//is device manager for 98 is a 16 bit dll. Since we would need to create something that
//worked similar to rundll in order call device manager we have brought the existing code
//across with some minor clean ups. win98 device manager provides three apis for our use
//in installing device drivers. These are:
//	UpdateDriver_Start()	- Start the device installation
//	UpdateDriver_RunDLL(inf Directory,hardware id, force flag, display string)
//	UpdateDriver_Finish 0 - finish the installation.
//The UpdateDriver_RunDLL() command 
//Comma separated string in following format:
//INFPath,HardwareID,flags,DisplayName
//INFPath = Path to INF and installation files
//HardwareID = PnpHardware ID
//flags	= '1' = force driver, '0' = do not force driver.
//Note: A Reinstall driver is detected based on the location of the INF path. If INF path
//is the same path as the reinstallbackups registry key then reinstall is selected.
//DisplayName = Name to display in install dialogs.

//This method installs a CDM driver for Windows 98.
static HRESULT Install98(
	LPCTSTR pszHardwareID,			
	LPCTSTR pszLocalDir,			// location of INF and other driver install files
	LPCTSTR pszDisplayName,	
	PDWORD pdwReboot			
)
{
	LOG_Block("Install98");

	HRESULT hr = E_NOTIMPL;

	DWORD dwStatus = 0;
	LPTSTR pszCmd = NULL;
	DWORD dwLen;
	LONG lRet;
	DWORD dwSize;


	if (NULL == pdwReboot)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#if defined(DBG)
	// checked by caller
	if (NULL == pszHardwareID || NULL == pszLocalDir || NULL == pszDisplayName)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#endif

#if !(defined(_UNICODE) || defined(UNICODE))
	//
	// Win98 and WinME (ANSI only)
	//

	// Start
	CleanUpIfFailedAndSetHr(LaunchProcess(_T("rundll32 sysdm.cpl,UpdateDriver_Start"), NULL, SW_NORMAL, TRUE));

	TCHAR szShortInfPathName[MAX_PATH] = {0};
	dwLen = GetShortPathName(pszLocalDir, szShortInfPathName, ARRAYSIZE(szShortInfPathName));

	//Note: The maximum a hardware or compatible ID can be is 200 characters
	//      (MAX_DEVICE_ID_LEN defined in sdk\inc\cfgmgr32.h)

	DWORD dwBuffLength=( lstrlen(szShortInfPathName) + lstrlen(pszHardwareID) + lstrlen(pszDisplayName) + 64);
	CleanUpFailedAllocSetHrMsg(pszCmd = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 
		dwLen * sizeof(TCHAR)));


	hr=StringCchPrintfEx(pszCmd,dwBuffLength,NULL,NULL,MISTSAFE_STRING_FLAGS,
	_T("rundll32 sysdm.cpl,UpdateDriver_RunDLL %s,%s,%d,%s"), 
	szShortInfPathName, pszHardwareID,0,pszDisplayName);

	CleanUpIfFailedAndSetHr(hr);

	// RunDLL
	LOG_Driver(_T("LaunchProcess(%s)"), pszCmd);
	CleanUpIfFailedAndSetHr(LaunchProcess(pszCmd, NULL, SW_NORMAL, TRUE));

	// Get resulting code
	HKEY hKeyReinstall;
	if (ERROR_SUCCESS == (lRet = OpenReinstallKey(&hKeyReinstall)))
	{
		dwSize = sizeof(dwStatus);
		if (ERROR_SUCCESS == (lRet = RegQueryValueEx(hKeyReinstall, _T("LastInstallStatus"), NULL, NULL, (LPBYTE)&dwStatus, &dwSize)))
		{
			if (3 == dwStatus)
			{
				//Check if we need to reboot
				HKEY hKeySysDM;
				*pdwReboot = 0;
				dwSize = sizeof(*pdwReboot);
				if (ERROR_SUCCESS == (lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SysDM"), 0, KEY_READ, &hKeySysDM)))
				{
					if (ERROR_SUCCESS != (lRet = RegQueryValueEx(hKeySysDM, "UpgradeDeviceFlags", NULL, NULL, (LPBYTE)&pdwReboot, &dwSize)))
					{
						LOG_ErrorMsg(lRet);
						hr = HRESULT_FROM_WIN32(lRet);
					}

					RegCloseKey(hKeySysDM);
				}
				else
				{
					LOG_ErrorMsg(lRet);
					hr = HRESULT_FROM_WIN32(lRet);
				}
			}
		}
		else
		{
			LOG_ErrorMsg(lRet);
			hr = HRESULT_FROM_WIN32(lRet);
		}

		LOG_Driver(_T("Reboot %srequired"), *pdwReboot ? _T(" ") : _T("not "));

		RegCloseKey(hKeyReinstall);
	}
	else
	{
		LOG_ErrorMsg(lRet);
		hr = HRESULT_FROM_WIN32(lRet);
	}

	// Finish no reboot
	CleanUpIfFailedAndSetHr(LaunchProcess(_T("rundll32 sysdm.cpl,UpdateDriver_Finish 2"), NULL, SW_NORMAL, TRUE));

	if (3 != dwStatus) 
	{
		LOG_Error("3 != dwStatus");
		hr = E_FAIL;
	}
	else
	{
		hr = S_OK;
	}


#endif // #if !(defined(_UNICODE) || defined(UNICODE))
CleanUp:

	SafeHeapFree(pszCmd);

	return hr;
}

//This function installs a driver on Windows NT.
// Its prototype is:
// BOOL
// InstallWindowsUpdateDriver(
//   HWND hwndParent,
//   LPCWSTR HardwareId,
//   LPCWSTR InfPathName,
//   LPCWSTR DisplayName,
//   BOOL Force,
//   BOOL Backup,
//   PDWORD pReboot
//   )
// This API takes a HardwareID.  Newdev will cycle through all devices that match this hardware ID
// and install the specified driver on them all.
// It also takes a BOOL value Backup which specifies whether or not to backup the current drivers.
// This should always be TRUE.
static HRESULT InstallNT(
	LPCTSTR pszHardwareID,	
	LPCTSTR pszLocalDir,			// passed to InstallWindowsUpdateDriver(... InfPathName, ...)
	LPCTSTR pszDisplayName,
	PDWORD pdwReboot		
	)
{
	USES_IU_CONVERSION;

	LOG_Block("InstallNT");

	//
	// InstallWindowsUpdateDriver function found in $(BASEDIR)\shell\osshell\cpls\newdev\init.c (not in any headers)
	//
	typedef BOOL (*PFN_InstallWindowsUpdateDriver)(HWND hwndParent, LPCWSTR HardwareId, LPCWSTR InfPathName, LPCWSTR DisplayName, BOOL Force, BOOL Backup, PDWORD pReboot);
	
	HRESULT hr = S_OK;
	HMODULE hLibModule = NULL;
	PFN_InstallWindowsUpdateDriver pfnInstallWindowsUpdateDriver;

	if (NULL == pdwReboot)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#if defined(DBG)
	// checked by caller
	if (NULL == pszHardwareID || NULL == pszLocalDir || NULL == pszDisplayName)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}
#endif


	// Load newdev.dll and get pointer to our function
	if (NULL == (hLibModule = LoadLibraryFromSystemDir(_T("newdev.dll"))))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}

	if (NULL == (pfnInstallWindowsUpdateDriver = (PFN_InstallWindowsUpdateDriver)GetProcAddress(hLibModule,"InstallWindowsUpdateDriver")))
	{
		Win32MsgSetHrGotoCleanup(GetLastError());
	}
		
	// Industry Update RAID # 461 waltw	May need to massage HWID's for site Driver Install for Win2K
	//
	// Linked to: RAID # 12021 in Windows Update Database - This logic (required for Win2K) is implemented
	// on the server rather than the client in IU (V3 Wuv3is implements this on the client)
	//
    // first, we search for a matching SPDRP_HARDWAREID
	// if we didn't find a Hardware ID, we search for a matching SPDRP_COMPATIBLEID, 
	// and we pass the last SPDRP_HARDWAREID associated with the same device.
#if (defined(UNICODE) || defined(_UNICODE))
    LOG_Driver (_T("InstallWindowsUpdateDriver(GetActiveWindow(), %s, %s, %s, fForce=%d, fBackup=%d)"), 
				pszHardwareID, pszLocalDir, pszDisplayName, FALSE, TRUE);
#endif
	// 
	// NOTES on calling InstallWindowsUpdateDriver():
	// * Never pass TRUE  in Force flag (only used if we are doing uninstall, which we don't support).
	// * Always pass TRUE in Backup flag.
	// * OK to cast away const-ness on strings since InstallWindowsUpdateDriver takes const wide strings
	if(!(pfnInstallWindowsUpdateDriver)(GetActiveWindow(),
				T2OLE(const_cast<TCHAR*>(pszHardwareID)),
				T2OLE(const_cast<TCHAR*>(pszLocalDir)),
				T2OLE(const_cast<TCHAR*>(pszDisplayName)), FALSE, TRUE, pdwReboot))
    {
        LOG_Driver(_T("InstallWindowsUpdateDriver returned false. Driver was not be updated."));
		Win32MsgSetHrGotoCleanup(GetLastError());
    }

CleanUp:

    if (NULL != hLibModule)
	{
		FreeLibrary(hLibModule);
		hLibModule = NULL;
	}

	return hr;
}

//
// MatchHardwareID (used only on Windows 2000)
//
// Takes as input a hardware or compatible ID and returns an allocated
// buffer with the same hardware ID or, if it was a compatible ID the
// most general hardware ID for the device node that matched the
// given compatible ID.
//
// Return: S_OK if a match was found, else a failure code
//
// *ppszMatchingHWID must be NULL on entry, and if S_OK is returned
// the buffer must be heap-freed by the caller.
//
HRESULT MatchHardwareID(LPCWSTR pwszHwOrCompatID, LPWSTR * ppszMatchingHWID)
{
	LOG_Block("MatchHardwareID");

	HRESULT hr = E_FAIL;

    SP_DEVINFO_DATA DeviceInfoData;
    DWORD           dwIndex = 0;
    DWORD           dwSize = 0;

    LPWSTR          pwszHardwareIDList = NULL;
    LPWSTR          pwszCompatibleIDList = NULL;
    LPWSTR          pwszSingleID = NULL;

    HDEVINFO		hDevInfo = INVALID_HANDLE_VALUE;
	BOOL			fRet;

    ZeroMemory((void*)&DeviceInfoData, sizeof(SP_DEVINFO_DATA));
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

	if (NULL == pwszHwOrCompatID || NULL == ppszMatchingHWID || NULL != *ppszMatchingHWID)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	// get a handle to the class devices
    hDevInfo = SetupDiGetClassDevs(NULL,
                                   NULL,
                                   GetActiveWindow(),
                                   DIGCF_ALLCLASSES | DIGCF_PRESENT
                                   );

    if (INVALID_HANDLE_VALUE == hDevInfo)
	{
		Win32MsgSetHrGotoCleanup(ERROR_INVALID_HANDLE);
    }

    //loop through all devices
	DWORD dwBufLen=0;
	while ((NULL == *ppszMatchingHWID) && SetupDiEnumDeviceInfo(hDevInfo,
								 dwIndex++,
								 &DeviceInfoData
								 ))
	{
		//
		// Free up buffers for each device node loop (if allocated)
		//
		SafeHeapFree(pwszHardwareIDList);
		SafeHeapFree(pwszCompatibleIDList);
		dwSize = 0;
		//
		// Get the list of Hardware Ids for this device
		//
		fRet = SetupDiGetDeviceRegistryPropertyW(hDevInfo,
										 &DeviceInfoData,
										 SPDRP_HARDWAREID,
										 NULL,
										 NULL,
										 0,
										 &dwSize
										 );

		if (0 == dwSize || (FALSE == fRet && ERROR_INSUFFICIENT_BUFFER != GetLastError()))
		{
			//
			// FIX: NTRAID#NTBUG9-500223-2001/11/28- IU - Dual mode USB camera install fails while installing of web site
			//
			// If we hit a node without a HWID before finding device node we are looking for, just continue. If the node
			// we ARE looking for doesn't have a HWID then we will fail later anyway when we run out of nodes.
			//
 			LOG_Out(_T("No HWID's found for device node"));
			continue;
		}

		if (MAX_SETUP_MULTI_SZ_SIZE_W < dwSize)
		{
			//
			// Something is very wrong - bail
			//
			CleanUpIfFailedAndSetHrMsg(ERROR_INSUFFICIENT_BUFFER);
		}

		//
		// We got the expected ERROR_INSUFFICIENT_BUFFER with a reasonable dwSize
		//
		// Now guarantee we are double-NULL terminated by allocating two extra WCHARs we don't tell SetupDi about
		//
		pwszHardwareIDList = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + (sizeof(WCHAR) * 2));
		CleanUpFailedAllocSetHrMsg(pwszHardwareIDList);

		if (SetupDiGetDeviceRegistryPropertyW(hDevInfo,
											 &DeviceInfoData,
											 SPDRP_HARDWAREID,
											 NULL,
											 (PBYTE)pwszHardwareIDList,
											 dwSize,
											 &dwSize
											 ))
		{
			//
			// If any of the devices HardwareIDs match the input ID then
			// we copy the incoming argument to a new buffer and return true 
			//
          
			for (pwszSingleID = pwszHardwareIDList;
				 *pwszSingleID;
				 pwszSingleID += lstrlenW(pwszSingleID) + 1)
			{

				if (0 == lstrcmpiW(pwszSingleID, pwszHwOrCompatID))
				{
                    // return the hardware ID we matched
					dwBufLen=(lstrlenW(pwszHwOrCompatID) + 1);
                    *ppszMatchingHWID = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
									dwBufLen * sizeof(WCHAR));
					CleanUpFailedAllocSetHrMsg(*ppszMatchingHWID);
                   
					hr=StringCchCopyExW(*ppszMatchingHWID,dwBufLen,pwszHwOrCompatID,NULL,NULL,MISTSAFE_STRING_FLAGS);
				     goto CleanUp;
				}
			}
		}

		//
		// Hardware match not found, let's try to match to a
		// compatible ID then return the (most generic) Hardware ID 
		// associated with the same device node
		//
		fRet = SetupDiGetDeviceRegistryPropertyW(hDevInfo,
										 &DeviceInfoData,
										 SPDRP_COMPATIBLEIDS,
										 NULL,
										 NULL,
										 0,
										 &dwSize
										 );

		if (0 == dwSize || (FALSE == fRet && ERROR_INSUFFICIENT_BUFFER != GetLastError()))
		{
 			LOG_Out(_T("No Compatible ID's found for device node"));
			continue;
		}

		if (MAX_SETUP_MULTI_SZ_SIZE_W < dwSize)
		{
			//
			// Something is very wrong - bail
			//
			CleanUpIfFailedAndSetHrMsg(ERROR_INSUFFICIENT_BUFFER);
		}

		//
		// We got the expected ERROR_INSUFFICIENT_BUFFER with a reasonable dwSize
		//
		// Now guarantee we are double-NULL terminated by allocating two extra WCHARs we don't tell SetupDi about
		//
		pwszCompatibleIDList = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + (sizeof(WCHAR) * 2));
		CleanUpFailedAllocSetHrMsg(pwszCompatibleIDList);

		if (SetupDiGetDeviceRegistryPropertyW(hDevInfo,
												 &DeviceInfoData,
												 SPDRP_COMPATIBLEIDS,
												 NULL,
												 (PBYTE)pwszCompatibleIDList,
												 dwSize,
												 &dwSize
												 ))
		{
			for (pwszSingleID = pwszCompatibleIDList;
				 *pwszSingleID;
				 pwszSingleID += lstrlenW(pwszSingleID) + 1)
			{

				if (0 == lstrcmpiW(pwszSingleID, pwszHwOrCompatID))
				{
					//
					// We found a compatible match, now return the most general HWID
					// for this device node. Must be at least one character long.
					//
					if (NULL != pwszHardwareIDList && NULL != *pwszHardwareIDList)
					{
						LPWSTR lpwszLastID = NULL;

						for(pwszSingleID = pwszHardwareIDList;
							 *pwszSingleID;
							 pwszSingleID += lstrlenW(pwszSingleID) + 1)
						{
							//
							// Remember last ID before NULL string
							//
							lpwszLastID = pwszSingleID;
						}

						// copy the last HWID into a new buffer
						dwBufLen=(lstrlenW(lpwszLastID) + 1);
						*ppszMatchingHWID = (LPWSTR) HeapAlloc(GetProcessHeap(), 0,
											dwBufLen * sizeof(WCHAR));
						CleanUpFailedAllocSetHrMsg(*ppszMatchingHWID);
						hr=StringCchCopyExW(*ppszMatchingHWID,dwBufLen,lpwszLastID,NULL,NULL,MISTSAFE_STRING_FLAGS);
						goto CleanUp;
					}
				}
			}
		}
    }	// end while

	
CleanUp:
	
	if (INVALID_HANDLE_VALUE != hDevInfo)
	{
	    SetupDiDestroyDeviceInfoList(hDevInfo);
	}

	//
	// Free up any allocated buffers (except *ppszMatchingHWID)
	//
	if(FAILED(hr))
	{
		SafeHeapFree(*ppszMatchingHWID);
	}

	SafeHeapFree(pwszHardwareIDList);
	SafeHeapFree(pwszCompatibleIDList);

	return hr;
}

//This function handles installation of a Device driver package.
HRESULT InstallDriver(
	LPCTSTR pszLocalDir,				// Local directory where installation files are.
	LPCTSTR pszDisplayName,				// Description of package, Device Manager displays this in its install dialog.
	LPCTSTR pszHardwareID,				// ID from XML matched to client hardware via GetManifest()
	DWORD* pdwStatus
	)
{
	LOG_Block("InstallDriver");
	USES_IU_CONVERSION;

	HRESULT hr;
	OSVERSIONINFO osvi;
	DWORD dwReboot = 0;
	LPWSTR pszwMatchingHWID = NULL;

	if (NULL == pszLocalDir || NULL == pszDisplayName || NULL == pszHardwareID || NULL == pdwStatus)
	{
		SetHrMsgAndGotoCleanUp(E_INVALIDARG);
	}

	//
	// DecompressFolderCabs may return S_FALSE if it didn't find a cab to decompress...
	//
	hr = DecompressFolderCabs(pszLocalDir);
	if (S_OK != hr)
	{
		CleanUpIfFailedAndSetHr(E_FAIL);
	}
	
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId && 4 < osvi.dwMajorVersion)
	{
		//
		// Win2K or higher NT
		//
		if (5 == osvi.dwMajorVersion && 0 == osvi.dwMinorVersion)
		{
			//
			// Windows 2000
			// NTBUG9-485554 Convert compatible IDs to hardware IDs for site Driver Install for Win2K
			//
			// OK to cast away const-ness on string params so T2OLE works, since it doesn't modify them anyway
			CleanUpIfFailedAndSetHr(MatchHardwareID(T2OLE((LPTSTR)pszHardwareID), &pszwMatchingHWID));

			hr = InstallNT(OLE2T(pszwMatchingHWID), pszLocalDir, pszDisplayName, &dwReboot);

			// pszMatchingHWID must be non-null if we got here
			SafeHeapFree(pszwMatchingHWID);
		}
		else
		{
			//
			// Normal case, just install
			//
			CleanUpIfFailedAndSetHr(InstallNT(pszHardwareID, pszLocalDir, pszDisplayName, &dwReboot));
		}
	}
	else if (VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId && 
			(4 < osvi.dwMajorVersion)	||
					(	(4 == osvi.dwMajorVersion) &&
						(0 < osvi.dwMinorVersion)	)	)
	{
		//
		// Win98 or higher (WinME)
		//
		CleanUpIfFailedAndSetHr(Install98(pszHardwareID, pszLocalDir, pszDisplayName, &dwReboot));
	}
	else
	{
		*pdwStatus = ITEM_STATUS_FAILED;
		SetHrMsgAndGotoCleanUp(E_NOTIMPL);
	}

	if (DI_NEEDRESTART & dwReboot || DI_NEEDREBOOT & dwReboot)
		*pdwStatus = ITEM_STATUS_SUCCESS_REBOOT_REQUIRED;
	else
		*pdwStatus = ITEM_STATUS_SUCCESS;

CleanUp:

	if (FAILED(hr))
	{
        if (NULL != pdwStatus)
        {
	    	*pdwStatus = ITEM_STATUS_FAILED;
        }
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.download

TARGETNAME=download
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
        download.cpp \
        dlutil.cpp \
        dlhttp.cpp \
        dlcache.cpp \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\dlutil.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <tchar.h>
#include <winhttp.h>
#include "iucommon.h"
#include "logging.h"
#include "download.h"
#include "dlutil.h"
#include "malloc.h"

#include "wusafefn.h"

///////////////////////////////////////////////////////////////////////////////
// 

typedef BOOL  (WINAPI *pfn_OpenProcessToken)(HANDLE, DWORD, PHANDLE);
typedef BOOL  (WINAPI *pfn_OpenThreadToken)(HANDLE, DWORD, BOOL, PHANDLE);
typedef BOOL  (WINAPI *pfn_SetThreadToken)(PHANDLE, HANDLE);
typedef BOOL  (WINAPI *pfn_GetTokenInformation)(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD);
typedef BOOL  (WINAPI *pfn_IsValidSid)(PSID);
typedef BOOL  (WINAPI *pfn_AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, PSID);
typedef BOOL  (WINAPI *pfn_EqualSid)(PSID, PSID);
typedef PVOID (WINAPI *pfn_FreeSid)(PSID);

const TCHAR c_szRPWU[]        = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
const TCHAR c_szRVTransport[] = _T("DownloadTransport");
const TCHAR c_szAdvapi32[]    = _T("advapi32.dll");

// ***************************************************************************
static
BOOL AmIPrivileged(void)
{
    LOG_Block("AmINotPrivileged()");

    pfn_AllocateAndInitializeSid    pfnAllocateAndInitializeSid = NULL;
    pfn_GetTokenInformation         pfnGetTokenInformation = NULL;
    pfn_OpenProcessToken            pfnOpenProcessToken = NULL;
    pfn_OpenThreadToken             pfnOpenThreadToken = NULL;
    pfn_SetThreadToken              pfnSetThreadToken = NULL;
    pfn_IsValidSid                  pfnIsValidSid = NULL;
    pfn_EqualSid                    pfnEqualSid = NULL;
    pfn_FreeSid                     pfnFreeSid = NULL;
    HMODULE                         hmod = NULL;
    
    SID_IDENTIFIER_AUTHORITY        siaNT = SECURITY_NT_AUTHORITY;
    TOKEN_USER                      *ptu = NULL;
    HANDLE                          hToken = NULL, hTokenImp = NULL;
    DWORD                           cb, cbGot, i;
    PSID                            psid = NULL;
    BOOL                            fRet = FALSE;

    DWORD                           rgRIDs[3] = { SECURITY_LOCAL_SYSTEM_RID,
                                                  SECURITY_LOCAL_SERVICE_RID,
                                                  SECURITY_NETWORK_SERVICE_RID };

    hmod = LoadLibraryFromSystemDir(c_szAdvapi32);
    if (hmod == NULL)
        goto done;

    pfnAllocateAndInitializeSid = (pfn_AllocateAndInitializeSid)GetProcAddress(hmod, "AllocateAndInitializeSid");
    pfnGetTokenInformation      = (pfn_GetTokenInformation)GetProcAddress(hmod, "GetTokenInformation");
    pfnOpenProcessToken         = (pfn_OpenProcessToken)GetProcAddress(hmod, "OpenProcessToken");
    pfnOpenThreadToken          = (pfn_OpenThreadToken)GetProcAddress(hmod, "OpenThreadToken");
    pfnSetThreadToken           = (pfn_SetThreadToken)GetProcAddress(hmod, "SetThreadToken");
    pfnIsValidSid               = (pfn_IsValidSid)GetProcAddress(hmod, "IsValidSid");
    pfnEqualSid                 = (pfn_EqualSid)GetProcAddress(hmod, "EqualSid");
    pfnFreeSid                  = (pfn_FreeSid)GetProcAddress(hmod, "FreeSid");
    if (pfnAllocateAndInitializeSid == NULL || 
        pfnGetTokenInformation == NULL || 
        pfnOpenProcessToken == NULL ||
        pfnOpenThreadToken == NULL ||
        pfnSetThreadToken == NULL ||
        pfnIsValidSid == NULL ||
        pfnEqualSid == NULL ||
        pfnFreeSid == NULL)
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        goto done;
    }

    // need the process token
    fRet = (*pfnOpenProcessToken)(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (fRet == FALSE)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            fRet = (*pfnOpenThreadToken)(GetCurrentThread(), 
                                         TOKEN_READ | TOKEN_IMPERSONATE,
                                         TRUE, &hTokenImp);
            if (fRet == FALSE)
                goto done;

            fRet = (*pfnSetThreadToken)(NULL, NULL);

            fRet = (*pfnOpenProcessToken)(GetCurrentProcess(), TOKEN_READ, 
                                          &hToken);
            if ((*pfnSetThreadToken)(NULL, hTokenImp) == FALSE)
                fRet = FALSE;
        }

        if (fRet == FALSE)
            goto done;
    }

    // need the SID from the token
    fRet = (*pfnGetTokenInformation)(hToken, TokenUser, NULL, 0, &cb);
    if (fRet != FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        fRet = FALSE;
        goto done;
    }

    ptu = (TOKEN_USER *)HeapAlloc(GetProcessHeap(), 0, cb);
    if (ptu == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        fRet = FALSE;
        goto done;
    }

    fRet = (*pfnGetTokenInformation)(hToken, TokenUser, (LPVOID)ptu, cb, 
                                     &cbGot);
    if (fRet == FALSE)
        goto done;

    fRet = (*pfnIsValidSid)(ptu->User.Sid);
    if (fRet == FALSE)
        goto done;

    // loop thru & check against the SIDs we are interested in
    for (i = 0; i < 3; i++)
    {
        fRet = (*pfnAllocateAndInitializeSid)(&siaNT, 1, rgRIDs[i], 0, 0, 0, 
                                              0, 0, 0, 0, &psid);
        if (fRet == FALSE)
            goto done;

        fRet = (*pfnIsValidSid)(psid);
        if (fRet == FALSE)
            goto done;

        // if we get a SID match, then return TRUE
        fRet = (*pfnEqualSid)(psid, ptu->User.Sid);
        (*pfnFreeSid)(psid);
        psid = NULL;
        if (fRet)
        {
            fRet = TRUE;
            goto done;
        }
    }

    // only way to get here is to fail all the SID checks above.  So we ain't
    //  privileged.  Yeehaw.
    fRet = FALSE;
    
done:
    // if we had an impersonation token on the thread, put it back in place.
    if (ptu != NULL)
        HeapFree(GetProcessHeap(), 0, ptu);
    if (hToken != NULL)
        CloseHandle(hToken);
    if (hTokenImp != NULL)
        CloseHandle(hTokenImp);
    if (psid != NULL && pfnFreeSid != NULL)
        (*pfnFreeSid)(psid);
    if (hmod != NULL)
        FreeLibrary(hmod);

    return fRet;
}

#if defined(DEBUG) || defined(DBG)

// **************************************************************************
static
BOOL CheckDebugRegKey(DWORD *pdwAllowed)
{
    LOG_Block("CheckDebugRegKey()");

    DWORD   dw, dwType, dwValue, cb;
    HKEY    hkey = NULL;
    BOOL    fRet = FALSE;

    // explictly do not initialize *pdwAllowed.  We only want it overwritten
    //  if the reg key is properly set

    dw = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRPWU, 0, KEY_READ, &hkey);
    if (dw != ERROR_SUCCESS)
        goto done;

    cb = sizeof(dwValue);
    dw = RegQueryValueEx(hkey, c_szRVTransport, 0, &dwType, (LPBYTE)&dwValue, 
                         &cb);
    if (dw != ERROR_SUCCESS)
        goto done;

    // set this to 3 so we'll fall down into the error case below
    if (dwType != REG_DWORD)
        dwValue = 3;
    
    fRet = TRUE;

    switch(dwValue)
    {
        case 0:
            *pdwAllowed = 0;
            break;

        case 1:
            *pdwAllowed = WUDF_ALLOWWINHTTPONLY;
            break;

        case 2:
            *pdwAllowed = WUDF_ALLOWWININETONLY;
            break;

        default:
            LOG_Internet(_T("Bad reg value in DownloadTransport.  Ignoring."));
            fRet = FALSE;
            break;
    }

done:
    if (hkey != NULL)
        RegCloseKey(hkey);

    return fRet;
}

#endif

// **************************************************************************
DWORD GetAllowedDownloadTransport(DWORD dwFlagsInitial)
{
    DWORD   dwFlags = (dwFlagsInitial & WUDF_TRANSPORTMASK);

#if defined(UNICODE)
    // don't bother checking if we're local system if we're already using
    //  wininet
    if ((dwFlags & WUDF_ALLOWWININETONLY) == 0)
    {
        if (AmIPrivileged() == FALSE)
            dwFlags = WUDF_ALLOWWININETONLY;
    }

#if defined(DEBUG) || defined(DBG)
    CheckDebugRegKey(&dwFlags);
#endif // defined(DEBUG) || defined(DBG)

#else // defined(UNICODE)

    // only allow wininet on ANSI
    dwFlags = WUDF_ALLOWWININETONLY;

#endif // defined(UNICODE)

    return (dwFlags | (dwFlagsInitial & ~WUDF_TRANSPORTMASK));
}

///////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
static inline
BOOL IsServerFileDifferentWorker(FILETIME &ftServerTime, 
                                 DWORD dwServerFileSize, HANDLE hFile)
{
    LOG_Block("IsServerFileNewerWorker()");

    FILETIME    ftCreateTime;
    DWORD       cbLocalFile;

    // By default, always return TRUE so we can download a new file..
	BOOL        fRet = TRUE;

    // if we don't have a valid file handle, just return TRUE to download a 
    //  new copy
    if (hFile == INVALID_HANDLE_VALUE)
        goto done;

    cbLocalFile = GetFileSize(hFile, NULL);

	LOG_Internet(_T("IsServerFileNewer: Local size: %d.  Remote size: %d"),
				 cbLocalFile, dwServerFileSize);

    // if the sizes are not equal, then return TRUE
	if (cbLocalFile != dwServerFileSize)
	    goto done;

	if (GetFileTime(hFile, &ftCreateTime, NULL, NULL))
	{
		LOG_Internet(_T("IsServerFileNewer: Local time: %x%0x.  Remote time: %x%0x."),
					 ftCreateTime.dwHighDateTime, ftCreateTime.dwLowDateTime,
					 ftServerTime.dwHighDateTime, ftServerTime.dwLowDateTime);

		// if the local file has a different timestamp, then return TRUE.  
		fRet = (CompareFileTime(&ftCreateTime, &ftServerTime) != 0);
	}

done:
    return fRet;
}

// **************************************************************************
BOOL IsServerFileDifferentW(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                            LPCWSTR wszLocalFile)
{
    LOG_Block("IsServerFileDifferentW()");

    HANDLE  hFile = INVALID_HANDLE_VALUE;
    BOOL    fRet = TRUE;

    // if we have an error opening the file, just return TRUE to download a 
    //  new copy
    hFile = CreateFileW(wszLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOG_Internet(_T("IsServerFileDifferent: %ls does not exist."), wszLocalFile);
        return TRUE;
    }
    else
    {
        fRet = IsServerFileDifferentWorker(ftServerTime, dwServerFileSize, hFile);
        CloseHandle(hFile);
        return fRet;
    }
}

// **************************************************************************
BOOL IsServerFileDifferentA(FILETIME &ftServerTime, DWORD dwServerFileSize, 
                            LPCSTR szLocalFile)
{
    LOG_Block("IsServerFileDifferentA()");

    HANDLE hFile = INVALID_HANDLE_VALUE;

    // if we have an error opening the file, just return TRUE to download a 
    //  new copy
    hFile = CreateFileA(szLocalFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        LOG_Internet(_T("IsServerFileDifferent: %s does not exist."), szLocalFile);
        return TRUE;
    }
    else
    {
        BOOL fRet;
        fRet = IsServerFileDifferentWorker(ftServerTime, dwServerFileSize, hFile);
        CloseHandle(hFile);
        return fRet;
    }
}

// **************************************************************************
// helper function to handle quit events
//
// return TRUE if okay to continue
// return FALSE if we should quit now!
BOOL HandleEvents(HANDLE *phEvents, UINT nEventCount)
{
    LOG_Block("HandleEvents()");

    DWORD dwWait;

    // is there any events to handle?
    if (phEvents == NULL || nEventCount == 0)
        return TRUE;

    // we only want to check the signaled status, so don't bother waiting
    dwWait = WaitForMultipleObjects(nEventCount, phEvents, FALSE, 0);

    if (dwWait == WAIT_TIMEOUT)
    {
        return TRUE;
    }
    else
    {
        LOG_Internet(_T("HandleEvents: A quit event was signaled.  Aborting..."));
        return FALSE;
    }
}


///////////////////////////////////////////////////////////////////////////////
// 

// **************************************************************************
HRESULT PerformDownloadToFile(pfn_ReadDataFromSite pfnRead,
                              HINTERNET hRequest, 
                              HANDLE hFile, DWORD cbFile,
                              DWORD cbBuffer,
                              HANDLE *rghEvents, DWORD cEvents,
                              PFNDownloadCallback fpnCallback, LPVOID pCallbackData,
                              DWORD *pcbDownloaded)
{
    LOG_Block("PerformDownloadToFile()");

    HRESULT hr = S_OK;
    PBYTE   pbBuffer = NULL;
    DWORD   cbDownloaded = 0, cbRead, cbWritten;
    LONG    lCallbackRequest = 0;

    pbBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbBuffer);
    if (pbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto done;
    }

    // Download the File
    for(;;)
    {
        if ((*pfnRead)(hRequest, pbBuffer, cbBuffer, &cbRead) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (FAILED(hr))
            {
                LOG_ErrorMsg(hr);
                goto done;
            }
        }
            
        if (cbRead == 0)
        {
            BYTE bTemp[32];
            
            // Make one final call to WinHttpReadData to commit the file to
            //  Cache.  (the download is not complete otherwise)
            (*pfnRead)(hRequest, bTemp, ARRAYSIZE(bTemp), &cbRead);
            break;
        }
        
        cbDownloaded += cbRead;

        if (fpnCallback != NULL)
        {
            fpnCallback(pCallbackData, DOWNLOAD_STATUS_OK, cbFile, cbRead, NULL, 
                        &lCallbackRequest);
            if (lCallbackRequest == 4)
            {
                // QuitEvent was Signaled.. abort requested. We will do 
                //  another callback and pass the Abort State back
                fpnCallback(pCallbackData, DOWNLOAD_STATUS_ABORTED, cbFile, cbRead, NULL, NULL);
                
                hr = E_ABORT; // set return result to abort.
                goto done;
            }
        }

        if (WriteFile(hFile, pbBuffer, cbRead, &cbWritten, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto done;
        }

        if (HandleEvents(rghEvents, cEvents) == FALSE)
        {
            // we need to quit the download clean up, send abort event and clean up what we've downloaded
            if (fpnCallback != NULL)
                fpnCallback(pCallbackData, DOWNLOAD_STATUS_ABORTED, cbFile, cbRead, NULL, NULL);

            hr = E_ABORT; // set return result to abort.
            goto done;
        }
    }

    if (pcbDownloaded != NULL)
        *pcbDownloaded = cbDownloaded;

done:
    SafeHeapFree(pbBuffer);

    return hr;

}


///////////////////////////////////////////////////////////////////////////////
//

struct MY_OSVERSIONINFOEX
{
    OSVERSIONINFOEX osvi;
    LCID            lcidCompare;
};
static MY_OSVERSIONINFOEX g_myosvi;
static BOOL               g_fInit = FALSE;

// **************************************************************************
// Loads the current OS version info if needed, and returns a pointer to
//  a cached copy of it.
const OSVERSIONINFOEX* GetOSVersionInfo(void)
{
    if (g_fInit == FALSE)
    {
        OSVERSIONINFOEX* pOSVI = &g_myosvi.osvi;
        
        g_myosvi.osvi.dwOSVersionInfoSize = sizeof(g_myosvi.osvi);
        GetVersionEx((OSVERSIONINFO*)&g_myosvi.osvi);

        // WinXP-specific stuff
        if ((pOSVI->dwMajorVersion > 5) || 
            (pOSVI->dwMajorVersion == 5 && pOSVI->dwMinorVersion >= 1))
            g_myosvi.lcidCompare = LOCALE_INVARIANT;
        else
            g_myosvi.lcidCompare = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

        g_fInit = TRUE;
    }
    
    return &g_myosvi.osvi;
}

// **************************************************************************
// String lengths can be -1 if the strings are null-terminated.
int LangNeutralStrCmpNIA(LPCSTR psz1, int cch1, LPCSTR psz2, int cch2)
{
    if (g_fInit == FALSE)
        GetOSVersionInfo();

    int nCompare = CompareStringA(g_myosvi.lcidCompare,
                                  NORM_IGNORECASE,
                                  psz1, cch1,
                                  psz2, cch2);

    return (nCompare - 2); // convert from (1, 2, 3) to (-1, 0, 1)
}

// **************************************************************************
// Finds the first instance of pszSearchFor in pszSearchIn, case-insensitive.
//  Returns an index into pszSearchIn if found, or -1 if not.
//  You can pass -1 for either or both of the lengths.
int LangNeutralStrStrNIA(LPCSTR pszSearchIn, int cchSearchIn, 
                         LPCSTR pszSearchFor, int cchSearchFor)
{
    char chLower, chUpper;
    
    if (cchSearchIn == -1)
        cchSearchIn = lstrlenA(pszSearchIn);
    if (cchSearchFor == -1)
        cchSearchFor = lstrlenA(pszSearchFor);

    // Note: since this is lang-neutral, we can assume no DBCS search chars
    chLower = (char)CharLowerA(MAKEINTRESOURCEA(*pszSearchFor));
    chUpper = (char)CharUpperA(MAKEINTRESOURCEA(*pszSearchFor));

    // Note: since search-for is lang-neutral, we can ignore any DBCS chars 
    //        in search-in
    for (int ichIn = 0; ichIn <= cchSearchIn - cchSearchFor; ichIn++)
    {
        if (pszSearchIn[ichIn] == chLower || pszSearchIn[ichIn] == chUpper)
        {
            if (LangNeutralStrCmpNIA(pszSearchIn + ichIn + 1, cchSearchFor - 1, 
                                     pszSearchFor + 1, cchSearchFor - 1) == 0)
            {
                return ichIn;
            }
        }
    }

    return -1;
}

// **************************************************************************
// Opens the given file and looks for "<html" (case-insensitive) within the
//  first 200 characters. If there are any binary chars before "<html", the
//  file is assumed to *not* be HTML.
// Returns S_OK if so, S_FALSE if not, or an error if file couldn't be opened.
HRESULT IsFileHtml(LPCTSTR pszFileName)
{
    LOG_Block("IsFileHtml()");

    HRESULT hr = S_FALSE;
    LPCSTR  pszFile;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hMapping = NULL;
    LPVOID  pvMem = NULL;
    DWORD   cbFile;

    hFile = CreateFile(pszFileName, GENERIC_READ, 
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0)
        goto done;

    // Only examine the 1st 200 bytes
    if (cbFile > 200)
        cbFile = 200;

    hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, cbFile, NULL);
    if (hMapping == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    pvMem = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, cbFile);
    if (pvMem == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    pszFile = (LPCSTR)pvMem;
    int ichHtml = LangNeutralStrStrNIA(pszFile, cbFile, "<html", 5);
    if (ichHtml != -1)
    {
        // Looks like html...
        hr = S_OK;

        // Just make sure there aren't any binary chars before the <HTML> tag
        for (int ich = 0; ich < ichHtml; ich++)
        {
            char ch = pszFile[ich];
            if (ch < 32 && ch != '\t' && ch != '\r' && ch != '\n')
            {
                // Found a binary character (before <HTML>)
                hr = S_FALSE;
                break;
            }
        }
    }

done:
    if (pvMem != NULL)
        UnmapViewOfFile(pvMem);
    if (hMapping != NULL)
        CloseHandle(hMapping);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\install\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	detect
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=install
#TARGETPATH=$(_IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=0

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);..\..\..\inc

SOURCES= \
	drvinst.cpp \
        install.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\download\download.cpp ===
#include <windows.h>
#include <wininet.h>
#include <shlwapi.h>
#include <logging.h>
#include "iucommon.h"
#include "download.h"
#include "dlutil.h"

#include "trust.h"
#include "fileutil.h"
#include "malloc.h"

extern "C"
{
// wininet 
typedef BOOL      (STDAPICALLTYPE *pfn_InternetCrackUrl)(LPCTSTR, DWORD, DWORD, LPURL_COMPONENTS);
typedef HINTERNET (STDAPICALLTYPE *pfn_InternetOpen)(LPCTSTR, DWORD, LPCTSTR, LPCTSTR, DWORD);
typedef HINTERNET (STDAPICALLTYPE *pfn_InternetConnect)(HINTERNET, LPCTSTR, INTERNET_PORT, LPCTSTR, LPCTSTR, DWORD, DWORD, DWORD_PTR);
typedef HINTERNET (STDAPICALLTYPE *pfn_HttpOpenRequest)(HINTERNET, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR FAR *, DWORD, DWORD_PTR);
typedef BOOL      (STDAPICALLTYPE *pfn_HttpSendRequest)(HINTERNET, LPCTSTR, DWORD, LPVOID, DWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_HttpQueryInfo)(HINTERNET, DWORD, LPVOID, LPDWORD, LPDWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_InternetReadFile)(HINTERNET, LPVOID, DWORD, LPDWORD);
typedef BOOL      (STDAPICALLTYPE *pfn_InternetCloseHandle)(HINTERNET);
};


struct SWinInetFunctions
{
    // wininet function pointers
    pfn_InternetCrackUrl    pfnInternetCrackUrl;
    pfn_InternetOpen        pfnInternetOpen;
    pfn_InternetConnect     pfnInternetConnect;
    pfn_HttpOpenRequest     pfnHttpOpenRequest;
    pfn_HttpSendRequest     pfnHttpSendRequest;
    pfn_HttpQueryInfo       pfnHttpQueryInfo;
    pfn_InternetReadFile    pfnInternetReadFile;
    pfn_InternetCloseHandle pfnInternetCloseHandle;
    HMODULE                 hmod;
};

#define SafeInternetCloseHandle(sfns, x) if (NULL != x) { (*sfns.pfnInternetCloseHandle)(x); x = NULL; }

// **************************************************************************
BOOL LoadWinInetFunctions(HMODULE hmod, SWinInetFunctions *psfns)
{
    LOG_Block("LoadWinInetFunctions()");

    BOOL    fRet = FALSE;

    psfns->hmod                   = hmod;
#if defined(UNICODE)
    psfns->pfnInternetCrackUrl    = (pfn_InternetCrackUrl)GetProcAddress(hmod, "InternetCrackUrlW");
    psfns->pfnInternetOpen        = (pfn_InternetOpen)GetProcAddress(hmod, "InternetOpenW");
    psfns->pfnInternetConnect     = (pfn_InternetConnect)GetProcAddress(hmod, "InternetConnectW");
    psfns->pfnHttpOpenRequest     = (pfn_HttpOpenRequest)GetProcAddress(hmod, "HttpOpenRequestW");
    psfns->pfnHttpSendRequest     = (pfn_HttpSendRequest)GetProcAddress(hmod, "HttpSendRequestW");
    psfns->pfnHttpQueryInfo       = (pfn_HttpQueryInfo)GetProcAddress(hmod, "HttpQueryInfoW");
    psfns->pfnInternetReadFile    = (pfn_InternetReadFile)GetProcAddress(hmod, "InternetReadFile");
    psfns->pfnInternetCloseHandle = (pfn_InternetCloseHandle)GetProcAddress(hmod, "InternetCloseHandle");
#else
    psfns->pfnInternetCrackUrl    = (pfn_InternetCrackUrl)GetProcAddress(hmod, "InternetCrackUrlA");
    psfns->pfnInternetOpen        = (pfn_InternetOpen)GetProcAddress(hmod, "InternetOpenA");
    psfns->pfnInternetConnect     = (pfn_InternetConnect)GetProcAddress(hmod, "InternetConnectA");
    psfns->pfnHttpOpenRequest     = (pfn_HttpOpenRequest)GetProcAddress(hmod, "HttpOpenRequestA");
    psfns->pfnHttpSendRequest     = (pfn_HttpSendRequest)GetProcAddress(hmod, "HttpSendRequestA");
    psfns->pfnHttpQueryInfo       = (pfn_HttpQueryInfo)GetProcAddress(hmod, "HttpQueryInfoA");
    psfns->pfnInternetReadFile    = (pfn_InternetReadFile)GetProcAddress(hmod, "InternetReadFile");
    psfns->pfnInternetCloseHandle = (pfn_InternetCloseHandle)GetProcAddress(hmod, "InternetCloseHandle");
#endif
    if (psfns->pfnInternetCrackUrl == NULL || 
        psfns->pfnInternetOpen == NULL ||
        psfns->pfnInternetConnect == NULL || 
        psfns->pfnHttpOpenRequest == NULL ||
        psfns->pfnHttpSendRequest == NULL || 
        psfns->pfnHttpQueryInfo == NULL ||
        psfns->pfnInternetReadFile == NULL || 
        psfns->pfnInternetCloseHandle == NULL)
    {
        // don't free the library here.  It should be freed 
        SetLastError(ERROR_PROC_NOT_FOUND);
        ZeroMemory(psfns, sizeof(SWinInetFunctions));
        goto done;
    }

    LOG_Internet(_T("Successfully loaded WinInet functions"));

    fRet = TRUE;

done:
    return fRet;
}

// **************************************************************************
static
HRESULT MakeRequest(SWinInetFunctions   &sfns,
                    HINTERNET hConnect, 
                    HINTERNET hRequest, 
                    LPCTSTR szVerb, 
                    LPCTSTR szObject, 
                    HANDLE *rghEvents, 
                    DWORD cEvents, 
                    HINTERNET *phRequest)
{
    LOG_Block("MakeRequest()");

    HINTERNET   hOpenRequest = NULL;
    LPCTSTR     szAcceptTypes[] = { _T("*/*"), NULL };
    HRESULT     hr = S_OK;

    LOG_Internet(_T("WinInet: Making %s request for %s"), szVerb, szObject);

    if (hRequest == NULL)
    {
        // Open a HEAD request to ask for information about this file
        hOpenRequest = (*sfns.pfnHttpOpenRequest)(hConnect, szVerb, szObject, NULL, NULL, 
                                                  szAcceptTypes, INTERNET_FLAG_KEEP_CONNECTION | INTERNET_FLAG_NO_UI, 0);
        if (!hOpenRequest)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
    }
    else
    {
        hOpenRequest = hRequest;
    }

    if (!HandleEvents(rghEvents, cEvents))
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    if (! (*sfns.pfnHttpSendRequest)(hOpenRequest, NULL, 0, NULL, 0) )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (HandleEvents(rghEvents, cEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    *phRequest   = hOpenRequest;
    hOpenRequest = NULL;
    
CleanUp:
    // don't want to free handle if we didn't open it.
    if (hRequest != hOpenRequest)
        SafeInternetCloseHandle(sfns, hOpenRequest);
    return hr;
}

// **************************************************************************
static
HRESULT GetContentTypeHeader(SWinInetFunctions &sfns,
                             HINTERNET hOpenRequest,
                             LPTSTR *pszContentType)
{
    LOG_Block("GetContentTypeHeader()");

    HRESULT hr = S_OK;
    LPTSTR  szContentType = NULL;
    DWORD   dwLength, dwErr;
    BOOL    fRet;

    *pszContentType = NULL;

    dwLength = 0;
    fRet = (*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_TYPE, 
                                    (LPVOID)NULL, &dwLength, NULL);
    if (fRet == FALSE && GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    if (dwLength == 0)
    {
        hr = HRESULT_FROM_WIN32(ERROR_HTTP_HEADER_NOT_FOUND);
        goto done;
    }

    szContentType = (LPTSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLength);
    if (szContentType == NULL)
    {
        hr = E_INVALIDARG;
        LOG_ErrorMsg(hr);
        goto done;
    }

    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_TYPE, 
                                 (LPVOID)szContentType, &dwLength, 
                                 NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto done;
    }

    *pszContentType = szContentType;
    szContentType   = NULL;

done:
    SafeHeapFree(szContentType);

    return hr;
}

// **************************************************************************
HRESULT StartWinInetDownload(HMODULE hmodWinInet,
                             LPCTSTR pszServerUrl, 
                             LPCTSTR pszLocalFile,
                             DWORD *pdwDownloadedBytes,
                             HANDLE *rghQuitEvents,
                             UINT cQuitEvents,
                             PFNDownloadCallback pfnCallback,
                             LPVOID pvCallbackData,
                             DWORD dwFlags,
                             DWORD cbDownloadBuffer)
{
    LOG_Block("StartWinInetDownload()");

    URL_COMPONENTS UrlComponents;
    
    SWinInetFunctions sfns;
    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect = NULL;
    HINTERNET   hOpenRequest = NULL;
    DWORD       dwStatus, dwAccessType;
    
    LPTSTR      pszServerName = NULL;
    LPTSTR      pszObject = NULL;
    LPTSTR      pszContentType = NULL;
    TCHAR       szUserName[UNLEN + 1];
    TCHAR       szPasswd[UNLEN + 1];
    TCHAR       szScheme[32];
    
    // NULL (equivalent to "GET") MUST be the last verb in the list
    LPCTSTR     rgszVerbs[] = { _T("HEAD"), NULL };
    DWORD       iVerb;
    
    HRESULT     hr = S_OK, hrToReturn = S_OK;
    BOOL        fRet = TRUE;

    SYSTEMTIME  st;
    FILETIME    ft;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    DWORD       cbRemoteFile = 0;

    DWORD       dwLength;
    DWORD       dwTickStart = 0, dwTickEnd = 0;
    
    int         iRetryCounter = -1;         // non-negative during download mode

    BOOL        fAllowProxy = ((dwFlags & WUDF_DONTALLOWPROXY) == 0);
    BOOL        fCheckStatusOnly = ((dwFlags & WUDF_CHECKREQSTATUSONLY) != 0);
    BOOL        fAppendCacheBreaker = ((dwFlags & WUDF_APPENDCACHEBREAKER) != 0);
    BOOL        fSkipDownloadRetry = ((dwFlags & WUDF_DODOWNLOADRETRY) == 0);
    BOOL        fDoCabValidation = ((dwFlags & WUDF_SKIPCABVALIDATION) == 0);
    
    ZeroMemory(&sfns, sizeof(sfns));

    if ((pszServerUrl == NULL) || 
        (pszLocalFile == NULL && fCheckStatusOnly == FALSE))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }
   
    if (NULL != pdwDownloadedBytes)
        *pdwDownloadedBytes = 0;

    if (LoadWinInetFunctions(hmodWinInet, &sfns) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        return hr;
    }

    pszServerName = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, c_cchMaxURLSize * sizeof(TCHAR));
    pszObject     = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, c_cchMaxURLSize * sizeof(TCHAR));
    if ((pszServerName == NULL) || (pszObject == NULL))
    {
        hr = E_OUTOFMEMORY;
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    pszServerName[0] = L'\0';
    pszObject[0]     = L'\0';
    szUserName[0]    = L'\0';
    szPasswd[0]      = L'\0';

    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }

    // Break down the URL into its various components for the InternetAPI calls.
    //  Specifically we need the server name, object to download, username and 
    //  password information.
    ZeroMemory(&UrlComponents, sizeof(UrlComponents));
    UrlComponents.dwStructSize     = sizeof(UrlComponents);
    UrlComponents.lpszHostName     = pszServerName;
    UrlComponents.dwHostNameLength = c_cchMaxURLSize;
    UrlComponents.lpszUrlPath      = pszObject;
    UrlComponents.dwUrlPathLength  = c_cchMaxURLSize;
    UrlComponents.lpszUserName     = szUserName;
    UrlComponents.dwUserNameLength = ARRAYSIZE(szUserName);
    UrlComponents.lpszPassword     = szPasswd;
    UrlComponents.dwPasswordLength = ARRAYSIZE(szPasswd);
    UrlComponents.lpszScheme       = szScheme;
    UrlComponents.dwSchemeLength   = ARRAYSIZE(szScheme);

    LOG_Internet(_T("WinInet: Downloading URL %s to FILE %s"), pszServerUrl, pszLocalFile);

    if ((*sfns.pfnInternetCrackUrl)(pszServerUrl, 0, 0, &UrlComponents) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    if (pszServerUrl[0] == L'\0' || szScheme[0] == L'\0' || pszServerName[0] == L'\0' ||
        _tcsicmp(szScheme, _T("http")) != 0)
    {
        LOG_ErrorMsg(E_INVALIDARG);
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (fAppendCacheBreaker)
    {
        SYSTEMTIME  stCB;
        TCHAR       szCacheBreaker[12];
        
        GetSystemTime(&stCB);
        hr = StringCchPrintfEx(szCacheBreaker, ARRAYSIZE(szCacheBreaker),
                               NULL, NULL, MISTSAFE_STRING_FLAGS,
                               _T("?%02d%02d%02d%02d%02d"),
                               stCB.wYear % 100,
                               stCB.wMonth,
                               stCB.wDay,
                               stCB.wHour,
                               stCB.wMinute);
        if (FAILED(hr))
            goto CleanUp;

        hr = StringCchCatEx(pszObject, c_cchMaxURLSize, szCacheBreaker, 
                            NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            goto CleanUp;
    }

    if (fAllowProxy)
        dwAccessType = INTERNET_OPEN_TYPE_PRECONFIG;
    else
        dwAccessType = INTERNET_OPEN_TYPE_DIRECT;

    dwTickStart = GetTickCount();
    
START_INTERNET:
    // start to deal with Internet
    iRetryCounter++;

    // If the connection has already been established re-use it.
    hInternet = (*sfns.pfnInternetOpen)(c_tszUserAgent, dwAccessType, NULL, NULL, 0);
    if (hInternet == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    hConnect = (*sfns.pfnInternetConnect)(hInternet, pszServerName, INTERNET_DEFAULT_HTTP_PORT, 
                                          szUserName, szPasswd,
                                          INTERNET_SERVICE_HTTP,
                                          INTERNET_FLAG_NO_UI | INTERNET_FLAG_RELOAD | INTERNET_FLAG_KEEP_CONNECTION,
                                          0);
    if (hConnect == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    iVerb = (DWORD)((fCheckStatusOnly) ? ARRAYSIZE(rgszVerbs) - 1 : 0);
    for(; iVerb < ARRAYSIZE(rgszVerbs); iVerb++)
    {
        SafeInternetCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, NULL, rgszVerbs[iVerb], pszObject, rghQuitEvents, cQuitEvents,
                         &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        dwLength = sizeof(dwStatus);
        if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, 
                                     (LPVOID)&dwStatus, &dwLength, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }

        LOG_Internet(_T("WinInet: Request result: %d"), dwStatus);

        if (dwStatus == HTTP_STATUS_OK || dwStatus == HTTP_STATUS_PARTIAL_CONTENT)
        {
            break;
        }
        else
        {
            // since a server result is not a proper win32 error code, we can't 
            //  really do a HRESULT_FROM_WIN32 here.  Otherwise, we'd return
            //  a bogus code.  However, we do want to pass an error HRESULT back
            //  that contains this code.
            hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_HTTP, dwStatus);
            LOG_Error(_T("WinInet: got failed status code from server %d\n"), dwStatus);

            // if it's the last verb in the list, then bail...
            if (rgszVerbs[iVerb] == NULL)
                goto CleanUp;
        }
    }

    // if we made it here & we're only trying to check status, then we're done
    if (fCheckStatusOnly)
    {
        LOG_Internet(_T("WinInet: Only checking status.  Exiting before header check and download."));
        hr = S_OK;
        goto CleanUp;
    }

    dwLength = sizeof(st);
    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_LAST_MODIFIED | HTTP_QUERY_FLAG_SYSTEMTIME, 
                                 (LPVOID)&st, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }

    SystemTimeToFileTime(&st, &ft);

    // Now Get the FileSize information from the Server
    dwLength = sizeof(cbRemoteFile);
    if ((*sfns.pfnHttpQueryInfo)(hOpenRequest, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, 
                                 (LPVOID)&cbRemoteFile, &dwLength, NULL) == FALSE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LOG_ErrorMsg(hr);
        goto CleanUp;
    }
    
    if (HandleEvents(rghQuitEvents, cQuitEvents) == FALSE)
    {
        hr = E_ABORT;
        goto CleanUp;
    }
    
    // unless we have a flag that explicitly allows it, do not retry downloads 
    //  here.  The reasoning is that we could be in the middle of a large 
    //  download and have it fail...
    if (fSkipDownloadRetry)
        iRetryCounter = c_cMaxRetries;

    if (IsServerFileDifferent(ft, cbRemoteFile, pszLocalFile))
    {
        DWORD cbDownloaded;
        BOOL  fCheckForHTML = fDoCabValidation;

        LOG_Internet(_T("WinInet: Server file was newer.  Downloading file"));
        
        // if we didn't open with a GET request above, then we gotta open a new
        //  request.  Otherwise, can reuse the request object...
        if (rgszVerbs[iVerb] != NULL)
            SafeInternetCloseHandle(sfns, hOpenRequest);

        hr = MakeRequest(sfns, hConnect, hOpenRequest, NULL, pszObject,
                         rghQuitEvents, cQuitEvents, &hOpenRequest);
        if (FAILED(hr))
            goto CleanUp;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = GetContentTypeHeader(sfns, hOpenRequest, &pszContentType);
            if (SUCCEEDED(hr) && pszContentType != NULL)
            {
                fCheckForHTML = FALSE;
                if (_tcsicmp(pszContentType, _T("text/html")) == 0)
                {
                    LOG_Internet(_T("WinInet: Content-Type header is text/html.  Bailing."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    goto CleanUp;
                }
                else
                {
                    LOG_Internet(_T("WinInet: Content-Type header is %s.  Continuing."), pszContentType);
                }
            }

            hr = NOERROR;
        }

        // open the file we're gonna spew into
        hFile = CreateFile(pszLocalFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
                           FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LOG_ErrorMsg(hr);
            goto CleanUp;
        }
        
        LOG_Internet(_T("WinInet: downloading to FILE %s"), pszLocalFile);

        // bring down the bits
        hr = PerformDownloadToFile(sfns.pfnInternetReadFile, hOpenRequest, 
                                   hFile, cbRemoteFile,
                                   cbDownloadBuffer, 
                                   rghQuitEvents, cQuitEvents, 
                                   pfnCallback, pvCallbackData, &cbDownloaded);
        if (FAILED(hr))
        {
            LOG_Internet(_T("WinInet: Download failed: hr: 0x%08x"), hr);
            SafeCloseInvalidHandle(hFile);
            DeleteFile(pszLocalFile);
            goto CleanUp;
        }

        LOG_Internet(_T("WinInet: Download succeeded"));

        // set the file time to match the server file time since we just 
        //  downloaded it. If we don't do this the file time will be set 
        //  to the current system time.
        SetFileTime(hFile, &ft, NULL, NULL); 
        SafeCloseInvalidHandle(hFile);

        if (pdwDownloadedBytes != NULL)
            *pdwDownloadedBytes = cbRemoteFile;

        // sometimes, we can get fancy error pages back from the site instead of 
        //  a nice nifty HTML error code, so check & see if we got back a html
        //  file when we were expecting a cab.
        if (fCheckForHTML)
        {
            hr = IsFileHtml(pszLocalFile);
            if (SUCCEEDED(hr))
            {
                if (hr == S_FALSE)
                {
                    LOG_Internet(_T("WinInet: Download is not a html file"));
                    hr = S_OK;
                }
                else
                {
                    LOG_Internet(_T("WinInet: Download is a html file.  Failing download."));
                    hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
                    SafeCloseInvalidHandle(hFile);
                    DeleteFile(pszLocalFile);
                    goto CleanUp;
                }
            }
            else
            {
                LOG_Internet(_T("WinInet: Unable to determine if download is a html file or not.  Failing download."));
            }
        }
        else
        {
            LOG_Internet(_T("WinInet: Skipping cab validation."));
        }
    }
    else
    {
        hr = S_OK;
        
        LOG_Internet(_T("WinInet: Server file is not newer.  Skipping download."));

        // The server ain't newer & the file is already on machine, so
        //  send progress callback indicating file downloadeded ok
        if (pfnCallback != NULL)
        {
            // fpnCallback(pCallbackData, DOWNLOAD_STATUS_FILECOMPLETE, dwFileSize, dwFileSize, NULL, NULL);
            pfnCallback(pvCallbackData, DOWNLOAD_STATUS_OK, cbRemoteFile, cbRemoteFile, NULL, NULL);
        }
    }

CleanUp:
 
    SafeInternetCloseHandle(sfns, hOpenRequest);
    SafeInternetCloseHandle(sfns, hConnect);
    SafeInternetCloseHandle(sfns, hInternet);

    SafeHeapFree(pszContentType);

    // if we failed, see if it's ok to continue (quit events) and whether
    //  we've tried enuf times yet.
    if (FAILED(hr) &&
        HandleEvents(rghQuitEvents, cQuitEvents) &&
        iRetryCounter >= 0 && iRetryCounter < c_cMaxRetries)
    {
        // in case of failure and have no enough retries yet, we retry
        // as long as not timeout yet
        DWORD dwElapsedTime;

        dwTickEnd = GetTickCount();
        if (dwTickEnd > dwTickStart)   
            dwElapsedTime = dwTickEnd - dwTickStart;
        else
            dwElapsedTime = (0xFFFFFFFF - dwTickStart) + dwTickEnd;

        // We haven't hit our retry limit, so log & error and go again
        if (dwElapsedTime < c_dwRetryTimeLimitInmsWiuInet)
        {
            LogError(hr, "Library download error. Will retry.");

            // in the case where we're gonna retry, keep track of the very first
            //  error we encoutered cuz the ops guys say that this is the most
            //  useful error to know about.
            if (iRetryCounter == 0)
            {
                LOG_Internet(_T("First download error saved: 0x%08x."), hr);
                hrToReturn = hr;
            }
            else
            {
                LOG_Internet(_T("Subsequent download error: 0x%08x."), hr);
            }
            hr = S_OK;
            goto START_INTERNET;
        }

        // We've completely timed out, so bail
        else
        {
            LogError(hr, "Library download error and timed out (%d ms). Will not retry.", dwElapsedTime);
        }
    }
    
    // make a callback indicating a download error
    if (FAILED(hr) && pfnCallback != NULL)
        pfnCallback(pvCallbackData, DOWNLOAD_STATUS_ERROR, cbRemoteFile, 0, NULL, NULL);

    // if we haven't saved off an error, just use the current error.  We can't
    //  have set hrToReturn previously if we didn't fail and want to attempt 
    //  a retry.
    // However, if we've got a success from this pass, be sure to return that 
    //  and not a fail code.
    if (FAILED(hr) && SUCCEEDED(hrToReturn))
        hrToReturn = hr;
    else if (SUCCEEDED(hr) && FAILED(hrToReturn))
        hrToReturn = hr;
    
    SafeHeapFree(pszServerName);
    SafeHeapFree(pszObject);

    return hrToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\logging\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.Logging

TARGETNAME=Logging
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc
TARGETLIBS= $(IU_UTIL_LIB_DIR)\*\util.lib

SOURCES= \
	..\IULogger.cpp  \
	..\FreeLog.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\logging\iulogger.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   IULogger.cpp: implementation of the CIULogger class.
//
//  Description:
//
//      See IULogger.h
//
//=======================================================================

#if defined(DBG)

#include <windows.h>
#include <ole2.h>
#include <tchar.h>
#include <MemUtil.h>

#include <fileutil.h>
#include <Logging.h>
#include <strsafe.h>


//
// declare constants used to control log exclusions
//
const DWORD    LOG_BLOCK                = 0x00000001;    // log function/block in/out
const DWORD LOG_XML_DETAIL            = 0x00000002;    // log detailed XML operation
const DWORD LOG_INTERNET            = 0x00000004;    // log action related to Internet activities, e.g., downld
const DWORD LOG_SOFTWARE            = 0x00000008;    // log details about software detection/installation
const DWORD LOG_DRIVER                = 0x00000010;    // log actions related to driver detection/installation
const DWORD LOG_TRUST                = 0x00000020;    // log actions related to wintrust checking
const DWORD    LOG_DOWNLOAD            = 0x00000040;    // log actions related to download
const DWORD LOG_XML_BSTR_DETAIL        = 0x00000080;    // log XML BSTRs
const DWORD LOG_ERROR                = 0x00008000;    // you can not exclude this type of logs from output
const DWORD LOG_ALL                    = 0xFFFFFFFF;    // default, all above

//
// const for longest line of XML we will output
//
const DWORD LOG_XML_BUFF_LEN        = 128;

//
// const for specifying the intent array size increament.
// each element in array holds indent data for one thread
//
const int c_IndentArrayChunk = 16;

//
// define the log header format
//
// It is constructed as: <date> <time> <thread id>
//
const TCHAR szLogHeaderFmt[]        = _T("yyyy/mm/dd hh:nn:ss:sss xxxxxxxx  ");

//
// initialization of static members
//

int                CIULogger::m_Size            = 0;
int                CIULogger::m_siIndentStep    = 0;    // init to use tab char
CIULogger::_THREAD_INDENT* CIULogger::m_psIndent = NULL;

DWORD            CIULogger::m_sdwLogMask        = LOG_ALL;
HANDLE            CIULogger::m_shFile            = INVALID_HANDLE_VALUE;
bool            CIULogger::m_fLogDebugMsg    = false;
bool            CIULogger::m_fLogFile        = false;
bool            CIULogger::m_fLogUsable        = false;
HANDLE            CIULogger::m_hMutex            = NULL;
int                CIULogger::m_cFailedWaits    = 0;
int                CIULogger::m_fFlushEveryTime = FALSE;

//
// Defines for Mutex (borrowed from freelog)
//
// NOTE: globals and statics are per-module (e.g. iuctl, iuengine), but Mutex is per-processes
// due to the name being constructed from the log file name (contains process ID).
//
#define MUTEX_TIMEOUT       1000    // Don't wait more than 1 second to write to logfile
#define MAX_MUTEX_WAITS     4       // Don't keep trying after this many failures

//
// global variable
//

//
// reference count to control log file open/close
//
LONG g_RefCount = 0;

//
// critical sectoin handling multi-threading
// access of indent array case
//
//
CRITICAL_SECTION g_LogCs;



//
// we need to declare a global object so refcount wont't
// be zero, otherwise in multi-threading mode ref count
// can be fooled and AV when one object thinks m_psIdent not NULL
// but another object in another (parent) thread freed m_psIndent
// in destructor (only if parent thread quits)
//
CIULogger g_DummyLogObj(NULL);


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CIULogger::CIULogger(char* szBlockName)
: m_Index(-1), m_LineNum(0)
{
    if (0 == g_RefCount)
    {
        //
        // This must be the g_DummyLogObj (or another global
        // instance) during initialization of globals. Since
        // this is the first instance created, we must init CS
        //
        InitializeCriticalSection(&g_LogCs);
    }

    //
    // Protect the statics while in the ctor
    //
    EnterCriticalSection(&g_LogCs);

    m_dwTickBegin    = GetTickCount();
    m_dwThreadId    = GetCurrentThreadId();
    m_fProcessLog    = (NULL == szBlockName);
    ZeroMemory(m_szBlockName, sizeof(m_szBlockName)); 

    g_RefCount++;

    if (1 == g_RefCount)
    {
        //
        // this is the first time to call this class, we need to 
        // find out whether we should log and where to log to
        //

        ReadRegistrySettings();

        //
        // allocate memory for thread indent array initially
        //
        SetIndent(0);

        //
        // if the indent level is not negative, then it's okay to log
        //
        m_fLogFile = (INVALID_HANDLE_VALUE != m_shFile);
        m_fLogUsable = (m_fLogFile || m_fLogDebugMsg) && (NULL != m_psIndent);
    }


    if (m_fLogUsable)
    {
        if (!m_fProcessLog)
        {
            //
            // this is probably a new thread, so we need to find the index
            // for this thread.
            //
            SetIndent(0);

            //
            // do block logging, if permitted
            //
            if (0x0 != (m_sdwLogMask & LOG_BLOCK) && szBlockName && _T('\0') != szBlockName[0]) 
            {
                StringCchCopyA(m_szBlockName, ARRAYSIZE(m_szBlockName), szBlockName);
                USES_IU_CONVERSION;
                
                char szOut[sizeof(m_szBlockName) + 10];
                //
                // Implicit "Enter " before block name to save log space
                //
                if (SUCCEEDED(StringCchPrintfA(szOut, ARRAYSIZE(szOut), "%hs\r\n", szBlockName)))
                {
                    _LogOut(A2T(szOut));
                }
            }
            SetIndent(+1);
        }

    }
    LeaveCriticalSection(&g_LogCs);
}



CIULogger::~CIULogger()
{
    EnterCriticalSection(&g_LogCs);

    if (m_fLogUsable)
    {
        //
        // decrease the indent level by 1 if we increased indent
        //
        if (!m_fProcessLog)
        {
            SetIndent(-1);
        }

        //
        // write log file for exiting block, if allowed and block name exists
        //
        if (0x0 != (m_sdwLogMask & LOG_BLOCK) && _T('\0') != m_szBlockName[0]) 
        {
            USES_IU_CONVERSION; 
            char szOut[1024];
            //
            // "Exit " shortened to "~" to save log space
            //
            if (SUCCEEDED(StringCchPrintfA(szOut, ARRAYSIZE(szOut), "~%hs, %d msec\r\n", m_szBlockName, GetTickCount() - m_dwTickBegin)))
            {
                _LogOut(A2T(szOut));
            }
        }
    }

    //
    // reduce reference cnt
    //
    g_RefCount--;

    //
    // g_RefCount will go to zero before leaving dtor if this is the last global instance
    // in this module
    //
    if (0 == g_RefCount)
    {
        //
        // close file if the file is open
        //
        if (m_fLogFile && INVALID_HANDLE_VALUE != m_shFile)    // redundent?
        {
            CloseHandle(m_shFile);
            m_shFile = INVALID_HANDLE_VALUE;
        }
        if(NULL != m_hMutex)
        {
            CloseHandle(m_hMutex);
        }
        //
        // free memory of indent array
        //
        if (NULL != m_psIndent)
        {
            HeapFree(GetProcessHeap(), 0, m_psIndent);
            m_psIndent = NULL;
        }
    }

    LeaveCriticalSection(&g_LogCs);

    //
    // This is the last global instance (probably g_DummyLogObj) and is
    // being destructed before the DLL unloads
    //
    if (0 == g_RefCount)
    {
        DeleteCriticalSection(&g_LogCs);
    }
}

//
// Mutex stuff borrowed from freelog
// fixcode: This should not be required here since chk logging is per process only
BOOL CIULogger::AcquireMutex()
{
    // In rare case where mutex not created, we allow file operations
    // with no synchronization
    if (m_hMutex == NULL)
        return TRUE;

    // Don't keep waiting if we've been blocked in the past
    if (m_cFailedWaits >= MAX_MUTEX_WAITS)
        return FALSE;

    BOOL fResult = TRUE;
    if (WaitForSingleObject(m_hMutex, MUTEX_TIMEOUT) != WAIT_OBJECT_0)
    {
        fResult = FALSE;
        m_cFailedWaits++;
    }

    return fResult;
}

void CIULogger::ReleaseMutex()
{
    if (m_hMutex != NULL) // Note: AcquireMutex succeeds even if m_hMutex is NULL
    {
        ::ReleaseMutex(m_hMutex);
    }
}

////////////////////////////////////////////////////////////////////////
//
// log with no flag, so can not be removed by excluding directives
//
////////////////////////////////////////////////////////////////////////
void CIULogger::Log(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        USES_IU_CONVERSION;
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_ALL, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log error, so can not be removed by excluding directives
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogError(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_ERROR, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// Helper for LogErrorMsg and LogInfoMsg (which supply message to prepend)
//
////////////////////////////////////////////////////////////////////////
void CIULogger::_LogFormattedMsg(DWORD dwErrCode, LPCTSTR pszErrorInfo)
{
    if (m_fLogUsable)
    {
        //
        // try to retrive system msg
        //
        LPTSTR lpszBuffer = NULL, lpszLogMsg = NULL;
        LPVOID lpMsg = NULL;
        FormatMessage(
                      FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,    // no source, use system msg
                      dwErrCode,
                      MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),
                      (LPTSTR)&lpMsg,
                      0,
                      NULL);
        if (NULL == lpMsg)
        {
            //
            // if we failed to get the msg, then output generic 
            // error/info log
            //
            LogError(_T("Unknown %s Line %d: 0x%08x\n"), pszErrorInfo, m_LineNum, dwErrCode);
        }
        else
        {
            lpszBuffer = (LPTSTR) lpMsg;
            int nLen = lstrlen(lpszBuffer);
            lpszLogMsg = (LPTSTR) LocalAlloc(0, (nLen + 128) * sizeof(TCHAR));
            if (NULL != lpszLogMsg)
            {
                //
                // insert Error/Info keyword
                //
                if (FAILED(StringCchPrintf(lpszLogMsg, ARRAYSIZE(lpszLogMsg), _T("%s Line %d: 0x%08x: %s"), pszErrorInfo, m_LineNum, dwErrCode, lpszBuffer)))
                {
                    // Couldn't build the right string, so just output the system msg
                    LocalFree(lpszLogMsg);
                    lpszLogMsg = lpszBuffer;
                }
            }
            else
            {
                //
                // failed to get buffer? unlikely, anyway, 
                // we have no option but just output the system msg
                //
                lpszLogMsg = lpszBuffer;
            }

            //
            // write log out
            //
            _LogOut(lpszLogMsg);

            //
            // clean up buffer
            //
            if (lpszLogMsg != lpszBuffer)
            {
                LocalFree(lpszLogMsg);
            }
            LocalFree(lpszBuffer);
        }

    }
}

////////////////////////////////////////////////////////////////////////
//
// similar to LogError, but try to log the system msg based
// on the error code. If the sysmsg not avail, log 
//    "Unknown error with error code 0x%08x"
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogErrorMsg(DWORD dwErrCode)
{
    _LogFormattedMsg(dwErrCode, _T("Error"));
}

////////////////////////////////////////////////////////////////////////
//
// similar to LogErrorMsg but prepends with "Info" rather than "Error"
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogInfoMsg(DWORD dwErrCode)
{
    _LogFormattedMsg(dwErrCode, _T("Info"));
}


////////////////////////////////////////////////////////////////////////
//
// log with type INTERNET, this function will do nothing
// if the Internet exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogInternet(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_INTERNET, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type XML, this function will do nothing
// if the XML exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogXML(LPCTSTR szLogFormat, ...)
{

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_XML_DETAIL, szLogFormat, va);
        va_end (va);
    }
}

void CIULogger::_NukeCrLf(LPTSTR pszBuffer)
{
    while (*pszBuffer)
    {
        if (_T('\r') == *pszBuffer || _T('\n') == *pszBuffer)
        {
            //
            // Overwrite <CR> and <LF> with space
            //
            *pszBuffer = _T(' ');
        }
        pszBuffer++;
    }
}

////////////////////////////////////////////////////////////////////////
//
// log BSTR containing valid XML. This gets around length limitations
// of LogOutput and attempts to break lines following ">". This
// output is sent for both fre and chk builds unless excluded from reg.
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogXmlBSTR(BSTR bstrXML)
{
    USES_IU_CONVERSION;

    LPTSTR pszLine;
    LPTSTR pszTemp;
    LPTSTR pszStop;
    LPTSTR pszLastGT;
    TCHAR  szXmlBuff[LOG_XML_BUFF_LEN];
	HRESULT hr;
    
    if (NULL == bstrXML)
    {
        return;
    }

    if (m_fLogUsable && (m_sdwLogMask & LOG_XML_BSTR_DETAIL) )
    {
#if !(defined(UNICODE) || defined(_UNICODE))
        DWORD dwANSIBuffLen = SysStringLen(bstrXML) + 1;
        LPSTR pszANSIBuff = (LPSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwANSIBuffLen);

        if (NULL == pszANSIBuff)
        {
            //
            // We're toast - just return without logging
            //
            return;
        }
        LPTSTR pTempTchar = OLE2T(bstrXML);
        if (NULL != pTempTchar)
        {
            if (FAILED(StringCchCopyA(pszANSIBuff, dwANSIBuffLen, pTempTchar)))
            {
                goto done;
            }
        }
        pszLine = pszANSIBuff;
#else
        pszLine = bstrXML;
#endif

        while (*pszLine)
        {
            //
            // Skip <CR> & <LF> chars
            //
            while (_T('\r') == *pszLine || _T('\n') == *pszLine)
            {
                pszLine++;
                if (NULL == *pszLine)
                {
                    break;
                }
            }
            if (NULL == *pszLine)
            {
                break;
            }

            pszTemp = pszLine;
            pszStop = pszLine + LOG_XML_BUFF_LEN - 1;
            pszLastGT = NULL;

            //
            // Try to find the last '>' char that will fit in buffer
            //
            while (*pszTemp && pszTemp < pszStop)
            {
                if (_T('>') == *pszTemp)
                {
                    pszLastGT = pszTemp;
                }
                pszTemp++;
            }

            if (pszLastGT)
            {
                //
                // Break the line at the last '>' that fits into LOG_XML_BUFF_LEN
                //
				hr = StringCchCopy(szXmlBuff, (int) (pszLastGT - pszLine) + 2, pszLine);
				//
				// STRSAFE_E_INSUFFICIENT_BUFFER is returned if the string is truncated.
				// This is normal since we are just copying a portion of the XML at
				// a time so it won't be too long to log.
				//
                if (SUCCEEDED(hr) || STRSAFE_E_INSUFFICIENT_BUFFER == hr)
                {
                    _NukeCrLf(szXmlBuff);
                    _LogOut(szXmlBuff);
                    pszLine = pszLastGT + 1;
                }
				else
				{
					break;
				}
            }
            else if (*pszTemp)
            {
                //
                // We're forced to break the line at LOG_XML_BUFF_LEN with no '>' in range
                //
				hr = StringCchCopy(szXmlBuff, LOG_XML_BUFF_LEN, pszLine);
                if (SUCCEEDED(hr) || STRSAFE_E_INSUFFICIENT_BUFFER == hr)
                {
                    _NukeCrLf(szXmlBuff);
                    _LogOut(szXmlBuff);
                    pszLine += LOG_XML_BUFF_LEN -1;
                }
				else
				{
					break;
				}
            }
            else
            {
                //
                // Output any leftover XML to end of BSTR
                //
                _NukeCrLf(pszLine);
                _LogOut(pszLine);
                //
                // Set to end of BSTR so we bust out of outer while
                //
                pszLine += lstrlen(pszLine);
			}
		}

#if !(defined(UNICODE) || defined(_UNICODE))
done:
        if (pszANSIBuff)
        {
            HeapFree(GetProcessHeap(), 0, pszANSIBuff);
            pszANSIBuff = NULL;
        }
#endif
	}
}

////////////////////////////////////////////////////////////////////////
//
// log with type SOFTWARE, this function will do nothing
// if the SOFTWARE exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogSoftware(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_SOFTWARE, szLogFormat, va);
        va_end (va);
    }
}



////////////////////////////////////////////////////////////////////////
//
// log with type DOWNLOAD, this function will do nothing
// if the LogDownload exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogDownload(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_DOWNLOAD, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type DRIVER, this function will do nothing
// if the DRIVER exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogDriver(LPCTSTR szLogFormat, ...)
{
    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_DRIVER, szLogFormat, va);
        va_end (va);
    }
}


////////////////////////////////////////////////////////////////////////
//
// log with type CHECKTRUST, this function will do nothing
// if the CHECKTRUST exclusion directive is detected from reg
//
////////////////////////////////////////////////////////////////////////
void CIULogger::LogTrust(LPCTSTR szLogFormat, ...)
{

    USES_IU_CONVERSION;

    if (m_fLogUsable) 
    {
        va_list va;
        va_start (va, szLogFormat);
        _Log(LOG_TRUST, szLogFormat, va);
        va_end (va);
    }

}



////////////////////////////////////////////////////////////////////////
//
// actual base logging function
// if it actually logged, or just returned
// because directives say don't make this kind of log
//
////////////////////////////////////////////////////////////////////////
void CIULogger::_Log(DWORD LogType, LPCTSTR pszLogFormat, va_list va)
{

    USES_IU_CONVERSION;
    TCHAR szOut[5 * 1024];
    LPTSTR pszFormat;
    DWORD dwFormatLen;

    if (!m_fLogUsable || (0x0 == (m_sdwLogMask & LogType)) || NULL == pszLogFormat)
    {
        return;
    }

    if (LOG_ERROR == LogType)
    {
        //
        // for error case, we try to add "Error Line %d: " in front of the log
        //
        dwFormatLen = lstrlen(pszLogFormat) + 128;
        pszFormat = (TCHAR*) MemAlloc(dwFormatLen * sizeof(TCHAR));
        if (NULL != pszFormat)
        {
            if (FAILED(StringCchPrintf(pszFormat, dwFormatLen, _T("Error Line %d: %s"), m_LineNum, pszLogFormat)))
            {
                pszFormat = (LPTSTR)pszLogFormat;
            }
        }
        else
        {
            pszFormat = (LPTSTR)pszLogFormat;
        }
    }
    else
    {
        pszFormat = (LPTSTR)pszLogFormat;
    }

    if (SUCCEEDED(StringCchVPrintf(szOut, ARRAYSIZE(szOut), pszFormat, va)))
    {
        _LogOut(szOut);
    }
    return;
}



//
// function to write the log to log file
// also taking care of indentation
//
void CIULogger::_LogOut(LPTSTR pszLog)
{

    if (NULL == pszLog)
        return;

    //
    // Protect static variables and indent values
    //
    EnterCriticalSection(&g_LogCs);

    int n = GetIndent();
    int i, 
        nLogLen,    // length of log string passed in
        nTotalLen;    // length of constructed 

    HANDLE    hHeap = GetProcessHeap();
    LPTSTR    pszWholeLog;
    LPTSTR    pszCurrentPos;
    DWORD     dwCurrentLen;
    DWORD     dwWritten;
    TCHAR     szTab = (m_siIndentStep < 1) ? szTab = _T('\t') : szTab = _T(' ');

    //
    // find out length for log header
    //
    if (m_siIndentStep > 0)
    {
        //
        // if positive number, it means the number of
        // space chars to use for each indent, rather
        // than using a tab
        //
        n *= m_siIndentStep;
    }

    nLogLen = lstrlen(pszLog);
    //
    // verify this log is \r\n ended
    //
    if (nLogLen > 1 && _T('\n') == pszLog[nLogLen-1])
    {
        //
        // if there is no catriege return, just a \n,
        // then remove \n 
        //
        if (_T('\r') != pszLog[nLogLen-2])
        {
            nLogLen--;
            pszLog[nLogLen] = _T('\0');
        }
    }

    nTotalLen = n + sizeof(szLogHeaderFmt)/sizeof(TCHAR) + nLogLen + 3;
    
    //
    // allocate memory to construct the log
    //
    pszWholeLog = (LPTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, nTotalLen * sizeof(TCHAR));

    if (NULL == pszWholeLog)
    {
        //
        // nothing we can do in this case, bail.
        //
        LeaveCriticalSection(&g_LogCs);
        return;
    }

    //
    // get log header
    //
    GetLogHeader(pszWholeLog, nTotalLen);

    //
    // construct indent
    //
    pszCurrentPos = pszWholeLog + lstrlen(pszWholeLog);
    dwCurrentLen = nTotalLen - lstrlen(pszWholeLog);
    for (i = 0; i < n; i++) 
    {
        pszCurrentPos[i] = szTab;
    }
    pszCurrentPos[i] = _T('\0');

    //
    // add log to whilelog buffer
    //
    if (FAILED(StringCchCat(pszCurrentPos, dwCurrentLen, pszLog)))
    {
        goto done;
    }
    
    //
    // Always terminate lines with <CR> <LF>
    //
    if (_T('\n') != pszLog[nLogLen-1])
    {
        if (FAILED(StringCchCat(pszCurrentPos, dwCurrentLen, _T("\r\n"))))
        {
            goto done;
        }
    }
    
    //
    // write log
    //
    nTotalLen = lstrlen(pszWholeLog);
    
    if (m_fLogFile)
    {
        if (TRUE == AcquireMutex())
        {
            //
            // Another module (e.g. if we are iuengine, maybe iuctl) may have written
            // to the iu_xxx.log file, so we need to seek to the end before writing
            //
            SetFilePointer(m_shFile, 0, NULL, FILE_END);
            WriteFile(m_shFile, pszWholeLog, nTotalLen * sizeof(TCHAR), &dwWritten, NULL);
            if (m_fFlushEveryTime)
            {
                FlushFileBuffers(m_shFile);
            }

            ReleaseMutex();
        }
    }

    if (m_fLogDebugMsg)
    {
        OutputDebugString(pszWholeLog);
    }

done:

    HeapFree(hHeap, 0, pszWholeLog);

    LeaveCriticalSection(&g_LogCs);
    return;
}



//////////////////////////////////////////////////////////////////////
//
// Timestamp Helper
//
//////////////////////////////////////////////////////////////////////

void CIULogger::GetLogHeader(LPTSTR pszBuffer, DWORD cchBufferLen)
{
    SYSTEMTIME st = {0};

    if (pszBuffer == NULL)
    {
        return;
    }

    GetLocalTime(&st);

    //
    // print out as the pre-defined format:
    //    szTimeStampFmt[]
    //
    if (FAILED(StringCchPrintf(pszBuffer, cchBufferLen,
                        _T("%4d/%02d/%02d|%02d:%02d:%02d:%03d|%08x| "), 
                        st.wYear,
                        st.wMonth,
                        st.wDay,
                        st.wHour,
                        st.wMinute,
                        st.wSecond,
                        st.wMilliseconds,
                        m_dwThreadId)))
    {
        // It wont fit, just set it to an empty string
        pszBuffer[0] = 0;
    }
}



//
// function to retrieve the indent of current thread
//
int CIULogger::GetIndent(void)
{

    if (m_Index < 0 || !m_fLogUsable)
    {
        return 0;
    }
    else
    {
        return m_psIndent[m_Index].iIndent;
    }

}


//
// function to change indention of current thread
//
void CIULogger::SetIndent(int IndentDelta)
{
    int i;
    bool fQuit = false;

    EnterCriticalSection(&g_LogCs);

    if (m_Index < 0)
    {
        //
        // try to find the index
        //

        if (NULL == m_psIndent)
        {
            //
            // if no indent array created yet
            //
            m_psIndent = (_THREAD_INDENT*)
                         HeapAlloc(
                                   GetProcessHeap(),
                                   HEAP_ZERO_MEMORY,
                                   c_IndentArrayChunk * sizeof(_THREAD_INDENT)
                                   );
            if (NULL != m_psIndent)
            {
                m_Size = c_IndentArrayChunk;
            }
            else
            {
                LeaveCriticalSection(&g_LogCs);
                return;
            }
    
        }


        for (i = 0; i < m_Size && m_psIndent[i].dwThreadId != 0; i++)
        {
            if (m_psIndent[i].dwThreadId == m_dwThreadId)
            {
                m_Index = i;
                break;
            }
        }

        if (m_Index < 0)
        {
            //
            // this thread is not in the array yet
            //
            for (i = 0; i < m_Size; i++)
            {
                if (0 == m_psIndent[i].dwThreadId)
                {
                    break;
                }
            }
            if (i < m_Size)
            {
                //
                // fill the next empty slot in array
                //
                m_psIndent[i].dwThreadId = m_dwThreadId;
                m_psIndent[i].iIndent = 0;
                m_Index = i;
            }
            else
            {
                //
                // array is full, no empty slot anymore
                // need to increase the indent array size
                //
                int iSize = m_Size + c_IndentArrayChunk;

                _THREAD_INDENT* pNewArray = (_THREAD_INDENT*)
                                            HeapReAlloc(
                                                        GetProcessHeap(), 
                                                        HEAP_ZERO_MEMORY, 
                                                        m_psIndent, 
                                                        iSize * sizeof(_THREAD_INDENT)
                                                        );
                if (NULL != pNewArray)
                {
                    m_psIndent = pNewArray;
                    m_Size = iSize;

                    m_psIndent[i].dwThreadId = m_dwThreadId;
                    m_psIndent[i].iIndent = 0;
                    m_Index = i;
                }
            }

        }
    }
    

    if (m_Index >= 0)
    {
        m_psIndent[m_Index].iIndent += IndentDelta;
    }

    LeaveCriticalSection(&g_LogCs);

}






//
// read registry value helper -- protected by g_LogCs in ctor
//
void CIULogger::ReadRegistrySettings(void)
{

    //
    // declare constants used to retrive logging settings
    //
    const TCHAR REGKEY_IUTCTL[]            = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControlLogging");
    const TCHAR REGVAL_LOGFILE[]        = _T("Logging File");
    const TCHAR REGVAL_LOGDEBUGMSG[]    = _T("Logging DebugMsg");
    const TCHAR REGVAL_LOGINDENT[]        = _T("LogIndentStep");
    const TCHAR REGVAL_LOGNOBLOCK[]        = _T("LogExcludeBlock");
    const TCHAR REGVAL_LOGNOXML[]        = _T("LogExcludeXML");
    const TCHAR REGVAL_LOGNOXMLBSTR[]    = _T("LogExcludeXmlBSTR");
    const TCHAR REGVAL_LOGNOINET[]        = _T("LogExcludeInternet");
    const TCHAR REGVAL_LOGNODRIVER[]    = _T("LogExcludeDriver");
    const TCHAR REGVAL_LOGNOSW[]        = _T("LogExcludeSoftware");
    const TCHAR REGVAL_LOGNOTRUST[]        = _T("LogExcludeTrust");
    const TCHAR REGVAL_LOGDOWNLOAD[]    = _T("LogExcludeDownload");
    const TCHAR REGVAL_LOGFLUSH[]        = _T("FlushLogEveryTime");    // added by charlma 11/27/01 to improve logging performance
                                                                    // only flush everytime if this flag is set to 1


    HKEY    hKey = NULL;
    TCHAR    szFilePath[MAX_PATH] = {0};
    DWORD    dwSize = sizeof(szFilePath);
    DWORD    dwData;
    
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUTCTL, 0, KEY_READ, &hKey))
    {
        //
        // there is no reg key setting available, so we will not 
        // output any log to anywhere - this is the released mode
        //
        return;
    }


    //
    // try to read out the file path for log file.
    //
    if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_LOGFILE, 0, 0, (LPBYTE)&szFilePath, &dwSize) && dwSize  > 0 && szFilePath[0] != _T('\0'))
    {
        TCHAR szLogFile[MAX_PATH];
        TCHAR szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szFName[_MAX_FNAME], szExt[_MAX_EXT];
        //
        // TODO: changed to use private version splitpath()
        //
        //_tsplitpath(szFilePath, szDrive, szDir, szFName, szExt);
        MySplitPath(szFilePath, szDrive, szDir, szFName, szExt);

        //
        // construct the log file name with process id embedded
        //
        if (FAILED(StringCchPrintf(szLogFile, ARRAYSIZE(szLogFile),
                             _T("%s%s%s_%d%s"), 
                             szDrive, 
                             szDir, 
                             szFName, 
                             GetCurrentProcessId(), 
                             szExt)))
        {
            // Can't construct log filename, so nothing we can do.
            RegCloseKey(hKey);
            return;
        }
        
        m_shFile = CreateFile(
                             szLogFile,
                             GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             NULL,
                             OPEN_ALWAYS,
                             0,
                             NULL);
        if (INVALID_HANDLE_VALUE != m_shFile)
        {
            if (INVALID_SET_FILE_POINTER == SetFilePointer(m_shFile, 0, NULL, FILE_END))
            {
                CloseHandle(m_shFile);
                m_shFile = INVALID_HANDLE_VALUE;
            }
            else
            {
                //
                // we have successfully opened the log file
                // so increase the indent level to 0 for
                // top level logging. this will cause
                // the indent array created
                //
                SetIndent(0);

                //
                // Unicode files need a 0xFEFF header
                //
                #if defined(UNICODE) || defined(_UNICODE)
                const WORD wUnicodeHeader = 0xFEFF;

                //
                // if the file is zero length, then this is a new file
                // we need to add unicode header
                //
                DWORD dwFileSize;

                if ( -1 != (dwFileSize = GetFileSize(m_shFile, NULL)))
                {
                    if (0 == dwFileSize)
                    {
                        WriteFile(m_shFile, &wUnicodeHeader, sizeof(WORD), &dwFileSize, NULL);
                    }
                } 
                #endif

            }
            //
            // Now create the Mutex we will use to protect future writes (we are in global ctor now...)
            //
            // construct the log file name with process id embedded, but no drive or '\' in path
            // so we can use it to name our mutex (file will be per-process).
            //
            if (FAILED(StringCchPrintf(szLogFile, ARRAYSIZE(szLogFile),
                                 _T("%s_%d%s"),  
                                 szFName, 
                                 GetCurrentProcessId(), 
                                 szExt)))
            {
                // If that doesn't work, just use a simple named mutex 
                m_hMutex = ::CreateMutex(NULL, FALSE, szFName);
            }
            else
            {
                m_hMutex = ::CreateMutex(NULL, FALSE, szLogFile);
            }
        }
    }

    
    //
    // try to find out if we should output debug msg to debugger
    //
    
    dwData = 0x0;
    dwSize = sizeof(dwData);

    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGDEBUGMSG, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        m_fLogDebugMsg = true;
    }


    //
    // keep reading other *optional* log directives
    //

    //
    // read whether we should exlude block data
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOBLOCK, 0, 0, (LPBYTE)&dwData, &dwSize) 
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_BLOCK);
    }

    //
    // read whether we should exlude XML related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOXML, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_XML_DETAIL);
    }

    //
    // read whether we should exlude XML BSTR related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOXMLBSTR, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_XML_BSTR_DETAIL);
    }

    //
    // read whether we should exlude internet related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOINET, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_INTERNET);
    }

    //
    // read whether we should exlude driver related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNODRIVER, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_DRIVER);
    }

    //
    // read whether we should exlude driver related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOSW, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_SOFTWARE);
    }

    //
    // read whether we should exlude wintrust checking related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGNOTRUST, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_TRUST);
    }
    
    //
    // read whether we should exlude wintrust checking related logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGDOWNLOAD, 0, 0, (LPBYTE)&dwData, &dwSize)
            && (0x1 == dwData))
    {
        //
        // remove block logging bit
        //
        m_sdwLogMask &= (~LOG_DOWNLOAD);
    }


    //
    // read whether we should use tab or space(s) for each indent step
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGINDENT, 0, 0, (LPBYTE)&dwData, &dwSize)
            && ((int)dwData > 0))
    {
        //
        // use space char(s) (_T(' ')). If nagetive or 0, _Logout will use tab char
        //
        m_siIndentStep = (int) dwData;
    }


    //
    // read whether we should flush everytime we do file logging
    //
    dwData = 0x0;
    dwSize = sizeof(dwData);
    if (m_shFile != INVALID_HANDLE_VALUE &&
        (ERROR_SUCCESS == 
            RegQueryValueEx(hKey, REGVAL_LOGFLUSH, 0, 0, (LPBYTE)&dwData, &dwSize)))
    {
        
        m_fFlushEveryTime = (0x1 == dwData);
    }

    //
    // finished registry checking
    //
    RegCloseKey(hKey);

}

#endif // defined(DBG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\schemamisc\schemakeys.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaKeys.cpp
//
//	Author:	Charles Ma
//			2000.12.4
//
//  Description:
//
//      implementation of CSchemaKeys class
//
//=======================================================================

//#include <iuengine.h>
#include "schemakeys.h"

const TCHAR	CKEY_REGKEYEXISTS[]	= _T("regKeyExists");
const TCHAR	CKEY_REGKEYVALUE[]		= _T("regKeyValue");
const TCHAR	CKEY_REGKEYSUBSTR[]	= _T("regKeySubstring");
const TCHAR	CKEY_REGKEYVERSION[]	= _T("regKeyVersion");
const TCHAR	CKEY_FILEVERSION[]		= _T("fileVersion");
const TCHAR	CKEY_FILEEXISTS[]		= _T("fileExists");
const TCHAR	CKEY_AND[]				= _T("and");
const TCHAR	CKEY_OR[] 				= _T("or");
const TCHAR	CKEY_NOT[] 				= _T("not");


// ---------------------------------------------------------------------
//
// constructor
//
// ---------------------------------------------------------------------

CSchemaKeys::CSchemaKeys()
{
	//
	// create these BSTRs
	//
	SCHEMA_KEY_XML_NAMESPACE	= SysAllocString(L"xmlns");
	SCHEMA_KEY_XML				= SysAllocString(L"xml");
	SCHEMA_KEY_SYSTEMINFO		= SysAllocString(L"systemInfo");
	SCHEMA_KEY_COMPUTERSYSTEM	= SysAllocString(L"computerSystem");
	SCHEMA_KEY_MANUFACTURER		= SysAllocString(L"manufacturer");
	SCHEMA_KEY_MODEL			= SysAllocString(L"model");
	SCHEMA_KEY_SUPPORTSITE		= SysAllocString(L"supportSite");
	SCHEMA_KEY_ADMINISTRATOR	= SysAllocString(L"administrator");
	SCHEMA_KEY_WU_DISABLED		= SysAllocString(L"windowsUpdateDisabled");
	SCHEMA_KEY_AU_ENABLED		= SysAllocString(L"autoUpdateEnabled");
	SCHEMA_KEY_DRIVESPACE		= SysAllocString(L"driveSpace");
	SCHEMA_KEY_DRIVE			= SysAllocString(L"drive");
	SCHEMA_KEY_KBYTES			= SysAllocString(L"kbytes");
	SCHEMA_KEY_REGKEYS			= SysAllocString(L"regKeys");
	SCHEMA_KEY_REG_HKLM			= SysAllocString(L"HKEY_LOCAL_MACHINE");
	SCHEMA_KEY_REG_SW			= SysAllocString(L"SOFTWARE");

	SCHEMA_KEY_NAME				= SysAllocString(L"name");			
	SCHEMA_KEY_COMSERVER		= SysAllocString(L"comserverID");	
	SCHEMA_KEY_KEY				= SysAllocString(L"key");			
	SCHEMA_KEY_ENTRY			= SysAllocString(L"entry");
	SCHEMA_KEY_VALUE			= SysAllocString(L"value");
	SCHEMA_KEY_VERSION			= SysAllocString(L"version");
	SCHEMA_KEY_VERSIONSTATUS	= SysAllocString(L"versionStatus");
	SCHEMA_KEY_FILEPATH			= SysAllocString(L"filePath");
	SCHEMA_KEY_TIMESTAMP		= SysAllocString(L"timestamp");
	SCHEMA_KEY_GUID				= SysAllocString(L"guid");

	SCHEMA_KEY_CATALOG_PROVIDER	= SysAllocString(L"catalog/provider");
	SCHEMA_KEY_ITEMS			= SysAllocString(L"items");
	SCHEMA_KEY_ITEM_SEARCH		= SysAllocString(L"catalog/provider/item");
	SCHEMA_KEY_ITEM				= SysAllocString(L"item");
	SCHEMA_KEY_ITEM_ITEMSTATUS	= SysAllocString(L"items/itemStatus");
	SCHEMA_KEY_ITEMSTATUS		= SysAllocString(L"itemStatus");
	SCHEMA_KEY_DETECTION		= SysAllocString(L"detection");
    SCHEMA_KEY_INSTALLATION     = SysAllocString(L"installation");
    SCHEMA_KEY_INSTALLSTATUS    = SysAllocString(L"installStatus");
	SCHEMA_KEY_INSTALLERTYPE    = SysAllocString(L"installerType");
	SCHEMA_KEY_EXCLUSIVE		= SysAllocString(L"exclusive");
	SCHEMA_KEY_NEEDSREBOOT		= SysAllocString(L"needsReboot");
	SCHEMA_KEY_COMMAND			= SysAllocString(L"command");
	SCHEMA_KEY_SWITCHES			= SysAllocString(L"switches");
	SCHEMA_KEY_COMMANDTYPE		= SysAllocString(L"commandType");
	SCHEMA_KEY_INFINSTALL		= SysAllocString(L"infInstallSection");
	SCHEMA_KEY_CODEBASE			= SysAllocString(L"codeBase");
	SCHEMA_KEY_CRC				= SysAllocString(L"crc");
	SCHEMA_KEY_PATCHAVAILABLE	= SysAllocString(L"patchAvailable");
	SCHEMA_KEY_SIZE				= SysAllocString(L"size");
	SCHEMA_KEY_DOWNLOADPATH		= SysAllocString(L"downloadPath");
	SCHEMA_KEY_DOWNLOADSTATUS	= SysAllocString(L"downloadStatus");
    SCHEMA_KEY_DEPENDENCIES     = SysAllocString(L"dependencies");
    SCHEMA_KEY_DESCRIPTION      = SysAllocString(L"description");
	SCHEMA_KEY_HREF				= SysAllocString(L"href");
	SCHEMA_KEY_LANGUAGE			= SysAllocString(L"language");
	SCHEMA_KEY_PLATFORM			= SysAllocString(L"platform");
	SCHEMA_KEY_PROCESSORARCHITECTURE = SysAllocString(L"processorArchitecture");
	SCHEMA_KEY_SUITE			= SysAllocString(L"suite");
	SCHEMA_KEY_PRODUCTTYPE		= SysAllocString(L"productType");
	SCHEMA_KEY_LOCALE			= SysAllocString(L"locale");
	SCHEMA_KEY_CONTEXT			= SysAllocString(L"context");
	SCHEMA_KEY_MAJOR			= SysAllocString(L"major");
	SCHEMA_KEY_MINOR			= SysAllocString(L"minor");
	SCHEMA_KEY_BUILD			= SysAllocString(L"build");
	SCHEMA_KEY_SERVICEPACKMAJOR	= SysAllocString(L"servicePackMajor");
	SCHEMA_KEY_SERVICEPACKMINOR	= SysAllocString(L"servicePackMinor");
    SCHEMA_KEY_COMPATIBLEHARDWARE = SysAllocString(L"compatibleHardware");
    SCHEMA_KEY_DEVICES           = SysAllocString(L"devices");
    SCHEMA_KEY_DEVICE           = SysAllocString(L"device");
    SCHEMA_KEY_PRINTERINFO      = SysAllocString(L"printerInfo");
    SCHEMA_KEY_CDM_PINFO		= SysAllocString(L"device/printerInfo");
    SCHEMA_KEY_DRIVERNAME       = SysAllocString(L"driverName");
    SCHEMA_KEY_HWID             = SysAllocString(L"hwid");
    SCHEMA_KEY_CDM_HWIDPATH     = SysAllocString(L"device/hwid");
    SCHEMA_KEY_DESCRIPTIONTEXT  = SysAllocString(L"descriptionText");
    SCHEMA_KEY_TITLE            = SysAllocString(L"title");
	SCHEMA_KEY_ITEMID           = SysAllocString(L"itemID");
	SCHEMA_KEY_HIDDEN           = SysAllocString(L"hidden");
    SCHEMA_KEY_ISPRINTER        = SysAllocString(L"isPrinter");
    SCHEMA_KEY_DEVICEINSTANCE   = SysAllocString(L"deviceInstance");
    SCHEMA_KEY_DRIVERPROVIDER	= SysAllocString(L"driverProvider");
    SCHEMA_KEY_MFGNAME			= SysAllocString(L"mfgName");
	SCHEMA_KEY_DRIVERVER		= SysAllocString(L"driverVer");
	SCHEMA_KEY_RANK				= SysAllocString(L"rank");
	SCHEMA_KEY_READMORE			= SysAllocString(L"description/descriptionText/details");
	SCHEMA_KEY_ERRORCODE		= SysAllocString(L"errorCode");

    SCHEMA_KEY_CATALOGSTATUS    = SysAllocString(L"catalogStatus");
    SCHEMA_KEY_PID              = SysAllocString(L"pid");

	SCHEMA_KEY_DETECTRESULT		= SysAllocString(L"detectResult");
	SCHEMA_KEY_INSTALLED		= SysAllocString(L"installed");
	SCHEMA_KEY_UPTODATE			= SysAllocString(L"upToDate");
	SCHEMA_KEY_NEWERVERSION		= SysAllocString(L"newerVersion");
	SCHEMA_KEY_EXCLUDED			= SysAllocString(L"excluded");
	SCHEMA_KEY_FORCE			= SysAllocString(L"force");

	SCHEMA_KEY_VERSTATUS_HI		= SysAllocString(L"HIGHER");
	SCHEMA_KEY_VERSTATUS_HE		= SysAllocString(L"HIGHER_OR_SAME");
	SCHEMA_KEY_VERSTATUS_EQ		= SysAllocString(L"SAME");
	SCHEMA_KEY_VERSTATUS_LE		= SysAllocString(L"LOWER_OR_SAME");
	SCHEMA_KEY_VERSTATUS_LO		= SysAllocString(L"LOWER");

	SCHEMA_KEY_IDENTITY			= SysAllocString(L"identity");
	SCHEMA_KEY_PUBLISHERNAME	= SysAllocString(L"publisherName");
	SCHEMA_KEY_FILE				= SysAllocString(L"path");
	SCHEMA_KEY_REGKEY			= SysAllocString(L"regKey");
	SCHEMA_KEY_PATH				= SysAllocString(L"path");
	SCHEMA_KEY_STATUS_COMPLETE	= SysAllocString(L"COMPLETE");
	SCHEMA_KEY_STATUS_FAILED	= SysAllocString(L"FAILED");

	SCHEMA_KEY_CLIENT			= SysAllocString(L"client");
	SCHEMA_KEY_CLIENTINFO		= SysAllocString(L"clientInfo");
	SCHEMA_KEY_CLIENTNAME		= SysAllocString(L"clientName");

	SCHEMA_KEY_REGKEYEXISTS		= CKEY_REGKEYEXISTS		;	
	SCHEMA_KEY_REGKEYVALUE		= CKEY_REGKEYVALUE		;
	SCHEMA_KEY_REGKEYSUBSTR		= CKEY_REGKEYSUBSTR		;
	SCHEMA_KEY_REGKEYVERSION	= CKEY_REGKEYVERSION	;	
	SCHEMA_KEY_FILEVERSION		= CKEY_FILEVERSION		;
	SCHEMA_KEY_FILEEXISTS		= CKEY_FILEEXISTS		;	
	SCHEMA_KEY_AND				= CKEY_AND				;
	SCHEMA_KEY_OR 				= CKEY_OR 				;
	SCHEMA_KEY_NOT	 			= CKEY_NOT	 			;


}




// ---------------------------------------------------------------------
//
// destructor
//
// ---------------------------------------------------------------------

CSchemaKeys::~CSchemaKeys()
{
	//
	// release BSTRs
	//
	SysFreeString(SCHEMA_KEY_XML_NAMESPACE);
	SysFreeString(SCHEMA_KEY_XML);
	SysFreeString(SCHEMA_KEY_SYSTEMINFO);
	SysFreeString(SCHEMA_KEY_COMPUTERSYSTEM);
	SysFreeString(SCHEMA_KEY_MANUFACTURER);
	SysFreeString(SCHEMA_KEY_MODEL);
	SysFreeString(SCHEMA_KEY_SUPPORTSITE);
	SysFreeString(SCHEMA_KEY_ADMINISTRATOR);
	SysFreeString(SCHEMA_KEY_WU_DISABLED);
	SysFreeString(SCHEMA_KEY_AU_ENABLED);
	SysFreeString(SCHEMA_KEY_DRIVESPACE);
	SysFreeString(SCHEMA_KEY_DRIVE);
	SysFreeString(SCHEMA_KEY_KBYTES);
	SysFreeString(SCHEMA_KEY_REGKEYS);
	SysFreeString(SCHEMA_KEY_REG_HKLM);
	SysFreeString(SCHEMA_KEY_REG_SW);

	SysFreeString(SCHEMA_KEY_NAME);
	SysFreeString(SCHEMA_KEY_COMSERVER);
	SysFreeString(SCHEMA_KEY_KEY);
	SysFreeString(SCHEMA_KEY_ENTRY);
	SysFreeString(SCHEMA_KEY_VALUE);
	SysFreeString(SCHEMA_KEY_VERSION);
	SysFreeString(SCHEMA_KEY_VERSIONSTATUS);
	SysFreeString(SCHEMA_KEY_FILEPATH);
	SysFreeString(SCHEMA_KEY_TIMESTAMP);
	SysFreeString(SCHEMA_KEY_GUID);

	SysFreeString(SCHEMA_KEY_CATALOG_PROVIDER);
	SysFreeString(SCHEMA_KEY_ITEMS);
	SysFreeString(SCHEMA_KEY_ITEM_SEARCH);
	SysFreeString(SCHEMA_KEY_ITEM);
	SysFreeString(SCHEMA_KEY_ITEM_ITEMSTATUS);
	SysFreeString(SCHEMA_KEY_ITEMSTATUS);
	SysFreeString(SCHEMA_KEY_DETECTION);
    SysFreeString(SCHEMA_KEY_INSTALLATION);
    SysFreeString(SCHEMA_KEY_INSTALLSTATUS);
    SysFreeString(SCHEMA_KEY_INSTALLERTYPE);
    SysFreeString(SCHEMA_KEY_EXCLUSIVE);
    SysFreeString(SCHEMA_KEY_NEEDSREBOOT);
    SysFreeString(SCHEMA_KEY_COMMAND);
    SysFreeString(SCHEMA_KEY_SWITCHES);
    SysFreeString(SCHEMA_KEY_COMMANDTYPE);
    SysFreeString(SCHEMA_KEY_INFINSTALL);
	SysFreeString(SCHEMA_KEY_CODEBASE);
	SysFreeString(SCHEMA_KEY_CRC);
	SysFreeString(SCHEMA_KEY_PATCHAVAILABLE);
	SysFreeString(SCHEMA_KEY_SIZE);
	SysFreeString(SCHEMA_KEY_DOWNLOADPATH);
	SysFreeString(SCHEMA_KEY_DOWNLOADSTATUS);
    SysFreeString(SCHEMA_KEY_DEPENDENCIES);
    SysFreeString(SCHEMA_KEY_DESCRIPTION);
	SysFreeString(SCHEMA_KEY_HREF);
	SysFreeString(SCHEMA_KEY_LANGUAGE);
	SysFreeString(SCHEMA_KEY_PLATFORM);
	SysFreeString(SCHEMA_KEY_PROCESSORARCHITECTURE);
	SysFreeString(SCHEMA_KEY_SUITE);
	SysFreeString(SCHEMA_KEY_PRODUCTTYPE);
	SysFreeString(SCHEMA_KEY_LOCALE);
	SysFreeString(SCHEMA_KEY_CONTEXT);
	SysFreeString(SCHEMA_KEY_MAJOR);
	SysFreeString(SCHEMA_KEY_MINOR);
	SysFreeString(SCHEMA_KEY_BUILD);
	SysFreeString(SCHEMA_KEY_SERVICEPACKMAJOR);
	SysFreeString(SCHEMA_KEY_SERVICEPACKMINOR);
    SysFreeString(SCHEMA_KEY_COMPATIBLEHARDWARE);
    SysFreeString(SCHEMA_KEY_DEVICES);
    SysFreeString(SCHEMA_KEY_DEVICE);
    SysFreeString(SCHEMA_KEY_PRINTERINFO);
    SysFreeString(SCHEMA_KEY_CDM_PINFO);
	SysFreeString(SCHEMA_KEY_DRIVERNAME);
	SysFreeString(SCHEMA_KEY_HWID);
    SysFreeString(SCHEMA_KEY_CDM_HWIDPATH);
    SysFreeString(SCHEMA_KEY_DESCRIPTIONTEXT);
    SysFreeString(SCHEMA_KEY_TITLE);
    SysFreeString(SCHEMA_KEY_ITEMID);
    SysFreeString(SCHEMA_KEY_HIDDEN);
    SysFreeString(SCHEMA_KEY_ISPRINTER);
    SysFreeString(SCHEMA_KEY_DEVICEINSTANCE);
    SysFreeString(SCHEMA_KEY_DRIVERPROVIDER);
    SysFreeString(SCHEMA_KEY_MFGNAME);
    SysFreeString(SCHEMA_KEY_DRIVERVER);
    SysFreeString(SCHEMA_KEY_RANK);
    SysFreeString(SCHEMA_KEY_READMORE);
    SysFreeString(SCHEMA_KEY_ERRORCODE);
    
    SysFreeString(SCHEMA_KEY_CATALOGSTATUS);
    SysFreeString(SCHEMA_KEY_PID);

	SysFreeString(SCHEMA_KEY_DETECTRESULT);
	SysFreeString(SCHEMA_KEY_INSTALLED);
	SysFreeString(SCHEMA_KEY_UPTODATE);
	SysFreeString(SCHEMA_KEY_NEWERVERSION);
	SysFreeString(SCHEMA_KEY_EXCLUDED);
	SysFreeString(SCHEMA_KEY_FORCE);

	SysFreeString(SCHEMA_KEY_VERSTATUS_HI);
	SysFreeString(SCHEMA_KEY_VERSTATUS_HE);
	SysFreeString(SCHEMA_KEY_VERSTATUS_EQ);
	SysFreeString(SCHEMA_KEY_VERSTATUS_LE);
	SysFreeString(SCHEMA_KEY_VERSTATUS_LO);

	SysFreeString(SCHEMA_KEY_CLIENT);
	SysFreeString(SCHEMA_KEY_CLIENTINFO);
	SysFreeString(SCHEMA_KEY_CLIENTNAME);

	SysFreeString(SCHEMA_KEY_IDENTITY);
	SysFreeString(SCHEMA_KEY_PUBLISHERNAME);
	SysFreeString(SCHEMA_KEY_FILE);
	SysFreeString(SCHEMA_KEY_REGKEY);
	SysFreeString(SCHEMA_KEY_PATH);
	SysFreeString(SCHEMA_KEY_STATUS_COMPLETE);
	SysFreeString(SCHEMA_KEY_STATUS_FAILED);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\schemamisc\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	schema
#
# Abstract:		schema and xml utility functions used by IU and AU
#
MAJORCOMP=windows.com
MINORCOMP=lib.schemamisc

TARGETNAME=schemamisc
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

INCLUDES= $(INCLUDES);$(WINDOWS_COM)\inc

SOURCES= schemamisc.CPP \
	 schemakeys.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\logging\freelog.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   FreeLog.cpp
//
//  Owner:  KenSh
//
//  Description:
//
//      Runtime logging for use in both checked and free builds.
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <malloc.h>
#include "FreeLog.h"
#include <MISTSAFE.h>

#ifndef _countof
#define _countof(ar) (sizeof(ar)/sizeof((ar)[0]))
#endif

// Unicode files start with the 2 bytes { FF FE }.
// This is the little-endian version of those 2 bytes.
#define UNICODE_FILE_HEADER 0xFEFF

#define MUTEX_TIMEOUT       1000    // Don't wait more than 1 second to write to logfile
#define MAX_MUTEX_WAITS     4       // Don't keep trying after this many failures

#define LOG_FILE_BIG_SIZE   50000   // Don't bother trimming if file is smaller than this
#define LOG_LINES_TRIM_FROM 1000    // Start trimming if more than this many lines
#define LOG_LINES_TRIM_TO   750     // Trim til the log file is this many lines

#define LOG_LEVEL_SUCCESS   0
#define LOG_LEVEL_FAILURE   1

#define MAX_MSG_LENGTH (MAX_PATH + 20)
#define MAX_ERROR_LENGTH 128

static const TCHAR c_szUnknownModuleName[] = _T("?");

// Local functions
void LogMessageExV(UINT nLevel, DWORD dwError, LPCSTR pszFormatA, va_list args);





//============================================================================
//
// Private CFreeLogging class to keep track of log file resources
//
//============================================================================

class CFreeLogging
{
public:
	CFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName);
	~CFreeLogging();

	void WriteLine(LPCTSTR pszText, UINT nLevel, DWORD dwError);

private:
	inline static HANDLE CreateMutex(LPCTSTR pszMutexName);
	inline HANDLE OpenLogFile(LPCTSTR pszFileName);
	inline void CloseLogFile();
	void TrimLogFile();

	BOOL AcquireMutex();
	void ReleaseMutex();

private:
	HANDLE m_hFile;
	HANDLE m_hMutex;
	int m_cLinesWritten;
	int m_cFailedWaits;
	LPTSTR m_pszModuleName;
};
CFreeLogging* g_pFreeLogging;

//============================================================================
//
// Public functions
//
//============================================================================

void InitFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName)
{
	if (g_pFreeLogging == NULL)
	{
		g_pFreeLogging = new CFreeLogging(pszModuleName, pszLogFileName);
	}
}

void TermFreeLogging()
{
	delete g_pFreeLogging;
	g_pFreeLogging = NULL;
}

void LogMessage(LPCSTR pszFormatA, ...)
{
	va_list arglist;
	va_start(arglist, pszFormatA);
	LogMessageExV(LOG_LEVEL_SUCCESS, 0, pszFormatA, arglist);
	va_end(arglist);
}

void LogError(DWORD dwError, LPCSTR pszFormatA, ...)
{
	va_list arglist;
	va_start(arglist, pszFormatA);
	LogMessageExV(LOG_LEVEL_FAILURE, dwError, pszFormatA, arglist);
	va_end(arglist);
}


void LogMessageExV(UINT nLevel, DWORD dwError, LPCSTR pszFormatA, va_list args)
{
	if (g_pFreeLogging != NULL)
	{
		char szBufA[MAX_MSG_LENGTH];
		
		size_t nRem=0;
		StringCchVPrintfExA(szBufA, _countof(szBufA), NULL, &nRem, MISTSAFE_STRING_FLAGS, pszFormatA, args);
		int cchA = _countof(szBufA) - nRem;

#ifdef UNICODE
		WCHAR szBufW[MAX_MSG_LENGTH];
		MultiByteToWideChar(CP_ACP, 0, szBufA, cchA+1, szBufW, _countof(szBufW));
		g_pFreeLogging->WriteLine(szBufW, nLevel, dwError);
#else
		g_pFreeLogging->WriteLine(szBufA, nLevel, dwError);
#endif
	}
}

//============================================================================
//
// CFreeLogging implementation
//
//============================================================================

CFreeLogging::CFreeLogging(LPCTSTR pszModuleName, LPCTSTR pszLogFileName)
	: m_cFailedWaits(0),
	  m_cLinesWritten(0)
{
	m_pszModuleName = _tcsdup(pszModuleName);
	if (m_pszModuleName == NULL)
		m_pszModuleName = (LPTSTR)c_szUnknownModuleName;

	m_hMutex = CreateMutex(pszLogFileName);
	m_hFile = OpenLogFile(pszLogFileName);
}

CFreeLogging::~CFreeLogging()
{
	CloseLogFile();
	if (m_hMutex != NULL)
		CloseHandle(m_hMutex);

	if (m_pszModuleName != c_szUnknownModuleName)
		free(m_pszModuleName);
}

inline HANDLE CFreeLogging::CreateMutex(LPCTSTR pszMutexName)
{
	// Create a mutex in the global namespace (works across TS sessions)
	HANDLE hMutex = ::CreateMutex(NULL, FALSE, pszMutexName);
	return hMutex;
}

inline HANDLE CFreeLogging::OpenLogFile(LPCTSTR pszLogFileName)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;

	TCHAR szPath[MAX_PATH+1];

	int cch = GetWindowsDirectory(szPath, _countof(szPath)-1);
		
	if(cch >0)
	{
		if (szPath[cch-1] != _T('\\'))
			szPath[cch++] = _T('\\');

		HRESULT hr = StringCchCopyEx(szPath + cch, _countof(szPath)-cch, pszLogFileName, NULL, NULL, MISTSAFE_STRING_FLAGS);

		if(FAILED(hr))
			return hFile;

		hFile = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE, 
						FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
						OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}


#ifdef UNICODE
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (AcquireMutex())
		{
			//
			// Check for the unicode header { FF FE }
			//
			WORD wHeader = 0;
			DWORD cbRead;
			(void)ReadFile(hFile, &wHeader, sizeof(wHeader), &cbRead, NULL);

			//
			// Write the header if there isn't one. This may be due to the
			// file being newly created, or to an ANSI-formatted file.
			//
			if (wHeader != UNICODE_FILE_HEADER)
			{
				SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

				DWORD cbWritten;
				wHeader = UNICODE_FILE_HEADER;
				WriteFile(hFile, &wHeader, sizeof(wHeader), &cbWritten, NULL);
				SetEndOfFile(hFile);
			}

			ReleaseMutex();
		}
	}
#endif

	return hFile;
}

inline void CFreeLogging::CloseLogFile()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		// Trim old stuff from the log before closing the file
		TrimLogFile();

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE; 
	}
}

BOOL CFreeLogging::AcquireMutex()
{
	// In rare case where mutex not created, we allow file operations
	// with no synchronization
	if (m_hMutex == NULL)
		return TRUE;

	// Don't keep waiting if we've been blocked in the past
	if (m_cFailedWaits >= MAX_MUTEX_WAITS)
		return FALSE;

	BOOL fResult = TRUE;
	if (WaitForSingleObject(m_hMutex, MUTEX_TIMEOUT) != WAIT_OBJECT_0)
	{
		fResult = FALSE;
		m_cFailedWaits++;
	}

	return fResult;
}

void CFreeLogging::ReleaseMutex()
{
	if (m_hMutex != NULL) // Note: AcquireMutex succeeds even if m_hMutex is NULL
	{
		::ReleaseMutex(m_hMutex);
	}
}

void CFreeLogging::WriteLine(LPCTSTR pszText, UINT nLevel, DWORD dwError)
{
	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		DWORD cbText = lstrlen(pszText) * sizeof(TCHAR);

		if (AcquireMutex())
		{
			DWORD cbWritten;

			SetFilePointer(m_hFile, 0, NULL, FILE_END);

			//
			// Write time/date/module as a prefix
			//
			//     2001-05-03 13:49:01  21:49:01   CDM      Failed   Loading module (Error 0x00000005: Access is denied.)
			//
			// NOTE: ISO 8601 format for date/time. Local time first, then GMT.
			//
			TCHAR szPrefix[60];
			SYSTEMTIME sysTime, gmtTime;
			GetLocalTime(&sysTime);
			GetSystemTime(&gmtTime);
			LPCTSTR pszStatus = (nLevel == LOG_LEVEL_SUCCESS) ? _T("Success") : _T("Error  ");

			StringCchPrintfEx(szPrefix, _countof(szPrefix), NULL, NULL, MISTSAFE_STRING_FLAGS,
				_T("%04d-%02d-%02d %02d:%02d:%02d  %02d:%02d:%02d   %s   %-13s  "),
					sysTime.wYear, sysTime.wMonth, sysTime.wDay, 
					sysTime.wHour, sysTime.wMinute, sysTime.wSecond,
					gmtTime.wHour, gmtTime.wMinute, gmtTime.wSecond,
					pszStatus, m_pszModuleName);
			
			WriteFile(m_hFile, szPrefix, lstrlen(szPrefix) * sizeof(TCHAR), &cbWritten, NULL);

			//
			// Write the message followed by error info (if any) and a newline
			//
			WriteFile(m_hFile, pszText, cbText, &cbWritten, NULL);

			if (nLevel != LOG_LEVEL_SUCCESS)
			{
				TCHAR szError[MAX_ERROR_LENGTH];
				HRESULT hr=S_OK;
				size_t nRem=0;

				// nRem contains the remaining characters in the buffer including the null terminator
				// To get the number of characters written in to the buffer we use
				// int cchErrorPrefix = _countof(szError) - nRem;

				StringCchPrintfEx(szError, _countof(szError), NULL, &nRem, MISTSAFE_STRING_FLAGS, _T(" (Error 0x%08X: "), dwError);

				// Get the number of characters written in to the buffer
				int cchErrorPrefix = _countof(szError) - nRem;
				int cchErrorText = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, 
												 szError + cchErrorPrefix, _countof(szError) - cchErrorPrefix - 1, NULL);
				int cchError = cchErrorPrefix + cchErrorText;
				cchError -= 2; // backup past ": " or "\r\n"

				StringCchCopyEx(szError + cchError, _countof(szError)-cchError, _T(")"), NULL, NULL, MISTSAFE_STRING_FLAGS);

				WriteFile(m_hFile, szError, (cchError + 1) * sizeof(TCHAR), &cbWritten, NULL);
			}

			WriteFile(m_hFile, _T("\r\n"), 2 * sizeof(TCHAR), &cbWritten, NULL);

			//
			// If we've written a ton of stuff, trim now rather than waiting
			// for the module to unload. (This check is only for how much this
			// module has written, not how big the log file itself is.)
			//
			if (++m_cLinesWritten > LOG_LINES_TRIM_FROM)
			{
				TrimLogFile();
				m_cLinesWritten = LOG_LINES_TRIM_TO;
			}

			ReleaseMutex();
		}
	}
}

// Checks the size of the log file, and trims it if necessary.
void CFreeLogging::TrimLogFile()
{
	if (AcquireMutex())
	{
		DWORD cbFile = GetFileSize(m_hFile, NULL);

		if (cbFile > LOG_FILE_BIG_SIZE)
		{
			DWORD cbFileNew = cbFile;

			//
			// Create a memory-mapped file so we can use memmove
			//
			HANDLE hMapping = CreateFileMapping(m_hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
			if (hMapping != NULL)
			{
				LPTSTR pszFileStart = (LPTSTR)MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0);
				if (pszFileStart != NULL)
				{
					LPTSTR pszEnd = (LPTSTR)((LPBYTE)pszFileStart + cbFile);

					LPTSTR pszTextStart = pszFileStart;
			#ifdef UNICODE
					pszTextStart++; // skip the 2-byte header
			#endif

					//
					// Count newlines
					//
					int cLines = 0;
					for (LPTSTR pch = pszTextStart; pch < pszEnd; )
					{
						if (*pch == _T('\n'))
							cLines++;

						// REVIEW: in Ansi builds should we call CharNextExA?
						//   If so, what code page is the log file in?
						pch++;
					}

					if (cLines > LOG_LINES_TRIM_FROM)
					{
						int cTrimLines = cLines - LOG_LINES_TRIM_TO;
						for (pch = pszTextStart; pch < pszEnd; )
						{
							if (*pch == _T('\n'))
								cTrimLines--;

							// REVIEW: in Ansi builds should we call CharNextExA?
							//   If so, what code page is the log file in?
							pch++;

							if (cTrimLines <= 0)
								break;
						}

						// Move more recent data to beginning of file
						int cchMove = (int)(pszEnd - pch);
						memmove(pszTextStart, pch, cchMove * sizeof(TCHAR));
						cbFileNew = (cchMove * sizeof(TCHAR));

			#ifdef UNICODE
						cbFileNew += sizeof(WORD);
			#endif
					}
					UnmapViewOfFile(pszFileStart);
				}
				CloseHandle(hMapping);

				if (cbFileNew != cbFile)
				{
					// Truncate the file, now that we've moved data as needed
					SetFilePointer(m_hFile, cbFileNew, NULL, FILE_BEGIN);
					SetEndOfFile(m_hFile);
				}
			}
		}

		ReleaseMutex();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\testkeys\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	WUTestKeys
#
# Abstract:		Verify if test keys should be allowed or not
#
MAJORCOMP=windows.com
MINORCOMP=lib.WUTestKeys

TARGETNAME=WUTestKeys
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\WUTestKeys.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\schemamisc\schemamisc.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   SchemaMisc.CPP
//
//	Author:	Charles Ma
//			2000.10.27
//
//  Description:
//
//      Implement helper functions related to IU schemas
//
//=======================================================================

//#include "iuengine.h"	// PCH - must include first
#include <windows.h>
#include <tchar.h>
#include <ole2.h>
//#include "iu.h"
#include <iucommon.h>

#include "schemamisc.h"
#include <MemUtil.h>
#include "regutil.h"
#include "fileutil.h"
#include "stringutil.h"
#include <shlwapi.h>	// pathappend() api
#include "schemakeys.h"
#include <URLLogging.h>
#include <MISTSAFE.h>

#include<wusafefn.h>

//
// max length of platform when being converted into string
// this is an artificial number that we think enough to
// take any MS platform data.
//
const UINT MAX_PLATFORM_STR_LEN = 1024;

//
// private flags used by functions to retrieve string data
//
const DWORD SKIP_SUITES				= 0x1;
const DWORD SKIP_SERVICEPACK_VER	= 0x2;

const long	MAX_VERSION = 256;

const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_SCHEMAVALIDATION[] = _T("ValidateSchema");

//
// Global pointer gets initialized to NULL by runtime. Any module including schemamisc.h must
// allocate this object following its call to CoInitialize, and delete the object before
// calling CoUninitialize.
//
CSchemaKeys * g_pGlobalSchemaKeys /* = NULL */;

#define QuitIfNull(p) {if (NULL == p) {hr = E_INVALIDARG; return hr;}}
#define QuitIfFail(x) {hr = x; if (FAILED(hr)) goto CleanUp;}


/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name under the given parent node
// Return value:
//		S_OK if *ppNode returns matching node value
//		HRESULT_FROM_WIN32(ERROR_NOT_FOUND)		if node not found
//		FAILED()								otherwise
// Caller is responsible for releasing *ppNode.
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMNode* pParentNode, BSTR bstrName, IXMLDOMNode** ppNode)
{
	HRESULT		hr	= S_OK;

	QuitIfNull(ppNode);
	*ppNode = NULL;
	QuitIfNull(pParentNode);
	QuitIfNull(bstrName);

	hr = pParentNode->selectSingleNode(bstrName, ppNode);
	if (S_FALSE == hr)
	{
		hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}
	if (FAILED(hr))
	{
		*ppNode = NULL;
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindSingleDOMNode()
//
// Retrieve the first xml node with the given tag name in the given xml doc
// Return value:
//		S_OK if *ppNode returns matching node value
//		HRESULT_FROM_WIN32(ERROR_NOT_FOUND)		if node not found
//		FAILED()								otherwise
// Caller is responsible for releasing *ppNode.
/////////////////////////////////////////////////////////////////////////////
HRESULT FindSingleDOMNode(IXMLDOMDocument* pDoc, BSTR bstrName, IXMLDOMNode** ppNode)
{
	HRESULT		hr	= S_OK;
	IXMLDOMNode	*pParentNode = NULL;

	QuitIfNull(ppNode);
	*ppNode = NULL;
	QuitIfNull(pDoc);
	QuitIfNull(bstrName);
	if (SUCCEEDED(hr = pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode)))
	{
		hr = FindSingleDOMNode(pParentNode, bstrName, ppNode);
		SafeRelease(pParentNode);
	}
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name under the given parent node
// Return value: NULL if failed or no match; matching node list otherwise.
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMNode* pParentNode, BSTR bstrName)
{
	HRESULT		hr	= S_OK;
	IXMLDOMNodeList *pNodeList = NULL;
	LONG	lLength = 0;

	if (NULL == pParentNode ||
		NULL == bstrName ||
		FAILED(pParentNode->selectNodes(bstrName, &pNodeList)) ||
		NULL == pNodeList)
	{
		return NULL;
	}

	if (SUCCEEDED(pNodeList->get_length(&lLength)) &&
		lLength > 0)
	{
		return pNodeList;
	}

	SafeRelease(pNodeList);
	return NULL;
}


/////////////////////////////////////////////////////////////////////////////
// FindDOMNodeList()
//
// Retrieve the xml nodelist with the given tag name in the given xml doc
// Return value: NULL if failed or no match; matching node list otherwise.
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNodeList* FindDOMNodeList(IXMLDOMDocument* pDoc, BSTR bstrName)
{	
	IXMLDOMNode		*pParentNode = NULL;
	IXMLDOMNodeList *pNodeList = NULL;

	if (NULL != pDoc &&
		NULL != bstrName &&
		SUCCEEDED(pDoc->QueryInterface(IID_IXMLDOMNode, (void**)&pParentNode)))
	{
		pNodeList = FindDOMNodeList(pParentNode, bstrName);
		pParentNode->Release();
	}
	return pNodeList;
}

	
/////////////////////////////////////////////////////////////////////////////
// CreateDOMNode()
//
// Create an xml node of the given type
/////////////////////////////////////////////////////////////////////////////
IXMLDOMNode* CreateDOMNode(IXMLDOMDocument* pDoc, SHORT nType, BSTR bstrName, BSTR bstrNamespaceURI /*= NULL*/)
{
	if (NULL == pDoc ||
		(NODE_TEXT != nType && NULL == bstrName))
	{
		return NULL;
	}

    IXMLDOMNode	*pNode = NULL;
    VARIANT		vType;
	VariantInit(&vType);

    vType.vt = VT_I2;
    vType.iVal = nType;

	if (S_OK != pDoc->createNode(vType, bstrName, bstrNamespaceURI, &pNode))
	{
		return NULL;
	}

    return pNode;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (integer) from the xml node
// If function fails, *piAttr preserves original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT* piAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(piAttr);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_INT == vAttr.vt)
	{
		*piAttr = vAttr.intVal;
	}
	else if (VT_BSTR == vAttr.vt)
	{
		*piAttr = (INT)MyBSTR2L(vAttr.bstrVal);
	}
	else if (VT_I2 == vAttr.vt)
	{
		*piAttr = vAttr.iVal;
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (long) from the xml node
// If function fails, *piAttr preservers original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, LONG* plAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(plAttr);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_I4 == vAttr.vt)
	{
		*plAttr = vAttr.lVal;
	}
	else if (VT_BSTR == vAttr.vt)
	{
		*plAttr = MyBSTR2L(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (BOOL) from the xml node
// If function fails, *piAttr preservers original value.
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttributeBOOL(IXMLDOMNode* pNode, BSTR bstrName, BOOL * pfAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);
    QuitIfNull(pfAttr);

	VARIANT		vAttr;
	VARIANT		vAttrBool;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));

    QuitIfFail(VariantChangeType(&vAttr, &vAttrBool, 0, VT_BOOL));              

    VariantClear(&vAttr);

    *pfAttr = (VARIANT_TRUE == vAttrBool.boolVal) ? TRUE : FALSE;

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetAttribute()
//
// Get attribute (BSTR) from the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR* pbstrAttr)
{
	HRESULT		hr = S_OK;
    QuitIfNull(pbstrAttr);
	*pbstrAttr = NULL;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);

	VARIANT		vAttr;
    IXMLDOMElement		*pElement = NULL;
    IXMLDOMAttribute	*pAttrNode = NULL;;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
	QuitIfFail(pElement->getAttributeNode(bstrName, &pAttrNode));
	if (NULL == pAttrNode) goto CleanUp;

	QuitIfFail(pAttrNode->get_value(&vAttr));
	if (VT_BSTR == vAttr.vt)
	{
		*pbstrAttr = SysAllocString(vAttr.bstrVal);
	}
	else
	{
		hr = E_FAIL;
	}
	VariantClear(&vAttr);

CleanUp:
    SafeRelease(pElement);
    SafeRelease(pAttrNode);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (integer) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, INT iAttr)
{
    VARIANT		vAttr;
	VariantInit(&vAttr);
	vAttr.vt = VT_INT;
    vAttr.intVal = iAttr;
    return SetAttribute(pNode, bstrName, vAttr);
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (BSTR) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, BSTR bstrAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(bstrAttr);

    VARIANT		vAttr;
	VariantInit(&vAttr);
    vAttr.vt = VT_BSTR;
    vAttr.bstrVal = bstrAttr;
    return SetAttribute(pNode, bstrName, vAttr);
}


/////////////////////////////////////////////////////////////////////////////
// SetAttribute()
//
// Set attribute (VARIANT) to the xml element
/////////////////////////////////////////////////////////////////////////////
HRESULT SetAttribute(IXMLDOMNode* pNode, BSTR bstrName, VARIANT vAttr)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);
	QuitIfNull(bstrName);

    IXMLDOMElement	*pElement = NULL;

    QuitIfFail(pNode->QueryInterface(IID_IXMLDOMElement, (void**)&pElement));
    QuitIfFail(pElement->setAttribute(bstrName, vAttr));

CleanUp:
    SafeRelease(pElement);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// GetText()
//
// Get text (BSTR) from the xml node
// Returns
//		S_OK if *pbstrText returns text of 1st child of the given node
//		S_FALSE if node has no child or 1st child has no text
//		FAILED() otherwise
/////////////////////////////////////////////////////////////////////////////
HRESULT GetText(IXMLDOMNode* pNode, BSTR* pbstrText)
{
	//USES_IU_CONVERSION;

	HRESULT		hr = E_FAIL;
	QuitIfNull(pbstrText);
	*pbstrText = NULL;
	QuitIfNull(pNode);

	DOMNodeType		nNodeType;
    IXMLDOMNode*	pNodeText = NULL;

	QuitIfFail(pNode->get_firstChild(&pNodeText));
	if (NULL == pNodeText) goto CleanUp;

	QuitIfFail(pNodeText->get_nodeType(&nNodeType));
	if (NODE_TEXT == nNodeType)
	{
		QuitIfFail(pNodeText->get_text(pbstrText));	
	}
	else
	{
		hr = E_UNEXPECTED;
	}

CleanUp:
	SafeRelease(pNodeText);
	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (integer) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, INT iValue)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);

    VARIANT		vValue;
	VariantInit(&vValue);
    vValue.vt = VT_INT;
    vValue.intVal = iValue;
    return (pNode->put_nodeValue(vValue));
}


/////////////////////////////////////////////////////////////////////////////
// SetValue()
//
// Set value (BSTR) for the xml node
/////////////////////////////////////////////////////////////////////////////
HRESULT SetValue(IXMLDOMNode* pNode, BSTR bstrValue)
{
	HRESULT		hr = S_OK;
	QuitIfNull(pNode);

    VARIANT		vValue;
	VariantInit(&vValue);
    vValue.vt = VT_BSTR;
    vValue.bstrVal = bstrValue;
    return (pNode->put_nodeValue(vValue));
}


/////////////////////////////////////////////////////////////////////////////
// InsertNode()
//
// Insert a child node to the parent node
/////////////////////////////////////////////////////////////////////////////
HRESULT InsertNode(IXMLDOMNode* pParentNode, IXMLDOMNode* pChildNode, IXMLDOMNode* pChildNodeRef /*= NULL*/)
{
	HRESULT		hr = S_OK;

	QuitIfNull(pParentNode);
	QuitIfNull(pChildNode);

	IXMLDOMNode	*p = NULL;
    if (NULL != pChildNodeRef)	// insert before the ref child node
	{
		VARIANT	vChildNodeRef;
	    VariantInit(&vChildNodeRef);
		vChildNodeRef.vt = VT_UNKNOWN;
		vChildNodeRef.punkVal = pChildNodeRef;
		QuitIfFail(pParentNode->insertBefore(pChildNode, vChildNodeRef, &p));
	}
	else						// append to the child list
	{
		VARIANT	vEmpty;
	    VariantInit(&vEmpty);
		vEmpty.vt = VT_EMPTY;
		QuitIfFail(pParentNode->insertBefore(pChildNode, vEmpty, &p));
	}

CleanUp:
    SafeRelease(p);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CopyNode()
//
// Create an xml node as a copy of the given node;
// this is different from cloneNode() as it copies node across xml document
/////////////////////////////////////////////////////////////////////////////
HRESULT CopyNode(IXMLDOMNode* pNodeSrc, IXMLDOMDocument* pDocDes, IXMLDOMNode** ppNodeDes)
{
	HRESULT hr = S_OK;
	BSTR	bstrNodeName = NULL;
	BSTR	bstrText = NULL;
	BSTR	bstrAttrName = NULL;
	IXMLDOMNode			*pChild = NULL;
	IXMLDOMNamedNodeMap	*pAttrs = NULL;

	LOG_Block("CopyNode()");

	QuitIfNull(ppNodeDes);
	*ppNodeDes = NULL;
	QuitIfNull(pNodeSrc);
	QuitIfNull(pDocDes);

	DOMNodeType		nNodeType;
	CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_nodeType(&nNodeType));

	switch (nNodeType)
	{
	case NODE_TEXT:
	{
		CleanUpFailedAllocSetHrMsg(*ppNodeDes = CreateDOMNode(pDocDes, NODE_TEXT, NULL));
		CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_text(&bstrText));
		CleanUpIfFailedAndSetHrMsg(SetValue(*ppNodeDes, bstrText));
		break;
	}
	case NODE_ELEMENT:
	{
		CleanUpIfFailedAndSetHrMsg(pNodeSrc->get_nodeName(&bstrNodeName));
		CleanUpFailedAllocSetHrMsg(*ppNodeDes = CreateDOMNode(pDocDes, NODE_ELEMENT, bstrNodeName));

		if (SUCCEEDED(pNodeSrc->get_attributes(&pAttrs)) && (NULL != pAttrs))
		{
			pAttrs->nextNode(&pChild);
			while (pChild)
			{
				CleanUpIfFailedAndSetHrMsg(pChild->get_nodeName(&bstrAttrName));

				VARIANT vAttrValue;
				CleanUpIfFailedAndSetHrMsg(pChild->get_nodeValue(&vAttrValue));
				hr = SetAttribute(*ppNodeDes, bstrAttrName, vAttrValue);
				VariantClear(&vAttrValue);
				CleanUpIfFailedAndMsg(hr);

				SafeSysFreeString(bstrAttrName);
				SafeReleaseNULL(pChild);
				pAttrs->nextNode(&pChild);
			}
			pAttrs->Release();
			pAttrs = NULL;
		}

		pNodeSrc->get_firstChild(&pChild);
		while (pChild)
		{
			IXMLDOMNode *pChildDes = NULL;
			CleanUpIfFailedAndSetHrMsg(CopyNode(pChild, pDocDes, &pChildDes));
			hr = InsertNode(*ppNodeDes, pChildDes);
			SafeRelease(pChildDes);
			CleanUpIfFailedAndMsg(hr);

			IXMLDOMNode *pNext = NULL;
			CleanUpIfFailedAndMsg(pChild->get_nextSibling(&pNext));
			pChild->Release();
			pChild = pNext;
		}
		hr = S_OK;
		break;
	}
	default:
		//
		// for now, do nothing for other node types
		//
		;
	}

CleanUp:
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppNodeDes);
	}
	SysFreeString(bstrNodeName);
	SysFreeString(bstrText);
	SysFreeString(bstrAttrName);
	SafeRelease(pChild);
	SafeRelease(pAttrs);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// AreNodesEqual()
//
// Return TRUE if two nodes are identical, return FALSE if function failed or
// if they're different (including order of attributes).
/////////////////////////////////////////////////////////////////////////////
BOOL AreNodesEqual(IXMLDOMNode* pNode1, IXMLDOMNode* pNode2)
{
	if (pNode1 == pNode2)
	{
		return TRUE;
	}
	if ((NULL == pNode1) || (NULL == pNode2))
	{
		return FALSE;
	}

	BOOL fResult = FALSE;
	BOOL fSkipAttribute = FALSE;
	BOOL fSkipChildNode = FALSE;
	LONG lenAttr1= -1 , lenAttr2= -1;
	LONG lenNode1= -1 , lenNode2= -1;
	DOMNodeType	nNodeType1, nNodeType2;
	BSTR bstrText1 = NULL, bstrText2 = NULL;
	BSTR bstrNodeName1 = NULL, bstrNodeName2 = NULL;
	BSTR bstrAttrName1 = NULL, bstrAttrName2 = NULL;
	IXMLDOMNodeList *pChildNodes1 = NULL, *pChildNodes2 = NULL;
	IXMLDOMNode	*pChild1= NULL, *pNext1 = NULL;
	IXMLDOMNode	*pChild2= NULL, *pNext2 = NULL;
	IXMLDOMNamedNodeMap	*pAttrs1 = NULL, *pAttrs2 = NULL;
	VARIANT vAttrValue1, vAttrValue2;

	VariantInit(&vAttrValue1);
	VariantInit(&vAttrValue2);

	if (FAILED(pNode1->get_nodeType(&nNodeType1)) ||
		FAILED(pNode2->get_nodeType(&nNodeType2)) ||
		(nNodeType1 != nNodeType2))
	{
		goto CleanUp;
	}

	switch (nNodeType1)
	{
	case NODE_TEXT:
	{
		if (FAILED(pNode1->get_text(&bstrText1)) ||
			FAILED(pNode2->get_text(&bstrText2)) ||
			!CompareBSTRsEqual(bstrText1, bstrText2))
		{
			goto CleanUp;
		}
		break;
	}
	case NODE_ELEMENT:
	{
		if (FAILED(pNode1->get_nodeName(&bstrNodeName1)) ||
			FAILED(pNode2->get_nodeName(&bstrNodeName2)) ||
			!CompareBSTRsEqual(bstrNodeName1, bstrNodeName2))
		{
			goto CleanUp;
		}

		//
		// 1. compare number of attributes
		//
		if (FAILED(pNode1->get_attributes(&pAttrs1)) ||
			FAILED(pNode2->get_attributes(&pAttrs2)))
		{
			// this shouldn't happen, but...
			goto CleanUp;
		}
		if ((NULL != pAttrs1) && (NULL != pAttrs2))
		{
			if (FAILED(pAttrs1->get_length(&lenAttr1)) ||
				FAILED(pAttrs2->get_length(&lenAttr2)) ||
				(abs(lenAttr1-lenAttr2) > 1))
			{
				// known bug in MSXML3.dll: xmlns="" could be one of the attribute
				goto CleanUp;
			}
		}
		else if (pAttrs1 == pAttrs2)
		{
			// pAttrs1 and pAttrs2 are both NULL,
			// set flag to ingore comparison of each individual attribute,
			// go ahead compare the number of child nodes
			fSkipAttribute = TRUE;
		}
		else
		{
			// one of pAttrs1 and pAttrs2 is NULL, the nodes are obviously different
			goto CleanUp;
		}

		//
		// 2. compare number of child nodes
		//
		if (FAILED(pNode1->get_childNodes(&pChildNodes1)) ||
			FAILED(pNode2->get_childNodes(&pChildNodes2)))
		{
			// this shouldn't happen, but...
			goto CleanUp;
		}
		if ((NULL != pChildNodes1) && (NULL != pChildNodes2))
		{
			if (FAILED(pChildNodes1->get_length(&lenNode1)) ||
				FAILED(pChildNodes2->get_length(&lenNode2)) ||
				(lenNode1 != lenNode2))
			{
				goto CleanUp;
			}
		}
		else if (pChildNodes1 == pChildNodes2)
		{
			// pChildNodes1 and pChildNodes2 are both NULL,
			// set flag to ingore comparison of each individual child node,
			// go ahead compare each attribute in next step
			fSkipChildNode = TRUE;
		}
		else
		{
			// one of pChildNodes1 and pChildNodes2 is NULL, the nodes are obviously different
			goto CleanUp;
		}
		
		//
		// 3. compare each attribute
		//
		if (!fSkipAttribute)
		{
			pAttrs1->nextNode(&pChild1);
			pAttrs2->nextNode(&pChild2);
			while (pChild1 && pChild2)
			{
				if (NULL == bstrAttrName1)
				{
					if (FAILED(pChild1->get_nodeName(&bstrAttrName1)))
					{
						goto CleanUp;
					}
				}
				if (NULL == bstrAttrName2)
				{
					if (FAILED(pChild2->get_nodeName(&bstrAttrName2)))
					{
						goto CleanUp;
					}
				}
				if (!CompareBSTRsEqual(bstrAttrName1, bstrAttrName2))
				{					
					if (CompareBSTRsEqual(bstrAttrName1, KEY_XML_NAMESPACE) && lenAttr1 == lenAttr2+1)
					{
						// ignore xmlns=""
						SafeSysFreeString(bstrAttrName1);
						pChild1->Release();
						pAttrs1->nextNode(&pChild1);
						continue;
					}
					else if (CompareBSTRsEqual(bstrAttrName2, KEY_XML_NAMESPACE) && lenAttr1 == lenAttr2-1)
					{
						// ignore xmlns=""
						SafeSysFreeString(bstrAttrName2);
						pChild2->Release();
						pAttrs2->nextNode(&pChild2);
						continue;
					}
					else
					{
						goto CleanUp;
					}
				}
				else
				{
					VariantInit(&vAttrValue1);
					VariantInit(&vAttrValue2);
					if (FAILED(pChild1->get_nodeValue(&vAttrValue1)) ||
						FAILED(pChild2->get_nodeValue(&vAttrValue2)) ||
						(vAttrValue1.vt != vAttrValue2.vt))
					{
						goto CleanUp;
					}
					switch (vAttrValue1.vt)
					{
					case VT_INT:	// integer
						{
							if (vAttrValue1.intVal != vAttrValue2.intVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_I2:		// short
						{
							if (vAttrValue1.iVal != vAttrValue2.iVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_I4:		// long
						{
							if (vAttrValue1.lVal != vAttrValue2.lVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_BOOL:	// bool
						{
							if (vAttrValue1.boolVal != vAttrValue2.boolVal)
							{
								goto CleanUp;
							}
							break;
						}
					case VT_BSTR:	// BSTR
						{
							if (!CompareBSTRsEqual(vAttrValue1.bstrVal, vAttrValue2.bstrVal))
							{
								goto CleanUp;
							}
							break;
						}
					default:
						//
						// for now, do nothing for other attribute types
						//
						;
					}
					SafeSysFreeString(bstrAttrName1);
					SafeSysFreeString(bstrAttrName2);
					VariantClear(&vAttrValue1);
					VariantClear(&vAttrValue2);
					pChild1->Release();
					pChild2->Release();
					pAttrs1->nextNode(&pChild1);
					pAttrs2->nextNode(&pChild2);
				}
			}

			if (pChild1 != pChild2)
			{
				if (NULL == pChild1)
				{
					// this is the case that we looped through all the attributes in the
					// first node but we still found attribute left in the second node;
					// if it's xmlns="", that's ok; otherwise these two nodes are different.
					if (FAILED(pChild2->get_nodeName(&bstrAttrName2)) ||
						(!CompareBSTRsEqual(bstrAttrName2, KEY_XML_NAMESPACE)))
					{
						goto CleanUp;
					}
				}
				else
				{
					if (FAILED(pChild1->get_nodeName(&bstrAttrName1)) ||
						(!CompareBSTRsEqual(bstrAttrName1, KEY_XML_NAMESPACE)))
					{
						goto CleanUp;
					}
				}
			}
		}

		//
		// 4. compare each child node
		//
		if (!fSkipChildNode)
		{
			pNode1->get_firstChild(&pChild1);
			pNode2->get_firstChild(&pChild2);
			while (pChild1)
			{
				if (!pChild2)
				{
					goto CleanUp;
				}
				if (!AreNodesEqual(pChild1, pChild2))
				{
					goto CleanUp;
				}
				pChild1->get_nextSibling(&pNext1);
				pChild2->get_nextSibling(&pNext2);
				pChild1->Release();
				pChild2->Release();
				pChild1 = pNext1;
				pChild2 = pNext2;
			}
		}
		break;
	}
	default:
		//
		// for now, do nothing for other node types
		//
		;
	}

	fResult = TRUE;

CleanUp:
	SafeSysFreeString(bstrText1);
	SafeSysFreeString(bstrText2);
	SafeSysFreeString(bstrNodeName1);
	SafeSysFreeString(bstrNodeName2);
	SafeSysFreeString(bstrAttrName1);
	SafeSysFreeString(bstrAttrName2);
	SafeRelease(pChildNodes1);
	SafeRelease(pChildNodes2);
	SafeRelease(pChild1);
	SafeRelease(pChild2);
	SafeRelease(pAttrs1);
	SafeRelease(pAttrs2);
	if (vAttrValue1.vt != VT_EMPTY)
		VariantClear(&vAttrValue1);
	if (vAttrValue2.vt != VT_EMPTY)
		VariantClear(&vAttrValue2);

    return fResult;
}


/////////////////////////////////////////////////////////////////////////////
// LoadXMLDoc()
//
// Load an XML Document from string
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadXMLDoc(BSTR bstrXml, IXMLDOMDocument** ppDoc, BOOL fOffline /*= TRUE*/)
{
	HRESULT	hr	= E_FAIL;
	VARIANT_BOOL fSuccess = VARIANT_FALSE, fValidate = VARIANT_FALSE;

	QuitIfNull(ppDoc);
	*ppDoc = NULL;
	QuitIfNull(bstrXml);
 	hr = CoCreateInstance(CLSID_DOMDocument,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  IID_IXMLDOMDocument,
						  (void **) ppDoc);
    if (FAILED(hr))
	{
		return hr;
	}

	fValidate = fOffline ? VARIANT_FALSE : VARIANT_TRUE;

	//
	// we don't do validation unless the reg key is set on to do so
	//
	if (fValidate)
	{
		HKEY	hKey = NULL;
		DWORD	dwValue = 0x0;
		DWORD	dwSize = sizeof(dwValue);
		DWORD	dwType = REG_DWORD;

		fValidate = VARIANT_FALSE;
		if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hKey))
		{
			if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_SCHEMAVALIDATION, NULL, &dwType, (LPBYTE)&dwValue, &dwSize))
			{
				if (REG_DWORD == dwType && sizeof(dwValue) == dwSize && 1 == dwValue)
				{
					fValidate = VARIANT_TRUE;
				}
			}
			RegCloseKey(hKey);
		}
	}

	//
	// force validation on parse if not offline
	//
	hr = (*ppDoc)->put_validateOnParse(fValidate);
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// force resolving external definition if not offline
	//
	hr = (*ppDoc)->put_resolveExternals(fValidate);
	if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// do synchronized loading
	//
    hr = (*ppDoc)->put_async(VARIANT_FALSE);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// load the XML Doc from input string
	//
	hr = (*ppDoc)->loadXML(bstrXml, &fSuccess);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}
	//
	// S_FALSE may be returned even if load fails, but
	// fSuccess will return VARIANT_FALSE if there was
	// an error so we call ValidateDoc to log the error
	// and get the correct HRESULT.
	//
	if (S_FALSE == hr || VARIANT_FALSE == fSuccess)
	{
		hr = ValidateDoc(*ppDoc);

		if (SUCCEEDED(hr))
		{
			hr = E_INVALIDARG;
		}
		SafeReleaseNULL(*ppDoc);
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LoadDocument()
//
// Load an XML Document from the specified file
/////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocument(BSTR bstrFilePath, IXMLDOMDocument** ppDoc, BOOL fOffline /*= TRUE*/)
{
	HRESULT	hr	= E_FAIL;
	VARIANT_BOOL fSuccess = VARIANT_FALSE, fValidate = VARIANT_FALSE;;
    VARIANT vFilePath;

	QuitIfNull(ppDoc);
	*ppDoc = NULL;
	QuitIfNull(bstrFilePath);
 	hr = CoCreateInstance(CLSID_DOMDocument,
						  NULL,
						  CLSCTX_INPROC_SERVER,
						  IID_IXMLDOMDocument,
						  (void **) ppDoc);
    if (FAILED(hr))
	{
		return hr;
	}

	//
	// do synchronized loading
	//
    hr = (*ppDoc)->put_async(VARIANT_FALSE);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	fValidate = fOffline ? VARIANT_FALSE : VARIANT_TRUE;
	//
	// force validation on parse if not offline
	//
	hr = (*ppDoc)->put_validateOnParse(fValidate);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// force resolving external definition if not offline
	//
	hr = (*ppDoc)->put_resolveExternals(fValidate);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}

	//
	// load the XML Doc from the given file path
	//
    VariantInit(&vFilePath);
    vFilePath.vt = VT_BSTR;
    vFilePath.bstrVal = bstrFilePath;
    hr = (*ppDoc)->load(vFilePath, &fSuccess);
    if (FAILED(hr))
	{
		SafeReleaseNULL(*ppDoc);
		return hr;
	}
	//
	// S_FALSE may be returned even if load fails, but
	// fSuccess will return VARIANT_FALSE if there was
	// an error so we call ValidateDoc to log the error
	// and get the correct HRESULT.
	//
	if (VARIANT_FALSE == fSuccess)
	{
	  hr = ValidateDoc(*ppDoc);
	  if (SUCCEEDED(hr))
	  {
		 hr = E_INVALIDARG;
	  }
	  SafeReleaseNULL(*ppDoc);
	}

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SaveDocument()
//
// Save an XML Document to the specified location
/////////////////////////////////////////////////////////////////////////////
HRESULT SaveDocument(IXMLDOMDocument* pDoc, BSTR bstrFilePath)
{
	HRESULT	hr	= E_FAIL;
	QuitIfNull(pDoc);
	QuitIfNull(bstrFilePath);

    //
	// save the XML Doc to the given location
	//
    VARIANT vFilePath;
    VariantInit(&vFilePath);
    vFilePath.vt = VT_BSTR;
    vFilePath.bstrVal = bstrFilePath;
    hr = pDoc->save(vFilePath);
                    
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ReportParseError()
//
// Report parsing error information
/////////////////////////////////////////////////////////////////////////////
HRESULT ReportParseError(IXMLDOMParseError *pXMLError)
{
    USES_IU_CONVERSION;

    HRESULT	hr = S_OK;
    LONG	lLine, lLinePos, lErrCode;
    BSTR	bstrErrText = NULL, bstrReason = NULL;

	QuitIfNull(pXMLError);
    QuitIfFail(pXMLError->get_errorCode(&lErrCode));
	hr = lErrCode;
    QuitIfFail(pXMLError->get_line(&lLine));
    QuitIfFail(pXMLError->get_linepos(&lLinePos));
    QuitIfFail(pXMLError->get_srcText(&bstrErrText));
    QuitIfFail(pXMLError->get_reason(&bstrReason));

    if (lLine > 0)
	{
		LOG_Block("ReportParseError()");
		LOG_Error(_T("XML line %ld, pos %ld error 0x%08x: %s)"),
				  lLine,
				  lLinePos,
				  lErrCode,
				  OLE2T(bstrReason));
		LOG_Error(_T("XML starts: %s"), OLE2T(bstrErrText));

#if defined(_UNICODE) || defined(UNICODE)
		LogError(lErrCode, "loadXML: line %ld, pos %ld, %S",
				  lLine,
				  lLinePos,
				  bstrReason);
		LogMessage("%S", bstrErrText);
#else
		LogError(lErrCode, "loadXML: line %ld, pos %ld, %s",
				  lLine,
				  lLinePos,
				  bstrReason);
		LogMessage("%s", bstrErrText);
#endif
/*
		//
		// We want to ping this error even though we don't have the
		// client information. This most likely indicates a server
		// content error.
		//
		CUrlLog pingSvr;

#define MAX_XML_PING_MSG	512

		TCHAR szMsg[MAX_XML_PING_MSG];
		lstrcpyn(szMsg, OLE2T(bstrErrText), MAX_XML_PING_MSG);

        pingSvr.Ping(
					FALSE,						// on-line (we don't know, so be safe)
					URLLOGDESTINATION_DEFAULT,	//fixcode: should depend of client and corp WU settings
					NULL,						// pt to cancel events
					0,							// number of events
					URLLOGACTIVITY_Detection,	// activity
					URLLOGSTATUS_Failed,		// status code
					lErrCode,					// error code
					NULL,						// itemID
					NULL,						// device data
					szMsg			// first MAX_XML_PING_MSG chars of XML for context
					);
*/
	}

CleanUp:
    SysFreeString(bstrErrText);
    SysFreeString(bstrReason);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// ValidateDoc()
//
// Validate the xml doc against the schema
/////////////////////////////////////////////////////////////////////////////
HRESULT ValidateDoc(IXMLDOMDocument* pDoc)
{
	HRESULT		hr = S_OK;
    QuitIfNull(pDoc);

    LONG				lErrCode = 0;
    IXMLDOMParseError	*pXMLError = NULL;

	QuitIfFail(pDoc->get_parseError(&pXMLError));
    QuitIfFail(pXMLError->get_errorCode(&lErrCode));

    if (lErrCode != 0)
    {
        hr = ReportParseError(pXMLError);
    }
    else
    {
		//
		// no error, so hr = S_FALSE. reset it --- charlma 1/17/01
		//
		hr = S_OK;
    }

CleanUp:
    SafeRelease(pXMLError);
    return hr;
}



//----------------------------------------------------------------------
//
// Helper function FindNode()
//	retrieve the named node
//
//	Input:
//		an IXMLDomNode and a bstr name
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------

BOOL
FindNode(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	IXMLDOMNode** ppFoundNode
)
{
	BSTR			bstrTag		= NULL;
	LONG			lLength		= 0L;
	IXMLDOMNode*	pChild		= NULL;
	IXMLDOMNode*	pNextChild	= NULL;

	if (NULL == pCurrentNode ||
		NULL == bstrName ||
		NULL == ppFoundNode)
	{
		return FALSE;
	}

	*ppFoundNode = NULL;

	if (S_OK == pCurrentNode->selectSingleNode(bstrName, &pChild))
	{
		*ppFoundNode = pChild;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



//----------------------------------------------------------------------
//
// Helper function FindNodeValue()
//	retrieve the named data from child of the current node, 
//
//	Input:
//		an IXMLDomNode
//
//	Return:
//		BOOL, tells succeed or not
//
//	Assumption:
//		input parameter not NULL
//		in case of fail, variant not touched
//
//----------------------------------------------------------------------
BOOL
FindNodeValue(
	IXMLDOMNode* pCurrentNode, 
	BSTR bstrName, 
	BSTR* pbstrValue)
{
	IXMLDOMNode* pChild	= NULL;

	if (NULL == pbstrValue)
	{
		return FALSE;
	}
	
	*pbstrValue = NULL;

	if (FindNode(pCurrentNode, bstrName, &pChild))
	{
		pChild->get_text(pbstrValue);
		SafeRelease(pChild);
		return TRUE;
	}

    return FALSE;
}



//----------------------------------------------------------------------
//
// public function Get3IdentiStrFromIdentNode()
//	retrieve the name, publisherName and GUID from an identity node 
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT Get3IdentiStrFromIdentNode(IXMLDOMNode* pIdentityNode, BSTR* pbstrName, BSTR* pbstrPublisherName, BSTR* pbstrGUID)
{
	HRESULT		hr = E_FAIL;
	BOOL		fPublisherNameExist = FALSE, fGUIDExist = FALSE;

	LOG_Block("Get3IdentiStrFromIdentNode()");

	if (NULL == pIdentityNode || NULL == pbstrName || NULL == pbstrPublisherName || NULL == pbstrGUID)
	{
		return E_INVALIDARG;
	}

	*pbstrName = NULL;
	*pbstrPublisherName = NULL;
	*pbstrGUID = NULL;

	//
	// get name attr
	//
	hr = GetAttribute(pIdentityNode, KEY_NAME, pbstrName);
	CleanUpIfFailedAndMsg(hr);

	//
	// try to get publisherName
	//
	fPublisherNameExist = FindNodeValue(pIdentityNode, KEY_PUBLISHERNAME, pbstrPublisherName);

	fGUIDExist = FindNodeValue(pIdentityNode, KEY_GUID, pbstrGUID);

	hr = (fPublisherNameExist || fGUIDExist) ? S_OK : E_FAIL;

CleanUp:
	
	if (FAILED(hr))
	{
		SysFreeString(*pbstrName);
		SysFreeString(*pbstrPublisherName);
		SysFreeString(*pbstrGUID);
		*pbstrName = NULL;
		*pbstrPublisherName = NULL;
		*pbstrGUID = NULL;
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
// MakeUniqNameString()
//
// This is a utility function to construct the identity name string 
// based on name|publiser|GUID and the rule to make this name string.
//
// This function defines the logic about what components can be used
// to define the uniqueness of an item based on the 3 parts of data from
// GetIdentity().
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MakeUniqNameString(
					BSTR bstrName,
					BSTR bstrPublisher,
					BSTR bstrGUID,
					BSTR* pbstrUniqIdentifierString)
{
    LPWSTR pszResult = NULL;
	DWORD dwLen=0;
	HRESULT hr=S_OK;

	if (NULL == bstrName || SysStringLen(bstrName) == 0 || NULL == pbstrUniqIdentifierString)
	{
		return E_INVALIDARG;
	}

	*pbstrUniqIdentifierString = NULL;

	if (NULL != bstrPublisher && SysStringLen(bstrPublisher) > 0)
	{
		//
		// if we have publisherName, we expect it is
		// reverse DNS name (e.g., com.microsoft), and Name is 
		// the reverse DNS name (e.g., windowsupdate.autoupdate.client)
		// inside that publisher. We combine them with a dot (.)
		//
        // Length of Publisher + Length of Name + 1 for the dot + 1 for null
		dwLen=(SysStringLen(bstrPublisher) + SysStringLen(bstrName) + 2);
        pszResult = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,  dwLen * sizeof(WCHAR));
        
		if (NULL == pszResult)
        {
            return E_OUTOFMEMORY;
        }

		//
		// since we need to work on Win9x too, so we can not use Win32 API
		// for UNICODE, and have to use shlwapi verison
		//

		hr=StringCchCopyExW(pszResult,dwLen,bstrPublisher,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}


		hr=StringCchCatExW(pszResult,dwLen,L".",NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}

		
		hr=StringCchCatExW(pszResult,dwLen,bstrName,NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszResult);
			return hr;
		}

        *pbstrUniqIdentifierString = SysAllocString(pszResult);
        SafeHeapFree(pszResult);
        if (NULL == *pbstrUniqIdentifierString)
        {
            return E_OUTOFMEMORY;
        }
	}
	else
	{
		if (NULL == bstrGUID || SysStringLen(bstrGUID) == 0)
		{
			return E_INVALIDARG;
		}

		//
		// if no suitable publisherName, then we use GUID
		//
		*pbstrUniqIdentifierString = SysAllocString(bstrGUID);
		if (NULL == *pbstrUniqIdentifierString)
		{
			return E_OUTOFMEMORY;
		}
	}
	return S_OK;
}



//----------------------------------------------------------------------
//
// public function UtilGetUniqIdentityStr()
//	retrieve the unique string that make this <identity> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetUniqIdentityStr(
	IXMLDOMNode* pIdentityNode, 
	BSTR* pbstrUniqIdentifierString, 
	DWORD dwFlag)
{
	DWORD dwLen=0;
	LOG_Block("UtilGetUniqIdentityStr");

    IXMLDOMNode *pNodeVersion = NULL;
	IXMLDOMNode *pNodeIdentity = NULL;
	BSTR		bstrName = NULL, 
				bstrPublisher = NULL, 
				bstrGuid = NULL,
				bstrResult = NULL;

	USES_IU_CONVERSION;

	if (NULL == pIdentityNode || NULL == pbstrUniqIdentifierString)
	{
		return E_INVALIDARG;
	}
	//
	// retrive string
	//
	HRESULT hr = Get3IdentiStrFromIdentNode(pIdentityNode, &bstrName, &bstrPublisher, &bstrGuid);
	CleanUpIfFailedAndMsg(hr);

	//
	// construct string to make it unique
	//
	hr = MakeUniqNameString(bstrName, bstrPublisher, bstrGuid, &bstrResult);
	CleanUpIfFailedAndMsg(hr);

	//
	// check if this identity has version node. not all have <identity> nodes have <version>
	//
	if (FindNode(pNodeIdentity, KEY_VERSION, &pNodeVersion) && NULL != pNodeVersion)
	{
		TCHAR szVersion[MAX_VERSION];
        LPWSTR pszUniqueString = NULL;

		hr = UtilGetVersionStr(pNodeVersion, szVersion, dwFlag);
		CleanUpIfFailedAndMsg(hr);

		dwLen=(SysStringLen(bstrResult) + lstrlen(szVersion) + 2);
        pszUniqueString = (LPWSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwLen* sizeof(WCHAR));
        CleanUpFailedAllocSetHrMsg(pszUniqueString);
        
		hr=StringCchCopyExW(pszUniqueString,dwLen,bstrResult,NULL,NULL,MISTSAFE_STRING_FLAGS);
		
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}
		hr=StringCchCatExW(pszUniqueString,dwLen,L".",NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}

		hr=StringCchCatExW(pszUniqueString,dwLen,T2W(szVersion),NULL,NULL,MISTSAFE_STRING_FLAGS);
		if(FAILED(hr))
		{
			SafeHeapFree(pszUniqueString);
			SetHrMsgAndGotoCleanUp(hr);
		}

        *pbstrUniqIdentifierString = SysAllocString(pszUniqueString);
        SafeHeapFree(pszUniqueString);
	}
	else
	{
		*pbstrUniqIdentifierString = SysAllocString(bstrResult);
	}

    CleanUpFailedAllocSetHrMsg(*pbstrUniqIdentifierString);

    hr = S_OK;

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrPublisher);
	SysFreeString(bstrGuid);
	SysFreeString(bstrResult);

	SafeRelease(pNodeVersion);
	SafeRelease(pNodeIdentity);

	return hr;

}



//----------------------------------------------------------------------
//
// public function UtilGetPlatformStr()
//	retrieve the unique string that make this <platform> node unique
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetPlatformStr(
	IXMLDOMNode* pNodePlatform, 
	BSTR* pbstrPlatform, 
	DWORD dwFlag)
{
	HRESULT hr = E_INVALIDARG;
	IXMLDOMNode*	pNodeVersion = NULL;
	IXMLDOMNode*	pNodeSuite = NULL;
	IXMLDOMNodeList* pSuiteList = NULL;
	IXMLDOMElement* pElement = NULL;

	TCHAR	szPlatformStr[MAX_PLATFORM_STR_LEN],
			szVersion[256];			// should be enough for any version
	
	const TCHAR PART_CONNECTOR[2] = _T("_");
	const HRESULT RET_OVERFLOW = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);


	BSTR	bstrName = NULL,
			bstrProcessor = NULL,
			bstrType = NULL,
			bstrSuite = NULL;

	long	iCount = 0,
			iLength = 0;

	LOG_Block("UtilGetPlatformStr");

	USES_IU_CONVERSION;

	szPlatformStr[0] = _T('\0');

	if (NULL == pNodePlatform || NULL == pbstrPlatform)
	{
		return E_INVALIDARG;
	}

	//
	// get platform name
	//
	if (SUCCEEDED(GetAttribute(pNodePlatform, KEY_NAME, &bstrName)) &&
		NULL != bstrName && SysStringLen(bstrName) > 0)
	{
		iLength = SysStringLen(bstrName);
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrName),NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

	//
	// if there is a valid processor architecture, like x86 or alpha, append it
	//
	if (FindNodeValue(pNodePlatform, KEY_PROCESSORARCHITECTURE, &bstrProcessor) &&
		NULL != bstrProcessor && SysStringLen(bstrProcessor) > 0)
	{
		//
		// processor architector should directly append to name, without
		// the connect char "_"
		iLength += SysStringLen(bstrProcessor) ;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrProcessor),NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

	//
	// try to get version code
	//
	hr = (TRUE == FindNode(pNodePlatform, KEY_VERSION, &pNodeVersion)) ? S_OK : E_FAIL;
	
	//
	// if return code is not saying we don't have version node, 
	// then it must be an error
	//
	if (FAILED(hr) && HRESULT_FROM_WIN32(ERROR_NOT_FOUND) != hr)
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// if we have a version node, try to find the version string
	//
	if (SUCCEEDED(hr))
	{
		hr = UtilGetVersionStr(pNodeVersion, szVersion, dwFlag);
		SafeReleaseNULL(pNodeVersion);
		//
		// if we have a version node, it better be a good one
		//
		CleanUpIfFailedAndMsg(hr);
		iLength += lstrlen(szVersion) + 1 ;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),szVersion,NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

	//
	// try to get a list of suite nodes
	//
	if (0x0 == (dwFlag & SKIP_SUITES))
	{
		hr = pNodePlatform->QueryInterface(IID_IXMLDOMElement, (void**)&pElement);
		CleanUpIfFailedAndMsg(hr);
		hr = pElement->getElementsByTagName(KEY_SUITE, &pSuiteList);
		CleanUpIfFailedAndMsg(hr);

		//
		// try to get the length of the list, i.e., how many suite node(s)
		//
		hr = pSuiteList->get_length(&iCount);
		CleanUpIfFailedAndMsg(hr);

		//
		// loop through each suite, if any
		//
		pSuiteList->reset();
		for (int i = 0; i < iCount; i++)
		{
			hr = pSuiteList->get_item(i, &pNodeSuite);
			CleanUpIfFailedAndMsg(hr);
			if (pNodeSuite)
			{
				hr = pNodeSuite->get_text(&bstrSuite);
				CleanUpIfFailedAndMsg(hr);
				iLength += SysStringLen(bstrSuite) + 1;
				CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
				
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrSuite),NULL,NULL,MISTSAFE_STRING_FLAGS));

				pNodeSuite->Release();
				pNodeSuite = NULL;
				SafeSysFreeString(bstrSuite);
			}
		}
		pSuiteList->Release();
		pSuiteList = NULL;
	}

	//
	// if we find a productType node, append its text data
	//
	if (FindNodeValue(pNodePlatform, KEY_PRODUCTTYPE, &bstrType) &&
		NULL != bstrType && SysStringLen(bstrType) > 0)
	{
		iLength += SysStringLen(bstrType) + 1;
		CleanUpIfFalseAndSetHrMsg(iLength >= MAX_PLATFORM_STR_LEN, RET_OVERFLOW);
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),PART_CONNECTOR,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szPlatformStr,ARRAYSIZE(szPlatformStr),OLE2T(bstrType),NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

	*pbstrPlatform = SysAllocString(T2OLE(szPlatformStr));

	LOG_XML(_T("Got platform string %s"), szPlatformStr);

	hr = S_OK;

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrProcessor);
	SysFreeString(bstrSuite);
	SysFreeString(bstrType);
	SafeRelease(pNodeVersion);
	SafeRelease(pNodeSuite);
	SafeRelease(pSuiteList);
	SafeRelease(pElement);
	return hr;
}

    

//----------------------------------------------------------------------
//
// public function UtilGetVersionStr()
//	retrieve the data from this <version> in string format
//
//	Return:
//		HREUSLT - error code
//
//----------------------------------------------------------------------
HRESULT 
UtilGetVersionStr(
	IXMLDOMNode* pVersionNode, 
	LPTSTR pszVersion, 
	DWORD dwFlag)
{
	HRESULT hr = E_INVALIDARG;
	LONG iMajor = -1,
		iMinor = -1,
		iBuild = -1,
		iSvcPackMajor = -1,
		iSvcPackMinor = -1;

	LOG_Block("UtilGetVersionStr()");

	BSTR bstrTimestamp = NULL;
	BSTR bstrVersion = NULL;
	TCHAR szNumber[16];			// enough to store a positive integer

	BOOL fLastChunkExists = FALSE;

	USES_IU_CONVERSION;

	if (NULL == pVersionNode || NULL == pszVersion)
	{
		return hr;
	}

	*pszVersion = _T('\0');

	//
	// a version node can contain either text version data (for binaries), 
	// or attribute version data (for OS). If both exist, we prefer text data
	// 
	if (SUCCEEDED(pVersionNode->get_text(&bstrVersion)) && NULL != bstrVersion &&
		SysStringLen(bstrVersion) > 0)
	{
		lstrcpyn(pszVersion, OLE2T(bstrVersion), MAX_VERSION);
	}
	else
	{
		if (SUCCEEDED(GetAttribute(pVersionNode, KEY_MAJOR, &iMajor)) && iMajor > 0)
		{
		
			//It's an  assumption that  the pszVersion will be atleast MAX_VERSION characters wide
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(pszVersion,MAX_VERSION,NULL,NULL,MISTSAFE_STRING_FLAGS, _T("%d"),iMajor));
		
			if (SUCCEEDED(GetAttribute(pVersionNode, KEY_MINOR, &iMinor)) && iMinor >= 0)
			{
				
				CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T(".%d"),iMinor));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
				if (SUCCEEDED(GetAttribute(pVersionNode, KEY_BUILD, &iBuild)) && iBuild >= 0)
				{
					CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T(".%d"),iBuild));
					CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
				}
			}
			fLastChunkExists = TRUE;
		}

		if (0x0 == (dwFlag & SKIP_SERVICEPACK_VER) &&
			SUCCEEDED(GetAttribute(pVersionNode, KEY_SERVICEPACKMAJOR, &iSvcPackMajor)) &&
			iSvcPackMajor > 0)
		{
			if (fLastChunkExists)
			{
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(","),NULL,NULL,MISTSAFE_STRING_FLAGS));
			}
			
			
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS, _T("%d"),iSvcPackMajor));
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
			
			if (SUCCEEDED(GetAttribute(pVersionNode, KEY_SERVICEPACKMINOR, &iSvcPackMinor)) &&
				iSvcPackMinor >= 0)
			{	
				CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szNumber,ARRAYSIZE(szNumber),NULL,NULL,MISTSAFE_STRING_FLAGS,_T(".%d"),iSvcPackMinor));
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,szNumber,NULL,NULL,MISTSAFE_STRING_FLAGS));
			}
			fLastChunkExists = TRUE;
		}
		else
		{
			fLastChunkExists = FALSE;
		}

		if (SUCCEEDED(GetAttribute(pVersionNode, KEY_TIMESTAMP, &bstrTimestamp)) &&
			NULL != bstrTimestamp && SysStringLen(bstrTimestamp) > 0)
		{
			if (fLastChunkExists)
			{
				
				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(","),NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			else
			{
				//
				// if we need to append timestamp, and we didn't get service pack
				// data, we want to leave extra separator "," to tell the following
				// part is timestamp and service pack data missing.
				//
				if (*pszVersion != _T('\0'))
				{
					CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,_T(",,"),NULL,NULL,MISTSAFE_STRING_FLAGS));
					
				}
				//
				// if this is the first chunk we found, then no prefix needed
				// 
			}

			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszVersion,MAX_VERSION,OLE2T(bstrTimestamp),NULL,NULL,MISTSAFE_STRING_FLAGS));
		}
	}

	//
	// if we got something, then this is a valid version node and
	// we can pass back whatever we got. Otherwise we return E_INVALIDARG
	//
	if (*pszVersion != _T('\0'))
	{
		LOG_XML(_T("Got version str %s"), pszVersion);
		hr = S_OK;	
	}

CleanUp:
	SysFreeString(bstrTimestamp);
	SysFreeString(bstrVersion);

	return hr;
}



//-----------------------------------------------------------------------
//
// function GetFullFilePathFromFilePathNode()
//
//	retrieve the full qualified file path from a filePath node
//
// Input:
//		a filePath XMLDom node
//		a pointer to a buffer to receive path, assumes MAX_PATH long.
//
// Return:
//		HRESULT
//		Found path: S_OK
//		Not found path: S_FALSE, lpszFilePath is empty
//		otherwise, error code
//
//		
//-----------------------------------------------------------------------

HRESULT GetFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			LPTSTR lpszFilePath
)
{
	HRESULT hr = S_OK;
	LOG_Block("GetFullFilePathFromFilePathNode");

	USES_IU_CONVERSION;

	IXMLDOMNode* pRegKeyNode = NULL;
	
	TCHAR	szPath[MAX_PATH] = {_T('\0')};

	LPTSTR	lpszFileName	= NULL;
	LPTSTR	lpszKey			= NULL;
	LPTSTR	lpszValue		= NULL;
	LPTSTR	lpszPath		= NULL;

	BSTR	bstrName		= NULL;
	BSTR	bstrPath		= NULL;
	BSTR	bstrKey			= NULL;
	BSTR	bstrValue		= NULL;

	BOOL	fPathExists		= FALSE;

	UINT	nReqSize		= 0;


	if (NULL == pFilePathNode || NULL == lpszFilePath)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	//
	// init path buffer
	//
	*lpszFilePath = _T('\0');

	//
	// try to get name data, note: S_FALSE won't do, it means everything is
	// fine but this attribute does not exist.
	//
	if (S_OK == (hr = GetAttribute(pFilePathNode, KEY_NAME, &bstrName)))
	{
		//
		// found name attribute
		//
		lpszFileName = OLE2T(bstrName);		
		LOG_XML(_T(" file name=%s"), lpszFileName);
		fPathExists = TRUE;
	}


	if (FindNode(pFilePathNode, KEY_REGKEY, &pRegKeyNode) && NULL != pRegKeyNode)
	{
		//
		// found a reg key node
		//
		if (!FindNodeValue(pRegKeyNode, KEY_KEY, &bstrKey))
		{
			//
			// key node is required!
			//
			hr = E_INVALIDARG;
			LOG_ErrorMsg(hr);
			goto CleanUp;
		}

		lpszKey = OLE2T(bstrKey);
		LOG_XML(_T("Found key=%s"), lpszKey);

		//
		// get optional value name
		//
		if (FindNodeValue(pRegKeyNode, KEY_ENTRY, &bstrValue))
		{
			lpszValue = OLE2T(bstrValue);
			LOG_XML(_T("found entry=%s"), lpszValue);
		}
		else
		{
			LOG_XML(_T("found no value, use default"));
		}

		if (GetFilePathFromReg(lpszKey, lpszValue, NULL, NULL, szPath) && _T('\0') != *szPath)
		{
			//
			// various reason can me this call fail, such as
			// reg key wrong, no access to reg key, out of memory, etc
			// 
			fPathExists = TRUE;
		}

	}

	if (FindNodeValue(pFilePathNode, KEY_PATH, &bstrPath) && SysStringLen(bstrPath) > 0)
	{
		//
		// found path element
		//
		lpszPath = OLE2T(bstrPath);
		fPathExists = TRUE;
	}

	if (!fPathExists)
	{
		//
		// nothing exist
		//
		lpszFilePath[0] = _T('\0');
		LOG_XML(_T("empty node!"));
		hr = S_FALSE;
		goto CleanUp;
	}

	nReqSize = lstrlen(szPath) + SysStringLen(bstrPath) + SysStringLen(bstrName);

	if (nReqSize >= MAX_PATH ||
		NULL != lpszPath && FAILED(PathCchAppend(szPath,MAX_PATH,lpszPath)) ||			// append path to reg path
		NULL != lpszFileName && FAILED(PathCchAppend(szPath,MAX_PATH,lpszFileName)))		// append name
	{
		LOG_ErrorMsg(ERROR_BUFFER_OVERFLOW);
		hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
		goto CleanUp;
	}

	if (FAILED (hr = ExpandFilePath(szPath, lpszFilePath, MAX_PATH)))
	{
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

CleanUp:

	SysFreeString(bstrName);
	SysFreeString(bstrPath);
	SysFreeString(bstrKey);
	SysFreeString(bstrValue);
	SafeRelease(pRegKeyNode);
	return hr;

}



HRESULT GetBstrFullFilePathFromFilePathNode(
			IXMLDOMNode* pFilePathNode,
			BSTR* pbstrFilePath
)
{
	HRESULT hr = S_OK;
	
	USES_IU_CONVERSION;

	TCHAR szPath[MAX_PATH];

	QuitIfNull(pbstrFilePath);
	*pbstrFilePath = NULL;
	if (SUCCEEDED(hr = GetFullFilePathFromFilePathNode(pFilePathNode, szPath)))
	{
		*pbstrFilePath = SysAllocString(T2OLE(szPath));
	}

	return hr;
}



/////////////////////////////////////////////////////////////////////////////
//
// Helper function DoesNodeHaveName()
//
//	find out the the current node has a matching name
//
//	Input:
//			a node
//
//	Return:
//			TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////////
BOOL DoesNodeHaveName(IXMLDOMNode* pNode, BSTR bstrTagName)
{
	BSTR	bstrName;
	BOOL	fRet = FALSE;
	IXMLDOMElement* pElement = NULL;

	if (NULL == pNode)
	{
		return fRet;
	}

	if (FAILED(pNode->QueryInterface(IID_IXMLDOMElement, (void**) &pElement)) || NULL == pElement)
	{
		return FALSE;
	}

	if (SUCCEEDED(pElement->get_nodeName(&bstrName)))
	{
		fRet = CompareBSTRsEqual(bstrName, bstrTagName);
	}

	SysFreeString(bstrName);
	SafeReleaseNULL(pElement);

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\testkeys\wutestkeys.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	WUTESTKEYS.CPP
//  Module: WUTESTKEYS.LIB
//
//***********************************************************************************
#include <iucommon.h>
#include <fileutil.h>
#include <trust.h>
#include <shlobj.h>
#include <memutil.h>
#include <advpub.h>
#include <WUTestKeys.h>

#define HOUR (60 * 60)
#define DAY (24 * HOUR)
#define TWO_WEEKS (14 * DAY)

const DWORD MAX_FILE_SIZE = 200;    //Maximum expected file size in bytes
const TCHAR WU_DIR[] = _T("\\WindowsUpdate\\");
const CHAR WU_SENTINEL_STRING[] = "Windows Update Test Key Authorization File\r\n";

//function to check if the specified file is a valid WU test file
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath);

// This function returns true if the specified file is a valid WU Test Authorization file
BOOL WUAllowTestKeys(LPCTSTR lpszFileName)
{
    TCHAR szWUDirPath[MAX_PATH + 1];
    TCHAR szFilePath[MAX_PATH + 1];
    TCHAR szTxtFilePath[MAX_PATH+1];
    TCHAR szTextFile[MAX_PATH+1];          

    if (S_OK != SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szWUDirPath) ||
        FAILED(StringCchCatEx(szWUDirPath, ARRAYSIZE(szWUDirPath), WU_DIR, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {        
        return FALSE;
    } 
    if (NULL == lpszFileName || 
        FAILED(StringCchCopyEx(szFilePath, ARRAYSIZE(szFilePath), szWUDirPath, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        FAILED(StringCchCatEx(szFilePath, ARRAYSIZE(szFilePath), lpszFileName, NULL, NULL, MISTSAFE_STRING_FLAGS)) ||
        !FileExists(szFilePath))
    {
        return FALSE;
    }
    //The filename of the compressed text file should be the same as the name of the cab file
    _tsplitpath(lpszFileName, NULL, NULL, szTextFile, NULL);    
    if(FAILED(StringCchCatEx(szTextFile, ARRAYSIZE(szTextFile), _T(".txt"), NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        return FALSE;
    }
    //Verify the cab is signed with a Microsoft Cert and extract the file 
    if (FAILED(VerifyFileTrust(szFilePath, NULL, FALSE, TRUE)) ||
        !IUExtractFiles(szFilePath, szWUDirPath, szTextFile))
    {
        return FALSE;
    }
    //Generate path to the txt file. The filename should be the same as the name of the cab file
    if (!ReplaceFileExtension(szFilePath, _T(".txt"), szTxtFilePath, ARRAYSIZE(szTxtFilePath)))
    {
    	return FALSE;
    }
    //Check if it is a valid WU test file
    BOOL fRet = IsValidWUTestFile(szTxtFilePath);
    DeleteFile(szTxtFilePath);       //Delete the uncabbed file
    return fRet;
}

/*****************************************************************************************
//This function will open the specified file and parse it to make sure:
//  (1) The file has the WU Test Sentinel string at the top
//  (2) The time stamp on the file is not more than 2 weeks old and 
//      that it is not a future time stamp.
//   The format of a valid file should be as follows:
//      WINDOWSUPDATE_SENTINEL_STRING
//      YYYY.MM.DD HH:MM:SS
*****************************************************************************************/
BOOL IsValidWUTestFile(LPCTSTR lpszFilePath)
{
    USES_IU_CONVERSION;
    DWORD cbBytesRead = 0;
    const DWORD cbSentinel = ARRAYSIZE(WU_SENTINEL_STRING) - 1;     //Size of the sentinel string
    //Ansi buffer to read file data
    CHAR szFileData[MAX_FILE_SIZE+1];                        
    ZeroMemory(szFileData, ARRAYSIZE(szFileData));
    BOOL fRet = FALSE;
 
    HANDLE hFile = CreateFile(lpszFilePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        goto done;
    }
    //If the file size is greater than MAX_FILE_SIZE then bail out
    DWORD cbFile = GetFileSize(hFile, NULL);
    if(cbFile == INVALID_FILE_SIZE || cbFile > MAX_FILE_SIZE)
    {
        goto done;
    }
    if(!ReadFile(hFile, &szFileData, cbFile, &cbBytesRead, NULL) ||
        cbBytesRead != cbFile)
    {
        goto done;
    }
    //Compare with sentinel string
    if(0 != memcmp(szFileData, WU_SENTINEL_STRING, cbSentinel))
    {     
        goto done;
    }

    LPTSTR tszTime = A2T(szFileData + cbSentinel);
    if(tszTime == NULL)
    {
        goto done;
    }
    SYSTEMTIME tmCur, tmFile;
    if(FAILED(String2SystemTime(tszTime, &tmFile)))
    {
        goto done;
    }
	GetSystemTime(&tmCur);
    int iSecs = TimeDiff(tmFile, tmCur);  
    //If the time stamp is less than 2 weeks old and not newer than current time than it is valid
    fRet = iSecs > 0 && iSecs < TWO_WEEKS;
    
done:
    if(hFile != INVALID_HANDLE_VALUE)
    {
		CloseHandle(hFile);
	}
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\trust\stdafx.h ===
//
// StdAfx.h
//
//		Stand-in for precompiled header, so that trust.cpp can be properly
//		included in projects that use precompiled headers.
//
// History:
//
//		2001-11-05  KenSh     Created
//

#pragma once

#include <windows.h>
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\trust\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	trust
#
# Abstract:		trust checking for use by IU project
#
MAJORCOMP=windows.com
MINORCOMP=lib.Trust

TARGETNAME=Trust
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\Trust.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\trust\trustpriv.h ===
//
// TrustPriv.h
//
//		Some private trust settings for trust.cpp
//
// History:
//
//		2001-11-05  KenSh     Created
//

#pragma once

//
// Disable IU logging if requested
//
#ifdef DISABLE_IU_LOGGING
inline void __cdecl LOG_Block(LPCSTR, ...) { }
inline void __cdecl LOG_Error(LPCTSTR, ...) { }
inline void __cdecl LOG_Trust(LPCTSTR, ...) { }
inline void __cdecl LogError(HRESULT, LPCSTR, ...) { }
inline void LOG_ErrorMsg(HRESULT) { }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\trust\testtrust\testtrust.cpp ===
// TestTrust.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <tchar.h>
#include <logging.h>
#include <stdlib.h>
#include <stdio.h>
//#include <malloc.h>	// use _alloc

const TCHAR TestQuitEvent[] = _T("B4715050-ED35-4a7c-894A-1DF04F4F7F27");

LOG_Process;

HANDLE g_QuitEvent = NULL;
long g_Cnt = 0;

void Randomize()
{
	srand(GetTickCount());
}

int RandomNum(int _max)
{
	int n = rand();
	float f = (float)n / RAND_MAX;
	n = (int) (f * _max);
	return n;
}



inline bool ShouldQuit()
{
	return (WaitForSingleObject(g_QuitEvent, 0) == WAIT_OBJECT_0);
}


void RandomGenLogs(int _max)
{
	LOG_Block("WriteLog");
	
	Randomize();

	for (int i = 0; i < RandomNum(_max); i++)
	{
		int n = RandomNum(10);
		if (n >= 5)
		{
			if (RandomNum(2) > 1)
			{
				LOG_Error(_T("Error: %d"), RandomNum(100));
			}
			else
			{
				LOG_ErrorMsg(RandomNum(128));
			}
		}
		else
		{
			switch (n)
			{
			case 0:
				LOG_XML(_T("XML Error"));
				break;
			case 1:
				LOG_Driver(_T("Driver Log sample"));
				break;
			case 2:
				LOG_Internet(_T("Internet related log"));
				break;
			case 3:
				LOG_Software(_T("Software related log"));
				break;
			case 4:
				LOG_Trust(_T("Trust related log"));
				break;

			}
		}
	}

}


DWORD TestLog(int nDepth)
{
	int i;

	char szTitle[16];
	wsprintfA(szTitle, "TestLog(%d)", nDepth);
	LOG_Block(szTitle);
	
	Randomize();

	if (ShouldQuit())
		return 0;

	if (nDepth <= 0)
	{
		RandomGenLogs(10);
		return 0;
	}

	RandomGenLogs(4);

	for (i = 0; i < RandomNum(2); i++)
	{
		if (ShouldQuit())
		{
			LOG_Out(_T("Got quit signal!"));
			return 0;
		}


		TestLog(nDepth - 1); 
	}

	RandomGenLogs(6);

	return 0;
}


DWORD WINAPI ThreadProc(LPVOID Param)
{
	LOG_Block("ThreadProc");

	InterlockedIncrement(&g_Cnt);
	int n = (int) Param;
	printf("\t\tThread %d starts with depth %d\n", GetCurrentThreadId(), n);
	while (!ShouldQuit())
		TestLog(n);
	LOG_Out(_T("ThreadProc:::::::::Got quit signal!"));
	printf("\t\tThread %d quits\n", GetCurrentThreadId());
	InterlockedDecrement(&g_Cnt);
	return 0;
}


void StartThreadTesting(int nTotalThreads)
{
	LOG_Block("StartThreadTesting()");
	DWORD dwThreadId;
	int Num, i;

	HANDLE* pHandles = (HANDLE*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nTotalThreads * sizeof(HANDLE));

	Randomize();

	for (i = 0; i < nTotalThreads; i++)
	{
		Num = RandomNum(6);
		//LOG_Out(_T("Generate thread #%d with depth %d"), i, Num);
		printf("\tGenerate thread #%d with depth %d\n", i, Num);
		if (pHandles != NULL)
			pHandles[i] = CreateThread(NULL, 0, ThreadProc, (LPVOID) Num, CREATE_SUSPENDED, &dwThreadId); 
		else
			CreateThread(NULL, 0, ThreadProc, (LPVOID) Num, 0, &dwThreadId); 

	}

	if (pHandles != NULL)
	{
		//
		// start all threads
		//
		for (i = 0; i < nTotalThreads; i++)
		{
			ResumeThread(pHandles[i]);
		}
		HeapFree(GetProcessHeap(), 0, (LPVOID)pHandles);
	}

}


int main(int argc, char* argv[])
{
	LOG_Block("main");
	int nWaitSeconds = 5 * 1000;;
	int nThreads= 20;
	if (argc > 1)
	{
		nWaitSeconds = abs(atoi(argv[1])) * 1000;
	}
	LOG_Out(_T("Found timing %d seconds"), nWaitSeconds/1000);
	if (argc > 2)
	{
		nThreads = abs(atoi(argv[2]));
	}
	LOG_Out(_T("Found number of threads: %d"), nThreads);

		
	g_QuitEvent = CreateEvent(NULL, TRUE, FALSE, TestQuitEvent);

	printf("Start threading ....\n");

	StartThreadTesting(nThreads);

	printf("Finished threading\n");

	int iStart = (int)GetTickCount();
	int nNow = (int)GetTickCount();
	while (nNow <  iStart + nWaitSeconds)
	{
		printf("Wait for %d more seconds...\n", (nWaitSeconds - (nNow - iStart))/1000);
		Sleep(2000);
		nNow = (int)GetTickCount();
	}

	//
	// tell that we need to quit
	//
	SetEvent(g_QuitEvent);

	//
	// wait for threads to quit
	//
	int nCnt = g_Cnt;
	iStart = (int)GetTickCount();

	while (nCnt > 0)
	{
		Sleep(1000);
		printf("Seconds: %d, Threads: %d\n", ((int)GetTickCount() - iStart)/1000, nCnt);
		nCnt = g_Cnt;
	}



	//
	// quit
	//
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\trust\trust.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
//
//  SYSTEM:     Industry Update
//
//  CLASS:      N/A
//  MODULE:     TRUST.LIB
//  FILE:       Trust.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this file implements the functions used to make cabs 
//			signed by certain providers trusted.
//          
//
//  AUTHOR: Charles Ma, converted from WU CDMLIB
//  DATE:   10/4/2000
//
/////////////////////////////////////////////////////////////////////
//
//  Revision History:
//
//  Date    Author          Description
//  ~~~~    ~~~~~~          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//  
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <wintrust.h>
#include <softpub.h>
#include "trust.h"
#include "TrustPriv.h"
#include "wusafefn.h"

#if !defined(DISABLE_IU_LOGGING)
#include <MemUtil.h>
#include <logging.h>
#endif

#if defined(DEBUG) || defined(DBG)
	#ifdef DISABLE_IU_POLICY		// in debug mode, we enable pop up check
		#undef DISABLE_IU_POLICY
	#endif
#else
	#define DISABLE_IU_POLICY		// in release mode, we never allow cert pop up!
#endif

#if defined(__WUIUTEST) || !defined(DISABLE_IU_POLICY)
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
#endif

/////////////////////////////////////////////////////////////////////////////
// 
// typedefs for APIs used in the CheckTrust() function
//
//      Since some of these APIs are new and only available on IE5 we have to
//      try to dynamicaly use them when available and do without the extra checks
//      when we are on an OS that has not been upgraded to the new crypto code.
//
/////////////////////////////////////////////////////////////////////////////


#define WINTRUST _T("wintrust.dll")
#define CRYPT32  _T("crypt32.dll")

#if !defined(USES_IU_CONVERSION) && defined(USES_CONVERSION)
#define USES_IU_CONVERSION USES_CONVERSION
#endif

//
// declare a global crypt32.dll library handler, so we don't
// need to load the library every time these functions are called.
// NOTE: we do not release the library though. When the process of
// calling this feature exits, the library is released.
// same as wintrust.dll
//
static HINSTANCE shWinTrustDllInst = NULL;
static HINSTANCE shCrypt32DllInst = NULL;


//
// define prototype for function WinVerifyTrust()
// and declare a global variable to point to this function
//
typedef HRESULT 
(WINAPI * PFNWinVerifyTrust)(
                        HWND hwnd, GUID *ActionID, LPVOID ActionData);
PFNWinVerifyTrust pfnWinVerifyTrust = NULL; 


//
// define prototype for function WTHelperProvDataFromStateData()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_DATA * 
(WINAPI * PFNWTHelperProvDataFromStateData)(
						HANDLE hStateData);
PFNWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData = NULL;


//
// define prototype for function WTHelperGetProvSignerFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_SGNR * 
(WINAPI * PFNWTHelperGetProvSignerFromChain)(
						CRYPT_PROVIDER_DATA *pProvData,
						DWORD idxSigner,
						BOOL fCounterSigner,
						DWORD idxCounterSigner);
PFNWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = NULL;


//
// define prototype for function PFNWTHelperGetProvCertFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_CERT * 
(WINAPI * PFNWTHelperGetProvCertFromChain)(
						CRYPT_PROVIDER_SGNR *pSgnr,
						DWORD idxCert);
PFNWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = NULL;


//
// define prototype for function CryptHashPublicKeyInfo()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCryptHashPublicKeyInfo)(
						HCRYPTPROV hCryptProv,
						ALG_ID Algid,
						DWORD dwFlags,
						DWORD dwCertEncodingType,
						PCERT_PUBLIC_KEY_INFO pInfo,
						BYTE *pbComputedHash,
						DWORD *pcbComputedHash);
PFNCryptHashPublicKeyInfo pfnCryptHashPublicKeyInfo = NULL;


//
// define prototype for function CertGetCertificateContextProperty()
// and declare a global variable to point to this function
//
typedef BOOL 
(WINAPI * PFNCertGetCertificateContextProperty)(
						PCCERT_CONTEXT pCertContext,          
						DWORD dwPropId,                       
						void *pvData,                         
						DWORD *pcbData);
PFNCertGetCertificateContextProperty pfnCertGetCertificateContextProperty = NULL;



/////////////////////////////////////////////////////////////////////////////
// 
// pre-defined cert data to check against
//
/////////////////////////////////////////////////////////////////////////////

//
// The following is the sha1 key identifier for the Microsoft root
//
static const BYTE rgbSignerRootKeyIds[40] = {
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,		// the original MS root
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D,

	0x0E, 0xAC, 0x82, 0x60, 0x40, 0x56, 0x27, 0x97, 0xE5, 0x25,		// the new "son of MS root"
    0x13, 0xFC, 0x2A, 0xE1, 0x0A, 0x53, 0x95, 0x59, 0xE4, 0xA4

};


//
// define the size of each hash values in the known id buffer
// for special certs.
//
const size_t ExpectedKnownCertHashSize = 20;

//
// this is the size of buffer to receive the cert hash value
// it must be not less than the largest number in the
// above-defined array
//
const size_t ShaBufSize = 20;

//
// id buffer to store SH1 hashing values of known Microsoft
// certs (signature) that we should recognize.
// Warning: the size of this buffer should match the sum 
// of size_t values defined above.
//
static const BYTE rgbSpecialCertId[200] = {
	0xB1,0x59,0xA5,0x2E,0x3D,0xD8,0xCE,0xCD,0x3A,0x9A,0x4A,0x7A,0x73,0x92,0xAA,0x8D,0xA7,0xE7,0xD6,0x7F,	// MS cert
	0xB1,0xC7,0x75,0xE0,0x4A,0x9D,0xFD,0x23,0xB6,0x18,0x97,0x11,0x5E,0xF6,0xEA,0x6B,0x99,0xEC,0x76,0x1D,	// MSN cert
	0x11,0xC7,0x10,0xF3,0xCB,0x6C,0x43,0xE1,0x66,0xEC,0x64,0x1C,0x7C,0x01,0x17,0xC4,0xB4,0x10,0x35,0x30,	// MSNBC cert
	0x95,0x25,0x58,0xD4,0x07,0xDE,0x4A,0xFD,0xAE,0xBA,0x13,0x72,0x83,0xC2,0xB3,0x37,0x04,0x90,0xC9,0x8A,	// MSN Europe
	0x72,0x54,0x14,0x91,0x1D,0x6E,0x10,0x84,0x8E,0x0F,0xFA,0xA0,0xB0,0xA1,0x65,0xBF,0x44,0x8F,0x9F,0x6D,	// MS Europe
	0x20,0x5E,0x48,0x43,0xAB,0xAD,0x54,0x77,0x71,0xBD,0x8D,0x1A,0x3C,0xE0,0xE5,0x9D,0xF5,0xBD,0x25,0xF9,	// Old MS cert: 97~98
	0xD6,0xCD,0x01,0x90,0xB3,0x1B,0x31,0x85,0x81,0x12,0x23,0x14,0xB5,0x17,0xA0,0xAA,0xCE,0xF2,0x7B,0xD5,	// Old MS cert: 98~99
	0x8A,0xA1,0x37,0xF5,0x03,0x9F,0xE0,0x28,0xC9,0x26,0xAA,0x55,0x90,0x14,0x19,0x68,0xFA,0xFF,0xE8,0x1A,	// Old MS cert: 99~00
	0xF3,0x25,0xF8,0x67,0x07,0x29,0xE5,0x27,0xF3,0x77,0x52,0x34,0xE0,0x51,0x57,0x69,0x0F,0x40,0xC6,0x1C,	// Old MS Europe cert: 99~00
	0x6A,0x71,0xFE,0x54,0x8A,0x51,0x08,0x70,0xF9,0x8A,0x56,0xCA,0x11,0x55,0xF6,0x76,0x45,0x92,0x02,0x5A     // Old MS Europe cert: 98~99

};




/////////////////////////////////////////////////////////////////////////////
// 
// Private Function ULONG CompareMem(PVOID pBlock1, PVOID pBlock2, ULONG Length)
//
//      This function acts in the same way as RtlCompareMemory() 
//
//
// Input:   two pointers to two memory blocks, and a byte size to compare
// Return:  the number of bytes that compared as equal. 
//			If all bytes compare as equal, the input Length is returned.
//			If any pointer is NULL, 0 is returned.
//
/////////////////////////////////////////////////////////////////////////////
ULONG CompareMem(const BYTE* pBlock1, const BYTE* pBlock2, ULONG Length)
{
	ULONG uLen = 0L;
	if (pBlock1 != NULL && pBlock2 != NULL)
	{
		for (; uLen < Length; uLen++, pBlock1++, pBlock2++)
		{
			if (*pBlock1 != *pBlock2) return uLen;
		}
	}
	return uLen;
}






/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifyMSRoot()
//
//      This function takes the passed-in certificate as a root cert,
//		and verifies its public key hash value is the same as 
//		known "Microsoft Root Authority" cert value.
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			the result code, in case of error, are code retuned by
//			crypt32.dll, with these the exception of E_INVALIDARG if
//			the passed-in parameters are NULL.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyMSRoot(
					 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
					 PCCERT_CONTEXT pRootCert
					 )
{
	HRESULT hr = S_OK;
	BYTE	rgbKeyId[ExpectedKnownCertHashSize];
    DWORD	cbKeyId = sizeof(rgbKeyId);

	LOG_Block("VerifyMSRoot()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pRootCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCryptHashPublicKeyInfo = (PFNCryptHashPublicKeyInfo)
		GetProcAddress(hCrypt32DllInst, "CryptHashPublicKeyInfo")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}

	//
	// get the public key hash value of this cert
	//
	ZeroMemory(rgbKeyId, sizeof(rgbKeyId));
    if (!pfnCryptHashPublicKeyInfo(
							0,						// use default crypto svc provider
							CALG_SHA1,				// use SHA algorithm
							0,						// dwFlags
							X509_ASN_ENCODING,
							&pRootCert->pCertInfo->SubjectPublicKeyInfo,
							rgbKeyId,
							&cbKeyId
							))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrHandler;
	}

	//
	// compare the hash value of public key of this root cert with the known MS root cert value
	//
	if (ExpectedKnownCertHashSize != cbKeyId || 
		(cbKeyId != CompareMem(rgbSignerRootKeyIds, rgbKeyId, cbKeyId) &&
		 cbKeyId != CompareMem(rgbSignerRootKeyIds + ExpectedKnownCertHashSize, rgbKeyId, cbKeyId)
		)
	   )
	{
		hr = S_FALSE;
	}


ErrHandler:

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		LOG_Trust(_T("Exit VerifyMSRoot() with %s"), (S_OK == hr) ? _T("S_OK") : _T("S_FALSE"));
	}

	return hr;
}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function VerifySpecialMSCerts()
//
//      This function takes the passed-in certificate as a leaf cert,
//		and verifies its hash value matches the hash value of one of
//		known Microsoft special certs that does not have MS root.
//
//		The known certs are, in comparing order:
//			Microsoft Corporation
//			Microsoft Corporation MSN
//			MSNBC Interactive News LLC
//			Microsoft Corporation MSN (Europe)
//			Microsoft Corporation (Europe)
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//			pRootCert - the certificate context of the root cert
//			pbSha1HashVal - if not NULL, compare to this one, instead of
//							hard-coded hash values. this is the case
//							of working on 3rd party package
//
// Return:  HRESULT - result of execution, S_OK if matched.
//			if not matched, CERT_E_UNTRUSTEDROOT, or
//			E_INVALIDARG if arguments not right, or
//			crypt32.dll error returned by API calls
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyKnownCerts(					 
							 HINSTANCE hCrypt32DllInst,			// handle point to loaded crypt32.dll librar
							 PCCERT_CONTEXT pLeafCert,
							 pCERT_HASH_ARRAY pKnownCertsData
							 )
{
	HRESULT hr = S_FALSE;
	BYTE	btShaBuffer[ShaBufSize];
	DWORD	dwSize = sizeof(btShaBuffer);
	BYTE const * pId;

	LOG_Block("VerifyKnownCerts()");

	//
	// valid parameter values
	//
	if (NULL == hCrypt32DllInst || NULL == pLeafCert)
	{
		hr = E_INVALIDARG;
		goto ErrHandler;
	}

	//
	// get the function we need from the passed in library handle
	// If not available, return error
	//
	if (NULL == (pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)
		GetProcAddress(hCrypt32DllInst, "CertGetCertificateContextProperty")))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto ErrHandler;
	}
	
	//
	// find out the id hash of leaf cert
	//
	ZeroMemory(btShaBuffer, dwSize);
	if (!pfnCertGetCertificateContextProperty(
						pLeafCert,					// pCertContext
						CERT_SHA1_HASH_PROP_ID,	// dwPropId
						btShaBuffer,
						&dwSize
						))
	{
		hr = GetLastError();
		goto ErrHandler;
	}


	if (NULL == pKnownCertsData)
	{
		int		i;
		//
		// iterrate through all known id hash values to see if this file is signed
		// with any of these special certs.
		//
		hr = S_FALSE;
		for (i = 0,pId = rgbSpecialCertId; 
			 i < sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize; 
			 i++, pId += ExpectedKnownCertHashSize)
		{
			if (ExpectedKnownCertHashSize == dwSize &&
				dwSize == CompareMem(btShaBuffer, pId, dwSize))
			{
				//
				// found a matching known cert!
				//
				hr = S_OK;
				LOG_Trust(_T("Found hash matching on #%d of %d MS certs!"), i, sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize);
				break;
			}
		}
	}
	else
	{
		//
		// check if the retrieved hashing value matches the one passed in.
		//
		UINT i;
		LOG_Trust(_T("Comparing retrieved hash value with passed-in key"));
		hr = S_FALSE;
		for (i = 0, pId = pKnownCertsData->pCerts; i < pKnownCertsData->uiCount;
			i++, pId += HASH_VAL_SIZE)
		{
			if (dwSize == HASH_VAL_SIZE &&
				HASH_VAL_SIZE == CompareMem(btShaBuffer, pId, HASH_VAL_SIZE))
			{
				hr = S_OK;
				LOG_Trust(_T("Found hash matching #%d of %d passed-in certs!"),
							i, pKnownCertsData->uiCount);
				break;
			}
		}
	}

ErrHandler:

	if (FAILED(hr))
	{
		LOG_ErrorMsg(hr);
	}
	else
	{
		LOG_Trust(_T("Exit VerifyKnownCerts() with %s"), (S_OK == hr) ? _T("S_OK") : _T("S_FALSE"));
	}

	return hr;


}





/////////////////////////////////////////////////////////////////////////////
// 
// Private Function CheckWinTrust()
//
//      This function will return the HRESULT for the trust state on the
//      specified file. The file can be pointing to any URL or local file.
//      The verification will be done by the wintrust.dll. 
//
//      dwUIChoice is WTD_UI_NONE, WTD_UI_ALL, etc. (defined in wintrust.h).
//		dwCheckRevocation is WTD_REVOKE_NONE (default) or WTD_REVOKE_WHOLE_CHAIN.
//
// Input:   Fully qualified filename, UIChoice, dwCheckRevocation
// Return:  HRESULT - result of execution
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CheckWinTrust(LPCTSTR pszFileName, pCERT_HASH_ARRAY pCertsData, DWORD dwUIChoice, DWORD dwCheckRevocation)
{

	LOG_Block("CheckWinTrust()");

#if !defined(UNICODE) && !defined(_UNICODE)
	USES_IU_CONVERSION;
#endif

    // Now verify the file
    WINTRUST_DATA               winData;
    WINTRUST_FILE_INFO          winFile;
    GUID                        gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2; 
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    CRYPT_PROVIDER_SGNR         *pProvSigner = NULL;
    CRYPT_PROVIDER_CERT	        *pProvCert = NULL;
    HRESULT                     hr = S_OK;


#ifdef __WUIUTEST
	{
		LOG_Trust(_T("CheckWinTrust _IUTEST Handling Begins"));
		//
		// handling test case:
		// if a reg key value is set to 1, then we will see if we need to pop up ALL certs
		//
		// NOTE:
		//
		// for the certs that user has checked "Always trust this provider..." previously, 
		// WinCheckTrust() API will still NOT show any UI even if we signal Show-ALL flag
		//
		HKEY	hkey;
		DWORD	dwWinTrustUI = 0;
		DWORD	dwSize = sizeof(dwWinTrustUI);

		if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hkey)) 
		{
			RegQueryValueEx(hkey, _T("WinTrustUI"), 0, 0, (LPBYTE)&dwWinTrustUI, &dwSize);
			RegCloseKey(hkey);
			LOG_Trust(_T("Found regval %s\\WinTrustUI=%x"), REGKEY_IUCTL, dwWinTrustUI);
		}
		if (0x1 == dwWinTrustUI && WTD_UI_NONE != dwUIChoice)
		{
			//
			// if there is a WinTrustUI reg key exist, and value is 1
			// and caller does not request silence, then we
			// pop up all certs
			//
			LOG_Trust(_T("Change UI choice to WTD_UI_ALL"));
			dwUIChoice = WTD_UI_ALL;
		}

		if (0x2 == dwWinTrustUI)
		{
			//
			// if reg vlaue is 2, we pop up any cert no matter caller 
			// says showing UI or not
			//
			LOG_Trust(_T("Changed UI choice from %d to WTD_UI_NOGOOD"));
			dwUIChoice = WTD_UI_ALL;
		}

		if (0x3 == dwWinTrustUI)
		{
			//
			// if reg value is 3, we pop up bad (include test) cert no matter
			// caller allow showing UI or not
			// 
			LOG_Trust(_T("Changed UI choice from %d to WTD_UI_NOGOOD"));
			dwUIChoice = WTD_UI_NOGOOD;
		}

	}
#endif


	//
	// dynamically load the wintrust.dll
	//
	if (NULL == shWinTrustDllInst)
	{
		if (NULL == (shWinTrustDllInst = LoadLibraryFromSystemDir(WINTRUST)))
		{
			LOG_Error(_T("Failed to load libary %s, exit function."), WINTRUST);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}

	//
	// dynamically load the crypt32.dll, which will be used by the two
	// helper functions to verify the cert is MS cert
	//
	if (NULL == shCrypt32DllInst)
	{
		if (NULL == (shCrypt32DllInst = LoadLibraryFromSystemDir(CRYPT32)))
		{
			LOG_Error(_T("Failed to load libary %s, exit function."), CRYPT32);
            hr = HRESULT_FROM_WIN32(GetLastError());
		    goto Done;
		}
	}
	//
	// find the functions we need
	//
	if (NULL == (pfnWinVerifyTrust = (PFNWinVerifyTrust)
				GetProcAddress(shWinTrustDllInst, "WinVerifyTrust")) ||
		NULL == (pfnWTHelperProvDataFromStateData = (PFNWTHelperProvDataFromStateData)
				GetProcAddress(shWinTrustDllInst, "WTHelperProvDataFromStateData")) ||
		NULL == (pfnWTHelperGetProvSignerFromChain = (PFNWTHelperGetProvSignerFromChain) 
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvSignerFromChain")) ||
		NULL == (pfnWTHelperGetProvCertFromChain = (PFNWTHelperGetProvCertFromChain)
				GetProcAddress(shWinTrustDllInst, "WTHelperGetProvCertFromChain")))
	{
		//
		// at least one function was not found in the loaded cryp32.dll libary.
		// we can not continue, jsut quit. 
		// NOTE: this shouldn't happen since we have tried to get 
		// the least common denomination of different version of this dll
		// on both IE4 and IE5
		//
		LOG_Error(_T("CheckWinTrust() did not find functions needed from %s"), CRYPT32);
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto Done;
	}


	//
	// initialize the data structure used to verify trust
	//
    winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
    winFile.hFile          = INVALID_HANDLE_VALUE;
    winFile.pcwszFilePath  = T2COLE(pszFileName);
    winFile.pgKnownSubject = NULL;

    winData.cbStruct            = sizeof(WINTRUST_DATA);
    winData.pPolicyCallbackData = NULL;
    winData.pSIPClientData      = NULL;
    winData.dwUIChoice          = (WTD_UI_ALL == dwUIChoice) ? dwUIChoice : WTD_UI_NONE;
    winData.fdwRevocationChecks = WTD_REVOKE_NONE;
    winData.dwUnionChoice       = WTD_CHOICE_FILE;
    winData.dwStateAction       = WTD_STATEACTION_VERIFY;
    winData.hWVTStateData       = 0;
    winData.dwProvFlags         = WTD_REVOCATION_CHECK_NONE;
    winData.pFile               = &winFile;

	if (dwCheckRevocation == WTD_REVOKE_WHOLECHAIN)
	{
		winData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
		winData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
	}

	//
	// verify the signature
	//
    hr = pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

	//
	// Ignore errors when retrieving Cert Revocation List (CRL). This
	// just means the list itself couldn't be retrieved, not that the
	// current cert was invalid or revoked. (KenSh, 2002/01/17)
	//
	if (hr == CERT_E_REVOCATION_FAILURE)
	{
		hr = S_OK;
	}

    if (FAILED(hr))
    {
        //
        // The object isn't even trusted so just get out here
        //
		LOG_Error(_T("When processing %s found error 0x%0x."), pszFileName, hr);
        goto Return;
    }


	//
	// the real usage should never pass in WTD_UI_ALL. If this is the case, 
	// then we are calling this recursively in order to force the show
	// a good but non-MS cert only, so no need to check MS cert again.
	//
	// or, in test mode, we always do this part
	//
	if (WTD_UI_ALL != dwUIChoice)
	{
		//
		// if come to here, it means all above verified okay.
		//
		// the rset of code is used to verify the signed cert is
		// a known cert.
		//
		
		hr = S_FALSE;

		pProvData = pfnWTHelperProvDataFromStateData(winData.hWVTStateData);
    
		pProvSigner = pfnWTHelperGetProvSignerFromChain(
										(PCRYPT_PROVIDER_DATA) pProvData, 
										0,      // first signer
										FALSE,  // not a counter signer
										0);

		//
		// check root cert then check leaf (signing) cert if that fails
		//
		// 0 is signing cert, csCertChain-1 is root cert
		//


		if (NULL == pCertsData)
		{
			//
			// if caller does not specify a hash value, then it means we want
			// to verify if this cert is known MS cert. We will first
			// try to find out if it is signed with a cert that has MS as root.
			//
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, pProvSigner->csCertChain - 1);
			hr = VerifyMSRoot(shCrypt32DllInst, pProvCert->pCert);	
		}

		if (S_OK != hr)
		{
			pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, 0);

			hr = VerifyKnownCerts(shCrypt32DllInst, pProvCert->pCert, pCertsData);
		}


	}

Return:

    //
    // free the wintrust state that was used to get the cert in the chain
    //
    winData.dwStateAction = WTD_STATEACTION_CLOSE;
    pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

	//
	// recursively call this function if not in test mode so we can show
	// UI for this non-MS but good cert.
	// Only the two functions checking MS cert will return S_FALSE
	//
	if (S_OK != hr)
	{
		if (WTD_UI_NOGOOD == dwUIChoice)
		{
			//
			// we need to show UI, so we will have to call this thing again
			// in case this is not a MS cert. From UI, if user clicks YES
			// then the return value will be S_OK;
			//
			hr = CheckWinTrust(pszFileName, NULL, WTD_UI_ALL, dwCheckRevocation);
			LOG_Error(_T("CheckWinTrust() found file not signed by a known MS cert. If user has not checked \"Always trust this\", UI should be shown, and user selected %s"), 
				SUCCEEDED(hr) ? _T("YES") : _T("NO"));
		}
		else
		{
			LOG_Error(_T("CheckWinTrust() found file not signed by a known cert!"));
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Digital Signatures on file %ls are not trusted",  pszFileName);
#else
			LogError(hr, "Digital Signatures on file %s are not trusted",  pszFileName);
#endif
			hr = TRUST_E_SUBJECT_NOT_TRUSTED;
		}
	}

	if (WTD_UI_ALL != dwUIChoice)
	{
		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Digital Signatures on file %ls are not trusted",  pszFileName);
#else
			LogError(hr, "Digital Signatures on file %s are not trusted",  pszFileName);
#endif
		}
		else
		{
			LOG_Trust(_T("CheckWinTrust(%s) returns S_OK"), pszFileName);
		}
	}

Done:
    if (NULL != shWinTrustDllInst)
    {
        FreeLibrary(shWinTrustDllInst);
        shWinTrustDllInst = NULL;
    }
    if (NULL != shCrypt32DllInst)
    {
        FreeLibrary(shCrypt32DllInst);
        shCrypt32DllInst = NULL;
    }

    return (hr); 
}    



/////////////////////////////////////////////////////////////////////////////
// 
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler 
// and WU classic code should use.
//
// Input:	szFileName - the file with complete path
//			pbSha1HashVal - hash value of a known good cert
//			fShowBadUI - whether pop up UI in cases 
//						 (1) inproperly signed signature, 
//						 (2) properly signed but not signed by a known cert
//
// Return:	HRESULT - S_OK the file is signed with a valid known cert
//					  or error code.
//
// Note:	If _WUV3TEST flag is set (for test build), then fShowBadUI is
//			ignored:
//				if reg key SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\wuv3test\WinTrustUI
//				is set to 1, then no UI is shown, and this function always return S_OK;
//				otherwise, UI always show no matter what cert, and return value is same
//				as the live build.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
						IN LPCTSTR szFileName,
						IN pCERT_HASH_ARRAY pCertsData,
						BOOL fShowBadUI,
						BOOL fCheckRevocation /*=FALSE*/
						)
{
	DWORD dwUIChoice = fShowBadUI ? WTD_UI_NOGOOD : WTD_UI_NONE;
	DWORD dwCheckRevocation = fCheckRevocation ? WTD_REVOKE_WHOLECHAIN : WTD_REVOKE_NONE;

	return CheckWinTrust(szFileName, pCertsData, dwUIChoice, dwCheckRevocation);
}


/////////////////////////////////////////////////////////////////////////////
// 
// Public Function ReadWUPolicyShowTrustUI()
//
// Input:   void
//
// Return:  BOOL - FALSE means ShowTrustUI regkey is not present, or is set to 0
//                 TRUE means ShowTrustUI regkey is present and is set to 1
//
//
/////////////////////////////////////////////////////////////////////////////
BOOL ReadWUPolicyShowTrustUI()
{
#if !defined(DISABLE_IU_POLICY)
    LOG_Block("ReadWUPolicyShowTrustUI()");
    HKEY hkey;
    DWORD dwShowTrustUI = 0; // if the key is not present, default to not showing any UI
    DWORD dwSize = sizeof(dwShowTrustUI);

    if (NO_ERROR == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hkey)) 
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, _T("WUPolicyShowTrustUI"), 0, 0, (LPBYTE)&dwShowTrustUI, &dwSize))
        {
            LOG_Trust(_T("Found regval %s\\WUPolicyShowTrustUI=%x"), REGKEY_IUCTL, dwShowTrustUI);
        }
        RegCloseKey(hkey);
    }

    return (1 == dwShowTrustUI);    
#else
	//
	// for released build, we never show up UI
	//
	return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urlagent\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.UrlAgent

TARGETNAME=UrlAgent
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\UrlAgent.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urllogging\sources.inc ===
#
# Copyright (c) 2001	Microsoft Corporation
#
# Module Name:	URLLogging
#
# Abstract:		A class performs URL logging
#
MAJORCOMP=windows.com
MINORCOMP=lib.URLLogging

TARGETNAME=URLLogging
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\URLLogging.cpp \
	..\internet.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urllogging\urllogging.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	URLLogging.cpp
//
//  Description:
//
//		URL logging utility class
//		This class helps you construct the server ping URL and
//		then send the ping to the designed server.
//
//		The default base URL is defined in IUIdent, under section [IUPingServer]
//		and entry is "ServerUrl".
//
//		This class implements single-thread version only. So it is suitable
//		to call it at operation level, i.e., create a separate object
//		for each operation in a single thread.
//
//		The ping string send to the ping server has the following format:
//			/wutrack.bin
//			?V=<version>
//			&U=<user>
//			&C=<client>
//			&A=<activity>
//			&I=<item>
//			&D=<device>
//			&P=<platform>
//			&L=<language>
//			&S=<status>
//			&E=<error>
//			&M=<message>
//			&X=<proxy>
//		where
//			<version>	a decimal number versioning the ping-back format in use
//			<user>		a static 128-bit value that unique-ifies each copy
//						of Windows installed.  The class will automatically
//						reuse one previously assigned to the running OS; or
//						will generate one if it does not exist.
//			<client>	a string that identifies the entity that performed
//						activity <activity>.  Here are the possible values
//						and their meanings:
//							"iu"			IU control
//							"au"			Automatic Updates
//							"du"			Dynamic Update
//							"CDM"			Code Download Manager
//							"IU_SITE"		IU Consumer site
//							"IU_Corp"		IU Catalog site
//			<activity>	a letter that identifies the activity performed.
//						Here are the possible values and their meanings:
//							"n"				IU control initization
//							"d"				detection
//							"s"				self-update
//							"w"				download
//							"i"				installation
//			<item>		a string that identifies an update item.
//			<device>	a string that identifies either a device's PNPID when
//						device driver not found during detection; or a
//						PNPID/CompatID used by item <item> for activity
//						<activity> if the item is a device driver.
//			<platform>	a string that identifies the platform of the running
//						OS and processor architecture.  The class will
//						compute this value for the pingback.
//			<language>	a string that identifies the language of the OS
//						binaries.  The class will compute this value for the
//						pingback.
//			<status>	a letter that specifies the status that activity
//						<activity> reached.  Here are the possible values and
//						 their meanings:
//							"s"				succeeded
//							"r"				succeeded (reboot required)
//							"f"				failed
//							"c"				cancelled by user
//							"d"				declined by user
//							"n"				no items
//							"p"				pending
//			<error>		a 32-bit error code in hex (w/o "0x" as prefix).
//			<message>	a string that provides additional information for the
//						status <status>.
//			<proxy>		a 32-bit random value in hex for overriding proxy
//						caching.  This class will compute this value for
//						each pingback.
//
//=======================================================================

#include <tchar.h>
#include <windows.h>		// ZeroMemory()
#include <shlwapi.h>		// PathAppend()
#include <stdlib.h>			// srand(), rand(), malloc() and free()
#include <sys/timeb.h>		// _ftime() and _timeb
#include <malloc.h>			// malloc() and free()
#include <ntsecapi.h>		// LsaXXX
#include <subauth.h>		// STATUS_SUCCESS

#include <fileutil.h>		// GetIndustryUpdateDirectory()
#include <logging.h>		// LOG_Block, LOG_ErrorMsg, LOG_Error and LOG_Internet
#include <MemUtil.h>		// USES_IU_CONVERSION, W2T() and T2W()
#include <osdet.h>			// LookupLocaleString()
#include <download.h>		// DownloadFile()
#include <wusafefn.h>		// PathCchAppend()
#include <safefunc.h>		// SafeFreeNULL()
#include <MISTSafe.h>

#include <URLLogging.h>

// Header of the log file
typedef struct tagULHEADER
{
	WORD wVersion;		// file version
} ULHEADER, PULHEADER;

#define ARRAYSIZE(x)	(sizeof(x)/sizeof(x[0]))

#define CACHE_FILE_VERSION	((WORD) 10004)	// must be bigger what we had in V3 (10001)
const DWORD c_dwPingbackVersion = 1;		// must be changed for each release that we've changed the ping back format

// bug 600602: must end all server URL with '/'
const TCHAR c_tszLiveServerUrl[] = _T("http://wustat.windows.com/");


HRESULT ValidateFileHeader(HANDLE hFile, BOOL fCheckHeader, BOOL fFixHeader);

#ifdef DBG
BOOL MustPingOffline(void)
{
	BOOL fRet = FALSE;
	HKEY hkey;

	if (NO_ERROR == RegOpenKeyEx(
						HKEY_LOCAL_MACHINE,
						_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate"),
						0,
						KEY_QUERY_VALUE | KEY_SET_VALUE,
						&hkey))
	{
		DWORD	dwForceOfflinePing;
		DWORD	dwSize = sizeof(dwForceOfflinePing);
		DWORD	dwType;

		if (NO_ERROR == RegQueryValueEx(
							hkey,
							_T("ForceOfflinePing"),
							0,
							&dwType,
							(LPBYTE) &dwForceOfflinePing,
							&dwSize))
		{
			if (REG_DWORD == dwType &&
				sizeof(dwForceOfflinePing) == dwSize &&
				1 == dwForceOfflinePing)
			{
				fRet = TRUE;
			}
		}
		RegCloseKey(hkey);
	}
	return fRet;
}
#endif

// ----------------------------------------------------------------------------------
//
// PUBLIC MEMBER FUNCTIONS
//
// ----------------------------------------------------------------------------------

CUrlLog::CUrlLog(void)
: m_ptszLiveServerUrl(NULL), m_ptszCorpServerUrl(NULL), m_fPingIdInit(FALSE)
{
	Init();
	m_tszDefaultClientName[0] = _T('\0');
}


CUrlLog::CUrlLog(LPCTSTR ptszClientName, LPCTSTR ptszLiveServerUrl, LPCTSTR ptszCorpServerUrl)
: m_ptszLiveServerUrl(NULL), m_ptszCorpServerUrl(NULL), m_fPingIdInit(FALSE)
{
	Init();
	(void) SetDefaultClientName(ptszClientName);
	(void) SetLiveServerUrl(ptszLiveServerUrl);
	(void) SetCorpServerUrl(ptszCorpServerUrl);
}


CUrlLog::~CUrlLog(void)
{
	if (NULL != m_ptszLiveServerUrl)
	{
		free(m_ptszLiveServerUrl);
	}
	if (NULL != m_ptszCorpServerUrl)
	{
		free(m_ptszCorpServerUrl);
	}
}

// Assume ptszServerUrl, if non-NULL, is of size INTERNET_MAX_URL_LENGTH in TCHARs
BOOL CUrlLog::SetServerUrl(LPCTSTR ptszUrl, LPTSTR & ptszServerUrl)
{
	LPTSTR ptszEnd = NULL;
	size_t cchRemaining = 0;

	if (NULL == ptszUrl ||
		_T('\0') == *ptszUrl)
	{
		SafeFreeNULL(ptszServerUrl);
	}
	else if (
		// Ensure ptszServerUrl is malloc'ed
		(NULL == ptszServerUrl &&
		 NULL == (ptszServerUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH))) ||
		// Copy URL
		FAILED(StringCchCopyEx(ptszServerUrl, INTERNET_MAX_URL_LENGTH, ptszUrl, &ptszEnd, &cchRemaining, MISTSAFE_STRING_FLAGS)) ||
		// Ensure URL ending with '/'
		(_T('/') != ptszEnd[-1] &&
		 FAILED(StringCchCopyEx(ptszEnd, cchRemaining, _T("/"), NULL, NULL, MISTSAFE_STRING_FLAGS))))
	{
		SafeFreeNULL(ptszServerUrl);
		return FALSE;
	}
	return TRUE;
}


// Watch out for the size of m_tszDefaultClientName.
BOOL CUrlLog::SetDefaultClientName(LPCTSTR ptszClientName)
{
	if (NULL == ptszClientName)
	{
		// E_INVALIDARG
		m_tszDefaultClientName[0] = _T('\0');
		return FALSE;
	}

	return SUCCEEDED(StringCchCopyEx(m_tszDefaultClientName, ARRAYSIZE(m_tszDefaultClientName), ptszClientName, NULL, NULL, MISTSAFE_STRING_FLAGS));
}


HRESULT CUrlLog::Ping(
				BOOL fOnline,			// online or offline ping
				URLLOGDESTINATION destination,	// live or corp WU ping server
				PHANDLE phQuitEvents,	// ptr to handles for cancelling the operation
				UINT nQuitEventCount,	// number of handles
				URLLOGACTIVITY activity,// activity code
				URLLOGSTATUS status,	// status code
				DWORD dwError,			// error code
				LPCTSTR ptszItemID,		// uniquely identify an item
				LPCTSTR ptszDeviceID,	// PNPID or CompatID
				LPCTSTR ptszMessage,	// additional info
				LPCTSTR ptszClientName)	// client name string
{
	LOG_Block("CUrlLog::Ping");

	LPTSTR	ptszUrl = NULL;
	HRESULT hr = E_FAIL;

	switch (activity)
	{
	case URLLOGACTIVITY_Initialization:	// fall thru
	case URLLOGACTIVITY_Detection:		// fall thru
	case URLLOGACTIVITY_SelfUpdate:		// fall thru
	case URLLOGACTIVITY_Download:		// fall thru
	case URLLOGACTIVITY_Installation:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	switch (status)
	{
	case URLLOGSTATUS_Success:		// fall thru
	case URLLOGSTATUS_Reboot:		// fall thru
	case URLLOGSTATUS_Failed:		// fall thru
	case URLLOGSTATUS_Cancelled:	// fall thru
	case URLLOGSTATUS_Declined:		// fall thru
	case URLLOGSTATUS_NoItems:		// fall thru
	case URLLOGSTATUS_Pending:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	//
	// handle optional (nullable) arguments
	//
	if (NULL == ptszClientName)
	{
		ptszClientName = m_tszDefaultClientName;
	}

	if (_T('\0') == *ptszClientName)
	{
		LOG_Error(_T("client name not initialized"));
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	switch (destination)
	{
	case URLLOGDESTINATION_DEFAULT:
		destination = (
			NULL == m_ptszCorpServerUrl ||
			_T('\0') == *m_ptszCorpServerUrl) ?
			URLLOGDESTINATION_LIVE :
			URLLOGDESTINATION_CORPWU;
		break;
	case URLLOGDESTINATION_LIVE:	// fall thru
	case URLLOGDESTINATION_CORPWU:
		break;
	default:
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	LPCTSTR ptszServerUrl;

	if (URLLOGDESTINATION_LIVE == destination)
	{
		if (NULL != m_ptszLiveServerUrl)
		{
			ptszServerUrl = m_ptszLiveServerUrl;
		}
		else
		{
			ptszServerUrl = c_tszLiveServerUrl;
		}
	}
	else
	{
		ptszServerUrl = m_ptszCorpServerUrl;
	}

	if (NULL == ptszServerUrl ||
		_T('\0') == *ptszServerUrl)
	{
		LOG_Error(_T("status server Url not initialized"));
		hr = E_INVALIDARG;
		goto CleanUp;
	}

	if (!m_fPingIdInit)
	{
		if (FAILED(hr = LookupPingID()))
		{
			LOG_Error(_T("failed to init PingID (error %#lx)"), hr);
			goto CleanUp;
		}
		m_fPingIdInit = TRUE;
	}

	if (NULL == (ptszUrl = (TCHAR*) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	if (FAILED(hr = MakePingUrl(
						ptszUrl,
						INTERNET_MAX_URL_LENGTH,
						ptszServerUrl,
						ptszClientName,
						activity,
						ptszItemID,
						ptszDeviceID,
						status,
						dwError,
						ptszMessage)))
	{
		goto CleanUp;
	}

	if (fOnline)
	{
		hr = PingStatus(destination, ptszUrl, phQuitEvents, nQuitEventCount);
		if (SUCCEEDED(hr))
		{
			(void) Flush(phQuitEvents, nQuitEventCount);
			goto CleanUp;
		}
	}

	{
		USES_IU_CONVERSION;

		LPWSTR pwszUrl = T2W(ptszUrl);
		HRESULT hr2;

		if (NULL == pwszUrl)
		{
			hr = E_OUTOFMEMORY;
			goto CleanUp;
		}

		ULENTRYHEADER ulentryheader;
		ulentryheader.progress = URLLOGPROGRESS_ToBeSent;
		ulentryheader.destination = destination;
		ulentryheader.wRequestSize = lstrlen(ptszUrl) + 1;
		ulentryheader.wServerUrlLen = (WORD) lstrlen(ptszServerUrl);

		if (SUCCEEDED(hr2 = SaveEntry(ulentryheader, pwszUrl)))
		{
			hr = S_FALSE;
		}
		else if (SUCCEEDED(hr))
		{
			hr = hr2;
		}
	}

CleanUp:
	if (NULL != ptszUrl)
	{
		free(ptszUrl);
	}

	return hr;
}


// ----------------------------------------------------------------------------------
//
// PRIVATE MEMBER FUNCTIONS
//
// ----------------------------------------------------------------------------------

// Init member variables within a constructor.  No memory clean-up done here.
void CUrlLog::Init()
{
	LookupPlatform();
	LookupSystemLanguage();
	GetLogFileName();
}


// ----------------------------------------------------------------------------------
//	Construct a URL used to ping server
//
//	Returned value indicates success/failure
// ----------------------------------------------------------------------------------
HRESULT CUrlLog::MakePingUrl(
			LPTSTR	ptszUrl,			// buffer to receive result
			int		cChars,				// the number of chars this buffer can take, including ending null
			LPCTSTR ptszBaseUrl,		// server URL
			LPCTSTR ptszClientName,		// which client called
			URLLOGACTIVITY activity,
			LPCTSTR ptszItemID,
			LPCTSTR ptszDeviceID,
			URLLOGSTATUS status,
			DWORD	dwError,			// return code of activity
			LPCTSTR	ptszMessage)
{
	HRESULT hr = E_FAIL;
	LPTSTR ptszEscapedItemID = NULL;
	LPTSTR ptszEscapedDeviceID = NULL;
	LPTSTR ptszEscapedMessage = NULL;

	LOG_Block("CUrlLog::MakePingUrl");

	// Retry to get info strings if we failed within the constructor.
	if (_T('\0') == m_tszPlatform[0] ||
		_T('\0') == m_tszLanguage[0])
	{
		LOG_Error(_T("Invalid platform or language info string"));
		hr = E_UNEXPECTED;
		goto CleanUp;
	}

	// allocate enough memory for URL manipulation. Since the buffer needs
	// to be at least 2Kbytes in size, stack buffer is not suitable here.
	// we involve mem utility to similate stack memory allocation
	if ((NULL != ptszItemID &&
		 (NULL == (ptszEscapedItemID = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszItemID, ptszEscapedItemID, INTERNET_MAX_URL_LENGTH))) ||
		(NULL != ptszDeviceID &&
		 (NULL == (ptszEscapedDeviceID = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszDeviceID, ptszEscapedDeviceID, INTERNET_MAX_URL_LENGTH))) ||
		(NULL != ptszMessage &&
		 (NULL == (ptszEscapedMessage = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		  !EscapeString(ptszMessage, ptszEscapedMessage, INTERNET_MAX_URL_LENGTH))))
	{
		// Either out-of-memory or the escaped string is too lengthy.
		LOG_Error(_T("Out of memory or EscapeString failure"));
		hr = E_OUTOFMEMORY;	// actually could be HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) as well
		goto CleanUp;
	}

	const TCHAR c_tszEmpty[] = _T("");

	// Use system time as proxy cache breaker
	SYSTEMTIME st;

	GetSystemTime(&st);

	hr = StringCchPrintfEx(
				ptszUrl,
				cChars,
				NULL,
				NULL,
				MISTSAFE_STRING_FLAGS,
				_T("%swutrack.bin?V=%d&U=%s&C=%s&A=%c&I=%s&D=%s&P=%s&L=%s&S=%c&E=%08x&M=%s&X=%02d%02d%02d%02d%02d%02d%03d"),
				NULL == ptszBaseUrl ? c_tszEmpty : ptszBaseUrl,					// server URL
				c_dwPingbackVersion,											// ping-back format version
				m_tszPingID,													// ping ID
				ptszClientName,													// client name
				activity,														// activity code
				NULL == ptszEscapedItemID ? c_tszEmpty : ptszEscapedItemID,		// escaped item ID
				NULL == ptszEscapedDeviceID ? c_tszEmpty : ptszEscapedDeviceID,	// escaped device ID
				m_tszPlatform,													// platform info
				m_tszLanguage,													// sys lang info
				status,															// status code
				dwError,														// activity error code
				NULL == ptszEscapedMessage ? c_tszEmpty : ptszEscapedMessage,	// escaped message str
				st.wYear % 100,													// proxy override
				st.wMonth,
				st.wDay,
				st.wHour,
				st.wMinute,
				st.wSecond,
				st.wMilliseconds);

CleanUp:
	if (NULL != ptszEscapedItemID)
	{
		free(ptszEscapedItemID);
	}
	if (NULL != ptszEscapedDeviceID)
	{
		free(ptszEscapedDeviceID);
	}
	if (NULL != ptszEscapedMessage)
	{
		free(ptszEscapedMessage);
	}

	return hr;
}


inline HRESULT HrOpenRegHandles(HKEY *phkeyWU)
{
	const TCHAR c_tszRegKeyWU[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
	LONG lErr;
	HRESULT hr = S_OK;

	LOG_Block("HrOpenRegHandles");

	if ( NO_ERROR != (lErr = RegCreateKeyEx(
								HKEY_LOCAL_MACHINE,
								c_tszRegKeyWU,
								0,
								_T(""),
								REG_OPTION_NON_VOLATILE,
								KEY_QUERY_VALUE | KEY_SET_VALUE,
								NULL,
								phkeyWU,
								NULL)) )
	{
		hr = HRESULT_FROM_WIN32(lErr);
		LOG_ErrorMsg(lErr);
	}

	return hr;
}


const TCHAR c_tszRegValueAccountDomainSid[] = _T("AccountDomainSid");

inline HRESULT HrGetSavedGarbledAccountDomainSid(HKEY hkey, PSID *ppSid, LPDWORD pcbSid)
{
	HRESULT	hr		= S_OK;
	LPBYTE	pBlob	= NULL;
	DWORD	cbSid	= 0;
	DWORD	dwType	= REG_BINARY;
	LONG	lErr;

	LOG_Block("HrGetSavedGarbledAccountDomainSid");

	if ( NO_ERROR != (lErr = RegQueryValueEx(
								hkey,
								c_tszRegValueAccountDomainSid,
								0,
								&dwType,
								NULL,
								&cbSid)) )
	{
		hr = HRESULT_FROM_WIN32(lErr);
		goto done;
	}

	if ( REG_BINARY != dwType || 1 >= cbSid )	// 1 for the garbling byte
	{
		hr = E_UNEXPECTED;
		goto done;
	}

	if ( NULL == (pBlob = (LPBYTE) malloc(cbSid)) )
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}

	if (NO_ERROR != (lErr = RegQueryValueEx(
								hkey,
								c_tszRegValueAccountDomainSid,
								0,
								NULL,
								pBlob,
								&cbSid)))
	{
		hr = HRESULT_FROM_WIN32(lErr);
		goto done;
	}

done:
	if (FAILED(hr) )
	{
		LOG_ErrorMsg(hr);
		SafeFreeNULL(pBlob);
		cbSid = 0;
	}

	*ppSid = (PSID) pBlob;
	*pcbSid = cbSid;

	return hr;
}


inline HRESULT HrGetGarbledAccountDomainSid(PSID *ppSid, DWORD *pcbSid)
{
	HRESULT	hr = S_OK;
	PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;
	LPBYTE pGarbledSid = NULL;
	DWORD cbGarbledSid = 0;
	NTSTATUS ntstatus;
	LSA_HANDLE lsahPolicyHandle;
	LSA_OBJECT_ATTRIBUTES ObjectAttributes;

	LOG_Block("HrGetGarbledAccountDomainSid");

	ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
	ObjectAttributes.Length = sizeof(ObjectAttributes);

	// Get current domain SID of the machine
	if ( STATUS_SUCCESS != (ntstatus = LsaOpenPolicy(
											NULL,
											&ObjectAttributes,
											POLICY_VIEW_LOCAL_INFORMATION,
											&lsahPolicyHandle)) )
	{
		hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntstatus));
		goto done;
	}

	if (STATUS_SUCCESS != (ntstatus = LsaQueryInformationPolicy(
										lsahPolicyHandle,
										PolicyAccountDomainInformation,
										(PVOID *) &pAccountDomainInfo)))
	{
		hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntstatus));
		goto CleanUp;
	}

#ifdef DBG
	// DebugPrint DomainName here
	//BLOCK
	{
		USES_MY_MEMORY;

		size_t cbDomainName = pAccountDomainInfo->DomainName.Length + sizeof(WCHAR);	// for trailing null
		LPWSTR pwszDomainName = (LPWSTR) MemAlloc(cbDomainName);
		if (NULL != pwszDomainName)
		{
			ZeroMemory(pwszDomainName, cbDomainName);
			CopyMemory(pwszDomainName, pAccountDomainInfo->DomainName.Buffer, pAccountDomainInfo->DomainName.Length);
			LOG_Out(_T("DomainName = \"%ls\""), pwszDomainName);
		}
	}
#endif

	PSID psidLsa = pAccountDomainInfo->DomainSid;
	if (!IsValidSid(psidLsa))
	{
		hr = E_UNEXPECTED;
		goto CleanUp;
	}

	//BLOCK
	{
		DWORD cbCurSid = GetLengthSid(psidLsa);
		cbGarbledSid = cbCurSid + 1;	// an extra byte to garble the SID

		if (NULL == (pGarbledSid = (LPBYTE) malloc(cbGarbledSid)))
		{
			hr = E_OUTOFMEMORY;
			goto CleanUp;
		}

		if (!CopySid(cbCurSid, (PSID) pGarbledSid, psidLsa))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto CleanUp;
		}

		// one more byte is allocated to garble SID to prevent SysPrep from updating it
		pGarbledSid[cbCurSid] = pGarbledSid[cbCurSid-1];	// move last byte of SID to the extra allocated byte
		pGarbledSid[cbCurSid-1] = (0x0 == pGarbledSid[cbCurSid]) ? 0xFF : 0x0;
	}

CleanUp:
	if ( NULL != pAccountDomainInfo &&
		 STATUS_SUCCESS != (ntstatus = LsaFreeMemory(pAccountDomainInfo)) )
	{
		hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntstatus));
	}
	if (STATUS_SUCCESS != (ntstatus = LsaClose(lsahPolicyHandle)))
	{
		hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntstatus));
	}

done:
	if (FAILED(hr) )
	{
		LOG_ErrorMsg(hr);
		SafeFreeNULL(pGarbledSid);
		cbGarbledSid = 0;
	}

	*ppSid = pGarbledSid;
	*pcbSid = cbGarbledSid;

	return hr;
}

HRESULT HrGetPingID(BOOL fWritePingID, HKEY hkey, UUID *pUuidPingID)
{
	const TCHAR c_tszRegUrlLogPingID[] = _T("PingID");
	HRESULT hr = S_OK;
	DWORD dwType;
	DWORD dwSize = sizeof(*pUuidPingID);
	DWORD lErr;

	LOG_Block("HrGetPingID");

	if ( !fWritePingID )
	{
		if (NO_ERROR == (lErr = RegQueryValueEx(
						hkey,
						c_tszRegUrlLogPingID,
						0,
						&dwType,
						(LPBYTE)pUuidPingID,
						&dwSize)) )
		{
			if ((REG_BINARY == dwType) && (sizeof(*pUuidPingID) == dwSize) )
			{
				goto done;
			}
			// if we get here, we want to fall through and create the PingID
		}
		else if ( (ERROR_MORE_DATA != lErr) && (ERROR_FILE_NOT_FOUND != lErr) )
		{
			hr = HRESULT_FROM_WIN32(lErr);
			goto done;
		}
		// if we get here, we want to fall through and create the PingID
	}

	// if we get to this point, we need to create the pingID and save machine cryptographic GUID
	MakeUUID(pUuidPingID);

	if ( NO_ERROR != (lErr = RegSetValueEx(
					hkey,
					c_tszRegUrlLogPingID,
					0,
					REG_BINARY,
					(CONST BYTE*)pUuidPingID,
					sizeof(*pUuidPingID))) )
	{
		hr = HRESULT_FROM_WIN32(lErr);
		goto done;
	}

done:
#ifdef DBG
	if ( FAILED(hr) )
	{
		LOG_ErrorMsg(hr);
	}
#endif

	return hr;
}

// Obtain the existing ping ID from the registry, or generate one if not available.
HRESULT CUrlLog::LookupPingID(void)
{
	const TCHAR c_tszRegUrlLogPingID[] = _T("PingID");
	// Reg key only available on Win2K and up

	HRESULT	hr = E_FAIL;
	HKEY	hkeyWU = NULL;
	UUID	uuidPingID;
#if (defined(UNICODE) || defined(_UNICODE))
	PSID	psidCurAccountDomain = NULL;
	PSID	psidSavedAccountDomain = NULL;
	DWORD	cbSid = 0;
	DWORD	cbSavedSid = 0;
#endif

	LOG_Block("CUrlLog::LookupPingID");

	if ( FAILED(hr = HrOpenRegHandles(&hkeyWU)) )
	{
		goto no_close_handle;
	}

#if (defined(UNICODE) || defined(_UNICODE))
	// Get account domain SID of the machine and the saved copy
	if ( FAILED(hr = HrGetGarbledAccountDomainSid(&psidCurAccountDomain, &cbSid)) ||
		 (FAILED(hr = HrGetSavedGarbledAccountDomainSid(hkeyWU, &psidSavedAccountDomain, &cbSavedSid)) &&
		  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr) )
	{
		goto done;
	}

	BOOL fWritePingID = (NULL == psidSavedAccountDomain) ||
						(cbSid != cbSavedSid) ||
						(0 != memcmp(psidCurAccountDomain, psidSavedAccountDomain, cbSid));
#endif

	if ( 
#if (defined(UNICODE) || defined(_UNICODE))
		 FAILED(hr = HrGetPingID(
						fWritePingID,
						hkeyWU, &uuidPingID))
#else
		 FAILED(hr = HrGetPingID(
						FALSE,
						hkeyWU, &uuidPingID))
#endif
	   )
	{
		goto done;
	}

#if (defined(UNICODE) || defined(_UNICODE))
	if ( fWritePingID )
	{
		LONG lErr;
		if (NO_ERROR != (lErr = RegSetValueEx(
					hkeyWU,
					c_tszRegValueAccountDomainSid,
					0,
					REG_BINARY,
					(CONST BYTE*) psidCurAccountDomain,
					cbSid)) )
		{
			hr = HRESULT_FROM_WIN32(lErr);
			goto done;
		}
	}
#endif

done:
	RegCloseKey(hkeyWU);

no_close_handle:
	if ( FAILED(hr) )
	{
		LOG_ErrorMsg(hr);
		// Only happens if something failed.
		// Make a ping ID of zeroes.
		ZeroMemory(&uuidPingID, sizeof(uuidPingID));
	}


	LPTSTR p = m_tszPingID;
	LPBYTE q = (LPBYTE)&uuidPingID;
	for ( int i = 0; i < sizeof(uuidPingID); i++, q++ )
	{
		BYTE nibble = *q >> 4;	// high nibble
		*p++ = nibble >= 0xA ? _T('a') + (nibble - 0xA) : _T('0') + nibble;
		nibble = *q & 0xF;	// low nibble
		*p++ = nibble >= 0xA ? _T('a') + (nibble - 0xA) : _T('0') + nibble;
	}
	*p = _T('\0');

#if (defined(UNICODE) || defined(_UNICODE))
	SafeFree(psidCurAccountDomain);
	SafeFree(psidSavedAccountDomain);
#endif

	return hr;
}


// Obtain platfrom info for ping
void CUrlLog::LookupPlatform(void)
{
	LOG_Block("CUrlLog::LookupPlatform");

	m_tszPlatform[0] = _T('\0');

	OSVERSIONINFOEX osversioninfoex;

	ZeroMemory(&osversioninfoex, sizeof(osversioninfoex));

	// pretend to be OSVERSIONINFO for W9X/Mil
	osversioninfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (!GetVersionEx((LPOSVERSIONINFO) &osversioninfoex))
	{
		LOG_ErrorMsg(GetLastError());
		return;
	}

	if (VER_PLATFORM_WIN32_NT == osversioninfoex.dwPlatformId &&
		(5 <= osversioninfoex.dwMajorVersion ||
		 (4 == osversioninfoex.dwMajorVersion &&
		  6 <= osversioninfoex.wServicePackMajor)))
	{
		// OS is Windows NT/2000 or later: Windows NT 4.0 SP6 or later.
		// It supports OSVERSIONINFOEX.
		osversioninfoex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);	// use actual size

		if (!GetVersionEx((LPOSVERSIONINFO) &osversioninfoex))
		{
			LOG_ErrorMsg(GetLastError());
			return;
		}
	}

	SYSTEM_INFO systeminfo;

	GetSystemInfo(&systeminfo);

	(void) StringCchPrintfEx(
						m_tszPlatform,
						ARRAYSIZE(m_tszPlatform),
						NULL,
						NULL,
						MISTSAFE_STRING_FLAGS,
						_T("%lx.%lx.%lx.%lx.%x.%x.%x"),
						osversioninfoex.dwMajorVersion,
						osversioninfoex.dwMinorVersion,
						osversioninfoex.dwBuildNumber,
						osversioninfoex.dwPlatformId,
						osversioninfoex.wSuiteMask,
						osversioninfoex.wProductType,
						systeminfo.wProcessorArchitecture);
}



// Obtain system language info for ping
void CUrlLog::LookupSystemLanguage(void)
{
	LOG_Block("CUrlLog::LookupSystemLanguage");

	(void) LookupLocaleString(m_tszLanguage, ARRAYSIZE(m_tszLanguage), FALSE);

	if (0 == _tcscmp(m_tszLanguage, _T("Error")))
	{
		LOG_Error(_T("call to LookupLocaleString() failed."));
		m_tszLanguage[0] = _T('\0');
	}
}

	
// Ping server to report status
//		ptszUrl - the URL string to be pinged
//		phQuitEvents - ptr to handles for cancelling the operation
//		nQuitEventCount - number of handles
HRESULT CUrlLog::PingStatus(URLLOGDESTINATION destination, LPCTSTR ptszUrl, PHANDLE phQuitEvents, UINT nQuitEventCount) const
{
#ifdef DBG
	LOG_Block("CUrlLog::PingStatus");

	LOG_Internet(_T("Ping request=\"%s\""), ptszUrl);

	if (MustPingOffline())
	{
		LOG_Internet(_T("ForceOfflinePing = 1"));
		return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
	}
#endif

	if (!IsConnected(ptszUrl, URLLOGDESTINATION_LIVE == destination))
	{
		// There is no connection.
		LOG_ErrorMsg(ERROR_CONNECTION_INVALID);
		return HRESULT_FROM_WIN32(ERROR_CONNECTION_INVALID);
	}

	if (!HandleEvents(phQuitEvents, nQuitEventCount))
	{
		LOG_ErrorMsg(E_ABORT);
		return E_ABORT;
	}

	TCHAR tszIUdir[MAX_PATH];

	GetIndustryUpdateDirectory(tszIUdir);

	DWORD dwFlags = WUDF_CHECKREQSTATUSONLY;	// we don't actually need a file,
												//  just need to check return code
	if (URLLOGDESTINATION_CORPWU == destination)
	{
		// don't allow proxy if destination is corp WU
		dwFlags |= WUDF_DONTALLOWPROXY;
	}

	HRESULT hr = DownloadFile(
					ptszUrl, 
					tszIUdir,	// local directory to download file to
					NULL,		// optional local file name for downloaded file
								// if pszLocalPath doesn't contain a file name
					NULL,		// ptr to bytes downloaded for this file
					phQuitEvents,	// quit event, if signalled, abort downloading
					nQuitEventCount,
					NULL,
					NULL,		// parameter for call back function to use
					dwFlags
					);
#ifdef DBG
	if (FAILED(hr))
	{
		LOG_Error(_T("DownloadFile() returned error %lx"), hr);
	}
#endif

	return hr;
}



// Obtain file names for offline ping
void CUrlLog::GetLogFileName(void)
{
	const TCHAR c_tszLogFile_Local[] = _T("urllog.dat");

	GetIndustryUpdateDirectory(m_tszLogFile);

	if (FAILED(PathCchAppend(m_tszLogFile, ARRAYSIZE(m_tszLogFile), c_tszLogFile_Local)))
	{
		m_tszLogFile[0] = _T('\0');
	}
}


// Read cache entry header and request in entry
//		hFile - an open file handle to read the entry from
//		ulentryheader - reference to the struct to store the entry header
//		pwszBuffer - the WCHAR buffer to store the request (including trailing null character) in the entry
//		dwBufferSize - the size of buffer in WCHARs
// Returned value:
//		S_OK - entry successfully read
//		S_FALSE - no more entry to read from the file
//		other - error codes
HRESULT CUrlLog::ReadEntry(HANDLE hFile, ULENTRYHEADER & ulentryheader, LPWSTR pwszBuffer, DWORD dwBufferSize) const
{
	LOG_Block("CUrlLog::ReadEntry");

	DWORD dwBytes;
	DWORD dwErr;

	if (!ReadFile(
			hFile,
			&ulentryheader,
			sizeof(ulentryheader),
			&dwBytes,
			NULL))
	{
		// We failed to read the entry header.
		// There is nothing we can do at this point.
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return HRESULT_FROM_WIN32(dwErr);
	}

	if (0 == dwBytes)
	{
		// This is the end of the file.
		// There is no other entries after this point.
		return S_FALSE;
	}

	if (sizeof(ulentryheader) < dwBytes ||
		(URLLOGPROGRESS_ToBeSent != ulentryheader.progress &&
		 URLLOGPROGRESS_Sent != ulentryheader.progress) ||
		(URLLOGDESTINATION_LIVE != ulentryheader.destination &&
		 URLLOGDESTINATION_CORPWU != ulentryheader.destination) ||
		dwBufferSize < ulentryheader.wRequestSize ||
		ulentryheader.wRequestSize <= ulentryheader.wServerUrlLen)
	{
		LOG_Error(_T("Invalid entry header"));
		return E_FAIL;
	}

	if (!ReadFile(
				hFile,
				pwszBuffer,
				sizeof(WCHAR) * ulentryheader.wRequestSize,
				&dwBytes,
				NULL))
	{
		// We failed to read the string in the entry.
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return HRESULT_FROM_WIN32(dwErr);
	}

	if (dwBytes < sizeof(WCHAR) * ulentryheader.wRequestSize ||
		_T('\0') != pwszBuffer[ulentryheader.wRequestSize-1] ||
		ulentryheader.wRequestSize-1 != lstrlenW(pwszBuffer))
	{
		// The entry does not contain the complete string.
		return E_FAIL;
	}

	return S_OK;
}


// Save a string to the log file
//		destination - going to the live or corp WU ping server
//		wServerUrlLen - length of server URL part of the request, in WCHARs (not including trailing NULL)
//		pwszString - the string to be saved into the specific log file
// Returned value:
//		S_OK - entry was written to file
//		S_FALSE - the file was created by a CUrlLog class of newer version than this; entry was not written to file
//		other - error codes; entry was not written to file
HRESULT CUrlLog::SaveEntry(ULENTRYHEADER & ulentryheader, LPCWSTR pwszString) const
{
	HRESULT		hr;
	BOOL		fDeleteFile = FALSE;
	HANDLE		hFile = INVALID_HANDLE_VALUE;
	DWORD		dwBytes;

	LOG_Block("CUrlLog::SaveEntry");

	LOG_Internet(
			_T("destination = %s"),
			URLLOGDESTINATION_LIVE == ulentryheader.destination ? _T("live") : _T("corp WU"));

	if (_T('\0') == m_tszLogFile[0])
	{
		hr = E_UNEXPECTED;
		LOG_Error(_T("log file name not initialized"));
		goto CleanUp;
	}

	if(INVALID_HANDLE_VALUE == (hFile = CreateFile(
							m_tszLogFile,
							GENERIC_READ | GENERIC_WRITE,
							0,						// no sharing
							NULL,
							OPEN_ALWAYS,
							FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
							NULL)))
	{
		// We failed to open or create the file.
		// Someone may be currently using it.

		//fixcode: allow multiple pingback users
		// access the file sequentially.
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}


	hr = ValidateFileHeader(hFile, ERROR_ALREADY_EXISTS == GetLastError(), TRUE);
	if (S_OK != hr)
	{
		if (S_FALSE != hr)
		{
			// The file header is bad or there was problem validating it.
			fDeleteFile = TRUE;		// destroy the file and fail the function
		}
		// else
			// The file header has a newer version than this library code.
			// Keep the file around.

		goto CleanUp;
	}


	// Set outselves to the right position before writing to the file.
	DWORD nCurrPos;

	if (INVALID_SET_FILE_POINTER == (nCurrPos = SetFilePointer(
										hFile,
										0,
										NULL,
										FILE_END)))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
		goto CleanUp;
	}

	// Write the entry to the log.
	if (!WriteFile(
			hFile,
			&ulentryheader,
			sizeof(ulentryheader),
			&dwBytes,
			NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
	}

	if (SUCCEEDED(hr) &&
		sizeof(ulentryheader) != dwBytes)
	{
		LOG_Error(_T("Failed to write entry header to file (%d bytes VS %d bytes)"), sizeof(ulentryheader), dwBytes);
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr) &&
		!WriteFile(
			hFile,
			pwszString,
			sizeof(WCHAR) * ulentryheader.wRequestSize,
			&dwBytes,
			NULL))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		LOG_ErrorMsg(hr);
	}

	if (SUCCEEDED(hr) &&
		sizeof(WCHAR) * ulentryheader.wRequestSize != dwBytes)
	{
		LOG_Error(_T("Failed to write entry header to file (%d bytes VS %d bytes)"), sizeof(WCHAR) * ulentryheader.wRequestSize, dwBytes);
		hr = E_FAIL;
	}

	// We failed to wrote the entry into the log.
	if (FAILED(hr))
	{
		// We don't want to get rid of the other entries.
		// We can only try to remove the portion of the entry
		// we have appended from the file.
		if (INVALID_SET_FILE_POINTER == SetFilePointer(
											hFile,
											nCurrPos,
											NULL,
											FILE_BEGIN) ||
			!SetEndOfFile(hFile))
		{
			// We failed to remove the new entry.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			fDeleteFile = TRUE;
		}
		// else
			// We successfully got rid of this entry.
			// And preserved existing entries in log.
	}

CleanUp:
	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}
	if (fDeleteFile)
	{
		(void) DeleteFile(m_tszLogFile);
		// We don't delete the log file if the operation was successful.
		// Thus, no need to modify the fRet value even if DeleteFile() failed.
	}

	return hr;
}



// Send all pending (offline) ping requests to server
HRESULT CUrlLog::Flush(PHANDLE phQuitEvents, UINT nQuitEventCount)
{
	LPWSTR	pwszBuffer = NULL;
	LPTSTR	ptszUrl = NULL;
	HANDLE	hFile = INVALID_HANDLE_VALUE;
	BOOL	fKeepFile = FALSE;
	DWORD	dwErr;
	HRESULT	hr;

	LOG_Block("CUrlLog::Flush");

	if (NULL == (pwszBuffer = (LPWSTR) malloc(sizeof(WCHAR) * INTERNET_MAX_URL_LENGTH)) ||
		NULL == (ptszUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		hr = E_OUTOFMEMORY;
		goto CleanUp;
	}

	if (_T('\0') == m_tszLogFile[0])
	{
		hr = E_UNEXPECTED;
		LOG_Error(_T("log file name not initialized"));
		goto CleanUp;
	}

	// Open existing log
	if(INVALID_HANDLE_VALUE == (hFile = CreateFile(
							m_tszLogFile,
							GENERIC_READ | GENERIC_WRITE,
							0,						// no sharing
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_HIDDEN | FILE_FLAG_RANDOM_ACCESS,
							NULL)))
	{
		// We failed to open the file.
		// The file may not exist or someone may be currently using it.
		dwErr = GetLastError();

		if (ERROR_FILE_NOT_FOUND == dwErr)
		{
			// We are done.  There is nothing more to do.
			hr = S_OK;
		}
		else
		{
			//fixcode: allow multiple pingback users
			// access the file sequentially.
			LOG_ErrorMsg(dwErr);
			hr = HRESULT_FROM_WIN32(dwErr);
		}
		goto CleanUp;
	}


	// File opened.  Check header.
	hr = ValidateFileHeader(hFile, TRUE, FALSE);

	if (S_OK != hr)
	{
		if (S_FALSE == hr)
		{
			// The file header has a newer version than this library code.
			goto CleanUp; // Keep the file around.
		}
		// else
			// The file header is bad or there was problem validating it.
			// destroy the file and fail the function
	}
	else
	{
		BOOL fLiveServerFailed = FALSE;
		BOOL fCorpServerFailed = FALSE;

		// It is time to read an entry.
		for (;;)
		{
			ULENTRYHEADER ulentryheader;

			if (!HandleEvents(phQuitEvents, nQuitEventCount))
			{
				hr = E_ABORT;
				LOG_ErrorMsg(hr);
				break;
			}

			// Assume we are in the right position to read
			// the next entry from the file.

			// Read the entry header and request in entry.
			if (FAILED(hr = ReadEntry(hFile, ulentryheader, pwszBuffer, INTERNET_MAX_URL_LENGTH)))
			{
				LOG_Error(_T("Failed to read entry from cache (%#lx)"), hr);
				break;
			}

			if (S_FALSE == hr)
			{
				// There are no more unprocessed entries.
				hr = S_OK;
				break;
			}

			// We have successfully read the entry from the cache file.
			if (URLLOGPROGRESS_Sent != ulentryheader.progress)
			{
				// The entry hasn't been successfully sent yet.
				LPCTSTR	ptszBaseUrl = NULL;
				BOOL *pfWhichServerFailed;

				if (URLLOGDESTINATION_LIVE == ulentryheader.destination)
				{
					ptszBaseUrl = m_ptszLiveServerUrl;
					pfWhichServerFailed = &fLiveServerFailed;
				}
				else
				{
					ptszBaseUrl = m_ptszCorpServerUrl;
					pfWhichServerFailed = &fCorpServerFailed;
				}

				if (*pfWhichServerFailed)
				{
					continue;	// this base URL has failed before.  go on to the next entry.
				}

				LPTSTR ptszRelativeUrl;

				USES_IU_CONVERSION;

				if (NULL == (ptszRelativeUrl = W2T(pwszBuffer + ulentryheader.wServerUrlLen)))
				{
					// Running out of memory.  Will retry later.
					hr = E_OUTOFMEMORY;
					break;
				}

				if (NULL != ptszBaseUrl)
				{
					// Form the request URL
					DWORD dwUrlLen = INTERNET_MAX_URL_LENGTH;

					if (S_OK != UrlCombine(	// requires IE3 for 95/NT4
										ptszBaseUrl,
										ptszRelativeUrl,
										ptszUrl,
										&dwUrlLen,
										URL_DONT_SIMPLIFY))
					{
						// Either the buffer is too small to hold both the base and
						// the relative URLs, or the host name is invalid.
						// We will retry this entry just in case we will have a
						// shorter/better host name.
						fKeepFile = TRUE;
						continue;	// go on to the next entry
					}
				}
				else
				{
#if defined(UNICODE) || defined(_UNICODE)
					if (FAILED(hr = StringCchCopyExW(ptszUrl, INTERNET_MAX_URL_LENGTH, pwszBuffer, NULL, NULL, MISTSAFE_STRING_FLAGS)))
					{
						LOG_Error(_T("Failed to construct ping URL (%#lx)"), hr);
						break;
					}
#else
					if (0 == AtlW2AHelper(ptszUrl, pwszBuffer, INTERNET_MAX_URL_LENGTH))
					{
						// The buffer is probably too small to hold both the base and
						// the relative URLs.  We will retry this entry just in case
						// we will have a shorter/better host name.
						fKeepFile = TRUE;
						continue;	// go on to the next entry
					}
#endif
				}

				hr = PingStatus(ulentryheader.destination, ptszUrl, phQuitEvents, nQuitEventCount);

				if (FAILED(hr))
				{
					if (E_ABORT == hr)
					{
						break;
					}

					// We will resend this entry later.
					LOG_Internet(_T("Failed to send message (%#lx).  Will retry later."), hr);
					*pfWhichServerFailed = TRUE;
					fKeepFile = TRUE;

					if (fLiveServerFailed && fCorpServerFailed)
					{
						// Failed to send ping messages to both destinations.
						hr = S_OK;
						break;
					}
					continue;
				}

				DWORD	dwBytes;

				// Mark the entry off the cache file.
				ulentryheader.progress = URLLOGPROGRESS_Sent;
				// Go to the beginning of the current entry and change the entry header.
				if (INVALID_SET_FILE_POINTER == SetFilePointer(
													hFile,
													- ((LONG) (sizeof(ulentryheader) +
															   sizeof(WCHAR) * ulentryheader.wRequestSize)),
													NULL,
													FILE_CURRENT) ||
					!WriteFile(
							hFile,
							&ulentryheader,
							sizeof(ulentryheader),
							&dwBytes,
							NULL))
				{
					// We failed to mark this entry 'sent'.
					hr = HRESULT_FROM_WIN32(GetLastError());
					LOG_ErrorMsg(hr);
					break;
				}

				if (sizeof(ulentryheader) != dwBytes)
				{
					// We failed to write the header.
					LOG_Error(_T("Failed to write header (%d bytes VS %d bytes)"), sizeof(ulentryheader), dwBytes);
					hr = E_FAIL;
					break;
				}

				// Set the file pointer to the start of the next entry
				if (INVALID_SET_FILE_POINTER == SetFilePointer(
													hFile,
													sizeof(WCHAR) * ulentryheader.wRequestSize,
													NULL,
													FILE_CURRENT))
				{
					// We failed to skip the current entry.
					hr = HRESULT_FROM_WIN32(GetLastError());
					LOG_ErrorMsg(hr);
					break;
				}
			}
		}
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	if ((FAILED(hr) && E_ABORT != hr && E_OUTOFMEMORY != hr) ||
		(SUCCEEDED(hr) && !fKeepFile))
	{
		(void) DeleteFile(m_tszLogFile);
	}

CleanUp:
	if (NULL != pwszBuffer)
	{
		free(pwszBuffer);
	}
	if (NULL != ptszUrl)
	{
		free(ptszUrl);
	}
	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}

	return hr;
}



// Escape unsafe chars in a TCHAR string
// Returned value: non-zero if successful; zero otherwise
BOOL EscapeString(
			LPCTSTR	ptszUnescaped,
			LPTSTR	ptszBuffer,
			DWORD	dwCharsInBuffer)
{
	BOOL fRet = FALSE;

	LOG_Block("CUrlLog::EscapeString");

	if (NULL != ptszUnescaped &&
		NULL != ptszBuffer &&
		0 != dwCharsInBuffer)
	{
		for (DWORD i=0, j=0; _T('\0') != ptszUnescaped[i] && j+1<dwCharsInBuffer; i++, j++)
		{
			TCHAR tch = ptszUnescaped[i];

			if ((_T('a') <= tch && _T('z') >= tch) ||
				(_T('A') <= tch && _T('Z') >= tch) ||
				(_T('0') <= tch && _T('9') >= tch) ||
				NULL != _tcschr(_T("-_.!~*'()"), tch))
			{
				ptszBuffer[j] = tch;
			}
			else if (j+3 >= dwCharsInBuffer)
			{
				// We don't have enough buffer to hold the escaped string.
				// Bail out.
				break;
			}
			else
			{
				TCHAR nibble = tch >> 4;

				ptszBuffer[j++]	= _T('%');
				ptszBuffer[j++]	= nibble + (nibble >= 0x0a ? _T('A') - 0x0a : _T('0'));
				nibble = tch & 0x0f;
				ptszBuffer[j]	= nibble + (nibble >= 0x0a ? _T('A') - 0x0a : _T('0'));
			}
		}

		if (_T('\0') == ptszUnescaped[i])
		{
			ptszBuffer[j] = _T('\0');
			fRet = TRUE;
		}
#ifdef DBG
		else
		{
			// Couldn't escape the whole string due to insufficient buffer.
			LOG_ErrorMsg(ERROR_INSUFFICIENT_BUFFER);
		}
#endif
	}
#ifdef DBG
	else
	{
		LOG_ErrorMsg(E_INVALIDARG);
	}
#endif

	return fRet;
}



// Create a UUID that is not linked to MAC address of a NIC, if any, on the system.
//		pUuid - ptr to the UUID structure to hold the returning value.
void MakeUUID(UUID* pUuid)
{
	OSVERSIONINFO	osverinfo;

	LOG_Block("CUrlLog::MakeUUID");

	// check OS version
	osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);
	if (!(GetVersionEx(&osverinfo)))
	{
		LOG_ErrorMsg(GetLastError());	// log this error
	}
	else if (5 <= osverinfo.dwMajorVersion &&					// Check for Win2k & up
			 VER_PLATFORM_WIN32_NT == osverinfo.dwPlatformId)
	{
		// The OS is Win2K & up.
		// We can safely use CoCreateGuid().
		HRESULT hr = CoCreateGuid(pUuid);
		if (SUCCEEDED(hr))
		{
			goto Done;
		}

		LOG_ErrorMsg(hr);	// log this error
	}

	// Either the OS is something older than Win2K, or
	// somehow we failed to get a GUID with CoCreateGuid.
	// We still have to do something to resolve the proxy caching problem.
	// Here we construct this psudo GUID by using:
	// -	ticks since last reboot
	// -	the current process ID
	// -	time in seconds since 00:00:00 1/1/1970 UTC
	// -	fraction of a second in milliseconds for the above time.
	// -	a 15-bit unsigned random number
	//
	pUuid->Data1 = GetTickCount();
	*((DWORD*) &pUuid->Data2) = GetCurrentProcessId();

	// Use the first 6 bytes of m_uuidPingID.Data1 to store sys date/time.
	{
		_timeb tm;

		_ftime(&tm);
		*((DWORD*) &pUuid->Data4) = (DWORD) tm.time;
		((WORD*) &pUuid->Data4)[2] = tm.millitm;
	}

	// Use the last 2 bytes of m_uuidPingID.Data1 to store another random number.
	srand(pUuid->Data1);
	((WORD*) &pUuid->Data4)[3] = (WORD) rand();	// rand() returns only positive values.


Done:
	return;
}


// Check and/or fix (if necessary) the header of the log file.
//
// Returned value:
//		S_OK - the header has been fixed or the file contains
//			   a valid header. The file pointer now points to
//			   the first entry in the log file.
//		S_FALSE - the file has a valid header but the version
//				  of the file is newer than this library code.
//				  The caller should not try to overwrite the
//				  file's contents.
//		Others (failure) - the header is invalid or there was
//						   a problem accessing the file.  The
//						   file should be deleted.
HRESULT ValidateFileHeader(HANDLE hFile, BOOL fCheckHeader, BOOL fFixHeader)
{
	ULHEADER ulheader;
	DWORD dwBytes;
	HRESULT hr = E_FAIL;

	LOG_Block("ValidateFileHeader");

	if (fCheckHeader)
	{
		DWORD dwFileSize = GetFileSize(hFile, NULL);
		// Log file existed before we opened it
		if (INVALID_FILE_SIZE == dwFileSize)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
		else if (1024 * 100 < dwFileSize)	// no more than 100Kbytes
		{
			LOG_Error(_T("too many stale entries in cache."));
		}
		else if (!ReadFile(hFile, &ulheader, sizeof(ulheader), &dwBytes, NULL))
		{
			// We failed to read the header.  We must then fix up the
			// header.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
		}
		else if (sizeof(ulheader) == dwBytes)
		{
			if (CACHE_FILE_VERSION < ulheader.wVersion)
			{
				// A log file of newer version already exists.
				// We should not mess it up with an entry of older
				// format.  The query string will not be saved.
				LOG_Internet(_T("log file is of a newer version. operation cancelled."));
				return S_FALSE;
			}

			if (CACHE_FILE_VERSION == ulheader.wVersion)
			{
				// Correct version number.  We're done.
				return S_OK;
			}
			// else
				// out-dated header
				// We don't care about the entries in it.  We will replace everything
				// in order to fix the header.
		}
		// else
			// incorrect header size
			// We don't care about the entries in it.  We will replace everything
			// in order to fix the header.

		if (!fFixHeader)
		{
			return hr;
		}

		// Truncate the file to zero byte.
		if (INVALID_SET_FILE_POINTER == SetFilePointer(
										hFile,
										0,
										NULL,
										FILE_BEGIN) ||
			!SetEndOfFile(hFile))
		{
			// Nothing we can do if we failed to clear the
			// contents of the file in order to fix it up.
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			return hr;
		}
	}
	else if (!fFixHeader)
	{
		// The caller needs to pick at least one operation.
		return E_INVALIDARG;
	}


	// Assume we are at the beginning of the file.
	// We need to (re)initialize the file.
	if (fFixHeader)
	{
		ZeroMemory(&ulheader, sizeof(ulheader));

		ulheader.wVersion = CACHE_FILE_VERSION;
		if (!WriteFile(hFile, &ulheader, sizeof(ulheader), &dwBytes, NULL))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ErrorMsg(hr);
			return hr;
		}
		else if (sizeof(ulheader) != dwBytes)
		{
			LOG_Error(_T("Failed to write file header (%d bytes VS %d bytes)"), sizeof(ulheader), dwBytes);
			return E_FAIL;
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urlagent\urlagent.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:	UrlAgent.cpp
//
//  Description:
//
//		This class encapsulates the logic about where to get the right logic
//		for various purposes, including the case of running WU in corporate 
//		environments.
//
//		An object based on this class should be created first, then call
//		GetOriginalIdentServer() function to get where to download ident,
//		then download ident, then call PopulateData() function to read
//		all URL related data.
// 
//  Created by: 
//		Charles Ma
//
//	Date Creatd:
//		Oct 19, 2001
//
//***********************************************************************************

#include <windows.h>
#include <iucommon.h>
#include <osdet.h>
#include <logging.h>
#include <fileUtil.h>
#include <memutil.h>
#include <shlwapi.h>
#include <UrlAgent.h>

#include <MISTSAFE.h>
#include <wusafefn.h>



#ifndef INTERNET_MAX_URL_LENGTH
#define INTERNET_MAX_URL_LENGTH  2200
#endif

//
// starting size of url array
//
const int C_INIT_URL_ARRAY_SIZE = 4;	// for time being,we only have this many clients

//
// define the default original ident url
//
const TCHAR C_DEFAULT_IDENT_URL[] = _T("http://windowsupdate.microsoft.com/v4/");

//
// define reg keys to get ident server override for debugging
//
const TCHAR REGKEY_IDENT_SERV[] = _T("IdentServer");
const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");

const TCHAR REGVAL_ISBETA[] = _T("IsBeta");

//
// define reg keys used by related policies 
//

//
// define policy location
//
const TCHAR REGKEY_CORPWU_POLICY[] = _T("Software\\Policies\\Microsoft\\Windows\\WindowsUpdate");

//
// define ident and selfupdate server, and ping server
//
const TCHAR REGKEY_CORPWU_WUSERVER[] = _T("WUServer");
const TCHAR REGKEY_CORPWU_PINGSERVER[] = _T("WUStatusServer");

//
// define the boolean (DWORD) value under each client
//
const TCHAR REGKEY_USEWUSERVER[] = _T("UseWUServer");


//
// define ident data
//
const TCHAR IDENT_SECTION_PINGSERVER[] = _T("IUPingServer");	// section name in ident
const TCHAR IDENT_ENTRY_SERVERURL[] = _T("ServerUrl");			// ping server entry name
const TCHAR IDENT_SECITON_IUSERVERCACHE[] = _T("IUServerCache");	// query server section
const TCHAR IDENT_ENTRY_QUERYSEVERINDEX[] = _T("QueryServerIndex");	// suffix of client entry
const TCHAR IDENT_ENTRY_BETAQUERYSERVERINDEX[] = _T("BetaQueryServerIndex"); // for beta server
const TCHAR IDENT_ENTRY_SERVER[] = _T("Server");				// prefix of server entry

// main IU selfupdate keys
const TCHAR IDENT_IUSELFUPDATE[] = _T("IUSelfUpdate");
const TCHAR IDENT_IUBETASELFUPDATE[] = _T("IUBetaSelfUpdate");
const TCHAR IDENT_STRUCTUREKEY[] = _T("StructureKey");
// IU selfupdate architecture flags
const TCHAR IDENT_ARCH[] = _T("ARCH");
const TCHAR IDENT_OS[] = _T("OS");
const TCHAR IDENT_LOCALE[] = _T("LOCALE");
const TCHAR IDENT_CHARTYPE[] = _T("CHARTYPE");
// IU selfupdate sections
const TCHAR IDENT_IUARCH[] = _T("IUArch");
const TCHAR IDENT_IUOS[] = _T("IUOS");
const TCHAR IDENT_IULOCALE[] = _T("IULocale");
const TCHAR IDENT_IUCHARTYPE[] = _T("IUCharType");
// IU selfupdate arch keys
const TCHAR IDENT_X86[] = _T("x86");
const TCHAR IDENT_IA64[] = _T("ia64");
// IU selfupdate chartypes
const TCHAR IDENT_ANSI[] = _T("ansi");
const TCHAR IDENT_UNICODE[] = _T("unicode");

const TCHAR SLASHENGINECAB[] = _T("/iuengine.cab");

// AU specific:
const TCHAR CLIENT_AU[] = _T("AU");
const TCHAR CLIENT_AU_DRIVER[] = _T("AUDriver");

// *********************************************************************
// 
// begin of class implementation
//
// *********************************************************************


CUrlAgent::CUrlAgent(void)
: 	m_fPopulated(FALSE),
	m_pszOrigIdentUrl(NULL),
	m_pszInternetPingUrl(NULL),
	m_pszIntranetPingUrl(NULL),
	m_pszWUServer(NULL),
	m_ArrayUrls(NULL),
	m_nArrayUrlCount(0),
	m_nArraySize(0),
	m_nOrigIdentUrlBufSize(0),
	m_fIdentFromPolicy(FALSE)
{

	HKEY hKey = NULL;
	DWORD dwRegCheckResult = 0;
	DWORD dwSize = 0, dwType, dwValue;

	LOG_Block("CUrlAgent::CUrlAgent()");

	//
	// always try to get original ident server url
	//
	m_hProcHeap = GetProcessHeap();

	if (NULL != m_hProcHeap)
	{
		m_nOrigIdentUrlBufSize = __max(
									MAX_PATH, // reg based?
									sizeof(C_DEFAULT_IDENT_URL)/sizeof(TCHAR)); // default

		m_pszOrigIdentUrl = (LPTSTR) 
					HeapAlloc(
							m_hProcHeap,	// allocate from process heap
							HEAP_ZERO_MEMORY, 
							sizeof(TCHAR) * m_nOrigIdentUrlBufSize);

		if (NULL != m_pszOrigIdentUrl)
		{
			//
			// first, check to see if there is debug override
			//
		    dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, 0, KEY_READ, &hKey);
		    if (ERROR_SUCCESS == dwRegCheckResult)
		    {
				dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
			    dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_IDENT_SERV, NULL, &dwType, (LPBYTE)m_pszOrigIdentUrl, &dwSize);
			    if (ERROR_SUCCESS == dwRegCheckResult)
			    {
				    if (REG_SZ == dwType)
					{
						LOG_Internet(_T("Found debugging Ident-URL %s"), m_pszOrigIdentUrl);
					}
					else
				    {
					    dwRegCheckResult = ERROR_SUCCESS + 1;	// any error number will do
				    }
			    }
			    RegCloseKey(hKey);
		    }

		    if (ERROR_SUCCESS != dwRegCheckResult)
		    {
				//
				// if there is no debug override, check to see if there is policy define
				// ident server for corporate case
				//
				dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_CORPWU_POLICY, 0, KEY_READ, &hKey);
				if (ERROR_SUCCESS == dwRegCheckResult)
				{
					dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
					dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_CORPWU_WUSERVER, NULL, &dwType, (LPBYTE)m_pszOrigIdentUrl, &dwSize);
					if (ERROR_SUCCESS == dwRegCheckResult && REG_SZ == dwType)
					{
						m_fIdentFromPolicy = TRUE;
						
						//
						// for any client that its name appear here as a subkey, and
						// has a value "UseWUServer" set to 1 under the subkey, then
						// this will also be the base url used to construct the query url
						// for that client
						//
						m_pszWUServer = m_pszOrigIdentUrl;

					    LOG_Internet(_T("Found corp Ident-URL %s"), m_pszOrigIdentUrl);

						//
						// since we found wu server, for any client uses this url,
						// we can also have an optional ping server
						//
						m_pszIntranetPingUrl = (LPTSTR) HeapAlloc(
											m_hProcHeap,
											HEAP_ZERO_MEMORY, 
											sizeof(TCHAR) * m_nOrigIdentUrlBufSize);
						dwSize = sizeof(TCHAR) * m_nOrigIdentUrlBufSize;
						if (NULL != m_pszIntranetPingUrl)
						{
							if (ERROR_SUCCESS != (dwRegCheckResult = RegQueryValueEx(hKey, REGKEY_CORPWU_PINGSERVER, NULL, &dwType, (LPBYTE)m_pszIntranetPingUrl, &dwSize)) || REG_SZ != dwType)
							{
								StringCchCopyEx(m_pszIntranetPingUrl,m_nOrigIdentUrlBufSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
								dwRegCheckResult = ERROR_SUCCESS;
							}
						}
					}
					else
					{
						dwRegCheckResult = ERROR_SUCCESS + 1;	// any error number will do
					}
					RegCloseKey(hKey);
				}
		    }

		    if (ERROR_SUCCESS != dwRegCheckResult)
		    {
				//
				// not debugging , neither corporate policy found
				//
				
				StringCchCopyEx(m_pszOrigIdentUrl,m_nOrigIdentUrlBufSize,C_DEFAULT_IDENT_URL,NULL,NULL,MISTSAFE_STRING_FLAGS);
				LOG_Internet(_T("Use default ident URL %s"), m_pszOrigIdentUrl);
			}
		}
	}
	else
	{
		LOG_ErrorMsg(GetLastError());
	}

	//
    // Check IUControl Reg Key for Beta Mode
	//
	m_fIsBetaMode = FALSE;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hKey))
    {
		dwValue = 0;
		dwSize = sizeof(dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGVAL_ISBETA, NULL, NULL, (LPBYTE)&dwValue, &dwSize))
        {
            m_fIsBetaMode = (1 == dwValue);
        }
        RegCloseKey(hKey);
    }
}	


CUrlAgent::~CUrlAgent(void)
{
	DesertData();

	SafeHeapFree(m_pszOrigIdentUrl);
	SafeHeapFree(m_pszIntranetPingUrl);
}



//------------------------------------------------------------------------
//
// this function should be called after you downloaded ident, and get
// a fresh copy of ident text file from the cab, after verifying cab was
// signed properly.
//
// this function reads data from ident and registry
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::PopulateData(void)
{
	LOG_Block("CUrlAgent::PopuldateData");

	if (m_fPopulated)
		return S_OK;

	HRESULT	hr = S_OK;
	LPTSTR	pszBuffer = NULL;
	LPTSTR	pszCurrentKey = NULL;	// ptr only, no memory alloc
	LPTSTR	pszUrlBuffer = NULL;
	LPCTSTR	pcszSuffix = (m_fIsBetaMode ? IDENT_ENTRY_BETAQUERYSERVERINDEX : IDENT_ENTRY_QUERYSEVERINDEX);
	HKEY	hKey = NULL;
	DWORD	dwRegCheckResult = 0;
	DWORD	dwSize = 0, 
			dwType,
			dwValue = 0;

	int		iLen = 0, iLenSuffix = 0;
	TCHAR	szIdentBuffer[MAX_PATH + 1];
	TCHAR	szIdentFile[MAX_PATH + 1];

	if (NULL == m_hProcHeap)
	{
		return E_FAIL;
	}

	pszUrlBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR)*INTERNET_MAX_URL_LENGTH);
	CleanUpFailedAllocSetHrMsg(pszUrlBuffer);


	GetIndustryUpdateDirectory(szIdentBuffer);
	
	
	hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile), szIdentBuffer, IDENTTXT);

	if(FAILED(hr))
	{
		SafeHeapFree(pszUrlBuffer);
		LOG_ErrorMsg(hr);
		return hr;
	}

	//
	// make sure we release all data, if any
	//
	DesertData();
	
	//
	// before populate per-client array, we want to find out inter net ping server
	//
	m_pszInternetPingUrl = RetrieveIdentStrAlloc(
								IDENT_SECTION_PINGSERVER, 
								IDENT_ENTRY_SERVERURL, 
								NULL, 
								szIdentFile);

	//
	// allocate array of pointers for storing each server node
	//
	m_ArrayUrls = (PServerPerClient) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, C_INIT_URL_ARRAY_SIZE * sizeof(ServerPerClient));
	CleanUpFailedAllocSetHrMsg(m_ArrayUrls);

	m_nArraySize = C_INIT_URL_ARRAY_SIZE;	// now array is this big

	//
	// try to read data from policy first, if WU server exists
	//
	if (NULL != m_pszWUServer && 
		ERROR_SUCCESS == (dwRegCheckResult= RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_CORPWU_POLICY, 0, KEY_READ, &hKey)))
	{
		//
		// the way we find a client name under WU policy is, to open this key, see if it has a value
		// called "UseWUServer"
		//
		DWORD dwSubKeyIndex = 0;
		TCHAR szKeyName[32];
	
		while (TRUE)
		{
		DWORD dwKeyBufLen = ARRAYSIZE(szKeyName);
		dwRegCheckResult = RegEnumKeyEx(
									  hKey,             // handle to key to enumerate
									  dwSubKeyIndex,    // subkey index
									  szKeyName,        // subkey name
									  &dwKeyBufLen,     // size of subkey buffer
									  NULL,				// reserved
									  NULL,             // class string buffer
									  NULL,				// size of class string buffer
									  NULL				// last write time
									);
			if (ERROR_SUCCESS == dwRegCheckResult)
			{
				//
				// try to open this key
				//
				HKEY hKeyClient = NULL;
				dwRegCheckResult= RegOpenKeyEx(hKey, szKeyName, 0, KEY_READ, &hKeyClient);
				if (ERROR_SUCCESS == dwRegCheckResult)
				{
					//
					// try to see if it has a value called UseWUServer
					//
					dwValue = 0;
					dwType = REG_DWORD;
					dwSize = sizeof(dwValue);
					dwRegCheckResult = RegQueryValueEx(hKeyClient, REGKEY_USEWUSERVER, NULL, &dwType, (LPBYTE) &dwValue, &dwSize);
					if (ERROR_SUCCESS == dwRegCheckResult && REG_DWORD == dwType && 0x1 == dwValue)
					{
						LOG_Internet(_T("Found client %s\\UseWUServer=1"), szKeyName);

						//
						// we want to add this client to our url array
						//
						CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());

						m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy(szKeyName, sizeof(TCHAR) * (lstrlen(szKeyName) + 1));
						CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
						m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(m_pszOrigIdentUrl, sizeof(TCHAR) * (lstrlen(m_pszOrigIdentUrl) + 1));
						CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
						m_ArrayUrls[m_nArrayUrlCount].fInternalServer = TRUE;
						m_nArrayUrlCount++; // increase counter by 1

						//
						// BUG 507500 AUDriver Policy - 
						// map calls with the "AUDriver client to "AU" when checking the policy for usewuserver
						//
						if (CSTR_EQUAL == WUCompareStringI(szKeyName, CLIENT_AU))
						{
							//
							// we want to add client "AUDriver" to our url array
							//
							CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());

							m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy((LPTSTR)CLIENT_AU_DRIVER, sizeof(TCHAR) * (lstrlen(CLIENT_AU_DRIVER) + 1));
							CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
							m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(m_pszOrigIdentUrl, sizeof(TCHAR) * (lstrlen(m_pszOrigIdentUrl) + 1));
							CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
							m_ArrayUrls[m_nArrayUrlCount].fInternalServer = TRUE;
							m_nArrayUrlCount++; // increase counter by 1
						}
					}
				}
				RegCloseKey(hKeyClient);
			}
			else
			{
				if (ERROR_NO_MORE_ITEMS == dwRegCheckResult)
				{
					//
					// there is no more sub key to loop through. get out here
					//
					break;
				}
				//
				// otherwise, we try next sub key
				//
			}

			dwSubKeyIndex++; // try next sub key
		}

		RegCloseKey(hKey); // done with policy reg
	}

	//
	// now we should continue to work on internet case
	// that is, to retrieve query server(s) from ident
	//
	dwSize = MAX_PATH;
	pszBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
	while (NULL != pszBuffer &&
		   GetPrivateProfileString(
						IDENT_SECITON_IUSERVERCACHE, 
						NULL, 
						_T(""), 
						pszBuffer, 
						dwSize, 
						szIdentFile) == dwSize-2)
	{
		//
		// buffer too small? 
		//
		dwSize *= 2;

		LPTSTR pszTemp = (LPTSTR) HeapReAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, pszBuffer, dwSize * sizeof(TCHAR));
		if (NULL != pszTemp)
		{
			pszBuffer = pszTemp;
		}
		else
		{
			//
			// HeapReAlloc failed, bail from while with origional allocation freed
			//
			SafeHeapFree(pszBuffer);
		}
	}
	
	CleanUpFailedAllocSetHrMsg(pszBuffer);

	//
	// loop through each key
	//
	pszCurrentKey = pszBuffer;
	while ('\0' != *pszCurrentKey)
	{
		//
		// for the current key, we first try to see if its index key or server key
		// if it's not index key, skip it
		//
		iLen = lstrlen(pszCurrentKey);
		iLenSuffix = lstrlen(pcszSuffix);
		if ((iLen > iLenSuffix) && (0 == StrCmpI((pszCurrentKey + (iLen - iLenSuffix)), pcszSuffix)))
		{
			TCHAR szClient[MAX_PATH];	// isn't MAX_PATH big enough?
			int nIndex = 0;
			BOOL fExist = FALSE;

			//
			// retrieve server index from this key
			//
			nIndex = GetPrivateProfileInt(IDENT_SECITON_IUSERVERCACHE, pszCurrentKey, 0, szIdentFile); 

			//
			// no use of szIdentBuffer, so utilize it here
			//
			
			CleanUpIfFailedAndSetHrMsg(StringCchPrintfEx(szIdentBuffer,ARRAYSIZE(szIdentBuffer),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%d"), IDENT_ENTRY_SERVER, nIndex));
			
			GetPrivateProfileString(
								IDENT_SECITON_IUSERVERCACHE, 
								szIdentBuffer,		// use current str as key
								_T(""), 
								pszUrlBuffer, 
								INTERNET_MAX_URL_LENGTH, 
								szIdentFile);
			if ('0' != *pszUrlBuffer)
			{
				//
				// this is an index key!
				// try to extract client name from this key
				//
				
				CleanUpIfFailedAndSetHrMsg(StringCchCopyNEx(szClient,ARRAYSIZE(szClient),pszCurrentKey,iLen - iLenSuffix,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			
				//
				// find out if this client is already defined in policy and therefore
				// arleady got data in the url array
				//
				for (int i = 0; i < m_nArrayUrlCount && !fExist; i++)
				{
					fExist= (StrCmpI(m_ArrayUrls[i].pszClientName, szClient) == 0);
				}

				if (!fExist)
				{					
					CleanUpIfFailedAndSetHrMsg(ExpandArrayIfNeeded());
					m_ArrayUrls[m_nArrayUrlCount].pszClientName = (LPTSTR)HeapAllocCopy(szClient, sizeof(TCHAR) * (lstrlen(szClient) + 1));
					CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszClientName);
					m_ArrayUrls[m_nArrayUrlCount].pszQueryServer = (LPTSTR) HeapAllocCopy(pszUrlBuffer, sizeof(TCHAR) * (lstrlen(pszUrlBuffer) + 1));
					CleanUpFailedAllocSetHrMsg(m_ArrayUrls[m_nArrayUrlCount].pszQueryServer);
					m_ArrayUrls[m_nArrayUrlCount].fInternalServer = FALSE;
					m_nArrayUrlCount++; // increase counter by 1
				}
				else
				{	
					//
					// this client is already defined in policy, we just need to append the QueryServer with the
					// rest of the url path defined in iuident
					//
					LPTSTR pszPath = NULL;
					//
					// find "//" in URL retrieved from iuident          
					//
					if (NULL == (pszPath = StrStrI(pszUrlBuffer, _T("//"))))
					{
						// unexpected error
						hr = E_FAIL;
						LOG_ErrorMsg(hr);
						goto CleanUp;
					}
					else
					{
						//
						// find next "/" in URL retrieved from iuident
						//
						if (NULL != (pszPath = StrStrI(pszPath+2, _T("/"))))
						{
							DWORD dwLen = 0;
							LPTSTR pszTemp = NULL;
							//
							// remove trailing "/" in URL retrieved from policy
							//
							if (_T('/') == *(m_ArrayUrls[i-1].pszQueryServer + lstrlen(m_ArrayUrls[i-1].pszQueryServer) - 1))
							{
								dwLen = lstrlen(m_ArrayUrls[i-1].pszQueryServer) + lstrlen(pszPath);
								pszTemp = (LPTSTR)HeapReAlloc(GetProcessHeap(),
																	HEAP_ZERO_MEMORY,
																	m_ArrayUrls[i-1].pszQueryServer,
																	sizeof(TCHAR) * dwLen);
								CleanUpFailedAllocSetHrMsg(pszTemp);
								m_ArrayUrls[i-1].pszQueryServer = pszTemp;

								hr=StringCchCatEx(m_ArrayUrls[i-1].pszQueryServer,dwLen,pszPath + 1,NULL,NULL,MISTSAFE_STRING_FLAGS);
								if(FAILED(hr))
								{
									LOG_ErrorMsg(hr);
									SafeHeapFree(pszTemp);
									m_ArrayUrls[i-1].pszQueryServer=NULL;
									
								}
								
							}
							else
							{
								dwLen = lstrlen(m_ArrayUrls[i-1].pszQueryServer) + lstrlen(pszPath) + 1;
								pszTemp = (LPTSTR)HeapReAlloc(GetProcessHeap(),
																	HEAP_ZERO_MEMORY,
																	m_ArrayUrls[i-1].pszQueryServer,
																	sizeof(TCHAR) * dwLen);
								CleanUpFailedAllocSetHrMsg(pszTemp);
								m_ArrayUrls[i-1].pszQueryServer = pszTemp;
								
								hr=StringCchCatEx(m_ArrayUrls[i-1].pszQueryServer,dwLen,pszPath,NULL,NULL,MISTSAFE_STRING_FLAGS);
								if(FAILED(hr))
								{
									LOG_ErrorMsg(hr);
									SafeHeapFree(pszTemp);
									m_ArrayUrls[i-1].pszQueryServer=NULL;
								
								}

								
							}
						}
					}					
				}
			}
		}

		//
		// move to next string
		//
		pszCurrentKey += lstrlen(pszCurrentKey) + 1;
	}

	
CleanUp:

	if (FAILED(hr))
	{
		//
		// clean up half-way populated data
		//
		DesertData();
	}
	else
	{
		m_fPopulated = TRUE;
	}

	SafeHeapFree(pszBuffer);
	SafeHeapFree(pszUrlBuffer);

	return hr;
}

	
	
//------------------------------------------------------------------------
//
// get the original ident server. 
// *** this API should be called before PopulateData() is called ***
// *** this API should be called to retrieve the base URL where you download ident ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetOriginalIdentServer(
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{
	
	HRESULT hr=S_OK;

	if (NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	if (nBufferSize <= lstrlen(m_pszOrigIdentUrl))
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}

	

	hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if( FAILED(hr) )
	{ 
		return  hr;
	}


	if (NULL != pfInternalServer)
	{
		*pfInternalServer = m_fIdentFromPolicy;
	}

	return S_OK;
}



//------------------------------------------------------------------------
//
// get the ping/status server
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetLivePingServer(
			LPTSTR lpsBuffer, 
			int nBufferSize)
{

	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsBuffer || 0 >= nBufferSize)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	if (NULL != m_pszInternetPingUrl &&
		_T('\0') != *m_pszInternetPingUrl)
	{
		if (nBufferSize <= lstrlen(m_pszInternetPingUrl))
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else
		{
			
			hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszInternetPingUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
				return hr;
		}
	}
	else
	{
		*lpsBuffer = _T('\0');
	}
	return S_OK;
}


// *** this API can be called before PopulateData() is called ***
HRESULT CUrlAgent::GetCorpPingServer(
			LPTSTR lpsBuffer, 
			int nBufferSize)
{
	HRESULT hr=S_OK;

	if (NULL == m_pszIntranetPingUrl)
	{
		return (E_OUTOFMEMORY);
	}

	if (NULL == lpsBuffer || 0 >= nBufferSize)
	{
		return E_INVALIDARG;
	}
	nBufferSize/=sizeof(TCHAR);

	if (NULL != m_pszIntranetPingUrl &&
		_T('\0') != *m_pszIntranetPingUrl)
	{
		if (nBufferSize <= lstrlen(m_pszIntranetPingUrl))
		{
			return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
		else
		{
			

			hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszIntranetPingUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
				return hr;
			
		}
	}
	else
	{
		*lpsBuffer = _T('\0');
	}
	return hr;
}



//------------------------------------------------------------------------
//
// get the query server. this is per client based
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::GetQueryServer(
			LPCTSTR lpsClientName, 
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{
	
	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsClientName || NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);

	for (int i = 0; i < m_nArrayUrlCount; i++)
	{
		if (StrCmpI(m_ArrayUrls[i].pszClientName, lpsClientName) == 0)
		{
			if (nBufferSize <= lstrlen(m_ArrayUrls[i].pszQueryServer))
			{
				return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			}
			else
			{				
				hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_ArrayUrls[i].pszQueryServer,NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr)) return hr;

				if (NULL != pfInternalServer)
				{
					*pfInternalServer = m_ArrayUrls[i].fInternalServer;
				}
			}
			return S_OK;
		}
	}

	return ERROR_IU_QUERYSERVER_NOT_FOUND;
}



//------------------------------------------------------------------------
//
// tell if a particular client is controlled by policy in corporate
// returns: 
//			S_OK = TRUE
//			S_FALSE = FALSE
//			other = error, so don't know
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::IsClientSpecifiedByPolicy(
			LPCTSTR lpsClientName
			)
{

	HRESULT hr=S_OK;

	if (!m_fPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == lpsClientName)
	{
		return E_INVALIDARG;
	}

	for (int i = 0; i < m_nArrayUrlCount; i++)
	{
		if (StrCmpI(m_ArrayUrls[i].pszClientName, lpsClientName) == 0)
		{
			return (m_ArrayUrls[i].fInternalServer) ? S_OK : S_FALSE;
		}
	}

	return S_FALSE;
}


HRESULT CUrlAgent::IsIdentFromPolicy()
{
	return TRUE == m_fIdentFromPolicy ? S_OK : S_FALSE;
}

//------------------------------------------------------------------------
//
// private function, to clean up. called by destructor
//
//------------------------------------------------------------------------
void CUrlAgent::DesertData(void)
{
	LOG_Block("CUrlAgent::DesertData");

	if (NULL != m_ArrayUrls && m_nArrayUrlCount > 0)
	{
		for (int i = 0; i < m_nArrayUrlCount; i++)
		{
			SafeHeapFree(m_ArrayUrls[i].pszClientName);
			SafeHeapFree(m_ArrayUrls[i].pszQueryServer);
		}
		SafeHeapFree(m_ArrayUrls);
		m_nArrayUrlCount = 0;
		m_nArraySize = 0;
	}

	SafeHeapFree(m_pszInternetPingUrl);

	m_fPopulated = FALSE;
}




//------------------------------------------------------------------------
//
// private function, retrieve string from ident
// allocated memory will be multiple of MAX_PATH long.
//
//------------------------------------------------------------------------
LPTSTR CUrlAgent::RetrieveIdentStrAlloc(
					LPCTSTR pSection,
					LPCTSTR pEntry,
					LPDWORD lpdwSizeAllocated, 
					LPCTSTR lpszIdentFile)
{
	LPTSTR pBuffer = NULL;
	DWORD dwSize = MAX_PATH;
	DWORD dwRet = 0;
	TCHAR szIdentFile[MAX_PATH + 1];

	if (NULL == pSection || NULL == pEntry || NULL == lpszIdentFile)
	{
		return NULL;
	}
	
	//
	// try to allocate buffer first
	//
	while (TRUE)
	{
		pBuffer = (LPTSTR) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, sizeof(TCHAR) * dwSize);
		if (NULL == pBuffer)
		{
			break;
		}

		dwRet = GetPrivateProfileString(
							pSection,
							pEntry,
							_T(""),
							pBuffer,
							dwSize,
							lpszIdentFile);
		if (dwSize - 1 != dwRet)
		{
			if ('\0' == pBuffer)
			{
				//
				// no such data found from ident!
				//
				SafeHeapFree(pBuffer);
			}
			//
			// we are done!
			//
			break;
		}
		
		//
		// assume it's buffer too small
		//
		SafeHeapFree(pBuffer);
		dwSize += MAX_PATH;		// increase by 255
	}

	if (NULL != lpdwSizeAllocated)
	{
		*lpdwSizeAllocated = dwSize;
	}

	return pBuffer;
}




//------------------------------------------------------------------------
//
// helper function
// if there is no empty slot, double the size of url array
//
//------------------------------------------------------------------------
HRESULT CUrlAgent::ExpandArrayIfNeeded(void)
{
	HRESULT hr = S_OK;
	LOG_Block("CUrlAgent::ExpandArrayIfNeeded()");

	if (m_nArrayUrlCount >= m_nArraySize)
	{
		//
		// we have used up all data slots. need to expand array
		//
		m_nArraySize *= 2;
		PServerPerClient pNewArray = (PServerPerClient) HeapAlloc(m_hProcHeap, HEAP_ZERO_MEMORY, m_nArraySize * sizeof(ServerPerClient));
		if (NULL == pNewArray)
		{
			m_nArraySize /= 2;	// shrink it back
			SetHrMsgAndGotoCleanUp(E_OUTOFMEMORY);
		}
		//
		// copy old data to this new array
		//
		for (int i = 0; i < m_nArrayUrlCount; i++)
		{
			pNewArray[i] = m_ArrayUrls[i];
		}

		HeapFree(m_hProcHeap, 0, m_ArrayUrls);
		m_ArrayUrls = pNewArray;
	}
CleanUp:
	return hr;
}



// *********************************************************************
// 
// begin of derived class implementation
//
// *********************************************************************
CIUUrlAgent::CIUUrlAgent()
: 	m_fIUPopulated(FALSE),
	m_pszSelfUpdateUrl(NULL)
{
	if (m_fIdentFromPolicy)
	{
		//
		// since we found wu server, set selfupdate url to it
		//
		m_pszSelfUpdateUrl = (LPTSTR) HeapAlloc(
						m_hProcHeap,
						HEAP_ZERO_MEMORY, 
						sizeof(TCHAR) * m_nOrigIdentUrlBufSize);
		if (NULL != m_pszSelfUpdateUrl)
		{
			
			//No check is made  for the return value since this is a constructor and failure codes cannot be returned
			StringCchCopyEx(m_pszSelfUpdateUrl,m_nOrigIdentUrlBufSize,m_pszOrigIdentUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);

		}
	}
}



CIUUrlAgent::~CIUUrlAgent()
{
	m_fIUPopulated = FALSE;
	SafeHeapFree(m_pszSelfUpdateUrl);
}



//------------------------------------------------------------------------
//
// PopulateData():
// Do base class PopulateData() and then populate self-update url
//
//------------------------------------------------------------------------
HRESULT CIUUrlAgent::PopulateData(void)
{
	LOG_Block("CIUUrlAgent::PopulateData");

	if (m_fIUPopulated)
		return S_OK;

	HRESULT hr = ((CUrlAgent*)this)->PopulateData();
	if (FAILED(hr))
		return hr;

	//
	// we need to populate the self-update url from iuident if wu server is not present
	//
	if (!m_fIdentFromPolicy)
	{
		if (NULL == m_hProcHeap)
		{
			return E_FAIL;
		}

		TCHAR	szBaseServerUrl[INTERNET_MAX_URL_LENGTH];
		TCHAR	szSelfUpdateStructure[MAX_PATH];
		TCHAR	szServerDirectory[MAX_PATH] = { '\0' };
		TCHAR	szLocalPath[MAX_PATH];
		TCHAR	szValue[MAX_PATH];
		LPTSTR	pszWalk = NULL, pszDelim = NULL;		
		TCHAR	szIdentBuffer[MAX_PATH + 1];
		TCHAR	szIdentFile[MAX_PATH + 1];

		GetIndustryUpdateDirectory(szIdentBuffer);

		hr=PathCchCombine(szIdentFile,ARRAYSIZE(szIdentFile),szIdentBuffer, IDENTTXT);
		if(FAILED(hr))
		{
			LOG_ErrorMsg(hr);
			return hr;
		}
			
		m_pszSelfUpdateUrl = (LPTSTR) HeapAlloc(
							m_hProcHeap,
							HEAP_ZERO_MEMORY, 
							sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH);
		CleanUpFailedAllocSetHrMsg(m_pszSelfUpdateUrl);

		// Get SelfUpdate Server URL
		GetPrivateProfileString(m_fIsBetaMode ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
								IDENT_ENTRY_SERVERURL, 
								_T(""), 
								szBaseServerUrl, 
								ARRAYSIZE(szBaseServerUrl), 
								szIdentFile);

		if ('\0' == szBaseServerUrl[0])
		{
			// no URL specified in iuident.. 
			LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
			hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
			goto CleanUp;
		}

		// Get SelfUpdate Structure Key
		// ARCH|LOCALE
		GetPrivateProfileString(m_fIsBetaMode ? IDENT_IUBETASELFUPDATE : IDENT_IUSELFUPDATE, 
								IDENT_STRUCTUREKEY, 
								_T(""), 
								szSelfUpdateStructure, 
								ARRAYSIZE(szSelfUpdateStructure), 
								szIdentFile);

		if ('\0' == szSelfUpdateStructure[0])
		{
			// no SelfUpdate Structure in iudent
			LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
			hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
			goto CleanUp;
		}

		// Parse the SelfUpdate Structure Key for Value Names to Read
		// Initially we will only have an ARCH key.. 

		pszWalk = szSelfUpdateStructure;
		while (NULL != (pszDelim = StrChr(pszWalk, '|')))
		{
			*pszDelim = '\0';

			if (0 == StrCmpI(pszWalk, IDENT_ARCH))
			{
	#ifdef _IA64_
				GetPrivateProfileString(IDENT_IUARCH, IDENT_IA64, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#else
				GetPrivateProfileString(IDENT_IUARCH, IDENT_X86, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#endif
			}
			else if (0 == StrCmpI(pszWalk, IDENT_OS))
			{
				// Get the Current OS String
				GetIdentPlatformString(szLocalPath, ARRAYSIZE(szLocalPath));
				if ('\0' == szLocalPath[0])
				{
					LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
					hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
					goto CleanUp;
				}
				GetPrivateProfileString(IDENT_IUOS, szLocalPath, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
			}
			else if (0 == StrCmpI(pszWalk, IDENT_LOCALE))
			{
				// Get the Current Locale String
				GetIdentLocaleString(szLocalPath, ARRAYSIZE(szLocalPath));
				if ('\0' == szLocalPath[0])
				{
					LOG_ErrorMsg(ERROR_IU_SELFUPDSERVER_NOT_FOUND);
					hr = ERROR_IU_SELFUPDSERVER_NOT_FOUND;
					goto CleanUp;
				}
				GetPrivateProfileString(IDENT_IULOCALE, szLocalPath, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
			}
			else if (0 == StrCmpI(pszWalk, IDENT_CHARTYPE))
			{
	#ifdef UNICODE
				GetPrivateProfileString(IDENT_IUCHARTYPE, IDENT_UNICODE, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#else
				GetPrivateProfileString(IDENT_IUCHARTYPE, IDENT_ANSI, _T(""), szValue, ARRAYSIZE(szValue), szIdentFile);
	#endif
			}
			else
			{
				LOG_Internet(_T("Found Unrecognized Token in SelfUpdate Structure String: Token was: %s"), pszWalk);
				pszWalk += lstrlen(pszWalk) + 1; // skip the previous token, and go to the next one in the string.
				*pszDelim = '|';
				continue;
			}

			if ('\0' != szValue[0])
			{

				CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szServerDirectory,ARRAYSIZE(szServerDirectory),szValue,NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			pszWalk += lstrlen(pszWalk) + 1; // skip the previous token, and go to the next one in the string.
			*pszDelim = '|';
		}


		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(szServerDirectory,ARRAYSIZE(szServerDirectory),SLASHENGINECAB,NULL,NULL,MISTSAFE_STRING_FLAGS));
		


		if ('/' == szServerDirectory[0])
		{
			pszWalk = CharNext(szServerDirectory);
		}
		else
		{
			pszWalk = szServerDirectory;
		}

		DWORD dwSize = INTERNET_MAX_URL_LENGTH;
		UrlCombine(szBaseServerUrl, pszWalk, m_pszSelfUpdateUrl, &dwSize, 0);
	}

CleanUp:

	if (SUCCEEDED(hr))
	{
		m_fIUPopulated = TRUE;
	}

	return hr;
}



//------------------------------------------------------------------------
//
// get the self-update server. 
// *** this API should be called after PopulateData() is called ***
//
//------------------------------------------------------------------------
HRESULT CIUUrlAgent::GetSelfUpdateServer(
			LPTSTR lpsBuffer, 
			int nBufferSize,
			BOOL* pfInternalServer /*= NULL*/)
{

	HRESULT hr=S_OK;

	if (!m_fIUPopulated)
	{
		return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	}

	if (NULL == m_pszSelfUpdateUrl)
	{
		return (E_OUTOFMEMORY);
	}

	if (NULL == lpsBuffer)
	{
		return E_INVALIDARG;
	}

	nBufferSize/=sizeof(TCHAR);
	if (nBufferSize <= lstrlen(m_pszSelfUpdateUrl))
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}


	hr=StringCchCopyEx(lpsBuffer,nBufferSize,m_pszSelfUpdateUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);

	if(FAILED(hr))
		return hr;


	if (NULL != pfInternalServer)
	{
		*pfInternalServer = m_fIdentFromPolicy;
	}	
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urllogging\internet.cpp ===
//=======================================================================
//
//  Copyright (c) 2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:    internet.cpp
//
//  Creator: PeterWi
//
//  Purpose: internet functions.
//
//=======================================================================

#pragma hdrstop

#include <tchar.h>
#include <winsock2.h>	// for LPWSADATA, struct hostent
#include <wininet.h>	// for InternetGetConnectedState(), InternetQueryOptionA()
#include <iphlpapi.h>	// for IPAddr
#include <sensapi.h>	// for NETWORK_ALIVE_*

#include <logging.h>	// for LOG_Block, LOG_Error and LOG_Internet
#include <MemUtil.h>	// USES_IU_CONVERSION, T2A(), MemAlloc
#include <wusafefn.h>
#include <shlwapi.h>	// UrlGetPart
#include <MISTSafe.h>

#include <URLLogging.h>

#define ARRAYSIZE(a)	(sizeof(a)/sizeof((a)[0]))

typedef BOOL	(WINAPI * ISNETWORKALIVE)(LPDWORD);
//typedef BOOL	(WINAPI * INETCONNECTSTATE)(LPDWORD, DWORD);
//typedef BOOL	(WINAPI * INETQUERYOPTION)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef DWORD	(WINAPI * GETBESTINTERFACE)(IPAddr, DWORD *);
typedef ULONG	(WINAPI * INET_ADDR)(const char FAR *);
typedef struct hostent FAR * (WINAPI * GETHOSTBYNAME)(const char FAR *name);
typedef int		(WINAPI * WSASTARTUP)(WORD, LPWSADATA);
typedef int		(WINAPI * WSACLEANUP)(void);
#ifdef DBG
typedef int		(WINAPI * WSAGETLASTERROR)(void);
#endif

const char c_szWU_PING_URL[] = "207.46.226.17"; // current ip addr for windowsupdate.microsoft.com

// forward declarations
BOOL IsConnected_2_0(void);

// HKLM\Software\Microsoft\Windows\CurrentVersion\WindowsUpdate\IsConnected DWORD reg value
#define ISCONNECTEDMODE_Unknown				-1		// static variable not initialized yet
#define ISCONNECTEDMODE_Default				0
	// live: use AU 2.0 logic
	//       test = InternetGetConnectedState + InternetQueryOption + GetBestInterface on static IP
	// CorpWU: same as ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface
#define ISCONNECTEDMODE_AlwaysConnected		1
	// live/CorpWU: Assume the destination is always reachable. e.g. via D-tap connection.
#define ISCONNECTEDMODE_IsNetworkAliveOnly	2
	// live/CorpWU: test = IsNetworkAlive.
#define ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface	3
	// live: test = IsNetworkAlive + GetBestInterface on static IP
	// CorpWU: test = IsNetworkAlive + gethostbyname + GetBestInterface

#define ISCONNECTEDMODE_MinValue			0
#define ISCONNECTEDMODE_MaxValue			3

inline DWORD GetIsConnectedMode(void)
{
	static DWORD s_dwIsConnectedMode = ISCONNECTEDMODE_Unknown;

	if (ISCONNECTEDMODE_Unknown == s_dwIsConnectedMode)
	{
		// Assume using default connection detection mechanism
		s_dwIsConnectedMode = ISCONNECTEDMODE_Default;

		const TCHAR c_tszRegKeyWU[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate");
		const TCHAR c_tszRegUrlLogIsConnectedMode[] = _T("IsConnectedMode");

		HKEY	hkey;

		if (NO_ERROR == RegOpenKeyEx(
							HKEY_LOCAL_MACHINE,
							c_tszRegKeyWU,
							0,
							KEY_QUERY_VALUE,
							&hkey))
		{
			DWORD	dwSize = sizeof(s_dwIsConnectedMode);
			DWORD	dwType;

			if (NO_ERROR != RegQueryValueEx(
								hkey,
								c_tszRegUrlLogIsConnectedMode,
								0,
								&dwType,
								(LPBYTE) &s_dwIsConnectedMode,
								&dwSize) ||
				REG_DWORD != dwType ||
				sizeof(s_dwIsConnectedMode) != dwSize ||
// comment out the next line to avoid error C4296: '>' : expression is always false
//				ISCONNECTEDMODE_MinValue > s_dwIsConnectedMode ||
				ISCONNECTEDMODE_MaxValue < s_dwIsConnectedMode)
			{
				s_dwIsConnectedMode = ISCONNECTEDMODE_Default;
			}

			RegCloseKey(hkey);
		}
	}

	return s_dwIsConnectedMode;
}

// ----------------------------------------------------------------------------------
// IsConnected()
//          detect if there is a connection currently that can be used to
//          connect to Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :  ptszUrl - Url containing host name to check for connection
//			fLive - whether the destination is the live site
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the site or we are not connected.
// ----------------------------------------------------------------------------------

BOOL IsConnected(LPCTSTR ptszUrl, BOOL fLive)
{
    BOOL bRet = FALSE;
	DWORD dwFlags = 0;
	ISNETWORKALIVE pIsNetworkAlive = NULL;
    HMODULE hIphlp = NULL, hSock = NULL, hSens = NULL;
	DWORD dwIsConnectedMode = GetIsConnectedMode();

	LOG_Block("IsConnected");

	if (ISCONNECTEDMODE_AlwaysConnected == dwIsConnectedMode)
	{
		LOG_Internet(_T("AlwaysConnected"));
		bRet = TRUE;
		goto lFinish;
	}

	if (fLive && ISCONNECTEDMODE_Default == dwIsConnectedMode)
	{
		LOG_Internet(_T("Use 2.0 algorithm"));
		bRet = IsConnected_2_0();
		goto lFinish;
	}

// InternetGetConnectedState() returns FALSE if Wininet/IE AutoDial is configured.
// Thus we can't rely on it to see if we have network connectivity.
#if 0
    DWORD dwConnMethod = 0, dwState = 0, dwSize = sizeof(DWORD);

    bRet = InternetGetConnectedState(&dwConnMethod, 0);

#ifdef DBG
	
	LOG_Internet(_T("Connection Method is %#lx"), dwConnMethod);  
	LOG_Internet(_T("InternetGetConnectedState() return value %d"), bRet);

    if (dwConnMethod & INTERNET_CONNECTION_MODEM)
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_LAN )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_LAN"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_PROXY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_PROXY"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM_BUSY"));
    }
#endif

    if (bRet)
    {
        // modem is dialing
        if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
        {
            bRet = FALSE;
			goto lFinish;
        }

        // check if there is a proxy but currently user is offline
        if (dwConnMethod & INTERNET_CONNECTION_PROXY)
        {
            if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
            {
                if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
                    bRet = FALSE;
					goto lFinish;
				}
            }
            else
            {
                LOG_Error(_T("IsConnected() fail to get InternetQueryOption (%#lx)"), GetLastError());
            }
        }
    }
    else
    {
        //
        // further test the case that user didn't run icw but is using a modem connection
        //
        const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
        if ((dwConnMethod & dwModemConn) == dwModemConn)
        {
            bRet = TRUE;
        }
    }

    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if (!bRet || (dwConnMethod & INTERNET_CONNECTION_LAN))  //LAN card present
		//bug 299338
	{
		// do gethostbyname and GetBestInterface
	}
#endif

	if (NULL == (hSens = LoadLibraryFromSystemDir(TEXT("sensapi.dll"))) ||
		NULL == (pIsNetworkAlive = (ISNETWORKALIVE)::GetProcAddress(hSens, "IsNetworkAlive")))
	{
		LOG_Error(_T("failed to load IsNetworkAlive() from sensapi.dll"));
		goto lFinish;
	}

	if (pIsNetworkAlive(&dwFlags))
    {
#ifdef DBG
		if (NETWORK_ALIVE_LAN & dwFlags)
		{
			LOG_Internet(_T("active LAN card(s) detected"));
		}
		if (NETWORK_ALIVE_WAN & dwFlags)
		{
			LOG_Internet(_T("active RAS connection(s) detected"));
		}
		if (NETWORK_ALIVE_AOL & dwFlags)
		{
			LOG_Internet(_T("AOL connection detected"));
		}
#endif
		if (ISCONNECTEDMODE_IsNetworkAliveOnly == dwIsConnectedMode)
		{
			LOG_Internet(_T("IsNetworkAliveOnly ok"));
			bRet = TRUE;
			goto lFinish;
		}

		// can't be moved into where ptszHostName and pszHostName are
		// MemAlloc'ed since pszHostName will be used outside that block.
		USES_IU_CONVERSION;

		GETBESTINTERFACE pGetBestInterface = NULL;
		INET_ADDR pInetAddr = NULL;
		LPCSTR pszHostName = NULL;

		if (fLive && ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface == dwIsConnectedMode)
		{
			pszHostName = c_szWU_PING_URL;
		}
		else
		{
			// !fLive && (ISCONNECTEDMODE_Default == dwIsConnectedMode ||
			// ISCONNECTEDMODE_IsNetworkAliveAndGetBestInterface == dwIsConnectedMode)
			if (NULL == ptszUrl || _T('\0') == ptszUrl[0])
			{
				LOG_Error(_T("IsConnected() invalid parameter"));
			}
			else
			{
				TCHAR tszHostName[40];	// arbitrary buffer size that should work with most domain names
				DWORD dwCchHostName = ARRAYSIZE(tszHostName);
				LPTSTR ptszHostName = tszHostName;

				HRESULT hr = UrlGetPart(ptszUrl, tszHostName, &dwCchHostName, URL_PART_HOSTNAME, 0);

				if (E_POINTER == hr)
				{
					if (NULL != (ptszHostName = (LPTSTR) MemAlloc(sizeof(TCHAR) * dwCchHostName)))
					{
						hr = UrlGetPart(ptszUrl, ptszHostName, &dwCchHostName, URL_PART_HOSTNAME, 0);
					}
					else
					{
						hr = E_OUTOFMEMORY;
					}
				}

				if (FAILED(hr))
				{
					LOG_Error(_T("failed to extract hostname (error %#lx)"), hr);
				}
				else
				{
					pszHostName = T2A(ptszHostName);
				}
			}
		}

		if (NULL == pszHostName)
		{
			LOG_Error(_T("call to T2A (IU version) failed"));
		}
		else if (
			NULL != (hIphlp = LoadLibraryFromSystemDir(TEXT("iphlpapi.dll"))) &&
			NULL != (hSock = LoadLibraryFromSystemDir(TEXT("ws2_32.dll"))) &&
			NULL != (pGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(hIphlp, "GetBestInterface")) &&
			NULL != (pInetAddr = (INET_ADDR)::GetProcAddress(hSock, "inet_addr")))
		{
			IPAddr dest;

			LOG_Internet(_T("checking connection to %hs..."), pszHostName);

			//fixcode: should check against broadcasting IP addresses
			if (INADDR_NONE == (dest = pInetAddr(pszHostName)))
			{
				GETHOSTBYNAME pGetHostByName = NULL;
				WSASTARTUP pWSAStartup = NULL;
				WSACLEANUP pWSACleanup = NULL;
#ifdef DBG
				WSAGETLASTERROR pWSAGetLastError = NULL;
#endif
				WSADATA wsaData;
				int iErr = 0;

				if (NULL != (pGetHostByName = (GETHOSTBYNAME)::GetProcAddress(hSock, "gethostbyname")) &&
#ifdef DBG
					NULL != (pWSAGetLastError = (WSAGETLASTERROR)::GetProcAddress(hSock, "WSAGetLastError")) &&
#endif
					NULL != (pWSAStartup = (WSASTARTUP)::GetProcAddress(hSock, "WSAStartup")) &&
					NULL != (pWSACleanup = (WSACLEANUP)::GetProcAddress(hSock, "WSACleanup")) &&

					//fixcode: should be called at the constructor of CUrlLog and when IU (when online) or AU starts.
					0 == pWSAStartup(MAKEWORD(1, 1), &wsaData))
				{
#ifdef DBG
					DWORD dwStartTime = GetTickCount();
#endif
					struct hostent *ptHost = pGetHostByName(pszHostName);

					if (NULL != ptHost &&
						AF_INET == ptHost->h_addrtype &&
						sizeof(IPAddr) == ptHost->h_length &&
						NULL != ptHost->h_addr_list &&
						NULL != ptHost->h_addr)
					{
						// take the first IP address
						dest = *((IPAddr FAR *) ptHost->h_addr);
#ifdef DBG
						LOG_Internet(
								_T("Host name %hs resolved to be %d.%d.%d.%d, took %d msecs"),
								pszHostName,
								(BYTE) ((ptHost->h_addr)[0]),
								(BYTE) ((ptHost->h_addr)[1]),
								(BYTE) ((ptHost->h_addr)[2]),
								(BYTE) ((ptHost->h_addr)[3]),
								GetTickCount() - dwStartTime);
#endif
					}
#ifdef DBG
					else
					{
						LOG_Internet(_T("Host name %hs couldn't be resolved (error %d), took %d msecs"), pszHostName, pWSAGetLastError(), GetTickCount() - dwStartTime);
					}
#endif
					//fixcode: should be called at the destructor of CUrlLog and when IU (when online) or AU ends.
					if (iErr = pWSACleanup())
					{
						LOG_Error(_T("failed to clean up winsock (error %d)"), iErr);
					}
				}
				else
				{
					LOG_Error(_T("failed to load winsock procs or WSAStartup() failed"));
				}
			}

			if (INADDR_NONE != dest)
			{
				DWORD dwErr, dwIndex;

				if (bRet = (NO_ERROR == (dwErr = pGetBestInterface(dest, &dwIndex))))
				{
					LOG_Internet(_T("route found on interface #%d"), dwIndex);
				}
				else
				{
					LOG_Internet(_T("GetBestInterface() failed w/ error %d"), dwErr);
				}
			}
		}
		else
		{
			LOG_Error(_T("failed to load procs from winsock/ip helper (error %d)"), GetLastError());
		}
    }
	else
	{
		LOG_Internet(_T("no active connection detected"));
	}

lFinish:
    if (hIphlp != NULL)
    {
        FreeLibrary(hIphlp);
    }
	if (hSock != NULL)
	{
		FreeLibrary(hSock);
	}
	if (hSens != NULL)
	{
		FreeLibrary(hSens);
	}

    return (bRet);
}


// ----------------------------------------------------------------------------------
//
// Function IsConnected_2_0()
//          detect if there is a cunection currently can be used to
//          connect to live Windows Update site.
//          If yes, we activate the shedule DLL
//
// Input :   None
// Output:  None
// Return:  TRUE if we are connected and we can reach the web site.
//          FALSE if we cannot reach the live site or we are not connected.
//
//
// ----------------------------------------------------------------------------------

BOOL IsConnected_2_0()
{
    BOOL bRet = FALSE;
    DWORD dwConnMethod, dwState = 0, dwSize = sizeof(DWORD), dwErr, dwIndex;
    GETBESTINTERFACE pGetBestInterface = NULL;
    INET_ADDR pInet_addr = NULL;
    HMODULE hIphlp = NULL, hSock = NULL;

	LOG_Block("IsConnected");

    bRet = InternetGetConnectedState(&dwConnMethod, 0);

/*
#ifdef DBG
	
	LOG_Internet(_T("Connection Method is %#lx"), dwConnMethod);  
	LOG_Internet(_T("InternetGetConnectedState() return value %d"), bRet);

    if (dwConnMethod & INTERNET_CONNECTION_MODEM)
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_LAN )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_LAN"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_PROXY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_PROXY"));
    }
    if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
    {
        LOG_Internet(_T("\t%s"), _T("INTERNET_CONNECTION_MODEM_BUSY"));
    }
#endif
*/

    if (bRet)
    {
        // modem is dialing
        if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
        {
            bRet = FALSE;
			goto lFinish;
        }

        // check if there is a proxy but currently user is offline
        if (dwConnMethod & INTERNET_CONNECTION_PROXY)
        {
            if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
            {
                if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
                    bRet = FALSE;
					goto lFinish;
				}
            }
            else
            {
                LOG_Error(_T("IsConnected() fail to get InternetQueryOption (%#lx)"), GetLastError());
            }
        }
    }
    else
    {
        //
        // further test the case that user didn't run icw but is using a modem connection
        //
        const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
        if ((dwConnMethod & dwModemConn) == dwModemConn)
        {
            bRet = TRUE;
        }
    }
    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if ((bRet && (dwConnMethod & INTERNET_CONNECTION_LAN)) ||  //LAN card present
		(!bRet)) //bug 299338
    {
        struct sockaddr_in dest;
        hSock = LoadLibraryFromSystemDir(TEXT("ws2_32.dll"));
        hIphlp = LoadLibraryFromSystemDir(TEXT("iphlpapi.dll"));
        if ((hIphlp == NULL) || (hSock == NULL))
        {
            goto lFinish;
        }

        pGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(hIphlp, "GetBestInterface");
        pInet_addr = (INET_ADDR)::GetProcAddress(hSock, "inet_addr");
        if ((pGetBestInterface == NULL) || (pInet_addr == NULL))
        {
            goto lFinish;
        }
        if ((dest.sin_addr.s_addr = pInet_addr(c_szWU_PING_URL)) == INADDR_ANY)
        {
            goto lFinish;
        }
        if (NO_ERROR != (dwErr = pGetBestInterface(dest.sin_addr.s_addr, &dwIndex)))
        {
            LOG_ErrorMsg(dwErr);
            bRet = FALSE;
            //any error bail out for now
            /*
            if (dwErr == ERROR_NETWORK_UNREACHABLE)     //winerror.h
            {
                bRet = FALSE;
            }
            */
        }
		else
		{
			bRet = TRUE;
		}
    }

lFinish:
    if (hIphlp != NULL)
    {
        FreeLibrary(hIphlp);
    }
    if (hSock != NULL)
    {
        FreeLibrary(hSock);
    }

    LOG_Internet(_T("%s"), bRet ? _T("Connected") : _T("Not connected"));
    return (bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urllogging\test\sources.inc ===
#
# Copyright (c) 2002	Microsoft Corporation
#
# Module Name:	testIsConnected
#
# Abstract:		Test the IsConnected() function in the URLLogging library
#

TARGETNAME=testIsConnected
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM
UMTYPE=console

SOURCES= \
	testIsConnected.cpp	\
#	testSens.cpp \
	testIsConnected.rc

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\..\inc

TARGETLIBS = \
	$(WINDOWS_COM)\lib\URLLogging\$(WUBLDTYPE)\$(O)\URLLogging.lib	\
	$(WINDOWS_COM)\lib\logging\$(WUBLDTYPE)\$(O)\logging.lib	\
	$(WINDOWS_COM)\lib\util\$(WUBLDTYPE)\$(O)\util.lib	\
	$(WINDOWS_COM)\lib\wusafefn\$(WUBLDTYPE)\$(O)\wusafefn.lib	\
	$(SDK_LIB_PATH)\shlwapi.lib	\
	$(SDK_LIB_PATH)\User32.lib	\
	$(SDK_LIB_PATH)\ole32.lib	\
	$(SDK_LIB_PATH)\oleaut32.lib	\
	$(SDK_LIB_PATH)\version.lib	\
    $(SDK_LIB_PATH)\uuid.lib	\
    $(SDK_LIB_PATH)\Rpcrt4.lib	\
    $(SDK_LIB_PATH)\comctl32.lib	\
	$(SDK_LIB_PATH)\shell32.lib	\
    $(SDK_LIB_PATH)\advpack.lib	\
	$(SDK_LIB_PATH)\wininet.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\bincompatible.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	BinarySubSystem.cpp
//  Module: util.lib
//
//***********************************************************************************
#pragma once
#include <windows.h>
#include <tchar.h>
#include <iucommon.h>
#include <fileutil.h>

HRESULT IsBinaryCompatible(LPCTSTR lpszFile)
{
    DWORD               cbRead;
    IMAGE_DOS_HEADER    img_dos_hdr;
    PIMAGE_OS2_HEADER   pimg_os2_hdr;
    IMAGE_NT_HEADERS    img_nt_hdrs;
    HRESULT             hr = BIN_E_MACHINE_MISMATCH;
    HANDLE              hFile = INVALID_HANDLE_VALUE;

    if((hFile = CreateFile(lpszFile, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE)
    {
        goto done;
    }

    //Read the MS-DOS header (all windows executables start with an MS-DOS stub)
    if(!ReadFile(hFile, &img_dos_hdr, sizeof(img_dos_hdr), &cbRead, NULL) ||
        cbRead != sizeof(img_dos_hdr))
    {
        goto done;
    }

    //Verify that the executable has the MS-DOS header
    if(img_dos_hdr.e_magic != IMAGE_DOS_SIGNATURE)
    {
        hr = BIN_E_BAD_FORMAT;
        goto done;
    }
    //Move file pointer to the actual PE header (NT header)
    if(SetFilePointer(hFile, img_dos_hdr.e_lfanew, 0, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        goto done;
    }

    //Read the NT header
    if(!ReadFile(hFile, &img_nt_hdrs, sizeof(img_nt_hdrs), &cbRead, NULL) ||
        cbRead != sizeof(img_nt_hdrs))
    {
        goto done;
    }

    //Check for NT signature in the header (we dont support OS2)
    if(img_nt_hdrs.Signature != IMAGE_NT_SIGNATURE)
    {
        goto done;
    }

    //Check to see if the executable belongs to the correct subsystem
    switch(img_nt_hdrs.OptionalHeader.Subsystem)
    {
    case IMAGE_SUBSYSTEM_NATIVE:
    case IMAGE_SUBSYSTEM_WINDOWS_GUI:
    case IMAGE_SUBSYSTEM_WINDOWS_CUI:
 
    //If it is a supported subsystem, check CPU architecture
    if ( img_nt_hdrs.FileHeader.Machine == 
#ifdef _IA64_
    IMAGE_FILE_MACHINE_IA64)
#elif defined _X86_
    IMAGE_FILE_MACHINE_I386)
#elif defined _AMD64_
    IMAGE_FILE_MACHINE_AMD64)
#else
#pragma message( "Windows Update : Automatic Updates does not support this processor." )
    IMAGE_FILE_MACHINE_I386)
#endif
        {
            hr = S_OK;
        }
        break;
    default:
        break;
    }

done:
    SafeCloseFileHandle(hFile);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\ensureacls.cpp ===
//***********************************************************************************
//
//  Copyright (c) 2002 Microsoft Corporation.  All Rights Reserved.
//
//  File:	EnsureACLs.cpp
//  Module: util.lib
//
//***********************************************************************************
#pragma once

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500  // Win2000 and later
#endif

#include <windows.h>
#include <tchar.h>
#include <safefunc.h>
#include <shlobj.h>
#include <sddl.h>
#include <Aclapi.h>
#include <fileutil.h>
#include <logging.h>
#include <wusafefn.h>
#include <mistsafe.h>


#if defined(UNICODE) || defined (_UNICODE)

typedef DWORD (*TREERESETSECURITY)(
                        LPTSTR               pObjectName,
                        SE_OBJECT_TYPE       ObjectType,
                        SECURITY_INFORMATION SecurityInfo,
                        PSID                 pOwner OPTIONAL,
                        PSID                 pGroup OPTIONAL,
                        PACL                 pDacl OPTIONAL,
                        PACL                 pSacl OPTIONAL,
                        BOOL                 KeepExplicit,
                        FN_PROGRESS          fnProgress OPTIONAL,
                        PROG_INVOKE_SETTING  ProgressInvokeSetting,
                        PVOID                Args OPTIONAL);



//Function to enable or disable a particular privelege for the current process
//Last parameter is optional, will return the previous state of the privelege
DWORD EnablePrivilege(LPCTSTR pszPrivName, BOOL fEnable, BOOL *pfWasEnabled);

/******************************************************************************
//Function to recursively set ACLS on the specified folder.
//Currently we set the following ACL's
// * Allow SYSTEM full control 
// * Allow Admins full control 
// * Allow Owners full control 
// * Allow Power Users R/W/X control 
******************************************************************************/
HRESULT SetDirPermissions(LPCTSTR lpszDir);

#endif 

//Rename the 'WindowsUpdate' file to 'WindowsUpdate.TickCount'; if rename fails we try to delete it
//Note that we wont revert the ownerhip of the file
BOOL RenameWUFile(LPCTSTR lpszFilePath);


/*****************************************************************************
//Function to set ACL's on Windows Update directories, optionally creates the 
//directory if it doesnt already exists
//This function will:
// * Take ownership of the directory and it's children
// * Set all the children to inherit ACL's from parent
// * Set the specified directory to NOT inherit properties from it's parent
// * Set the required ACL's on the specified directory
// * Replace the ACL's on the children (i.e. propogate own ACL's and remove 
//   those ACL's which were explicitly set
//
//	Input: 
//		lpszDirectory: Path to the directory to ACL, If it is NULL we use the
                       path to the WindowsUpdate directory
        fCreateAlways: Flag to indicate creation of new directory if it doesnt
                       already exist
******************************************************************************/
HRESULT CreateDirectoryAndSetACLs(LPCTSTR lpszDirectory, BOOL fCreateAlways)
{
    LOG_Block("CreateDirectoryAndSetACLs");
    BOOL fIsDirectory = FALSE;
    LPTSTR lpszWUDirPath = NULL;
    LPTSTR lpszDirPath = NULL;

#if defined(UNICODE) || defined (_UNICODE)
    BOOL fChangedPriv = FALSE;
    BOOL fPrevPrivEnabled = FALSE;
#endif
    
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_CANNOT_MAKE);
    
    if(NULL == lpszDirectory && !fCreateAlways)     
    {
        hr = E_INVALIDARG;
        goto done;
    }

    //Use WU directory if input parameter is NULL
    if(NULL == lpszDirectory) 
    {
        lpszWUDirPath = (LPTSTR)malloc(sizeof(TCHAR)*(MAX_PATH+1));
        if(NULL == lpszWUDirPath)
        {
            hr = E_OUTOFMEMORY;
            goto done;
        }
        //Get the path to the Windows Update directory
        if(!GetWUDirectory(lpszWUDirPath, MAX_PATH+1))
        {
            goto done;
        }
        lpszDirPath = lpszWUDirPath;
    }
    // else use the passed in parameter
    else    
    {
        lpszDirPath = (LPTSTR)lpszDirectory;
    }

    //if dir (or file) does not exist
    if (!fFileExists(lpszDirPath, &fIsDirectory))
    {
        if(!fCreateAlways)      //no need to create a new one
        {
            goto done;
        }
        if(!(fIsDirectory = CreateNestedDirectory(lpszDirPath)))
        {
            goto done;
        }
    }

    //Since these apis are only available for win2k and above, dont compile for ansii (we dont care about NT4)
#if defined(UNICODE) || defined (_UNICODE)
    //Enable privelege to 'take ownership' , we will continue even if we failed for some reason
    fChangedPriv = (ERROR_SUCCESS == EnablePrivilege(SE_TAKE_OWNERSHIP_NAME, TRUE, &fPrevPrivEnabled));
    
    //Take ownership and apply correct ACL's, we dont care if we fail
    SetDirPermissions(lpszDirPath);
#endif
    
    //Check for a file name-squatting on the specified directory
    if (!fIsDirectory)     
    {
        if( !RenameWUFile(lpszDirPath) ||           //Rename or delete the existing file
            !CreateNestedDirectory(lpszDirPath))    //Create a new directory
        {
            goto done;
        }
#if defined(UNICODE) || defined (_UNICODE)
        //Take ownership and apply correct ACL's, we dont care if we fail
        SetDirPermissions(lpszDirPath);
#endif
    }
    hr = S_OK;

done:
#if defined(UNICODE) || defined (_UNICODE)
    //Restore previous privelege
    if(fChangedPriv)
    {
         EnablePrivilege(SE_TAKE_OWNERSHIP_NAME, fPrevPrivEnabled, NULL);
    }
#endif
    SafeFreeNULL(lpszWUDirPath);
    return hr;
}

/********************************************************************************
//Get the path to the WindowsUpdate Directory (without the backslash at the end)
*********************************************************************************/
BOOL GetWUDirectory(LPTSTR lpszDirPath, DWORD chCount, BOOL fGetV4Path)
{
    LOG_Block("GetWUDirectory");
    const TCHAR szWUDir[]   = _T("\\WindowsUpdate");
    const TCHAR szV4[]      = _T("\\V4");
    BOOL fRet = FALSE;

    if(NULL == lpszDirPath)
    {
        return FALSE;
    }

    //Get the path to the Program Files directory
    if (S_OK != SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, lpszDirPath))
    {
        goto done;
    }
    //Append the WU Directory
    if (FAILED(StringCchCatEx(lpszDirPath, chCount, szWUDir, NULL, NULL, MISTSAFE_STRING_FLAGS)))
	{
        goto done;
	}
    if(fGetV4Path && FAILED(StringCchCatEx(lpszDirPath, chCount, szV4, NULL, NULL, MISTSAFE_STRING_FLAGS)))
    {
        goto done;
    }
    fRet = TRUE;
    
done:
    return fRet;
}


#if defined(UNICODE) || defined (_UNICODE)
/********************************************************************************
//Function to enable or disable a particular privelege
//Last parameter is optional, will return the previous state of the privelege
********************************************************************************/
DWORD EnablePrivilege(LPCTSTR pszPrivName, BOOL fEnable, BOOL *pfWasEnabled)
{
    LOG_Block("EnablePrivilege");
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hToken = 0;
    DWORD dwSize = 0;
    TOKEN_PRIVILEGES privNew;
    TOKEN_PRIVILEGES privOld;

    if(!OpenProcessToken(
                   GetCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &hToken))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    if(!LookupPrivilegeValue(
                   0,
                   pszPrivName,
                   &privNew.Privileges[0].Luid))
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    privNew.PrivilegeCount = 1;
    privNew.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;

    AdjustTokenPrivileges(
                   hToken,
                   FALSE,
                   &privNew,
                   sizeof(privOld),
                   &privOld,
                   &dwSize);
    //Always call GetLastError, even when we succeed (as per msdn)
    dwError = GetLastError();
    if(dwError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }
    if (pfWasEnabled)
    {
        *pfWasEnabled = (privOld.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED) ? TRUE : FALSE;
    }
    
Cleanup:
    SafeCloseHandle(hToken);
    return dwError;
}

/********************************************************************************
//Apply appropriate ACL's to the specified directory
********************************************************************************/
HRESULT SetDirPermissions(LPCTSTR lpszDir)
{
    LOG_Block("SetDirPermissions");
    DWORD dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pAdminSD = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    PACL pDacl = NULL;
    PSID pOwner = NULL;
    BOOL fIsDefault = FALSE;
    HMODULE hModule = NULL;
    TREERESETSECURITY pfnTreeResetSec = NULL;

    //Admin Security Descriptor String
    LPCTSTR pszAdminSD = _T("O:BAG:BAD:(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)");      
    
    //Security Descriptor String with correct ACLs for the WindowsUpdate Directory
    LPCTSTR pszSD = _T("D:")                    // DACL
                    _T("(A;OICI;GA;;;SY)")      // Allow SYSTEM full control
                    _T("(A;OICI;GA;;;BA)")      // Allow Admins full control
                    _T("(A;OICI;GA;;;CO)")      // Allow Owners full control
                    _T("(A;OICI;GRGWGX;;;PU)"); // Allow Power Users R/W/X control

    if(NULL == lpszDir)
    {
        return E_INVALIDARG;
    }
    
    //Create an admin SD from admin SD string
    if(!ConvertStringSecurityDescriptorToSecurityDescriptor(pszAdminSD, SDDL_REVISION_1, &pAdminSD, NULL))
    {
        dwErr = GetLastError();
        goto done;
    }

    //Get the owner SID from the Admin SD
    if(!GetSecurityDescriptorOwner(pAdminSD, &pOwner, &fIsDefault))
    {
        dwErr = GetLastError();
        goto done;
    }

    //Generate the Security Descriptor from the SD String with custom ACL's
    if(!ConvertStringSecurityDescriptorToSecurityDescriptor(pszSD, SDDL_REVISION_1, &pSD, NULL))
    {
        dwErr = GetLastError();
        goto done;
    }
    
    //Exctract the DACL from the Security Descriptor
    BOOL fIsDaclPresent = FALSE;
    if(!GetSecurityDescriptorDacl(
                                pSD,                // SD
                                &fIsDaclPresent,    // DACL presence
                                &pDacl,             // ACL
                                &fIsDefault))       // default DACL
    {

        dwErr = GetLastError();
        goto done;
    }
    //If for some reason no DACL was present, we have an invalid SD
    if(!fIsDaclPresent)
    {
        dwErr = ERROR_INVALID_SECURITY_DESCR;
        goto done;
    }

    //Load Advapi32.dll
    if ((NULL == (hModule = LoadLibraryFromSystemDir(_T("advapi32.dll")))) ||
        (NULL == (pfnTreeResetSec = (TREERESETSECURITY)::GetProcAddress(hModule, "TreeResetNamedSecurityInfo"))))
    {
        if(ERROR_SUCCESS != (dwErr = SetNamedSecurityInfo(
                                            (LPTSTR)lpszDir,
                                            SE_FILE_OBJECT,
                                            DACL_SECURITY_INFORMATION | 
                                            PROTECTED_DACL_SECURITY_INFORMATION |
                                            OWNER_SECURITY_INFORMATION,
                                            pOwner,
                                            NULL,
                                            pDacl,
                                            NULL)))
        {
            goto done;
        }
    }
    else
    {
        //Recursively apply the ownership and the ACL's on the tree
        if(ERROR_SUCCESS != (dwErr = pfnTreeResetSec(
                                                (LPTSTR)lpszDir,                            //Directory
                                                SE_FILE_OBJECT,                             //object type
                                                DACL_SECURITY_INFORMATION |                 //Set DACL
                                                PROTECTED_DACL_SECURITY_INFORMATION |       //Do not inherit
                                                OWNER_SECURITY_INFORMATION,                 //Set owner
                                                pOwner,                                     //Owner SID
                                                NULL,                                       //pGroup - null
                                                pDacl,                                      //Dacl to set
                                                NULL,                                       //pSacl - null
                                                FALSE,                                      //Retain explicitly added ACL's to children
                                                NULL,                                       //Callback function --- we dont need one
                                                ProgressInvokeNever,                        //Since we dont have a callback
                                                NULL)))                                     //Other args
        {
            goto done;
        }
    }

done:
    if ( NULL != hModule )
	{
		FreeLibrary(hModule);
	}
    SafeLocalFree(pSD);
    SafeLocalFree(pAdminSD);
    return HRESULT_FROM_WIN32(dwErr);
}

#endif

/*************************************************************************************************
//Rename the 'WindowsUpdate' file to 'WindowsUpdate.TickCount'; if rename fails we try to delete it
//Note that we wont revert the ownerhip of the file
**************************************************************************************************/
BOOL RenameWUFile(LPCTSTR lpszFilePath)
{
    LOG_Block("RenameWUFile");
    TCHAR szNewFilePath[MAX_PATH+1];
    DWORD dwTickCount = GetTickCount();
    LPTSTR szFormat = _T("%s.%lu");

    //Generate path to new file, should never fail
    if(SUCCEEDED(StringCchPrintfEx(szNewFilePath, ARRAYSIZE(szNewFilePath), NULL, NULL, MISTSAFE_STRING_FLAGS, szFormat, lpszFilePath, dwTickCount)) &&
        MoveFile(lpszFilePath, szNewFilePath) || 
        DeleteFile(lpszFilePath))
    {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\regutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RegUtil.CPP
//	Author:	Charles Ma, 10/20/2000
//
//	Revision History:
//
//
//
//
//  Description:
//
//      Implement IU registry accessing utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <logging.h>
#include <memutil.h>
#include <fileutil.h>
#include <stringutil.h>
#include <shlwapi.h>
#include "wusafefn.h"
#include <regutil.h>
#include<iucommon.h>
#include <MISTSAFE.h>

const int REG_BUF_SIZE = 1024;


const LPCTSTR REG_ROOTKEY_STR[7] = { 
	_T("HKEY_LOCAL_MACHINE"),
	_T("HKEY_CLASSES_ROOT"),
	_T("HKEY_CURRENT_USER"),
	_T("HKEY_CURRENT_CONFIG"),
	_T("HKEY_USERS"),
	_T("HKEY_PERFORMANCE_DATA"),	// NT only
	_T("HKEY_DYN_DATA")				// W9x only
};

const HKEY REG_ROOTKEY[7] = {
	HKEY_LOCAL_MACHINE,
	HKEY_CLASSES_ROOT,
	HKEY_CURRENT_USER,
	HKEY_CURRENT_CONFIG,
	HKEY_USERS,
	HKEY_PERFORMANCE_DATA,
	HKEY_DYN_DATA
};


typedef BOOL (WINAPI * PFN_StrToInt64Ex)(LPCTSTR pszString,
										 DWORD dwFlags,
										 LONGLONG * pllRet);



// ----------------------------------------------------------------------
//
// private function to split a full reg path into
// two parts: root key and subkey
//
// ----------------------------------------------------------------------
LPCTSTR SplitRegPath(LPCTSTR lpsRegPath, HKEY* phRootKey)
{
	LPTSTR lpSubKey = NULL;
	for (int i = 0; i < sizeof(REG_ROOTKEY)/sizeof(HKEY); i++)
	{
		if ((lpSubKey = StrStrI(lpsRegPath, REG_ROOTKEY_STR[i])) == lpsRegPath)
		{
			*phRootKey = REG_ROOTKEY[i];
			lpSubKey += lstrlen(REG_ROOTKEY_STR[i]);
			lpSubKey = CharNext(lpSubKey); // skip past "\", if any (or remain on NULL)
			return lpSubKey;
		}
	}
	//
	// if come to here, must be no right root key
	//
	*phRootKey = 0;
	return lpsRegPath;
}


// ----------------------------------------------------------------------
//
// public function to tell if a reg key exists
//
// ----------------------------------------------------------------------
BOOL RegKeyExists(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName		// optional value name
)
{
	LOG_Block("RegKeyExists()");

	HKEY hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL rc = FALSE;
	DWORD dwType = 0x0;

	if (NULL == lpsKeyPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s)"), lpsKeyPath, lpsValName);

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (hRootKey && ERROR_SUCCESS == RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey))
	{
		rc = (NULL == lpsValName) ||
			 (ERROR_SUCCESS == RegQueryValueEx(hKey, lpsValName, NULL, &dwType, NULL, NULL));
	}

	if (hKey)
	{
		RegCloseKey(hKey);
	}

	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));

	return rc;

}






// ----------------------------------------------------------------------
//
// public function to tell is a reg value in reg matches given value
//
// ----------------------------------------------------------------------
BOOL RegKeyValueMatch(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsValue		// value value
)
{
	LOG_Block("RegKeyValueMatch()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	LPCTSTR lpCurStr;
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	HRESULT hr=S_OK;

	USES_MY_MEMORY;

	if (NULL == lpsKeyPath || NULL == lpsValue)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		goto CleanUp;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s)"), lpsKeyPath, lpsValName, lpsValue);


	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize)))
		{
			goto CleanUp;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode)
	{
		goto CleanUp;
	}

	//
	// since the value to compare was read from XML doc, obviously only
	// the following 4 types possible to compare with
	//

	switch (dwType)
	{
	case REG_DWORD:
		{
			int x, y = *((int *) pBuffer);
			DWORD dwFlag = STIF_DEFAULT;
			//
			// check if the value from manifest is a hex value:
			// starts with x, or starts with 0x
			//
			LPCTSTR lpSecondChar  = lpsValue + 1;
			if (_T('0') == *lpsValue && (_T('x') == *lpSecondChar || _T('X') == *lpSecondChar))
			{
				dwFlag = STIF_SUPPORT_HEX;
			}

			if (StrToIntEx(lpsValue, dwFlag, &x))
			{
				rc = ( x == y);
			}
		}
		break;
	case REG_SZ:
	case REG_EXPAND_SZ:	// for mult-string, we only compair its first substring
		rc = (lstrcmpi((LPCTSTR)lpsValue, (LPCTSTR) pBuffer) == 0);
		if (!rc)
		{
			//
			// if the ressult is not equal, it's possibly caused by
			// path variables
			//
			// ASSUMPTION: these reg strings are for file path only, so we only
			// handle cases not longer than MAX_PATH.
			//
			TCHAR szRegStr[MAX_PATH], szValStr[MAX_PATH];

			if (dwSize >= MAX_PATH || lstrlen(lpsValue) >= MAX_PATH)
			{
				break;
			}

			if (SUCCEEDED(ExpandFilePath(lpsValue, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
			{
				//
				// if we can expand the given sub-string,
				// then try to expand the reg string if QueryRegValue says
				// this string is expandable. Otherwise, use the
				// string retrieved only.
				//
				if (REG_EXPAND_SZ == dwType)
				{
					ExpandFilePath((LPCTSTR)pBuffer, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0]));
				}
				else
				{
					
					
					hr=StringCchCopyEx(szRegStr,ARRAYSIZE(szRegStr),(LPTSTR) pBuffer,NULL,NULL,MISTSAFE_STRING_FLAGS);
					if(FAILED(hr)) break;

				}

				//
				// compare in expanded mode
				//
				rc = (lstrcmpi((LPCTSTR)szRegStr, szValStr) == 0);
			}
		}
		break;

	case REG_MULTI_SZ:
		{
			TCHAR szRegStr[MAX_PATH], szValStr[MAX_PATH];

			szValStr[0] = '\0';
			lpCurStr = (LPCTSTR)pBuffer;
			//
			// try to match each SZ in this multi sz.
			//
			do
			{
				//
				// see if the value contains the substring passed in
				//
				rc = (lstrcmpi((LPCTSTR)lpsValue, (LPCTSTR)pBuffer) == 0);

				//
				// if not found, it's possibly caused by
				// path variable or environment variable embedded
				//
				if (!rc && _T('\0') == szValStr[0])
				{
					if (FAILED(ExpandFilePath(lpsValue, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
					{
						szValStr[0] = '\0';
					}
				}

				//
				// compare expanded XML str with current reg str expanded
				// since this is REG_MULTI_SZ type, we have no way to tell
				// if this SZ inside MULTI_SZ is expandable or not, we
				// we will always try to expand it.
				//
				if (!rc && _T('\0') != szValStr[0])
				{
					rc = (SUCCEEDED(ExpandFilePath((LPCTSTR)lpCurStr, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0])))) &&
							 (lstrcmpi((LPCTSTR)szRegStr, szValStr) == 0);
				}

				if (!rc)
				{
					//
					// move to next string
					//
					lpCurStr += (lstrlen(lpCurStr) + 1);
					if (_T('\0') == *lpCurStr)
					{
						break;	// no more string to read
					}
				}
			} while (!rc); // repeat to next string

		}
		break;
	case REG_QWORD:
		{
			HMODULE hLib = LoadLibraryFromSystemDir(_T("Shlwapi.dll"));
			if (hLib)
			{
#if defined(UNICODE) || defined(_UNICODE)
				PFN_StrToInt64Ex pfnStrToInt64Ex = (PFN_StrToInt64Ex) GetProcAddress(hLib, "StrToInt64ExW");
#else
				PFN_StrToInt64Ex pfnStrToInt64Ex = (PFN_StrToInt64Ex) GetProcAddress(hLib, "StrToInt64ExA");
#endif
				if (pfnStrToInt64Ex)
				{
					LONGLONG llNum;
					rc = (pfnStrToInt64Ex((LPCTSTR)lpsValue, STIF_DEFAULT, &llNum) &&
						  (llNum == (LONGLONG)pBuffer));
				}
				FreeLibrary(hLib);
			} 
		}
		break;
		
	case REG_BINARY:
		rc = (CmpBinaryToString(pBuffer, dwSize, lpsValue) == 0);
		break;
	default:
		rc = FALSE;
	}

CleanUp:
	
	if (hKey)
	{
		RegCloseKey(hKey);
	}

	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));

	return rc;
}



// ----------------------------------------------------------------------
//
// public function to tell is a reg key has a string type value
// that contains given string
//
// ----------------------------------------------------------------------
BOOL RegKeySubstring(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsSubString	// substring to see if contained in value
)
{
	LOG_Block("RegKeySubstring()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	LPTSTR	lpCurStr = (LPTSTR) pBuffer;
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	TCHAR	szRegStr[MAX_PATH];
	TCHAR	szValStr[MAX_PATH];		// buffer for expanding

	USES_MY_MEMORY;

	if (NULL == lpsKeyPath || NULL == lpsSubString)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s)"), lpsKeyPath, lpsValName, lpsSubString);


	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize)))
		{
			goto CleanUp;
		}
		lpCurStr = (LPTSTR) pBuffer;
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType && REG_EXPAND_SZ != dwType && REG_MULTI_SZ != dwType)
	{
		goto CleanUp;
	}

	szValStr[0] = _T('\0');

	do
	{
		//
		// see if the value contains the substring passed in
		//
		rc = (StrStrI((LPCTSTR)lpCurStr, lpsSubString) != NULL);

		//
		// if not found, it's possibly caused by
		// path variable or environment variable embedded
		//
		if (!rc && _T('\0') == szValStr[0])
		{
			if (FAILED(ExpandFilePath(lpsSubString, szValStr, sizeof(szValStr)/sizeof(szValStr[0]))))
			{
				break;
			}
			rc = StrStrI((LPCTSTR)szRegStr, szValStr) != NULL;
		}

		if (!rc && _T('\0') != szValStr[0] && (REG_EXPAND_SZ == dwType ))
		{
			//
			// try to expand string from reg if this string is expandable
			//
			rc = (SUCCEEDED(ExpandFilePath((LPCTSTR)lpCurStr, szRegStr, sizeof(szRegStr)/sizeof(szRegStr[0])))) &&
					 (StrStrI((LPCTSTR)szRegStr, szValStr) != NULL);
		
		} // if not found

		if (!rc && REG_MULTI_SZ == dwType)
		{
			//
			// move to next string
			//
			lpCurStr += (lstrlen(lpCurStr) + 1);
			if (_T('\0') == *lpCurStr)
			{
				break;	// no more string to read
			}
		}
	} while (!rc && REG_MULTI_SZ == dwType); // repeat to next string if REG_MULTI_SZ

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));
	return rc;
}



// ----------------------------------------------------------------------
//
// public function to tell is a reg key has a string type value
// that contains given string
//
// since this is a comparision function, rather than to check existance,
// anything wrong to get the reg version will make the reg having default
// version: 0.0.0.0
//
// ----------------------------------------------------------------------
BOOL RegKeyVersion(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR lpsValName,		// optional value name
	LPCTSTR lpsVersion,		// version in string to compare
	_VER_STATUS CompareVerb	// how to compair
)
{
	LOG_Block("RegKeyVersion()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	FILE_VERSION verReg, verXml;
	int		verCompare;
	HRESULT hr=S_OK;

	USES_IU_CONVERSION;


	if (NULL == lpsKeyPath || NULL == lpsVersion)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	LOG_Out(_T("Parameters: (%s, %s, %s, %d)"), lpsKeyPath, lpsValName, lpsVersion, (int)CompareVerb);

	//
	// initialize the reg version string buffer
	//
	

	//The buffer size of btBuffer is sufficient to hold the source string
	if(FAILED(hr=StringCchCopyEx((LPTSTR)btBuffer,ARRAYSIZE(btBuffer)/sizeof(TCHAR),_T("0.0.0.0"),NULL,NULL,MISTSAFE_STRING_FLAGS)))
	{
		LOG_ErrorMsg(hr);
		return FALSE;

	}
	

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		// LOG_ErrorMsg(ERROR_BADKEY); don't log error since we don't know if this key HAS to be there or not
		goto GotVersion;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		pBuffer = (LPBYTE) MemAlloc(dwSize);
		if (NULL == pBuffer)
		{
			goto GotVersion;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType)
	{

			
			hr=StringCchCopyEx((LPTSTR)pBuffer,dwSize/sizeof(TCHAR),_T("0.0.0.0"),NULL,NULL,MISTSAFE_STRING_FLAGS);
			if(FAILED(hr))
			{
				LOG_ErrorMsg(hr);
				goto CleanUp;
			}

	}

GotVersion:

	//
	// convert the retrieved reg value to version
	//
	if (!ConvertStringVerToFileVer(T2CA((LPCTSTR) pBuffer), &verReg) ||
		!ConvertStringVerToFileVer(T2CA((LPCTSTR) lpsVersion), &verXml))
	{
		goto CleanUp;
	}

	//
	// maybe we successfully read data from reg, but that data can't be converted
	// into version at all. In this case, we still want to use the default version
	// for comparision
	//
	if (0 > verReg.Major)
	{
		verReg.Major = verReg.Minor = verReg.Build = verReg.Ext = 0;
	}

	//
	// compare version number. if a < b, -1; a > b, +1
	//
	verCompare = CompareFileVersion(verReg, verXml);
	switch (CompareVerb)
	{
	case DETX_LOWER:
        //
        // if reg key version less than XML version
        //
		rc = (verCompare < 0);
		break;
	case DETX_LOWER_OR_EQUAL:
        //
        // if reg key version less than  or equal to XML version
        //
		rc = (verCompare <= 0);
		break;
	case DETX_SAME:
        //
        // if reg key version same as XML version
        //
		rc = (0 == verCompare);
		break;
	case DETX_HIGHER_OR_EQUAL:
        //
        // if reg key version higher than  or equal to XML version
        //
		rc = (verCompare >= 0);
		break;
	case DETX_HIGHER:
        //
        // if reg key versiong higher than  XML version
        //
		rc = (verCompare > 0);
		break;
	default:
		//
		// should never happen
		//
		rc = FALSE;
		break;
	}

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	LOG_Out(_T("Result: %s"), rc ? _T("TRUE") : _T("FALSE"));
	return rc;
}




// ----------------------------------------------------------------------------------
//
// public function to find out the file path based on reg
//	assumption: 
//		lpsFilePath points to a buffer at least MAX_PATH long.
//
// ----------------------------------------------------------------------------------
BOOL GetFilePathFromReg(
	LPCTSTR lpsKeyPath,		// key path
	LPCTSTR	lpsValName,		// optional value name
	LPCTSTR	lpsRelativePath,// optional additonal relative path to add to path in reg
	LPCTSTR	lpsFileName,	// optional file name to append to path
	LPTSTR	lpsFilePath
)
{
	LOG_Block("GetFilePathFromReg()");

	HKEY	hRootKey = 0, hKey = 0;
	LPCTSTR lpsSubKey = NULL;
	BOOL	rc = FALSE;
	BYTE	btBuffer[REG_BUF_SIZE];
	LPBYTE	pBuffer = btBuffer;	
	DWORD	dwType = 0x0;
	DWORD	dwSize = sizeof(btBuffer);
	DWORD	dwCode = 0x0;
	FILE_VERSION verReg, verXml;
	int		verCompare;
	HRESULT hr=S_OK;

	USES_IU_CONVERSION;

	if (NULL == lpsKeyPath || NULL == lpsFilePath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	//
	// initialize file path
	//
	*lpsFilePath = '\0';

	LOG_Out(_T("Parameters: (%s, %s, %s, %s)"), lpsKeyPath, lpsValName, lpsRelativePath, lpsFileName);

	lpsSubKey = SplitRegPath(lpsKeyPath, &hRootKey);
	if (0 == hRootKey || (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, lpsSubKey, 0, KEY_QUERY_VALUE, &hKey)))
	{
		// LOG_ErrorMsg(ERROR_BADKEY); --- key probably not required to exist!
		goto CleanUp;
	}

	//
	// try to query the value with existing buffer.
	//
	dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, btBuffer, &dwSize);
	if (ERROR_MORE_DATA == dwCode)
	{
		//
		// if found the existing buffer not large enough, 
		// then allocate memory large enough to store the data now
		//
		if (NULL == (pBuffer = (LPBYTE) MemAlloc(dwSize + sizeof(TCHAR))))
		{
			goto CleanUp;
		}
		dwCode = RegQueryValueEx(hKey, lpsValName, NULL, &dwType, pBuffer, &dwSize);
	}

	if (ERROR_SUCCESS != dwCode || REG_SZ != dwType)
	{
		LOG_ErrorMsg(ERROR_BADKEY);
		goto CleanUp;
	}

	//
	// validate the to-be-combined path can fit into the buffer
	//
	if (lstrlen(lpsRelativePath) + lstrlen(lpsFileName) + dwSize/sizeof(TCHAR) >= MAX_PATH)
	{
		LOG_ErrorMsg(ERROR_BUFFER_OVERFLOW);
		goto CleanUp;
	}

	//
	// combile the path with optional relative path and file name
	//

	//The size of lpsFilePath is not available for using Safe String Functions

	
	hr=StringCchCopyEx(lpsFilePath,MAX_PATH,(LPCTSTR) pBuffer,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if ( SUCCEEDED(hr) && (NULL == lpsRelativePath || SUCCEEDED(PathCchAppend(lpsFilePath,MAX_PATH,lpsRelativePath)) ) && (NULL == lpsFileName || SUCCEEDED(PathCchAppend(lpsFilePath,MAX_PATH,lpsFileName)) ))
	{
		rc = TRUE;
	}

CleanUp:

	if (hKey)
	{
		RegCloseKey(hKey);
	}
	if (!rc)
	{
		//
		// make sure the buffer is set to empty string if error
		//
		*lpsFilePath = _T('\0');
	}
	else
	{
		LOG_Out(_T("Found path: %s"), lpsFilePath);
	}

	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\memutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   MemUtil.CPP
//	Author:	Charles Ma, 10/13/2000
//
//	Revision History:
//
//
//
//
//  Description:
//
//      Implement IU memory utility library
//
//=======================================================================

#include <windows.h>
#include <MemUtil.h>




// *******************************************************************************
//
//	Implementation of class CSmartHeapMem
//
// *******************************************************************************


const size_t ArrayGrowChunk = 4;

//
// constructor
//
CSmartHeapMem::CSmartHeapMem()
{
	m_ArraySize		= 0;
	m_lppMems		= NULL;
	m_Heap			= GetProcessHeap();
}



//
// desctructor
//
CSmartHeapMem::~CSmartHeapMem()
{
	if (NULL != m_Heap)
	{
		for (size_t i = 0; i < m_ArraySize; i++)
		{
			if (NULL != m_lppMems[i])
				HeapFree(m_Heap, 0, m_lppMems[i]);
		}
		HeapFree(m_Heap, 0, m_lppMems);
	}
}


//
// allocate mem
//
LPVOID CSmartHeapMem::Alloc(size_t nBytes, DWORD dwFlags /*= HEAP_ZERO_MEMORY*/)
{
	int		iNdx;
	LPVOID	pMem			= NULL;
	DWORD	dwBytes			= (DWORD) nBytes;
	DWORD	dwCurrentFlag	= dwFlags & (~HEAP_GENERATE_EXCEPTIONS | 
										 ~HEAP_NO_SERIALIZE);
	
	if (NULL == m_Heap || 0x0 == dwBytes)
	{
		return NULL;
	}

	iNdx = GetUnusedArraySlot();

	if (iNdx < 0 || NULL == m_Heap)
	{
		//
		// out of mem
		//
		return NULL;
	}

	
	pMem = m_lppMems[iNdx] = HeapAlloc(m_Heap, dwCurrentFlag, dwBytes);

	return pMem;
}



//
// reallocate mem
//
LPVOID CSmartHeapMem::ReAlloc(LPVOID lpMem, size_t nBytes, DWORD dwFlags)
{
	LPVOID	pMem			= NULL;
	DWORD	dwBytes			= (DWORD) nBytes;
	DWORD	dwCurrentFlag	= dwFlags & (~HEAP_GENERATE_EXCEPTIONS | 
										 ~HEAP_NO_SERIALIZE);
	int n;

	if (0x0 == dwBytes || NULL == m_Heap)
	{
		return NULL;
	}

	n = FindIndex(lpMem);
	if (n < 0)
	{
		return NULL;
	}

	pMem = HeapReAlloc(m_Heap, dwCurrentFlag, lpMem, dwBytes);
	if (NULL != pMem)
	{
		m_lppMems[n] = pMem;
	}

	return pMem;
}


//
// return the size allocated
//
size_t CSmartHeapMem::Size(LPVOID lpMem)
{
	if (NULL == m_Heap) return 0;
	return HeapSize(m_Heap, 0, lpMem);
}



void CSmartHeapMem::FreeAllocatedMem(LPVOID lpMem)
{
	int n = FindIndex(lpMem);
	if (n < 0 || NULL == m_Heap)
	{
		return;
	}
	HeapFree(m_Heap, 0, lpMem);
	m_lppMems[n] = NULL;
}



//
// get first empty slot from mem pointer array
// expand array if needed
//
int CSmartHeapMem::GetUnusedArraySlot()
{
	int iNdx = -1;
	UINT i;
	LPVOID lpCurrent;
	LPVOID lpTemp;

	if (0 == m_ArraySize)
	{
		if (NULL == (m_lppMems = (LPVOID*)HeapAlloc(
										m_Heap, 
										HEAP_ZERO_MEMORY, 
										ArrayGrowChunk * sizeof(LPVOID))))
		{
			return -1;
		}
		m_ArraySize = ArrayGrowChunk;
	}
	
		
	while (true)
	{
		for (i = 0; i < m_ArraySize; i++)
		{
			if (NULL == m_lppMems[i])
			{
				return i;
			}
		}
		
		//
		// if come to here, we didn't find an empty slot
		//
		if (NULL == (lpTemp = HeapReAlloc(
										m_Heap, 
										HEAP_ZERO_MEMORY, 
										m_lppMems, 
										(m_ArraySize + ArrayGrowChunk) * sizeof(LPVOID))))
		{
			//
			// when fail, original mem buffer pointed by m_lppMems untouched, 
			// we we simply return -1 to signal caller that no more free slots.
			//
			return -1;
		}

		//
		// when success, the mem pointers previously stored in m_lppMems already
		// been copied to lpTemp, and lppMems was freed.
		//

		//
		// assign the newly allocated mems to m_lppMems in success case
		//
		m_lppMems = (LPVOID *) lpTemp;

		m_ArraySize += ArrayGrowChunk;

		//
		// go back to loop again
		//
	}
}



//
// based on mem pointer, find index
//
int CSmartHeapMem::FindIndex(LPVOID pMem)
{
	if (NULL == pMem) return -1;
	for (size_t i = 0; i < m_ArraySize; i++)
	{
		if (pMem == m_lppMems[i]) return (int)i;
	}
	return -1;
}






// *******************************************************************************
//
//	Other memory related functions
//
// *******************************************************************************



//
// implemenation of CRT memcpy() function
//
LPVOID MyMemCpy(LPVOID dest, const LPVOID src, size_t nBytes)
{
	LPBYTE lpDest = (LPBYTE)dest;
	LPBYTE lpSrc = (LPBYTE)src;

	if (NULL == src || NULL == dest || src == dest)
	{
		return dest;
	}

	while (nBytes-- > 0)
	{
		*lpDest++ = *lpSrc++;
	}
	
	return dest;
}


//
// allocate heap mem and copy
//
LPVOID HeapAllocCopy(LPVOID src, size_t nBytes)
{
	LPVOID pBuffer;

	if (0 == nBytes)
	{
		return NULL;
	}
	
	pBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, nBytes);
	if (NULL != pBuffer)
	{
		MyMemCpy(pBuffer, src, nBytes);
	}
	return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\sources.inc ===
#
# Copyright (c) 2000	Microsoft Corporation
#
# Module Name:	util
#
# Abstract:		Various utilities for use by the IUEngine
#
MAJORCOMP=windows.com
MINORCOMP=lib.util

TARGETNAME=util
#TARGETPATH=$(IU_UTIL_LIB_DIR)
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=LIBRARY
UMTYPE=windows

#
# Compiler settings
#
# C_DEFINES=-D_USRDLL -D_ATL_MIN_CRT
# PRECOMPILED_CXX=1
# PRECOMPILED_OBJ=StdAfx.obj
# PRECOMPILED_INCLUDE=StdAfx.h
# USE_CRTDLL=1
# USE_LIBCMT=1
# USE_STL=1
# USE_MSVCRT=1
# USE_NATIVE_EH=1

CHICAGO_PRODUCT=1
#BROWSER_INFO=1

#
# we use try/catch for safearray, so we need this flag
#
# USER_C_FLAGS=/GX

INCLUDES= $(INCLUDES);$(BASEDIR)\public\sdk\inc\atl30;..\..\..\inc

SOURCES= \
	..\fileutil.cpp \
    ..\StringUtil.cpp \
	..\MemUtil.cpp  \
    ..\RegUtil.cpp  \
    ..\WaitUtil.cpp \
    ..\timeutil.cpp \
    ..\BinCompatible.cpp \
    ..\RedirectUtil.cpp \
    ..\EnsureACLs.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\redirectutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2001 Microsoft Corporation.  All Rights Reserved.
//
//  File:   RedirectUtil.cpp
//	Author:	Charles Ma, 9/19/2001
//
//	Revision History:
//
//
//
//  Description:
//
//      Helper function(s) for handling server redirect
//		Can be shared by IU control and other Windows Update components
//
//=======================================================================

#include <iucommon.h>
#include <logging.h>
#include <stringutil.h>
#include <fileutil.h>	// for using function GetIndustryUpdateDirectory()
#include <download.h>
#include <trust.h>
#include <memutil.h>

#include <wininet.h>	// for define of INTERNET_MAX_URL_LENGTH

#include <RedirectUtil.h>
#include <MISTSAFE.h>
#include <wusafefn.h>


const TCHAR IDENTNEWCABDIR[] = _T("temp");	// temp name for newly downloaded cab
													// we need to validate time before we take it as a good iuident.cab
const TCHAR IDENTCAB[] = _T("iuident.cab");
const TCHAR REDIRECT_SECTION[] = _T("redirect");


//
// private structure, which defines data used to 
// determine server redirect key
//
typedef struct OS_VER_FOR_REDIRECT 
{
	DWORD dwMajor;
	DWORD dwMinor;
	DWORD dwBuildNumber;
	DWORD dwSPMajor;
	DWORD dwSPMinor;
} OSVerForRedirect, *pOSVerForRedirect;

const OSVerForRedirect MAX_VERSION = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};



//-----------------------------------------------------------------------
//
// private helper function:
//	read data in string, convert it to structure
//	string ends with \0 or "-"
//
//-----------------------------------------------------------------------
HRESULT ConvertStrToOSVer(LPCTSTR pszVer, pOSVerForRedirect pOSVer)
{
	int Numbers[5] = {0, 0, 0, 0, 0}; // default version component val is 0
	int n = 0;

	if (NULL == pOSVer || NULL == pszVer)
	{
		return E_INVALIDARG;
	}

	//
	// recognizing numbers from string can be done in two ways:
	// 1. more acceptive: stop if known ending char, otherwise continue
	// 2. more rejective: stop if anything not known.
	// we use the first way
	//
	while ('\0' != *pszVer && 
		   _T('-') != *pszVer &&
		   _T('=') != *pszVer &&
		   n < sizeof(Numbers)/sizeof(int))
	{
		if (_T('.') == *pszVer)
		{
			n++;
		}
		else if (_T('0') <= *pszVer && *pszVer <= _T('9'))
		{
			//
			// if this is a digit, add to the current ver component
			//
			Numbers[n] = Numbers[n]*10 + (*pszVer - _T('0'));
		}
		// 
		// else - for any other chars, skip it and continue,
		// therefore we are using a very acceptive algorithm
		//

		pszVer++;
	}

	pOSVer->dwMajor = Numbers[0];
	pOSVer->dwMinor = Numbers[1];
	pOSVer->dwBuildNumber = Numbers[2];
	pOSVer->dwSPMajor = Numbers[3];
	pOSVer->dwSPMinor = Numbers[4];

	return S_OK;
}



//-----------------------------------------------------------------------
//
// Private helper function: retrieve version info from current OS
//
//-----------------------------------------------------------------------
HRESULT GetCurrentOSVerInfo(pOSVerForRedirect pOSVer)
{
	OSVERSIONINFO osVer;
	OSVERSIONINFOEX osVerEx;

	osVer.dwOSVersionInfoSize = sizeof(osVer);
	osVerEx.dwOSVersionInfoSize = sizeof(osVerEx);

	if (NULL == pOSVer)
	{
		return E_INVALIDARG;
	}

	//
	// first, get basic version info
	//
	if (0 == GetVersionEx(&osVer))
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	//
	// check what kinf of platform is this?
	//
	if (VER_PLATFORM_WIN32_WINDOWS == osVer.dwPlatformId || 
		(VER_PLATFORM_WIN32_NT == osVer.dwPlatformId && osVer.dwMajorVersion < 5) )
	{
		//
		// if this is Win9X or NT4 and below, then OSVERSIONINFO is the only thing we can get
		// unless we hard code all those SP strings here.
		// Since Windows Update team has no intention to set different site
		// for different releases and SPs of these down level OS, we simply put 0.0 for 
		// SP components.
		//
		osVerEx.dwMajorVersion = osVer.dwMajorVersion;
		osVerEx.dwMinorVersion = osVer.dwMinorVersion;
		osVerEx.dwBuildNumber = osVer.dwBuildNumber;
		osVerEx.wServicePackMajor = osVerEx.wServicePackMinor = 0x0;
	}
	else
	{
		//
		// for later OS, we can get OSVERSIONINFOEX data, which contains SP data
		//
		if (0 == GetVersionEx((LPOSVERSIONINFO)&osVerEx))
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	pOSVer->dwMajor = osVerEx.dwMajorVersion;
	pOSVer->dwMinor = osVerEx.dwMinorVersion;
	pOSVer->dwBuildNumber = osVerEx.dwBuildNumber;
	pOSVer->dwSPMajor = osVerEx.wServicePackMajor;
	pOSVer->dwSPMinor = osVerEx.wServicePackMinor;

	return S_OK;

}


//-----------------------------------------------------------------------
//
// Private helper function: to tell one given ver structure is between
// two known ver structures or not.
//
// when compare, pass all 3 structures in ptr. Any NULL ptr will return FALSE
//
//-----------------------------------------------------------------------
BOOL IsVerInRange(pOSVerForRedirect pVerToBeTested, 
				 const pOSVerForRedirect pVerRangeStart,
				 const pOSVerForRedirect pVerRangeEnd)
{
	if (NULL == pVerToBeTested || 
		NULL == pVerRangeStart ||
		NULL == pVerRangeEnd)
	{
		return FALSE;
	}

	return ((pVerRangeStart->dwMajor < pVerToBeTested->dwMajor &&		// if major in the range
			 pVerToBeTested->dwMajor < pVerRangeEnd->dwMajor) ||
			((pVerRangeStart->dwMajor == pVerToBeTested->dwMajor ||		// or major equal
			  pVerRangeEnd->dwMajor == pVerToBeTested->dwMajor) &&	
			  ((pVerRangeStart->dwMinor < pVerToBeTested->dwMinor &&	// and minor in the range 
			    pVerToBeTested->dwMinor < pVerRangeEnd->dwMinor) ||
			    ((pVerRangeStart->dwMinor == pVerToBeTested->dwMinor ||		// or minor equal too
			      pVerToBeTested->dwMinor == pVerRangeEnd->dwMinor) &&
			      ((pVerRangeStart->dwBuildNumber < pVerToBeTested->dwBuildNumber && // and build number in the range
			        pVerToBeTested->dwBuildNumber < pVerRangeEnd->dwBuildNumber) ||
			        ((pVerRangeStart->dwBuildNumber == pVerToBeTested->dwBuildNumber || // or build number equal too
			          pVerToBeTested->dwBuildNumber == pVerRangeEnd->dwBuildNumber) &&
			          ((pVerRangeStart->dwSPMajor < pVerToBeTested->dwSPMajor &&		// and service pack major within
			            pVerToBeTested->dwSPMajor < pVerRangeEnd->dwSPMajor) ||
			            ((pVerRangeStart->dwSPMajor == pVerToBeTested->dwSPMajor ||		// or spmajor equal too
			              pVerToBeTested->dwSPMajor == pVerRangeEnd->dwSPMajor) &&
			              ((pVerRangeStart->dwSPMinor <= pVerToBeTested->dwSPMinor &&	// and sp minor within
			                pVerToBeTested->dwSPMinor <= pVerRangeEnd->dwSPMinor) 
						  )
						)
					  )
					)
				  )
				)
			  )
			));

}


//-----------------------------------------------------------------------
// 
// GetRedirectServerUrl() 
//	Search the [redirect] section of the given init file for the base
//  server URL corresponding to the OS version.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		lpszNewUrl - point to a buffer to receive redirect server url, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no redirect server url defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		Section name: [redirect]
//		Its entries should be defined according to GetINIValueByOSVer().
// 
//-----------------------------------------------------------------------

HRESULT GetRedirectServerUrl(
			LPCTSTR pcszInitFile, // path of file name.
			LPTSTR lpszNewUrl,	// points to a buffer to receive new server url 
			int nBufSize		// size of buffer, in chars
)
{
	LOG_Block("GetRedirectServerUrl()");
	
	return GetINIValueByOSVer(
				pcszInitFile,
				REDIRECT_SECTION,
				lpszNewUrl,
				nBufSize);
}


//-----------------------------------------------------------------------
// 
// GetINIValueByOSVer() 
//	Search the specified section of the given init file for
//  the value corresponding to the version of the OS.
//
// Parameters:
//		pcszInitFile - file name (including path) of the ini file.
//						if this paramater is NULL or empty string,
//						then it's assumed IUident.txt file.
//		pcszSection - section name which the key is under
//		lpszValue - point to a buffer to receive the entry value, if found
//		nBufSize - size of pointed buffer, in number of chars
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - the redirect server url is found and been put into pszBuffer
//		S_FALSE - no value defined for this OS. 
//		other - error code
//
// Comments:
//		Expected section in IUIDENT has the following format;
//		this section contains zero or more entries, each entry has format:
//		<beginVersionRange>-<endVersionRange>=<redirect server url>
//		where:
//			<beginVersionRange> ::= <VersionRangeBound>
//			<endVersionRange> ::= <VersionRangeBound>
//			<VersionRangeBound> ::= EMPTY | Major[.Minor[.Build[.ServicePackMajor[.ServicePackMinor]]]]
//			<redirect server url>=http://blahblah....
//		an empty version range bound means boundless.
//		a missing version component at end of a version data string means default value 0.
//		(e.g., 5.2 = 5.2.0.0.0)
// 
//-----------------------------------------------------------------------

HRESULT GetINIValueByOSVer(
			LPCTSTR pcszInitFile, // path of file name.
			LPCTSTR pcszSection, // section name
			LPTSTR lpszValue,	// points to a buffer to receive new server url 
			int nBufSize)		// size of buffer, in chars
{
	LOG_Block("GetINIValueByOSVer");

	HRESULT hr = S_OK;
	TCHAR szInitFile[MAX_PATH];
	LPTSTR pszBuffer = NULL;
	LPTSTR pszCurrentChar = NULL;
	LPCTSTR pszDash = NULL;
	DWORD dwRet;
	DWORD dwSize = INTERNET_MAX_URL_LENGTH;
	
	if (NULL == pcszSection || NULL == lpszValue || nBufSize < 1)
	{
		return E_INVALIDARG;
	}


	OSVerForRedirect osCurrent, osBegin, osEnd;

	CleanUpIfFailedAndSetHrMsg(GetCurrentOSVerInfo(&osCurrent));

	pszBuffer = (LPTSTR) malloc(dwSize * sizeof(TCHAR));
	CleanUpFailedAllocSetHrMsg(pszBuffer);

	//
	// find out what's the right init file to search
	//
	if (NULL == pcszInitFile ||
		_T('\0') == *pcszInitFile)
	{
		//
		// if not specified, use iuident.txt
		//
		GetIndustryUpdateDirectory(pszBuffer);
        if (FAILED(hr=PathCchCombine(szInitFile,ARRAYSIZE(szInitFile), pszBuffer, IDENTTXT)) )
		{
			goto CleanUp;
		}
	}
	else
	{
		lstrcpyn(szInitFile, pcszInitFile, ARRAYSIZE(szInitFile));
	}

	LOG_Out(_T("Init file to retrieve redirect data: %s"), szInitFile);

	//
	// read in all key names
	//
	if (GetPrivateProfileString(
			pcszSection, 
			NULL, 
			_T(""), 
			pszBuffer, 
			dwSize, 
			szInitFile) == dwSize-2)
	{
		//
		// buffer too small? assume bad ident. stop here
		//
		hr = S_FALSE;
		goto CleanUp;
	}

	//
	// loop through each key
	//
	pszCurrentChar = pszBuffer;
	while (_T('\0') != *pszCurrentChar)
	{
		//
		// for the current key, we first try to make sure it's in the right format:
		// there should be a dash "-". If no, then assume this key is bad and we try to 
		// skip it.
		//
		pszDash = MyStrChr(pszCurrentChar, _T('-'));

		if (NULL != pszDash)
		{
			//
			// get lower bound of ver range. If string starts with "-",
			// then the returned ver would be 0.0.0.0.0
			//
			ConvertStrToOSVer(pszCurrentChar, &osBegin);

			//
			// get upper bound of ver range
			//
			pszDash++;
			ConvertStrToOSVer(pszDash, &osEnd);
			if (0x0 == osEnd.dwMajor &&
				0x0 == osEnd.dwMinor &&
				0x0 == osEnd.dwBuildNumber &&
				0x0 == osEnd.dwSPMajor && 
				0x0 == osEnd.dwSPMinor)
			{
				//
				// if 0.0.0.0.0. it means nothing after "-".
				// assume the upper bound is unlimited
				//
				osEnd = MAX_VERSION;
			}

			if (IsVerInRange(&osCurrent, &osBegin, &osEnd))
			{
				//
				// the current OS falls in this range.
				// we read the redirect URL
				//
				if (GetPrivateProfileString(
									pcszSection, 
									pszCurrentChar,		// use current str as key
									_T(""), 
									lpszValue, 
									nBufSize, 
									szInitFile) == nBufSize - 1)
				{
					Win32MsgSetHrGotoCleanup(ERROR_INSUFFICIENT_BUFFER);
				}

				hr = S_OK;
				goto CleanUp;
			}
		}

		//
		// move to next string
		//
		pszCurrentChar += lstrlen(pszCurrentChar) + 1;
	}

	//
	// if come to here, it means no suitable version range found.
	//
	*lpszValue = _T('\0');
	hr = S_FALSE;
	
CleanUp:
	SafeFree(pszBuffer);
	return hr;
}


//-----------------------------------------------------------------------
// 
// DownloadCab() 
//	download a cab file of specific name from a base web address.  The
//  file will be saved locally, with file trust verified and extracted to
//  a specific folder.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszCabName - the file name of the cab file (eg. iuident.cab)
//		ptszBaseUrl - the base web address to download the cab file
//		ptszExtractDir - the local dir to save the cab file and those extracted from it
//		dwFlags - the set of flags to be passed to DownloadFileLite()
//		fExtractFiles (default as TRUE) - extract files
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadCab(
			HANDLE hQuitEvent,
			LPCTSTR ptszCabName,
			LPCTSTR ptszBaseUrl,
			LPCTSTR ptszExtractDir,
			DWORD dwFlags,
			BOOL fExtractFiles)
{
	LOG_Block("DownloadCab");

    LPTSTR ptszFullCabUrl;

	if (NULL == ptszCabName ||
		NULL == ptszBaseUrl ||
		_T('\0') == *ptszBaseUrl ||
		NULL == ptszExtractDir ||
		_T('\0') == *ptszExtractDir)
	{
		return E_INVALIDARG;
	}

	if (NULL == (ptszFullCabUrl = (LPTSTR) malloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH)))
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = S_OK;
    TCHAR tszTarget[MAX_PATH+1];
	int nBaseUrlLen = lstrlen(ptszBaseUrl);

	if (SUCCEEDED(PathCchCombine(tszTarget,ARRAYSIZE(tszTarget),ptszExtractDir, ptszCabName)) &&
		INTERNET_MAX_URL_LENGTH > nBaseUrlLen)
	{
		
		hr=StringCchCopyEx(ptszFullCabUrl,INTERNET_MAX_URL_LENGTH,ptszBaseUrl,NULL,NULL,MISTSAFE_STRING_FLAGS);
		CleanUpIfFailedAndMsg(hr);


		if (_T('/') != ptszFullCabUrl[nBaseUrlLen-1])
		{
			ptszFullCabUrl[nBaseUrlLen++] = _T('/');
		}

		if (INTERNET_MAX_URL_LENGTH > nBaseUrlLen + lstrlen(ptszCabName))
		{
	
			//
			// changes made by charlma 4/24/2002: add a safegard:
			//
			// first, make sure that if the local file exist, then it must be trusted. Otherwise,
			// it will block the download if the size/timestamp match the server file.
			//
			if (FileExists(tszTarget))
			{
				hr = VerifyFileTrust(tszTarget, NULL, ReadWUPolicyShowTrustUI());
				if (FAILED(hr))
				{
					(void)DeleteFile(tszTarget);
				}
			}

			hr=StringCchCopyEx(ptszFullCabUrl+ nBaseUrlLen,INTERNET_MAX_URL_LENGTH-nBaseUrlLen,ptszCabName,NULL,NULL,MISTSAFE_STRING_FLAGS);
			CleanUpIfFailedAndMsg(hr);
	

//			if (SUCCEEDED(hr = DownloadFile(
//								ptszFullCabUrl,			// full http url
//								ptszBaseUrl,
//								tszTarget,		// optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
//								NULL,
//								&hQuitEvent,		// quit event
//								1,
//								NULL,
//								NULL,
//								dwFlags))) //dwFlags | WUDF_ALLOWWINHTTPONLY)))
			if (SUCCEEDED(hr = DownloadFileLite(
								ptszFullCabUrl,			// full http url
								tszTarget,		// optional local file name to rename the downloaded file to if pszLocalPath does not contain file name
								hQuitEvent,		// quit event
								dwFlags))) //dwFlags | WUDF_ALLOWWINHTTPONLY)))
			{
				// need to use the VerifyFile function, not CheckWinTrust (WU bug # 12251)
				if (SUCCEEDED(hr = VerifyFileTrust(tszTarget, NULL, ReadWUPolicyShowTrustUI())))
				{
					if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
					{
						hr = E_ABORT;
						LOG_ErrorMsg(hr);
					}
					else 
					{
						//
						// changed by charlma for bug 602435:
						// added new flag to tell if we should extract files. default as TRUE
						//
						if (fExtractFiles)
						{
							if (IUExtractFiles(tszTarget, ptszExtractDir))
							{
								hr = S_OK;
								if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
								{
									hr = E_ABORT;
									LOG_ErrorMsg(hr);
								}
							}
							else
							{
								hr = E_FAIL;
								LOG_Error(_T("failed to extract %s"), tszTarget);
							}
						}
					}
				}
				else
				{
					LOG_Error(_T("VerifyFileTrust(\"%s\", NULL, ReadWUPolicyShowTrustUI()) failed (%#lx)"), tszTarget, hr);
					DeleteFile(tszTarget);
				}
			}
#ifdef DBG
			else
			{
				LOG_Error(_T("DownloadFileLite(\"%s\", \"%s\", xxx, %#lx) failed (%#lx)."), ptszFullCabUrl, tszTarget, dwFlags, hr);
			}
#endif
		}
		else
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}
	else
	{
		hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}


CleanUp:

	free(ptszFullCabUrl);
    return hr;
}


//-----------------------------------------------------------------------
//
// ValidateNewlyDownloadedCab()
//
// This is a new helper function to validate the newly downloaded iuident.cab
// 
// Description:
//	The newly downloaded iuident.cab will be saved as IUIDENTNEWCAB
//	then this function will do the following validation:
//	(1) if local iuident.cab not exist, then the new one is valid
//	(2) otherwise, extract iuident.txt from both cabs, make sure
//		the one from new cab has later date then the one from existing cab.
//	(3) If not valid, then delete the new cab.
//
//	Return: 
//		S_OK: validated, existing cab been replaced with the new one
//		S_FALSE: not valid, new cab deleted. 
//		error: any error encountered during validation
//
//-----------------------------------------------------------------------
HRESULT ValidateNewlyDownloadedCab(LPCTSTR lpszNewIdentCab)
{
	HRESULT	hr = S_OK;
	BOOL	fRet;
	DWORD	dwErr;
	TCHAR	szExistingIdent[MAX_PATH + 1];
	TCHAR	szIUDir[MAX_PATH + 1];

	HANDLE	hFile = INVALID_HANDLE_VALUE;
	FILETIME ft1, ft2;
    ZeroMemory(&ft1, sizeof(ft1));
    ZeroMemory(&ft2, sizeof(ft2));

	LOG_Block("ValidateNewlyDownloadedCab()");

	if (NULL == lpszNewIdentCab)
	{
		hr = E_INVALIDARG;
		LOG_ErrorMsg(hr);
		return hr;
	}

	if (!FileExists(lpszNewIdentCab))
	{
		LOG_ErrorMsg(ERROR_PATH_NOT_FOUND);
		hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
		return hr;
	}

	//
	// create existing cab path
	//
	fRet = GetWUDirectory(szIUDir, ARRAYSIZE(szIUDir), TRUE);
	CleanUpIfFalseAndSetHrMsg(!fRet, HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND));

	hr = PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTCAB);
	CleanUpIfFailedAndMsg(hr);

	//
	// if original ident not exist, we will assume the new one is valid, 
	// since we don't have anything else to validate against!
	//
	if (!FileExists(szExistingIdent))
	{
		LOG_Internet(_T("%s not exist. Will use new cab"), szExistingIdent);
		hr = S_OK;
		goto CleanUp;
	}

	if (!IUExtractFiles(szExistingIdent, szIUDir, IDENTTXT))
	{
		LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s. Use new one"), GetLastError(), szExistingIdent);
		hr = S_OK;
		goto CleanUp;
	}

	//
	// get the time stamp from the extacted files: we borrow szExistingIdent buffer
	// to contstruct the file name of iuident.txt
	//
	hr = PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTTXT);
	CleanUpIfFailedAndMsg(hr);
	
	//
	// open file for retrieving modified time
	//
	hFile = CreateFile(szExistingIdent, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		LOG_ErrorMsg(GetLastError());
		hr = S_OK;	// use new cab
		goto CleanUp;
	}

	if (!GetFileTime(hFile, NULL, NULL, &ft1))
	{
		LOG_ErrorMsg(GetLastError());
		hr = S_OK;	// use new cab
		goto CleanUp;
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	DeleteFile(szExistingIdent);

	//
	// extract files from new cab
	//
	if (!IUExtractFiles(lpszNewIdentCab, szIUDir, IDENTTXT))
	{
		dwErr = GetLastError();
		LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s"), dwErr, lpszNewIdentCab);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	//
	// open file for retrieving modified time
	//
	hFile = CreateFile(szExistingIdent, GENERIC_READ, FILE_SHARE_READ, NULL, 
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	if (!GetFileTime(hFile, NULL, NULL, &ft2))
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		hr = HRESULT_FROM_WIN32(dwErr);
		goto CleanUp;
	}

	CloseHandle(hFile);
	hFile = INVALID_HANDLE_VALUE;

	DeleteFile(szExistingIdent);

	//
	// compare the two values: if ft2 (from new cab) is later than ft1 (from old cab)
	// then S_OK, otherwise, S_FALSE
	//
	hr = ((ft2.dwHighDateTime  > ft1.dwHighDateTime) ||
		  ((ft2.dwHighDateTime == ft1.dwHighDateTime) && 
		  (ft2.dwLowDateTime > ft1.dwLowDateTime))) 
		  ? S_OK : S_FALSE;


CleanUp:

	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
	}

	if (S_OK == hr)
	{
		//
		// validated. copy the new cab to existing cab name
		//
		(void)PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTCAB);
		if (CopyFile(lpszNewIdentCab, szExistingIdent, FALSE))
		{
			LOG_Internet(_T("New cab is better, copy to existing one, if any"));
		}
		else
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			hr = HRESULT_FROM_WIN32(dwErr);
		}
	}
	else
	{
		//
		// if not to use the new cab, we delete it.
		//
		LOG_Internet(_T("Error (0x%x) or new iuident.cab not better than old one."), hr);
		if ((ft2.dwHighDateTime != ft1.dwHighDateTime) || (ft2.dwLowDateTime != ft1.dwLowDateTime))
		{
			LOG_Internet(_T("Found bad iuident.cab downloaded! Try to delete it."));
			if (!DeleteFile(lpszNewIdentCab))
			{
				LOG_ErrorMsg(GetLastError());
			}
		}
	}

	//
	// clean up the extracted ident
	//
	if (SUCCEEDED(PathCchCombine(szExistingIdent, ARRAYSIZE(szExistingIdent), szIUDir, IDENTTXT)))
	{
		DeleteFile(szExistingIdent);
	}
	return hr;

}


//-----------------------------------------------------------------------
// 
// DownloadIUIdent() 
//	download iuident.cab from a specific location, if provided.
//	Otherwise get it from where the WUServer registry value points to.
//  Either case, it will handle ident redirection.
//
// Parameters:
//		hQuitEvent - the event handle to cancel this operation
//		ptszBaseUrl - the initial base URL for iuident.cab, must be no bigger than
//					  (INTERNET_MAX_URL_LENGTH) TCHARs.  Otherwise use
//					  WUServer entry from policy.  If entry not found,
//					  use "http://windowsupdate.microsoft.com/v4"
//		ptszFileCacheDir - the local base path to store the iuident.cab and
//						   the files extracted from it
//		dwFlags - the set of flags used by DownloadCab()
//		fIdentFromPolicy - tell if this is corpwu use. It has these impacts:
//					TRUE:	(1) no iuident.txt timestamp validation will be done by
//							comparing the newly downloaded cab and existing one.
//							(2) if download fail and ident cab exist and valid,
//							we will verify trust and extract iuident to use.
//					FALSE:	will validate newly downloaded cab against existing one
//
// Returns:
//		HRESULT about success or error of this action
//		S_OK - iuident.cab was successfully downloaded into the specified location
//		other - error code
//
//-----------------------------------------------------------------------

HRESULT DownloadIUIdent(
			HANDLE hQuitEvent,
			LPCTSTR ptszBaseUrl,
			LPTSTR ptszFileCacheDir,
			DWORD dwFlags,
			BOOL fIdentFromPolicy
			)
{
	LOG_Block("DownloadIUIdent");

	HRESULT hr = S_OK;
	TCHAR	tszTargetPath[MAX_PATH + 1];
	LPTSTR	ptszIdentBaseUrl = NULL;
	BOOL	fVerifyTempDir = TRUE;
	DWORD	dwErr = 0;

	USES_MY_MEMORY;

	if (NULL == ptszBaseUrl ||
		NULL == ptszFileCacheDir)
	{
		return E_INVALIDARG;
	}

	ptszIdentBaseUrl = (LPTSTR) MemAlloc(sizeof(TCHAR) * INTERNET_MAX_URL_LENGTH);
	CleanUpFailedAllocSetHrMsg(ptszIdentBaseUrl);

	hr = StringCchCopyEx(ptszIdentBaseUrl, INTERNET_MAX_URL_LENGTH, ptszBaseUrl, NULL,NULL,MISTSAFE_STRING_FLAGS);
	CleanUpIfFailedAndMsg(hr);

	int iRedirectCounter = 3;	// any non-negative value; to catch circular reference

	while (0 <= iRedirectCounter)
	{
		if (fIdentFromPolicy)
		{
			//
			// for corpwu case, always download it to overwrite the original
			// no iuident.txt timestamp validation needed.
			//
			hr = StringCchCopyEx(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, NULL,NULL,MISTSAFE_STRING_FLAGS);
			CleanUpIfFailedAndMsg(hr);
		}
		else
		{
			//
			// constrcut the temp local path for consumer case: download it to v4\temp
			//
			hr = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTNEWCABDIR);
			CleanUpIfFailedAndMsg(hr);
			if (fVerifyTempDir)
			{
				if (!CreateNestedDirectory(tszTargetPath))
				{
					dwErr = GetLastError();
					LOG_ErrorMsg(dwErr);
					hr = HRESULT_FROM_WIN32(dwErr);
					goto CleanUp;
				}
				fVerifyTempDir = FALSE;
			}
		}
			
		
		hr = DownloadCab(
						hQuitEvent,
						IDENTCAB,
						ptszIdentBaseUrl,
						tszTargetPath,
						dwFlags,
						FALSE);	// download cab without extracting it.

		if (FAILED(hr))
		{
			LOG_ErrorMsg(hr);

            // Bad Case, couldn't download the iuident.. iuident is needed for security..
#if defined(UNICODE) || defined(_UNICODE)
			LogError(hr, "Failed to download %ls from %ls to %ls", IDENTCAB, ptszIdentBaseUrl, tszTargetPath);
#else
			LogError(hr, "Failed to download %s from %s to %s", IDENTCAB, ptszIdentBaseUrl, tszTargetPath);
#endif
			//
			// construct original path. 
			//
			HRESULT hr1 = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTCAB);
			if (FAILED(hr1))
			{
				LOG_ErrorMsg(hr1);
				goto CleanUp;
			}

			if (fIdentFromPolicy && FileExists(tszTargetPath))
			{
				//
				// charlma: moved the fix from selfupd.cpp to here:
				//

				// bug 580808 CorpWU: IU: If corpwu server is not available when user navigates to web site, 
				// website displays x80072ee7 error and cannot be used.
				// Fix:
				// if corpwu policy is set but the corpwu server is unavailable,
				// we fail over to the local iuident.
				// This is true for both corpwu client and site client.
				hr = S_OK;
#if defined(DBG)
				LOG_Out(_T("Ignore above error, use local copy of %s from %s"), IDENTCAB, ptszFileCacheDir);
#endif
#if defined(UNICODE) || defined(_UNICODE)
				LogMessage("Ignore above error, use local copy of %ls from %ls", IDENTCAB, ptszFileCacheDir);
#else
				LogMessage("Ignore above error, use local copy of %s from %s", IDENTCAB, ptszFileCacheDir);
#endif
			}
			else
			{
				//
				// if this is the consumer case, or iuident.cab not exist, can't continue
				//
				break;
			}
		}
		else
		{
#if defined(UNICODE) || defined(_UNICODE)
			LogMessage("Downloaded %ls from %ls to %ls", IDENTCAB, ptszIdentBaseUrl, ptszFileCacheDir);
#else
			LogMessage("Downloaded %s from %s to %s", IDENTCAB, ptszIdentBaseUrl, ptszFileCacheDir);
#endif
			//
			// added by charlma for bug 602435 fix: verify the signed time stamp of
			// the downloaded cab is newer than the local one.
			//
			if (!fIdentFromPolicy)
			{
				//
				// if the newly downloaded cab is newer, and nothing bad happen (SUCCEEDED(hr)), we
				// we'll have an iuident.cab there, new or old.
				//
				(void) PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTNEWCABDIR);
				hr = PathCchAppend(tszTargetPath, ARRAYSIZE(tszTargetPath), IDENTCAB);
				CleanUpIfFailedAndMsg(hr);

				hr = ValidateNewlyDownloadedCab(tszTargetPath);

				if (FAILED(hr))
				{
					break;
				}

				//
				// if we need to use old one, it's fine. so we correct S_FALSE to S_OK;
				//
				hr = S_OK;

			}

			//
			// construct original path. we won't fail since we already tried IDENTNEWCAB on this buffer
			//
			(void)PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTCAB);

		}

		//
		// validat the iuidentcab trust
		//
		if (FAILED(hr = VerifyFileTrust(tszTargetPath, NULL, ReadWUPolicyShowTrustUI())))
		{
			//
			// alreaady logged by VerifyFileTrust(), so just bail out.
			//
			DeleteFile(tszTargetPath);
			goto CleanUp;
		}

		//
		// now, we have iuident.cab ready to use. extract the files
		//
		if (!IUExtractFiles(tszTargetPath, ptszFileCacheDir, IDENTTXT))
		{
			dwErr = GetLastError();
			LOG_Internet(_T("Error 0x%x when extracting ident.txt from %s"), dwErr, tszTargetPath);
			hr = HRESULT_FROM_WIN32(dwErr);
			goto CleanUp;
		}

		//
		// now we use tszTargetPath buffer to construct the iuident.txt file
		//
		hr = PathCchCombine(tszTargetPath, ARRAYSIZE(tszTargetPath), ptszFileCacheDir, IDENTTXT);
		CleanUpIfFailedAndMsg(hr);
	
		
		//
		// check to see if this OS needs redirect ident
		//
		if (FAILED(hr = GetRedirectServerUrl(tszTargetPath, ptszIdentBaseUrl, INTERNET_MAX_URL_LENGTH)))
		{
			LOG_Error(_T("GetRedirectServerUrl(%s, %s, ...) failed (%#lx)"), tszTargetPath, ptszIdentBaseUrl, hr);
			break;
		}

		if (S_FALSE == hr || _T('\0') == ptszIdentBaseUrl[0])
		{
			LOG_Out(_T("no more redirection"));
			hr = S_OK;
			break;
		}

		if (WAIT_TIMEOUT != WaitForSingleObject(hQuitEvent, 0))
		{
			hr = E_ABORT;
			LOG_ErrorMsg(hr);
			break;
		}

		//
		// this OS should be redirect to get new ident.
		//
		iRedirectCounter--;
	}
	if (0 > iRedirectCounter)
	{
		// possible circular reference
		hr = E_FAIL;
	}

CleanUp:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\urllogging\test\testisconnected.cpp ===
// testIsConnected.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <tchar.h>
#include <stdio.h>

#include <wininet.h>
#include <iphlpapi.h>
#include <winsock2.h>
#include <malloc.h>
#include <MemUtil.h>
#include <shlwapi.h>
#include <sensapi.h>

#include <URLLogging.h>
//#include "testSens.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))

#define INTERNET_RAS_INSTALLED              0x10
#define INTERNET_CONNECTION_OFFLINE         0x20
#define INTERNET_CONNECTION_CONFIGURED      0x40

//
// from winsock.dll (version 1.1 and up)
//
//typedef BOOL	(WINAPI * INETCONNECTSTATE)(LPDWORD, DWORD);
//typedef BOOL	(WINAPI * INETQUERYOPTION)(HINTERNET, DWORD, LPVOID, LPDWORD);
typedef int FAR	(WINAPI * WSASTARTUP)(WORD, LPWSADATA);
typedef int FAR	(WINAPI * WSACLEANUP)(void);
typedef int FAR	(WINAPI * WSAGETLASTERROR)(void);
typedef struct hostent FAR * (WINAPI * GETHOSTBYNAME)(const char FAR *);
typedef ULONG	(WINAPI * INET_ADDR)(const CHAR FAR *);
typedef char FAR *	(WINAPI * INET_NTOA)(struct in_addr);

//
// from iphlpapi.dll
//
typedef DWORD FAR	(WINAPI * GETBESTINTERFACE)(IPAddr, DWORD *);
typedef DWORD FAR	(WINAPI * GETINTERFACEINFO)(PIP_INTERFACE_INFO, PULONG);
typedef DWORD FAR	(WINAPI * GETIPFORWARDTABLE)(PMIB_IPFORWARDTABLE, PULONG, BOOL);
typedef DWORD FAR	(WINAPI * GETBESTROUTE)(IPAddr, IPAddr, PMIB_IPFORWARDROW);

//
// from sensapi.dll
//
typedef BOOL	(WINAPI * ISNETWORKALIVE)(LPDWORD);
typedef BOOL	(WINAPI * ISDESTINATIONREACHABLEA)(LPCSTR, LPQOCINFO);

CHAR szWU_PING_URL[] = "207.46.130.150"; // ip addr for windowsupdate.microsoft.com
//const TCHAR szWU_BASE_URL[] = _T("http://windowsupdate.microsoft.com");

BOOL g_fVerbose = FALSE;

HMODULE g_hIphlp = NULL;
HMODULE g_hSock = NULL;
HMODULE g_hSens = NULL;

// from winsock.dll (version 1.0 and up)
WSASTARTUP g_pfnWSAStartup = NULL;
WSACLEANUP g_pfnWSACleanup = NULL;
WSAGETLASTERROR g_pfnWSAGetLastError = NULL;
GETHOSTBYNAME g_pfn_gethostbyname = NULL;
INET_NTOA g_pfn_inet_ntoa = NULL;
INET_ADDR g_pfn_inet_addr = NULL;

// from iphlpapi.dll
GETINTERFACEINFO g_pfnGetInterfaceInfo = NULL;
GETIPFORWARDTABLE g_pfnGetIpForwardTable = NULL;
GETBESTINTERFACE g_pfnGetBestInterface = NULL;
GETBESTROUTE g_pfnGetBestRoute = NULL;

// from sensapi.dll
ISNETWORKALIVE g_pfnIsNetworkAlive = NULL;
ISDESTINATIONREACHABLEA g_pfnIsDestinationReachableA = NULL;

void printBestRoute(MIB_IPFORWARDROW & bestRoute)
{
	CHAR szForwardDest[15 + 1];
	CHAR szForwardMask[15 + 1];
	CHAR szForwardNextHop[15 + 1];
	struct in_addr in;

	in.s_addr = bestRoute.dwForwardDest;
	lstrcpyA(szForwardDest, g_pfn_inet_ntoa(in));
	in.s_addr = bestRoute.dwForwardMask;
	lstrcpyA(szForwardMask, g_pfn_inet_ntoa(in));
	in.s_addr = bestRoute.dwForwardNextHop;
	lstrcpyA(szForwardNextHop, g_pfn_inet_ntoa(in));
	printf("\tdest\t= %s\n\tmask\t= %s\n\tgateway\t= %s\n\tifindex\t= %d\n\ttype\t= %d\n\tproto\t= %d\n\tage\t= %d\n",
		szForwardDest,
		szForwardMask,
		szForwardNextHop,
		bestRoute.dwForwardIfIndex,
		bestRoute.dwForwardType,
		bestRoute.dwForwardProto,
		bestRoute.dwForwardAge);
}


BOOL MyIsConnected(WORD wVersion, LPCTSTR ptszUrl, BOOL fLive)
{
    BOOL bRet = FALSE;
    DWORD dwErr;

	LPTSTR ptszHostName = NULL;
/*
	if (0x3 == wVersion)
	{
		printf("Sleeping 20 seconds...\n");
		Sleep(20000);
		return g_fConnected;
	}
*/
	if (0x1 == wVersion)
	{
		// Test latest behavior
		return IsConnected(ptszUrl, fLive);
	}

	DWORD dwConnMethod = 0;

	if (0x200 == wVersion || 0x202 == wVersion)
	{
		if (bRet = InternetGetConnectedState(&dwConnMethod, 0))
		{
			// modem is dialing
			if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY)
			{
				bRet = FALSE;
				goto lFinish;
			}

			// check if there is a proxy but currently user is offline
			if (dwConnMethod & INTERNET_CONNECTION_PROXY)
			{
				DWORD dwState = 0;
				DWORD dwSize = sizeof(DWORD);

				if (!InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
				{
					printf("IsConnected(): InternetQueryOptionA failed with error %d\n", GetLastError());
				}

				if (dwState & (INTERNET_STATE_DISCONNECTED_BY_USER | INTERNET_STATE_DISCONNECTED))
				{
					bRet = FALSE;
					goto lFinish;
				}
			}
		}
		else
		{
			//
			// further test the case that user didn't run icw but is using a modem connection
			//
			const DWORD dwModemConn = (INTERNET_CONNECTION_MODEM | INTERNET_CONNECTION_MODEM_BUSY);
			if ((dwConnMethod & dwModemConn) == dwModemConn)
			{
				bRet = TRUE;
			}
		}
	}
	else
	{
		DWORD dwFlags;

		bRet = g_pfnIsNetworkAlive(&dwFlags);
	}

    //one final check for connectivity by pinging microsoft.com
    //if (bRet)
    //{
    //  bRet = CheckByPing(szURL);
    //}
    //bugfix for InternetGetConnectedState API - if LAN card is disabled it still returns LAN connection
    //use GetBestInterface and see if there is any error trying to reach an outside IP address
    //this may fix scenarios in homelan case where there is no actual connection to internet??
    if (((0x0200 == wVersion || 0x0202 == wVersion) &&
		 (!bRet || (dwConnMethod & INTERNET_CONNECTION_LAN))) ||  //LAN card present
		//bug 299338
		(0x0 == wVersion && bRet))
    {
		IPAddr dest = INADDR_NONE;

		if (0x0200 == wVersion)
		{
			if (INADDR_NONE == (dest = g_pfn_inet_addr(szWU_PING_URL)))
			{
				printf("inet_addr(\"%s\") failed\n", szWU_PING_URL);
			}
		}
		else
		{
			if (NULL != ptszUrl && _T('\0') != ptszUrl[0])
			{
				const TCHAR c_tszHttpScheme[] = _T("http://");

				if (0 == _tcsncmp(ptszUrl, c_tszHttpScheme, ARRAYSIZE(c_tszHttpScheme) - 1))
				{
					ptszUrl += ARRAYSIZE(c_tszHttpScheme) - 1;	// skip http://
				}
				LPCTSTR ptszDelim = _tcschr(ptszUrl, _T('/'));
				if (NULL == ptszDelim)
				{
					ptszDelim = ptszUrl + lstrlen(ptszUrl);
				}

				if (NULL != (ptszHostName = (LPTSTR) malloc(sizeof(TCHAR) * (ptszDelim - ptszUrl + 1))))
				{
					lstrcpyn(ptszHostName, ptszUrl, ((int) (ptszDelim - ptszUrl)) + 1);

					USES_IU_CONVERSION;

					LPSTR pszHostName = T2A(ptszHostName);

					if (0x0 != wVersion || INADDR_NONE == (dest = g_pfn_inet_addr(pszHostName)))
					{
						if (g_fVerbose)
						{
							printf("Resolving domain name for %s...\n", pszHostName);
						}

						int iErr = 0;

						if (0x0 == wVersion)
						{
							WSADATA wsaData;

							if (0 == (iErr = g_pfnWSAStartup(MAKEWORD(1, 1), &wsaData)))
							{
								if (g_fVerbose)
								{
									printf("WSAStartup() succeeded, wVersion = %d.%d, wHighVersion = %d.%d\n",
											LOBYTE(wsaData.wVersion),
											HIBYTE(wsaData.wVersion),
											LOBYTE(wsaData.wHighVersion),
											HIBYTE(wsaData.wHighVersion));
								}
							}
							else
							{
								/* Tell the user that we could not find a usable */
								/* WinSock DLL.                                  */
								printf("IsConnected(): WSAStartup() failed with error %d\n", iErr);
							}
						}

						if (0 == iErr)
						{
							DWORD dwTimeEllapsed = GetTickCount();

							struct hostent *ptHost = g_pfn_gethostbyname(pszHostName);

							dwTimeEllapsed = GetTickCount() - dwTimeEllapsed;

							if (NULL == ptHost)
							{
								dwErr = g_pfnWSAGetLastError();
								printf("IsConnected(): gethostbyname(\"%s\") failed with error WSABASEERR+%d (%d), took %d msecs\n", pszHostName, dwErr - WSABASEERR, dwErr, dwTimeEllapsed);

								if (0x0 == wVersion)
								{
									bRet = FALSE;
								}
							}
							else if (AF_INET == ptHost->h_addrtype &&
									 sizeof(IPAddr) == ptHost->h_length &&
									 NULL != ptHost->h_addr_list &&
									 NULL != *ptHost->h_addr_list)
							{
								dest = *((IPAddr FAR *) ptHost->h_addr);

								if (g_fVerbose)
								{
									printf("Host name %s resolved to be ", pszHostName);

									for (IPAddr FAR * FAR * ppAddresses = (IPAddr FAR * FAR *) ptHost->h_addr_list;
										 *ppAddresses != NULL;
										ppAddresses++)
									{
										struct in_addr in;

										in.s_addr = **ppAddresses;
										printf("%s, ", g_pfn_inet_ntoa(in));
									}
									printf("took %d msecs\n", dwTimeEllapsed);
								}
							}
							else
							{
								printf("IsConnected(): gethostbyname(\"%s\") returns invalid host entry\n", pszHostName);
							}

							if (0x0 == wVersion)
							{
								if (iErr = g_pfnWSACleanup())
								{
									printf("IsConnected(): WSACleanup() failed with error %d\n", iErr);
								}
								else if (g_fVerbose)
								{
									printf("WSACleanup() succeeded\n");
								}
							}
						}
					}
				}
				else
				{
					printf("IsConnected(): call to malloc() failed\n");
				}
			}
		}

		if (INADDR_NONE != dest)
		{
			DWORD dwIndex;
			struct in_addr in;

			in.s_addr = dest;

			if (bRet = (NO_ERROR == (dwErr = g_pfnGetBestInterface(dest, &dwIndex))))
			{
				if (g_fVerbose)
				{
					printf("GetBestInterface(%s) succeeded, dwIndex = %d\n", g_pfn_inet_ntoa(in), dwIndex);
				}
			}
			else
			{
				printf("IsConnected(): GetBestInterface(%s) failed w/ error %d\n", g_pfn_inet_ntoa(in), dwErr);
			}
		}
    }

lFinish:
	if (NULL != ptszHostName)
	{
		free(ptszHostName);
	}

    printf(bRet ? "Connected\n" : "Not connected\n");
    return (bRet);
}


void runApiTests(LPSTR pszURL)
{
	if (!g_fVerbose)
	{
		return;
	}

	DWORD dwFlags;

	if (g_pfnIsNetworkAlive(&dwFlags))
	{
		printf("IsNetworkAlive(&dwFlags) returns TRUE, dwFlags = %#lx\n", dwFlags);
		if (dwFlags & NETWORK_ALIVE_LAN)
		{
			printf("\t%s\n", "NETWORK_ALIVE_LAN");
		}
		if (dwFlags & NETWORK_ALIVE_WAN)
		{
			printf("\t%s\n", "NETWORK_ALIVE_WAN");
		}
		if (dwFlags & NETWORK_ALIVE_AOL)
		{
			printf("\t%s\n", "NETWORK_ALIVE_AOL");
		}
	}
	else
	{
		printf("runApiTests(): IsNetworkAlive(&dwFlags) failed with error %d\n", GetLastError());
	}

	printf("Checking destination reachability for %s...\n", pszURL);
	if (g_pfnIsDestinationReachableA(pszURL, NULL))
	{
		printf("IsDestinationReachableA(\"%s\", NULL) returns TRUE\n", pszURL);
	}
	else
	{
		printf("runApiTests(): IsDestinationReachableA(\"%s\", NULL) failed with error %d\n", pszURL, GetLastError());
	}
	printf("\n");

	PMIB_IPFORWARDTABLE pIpForwardTable = NULL;
	PIP_INTERFACE_INFO pIfTable = NULL;
	DWORD dwOutBufLen = 0;
	DWORD dwErr;

	switch(dwErr = g_pfnGetInterfaceInfo(pIfTable, &dwOutBufLen))
	{
	case NO_ERROR:
		printf("runApiTests(): GetInterfaceInfo() returns NO_ERROR with no buffer?\n");
		break;

	case ERROR_INSUFFICIENT_BUFFER:
		if (NULL == (pIfTable = (PIP_INTERFACE_INFO) malloc(dwOutBufLen)))
		{
			printf("IsConnected(): call to malloc() failed\n");
		}
		else
		{
			if (NO_ERROR != (dwErr = g_pfnGetInterfaceInfo(pIfTable, &dwOutBufLen)))
			{
				printf("runApiTests(): GetInterfaceInfo() failed with error %d\n", dwErr);
			}
			else
			{
				if (0 != pIfTable->NumAdapters)
				{
					for (int i=0; i<pIfTable->NumAdapters; i++)
					{
						printf("Network interface #%d = %ls\n", pIfTable->Adapter[i].Index, pIfTable->Adapter[i].Name);
					}
				}
				else
				{
					printf("There is no network interface on this machine.\n");
				}
				printf("\n");
			}

			free(pIfTable);
		}
		break;

	default:
		printf("runApiTests(): GetInterfaceInfo() failed with error %d\n", dwErr);
		break;
	}

	// Find out how big our buffer needs to be
	DWORD dwSize = 0;

	if (ERROR_INSUFFICIENT_BUFFER == (dwErr = g_pfnGetIpForwardTable(pIpForwardTable, &dwSize, TRUE)))
	{
		// Allocate the memory for the table
		if (NULL != (pIpForwardTable = (PMIB_IPFORWARDTABLE) malloc(dwSize)))
		{
			// Now get the table
			dwErr = g_pfnGetIpForwardTable(pIpForwardTable, &dwSize, TRUE);
		}
		else
		{
			printf("runApiTests(): call to malloc() failed\n");
		}
	}

	if (NO_ERROR == dwErr)
	{
		if (0 != pIpForwardTable->dwNumEntries)
		{
			printf("%-15.15s\t%-15.15s\t%-15.15s\t%s\t%s\t%s\t%s\n",
				"Destination",
				"Network Mask",
				"Gateway",
				"IfIndex",
				"Type",
				"Proto",
				"Age");
			printf("===============================================================================\n");
			for (DWORD i=0; i < pIpForwardTable->dwNumEntries; i++)
			{
				PMIB_IPFORWARDROW pRow = &(pIpForwardTable->table[i]);

				CHAR szForwardDest[15 + 1];
				CHAR szForwardMask[15 + 1];
				CHAR szForwardNextHop[15 + 1];
				struct in_addr in;

				in.s_addr = pRow->dwForwardDest;
				lstrcpyA(szForwardDest, g_pfn_inet_ntoa(in));
				in.s_addr = pRow->dwForwardMask;
				lstrcpyA(szForwardMask, g_pfn_inet_ntoa(in));
				in.s_addr = pRow->dwForwardNextHop;
				lstrcpyA(szForwardNextHop, g_pfn_inet_ntoa(in));
				printf("%15.15s\t%15.15s\t%15.15s\t%d\t%d\t%d\t%d\n",
					szForwardDest,
					szForwardMask,
					szForwardNextHop,
					pRow->dwForwardIfIndex,
					pRow->dwForwardType,
					pRow->dwForwardProto,
					pRow->dwForwardAge);
			}
		}
		else
		{
			printf("There is no entry in the routing table.\n");
		}
		printf("\n");
	}
	else
	{
		printf("runApiTests(): GetIpForwardTable() failed w/ error %d\n", dwErr);
	}

	DWORD dwConnMethod = 0;

	if (InternetGetConnectedState(&dwConnMethod, 0))
	{
		printf("InternetGetConnectedState(&dwConnMethod) returns TRUE, dwConnMethod = %#lx\n", dwConnMethod);
	}
	else
	{
		printf("InternetGetConnectedState(&dwConnMethod) returns FALSE\n");
	}
	if (dwConnMethod & INTERNET_CONNECTION_MODEM)
	{
		printf("\t%s\n", "INTERNET_CONNECTION_MODEM");
	}
	if (dwConnMethod & INTERNET_CONNECTION_LAN )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_LAN");
	}
	if (dwConnMethod & INTERNET_CONNECTION_PROXY )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_PROXY");
	}
	if (dwConnMethod & INTERNET_CONNECTION_MODEM_BUSY )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_MODEM_BUSY");
	}
	if (dwConnMethod & INTERNET_RAS_INSTALLED )
	{
		printf("\t%s\n", "INTERNET_RAS_INSTALLED");
	}
	if (dwConnMethod & INTERNET_CONNECTION_OFFLINE )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_OFFLINE");
	}
	if (dwConnMethod & INTERNET_CONNECTION_CONFIGURED )
	{
		printf("\t%s\n", "INTERNET_CONNECTION_CONFIGURED");
	}
	printf("\n");

	DWORD dwState = 0;

	dwSize = sizeof(DWORD);
    if (InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize))
    {
		printf("InternetQueryOptionA(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState, &dwSize) returns TRUE, dwState = %#lx\n", dwState);
		if (dwState & INTERNET_STATE_CONNECTED)
		{
			printf("\t%s\n", "INTERNET_STATE_CONNECTED - connected state (mutually exclusive with disconnected)");
		}
		if (dwState & INTERNET_STATE_DISCONNECTED)
		{
			printf("\t%s\n", "INTERNET_STATE_DISCONNECTED - disconnected from network");
		}
		if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
		{
			printf("\t%s\n", "INTERNET_STATE_DISCONNECTED_BY_USER - disconnected by user request");
		}
		if (dwState & INTERNET_STATE_IDLE)
		{
			printf("\t%s\n", "INTERNET_STATE_IDLE - no network requests being made (by Wininet)");
		}
		if (dwState & INTERNET_STATE_BUSY)
		{
			printf("\t%s\n", "INTERNET_STATE_BUSY - network requests being made (by Wininet)");
		}
    }
    else
    {
        printf("IsConnected(): InternetQueryOptionA failed with error %d\n", GetLastError());
    }
	printf("\n");

	if (NULL != pIpForwardTable)
	{
		free(pIpForwardTable);
	}
}


void runTest(WORD wVersion, LPSTR pszURL, BOOL fLive)
{
	CHAR szVersion[50];
	HRESULT hr;
	BOOL fCoInit = FALSE;

	switch (wVersion)
	{
	case 0x0200:
	case 0x0202:
		sprintf(szVersion, "from AU %d.%d", HIBYTE(wVersion), LOBYTE(wVersion));
		break;
	case 0x0:
		sprintf(szVersion, "(bug fix candidate)");
		break;
	case 0x1:
		sprintf(szVersion, "(latest code)");
		break;
/*
	case 0x3:
		sprintf(szVersion, "(SENS test)");
		if (fCoInit = FAILED(hr = CoInitialize(NULL)))
		{
			printf("runTest(): CoInitialize(NULL) failed w/ error %#lx\n", hr);
			goto CleanUp;
		}
		if (g_fVerbose)
		{
			printf("runTest(): CoInitialize(NULL) succeeded\n");
		}
		if (FAILED(hr = ActivateSensNetworkNotification()))
		{
			printf("runTest(): ActivateSensNetworkNotification() failed w/ error %#lx\n", hr);
			goto CleanUp;
		}
		if (g_fVerbose)
		{
			printf("runTest(): ActivateSensNetworkNotification() succeeded\n");
		}
		break;
*/
	default:
		printf("runTest(): unknown wVersion\n");
		goto CleanUp;
	}

	printf("Testing connection detection/server reachability algorithm %s...\n", szVersion);

	{
		USES_IU_CONVERSION;

		LPTSTR ptszURL = A2T(0x0200 == wVersion ? szWU_PING_URL : pszURL);

		_tprintf(_T("IsConnected(\"%s\") returns %s\n"), ptszURL, MyIsConnected(wVersion, ptszURL, fLive) ? _T("TRUE") : _T("FALSE"));
	}

/*
	if (0x3 == wVersion)
	{
		if (FAILED(hr = DeactivateSensNetworkNotification()))
		{
			printf("runTest(): DeactivateSensNetworkNotification() failed w/ error %#lx\n", hr);
		}
		else if (g_fVerbose)
		{
			printf("runTest(): DeactivateSensNetworkNotification() succeeded\n");
		}
	}
*/

CleanUp:
	if (fCoInit)
	{
		CoUninitialize();
	}
}

int __cdecl main(int argc, char* argv[])
{
	char c_szMethodToken[] = "/method:";
	char c_szMToken[] = "/m:";
	char c_szVerboseToken[] = "/verbose";
	char c_szVToken[] = "/v";
	char c_szCorpToken[] = "/corpwu";
	char c_szLiveToken[] = "/live";
	int fLive = -1;

	WORD wVersion = 0xffff;	// default == unknown;
	LPSTR pszURL = NULL;

	int index = 0;

	while (index < argc - 1)
	{
		LPSTR psz = NULL;

		index++;

		if (0 == StrCmpNIA(argv[index], c_szMethodToken, ARRAYSIZE(c_szMethodToken) - 1))
		{
			psz = argv[index] + ARRAYSIZE(c_szMethodToken) - 1;
		}
		else if (0 == StrCmpNIA(argv[index], c_szMToken, ARRAYSIZE(c_szMToken) - 1))
		{
			psz = argv[index] + ARRAYSIZE(c_szMToken) - 1;
		}

		if (NULL != psz)
		{
			if (0xffff != wVersion)
			{
				// param specified twice
				goto Usage;
			}

			char c_szOptionCode[] = "code";
			char c_szOptionFix[] = "fix";
			char c_szOptionAll[] = "all";
			char c_szOptionSens[] = "sens";
			int iMajorVersion = 0, iMinorVersion = 0;

			if (2 != sscanf(psz, "%d.%d", &iMajorVersion, &iMinorVersion))
			{
				if (0 == StrCmpNIA(psz, c_szOptionCode, ARRAYSIZE(c_szOptionCode)))
				{
					iMajorVersion = 0;
					iMinorVersion = 1;
				}
				else if (0 == StrCmpNIA(psz, c_szOptionFix, ARRAYSIZE(c_szOptionFix)))
				{
					iMajorVersion = iMinorVersion = 0;
				}
				else if (0 == StrCmpNIA(psz, c_szOptionAll, ARRAYSIZE(c_szOptionAll)))
				{
					iMajorVersion = 0xff;
					iMinorVersion = 0xfe;
				}
/*
				else if (0 == StrCmpNIA(psz, c_szOptionSens, ARRAYSIZE(c_szOptionSens)))
				{
					iMajorVersion = 0;
					iMinorVersion = 3;
				}
*/
				else
				{
					goto Usage;
				}
			}
			wVersion = MAKEWORD(iMinorVersion, iMajorVersion);
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szVerboseToken, ARRAYSIZE(c_szVerboseToken)) ||
			0 == StrCmpNIA(argv[index], c_szVToken, ARRAYSIZE(c_szVToken)))
		{
			if (g_fVerbose)
			{
				// param specified twice
				goto Usage;
			}

			g_fVerbose = TRUE;
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szLiveToken, ARRAYSIZE(c_szLiveToken)))
		{
			if (-1 != fLive)
			{
				// param specified twice or conflicting param
				goto Usage;
			}

			fLive = 1;
			continue;
		}

		if (0 == StrCmpNIA(argv[index], c_szCorpToken, ARRAYSIZE(c_szCorpToken)))
		{
			if (-1 != fLive)
			{
				// param specified twice or conflicting param
				goto Usage;
			}

			fLive = 0;
			continue;
		}

		if ('/' != *argv[index])
		{
			if (NULL != pszURL)
			{
				// param specified twice
				goto Usage;
			}

			pszURL = argv[index];
			continue;
		}

		// unknown param
		goto Usage;
	}

	switch (wVersion)
	{
	case 0x0200:
		if (NULL != pszURL)
		{
			goto Usage;
		}
		break;
	case 0x0202:
	case 0x0:
	case 0x1:
//	case 0x3:
	case 0xfffe:
		if (NULL == pszURL)
		{
			goto Usage;
		}
		break;
	default:
		goto Usage;
	}

	if (-1 == fLive)
	{
		fLive = 1;
	}

	if ((NULL == g_hIphlp && NULL == (g_hIphlp = LoadLibrary(TEXT("iphlpapi.dll")))) ||
		NULL == (g_pfnGetBestInterface = (GETBESTINTERFACE)::GetProcAddress(g_hIphlp, "GetBestInterface")) ||
		NULL == (g_pfnGetBestRoute = (GETBESTROUTE)::GetProcAddress(g_hIphlp, "GetBestRoute")) ||
		NULL == (g_pfnGetInterfaceInfo = (GETINTERFACEINFO)::GetProcAddress(g_hIphlp, "GetInterfaceInfo")) ||
		NULL == (g_pfnGetIpForwardTable = (GETIPFORWARDTABLE)::GetProcAddress(g_hIphlp, "GetIpForwardTable")))
	{
		printf("Failed to load proc from iphlpapi.dll\n");
		goto Done;
	}

	if ((NULL == g_hSock && NULL == (g_hSock = LoadLibrary(TEXT("ws2_32.dll")))) ||
		NULL == (g_pfnWSAStartup = (WSASTARTUP)::GetProcAddress(g_hSock, "WSAStartup")) ||
		NULL == (g_pfnWSACleanup = (WSACLEANUP)::GetProcAddress(g_hSock, "WSACleanup")) ||
		NULL == (g_pfn_gethostbyname = (GETHOSTBYNAME)::GetProcAddress(g_hSock, "gethostbyname")) ||
		NULL == (g_pfnWSAGetLastError = (WSAGETLASTERROR)::GetProcAddress(g_hSock, "WSAGetLastError")) ||
		NULL == (g_pfn_inet_addr = (INET_ADDR)::GetProcAddress(g_hSock, "inet_addr")) ||
		NULL == (g_pfn_inet_ntoa = (INET_NTOA)::GetProcAddress(g_hSock, "inet_ntoa")))
	{
		printf("Failed to load proc from ws2_32.dll\n");
		goto Done;
	}

	if (NULL == (g_hSens = LoadLibrary(TEXT("sensapi.dll"))) ||
		NULL == (g_pfnIsNetworkAlive = (ISNETWORKALIVE)::GetProcAddress(g_hSens, "IsNetworkAlive")) ||
		NULL == (g_pfnIsDestinationReachableA = (ISDESTINATIONREACHABLEA)::GetProcAddress(g_hSens, "IsDestinationReachableA")))
	{
		printf("Failed to load proc from sensapi.dll\n");
		goto Done;
	}

	if (0xfffe == wVersion)
	{
		WORD awVersions[] = {0x0200, 0x0202, 0x0, 0x1};

		printf("*******************************************************************************\nRunning API tests...\n\n");
		runApiTests(0x0200 == wVersion ? szWU_PING_URL : pszURL);

		printf("*******************************************************************************\nRunning various connectivity tests...\n\n");
		for (int i=0; i < ARRAYSIZE(awVersions); i++)
		{
			runTest(awVersions[i], pszURL, fLive);
			printf("\n");
		}
	}
	else
	{
		runTest(wVersion, pszURL, fLive);
	}
	goto Done;

Usage:
	printf("Windows Update V4 Network Connectivity/Server Reachability (IsConnected) Test\nCopyright (c) 2002. Microsoft Corporation. All rights reserved.\n\n");
	printf("usage:\n\ttestIsConnected /m[ethod]:<method> [/v[erbose]] [/live | /corpwu] [<destination>]\n");
	printf("where\n\t<method>\ttest method i.e. \"2.0\" for AU 2.0,\n");
	printf("\t\t\t\t\t \"2.2\" for older AU 2.2,\n");
	printf("\t\t\t\t\t \"fix\" for AU 2.2 w/ fix (mirrored),\n");
	printf("\t\t\t\t\t \"code\" for actual AU 2.2 code w/ fix,\n");
	printf("\t\t\t\t\t \"all\" to test all methods\n");
	printf("\t/live\t\tspecifies destination points to the live WU server\n");
	printf("\t\t\t(default; cannot be used together with /corpwu)\n");
	printf("\t/corpwu\t\tspecifies destination points to a WUCE server\n");
	printf("\t\t\t(cannot be used together with /live)\n");
	printf("\t<destination>\thost name or full URL to check for server reachability\n\t\t\te.g. \"windowsupdate.microsoft.com\",\n\t\t\t     \"v4autest\" or \"http://www.any.place/any.thing\"\n\t\t\t(not used in 2.0 mode)\n");

Done:
    if (g_hIphlp != NULL)
    {
        FreeLibrary(g_hIphlp);
    }
	if (g_hSock != NULL)
	{
		FreeLibrary(g_hSock);
	}
	if (g_hSens != NULL)
	{
		FreeLibrary(g_hSens);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\fileutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   fileutil.cpp
//
//  Description:
//
//      IU file utility library
//
//=======================================================================

#include <windows.h>
#include <tchar.h>
#include <stringutil.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <memutil.h>
#include <fileutil.h>
#include <platform.h>
#include <logging.h>
#include <iucommon.h>
#include <advpub.h>
#include <wincrypt.h>
#include <mscat.h>


#include "mistsafe.h"
#include "wusafefn.h"


const TCHAR REGKEY_WINDOWSUPDATE[]		= _T("\\WindowsUpdate\\");
const TCHAR REGKEY_INDUSTRYUPDATE[]		= _T("\\WindowsUpdate\\V4\\");
const TCHAR REGKEY_WINCURDIR[]			= _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion");
const TCHAR REGKEY_PROGFILES[]			= _T(":\\Program Files");
const TCHAR REGKEY_PROGFILESDIR[]		= _T("ProgramFilesDir");

const TCHAR REGKEY_IUCTL[] = _T("Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\IUControl");
const TCHAR REGVAL_ISBETA[] = _T("IsBeta");

const TCHAR IDENT_IUSERVERCACHE[] = _T("IUServerCache");
const TCHAR IDENT_DEFAULTQUERYSERVERINDEX[] = _T("DefaultQueryServerIndex");
const TCHAR IDENT_BETAQUERYSERVERINDEX[] = _T("BetaQueryServerIndex");
const TCHAR IDENT_QUERYSERVERINDEX[] = _T("QueryServerIndex");

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))


#define	IfNullReturnNull(ptr)		if (NULL == ptr) return NULL;
#define InitString(lpStr)			if (NULL != lpStr) lpStr[0] = TCHAR_EOS


typedef BOOL (WINAPI * PFN_GetDiskFreeSpaceEx) (
												LPCTSTR lpDirectoryName,                 // directory name
												PULARGE_INTEGER lpFreeBytesAvailable,    // bytes available to caller
												PULARGE_INTEGER lpTotalNumberOfBytes,    // bytes on disk
												PULARGE_INTEGER lpTotalNumberOfFreeBytes // free bytes on disk
												);



//---------------------------------------------------------------------
//  CreateNestedDirectory
//      Creates the full path of the directory (nested directories)
//---------------------------------------------------------------------
#pragma warning( disable : 4706 )	// Ignore warning C4706: assignment within conditional expression
BOOL CreateNestedDirectory(LPCTSTR pszDir)
{
	BOOL bRc;
	TCHAR szPath[MAX_PATH];
	HRESULT hr=S_OK;

	if (NULL == pszDir || MAX_PATH < (lstrlen(pszDir) + 1))
	{
		return FALSE;
	}

	//
	// make a local copy and remove final slash
	//
	
	hr=StringCchCopyEx(szPath,ARRAYSIZE(szPath),pszDir,NULL,NULL,MISTSAFE_STRING_FLAGS);
	if(FAILED(hr))
	{
		SetLastError(HRESULT_CODE(hr));
		return FALSE;
	}

	int iLast = lstrlen(szPath) - 1;
	if (0 > iLast)		// Prefix
		iLast = 0;
	if (szPath[iLast] == '\\')
		szPath[iLast] = 0;

	//
	// check to see if directory already exists
	//
	DWORD dwAttr = GetFileAttributes(szPath);

	if (dwAttr != 0xFFFFFFFF)   
	{
		if ((dwAttr & FILE_ATTRIBUTE_DIRECTORY) != 0)
			return TRUE;
	}

	//
	// create it
	//
    TCHAR* p = szPath;
	if (p[1] == ':')
		p += 2;
	else 
	{
        // Check if the path is a UNC, need to skip past the UNC Server\Share specification to get to
        // real path
		if (p[0] == '\\' && p[1] == '\\')
        {
			p += 2;
            // skip to the beginning of the share declaration
            p = _tcschr(p, '\\');
            if (NULL == p)
            {
                return FALSE; // invalid UNC
            }
            p++;
            // look for a trailing '\', if it exists then we want to further check for any nested levels,
            // otherwise the path as is should be valid.
            p = _tcschr(p, '\\');
            if (NULL == p)
            {
                // UNC is valid base share name, assume its valid
                return TRUE;
            }
            else
            {
                // look for any further levels, if they exist then pass through to the rest of the directory
                // creator
                p++;
                if (NULL == p)
                {
                    // UNC is valid base share name, but had a trailing slash, not a problem, assume its valid
                    return TRUE;
                }
                // if we haven't exited then there are remaining levels, don't reset our current pointer in the string
                // and let the rest of the nested directory creation work.
            }
        }
	}
	
	if (*p == '\\')
		p++;
    while (p = _tcschr(p, '\\'))	// Ignore warning C4706: assignment within conditional expression
    {
        *p = 0;
		bRc = CreateDirectory(szPath, NULL);
		*p = '\\';
		p++;
		if (!bRc)
		{
			if (GetLastError() != ERROR_ALREADY_EXISTS)
			{
				return FALSE;
			}
		}
	}

	bRc = CreateDirectory(szPath, NULL);
	if ( !bRc )
	{
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			return FALSE;
		}
	}

    return TRUE;
}
#pragma warning( default : 4706 )

//-----------------------------------------------------------------------------------
//  GetIndustryUpdateDirectory
//		This function returns the location of the IndustryUpdate directory. All local
//		files are stored in this directory. The pszPath parameter needs to be at least
//		MAX_PATH.  
//-----------------------------------------------------------------------------------
void GetIndustryUpdateDirectory(LPTSTR pszPath)
{
/*	
	HRESULT hr=S_OK;

	LOG_Block("GetIndustryUpdateDirectory");

	if (NULL == pszPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	static TCHAR szCachePath[MAX_PATH] = {'\0'};

	if (szCachePath[0] == '\0')
	{
		HKEY hkey;

		pszPath[0] = '\0';
		if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_WINCURDIR, &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = MAX_PATH * sizeof(TCHAR);
			RegQueryValueEx(hkey, REGKEY_PROGFILESDIR, NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == '\0')
		{
			TCHAR szWinDir[MAX_PATH];
			if (! GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
			{
				//if GetWinDir fails, assume C:
				CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szWinDir,ARRAYSIZE(szWinDir),_T("C"),NULL,NULL,MISTSAFE_STRING_FLAGS));
		
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = '\0';
			
			//It is assumed that the pszPath will be of the size MAX_PATH
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_PROGFILES,NULL,NULL,MISTSAFE_STRING_FLAGS));


		}	

		
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_INDUSTRYUPDATE,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CreateNestedDirectory(pszPath);

		//
		// save it in the cache (lstrcpy -> lstrcpyn to shut Prefix up, although this
		// would always be safe given the constants used).
		//
		lstrcpyn(szCachePath, pszPath, MAX_PATH);
	}
	else
	{
		//It is assumed that the pszPath will be of the size MAX_PATH
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(pszPath,MAX_PATH,szCachePath,NULL,NULL,MISTSAFE_STRING_FLAGS));
	}

CleanUp:
	return;
	*/
	(void) GetWUDirectory(pszPath, MAX_PATH, TRUE);

}

//-----------------------------------------------------------------------------------
//  GetWindowsUpdateV3Directory - used for V3 history migration
//		This function returns the location of the WindowsUpdate(V3) directory. All V3 
//      local files are stored in this directory. The pszPath parameter needs to be 
//      at least MAX_PATH.  The directory is created if not found
//-----------------------------------------------------------------------------------
void GetWindowsUpdateV3Directory(LPTSTR pszPath)
{
	LOG_Block("GetWindowsUpdateV3Directory");

	HRESULT hr=S_OK;
	if (NULL == pszPath)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return;
	}

	static TCHAR szWUCachePath[MAX_PATH] = {'\0'};

	if (szWUCachePath[0] == '\0')
	{
		HKEY hkey;

		pszPath[0] = '\0';
		if (RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_WINCURDIR, &hkey) == ERROR_SUCCESS)
		{
			DWORD cbPath = MAX_PATH * sizeof(TCHAR);
			RegQueryValueEx(hkey, REGKEY_PROGFILESDIR, NULL, NULL, (LPBYTE)pszPath, &cbPath);
			RegCloseKey(hkey);
		}
		if (pszPath[0] == '\0')
		{
			TCHAR szWinDir[MAX_PATH];
			if (! GetWindowsDirectory(szWinDir, ARRAYSIZE(szWinDir)))
			{
				//if GetWinDir fails, assume C:
				CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(szWinDir,ARRAYSIZE(szWinDir),_T("C"),NULL,NULL,MISTSAFE_STRING_FLAGS));
				
			}
			pszPath[0] = szWinDir[0];
			pszPath[1] = '\0';
		
			CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_PROGFILES,NULL,NULL,MISTSAFE_STRING_FLAGS));
		}	

		
		CleanUpIfFailedAndSetHrMsg(StringCchCatEx(pszPath,MAX_PATH,REGKEY_WINDOWSUPDATE,NULL,NULL,MISTSAFE_STRING_FLAGS));
		CreateNestedDirectory(pszPath);

		//
		// save it in the cache (lstrcpy -> lstrcpyn to shut Prefix up, although this
		// would always be safe given the constants used).
		//
		lstrcpyn(szWUCachePath, pszPath, MAX_PATH);
	}
	else
	{
	
		CleanUpIfFailedAndSetHrMsg(StringCchCopyEx(pszPath,MAX_PATH,szWUCachePath,NULL,NULL,MISTSAFE_STRING_FLAGS));

	}

CleanUp:
	return;

}

// ----------------------------------------------------------------------
//
// Public function MySplitPath() - same as CRT _tsplitpath()
//		to break a path into pieces
//
//	Input: 
//		see below
//
//	Return:
//		Returns the address of the last occurrence of the character in 
//		the string if successful, or NULL otherwise.
//
//	Algorithm:
//				C:\mydir\...\mysubdir\myfile.ext
//       _________|          _________|     |____
//      |                   |                    |
//   start of dir   start of filename     start of extension
//
// ----------------------------------------------------------------------
void MySplitPath(
	LPCTSTR lpcszPath,	// original path
	LPTSTR lpszDrive,	// point to buffer to receive drive letter
	LPTSTR lpszDir,		// point to buffer to receive directory
	LPTSTR lpszFName,	// point to buffer to receive file name
	LPTSTR lpszExt		// point to buffer to receive extension
)
{
	LPCTSTR lpFirstSlash, lpLastSlash, lpPeriod;
	LPCTSTR lpStart = lpcszPath;

	int nPathLen = lstrlen(lpcszPath);
	int nExtLen;

	//
	// initialize pass in vars
	//
	InitString(lpszDrive);
	InitString(lpszDir);
	InitString(lpszFName);
	InitString(lpszExt);
	
	if (0 == nPathLen || TCHAR_DOT == lpcszPath[0])
	{
		//
		// not a valid path
		//
		return;
	}

	lpFirstSlash	= MyStrChr(lpcszPath, TCHAR_BACKSLASH);
	lpLastSlash		= MyStrRChr(lpcszPath, NULL, TCHAR_BACKSLASH);
	lpPeriod		= MyStrRChr(lpcszPath, NULL, TCHAR_DOT);

	nExtLen = lstrlen(lpPeriod);
	if (NULL != lpPeriod && NULL != lpszExt)
	{
		//
		// found a period from right, and
		// we have buffer to output extension
		//
		if(FAILED(StringCchCopyEx(lpszExt,nExtLen+1,lpPeriod,NULL,NULL,MISTSAFE_STRING_FLAGS)))
			return;

	}

	//
	// process drive
	//
	if (nPathLen > 2 && TCHAR_COLON == lpcszPath[1])
	{
		lpStart = lpcszPath + 2;
		if (NULL != lpszDir)
		{
			lstrcpyn(lpszDrive, lpcszPath, 3);
		}
	}


	if (NULL == lpFirstSlash)
	{
		//
		// no backslash, assume this is file name only
		//
		if (NULL != lpszFName)
		{
			lstrcpyn(lpszFName, lpStart, lstrlen(lpStart) - nExtLen + 1);
		}
	}
	else
	{
		//
		// find directory if not empty
		//
		//if (lpLastSlash != lpFirstSlash && NULL != lpszDir)
		if (NULL != lpszDir)
		{
			lstrcpyn(lpszDir, lpFirstSlash, (int)(lpLastSlash - lpFirstSlash + 2));
		}

		//
		// find file name
		//
		if (NULL != lpszFName)
		{
			lstrcpyn(lpszFName, lpLastSlash + 1, lstrlen(lpLastSlash) - nExtLen );
		}
	}
}







// **********************************************************************************
// 
// File version related declarations
//
// **********************************************************************************

// ----------------------------------------------------------------------------------
//
// public function to retrieve file version
//
// ----------------------------------------------------------------------------------
BOOL GetFileVersion(LPCTSTR lpsFile, LPFILE_VERSION lpstVersion)
{
	LOG_Block("GetFileVersion()");

	DWORD	dwVerInfoSize;
	DWORD	dwHandle;
	DWORD	dwVerNumber;
	LPVOID	lpBuffer = NULL;
	UINT	uiSize = 0;
	VS_FIXEDFILEINFO* lpVSFixedFileInfo;

	USES_MY_MEMORY;

	if (NULL != lpstVersion)
	{
		//
		// if this pointer not null, we always try to initialize
		// this structure to 0, in order to reduce the change of 
		// programming error, no matter the file exists or not.
		//
		ZeroMemory(lpstVersion, sizeof(FILE_VERSION));
	}
	if (NULL == lpsFile || NULL == lpstVersion)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	//
	// 506212 IU - FRE log reports incorrect version data for iuengine.dll
	//
	if (FALSE == FileExists(lpsFile))
	{
		//
		// GetFileVersionInfoSize() returns 0 but sets last error to 0 (or
		// doesn't set) if file doesn't exist on Win2K.
		//
		LOG_Out(_T("File \"%s\" doesn't exist, returning FALSE"), lpsFile);
		return FALSE;
	}
	
	dwVerInfoSize = GetFileVersionInfoSize((LPTSTR)lpsFile, &dwHandle);
	
	if (0 == dwVerInfoSize)
	{
		DWORD dwErr = GetLastError();
		if (0 == dwErr)
		{
			LOG_Error(_T("File %s does not have version data. Use 0.0.0.0"), lpsFile);
			lpstVersion->Major	= 0x0;
			lpstVersion->Minor	= 0x0;
			lpstVersion->Build	= 0x0;
			lpstVersion->Ext	= 0x0;
			return TRUE;
		}
		else
		{
			LOG_ErrorMsg(dwErr);
			return FALSE;
		}
	}


	if (NULL == (lpBuffer = (LPVOID) MemAlloc(dwVerInfoSize)))
	{
		LOG_Error(_T("Failed to allocate memory to get version info"));
		return FALSE;
	}

	if (!GetFileVersionInfo((LPTSTR)lpsFile, dwHandle, dwVerInfoSize, lpBuffer))
	{
		LOG_ErrorMsg(GetLastError());
		return FALSE;
	}

	//
	// Get the value for Translation
	//
	if (!VerQueryValue(lpBuffer, _T("\\"), (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize) && NULL != lpVSFixedFileInfo)
	{
		LOG_ErrorMsg(GetLastError());
		return FALSE;
	}

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionMS;
	lpstVersion->Major	= HIWORD(dwVerNumber);
	lpstVersion->Minor	= LOWORD(dwVerNumber);

	dwVerNumber = lpVSFixedFileInfo->dwFileVersionLS;
	lpstVersion->Build	= HIWORD(dwVerNumber);
	lpstVersion->Ext	= LOWORD(dwVerNumber);

	LOG_Out(_T("File %s found version %d.%d.%d.%d"), 
				lpsFile, 
				lpstVersion->Major, 
				lpstVersion->Minor, 
				lpstVersion->Build, 
				lpstVersion->Ext);

	return TRUE;
}



// ----------------------------------------------------------------------------------
//
// public functions to compare file versions
//	
// return:
//		-1: if file ver of 1st parameter < file ver of 2nd parameter
//		 0: if file ver of 1st parameter = file ver of 2nd parameter
//		+1: if file ver of 1st parameter > file ver of 2nd parameter
//
// ----------------------------------------------------------------------------------
int CompareFileVersion(const FILE_VERSION stVersion1, const FILE_VERSION stVersion2)
{

	if ((short)stVersion1.Major < 0 || (short)stVersion2.Major < 0)
	{
		//
		// two empty version structure to compare, we call it equal
		//
		return 0;
	}

	if (stVersion1.Major != stVersion2.Major)
	{
		//
		// major diff, then we know the answer 
		//
		return (stVersion1.Major < stVersion2.Major) ? -1 : 1;
	}
	else
	{
		if ((short)stVersion1.Minor < 0 || (short)stVersion2.Minor < 0)
		{
			//
			// if any minor missing, they equal
			//
			return 0;
		}

		if (stVersion1.Minor != stVersion2.Minor)
		{
			//
			// minor diff, then we know the answer
			//
			return (stVersion1.Minor < stVersion2.Minor) ? -1 : 1;
		}
		else
		{
			if ((short)stVersion1.Build < 0 || (short)stVersion2.Build < 0)
			{
				//
				// if any build is missing, they equal
				//
				return 0;
			}

			if (stVersion1.Build != stVersion2.Build)
			{
				//
				// if build diff then we are done
				//
				return (stVersion1.Build < stVersion2.Build) ? -1 : 1;
			}
			else
			{
				if ((short)stVersion1.Ext < 0 || (short)stVersion2.Ext < 0 || stVersion1.Ext == stVersion2.Ext)
				{
					//
					// if any ext is missing, or they equal, we are done
					//
					return 0;
				}
				else
				{
					return (stVersion1.Ext < stVersion2.Ext) ? -1 : 1;
				}
			}
		}
	}
}


HRESULT CompareFileVersion(LPCTSTR lpsFile1, LPCTSTR lpsFile2, int *pCompareResult)
{

	LOG_Block("CompareFileVersion(File, File)");

	FILE_VERSION stVer1 = {-1,-1,-1,-1}, stVer2 = {-1,-1,-1,-1};
	if (NULL == lpsFile1 || NULL == lpsFile2)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return E_INVALIDARG;
	}

	if (!GetFileVersion(lpsFile1, &stVer1))
	{
		return E_INVALIDARG;
	}
	if (!GetFileVersion(lpsFile2, &stVer2))
	{
		return E_INVALIDARG;
	}

	*pCompareResult = CompareFileVersion(stVer1, stVer2);
	return S_OK;
}


HRESULT CompareFileVersion(LPCTSTR lpsFile, FILE_VERSION stVersion, int *pCompareResult)
{
	LOG_Block("CompareFileVersion(FILE, VER)");
	
	FILE_VERSION stVer = {0};

	if (NULL == lpsFile)
	{
		LOG_Error(_T("NULL file pointer passed in. Function returns 0"));
		return E_INVALIDARG;
	}

	if (!GetFileVersion(lpsFile, &stVer))
	{
		return E_INVALIDARG;
	}

	*pCompareResult = CompareFileVersion(stVer, stVersion);
	return S_OK;
}




// ----------------------------------------------------------------------------------
//
// publif function to convert a string type functoin to FILE_VERSION type
//
// ----------------------------------------------------------------------------------
BOOL ConvertStringVerToFileVer(LPCSTR lpsVer, LPFILE_VERSION lpstVer)
{
	LOG_Block("ConvertStringVerToFileVer()");

	WORD n = -1;
	char c;
	BOOL fHasNumber = FALSE;

#if defined(DBG)	// full logging for checked builds
	USES_IU_CONVERSION;
#endif

	if (NULL == lpsVer || NULL == lpstVer)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

#if defined(DBG)	// full logging for checked builds
	LOG_Out(_T("String version = %s"), A2T(const_cast<LPSTR>(lpsVer)));
#endif

	lpstVer->Major = lpstVer->Minor = lpstVer->Build = lpstVer->Ext = -1;

	c = *lpsVer;

	//
	// get first number
	//
	n = 0;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Major = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}


	//
	// get 2nd number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Minor = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}

	//
	// get 3rd number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Build = n;
	}
	else
	{
		return TRUE;
	}

	//
	// skip delimiter
	//
	while (c != '\0'  && ('0' > c || c > '9'))
	{
		c = *++lpsVer;
	}

	//
	// get 4th number
	//
	n = 0;
	fHasNumber = FALSE;
	while (c != '\0' && '0' <= c && c <= '9')
	{
		n = n * 10 + (int)(c - '0');
		c = *++lpsVer;
		fHasNumber = TRUE;
	}
	if (fHasNumber) 
	{
		lpstVer->Ext = n;
	}

	return TRUE;
}



// ----------------------------------------------------------------------------------
//
// publif function to convert a FILE_VERSION to a string
//
// ----------------------------------------------------------------------------------
BOOL ConvertFileVerToStringVer(
	FILE_VERSION stVer,				// version to convert
	char chDel,						// delimiter to use
	LPSTR lpsBuffer,				// buffer of string
	int ccBufSize					// size of buffer
)
{
	//
	// declare max buffer that wsprintf can use
	//
	char szBuf[1024];

	HRESULT hr=S_OK;



	hr=StringCchPrintfExA(	szBuf,ARRAYSIZE(szBuf),
						NULL,NULL,MISTSAFE_STRING_FLAGS,
						"%d%c%d%c%d%c",
						 stVer.Major,
						 chDel,
						 stVer.Minor,
						 chDel,
						 stVer.Build,
						 chDel,
						 stVer.Ext,
						 chDel
						 );	
					
	if(FAILED(hr))
	{
		goto ErrorExit;
	}

	
	hr=StringCchCopyExA(lpsBuffer,ccBufSize,szBuf,NULL,NULL,MISTSAFE_STRING_FLAGS);
	
	if(FAILED(hr))
	{	
		goto ErrorExit;
	}

	return TRUE;

ErrorExit:
		lpsBuffer[0] = '\0';
		return FALSE;


}





// ----------------------------------------------------------------------------------
//
// public function to check if a file exists
//
// ----------------------------------------------------------------------------------
BOOL FileExists(
	LPCTSTR lpsFile		// file with path to check
)
{
	LOG_Block("FileExists");
	
	DWORD dwAttr;
	BOOL rc;

	if (NULL == lpsFile || _T('\0') == *lpsFile)
	{
		LOG_ErrorMsg(E_INVALIDARG);
		return FALSE;
	}

	dwAttr = GetFileAttributes(lpsFile);

	if (-1 == dwAttr)
	{
		LOG_InfoMsg(GetLastError());
		rc = FALSE;
	}

	else
	{
		rc = (0x0 == (FILE_ATTRIBUTE_DIRECTORY & dwAttr));
	}

	return rc;
}





// ----------------------------------------------------------------------------------
//
// publif function to retrieve the creation time of a file in ISO 8601 format
//	without zone info
//
//	if buffer too small, call GetLastError();
//
// ----------------------------------------------------------------------------------
BOOL GetFileTimeStamp(LPCTSTR lpsFile, LPTSTR lpsTimeStamp, int iBufSize)
{
	BOOL fRet = FALSE;
	HANDLE hFile;
	SYSTEMTIME tm;
	WIN32_FILE_ATTRIBUTE_DATA fileData;
	HRESULT hr=S_OK;

	if (0 != GetFileAttributesEx(lpsFile, GetFileExInfoStandard, &fileData) &&
		0 != FileTimeToSystemTime((const FILETIME*)&(fileData.ftCreationTime), &tm))
	{
		//
		// the output of this systemtime, according to ISA 8601 format, will be
		// like yyyy-mm-ddThh:mm:ss format, so it is 20 chars incl terminator
		//
		if (iBufSize < 20)
		{
			SetLastError(ERROR_BUFFER_OVERFLOW);
			return fRet;
		}
		
		
		hr=StringCchPrintfEx(lpsTimeStamp,iBufSize,NULL,NULL,MISTSAFE_STRING_FLAGS,
						_T("%4d-%02d-%02dT%02d:%02d:%02d"),
						tm.wYear, tm.wMonth, tm.wDay, tm.wHour, tm.wMinute, tm.wSecond);

		if(FAILED(hr))
		{
			fRet=FALSE;
			SetLastError(HRESULT_CODE(hr));
		}
		else
			fRet = TRUE;

	}
	
	return fRet;
}



// ----------------------------------------------------------------------------------
//
// publif function to find the free disk space in KB
//
//
// ----------------------------------------------------------------------------------
HRESULT GetFreeDiskSpace(TCHAR tcDriveLetter, int *piKBytes)
{
	HRESULT hr = E_INVALIDARG;
	BOOL fResult;
	TCHAR szDrive[4];

	if (!(_T('A') <= tcDriveLetter && tcDriveLetter <= _T('Z') ||
		  _T('a') <= tcDriveLetter && tcDriveLetter <= _T('z')))
	{
		return hr;
	}

	
	hr=StringCchPrintfEx(szDrive,ARRAYSIZE(szDrive),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%c:\\"), tcDriveLetter);

	if(FAILED(hr))
		return hr;

	PFN_GetDiskFreeSpaceEx pGetDiskFreeSpaceEx = 
								(PFN_GetDiskFreeSpaceEx) 
								GetProcAddress( GetModuleHandle(_T("kernel32.dll")),
#ifdef UNICODE
                                                "GetDiskFreeSpaceExW");
#else
                                                "GetDiskFreeSpaceExA");
#endif

	if (pGetDiskFreeSpaceEx)
	{
		LARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes;

		fResult = pGetDiskFreeSpaceEx (szDrive,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)NULL);
		*piKBytes = (int) (i64FreeBytesToCaller.QuadPart / 1024);
	}

	else 
	{
		DWORD	dwSectPerClust = 0x0,
				dwBytesPerSect = 0x0,
				dwFreeClusters = 0x0,
				dwTotalClusters = 0x0;

		fResult = GetDiskFreeSpace (szDrive, 
					&dwSectPerClust, 
					&dwBytesPerSect,
					&dwFreeClusters, 
					&dwTotalClusters);
		
		*piKBytes = (int) ((float)(((int)dwFreeClusters) * ((int)dwSectPerClust)) / 1024.0 * (int)dwBytesPerSect);
	}

	return (fResult) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

}

HRESULT GetFreeDiskSpace(LPCTSTR pszUNC, int *piKBytes)
{
	HRESULT hr = E_INVALIDARG;
	BOOL fResult;

	PFN_GetDiskFreeSpaceEx pGetDiskFreeSpaceEx = 
								(PFN_GetDiskFreeSpaceEx) 
								GetProcAddress( GetModuleHandle(_T("kernel32.dll")),
#ifdef UNICODE
                                                "GetDiskFreeSpaceExW");
#else
                                                "GetDiskFreeSpaceExA");
#endif

	if (pGetDiskFreeSpaceEx)
	{
		LARGE_INTEGER i64FreeBytesToCaller, i64TotalBytes;

		fResult = pGetDiskFreeSpaceEx (pszUNC,
					(PULARGE_INTEGER)&i64FreeBytesToCaller,
					(PULARGE_INTEGER)&i64TotalBytes,
					(PULARGE_INTEGER)NULL);
		*piKBytes = (int) (i64FreeBytesToCaller.QuadPart / 1024);
	}

	else 
	{
		DWORD	dwSectPerClust = 0x0,
				dwBytesPerSect = 0x0,
				dwFreeClusters = 0x0,
				dwTotalClusters = 0x0;

		fResult = GetDiskFreeSpace (pszUNC, 
					&dwSectPerClust, 
					&dwBytesPerSect,
					&dwFreeClusters, 
					&dwTotalClusters);
		
		*piKBytes = (int) ((float)(((int)dwFreeClusters) * ((int)dwSectPerClust)) / 1024.0 * (int)dwBytesPerSect);
	}

	return (fResult) ? S_OK : HRESULT_FROM_WIN32(GetLastError());

}

// ----------------------------------------------------------------------------------
//
// publif function to expand the file path
//
//	Assumption: lpszFilePath points to allocated buffer of MAX_PATH.
//	if the expanded path is longer than MAX_PATH, error returned.
//
// ----------------------------------------------------------------------------------
HRESULT ExpandFilePath(LPCTSTR lpszFilePath, LPTSTR lpszDestination, UINT cChars)
{
	HRESULT hr = S_OK;
	LPTSTR lpEnvExpanded;
	LPTSTR lp2ndPercentChar = NULL;
	LPTSTR lpSearchStart;

	USES_MY_MEMORY;

	if (NULL == (lpEnvExpanded = (LPTSTR) MemAlloc((cChars + 1) * sizeof(TCHAR))))
	{
		return E_OUTOFMEMORY;
	}

	//
	// first, let's substitute the system defined variables 
	//
	if (0 == ExpandEnvironmentStrings(lpszFilePath, lpEnvExpanded, cChars))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
	}

	//
	// then handle pre-defined variables that we need to recognize
	// these include all CSIDL definitions inside shlobj.h for SHGetFolderPath() API
	//
	const int C_NAME_LEN = 32;

	struct _CSIDL_NAME {
		long CSIDL_Id;
		TCHAR CSIDL_Str[C_NAME_LEN];
	};
	const _CSIDL_NAME C_CSIDL_NAMES[] = {
		{CSIDL_ADMINTOOLS 				,  _T("CSIDL_ADMINTOOLS")},
		{CSIDL_ALTSTARTUP 				,  _T("CSIDL_ALTSTARTUP")},
		{CSIDL_APPDATA 					,  _T("CSIDL_APPDATA")},
		{CSIDL_BITBUCKET 				,  _T("CSIDL_BITBUCKET")},
		{CSIDL_COMMON_ADMINTOOLS 		,  _T("CSIDL_COMMON_ADMINTOOLS")},
		{CSIDL_COMMON_ALTSTARTUP 		,  _T("CSIDL_COMMON_ALTSTARTUP")},
		{CSIDL_COMMON_APPDATA 			,  _T("CSIDL_COMMON_APPDATA")},
		{CSIDL_COMMON_DESKTOPDIRECTORY 	,  _T("CSIDL_COMMON_DESKTOPDIRECTORY")},
		{CSIDL_COMMON_DOCUMENTS 		,  _T("CSIDL_COMMON_DOCUMENTS")},
		{CSIDL_COMMON_FAVORITES 		,  _T("CSIDL_COMMON_FAVORITES")},
		{CSIDL_COMMON_PROGRAMS 			,  _T("CSIDL_COMMON_PROGRAMS")},
		{CSIDL_COMMON_STARTMENU 		,  _T("CSIDL_COMMON_STARTMENU")},
		{CSIDL_COMMON_STARTUP 			,  _T("CSIDL_COMMON_STARTUP")},
		{CSIDL_COMMON_TEMPLATES 		,  _T("CSIDL_COMMON_TEMPLATES")},
		{CSIDL_CONTROLS 				,  _T("CSIDL_CONTROLS")},
		{CSIDL_COOKIES 					,  _T("CSIDL_COOKIES")},
		{CSIDL_DESKTOP 					,  _T("CSIDL_DESKTOP")},
		{CSIDL_DESKTOPDIRECTORY 		,  _T("CSIDL_DESKTOPDIRECTORY")},
		{CSIDL_DRIVES 					,  _T("CSIDL_DRIVES")},
		{CSIDL_FAVORITES 				,  _T("CSIDL_FAVORITES")},
		{CSIDL_FONTS 					,  _T("CSIDL_FONTS")},
		{CSIDL_HISTORY 					,  _T("CSIDL_HISTORY")},
		{CSIDL_INTERNET 				,  _T("CSIDL_INTERNET")},
		{CSIDL_INTERNET_CACHE 			,  _T("CSIDL_INTERNET_CACHE")},
		{CSIDL_LOCAL_APPDATA 			,  _T("CSIDL_LOCAL_APPDATA")},
		{CSIDL_MYPICTURES 				,  _T("CSIDL_MYPICTURES")},
		{CSIDL_NETHOOD 					,  _T("CSIDL_NETHOOD")},
		{CSIDL_NETWORK 					,  _T("CSIDL_NETWORK")},
		{CSIDL_PERSONAL 				,  _T("CSIDL_PERSONAL")},
		{CSIDL_PRINTERS 				,  _T("CSIDL_PRINTERS")},
		{CSIDL_PRINTHOOD 				,  _T("CSIDL_PRINTHOOD")},
		{CSIDL_PROFILE 					,  _T("CSIDL_PROFILE")},
		{CSIDL_PROGRAM_FILES 			,  _T("CSIDL_PROGRAM_FILES")},
		{CSIDL_PROGRAM_FILES_COMMON 	,  _T("CSIDL_PROGRAM_FILES_COMMON")},
		{CSIDL_PROGRAMS 				,  _T("CSIDL_PROGRAMS")},
		{CSIDL_RECENT 					,  _T("CSIDL_RECENT")},
		{CSIDL_SENDTO 					,  _T("CSIDL_SENDTO")},
		{CSIDL_STARTMENU 				,  _T("CSIDL_STARTMENU")},
		{CSIDL_STARTUP 					,  _T("CSIDL_STARTUP")},
		{CSIDL_SYSTEM 					,  _T("CSIDL_SYSTEM")},
		{CSIDL_TEMPLATES 				,  _T("CSIDL_TEMPLATES")},
		{CSIDL_WINDOWS 					,  _T("CSIDL_WINDOWS")}
	};

	//
	// see if this path has any of these variables
	//
	lpSearchStart = lpEnvExpanded + 1;

	if (SUCCEEDED(hr) && _T('%') == *lpEnvExpanded && 
		NULL != (lp2ndPercentChar = StrChr(lpSearchStart, _T('%'))))
	{
		//
		// copy the variable name to passed in buffer
		//
		lstrcpyn(lpszDestination, lpSearchStart, (int)(lp2ndPercentChar - lpSearchStart + 1));	// skip the 1st % char
		
		lp2ndPercentChar++;	// move to begining of rest of path

		//
		// find out what this variable is
		//
		for (int i = 0; i < sizeof(C_CSIDL_NAMES)/sizeof(C_CSIDL_NAMES[0]); i++)
		{
			if (lstrcmpi(lpszDestination, C_CSIDL_NAMES[i].CSIDL_Str) == 0)
			{
				//
				// found the matching variable!
				//
				if (S_OK == (hr = SHGetFolderPath(NULL, C_CSIDL_NAMES[i].CSIDL_Id, NULL, SHGFP_TYPE_CURRENT, lpszDestination)))
				{
					//
					// ensure buffer big enough
					//
					if (lstrlen(lp2ndPercentChar) + lstrlen(lpszDestination) + sizeof(TCHAR) >= cChars) 
					{
						hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
					}

					//
					// append the rest of them - shouldn't be any of
					// these variables in the rest of string, since this
					// kind variable alaways starts at the beginning of
					// a path
					//

					if(SUCCEEDED(hr))
						hr=PathCchAppend(lpszDestination,MAX_PATH,lp2ndPercentChar);

					if (SUCCEEDED(hr))
					{
						return hr;
					}

				}

				//
				// we found the matching variable, but couldn't get the
				// string replaced.
				//
				break;
			}
		}

		//
		// didn't find it.
		//
	}

	//
	// didn't find it, or failed.
	//
	if (FAILED(hr))
	{
		*lpszDestination = _T('\0');
	}
	else
	{
		lstrcpyn(lpszDestination, lpEnvExpanded, cChars);
	}

	return hr;
}






//----------------------------------------------------------------------
//
// function to validate the folder to make sure
// user has required priviledge
//
// folder will be verified exist. then required priviledge will be checked.
//
// ASSUMPTION: lpszFolder not exceeding MAX_PATH long!!!
//
//----------------------------------------------------------------------
DWORD ValidateFolder(LPTSTR lpszFolder, BOOL fCheckForWrite)
{
	LOG_Block("ValidateFolder");

	DWORD dwErr = ERROR_SUCCESS;
	HRESULT hr=S_OK;
	//
	// first, check if the folder exist
	//
	dwErr = GetFileAttributes(lpszFolder);

	if (-1 == dwErr)
	{
		dwErr = GetLastError();
		LOG_ErrorMsg(dwErr);
		return dwErr;
	}

	//
	// make sure it's a directory
	//
	if ((FILE_ATTRIBUTE_DIRECTORY & dwErr) == 0)
	{
		dwErr = ERROR_PATH_NOT_FOUND;
		LOG_ErrorMsg(dwErr);
		return dwErr;
	}

	
	if (fCheckForWrite)
	{
		TCHAR szFile[MAX_PATH], szFileName[40];
		SYSTEMTIME tm;
		HANDLE hFile;

		//
		// create a random file name
		//
		
		hr=StringCchCopyEx(szFile,ARRAYSIZE(szFile),lpszFolder,NULL,NULL,MISTSAFE_STRING_FLAGS);

		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

		GetLocalTime(&tm);


		hr=StringCchPrintfEx(	szFileName, 
							ARRAYSIZE(szFileName),
							NULL,NULL,MISTSAFE_STRING_FLAGS,
							 _T("%08x%08x%02hd%02hd%02hd%02hd%02hd%03hd%08x"),
							 GetCurrentProcessId(),
							 GetCurrentThreadId(),
							 tm.wMonth,
							 tm.wDay,
							 tm.wHour,
							 tm.wMinute,
							 tm.wSecond,
							 tm.wMilliseconds,
							 GetTickCount());
		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}


		
		hr=PathCchAppend(szFile,ARRAYSIZE(szFile),szFileName);
		if(FAILED(hr))
		{
			dwErr = HRESULT_CODE(hr);;
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

			//
		// try to write file
		//
		hFile = CreateFile(szFile, GENERIC_WRITE | GENERIC_READ, 0, NULL, CREATE_ALWAYS, FILE_FLAG_DELETE_ON_CLOSE, NULL);

		if (INVALID_HANDLE_VALUE == hFile)
		{
			dwErr = GetLastError();
			LOG_ErrorMsg(dwErr);
			return dwErr;
		}

		CloseHandle(hFile);
	}

	return ERROR_SUCCESS;
}

//----------------------------------------------------------------------
//
// function to get a QueryServer from the Ident File for a Given ClientName
// This also looks in the registry for the IsBeta regkey indicating Beta
// functionlality
//
// Returns:
// S_OK : we successfully got QueryServer for this Client
// S_FALSE : we did NOT find a QueryServer for this Client (pszQueryServer will be a null string)
// E_INVALIDARG : parameters were incorrect
//----------------------------------------------------------------------
HRESULT GetClientQueryServer(LPCTSTR pszClientName, LPTSTR pszQueryServer, UINT cChars)
{
    HKEY hkey;
    BOOL fBeta = FALSE;
    int iIndex;
    TCHAR szQueryServerKeyName[128];
    TCHAR szIUDir[MAX_PATH];
    TCHAR szIdentFile[MAX_PATH];
    DWORD dwValue = 0;
    DWORD dwLength = sizeof(dwValue);
	HRESULT hr=S_OK;

    LOG_Block("GetClientQueryServer");

    if ((NULL == pszClientName) || (NULL == pszQueryServer) || (0 == cChars))
    {
        LOG_ErrorMsg(E_INVALIDARG);
        return E_INVALIDARG;
    }

    // Check IUControl Reg Key for Beta Mode
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_IUCTL, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, REGVAL_ISBETA, NULL, NULL, (LPBYTE)&dwValue, &dwLength))
        {
            if (1 == dwValue)
            {
                fBeta = TRUE;
            }
        }
        RegCloseKey(hkey);
    }

    GetIndustryUpdateDirectory(szIUDir);
    
	
	hr=PathCchCombine (szIdentFile,ARRAYSIZE(szIdentFile),szIUDir,IDENTTXT);
	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    // Form the KeyName for the QueryServer Index
    
	hr=StringCchPrintfEx(szQueryServerKeyName,ARRAYSIZE(szQueryServerKeyName),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("%s%s"), pszClientName, fBeta ? IDENT_BETAQUERYSERVERINDEX : IDENT_QUERYSERVERINDEX);

	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    iIndex = GetPrivateProfileInt(IDENT_IUSERVERCACHE, szQueryServerKeyName, 0, szIdentFile);
    if (0 == iIndex)
    {
        iIndex = GetPrivateProfileInt(IDENT_IUSERVERCACHE, IDENT_DEFAULTQUERYSERVERINDEX, 0, szIdentFile);
        if (0 == iIndex)
        {
            return S_FALSE;
        }
    }

    // Form the KeyName for the Specified QueryServer based on the Index
    

	hr=StringCchPrintfEx(szQueryServerKeyName,ARRAYSIZE(szQueryServerKeyName),NULL,NULL,MISTSAFE_STRING_FLAGS,_T("Server%d"), iIndex);
	if(FAILED(hr))
	{
		 LOG_ErrorMsg(hr);
         return hr;
	}

    GetPrivateProfileString(IDENT_IUSERVERCACHE, szQueryServerKeyName, _T(""), pszQueryServer, cChars, szIdentFile);
    if ('\0' == *pszQueryServer)
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

HRESULT DecompressFolderCabs(LPCTSTR pszDecompressPath)
{
    HRESULT hr = S_FALSE; // default is not an Error, but if there are no cabs we return S_FALSE
    TCHAR szSearchInfo[MAX_PATH];
    TCHAR szCabPath[MAX_PATH];
    LPTSTR pszCabList = NULL;
    LPTSTR pszWritePosition = NULL;
    LONG lCabCount = 0;

    WIN32_FIND_DATA fd;
    HANDLE hFind;
    BOOL fMore = TRUE;
    BOOL fRet = TRUE;

	USES_IU_CONVERSION;

    
	hr=PathCchCombine (szSearchInfo,ARRAYSIZE(szSearchInfo),pszDecompressPath, _T("*.cab"));

	if(FAILED(hr))
	{
		return hr;
	}
	

    hFind = FindFirstFile(szSearchInfo, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (fMore)
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                lCabCount++;
            }
            fMore = FindNextFile(hFind, &fd);
        }
        FindClose(hFind);

        pszCabList = (LPTSTR) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (MAX_PATH * sizeof(TCHAR) * lCabCount));
        if (NULL == pszCabList)
        {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        pszWritePosition = pszCabList;

        hFind = FindFirstFile(szSearchInfo, &fd);
        fMore = (INVALID_HANDLE_VALUE != hFind);

		DWORD dwRemLength=lCabCount*MAX_PATH;

        while (fMore)
        {
            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
               
				hr=PathCchCombine(szCabPath,ARRAYSIZE(szCabPath),pszDecompressPath, fd.cFileName);
				if(FAILED(hr))
				{
					 SafeHeapFree(pszCabList);
					 return hr;
				}
                
				hr=StringCchCatEx(pszWritePosition,dwRemLength,szCabPath,NULL,NULL,MISTSAFE_STRING_FLAGS);
				if(FAILED(hr))
				{
					 SafeHeapFree(pszCabList);
					return hr;

				}
                
				dwRemLength=dwRemLength-  ( lstrlen(pszWritePosition)+ 2 * (sizeof(TCHAR)) );
				pszWritePosition += lstrlen(pszWritePosition) + 2 * (sizeof(TCHAR));
				

            }
            fMore = FindNextFile(hFind, &fd);
        }
        FindClose(hFind);

        pszWritePosition = pszCabList;
        for (LONG lCnt = 0; lCnt < lCabCount; lCnt++)
        {
            fRet = IUExtractFiles(pszWritePosition, pszDecompressPath);
            if (!fRet)
            {
                break;
            }
            pszWritePosition += lstrlen(pszWritePosition) + 2 * (sizeof(TCHAR));
        }

        SafeHeapFree(pszCabList);
        if (!fRet)
        {
            hr = E_FAIL; // one of the cabs had an error decompressing
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

//Extracts a cab file to the specified destination. Optionally we can pass in a colon seperated list of files to extract
BOOL IUExtractFiles(LPCTSTR pszCabFile, LPCTSTR pszDecompressFolder, LPCTSTR pszFileNames)
{
    HRESULT hr = S_OK;
#ifdef UNICODE
    char szCabFile[MAX_PATH];
    char szDecompressFolder[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, pszCabFile, -1, szCabFile, sizeof(szCabFile), NULL, NULL);
    WideCharToMultiByte(CP_ACP, 0, pszDecompressFolder, -1, szDecompressFolder, sizeof(szDecompressFolder), NULL, NULL);
    char *pszFiles = NULL;
    if(pszFileNames != NULL)
    {
        pszFiles = (char*)malloc(lstrlen(pszFileNames)+1);
        if (pszFiles == NULL)
        {
            return  FALSE;
        }
        WideCharToMultiByte(CP_ACP, 0, pszFileNames, -1, pszFiles, lstrlen(pszFileNames)+1, NULL, NULL);
    }
    hr = ExtractFiles(szCabFile, szDecompressFolder, 0, pszFiles, 0, 0);
    free(pszFiles);
#else
    hr = ExtractFiles(pszCabFile, pszDecompressFolder, 0, pszFileNames, 0, 0);
#endif
    return SUCCEEDED(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// ReplaceFileExtension
//
/////////////////////////////////////////////////////////////////////////////

BOOL ReplaceFileExtension(  LPCTSTR pszPath,
                          LPCTSTR pszNewExt,
                          LPTSTR pszNewPathBuf, 
                          DWORD cchNewPathBuf)
{
    LPCTSTR psz;
    HRESULT hr;
    DWORD   cchPath, cchExt, cch;

    if (pszPath == NULL || *pszPath == _T('\0'))
        return FALSE;

    cchPath = lstrlen(pszPath);

    // note that only a '>' comparison is needed since the file extension
    //  should never start at the 1st char in the path.
    for (psz = pszPath + cchPath;
         psz > pszPath && *psz != _T('\\') && *psz != _T('.');
         psz--);
    if (*psz == _T('\\'))
        psz = pszPath + cchPath;
    else if (psz == pszPath)
        return FALSE;

    // ok, so now psz points to the place where the new extension is going to 
    //  go.  Make sure our buffer is big enough.
    cchPath = (DWORD)(psz - pszPath);
    cchExt  = lstrlen(pszNewExt);
    if (cchPath + cchExt >= cchNewPathBuf)
        return FALSE;

    // yay.  we got a big enuf buffer.
    hr = StringCchCopyEx(pszNewPathBuf, cchNewPathBuf, pszPath, 
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;
    
    hr = StringCchCopyEx(pszNewPathBuf + cchPath, cchNewPathBuf - cchPath, pszNewExt,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
// ReplaceFileInPath
//
/////////////////////////////////////////////////////////////////////////////

BOOL ReplaceFileInPath(LPCTSTR pszPath, 
                       LPCTSTR pszNewFile,
                       LPTSTR pszNewPathBuf,
                       DWORD cchNewPathBuf)
{
    LPCTSTR psz;
    HRESULT hr;
    DWORD   cchPath, cchFile, cch;

    if (pszPath == NULL || *pszPath == _T('\0'))
        return FALSE;

    cchPath = lstrlen(pszPath);

    // note that only the '>=' comparison is safe cuz we check if pszPath is 
    //  NULL above, so there should always be at least one value < pszPath
    for (psz = pszPath + cchPath;
         psz >= pszPath && *psz != _T('\\');
         psz--);

    // either way we break out of the loop, gotta increment the pointer to
    //  be either the first char in the string or the first char after the
    //  last backslash
    psz++;

    // ok, so now psz points to the place where the new filename is going to 
    //  go.  Make sure our buffer is big enough.
    cchPath = (DWORD)(psz - pszPath);
    cchFile = lstrlen(pszNewFile);
    if (cchPath + cchFile >= cchNewPathBuf)
        return FALSE;
    
    // yay.  we got a big enuf buffer.
    if (cchPath > 0)
    {
        hr = StringCchCopyEx(pszNewPathBuf, cchNewPathBuf, pszPath, 
                             NULL, NULL, MISTSAFE_STRING_FLAGS);
        if (FAILED(hr))
            return FALSE;
    }
    
    hr = StringCchCopyEx(pszNewPathBuf + cchPath, cchNewPathBuf - cchPath, pszNewFile,
                         NULL, NULL, MISTSAFE_STRING_FLAGS);
    if (FAILED(hr))
        return FALSE;

    return TRUE;
}

// ----------------------------------------------------------------------------------
// 
// VerifyFileCRC : This function takes a File Path, calculates the hash on this file
// and compares it to the passed in Hash (pCRC).
// Returns:
// S_OK: CRC's Match
// ERROR_CRC (HRESULT_FROM_WIN32(ERROR_CRC): if the CRC's do not match
// Otherwise an HRESULT Error Code
//
// ----------------------------------------------------------------------------------
HRESULT VerifyFileCRC(LPCTSTR pszFileToVerify, LPCTSTR pszHash)
{
    HRESULT hr = S_OK;
    TCHAR szCompareCRC[CRC_HASH_STRING_LENGTH];
       
    // Validate Parameters
    if ((NULL == pszFileToVerify) || (NULL == pszHash))
        return E_INVALIDARG;

    hr = CalculateFileCRC(pszFileToVerify, szCompareCRC, ARRAYSIZE(szCompareCRC));
    if (FAILED(hr))
        return hr;

    // Now we need to Compare the Calculated CRC with the Passed in CRC
    if (0 == lstrcmpi(szCompareCRC, pszHash))
        return S_OK; // CRC's Match
    else
        return HRESULT_FROM_WIN32(ERROR_CRC); // CRC's do not match
}

// ----------------------------------------------------------------------------------
// 
// CalculateFileCRC : This function takes a File Path, calculates a CRC from the file
// converts it to a string and returns it in the supplied TCHAR buffer
//
// ----------------------------------------------------------------------------------

typedef BOOL (WINAPI * PFN_CryptCATAdminCalcHashFromFileHandle)(HANDLE hFile,
                                                                                                          DWORD *pcbHash,
                                                                                                          BYTE *pbHash,
                                                                                                          DWORD dwFlags);

HRESULT CalculateFileCRC(LPCTSTR pszFileToHash, LPTSTR pszHash, int cchBuf)
{
    HANDLE hFile;
    HRESULT hr = S_OK;
    DWORD cbHash = CRC_HASH_SIZE;
    BYTE bHashBytes[CRC_HASH_SIZE];
    BYTE b;

    // Validate Parameters
    if ((NULL == pszFileToHash) || (NULL == pszHash) || (cchBuf < CRC_HASH_STRING_LENGTH))
        return E_INVALIDARG;

    hFile = CreateFile(pszFileToHash, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        HMODULE hWinTrust = LoadLibraryFromSystemDir(_T("wintrust.dll"));
        if (NULL == hWinTrust)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
        {
            PFN_CryptCATAdminCalcHashFromFileHandle fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            
            fpnCryptCATAdminCalcHashFromFileHandle  = (PFN_CryptCATAdminCalcHashFromFileHandle) GetProcAddress(hWinTrust, "CryptCATAdminCalcHashFromFileHandle");
            if (NULL == fpnCryptCATAdminCalcHashFromFileHandle)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                if (!fpnCryptCATAdminCalcHashFromFileHandle(hFile, &cbHash, bHashBytes, 0))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
                fpnCryptCATAdminCalcHashFromFileHandle = NULL;
            }
            FreeLibrary(hWinTrust);
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if (FAILED(hr))
        return hr;

    LPTSTR p = pszHash;

    // Now we have the Calculated CRC of the File, we need to convert it to a String and Return it. The following 
    // loop will go through each byte in the array and convert it to a Hex Character in the supplied TCHAR buffer
    for (int i = 0; i < CRC_HASH_SIZE; i++)
    {
        b = bHashBytes[i] >> 4;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;

        b = bHashBytes[i] & 0x0F;
        if (b <= 9)
            *p = '0' + (TCHAR)b;
        else
            *p = 'A' + (TCHAR)(b - 10);
        p++;
    }
    *p = _T('\0');
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\waitutil.cpp ===
//=======================================================================
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//  File:   WaitUtil.h
//
//  Description:
//
//      IU wait message utility library
//
//=======================================================================

#include "WaitUtil.h"

DWORD WaitAndPumpMessages(DWORD nCount, LPHANDLE pHandles, DWORD dwWakeMask)
{
    DWORD dwWaitResult;
    MSG msg;

    while (TRUE)
    {
        dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, FALSE, 1000, dwWakeMask);
        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
            return dwWaitResult;
        }

        if (WAIT_OBJECT_0 + nCount == dwWaitResult)
        {
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
    return dwWaitResult;
}

DWORD MyMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
{
    DWORD dwTickStart;
    DWORD dwWaitResult;
	DWORD dwLoopMS = 250;	// default 250 ms timeout for MsgWaitForMultipleObjects
    MSG msg;

    dwTickStart = GetTickCount();

	if (dwLoopMS > dwMilliseconds)
	{
		//
		// Never wait more than dwMilliseconds
		//
		dwLoopMS = dwMilliseconds;
	}

    while (TRUE)
    {
		//
		// Empty message queue before calling MsgWaitForMultipleObjects or any
		// existing messages will not be processed until a new message arrives
		// in the queue.
		//
		while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
		{
			switch (msg.message)
			{
			case WM_QUIT:
			case WM_CLOSE:
			case WM_DESTROY:
				{
					// if the message is one that indicates we're trying to close down, we'll signal the abort
					// and leave.
					dwWaitResult = ERROR_REQUEST_ABORTED;
					return dwWaitResult;
				}
			default:
				break;
			}

			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}

		dwWaitResult = MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll, dwLoopMS, dwWakeMask);

        if (dwWaitResult <= WAIT_OBJECT_0 + nCount - 1)
        {
			//
			// One (or all depending on fWaitAll) of the objects is signaled, return dwWaitResult
			//
            break;
        }

		//
		// NOTE: we ignore WAIT_ABANDONED_0 + n cases and just time out since our callers
		// don't handle this special case.
		//

		//
		// Stop pumping messages after dwMilliseconds
		//
		// Timer wraparound handled by unsigned subtract
		//
        if (GetTickCount() - dwTickStart >= dwMilliseconds)
        {
			//
			// No need to continue, even if caused by new message (WAIT_OBJECT_0 + nCount == dwWaitResult),
			// we have reached our dwMilliseconds timeout
			//
            dwWaitResult = WAIT_TIMEOUT;
            break;
        }

        //
		// Otherwise continue, WAIT_TIMEOUT from MsgWaitForMultipleObjects is only case left
		//
		continue;
    }

    return dwWaitResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\safecs.cpp ===
/******************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name:
    safecs.cpp

Abstract:
    Implements a safe InitializeCriticalSection (usable on all supported platforms)

******************************************************************************/

#include "stdafx.h"

BOOL WINAPI WUInitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpcs, DWORD dwSpinCount)
{
	OSVERSIONINFO osvinfo;
	ZeroMemory(&osvinfo, sizeof(osvinfo));
	osvinfo.dwOSVersionInfoSize = sizeof(osvinfo);

	if (!GetVersionEx(&osvinfo))
	{
		return FALSE;
	}

	typedef BOOL (WINAPI* PROC_InitializeCriticalSectionAndSpinCount)(LPCRITICAL_SECTION, DWORD);
	PROC_InitializeCriticalSectionAndSpinCount pfnInitCS = 
		(PROC_InitializeCriticalSectionAndSpinCount)GetProcAddress(
			GetModuleHandle(_T("kernel32.dll")), "InitializeCriticalSectionAndSpinCount");
	//
	// Don't use InitializeCriticalSectionAndSpinCount on Win9x.
	// It exists but returns VOID (it's a thunk to InitializeCriticalSection).
	//
	if (osvinfo.dwPlatformId == VER_PLATFORM_WIN32_NT && pfnInitCS != NULL)
	{
		return (*pfnInitCS)(lpcs, dwSpinCount);
	}
	else
	{
		BOOL fSuccess = TRUE;
		__try
		{
			InitializeCriticalSection(lpcs);
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			fSuccess = FALSE;
		}

		return fSuccess;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\util\timeutil.cpp ===
#include <timeutil.h>

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeDiff(tm1, tm2)
//          helper function to find the difference (in seconds) of 2 system times
//
// Input:   2 SYSTEMTIME structures
// Output:  None
// Return:  seconds of difference
//              > 0 if tm2 is later than tm1
//              = 0 if tm2 and tm1 are the same
//              < 0 if tm2 is earlier than tm1
//
// On error the function returns 0 even if the two times are not equal
//
// Comment: If the number of seconds goes beyond INT_MAX (that is 
//          more than 24,855 days, INT_MAX is returned.
//          If the number of seconds goes beyond INT_MIN (a negative value,
//          means 24,855 days ago), INT_MIN is returned.
//
////////////////////////////////////////////////////////////////////////////
int TimeDiff(SYSTEMTIME tm1, SYSTEMTIME tm2)
{
    LONGLONG i64Sec;
    int iSec;
    //
    // convert the two times from SYSTEMTIME format into FILETIME format
    //
    FILETIME ftm1, ftm2;

    if ((SystemTimeToFileTime(&tm1, &ftm1) == 0) ||
        (SystemTimeToFileTime(&tm2, &ftm2) == 0))
    {
        return 0;
    }

    if ((ftm1.dwHighDateTime == ftm2.dwHighDateTime) &&
        (ftm1.dwLowDateTime == ftm2.dwLowDateTime))
    {
        return 0;
    }

    //
    // convert the two times from FILETIME to LARGE_INTEGER type,
    //
    LARGE_INTEGER i64Sec1, i64Sec2;
    i64Sec2.LowPart = ftm2.dwLowDateTime;
    i64Sec2.HighPart = ftm2.dwHighDateTime;
    i64Sec1.LowPart = ftm1.dwLowDateTime;
    i64Sec1.HighPart = ftm1.dwHighDateTime;
    
    
    //
    // since Windows support LONGLONG, we directly use the quad portion of LARGE_INTEGER
    // to get the difference, which is 100 nanoseconds. Then convert the number to seconds.
    //
    i64Sec = (i64Sec2.QuadPart - i64Sec1.QuadPart) / NanoSec100PerSec;

    //
    // convert the LONGLONG seconds value into integer, since it shouldn't exceed 
    // integer limit
    //
    if (i64Sec > INT_MAX)
    {
        //
        // just in case user is playing with the system time.
        // Otherwise, this difference should not go beyond 68 years.
        //
        iSec = INT_MAX;
    }
    else
    {
        if (i64Sec < INT_MIN)
        {
            iSec = INT_MIN;
        }
        else
        {
            iSec = (int)i64Sec;
        }
    }
    
    return iSec;
}
    

////////////////////////////////////////////////////////////////////////////
//
// Helper Function  TimeAddSeconds(SYSTEMTIME, int, SYSTEMTIME* )
//          helper function to calculate time by adding n seconds to 
//          the given time.
//
// Input:   a SYSTEMTIME as base time, an int as seconds to add to the base time
// Output:  new time
// Return:  HRESULT
//
////////////////////////////////////////////////////////////////////////////
HRESULT TimeAddSeconds(SYSTEMTIME tmBase, int iSeconds, SYSTEMTIME* pTimeNew)
{
	// fixcode use i64 calcs
    FILETIME ftm;

    if (SystemTimeToFileTime(&tmBase, &ftm) == 0)
    {
        return E_FAIL;
    }

    LARGE_INTEGER i64Sec;
    i64Sec.LowPart  = ftm.dwLowDateTime;
    i64Sec.HighPart = ftm.dwHighDateTime;

    __int64 i64Delay = NanoSec100PerSec;
    i64Delay *= iSeconds;
    i64Sec.QuadPart += i64Delay;    
    ftm.dwLowDateTime = i64Sec.LowPart;
    ftm.dwHighDateTime = i64Sec.HighPart;
    if (FileTimeToSystemTime(&ftm, pTimeNew) == 0)
    {
        return E_FAIL;
    }
    return S_OK;
}



//=======================================================================
// String2SystemTime
//=======================================================================
HRESULT String2SystemTime(LPCTSTR pszDateTime, SYSTEMTIME *ptm)
{
    // we expect the date/time format as 4-digit year ISO:
    //      01234567890123456789
    //      YYYY.MM.DD HH:MM:SS
    //
    const TCHAR C_DATE_DEL      = _T('.');
    const TCHAR C_DATE_TIME_DEL = _T(' ');
    const TCHAR C_TIME_DEL      = _T(':');
    TCHAR szBuf[20];
	LPTSTR pszDestEnd;

    if (FAILED(StringCchCopyEx(szBuf, ARRAYSIZE(szBuf), pszDateTime, &pszDestEnd, NULL, MISTSAFE_STRING_FLAGS)) ||
		19 != pszDestEnd - szBuf)
    {
        return E_INVALIDARG;
    }

    for (int i = 0; i < 19; i++)
    {
        switch (i)
        {
        case 4:
        case 7:
            if (szBuf[i] != C_DATE_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 10:
            if (szBuf[i] != C_DATE_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        case 13:
        case 16:
            if (szBuf[i] != C_TIME_DEL)
            {
                return E_INVALIDARG;
            }
            break;
        default:
            if (szBuf[i] < _T('0') || pszDateTime[i] > _T('9'))
            {
                return E_INVALIDARG;
            }
            break;
        }
    }

    //
    // get values
    //
    szBuf[4]            = EOS;
    ptm->wYear          = (short)_ttoi(szBuf);
    szBuf[7]            = EOS;
    ptm->wMonth         = (short)_ttoi(szBuf + 5);
    szBuf[10]           = EOS;
    ptm->wDay           = (short)_ttoi(szBuf + 8);
    szBuf[13]           = EOS;
    ptm->wHour          = (short)_ttoi(szBuf + 11);
    szBuf[16]           = EOS;
    ptm->wMinute        = (short)_ttoi(szBuf + 14);
    ptm->wSecond        = (short)_ttoi(szBuf + 17); 
    ptm->wMilliseconds  = 0;

    //
    // validate if this constructed SYSTEMTIME data is good
    //
    // fixcode should this just be SystemTimeToFileTime() ?
    if (GetDateFormat(LOCALE_SYSTEM_DEFAULT,DATE_SHORTDATE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }
    if (GetTimeFormat(LOCALE_SYSTEM_DEFAULT,LOCALE_NOUSEROVERRIDE, ptm, NULL, NULL, 0) == 0)
    {
        return E_INVALIDARG;
    }

    return S_OK;
}


//=======================================================================
// SystemTime2String
//=======================================================================
HRESULT SystemTime2String(SYSTEMTIME & tm, LPTSTR pszDateTime, size_t cchSize)
{
    if ( pszDateTime == NULL )
    {
        return E_INVALIDARG;
    }

    // bug fixed: changed from wsprintf to _snwprintf because an invalid
    // date on tm was causing buffer overflow
    LPTSTR pszDestEnd;
	if (FAILED(StringCchPrintfEx(
					pszDateTime,
					cchSize,
					&pszDestEnd,
					NULL,
					MISTSAFE_STRING_FLAGS,
					TEXT("%4i.%02i.%02i %02i:%02i:%02i"),
					tm.wYear,
					tm.wMonth,
					tm.wDay,
					tm.wHour,
					tm.wMinute,
					tm.wSecond)) ||
		pszDestEnd - pszDateTime != 19)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\safefile.cpp ===
//
// SafeFile.cpp
//
//		Functions to help prevent opening unsafe files.
//
// History:
//
//		2002-03-18  KenSh     Created
//
// Copyright (c) 2002 Microsoft Corporation
//

#include "stdafx.h"
#include "SafeFile.h"
#include <strsafe.h>

//
// Hopefully most projects already define these; if not, ensure we still compile
//
#ifndef ASSERT
#define ASSERT(x)
#endif
#ifndef ARRAYSIZE
#define ARRAYSIZE(ar) (sizeof(ar)/sizeof((ar)[0]))
#endif

//
// Eliminate an unnecessary function call on Unicode builds
//
#ifndef CHARNEXT
#ifdef UNICODE
#define CHARNEXT(psz) (psz+1)
#else
#define CHARNEXT CharNextA
#endif
#endif

//
// Local function declarations
//
static inline BOOL IsSlashOrBackslash(IN TCHAR ch);
static inline BOOL IsSlashOrBackslash(IN TCHAR ch);
static BOOL SkipLangNeutralPrefix(IN LPCTSTR pszString, IN LPCTSTR pszPrefix, OUT LPCTSTR* ppszResult);
static BOOL MyPathFindNextComponent(IN LPCTSTR pszFileName, IN BOOL fAllowForwardSlash, OUT LPCTSTR* ppszResult);
static BOOL SkipPathDrivePart(IN LPCTSTR pszFileName, OUT OPTIONAL int* pcchDrivePart, OUT OPTIONAL BOOL* pfUNC, OUT OPTIONAL BOOL* pfExtendedSyntax);
static HRESULT CheckValidDriveType(IN LPCTSTR pszFileName, IN BOOL fAllowNetworkDrive, IN BOOL fAllowRemovableDrive);
static BOOL WINAPI DoesPathContainDotDot(IN LPCTSTR pszFileName);
static BOOL DoesPathContainStreamSyntax(IN LPCTSTR pszFileName);
static HRESULT CheckReparsePointPermissions(IN DWORD dwReparseType);


//============================================================================

static inline HRESULT GetLastErrorAsHresult()
{
	DWORD dwErr = GetLastError();
	return HRESULT_FROM_WIN32(dwErr);
}

// IsSlashOrBackslash [private]
//
//		Helper function to simplify code that checks for path separators.
//		Most places where backslash is valid, forward slash is also valid.
//
static inline BOOL IsSlashOrBackslash(IN TCHAR ch)
{
	return (ch == _T('\\') || ch == _T('/'));
}


// StrLenWithMax [private]
//
//		Returns the equivalent of min(lstrlen(pszString), cchMax)
//		but avoids most of the lstrlen when cchMax is small.
//
static int StrLenWithMax(IN LPCTSTR pszString, IN int cchMax)
{
	int cch = 0;
	while (*pszString && cch < cchMax)
		cch++;
	return cch;
}


// SkipLangNeutralPrefix [private]
//
//		Sets the out param to the new string pointer after skipping the prefix,
//		if the string starts with the prefix (case-insensitive). Otherwise sets
//		the out param to the start of the input string.
//
//		Returns TRUE if the prefix was found & skipped, otherwise FALSE.
//
static BOOL SkipLangNeutralPrefix(IN LPCTSTR pszString, IN LPCTSTR pszPrefix, OUT LPCTSTR* ppszResult)
{
	int cchPrefix = lstrlen(pszPrefix);
	int cchString = StrLenWithMax(pszString, cchPrefix);
	BOOL fResult = FALSE;

	if (CSTR_EQUAL == CompareString(MAKELCID(LANG_ENGLISH, SORT_DEFAULT), NORM_IGNORECASE,
							pszString, cchString, pszPrefix, cchPrefix))
	{
		fResult = TRUE;
		pszString += cchPrefix;
	}

	*ppszResult = pszString;
	return fResult;
}


// MyPathFindNextComponent [private]
//
//		Skips past the next component of the given path, including the slash or
//		backslash that follows it.
//
//		Sets the out param to the beginning of the next path component, or to
//		the end of string if there is no next path component.
//
//		Returns TRUE if a slash or backslash was found and skipped. Note that
//		the out param can be "" even if function returns TRUE.
//
static BOOL MyPathFindNextComponent
	(
		IN  LPCTSTR pszFileName,
		IN  BOOL    fAllowForwardSlash,
		OUT LPCTSTR* ppszResult
	)
{
	// This is a string-parsing helper function; params should never be NULL
	ASSERT(pszFileName != NULL);
	ASSERT(ppszResult != NULL);

	LPCTSTR pszStart = pszFileName;
	TCHAR chSlash2 = (fAllowForwardSlash ? _T('/') : _T('\\'));
	BOOL fResult = FALSE;

	for (;;)
	{
		TCHAR ch = *pszFileName;
		if (ch == _T('\0'))
			break; // didn't find a path separator; we'll return FALSE

		// Advance to next char, even if current char is path separator (\ or /)
		pszFileName = CHARNEXT(pszFileName);

		if (ch == _T('\\') || ch == chSlash2)
		{
			fResult = TRUE;
			break;
		}
	}

	*ppszResult = pszFileName;
	return fResult;
}


// SkipPathDrivePart [private]
//
//		Parses the filename to determine the length of the base drive portion of
//		the filename, and to determine what syntax the name is in.
//
//		This function does not actually examine the drive or file to ensure existence,
//		or to recognize that a drive letter like X:\ might be a network drive.
//
//		Returns:
//			TRUE  - if the input is a full path
//			FALSE - if input param is not a full path, or is bogus. The pcchDrivePart
//			        out param is set to 0 in this case.
//
static BOOL SkipPathDrivePart
	(
		IN LPCTSTR pszFileName,             // input path name (full or relative path)
		OUT OPTIONAL int* pcchDrivePart,    // # of TCHARs used by drive part
		OUT OPTIONAL BOOL* pfUNC,           // TRUE if path is UNC (not incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax // TRUE if path is \\?\ syntax
	)
{
	BOOL fFullPath = FALSE;
	LPCTSTR pszOriginalFileName = pszFileName;
	int fUNC = FALSE;
	int fExtendedSyntax = FALSE;

	if (!pszFileName)
		goto done;

	// BLOCK
	{
		//
		// Skip \\?\ if present. (This part must use backslashes, not forward slashes)
		//
#ifdef UNICODE
		if (SkipLangNeutralPrefix(pszFileName, _T("\\\\?\\"), &pszFileName))
		{
			fExtendedSyntax = TRUE;

			if (SkipLangNeutralPrefix(pszFileName, _T("UNC\\"), &pszFileName))
			{
				fUNC = TRUE; // Found "\\?\UNC\..."
			}
			else if (SkipLangNeutralPrefix(pszFileName, _T("Volume{"), &pszFileName))
			{
				// Found "\\?\Volume{1f3b3813-ddbf-11d5-ab2e-806d6172696f}\".
				// Skip the rest of the volume name.
				fFullPath = MyPathFindNextComponent(pszFileName, FALSE, &pszFileName);
				goto done;
			}
			// else continue normal parsing starting at updated pszFileName pointer
		}
#endif // UNICODE

		//
		// Check for path of the form C:\ 
		//
		TCHAR chFirstUpper = (TCHAR)CharUpper((LPTSTR)(pszFileName[0]));
		if (chFirstUpper >= _T('A') && chFirstUpper <= _T('Z') &&
			pszFileName[1] == _T(':') && pszFileName[2] == _T('\\'))
		{
			pszFileName += 3;
			fFullPath = TRUE;
			goto done;
		}

		//
		// Check for UNC of the form \\server\share\ 
		//
		if (!fExtendedSyntax &&
			pszFileName[0] == _T('\\') &&
			pszFileName[1] == _T('\\'))
		{
			fUNC = TRUE;
			pszFileName += 2; // skip the "\\"
		}
		if (fUNC) // may be \\server\share\ or \\?\UNC\server\share\ 
		{
			// Skip past server and share names. Trailing backslash is NOT optional.
			if (!MyPathFindNextComponent(pszFileName, TRUE, &pszFileName) ||
				!MyPathFindNextComponent(pszFileName, TRUE, &pszFileName))
			{
				goto done; // incomplete UNC path -> return failure
			}

			fFullPath = TRUE;
		}
	}

done:
	if (pcchDrivePart)
		*pcchDrivePart = fFullPath ? (int)(pszFileName - pszOriginalFileName) : 0;
	if (pfUNC)
		*pfUNC = fUNC;
	if (pfExtendedSyntax)
		*pfExtendedSyntax = fExtendedSyntax;

	return fFullPath;
}


// GetReparsePointType [public]
//
//		Given the full path of a file or directory, determines what type of 
//		reparse point the path represents.
//
//		Returns S_OK if the type of reparse point could be determined, or
//		an appropriate error code if not.
//
//		The out param is set to the reparse point type, or 0 if none.
//		The value for both volume mount points and junction points is
//		IO_REPARSE_TAG_MOUNT_POINT. (Use GetVolumeNameForVolumeMountPoint
//		to distinguish, if necessary.)
//
HRESULT WINAPI GetReparsePointType
	(
		IN LPCTSTR pszFileName,           // full path to folder to check
		OUT DWORD* pdwReparsePointType    // set to reparse point type, or 0 if none
	)
{
	HRESULT hr = S_OK;
	DWORD dwReparseType = 0;

	ASSERT(pdwReparsePointType);

	// BLOCK
	{
		if (!pszFileName)
		{
			hr = E_INVALIDARG;
			goto done;
		}

		DWORD dwAttrib = GetFileAttributes(pszFileName);
		if (dwAttrib == INVALID_FILE_ATTRIBUTES)
			goto win32_error;

		if (dwAttrib & FILE_ATTRIBUTE_REPARSE_POINT)
		{
			WIN32_FIND_DATA Find;
			HANDLE hFind = FindFirstFile(pszFileName, &Find);
			if (hFind == INVALID_HANDLE_VALUE)
				goto win32_error;

			dwReparseType = Find.dwReserved0;
			FindClose(hFind);
		}
		goto done;
	}

win32_error:
	hr = GetLastErrorAsHresult();

done:
	*pdwReparsePointType = dwReparseType;
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// CheckReparsePointPermissions [private]
//
//		Determines whether or not it's ok to trust the given reparse type.
//		Returns S_OK if it's safe, or an appropriate error message if not.
//
static HRESULT CheckReparsePointPermissions(IN DWORD dwReparseType)
{
	HRESULT hr = S_OK;

	// REVIEW: Any reason to worry about these other types of reparse points?
	//   IO_REPARSE_TAG_HSM, IO_REPARSE_TAG_SIS, IO_REPARSE_TAG_DFS, etc.
	if (dwReparseType == IO_REPARSE_TAG_MOUNT_POINT)
	{
		hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
	}

	return hr;
}


// CheckValidDriveType [private]
//
//		Gets the volume name associated with the given file, and checks the
//		return value from GetDriveType() to see whether or not operations
//		are allowed on the file.
//
static HRESULT CheckValidDriveType
	(
		IN LPCTSTR pszFileName,       // full path of a file whose drive we want to check
		IN BOOL fAllowNetworkDrive,   // determines whether or not net drives are allowed
		IN BOOL fAllowRemovableDrive  // determines whether or not removable drives are allowed
	)
{
	HRESULT hr = E_INVALIDARG;
	LPTSTR pszVolumePath = NULL;

	// BLOCK
	{
		if (!pszFileName)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		int cchFileName = lstrlen(pszFileName);
		pszVolumePath = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * (cchFileName+1));
		if (!pszVolumePath)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}

#ifdef UNICODE
		if (!GetVolumePathName(pszFileName, pszVolumePath, cchFileName+1))
		{
			hr = GetLastErrorAsHresult();
			goto done;
		}
#else
		int cchDrivePart;
		if (!SkipPathDrivePart(pszFileName, &cchDrivePart, NULL, NULL))
		{
			hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
			goto done;
		}
		StringCchCopy(pszVolumePath, cchDrivePart+1, pszFileName);
#endif

		UINT uDriveType = GetDriveType(pszVolumePath);
		switch (uDriveType)
		{
		case DRIVE_FIXED:
			hr = S_OK;
			break;

		case DRIVE_REMOVABLE:
		case DRIVE_CDROM:
		case DRIVE_UNKNOWN:
		case DRIVE_RAMDISK:
			hr = fAllowRemovableDrive ? S_OK : E_ACCESSDENIED;
			break;

		case DRIVE_REMOTE:
			hr = fAllowNetworkDrive ? S_OK : E_ACCESSDENIED;
			break;

		default:
			hr = E_INVALIDARG;
			break;
		}
	}

done:
	SafeFileFree(pszVolumePath);

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// IsFullPathName [public]
//
//		Determines whether the given filename is a full path including a drive
//		or UNC. Filenames such as \\?\ are supported, and can be considered
//		valid or not depending on the dwSafeFlags parameter.
//
//		Returns:
//			TRUE  - if the filename is a full path
//			FALSE - if filename is NULL, isn't a full path, or fails to meet
//			        the criteria given in the dwSafeFlags parameter.
//
BOOL WINAPI IsFullPathName
	(
		IN LPCTSTR pszFileName,              // full or relative path to a file
		OUT OPTIONAL BOOL* pfUNC,            // TRUE path is UNC (int incl mapped drive)
		OUT OPTIONAL BOOL* pfExtendedSyntax  // TRUE if path is \\?\ syntax
	)
{
	return SkipPathDrivePart(pszFileName, NULL, pfUNC, pfExtendedSyntax);
}


// DoesPathContainDotDot [private]
//
//		Returns TRUE if the path contains any ".." references, else FALSE.
//
static BOOL WINAPI DoesPathContainDotDot(IN LPCTSTR pszFileName)
{
	if (!pszFileName)
		return FALSE;

	while (*pszFileName)
	{
		// Flag path components that consist exactly of ".." (nothing following)
		if (pszFileName[0] == _T('.') && pszFileName[1] == _T('.') &&
			(pszFileName[2] == _T('/') || pszFileName[2] == _T('\\') || pszFileName[2] == _T('\0')))
		{
			return TRUE;
		}

		MyPathFindNextComponent(pszFileName, TRUE, &pszFileName);
	}

	return FALSE;
}


// DoesPathContainStreamSyntax [private]
//
//		Returns TRUE if the path contains any characters that could cause it
//		to refer to an alternate NTFS stream (namely any ":" characters beyond
//		the drive specification).
//
static BOOL DoesPathContainStreamSyntax(IN LPCTSTR pszFileName)
{
	if (!pszFileName)
		return FALSE;

	int cchSkip;
	SkipPathDrivePart(pszFileName, &cchSkip, NULL, NULL);

	for (LPCTSTR pch = pszFileName + cchSkip; *pch; pch = CHARNEXT(pch))
	{
		if (*pch == _T(':'))
			return TRUE;
	}

	return FALSE;
}


// SafeCreateFile [public]
//
//		Opens the given file, ensuring that it meets certain path standards (e.g.
//		doesn't contain "..") and that it is a file, not a device or named pipe.
//
HRESULT WINAPI SafeCreateFile
	(
		OUT HANDLE* phFileResult,       // receives handle to opened file, or INVALID_HANDLE_VALUE
		IN DWORD dwSafeFlags,           // zero or more SCF_* flags
		IN LPCTSTR pszFileName,         // same as CreateFile
		IN DWORD dwDesiredAccess,       // same as CreateFile
		IN DWORD dwShareMode,           // same as CreateFile
		IN LPSECURITY_ATTRIBUTES lpSecurityAttributes, // same as CreateFile
		IN DWORD dwCreationDisposition, // same as CreateFile
		IN DWORD dwFlagsAndAttributes,  // same as CreateFile + (SECURITY_SQOS_PRESENT|SECURITY_ANONYMOUS)
		IN HANDLE hTemplateFile         // same as CreateFile
	)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	HRESULT hr = S_OK;

	// BLOCK
	{
		if (!pszFileName || !phFileResult ||
			(dwSafeFlags & ~(SCF_ALLOW_NETWORK_DRIVE | SCF_ALLOW_REMOVABLE_DRIVE | SCF_ALLOW_ALTERNATE_STREAM)))
		{
			hr = E_INVALIDARG;
			goto done;
		}

		// We require a full pathname.
		if (!IsFullPathName(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
			goto done;
		}

		// Ensure path doesn't contain ".." references
		if (DoesPathContainDotDot(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
			goto done;
		}

		// Ensure filename doesn't refer to alternate stream unless allowed
		if (!(dwSafeFlags & SCF_ALLOW_ALTERNATE_STREAM) &&
			DoesPathContainStreamSyntax(pszFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
			goto done;
		}

		// Check drive type to ensure it's allowed by dwSafeFlags
		if (FAILED(hr = CheckValidDriveType(pszFileName, (dwSafeFlags & SCF_ALLOW_NETWORK_DRIVE),
							(dwSafeFlags & SCF_ALLOW_REMOVABLE_DRIVE))))
		{
			goto done;
		}

		// Open the file w/ extra security attributes
		dwFlagsAndAttributes |= (SECURITY_SQOS_PRESENT | SECURITY_ANONYMOUS);
		hFile = CreateFile(pszFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes,
							dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			goto win32_error;
		}

		// Ensure it's really a file
		if (FILE_TYPE_DISK != GetFileType(hFile))
		{
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
			hr = HRESULT_FROM_WIN32(ERROR_OPEN_FAILED);
		}
		goto done;

	} // end BLOCK

win32_error:
	hr = GetLastErrorAsHresult();

done:
	if (phFileResult)
		*phFileResult = hFile;
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeRemoveFileAttributes [public]
//
//		Given a filename and that file's current attributes, checks whether
//		any of the bits in dwRemoveAttrib need to be removed from the file,
//		and if necessary calls SetFileAttributes() to remove them.
//
//		Designed to check for invalid dwCurAttrib and call GetLastError()
//		for you, so you can pass GetFileAttributes() directly as a parameter.
//
HRESULT WINAPI SafeRemoveFileAttributes
	(
		IN LPCTSTR pszFileName,    // full path to file whose attributes we will change
		IN DWORD   dwCurAttrib,    // current attributes of the file
		IN DWORD   dwRemoveAttrib  // attribute bits to remove
	)
{
	HRESULT hr = S_OK; // this is default if attrib doesn't need to be removed

	if (!pszFileName || !dwRemoveAttrib)
	{
		hr = E_INVALIDARG;
		goto done;
	}

	if (dwCurAttrib & dwRemoveAttrib) // note: always true if dwCurAttrib==INVALID_FILE_ATTRIBUTES
	{
		if (dwCurAttrib == INVALID_FILE_ATTRIBUTES ||
			!SetFileAttributes(pszFileName, dwCurAttrib & ~dwRemoveAttrib))
		{
			hr = GetLastErrorAsHresult();
		}
	}

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeDeleteFolderAndContentsHelper [private]
//
//		Does all work except the parameter validation for for
//		SafeDeleteFolderAndContents.
//
static HRESULT SafeDeleteFolderAndContentsHelper
	(
		IN  LPCTSTR pszFolderToDelete,  // folder in current level of recursion
		IN  DWORD dwSafeFlags,          // zero or more SDF_* flags
		OUT WIN32_FIND_DATA* pFind      // struct to use for FindFirst/FindNext (to avoid malloc)
	)
{
	HRESULT hr = S_OK;
	LPTSTR pszCurFile = NULL;
	HANDLE hFind = INVALID_HANDLE_VALUE;

	// Allocate room for folder + backslash + MAX_PATH (includes trailing null)
	int cchFolderName = lstrlen(pszFolderToDelete);
	int cchAllocCurFile = cchFolderName + 1 + MAX_PATH;
	pszCurFile = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * cchAllocCurFile);
	if (!pszCurFile)
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}

	// Check for read-only base folder
	if (dwSafeFlags & SDF_DELETE_READONLY_FILES)
	{
		hr = SafeRemoveFileAttributes(pszFolderToDelete, GetFileAttributes(pszFolderToDelete), FILE_ATTRIBUTE_READONLY);
		if (FAILED(hr) && !(dwSafeFlags & SDF_CONTINUE_IF_ERROR))
			goto done;
	}

	// Build search path by appending "\*.*"
	StringCchCopy(pszCurFile, cchAllocCurFile, pszFolderToDelete);
	if (!IsSlashOrBackslash(pszCurFile[cchFolderName-1]))
		pszCurFile[cchFolderName++] = _T('\\');
	StringCchCopy(pszCurFile + cchFolderName, cchAllocCurFile - cchFolderName, _T("*.*"));

	// Iterate through all files in this folder
	hFind = FindFirstFile(pszCurFile, pFind);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = GetLastErrorAsHresult();  // probably doesn't exist, or not a folder
		goto done;
	}
	else
	{
		do
		{
			if (0 == lstrcmp(pFind->cFileName, _T(".")) ||
				0 == lstrcmp(pFind->cFileName, _T("..")))
			{
				continue;
			}

			StringCchCopy(pszCurFile + cchFolderName, cchAllocCurFile - cchFolderName, pFind->cFileName);
			HRESULT hrCur = S_OK;

			if (!(pFind->dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) ||
				SUCCEEDED(hrCur = CheckReparsePointPermissions(pFind->dwReserved0)))
			{
				// Remove read-only attribute if allowed
				if (dwSafeFlags & SDF_DELETE_READONLY_FILES)
				{
					hrCur = SafeRemoveFileAttributes(pszCurFile, pFind->dwFileAttributes, FILE_ATTRIBUTE_READONLY);
				}

				if (SUCCEEDED(hrCur) || (dwSafeFlags & SDF_CONTINUE_IF_ERROR))
				{
					HRESULT hrCur2 = S_OK;

					if (pFind->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
						// Recursively delete folder and contents
						// Note that pFind's contents are clobbered by this call
						hrCur2 = SafeDeleteFolderAndContentsHelper(pszCurFile, dwSafeFlags, pFind);
					}
					else
					{
						// Delete the file
						if (!DeleteFile(pszCurFile))
						{
							hrCur2 = GetLastErrorAsHresult();
						}
					}

					if (FAILED(hrCur2))
						hrCur = hrCur2;
				}
			}

			if (FAILED(hrCur))
				hr = hrCur;

			if (FAILED(hr) && !(dwSafeFlags & SDF_CONTINUE_IF_ERROR))
				goto done;

		} while (FindNextFile(hFind, pFind));
		FindClose(hFind);
		hFind = INVALID_HANDLE_VALUE;
	}

	// Delete the folder
	if (!RemoveDirectory(pszFolderToDelete))
	{
		if (SUCCEEDED(hr))
			hr = GetLastErrorAsHresult();
	}

done:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	SafeFileFree(pszCurFile);
	return hr;
}


// SafeDeleteFolderAndContents [public]
//
//		Deletes the given folder and all of its contents, but refuses to walk
//		across reparse points.
//
HRESULT WINAPI SafeDeleteFolderAndContents
	(
		IN LPCTSTR pszFolderToDelete,  // full path of folder to delete
		IN DWORD   dwSafeFlags         // zero or more SDF_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	if (!pszFolderToDelete || !(*pszFolderToDelete) ||
		(dwSafeFlags & ~(SDF_ALLOW_NETWORK_DRIVE | SDF_DELETE_READONLY_FILES | SDF_CONTINUE_IF_ERROR)))
	{
		goto done;  // hr already set to E_INVALIDARG
	}

	//
	// Ensure it's a full path, but not the root of a drive
	//
	int cchDrivePart;
	if (!SkipPathDrivePart(pszFolderToDelete, &cchDrivePart, NULL, NULL) ||
		pszFolderToDelete[cchDrivePart] == _T('\0'))
	{
		hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
		goto done;
	}

	//
	// Ensure we're not deleting from a network drive unless allowed
	//
	if (FAILED(hr = CheckValidDriveType(pszFolderToDelete, (dwSafeFlags & SDF_ALLOW_NETWORK_DRIVE), TRUE)))
	{
		goto done;
	}

	//
	// Ensure starting point is not a reparse point
	//
	DWORD dwReparseType;
	if (FAILED(hr = GetReparsePointType(pszFolderToDelete, &dwReparseType)) ||
		FAILED(hr = CheckReparsePointPermissions(dwReparseType)))
	{
		goto done;
	}

	WIN32_FIND_DATA Find;
	hr = SafeDeleteFolderAndContentsHelper(pszFolderToDelete, dwSafeFlags, &Find);

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafeFileCheckForReparsePoint [public]
//
//		Checks a subset of the given filename's component parts to ensure that
//		they are not reparse points (specifically, volume mount points or
//		junction points: see linkd.exe and mountvol.exe).
//
//		Normal return values are S_OK or HRESULT_FROM_WIN32(ERROR_REPARSE_TAG_MISMATCH).
//		Other values may be returned in exceptional cases such as out-of-memory.
//
HRESULT WINAPI SafeFileCheckForReparsePoint
	(
		IN LPCTSTR pszFileName,           // full path of a file
		IN int     nFirstUntrustedOffset, // char offset of first path component to check
		IN DWORD   dwSafeFlags            // zero or more SRP_* flags
	)
{
	HRESULT hr = E_INVALIDARG;
	LPTSTR pszMutableFileName = NULL;

	// BLOCK
	{
		if (!pszFileName || (dwSafeFlags & ~SRP_FILE_MUST_EXIST))
		{
			goto done;  // hr is already E_INVALIDARG
		}

		int cchFileName = lstrlen(pszFileName);
		if ((UINT)nFirstUntrustedOffset >= (UINT)cchFileName) // bad offset, or zero-length filename
		{
			goto done;  // hr is already E_INVALIDARG
		}

		pszMutableFileName = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * (cchFileName+1));
		if (!pszMutableFileName)
		{
			hr = E_OUTOFMEMORY;
			goto done;
		}
		StringCchCopy(pszMutableFileName, cchFileName+1, pszFileName);

		//
		// Always consider the drive part of the path to be trusted
		//
		int cchDrivePart;
		if (!SkipPathDrivePart(pszMutableFileName, &cchDrivePart, NULL, NULL))
		{
			hr = HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
			goto done;
		}
		if (nFirstUntrustedOffset < cchDrivePart)
			nFirstUntrustedOffset = cchDrivePart;

		//
		// Validate left-to-right, starting after trusted base path
		//
		LPTSTR pszNextComponent = pszMutableFileName + nFirstUntrustedOffset;
		BOOL fMoreComponents = TRUE;
		do
		{
			//
			// Advance pszNextComponent; truncate after current path component
			//
			fMoreComponents = MyPathFindNextComponent(pszNextComponent, TRUE, (LPCTSTR*)&pszNextComponent);
			TCHAR chSave = *(pszNextComponent-1);
			if (fMoreComponents)
			{
				*(pszNextComponent-1) = _T('\0');
			}

			// Get reparse point type of truncated string, and undo the truncation
			DWORD dwReparseType;
			if (FAILED(hr = GetReparsePointType(pszMutableFileName, &dwReparseType)))
				goto done;
			*(pszNextComponent-1) = chSave;

			// Check for forbidden reparse point type, e.g. mounted drive
			if (FAILED(hr = CheckReparsePointPermissions(dwReparseType)))
				goto done;
		}
		while (fMoreComponents);

	} // end BLOCK

done:
	SafeFileFree(pszMutableFileName);

	// Ignore file-not-found errors, if requested in dwSafeFlags
	if (!(dwSafeFlags & SRP_FILE_MUST_EXIST) &&
	    (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
	     hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))
	{
		hr = S_OK;
	}

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafePathCombine [public]
//
//		Combines a path and filename, ensuring exactly one backslash between them.
//		The second "untrusted" half of the path is checked to ensure that it is
//		safe (doesn't contain ".." or ":", or point to existing reparse points).
//
//		File-not-found errors are ignored unless SPC_FILE_MUST_EXIST flag is specified.
//
//		It's ok for the base path and the output buffer to point to the same buffer.
//
//		Returns S_OK if successful, or an appropriate error code if not.
//
HRESULT WINAPI SafePathCombine
	(
		OUT LPTSTR  pszBuf,               // buffer where combined path will be stored
		IN  int     cchBuf,               // size of output buffer, in TCHARs
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	if (!pszBuf || cchBuf <= 0 || !pszTrustedBasePath || !pszUntrustedFileName ||
		(dwSafeFlags & ~(SPC_FILE_MUST_EXIST | SPC_ALLOW_ALTERNATE_STREAM)))
	{
		goto done;  // hr is already E_INVALIDARG
	}

	// BLOCK
	{
		int cchBasePath = lstrlen(pszTrustedBasePath);
		int cchFileName = lstrlen(pszUntrustedFileName);
		if (cchBasePath == 0 || cchFileName == 0)
		{
			goto done;  // hr is already E_INVALIDARG
		}

		// Ensure nothing bogus in the untrusted part of the filename
		if (DoesPathContainDotDot(pszUntrustedFileName))
		{
			hr = ERROR_BAD_PATHNAME;
			goto done;
		}

		if (!(dwSafeFlags & SPC_ALLOW_ALTERNATE_STREAM) &&
			DoesPathContainStreamSyntax(pszUntrustedFileName))
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
			goto done;
		}

		//
		// Ensure room for the "\" that will be inserted.
		//
		int cchInsertSlash = 0;
		if (!IsSlashOrBackslash(pszTrustedBasePath[cchBasePath-1]))
		{
			cchInsertSlash = 1;
		}
		if (cchBasePath + cchInsertSlash + cchFileName >= cchBuf)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
			goto done;
		}

		//
		// Build full path with a backslash between
		//
		if (pszBuf != pszTrustedBasePath)
			StringCchCopy(pszBuf, cchBuf, pszTrustedBasePath);
		int cchUsed = cchBasePath;
		if (cchInsertSlash > 0)
		{
			pszBuf[cchUsed++] = _T('\\');
		}
		StringCchCopy(pszBuf + cchUsed, cchBuf - cchUsed, pszUntrustedFileName);

		//
		// Ensure no junctions or volume mount points in untrusted portion
		//
		DWORD dwReparseFlags = (dwSafeFlags & SPC_FILE_MUST_EXIST) ? SRP_FILE_MUST_EXIST : 0;
		hr = SafeFileCheckForReparsePoint(pszBuf, cchUsed, dwReparseFlags);
	}

done:
	if (FAILED(hr) && pszBuf && cchBuf > 0)
		pszBuf[0] = _T('\0');

	ASSERT(hr != E_INVALIDARG);
	return hr;
}


// SafePathCombineAlloc [public]
//
//		See comments for SafePathCombine. The only difference is that this
//		function allocates a buffer of sufficient size and stores it in the
//		output parameter ppszResult. Caller is responsible for freeing the
//		buffer via SafeFileFree.
//
HRESULT WINAPI SafePathCombineAlloc
	(
		OUT LPTSTR* ppszResult,           // ptr to newly alloc'd buffer stored here
		IN  LPCTSTR pszTrustedBasePath,   // first half of path, all trusted
		IN  LPCTSTR pszUntrustedFileName, // second half of path, not trusted
		IN  DWORD   dwSafeFlags           // zero or more SPC_* flags
	)
{
	HRESULT hr = E_INVALIDARG;

	ASSERT(ppszResult);
	*ppszResult = NULL;

	if (!pszTrustedBasePath || !pszUntrustedFileName)
	{
		goto done; // hr already set to E_INVALIDARG
	}

	// Allocate room for the max possible length (includes room for "\" between parts)
	int cchMaxNeeded = lstrlen(pszTrustedBasePath) + lstrlen(pszUntrustedFileName) + 2;
	LPTSTR pszResult = (LPTSTR)SafeFileMalloc(sizeof(TCHAR) * cchMaxNeeded);
	if (!pszResult)
	{
		hr = E_OUTOFMEMORY;
		goto done;
	}

	hr = SafePathCombine(pszResult, cchMaxNeeded, pszTrustedBasePath, pszUntrustedFileName, dwSafeFlags);
	if (FAILED(hr))
	{
		SafeFileFree(pszResult);
	}
	else
	{
		*ppszResult = pszResult;
	}

done:
	ASSERT(hr != E_INVALIDARG);
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\windows.com\lib\wusafefn\safelib.cpp ===
/**